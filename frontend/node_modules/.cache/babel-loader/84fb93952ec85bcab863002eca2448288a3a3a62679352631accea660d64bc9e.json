{"ast":null,"code":"// src/utils/wordProcessing.js\n\nimport analyzeWord from '../services/etymologyService';\nconst DICTIONARY_API_URL = 'https://api.dictionaryapi.dev/api/v2/entries/en/';\nexport const getWordDetails = async word => {\n  console.log('Starting word lookup for:', word);\n  try {\n    // Step 1: Get dictionary data\n    console.log('Fetching dictionary data...');\n    const dictResponse = await fetch(`${DICTIONARY_API_URL}${word}`);\n    if (!dictResponse.ok) {\n      console.error('Dictionary API error:', dictResponse.status);\n      throw new Error('Failed to fetch from dictionary API');\n    }\n    const dictData = await dictResponse.json();\n    console.log('Dictionary data received:', dictData);\n\n    // Step 2: Get etymology analysis\n    console.log('Getting etymology analysis...');\n    const etymologyData = analyzeWord(word);\n    console.log('Etymology data:', etymologyData);\n\n    // Step 3: Get translations\n    console.log('Getting translations...');\n    const translations = await Promise.all([translateWord(word, 'es'), translateWord(word, 'fr')]);\n    console.log('Translations received:', translations);\n\n    // Combine all data\n    const wordData = {\n      word,\n      definitions: extractDefinitions(dictData),\n      partOfSpeech: extractPartOfSpeech(dictData),\n      phonetics: extractPhonetics(dictData),\n      etymology: etymologyData.etymology,\n      translations: {\n        es: translations[0],\n        fr: translations[1]\n      }\n    };\n    console.log('Final word data:', wordData);\n    return wordData;\n  } catch (error) {\n    console.error('Error in getWordDetails:', error);\n    // Return a basic version with just etymology if dictionary lookup fails\n    const etymologyData = analyzeWord(word);\n    return {\n      word,\n      definitions: [],\n      partOfSpeech: [],\n      phonetics: null,\n      etymology: etymologyData.etymology,\n      translations: {\n        es: null,\n        fr: null\n      }\n    };\n  }\n};\n\n// Helper function to translate words\nconst translateWord = async (word, targetLanguage) => {\n  try {\n    console.log(`Translating \"${word}\" to ${targetLanguage}...`);\n    const response = await fetch('http://localhost:3001/api/translate', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${localStorage.getItem('token')}`\n      },\n      body: JSON.stringify({\n        word,\n        targetLanguage\n      })\n    });\n    if (!response.ok) {\n      throw new Error('Translation failed');\n    }\n    const data = await response.json();\n    return data.translation;\n  } catch (error) {\n    console.error('Translation error:', error);\n    return null;\n  }\n};\n\n// Helper functions to extract dictionary data\nconst extractDefinitions = dictData => {\n  var _dictData$, _dictData$$meanings;\n  if (!Array.isArray(dictData)) return [];\n  return ((_dictData$ = dictData[0]) === null || _dictData$ === void 0 ? void 0 : (_dictData$$meanings = _dictData$.meanings) === null || _dictData$$meanings === void 0 ? void 0 : _dictData$$meanings.flatMap(meaning => meaning.definitions.map(def => ({\n    definition: def.definition,\n    example: def.example,\n    partOfSpeech: meaning.partOfSpeech\n  })))) || [];\n};\nconst extractPartOfSpeech = dictData => {\n  var _dictData$2, _dictData$2$meanings;\n  if (!Array.isArray(dictData)) return [];\n  return [...new Set((_dictData$2 = dictData[0]) === null || _dictData$2 === void 0 ? void 0 : (_dictData$2$meanings = _dictData$2.meanings) === null || _dictData$2$meanings === void 0 ? void 0 : _dictData$2$meanings.map(meaning => meaning.partOfSpeech))] || [];\n};\nconst extractPhonetics = dictData => {\n  var _dictData$3, _dictData$3$phonetics;\n  if (!Array.isArray(dictData)) return null;\n  const phoneticData = (_dictData$3 = dictData[0]) === null || _dictData$3 === void 0 ? void 0 : (_dictData$3$phonetics = _dictData$3.phonetics) === null || _dictData$3$phonetics === void 0 ? void 0 : _dictData$3$phonetics[0];\n  return phoneticData ? {\n    text: phoneticData.text,\n    audio: phoneticData.audio\n  } : null;\n};","map":{"version":3,"names":["analyzeWord","DICTIONARY_API_URL","getWordDetails","word","console","log","dictResponse","fetch","ok","error","status","Error","dictData","json","etymologyData","translations","Promise","all","translateWord","wordData","definitions","extractDefinitions","partOfSpeech","extractPartOfSpeech","phonetics","extractPhonetics","etymology","es","fr","targetLanguage","response","method","headers","localStorage","getItem","body","JSON","stringify","data","translation","_dictData$","_dictData$$meanings","Array","isArray","meanings","flatMap","meaning","map","def","definition","example","_dictData$2","_dictData$2$meanings","Set","_dictData$3","_dictData$3$phonetics","phoneticData","text","audio"],"sources":["/Users/BrooksCole/Documents/reading-community/frontend/src/utils/wordProcessing.js"],"sourcesContent":["// src/utils/wordProcessing.js\n\nimport analyzeWord from '../services/etymologyService';\n\nconst DICTIONARY_API_URL = 'https://api.dictionaryapi.dev/api/v2/entries/en/';\n\nexport const getWordDetails = async (word) => {\n  console.log('Starting word lookup for:', word);\n\n  try {\n    // Step 1: Get dictionary data\n    console.log('Fetching dictionary data...');\n    const dictResponse = await fetch(`${DICTIONARY_API_URL}${word}`);\n    \n    if (!dictResponse.ok) {\n      console.error('Dictionary API error:', dictResponse.status);\n      throw new Error('Failed to fetch from dictionary API');\n    }\n    \n    const dictData = await dictResponse.json();\n    console.log('Dictionary data received:', dictData);\n\n    // Step 2: Get etymology analysis\n    console.log('Getting etymology analysis...');\n    const etymologyData = analyzeWord(word);\n    console.log('Etymology data:', etymologyData);\n\n    // Step 3: Get translations\n    console.log('Getting translations...');\n    const translations = await Promise.all([\n      translateWord(word, 'es'),\n      translateWord(word, 'fr')\n    ]);\n    console.log('Translations received:', translations);\n\n    // Combine all data\n    const wordData = {\n      word,\n      definitions: extractDefinitions(dictData),\n      partOfSpeech: extractPartOfSpeech(dictData),\n      phonetics: extractPhonetics(dictData),\n      etymology: etymologyData.etymology,\n      translations: {\n        es: translations[0],\n        fr: translations[1]\n      }\n    };\n\n    console.log('Final word data:', wordData);\n    return wordData;\n\n  } catch (error) {\n    console.error('Error in getWordDetails:', error);\n    // Return a basic version with just etymology if dictionary lookup fails\n    const etymologyData = analyzeWord(word);\n    return {\n      word,\n      definitions: [],\n      partOfSpeech: [],\n      phonetics: null,\n      etymology: etymologyData.etymology,\n      translations: {\n        es: null,\n        fr: null\n      }\n    };\n  }\n};\n\n// Helper function to translate words\nconst translateWord = async (word, targetLanguage) => {\n  try {\n    console.log(`Translating \"${word}\" to ${targetLanguage}...`);\n    const response = await fetch('http://localhost:3001/api/translate', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${localStorage.getItem('token')}`\n      },\n      body: JSON.stringify({\n        word,\n        targetLanguage\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error('Translation failed');\n    }\n\n    const data = await response.json();\n    return data.translation;\n  } catch (error) {\n    console.error('Translation error:', error);\n    return null;\n  }\n};\n\n// Helper functions to extract dictionary data\nconst extractDefinitions = (dictData) => {\n  if (!Array.isArray(dictData)) return [];\n  \n  return dictData[0]?.meanings?.flatMap(meaning => \n    meaning.definitions.map(def => ({\n      definition: def.definition,\n      example: def.example,\n      partOfSpeech: meaning.partOfSpeech\n    }))\n  ) || [];\n};\n\nconst extractPartOfSpeech = (dictData) => {\n  if (!Array.isArray(dictData)) return [];\n  \n  return [...new Set(\n    dictData[0]?.meanings?.map(meaning => meaning.partOfSpeech)\n  )] || [];\n};\n\nconst extractPhonetics = (dictData) => {\n  if (!Array.isArray(dictData)) return null;\n  \n  const phoneticData = dictData[0]?.phonetics?.[0];\n  return phoneticData ? {\n    text: phoneticData.text,\n    audio: phoneticData.audio\n  } : null;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}