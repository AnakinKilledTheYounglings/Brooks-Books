{"ast":null,"code":"// frontend/src/services/etymologyService.js\n\n// frontend/src/services/etymologyService.js\n\nimport { etymologyAPI } from './etymologyAPI';\nimport { LOCAL_ETYMOLOGY_DATA } from './localEtymologyData'; // We'll create this next\n\nexport class EtymologyService {\n  async getWordEtymology(word) {\n    try {\n      // First try to get data from external API\n      const apiData = await etymologyAPI.getWordEtymology(word);\n      if (apiData) {\n        return this.formatApiData(apiData);\n      }\n\n      // Fall back to local data if API fails or returns no data\n      return this.getLocalEtymology(word);\n    } catch (error) {\n      console.error('Etymology service error:', error);\n      return this.getLocalEtymology(word);\n    }\n  }\n  formatApiData(apiData) {\n    // This will convert external API data to match your expected format\n    return {\n      word: apiData.word,\n      pie: apiData.protoIndoEuropeanRoot,\n      evolution: this.formatEvolutionData(apiData.evolution),\n      modernCognates: apiData.cognates,\n      semanticDevelopment: apiData.meaningDevelopment\n    };\n  }\n  getLocalEtymology(word) {\n    // Your existing local etymology logic\n    return {\n      word,\n      pie: LOCAL_ETYMOLOGY_DATA.findPIERoot(word),\n      evolution: LOCAL_ETYMOLOGY_DATA.getEvolution(word),\n      modernCognates: LOCAL_ETYMOLOGY_DATA.getCognates(word),\n      semanticDevelopment: LOCAL_ETYMOLOGY_DATA.getSemanticDevelopment(word)\n    };\n  }\n  formatEvolutionData(evolution) {\n    // Convert API evolution data to your format\n    return (evolution === null || evolution === void 0 ? void 0 : evolution.map(stage => ({\n      period: stage.timePeriod,\n      years: stage.dateRange,\n      form: stage.wordForm,\n      changes: stage.soundChanges\n    }))) || [];\n  }\n}\nexport const etymologyService = new EtymologyService();\nconst PROTO_INDO_EUROPEAN_ROOTS = {\n  '*bher-': {\n    meaning: 'to carry, bring',\n    descendants: {\n      latin: ['ferre (to bear)', 'fertile', 'transfer'],\n      greek: ['pherein (to carry)', 'phosphorus (light-bearing)'],\n      germanic: ['bear', 'birth'],\n      sanskrit: ['bharati (he carries)']\n    }\n  },\n  '*weid-': {\n    meaning: 'to see, to know',\n    descendants: {\n      latin: ['videre (to see)', 'vision', 'video'],\n      greek: ['idein (to see)', 'idea'],\n      germanic: ['wit', 'wise'],\n      sanskrit: ['veda (knowledge)']\n    }\n  },\n  '*dhē-': {\n    meaning: 'to set, put, place',\n    descendants: {\n      latin: ['facere (to do)', 'fact'],\n      greek: ['thesis (placing)', 'theme'],\n      germanic: ['do', 'deed'],\n      sanskrit: ['dhātu (element)']\n    }\n  },\n  '*leuk-': {\n    meaning: 'light, brightness',\n    descendants: {\n      latin: ['lux (light)', 'lucid', 'illuminate'],\n      greek: ['leukos (white)', 'lychnos (lamp)'],\n      germanic: ['light', 'lightning'],\n      sanskrit: ['roca (bright)']\n    }\n  }\n};\nconst LANGUAGE_FAMILIES = {\n  GERMANIC: {\n    timeline: [{\n      period: 'Proto-Germanic',\n      years: '500 BCE-200 CE'\n    }, {\n      period: 'West Germanic',\n      years: '200-500 CE'\n    }, {\n      period: 'Old English',\n      years: '500-1100 CE'\n    }, {\n      period: 'Middle English',\n      years: '1100-1500 CE'\n    }, {\n      period: 'Early Modern English',\n      years: '1500-1800 CE'\n    }, {\n      period: 'Modern English',\n      years: '1800-present'\n    }],\n    soundChanges: {\n      'Proto-Germanic': 'Grimm\\'s Law consonant shifts',\n      'West Germanic': 'Loss of word-final -z',\n      'Old English': 'I-mutation and breaking of vowels',\n      'Middle English': 'Great Vowel Shift begins',\n      'Early Modern English': 'Great Vowel Shift completes'\n    }\n  },\n  ROMANCE: {\n    timeline: [{\n      period: 'Classical Latin',\n      years: '75 BCE-3rd c. CE'\n    }, {\n      period: 'Vulgar Latin',\n      years: '3rd-8th c. CE'\n    }, {\n      period: 'Old French',\n      years: '842-1400 CE'\n    }, {\n      period: 'Middle French',\n      years: '1400-1600 CE'\n    }, {\n      period: 'Modern French',\n      years: '1600-present'\n    }],\n    soundChanges: {\n      'Vulgar Latin': 'Loss of final consonants',\n      'Old French': 'Lenition of intervocalic consonants',\n      'Middle French': 'Loss of final -e in many words'\n    }\n  }\n};\nconst SEMANTIC_DEVELOPMENTS = {\n  'nice': ['From Latin nescius \"ignorant\"', 'Old French nice \"silly, simple\"', 'Middle English \"foolish, stupid\"', 'Gradually shifted to \"pleasing, agreeable\"', 'Modern English \"pleasant, kind\"'],\n  'silly': ['Old English gesælig \"happy, fortunate, blessed\"', 'Middle English \"innocent, harmless, pitiable\"', 'Later \"weak, feeble, frail\"', 'Finally \"foolish, simple, ridiculous\"']\n};\nconst analyzeWord = word => {\n  // Convert word to lowercase for matching\n  const wordLower = word.toLowerCase();\n\n  // Try to find PIE root\n  let pieRoot = null;\n  for (const [root, info] of Object.entries(PROTO_INDO_EUROPEAN_ROOTS)) {\n    if (Object.values(info.descendants).flat().some(desc => desc.toLowerCase().includes(wordLower) || wordLower.includes(desc.toLowerCase().split(' ')[0]))) {\n      pieRoot = {\n        root,\n        ...info\n      };\n      break;\n    }\n  }\n\n  // Determine language family and evolution path\n  let evolution = [];\n  let modernCognates = {};\n  let semanticDevelopment = null;\n\n  // Check for Germanic words\n  if (isGermanicWord(wordLower)) {\n    evolution = buildEvolutionPath(wordLower, 'GERMANIC');\n    modernCognates = getGermanicCognates(wordLower);\n  }\n  // Check for Romance words\n  else if (isRomanceWord(wordLower)) {\n    evolution = buildEvolutionPath(wordLower, 'ROMANCE');\n    modernCognates = getRomanceCognates(wordLower);\n  }\n\n  // Check for semantic development history\n  if (SEMANTIC_DEVELOPMENTS[wordLower]) {\n    semanticDevelopment = SEMANTIC_DEVELOPMENTS[wordLower];\n  }\n  return {\n    word,\n    pie: pieRoot,\n    evolution,\n    modernCognates,\n    semanticDevelopment\n  };\n};\n\n// Helper functions\nconst isGermanicWord = word => {\n  // Basic check for Germanic origin (can be enhanced)\n  const germanicPatterns = ['th', 'gh', 'ght', 'ing', 'ness', 'ship', 'hood'];\n  return germanicPatterns.some(pattern => word.includes(pattern));\n};\nconst isRomanceWord = word => {\n  // Basic check for Romance origin (can be enhanced)\n  const romancePatterns = ['tion', 'sion', 'ment', 'ance', 'ence', 'ify', 'ous'];\n  return romancePatterns.some(pattern => word.includes(pattern));\n};\nconst buildEvolutionPath = (word, family) => {\n  const timeline = LANGUAGE_FAMILIES[family].timeline;\n  const soundChanges = LANGUAGE_FAMILIES[family].soundChanges;\n  return timeline.map(stage => ({\n    ...stage,\n    changes: soundChanges[stage.period],\n    form: getHistoricalForm(word, stage.period, family)\n  }));\n};\nconst getHistoricalForm = (word, period, family) => {\n  // This is a simplified example - in a real implementation,\n  // you would have a database of historical forms\n  if (family === 'GERMANIC') {\n    var _historicalForms$word;\n    const historicalForms = {\n      'light': {\n        'Proto-Germanic': '*leuhtą',\n        'West Germanic': '*lioht',\n        'Old English': 'lēoht',\n        'Middle English': 'light',\n        'Early Modern English': 'light',\n        'Modern English': 'light'\n      }\n      // Add more words...\n    };\n    return ((_historicalForms$word = historicalForms[word]) === null || _historicalForms$word === void 0 ? void 0 : _historicalForms$word[period]) || word;\n  }\n  return word; // Fallback\n};\nconst getGermanicCognates = word => {\n  // Example cognates - in a real implementation,\n  // you would have a comprehensive database\n  const cognates = {\n    'light': {\n      'German': 'Licht',\n      'Dutch': 'licht',\n      'Swedish': 'ljus',\n      'Danish': 'lys'\n    }\n    // Add more words...\n  };\n  return cognates[word] || {};\n};\nconst getRomanceCognates = word => {\n  // Example cognates\n  const cognates = {\n    'nature': {\n      'French': 'nature',\n      'Spanish': 'naturaleza',\n      'Italian': 'natura',\n      'Portuguese': 'natureza'\n    }\n    // Add more words...\n  };\n  return cognates[word] || {};\n};\nexport { analyzeWord, PROTO_INDO_EUROPEAN_ROOTS, LANGUAGE_FAMILIES };","map":{"version":3,"names":["etymologyAPI","LOCAL_ETYMOLOGY_DATA","EtymologyService","getWordEtymology","word","apiData","formatApiData","getLocalEtymology","error","console","pie","protoIndoEuropeanRoot","evolution","formatEvolutionData","modernCognates","cognates","semanticDevelopment","meaningDevelopment","findPIERoot","getEvolution","getCognates","getSemanticDevelopment","map","stage","period","timePeriod","years","dateRange","form","wordForm","changes","soundChanges","etymologyService","PROTO_INDO_EUROPEAN_ROOTS","meaning","descendants","latin","greek","germanic","sanskrit","LANGUAGE_FAMILIES","GERMANIC","timeline","ROMANCE","SEMANTIC_DEVELOPMENTS","analyzeWord","wordLower","toLowerCase","pieRoot","root","info","Object","entries","values","flat","some","desc","includes","split","isGermanicWord","buildEvolutionPath","getGermanicCognates","isRomanceWord","getRomanceCognates","germanicPatterns","pattern","romancePatterns","family","getHistoricalForm","_historicalForms$word","historicalForms"],"sources":["/Users/BrooksCole/Documents/reading-community/frontend/src/services/etymologyService.js"],"sourcesContent":["// frontend/src/services/etymologyService.js\n\n// frontend/src/services/etymologyService.js\n\nimport { etymologyAPI } from './etymologyAPI';\nimport { LOCAL_ETYMOLOGY_DATA } from './localEtymologyData'; // We'll create this next\n\nexport class EtymologyService {\n  async getWordEtymology(word) {\n    try {\n      // First try to get data from external API\n      const apiData = await etymologyAPI.getWordEtymology(word);\n      if (apiData) {\n        return this.formatApiData(apiData);\n      }\n\n      // Fall back to local data if API fails or returns no data\n      return this.getLocalEtymology(word);\n    } catch (error) {\n      console.error('Etymology service error:', error);\n      return this.getLocalEtymology(word);\n    }\n  }\n\n  formatApiData(apiData) {\n    // This will convert external API data to match your expected format\n    return {\n      word: apiData.word,\n      pie: apiData.protoIndoEuropeanRoot,\n      evolution: this.formatEvolutionData(apiData.evolution),\n      modernCognates: apiData.cognates,\n      semanticDevelopment: apiData.meaningDevelopment\n    };\n  }\n\n  getLocalEtymology(word) {\n    // Your existing local etymology logic\n    return {\n      word,\n      pie: LOCAL_ETYMOLOGY_DATA.findPIERoot(word),\n      evolution: LOCAL_ETYMOLOGY_DATA.getEvolution(word),\n      modernCognates: LOCAL_ETYMOLOGY_DATA.getCognates(word),\n      semanticDevelopment: LOCAL_ETYMOLOGY_DATA.getSemanticDevelopment(word)\n    };\n  }\n\n  formatEvolutionData(evolution) {\n    // Convert API evolution data to your format\n    return evolution?.map(stage => ({\n      period: stage.timePeriod,\n      years: stage.dateRange,\n      form: stage.wordForm,\n      changes: stage.soundChanges\n    })) || [];\n  }\n}\n\nexport const etymologyService = new EtymologyService();\n\n\n\nconst PROTO_INDO_EUROPEAN_ROOTS = {\n  '*bher-': {\n    meaning: 'to carry, bring',\n    descendants: {\n      latin: ['ferre (to bear)', 'fertile', 'transfer'],\n      greek: ['pherein (to carry)', 'phosphorus (light-bearing)'],\n      germanic: ['bear', 'birth'],\n      sanskrit: ['bharati (he carries)']\n    }\n  },\n  '*weid-': {\n    meaning: 'to see, to know',\n    descendants: {\n      latin: ['videre (to see)', 'vision', 'video'],\n      greek: ['idein (to see)', 'idea'],\n      germanic: ['wit', 'wise'],\n      sanskrit: ['veda (knowledge)']\n    }\n  },\n  '*dhē-': {\n    meaning: 'to set, put, place',\n    descendants: {\n      latin: ['facere (to do)', 'fact'],\n      greek: ['thesis (placing)', 'theme'],\n      germanic: ['do', 'deed'],\n      sanskrit: ['dhātu (element)']\n    }\n  },\n  '*leuk-': {\n    meaning: 'light, brightness',\n    descendants: {\n      latin: ['lux (light)', 'lucid', 'illuminate'],\n      greek: ['leukos (white)', 'lychnos (lamp)'],\n      germanic: ['light', 'lightning'],\n      sanskrit: ['roca (bright)']\n    }\n  }\n};\n\nconst LANGUAGE_FAMILIES = {\n  GERMANIC: {\n    timeline: [\n      { period: 'Proto-Germanic', years: '500 BCE-200 CE' },\n      { period: 'West Germanic', years: '200-500 CE' },\n      { period: 'Old English', years: '500-1100 CE' },\n      { period: 'Middle English', years: '1100-1500 CE' },\n      { period: 'Early Modern English', years: '1500-1800 CE' },\n      { period: 'Modern English', years: '1800-present' }\n    ],\n    soundChanges: {\n      'Proto-Germanic': 'Grimm\\'s Law consonant shifts',\n      'West Germanic': 'Loss of word-final -z',\n      'Old English': 'I-mutation and breaking of vowels',\n      'Middle English': 'Great Vowel Shift begins',\n      'Early Modern English': 'Great Vowel Shift completes'\n    }\n  },\n  ROMANCE: {\n    timeline: [\n      { period: 'Classical Latin', years: '75 BCE-3rd c. CE' },\n      { period: 'Vulgar Latin', years: '3rd-8th c. CE' },\n      { period: 'Old French', years: '842-1400 CE' },\n      { period: 'Middle French', years: '1400-1600 CE' },\n      { period: 'Modern French', years: '1600-present' }\n    ],\n    soundChanges: {\n      'Vulgar Latin': 'Loss of final consonants',\n      'Old French': 'Lenition of intervocalic consonants',\n      'Middle French': 'Loss of final -e in many words'\n    }\n  }\n};\n\nconst SEMANTIC_DEVELOPMENTS = {\n  'nice': [\n    'From Latin nescius \"ignorant\"',\n    'Old French nice \"silly, simple\"',\n    'Middle English \"foolish, stupid\"',\n    'Gradually shifted to \"pleasing, agreeable\"',\n    'Modern English \"pleasant, kind\"'\n  ],\n  'silly': [\n    'Old English gesælig \"happy, fortunate, blessed\"',\n    'Middle English \"innocent, harmless, pitiable\"',\n    'Later \"weak, feeble, frail\"',\n    'Finally \"foolish, simple, ridiculous\"'\n  ]\n};\n\nconst analyzeWord = (word) => {\n  // Convert word to lowercase for matching\n  const wordLower = word.toLowerCase();\n  \n  // Try to find PIE root\n  let pieRoot = null;\n  for (const [root, info] of Object.entries(PROTO_INDO_EUROPEAN_ROOTS)) {\n    if (Object.values(info.descendants).flat().some(desc => \n      desc.toLowerCase().includes(wordLower) ||\n      wordLower.includes(desc.toLowerCase().split(' ')[0])\n    )) {\n      pieRoot = { root, ...info };\n      break;\n    }\n  }\n\n  // Determine language family and evolution path\n  let evolution = [];\n  let modernCognates = {};\n  let semanticDevelopment = null;\n\n  // Check for Germanic words\n  if (isGermanicWord(wordLower)) {\n    evolution = buildEvolutionPath(wordLower, 'GERMANIC');\n    modernCognates = getGermanicCognates(wordLower);\n  } \n  // Check for Romance words\n  else if (isRomanceWord(wordLower)) {\n    evolution = buildEvolutionPath(wordLower, 'ROMANCE');\n    modernCognates = getRomanceCognates(wordLower);\n  }\n\n  // Check for semantic development history\n  if (SEMANTIC_DEVELOPMENTS[wordLower]) {\n    semanticDevelopment = SEMANTIC_DEVELOPMENTS[wordLower];\n  }\n\n  return {\n    word,\n    pie: pieRoot,\n    evolution,\n    modernCognates,\n    semanticDevelopment\n  };\n};\n\n// Helper functions\nconst isGermanicWord = (word) => {\n  // Basic check for Germanic origin (can be enhanced)\n  const germanicPatterns = [\n    'th', 'gh', 'ght', 'ing', 'ness', 'ship', 'hood'\n  ];\n  return germanicPatterns.some(pattern => word.includes(pattern));\n};\n\nconst isRomanceWord = (word) => {\n  // Basic check for Romance origin (can be enhanced)\n  const romancePatterns = [\n    'tion', 'sion', 'ment', 'ance', 'ence', 'ify', 'ous'\n  ];\n  return romancePatterns.some(pattern => word.includes(pattern));\n};\n\nconst buildEvolutionPath = (word, family) => {\n  const timeline = LANGUAGE_FAMILIES[family].timeline;\n  const soundChanges = LANGUAGE_FAMILIES[family].soundChanges;\n  \n  return timeline.map(stage => ({\n    ...stage,\n    changes: soundChanges[stage.period],\n    form: getHistoricalForm(word, stage.period, family)\n  }));\n};\n\nconst getHistoricalForm = (word, period, family) => {\n  // This is a simplified example - in a real implementation,\n  // you would have a database of historical forms\n  if (family === 'GERMANIC') {\n    const historicalForms = {\n      'light': {\n        'Proto-Germanic': '*leuhtą',\n        'West Germanic': '*lioht',\n        'Old English': 'lēoht',\n        'Middle English': 'light',\n        'Early Modern English': 'light',\n        'Modern English': 'light'\n      }\n      // Add more words...\n    };\n    return historicalForms[word]?.[period] || word;\n  }\n  return word; // Fallback\n};\n\nconst getGermanicCognates = (word) => {\n  // Example cognates - in a real implementation,\n  // you would have a comprehensive database\n  const cognates = {\n    'light': {\n      'German': 'Licht',\n      'Dutch': 'licht',\n      'Swedish': 'ljus',\n      'Danish': 'lys'\n    }\n    // Add more words...\n  };\n  return cognates[word] || {};\n};\n\nconst getRomanceCognates = (word) => {\n  // Example cognates\n  const cognates = {\n    'nature': {\n      'French': 'nature',\n      'Spanish': 'naturaleza',\n      'Italian': 'natura',\n      'Portuguese': 'natureza'\n    }\n    // Add more words...\n  };\n  return cognates[word] || {};\n};\n\nexport {\n  analyzeWord,\n  PROTO_INDO_EUROPEAN_ROOTS,\n  LANGUAGE_FAMILIES\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}