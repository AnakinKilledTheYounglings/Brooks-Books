{"ast":null,"code":"// // frontend/src/services/etymologyService.js\n\n// const LATIN_ROOTS = {\n//   'duc/duct': 'to lead',\n//   'fac/fact': 'to make or do',\n//   'mit/miss': 'to send',\n//   'port': 'to carry',\n//   'scrib/script': 'to write',\n//   'spec/spect': 'to look',\n//   'ten/tain': 'to hold',\n//   'vid/vis': 'to see',\n//   'voc/vok': 'to call',\n//   'am': 'love',\n//   'audi': 'to hear',\n//   'bene': 'good, well',\n//   'corp': 'body',\n//   'dic/dict': 'to say',\n//   'form': 'shape',\n//   'geo': 'earth',\n//   'graph': 'to write',\n//   'log/logy': 'study of',\n//   'multi': 'many',\n//   'phil': 'love'\n// };\n\n// const GREEK_ROOTS = {\n//   'auto': 'self',\n//   'bio': 'life',\n//   'chron': 'time',\n//   'demo': 'people',\n//   'hydro': 'water',\n//   'micro': 'small',\n//   'phon': 'sound',\n//   'photo': 'light',\n//   'tele': 'distant',\n//   'therm': 'heat'\n// };\n\n// const COMMON_PREFIXES = {\n//   'un': { meaning: 'not', origin: 'Old English' },\n//   're': { meaning: 'again', origin: 'Latin' },\n//   'dis': { meaning: 'not, opposite of', origin: 'Latin' },\n//   'pre': { meaning: 'before', origin: 'Latin' },\n//   'post': { meaning: 'after', origin: 'Latin' },\n//   'inter': { meaning: 'between', origin: 'Latin' },\n//   'super': { meaning: 'above, beyond', origin: 'Latin' },\n//   'sub': { meaning: 'under', origin: 'Latin' },\n//   'trans': { meaning: 'across', origin: 'Latin' },\n//   'anti': { meaning: 'against', origin: 'Greek' }\n// };\n\n// const COMMON_SUFFIXES = {\n//   'able/ible': { meaning: 'capable of being', origin: 'Latin' },\n//   'tion/sion': { meaning: 'state or quality', origin: 'Latin' },\n//   'ment': { meaning: 'state of', origin: 'Latin' },\n//   'ness': { meaning: 'state of being', origin: 'Old English' },\n//   'ity': { meaning: 'state or quality', origin: 'Latin' },\n//   'ize': { meaning: 'to make or become', origin: 'Greek' },\n//   'ist': { meaning: 'one who', origin: 'Greek' },\n//   'ology': { meaning: 'study of', origin: 'Greek' },\n//   'phobia': { meaning: 'fear of', origin: 'Greek' },\n//   'ism': { meaning: 'doctrine or belief', origin: 'Greek' }\n// };\n\n// const findRootInWord = (word) => {\n//   word = word.toLowerCase();\n\n//   // Check Latin roots\n//   for (const [root, meaning] of Object.entries(LATIN_ROOTS)) {\n//     if (word.includes(root.split('/')[0])) {\n//       return { root, meaning, origin: 'Latin' };\n//     }\n//   }\n\n//   // Check Greek roots\n//   for (const [root, meaning] of Object.entries(GREEK_ROOTS)) {\n//     if (word.includes(root)) {\n//       return { root, meaning, origin: 'Greek' };\n//     }\n//   }\n\n//   return null;\n// };\n\n// const findAffixes = (word) => {\n//   word = word.toLowerCase();\n//   const affixes = [];\n\n//   // Check prefixes\n//   for (const [prefix, info] of Object.entries(COMMON_PREFIXES)) {\n//     if (word.startsWith(prefix)) {\n//       affixes.push({ \n//         type: 'prefix', \n//         affix: prefix, \n//         ...info \n//       });\n//     }\n//   }\n\n//   // Check suffixes\n//   for (const [suffix, info] of Object.entries(COMMON_SUFFIXES)) {\n//     const suffixVariants = suffix.split('/');\n//     if (suffixVariants.some(v => word.endsWith(v))) {\n//       affixes.push({ \n//         type: 'suffix', \n//         affix: suffix, \n//         ...info \n//       });\n//     }\n//   }\n\n//   return affixes;\n// };\n\n// const generateWordEvolution = (root, word) => {\n//   const evolution = [];\n\n//   if (root.origin === 'Latin') {\n//     evolution.push({\n//       period: 'Classical Latin',\n//       form: root.root.split('/')[0] + 'us'\n//     });\n//     evolution.push({\n//       period: 'Medieval Latin',\n//       form: root.root.split('/')[0] + 'um'\n//     });\n//     evolution.push({\n//       period: 'Old French',\n//       form: word.slice(0, -1) + 'e'\n//     });\n//   } else if (root.origin === 'Greek') {\n//     evolution.push({\n//       period: 'Ancient Greek',\n//       form: root.root + 'os'\n//     });\n//     evolution.push({\n//       period: 'Medieval Greek',\n//       form: root.root + 'us'\n//     });\n//   }\n\n//   evolution.push({\n//     period: 'Modern English',\n//     form: word\n//   });\n\n//   return evolution;\n// };\n\n// const analyzeWord = (word) => {\n//   const root = findRootInWord(word);\n//   const affixes = findAffixes(word);\n//   let meaning = '';\n//   let etymology = {};\n\n//   if (root) {\n//     meaning = root.meaning;\n//     etymology = {\n//       root: root.root,\n//       originLanguage: root.origin,\n//       meaning: root.meaning,\n//       evolution: generateWordEvolution(root, word)\n//     };\n\n//     // Add affix information to meaning\n//     affixes.forEach(affix => {\n//       if (affix.type === 'prefix') {\n//         meaning = `${affix.meaning} + ${meaning}`;\n//       } else {\n//         meaning = `${meaning} + ${affix.meaning}`;\n//       }\n//     });\n//   } else {\n//     // If no root found, use the first affix as the base\n//     const primaryAffix = affixes[0];\n//     if (primaryAffix) {\n//       etymology = {\n//         root: primaryAffix.affix,\n//         originLanguage: primaryAffix.origin,\n//         meaning: primaryAffix.meaning,\n//         evolution: [{\n//           period: 'Modern English',\n//           form: word\n//         }]\n//       };\n//     } else {\n//       // Default case when no etymology information is found\n//       etymology = {\n//         root: word,\n//         originLanguage: 'Unknown',\n//         meaning: 'No known etymology',\n//         evolution: [{\n//           period: 'Modern English',\n//           form: word\n//         }]\n//       };\n//     }\n//   }\n\n//   return {\n//     etymology,\n//     affixes\n//   };\n// };\n\n// export default analyzeWord;\n\nconst LANGUAGE_ROOTS = {\n  LATIN: {\n    name: 'Latin',\n    period: 'Classical',\n    roots: {\n      'duc/duct': {\n        meaning: 'to lead',\n        derivatives: ['conduct', 'deduce', 'produce']\n      },\n      'mit/miss': {\n        meaning: 'to send',\n        derivatives: ['submit', 'mission', 'transmit']\n      },\n      'port': {\n        meaning: 'to carry',\n        derivatives: ['transport', 'portable', 'export']\n      },\n      'spec/spect': {\n        meaning: 'to look',\n        derivatives: ['inspect', 'spectacle', 'perspective']\n      },\n      'vid/vis': {\n        meaning: 'to see',\n        derivatives: ['video', 'vision', 'visible']\n      }\n      // ... existing Latin roots\n    }\n  },\n  GREEK: {\n    name: 'Ancient Greek',\n    period: 'Classical',\n    roots: {\n      'bio': {\n        meaning: 'life',\n        derivatives: ['biology', 'biography', 'symbiotic']\n      },\n      'phil': {\n        meaning: 'love',\n        derivatives: ['philosophy', 'philanthropy', 'philology']\n      },\n      'logos': {\n        meaning: 'study/word',\n        derivatives: ['psychology', 'biology', 'mythology']\n      },\n      'demos': {\n        meaning: 'people',\n        derivatives: ['democracy', 'demographic', 'epidemic']\n      }\n      // ... more Greek roots\n    }\n  },\n  SANSKRIT: {\n    name: 'Sanskrit',\n    period: 'Ancient',\n    roots: {\n      'guru': {\n        meaning: 'teacher',\n        derivatives: ['guru']\n      },\n      'yoga': {\n        meaning: 'union',\n        derivatives: ['yoga', 'yogic']\n      },\n      'karma': {\n        meaning: 'action/deed',\n        derivatives: ['karma', 'karmic']\n      },\n      'man/manas': {\n        meaning: 'to think',\n        derivatives: ['mantra', 'mental']\n      }\n    }\n  },\n  GERMANIC: {\n    name: 'Proto-Germanic',\n    period: 'Ancient',\n    roots: {\n      'ber': {\n        meaning: 'to carry',\n        derivatives: ['bear', 'burden']\n      },\n      'kom': {\n        meaning: 'to come',\n        derivatives: ['come', 'become', 'welcome']\n      },\n      'seg': {\n        meaning: 'to say',\n        derivatives: ['say', 'saga']\n      },\n      'wer': {\n        meaning: 'man/person',\n        derivatives: ['werewolf', 'world']\n      }\n    }\n  }\n};\nconst EVOLUTION_PATHS = {\n  ROMANCE: {\n    path: ['Latin', 'Vulgar Latin', 'Old French/Spanish/Italian', 'Modern Romance'],\n    examples: {\n      'porta': {\n        'Latin': 'porta',\n        'Vulgar Latin': 'porta',\n        'Old French': 'porte',\n        'Modern French': 'porte',\n        'Spanish': 'puerta',\n        'Italian': 'porta',\n        'Portuguese': 'porta'\n      }\n    }\n  },\n  GERMANIC: {\n    path: ['Proto-Germanic', 'Old English/Old High German', 'Middle English/Middle High German', 'Modern Germanic'],\n    examples: {\n      'water': {\n        'Proto-Germanic': '*watōr',\n        'Old English': 'wæter',\n        'Middle English': 'water',\n        'Modern English': 'water',\n        'German': 'Wasser',\n        'Dutch': 'water'\n      }\n    }\n  }\n};\nexport const analyzeWord = word => {\n  // Search through all language roots\n  for (const [rootFamily, data] of Object.entries(LANGUAGE_ROOTS)) {\n    for (const [root, info] of Object.entries(data.roots)) {\n      if (word.toLowerCase().includes(root.split('/')[0].toLowerCase())) {\n        return {\n          root: root,\n          origin: data.name,\n          period: data.period,\n          meaning: info.meaning,\n          derivatives: info.derivatives,\n          evolutionPath: findEvolutionPath(rootFamily, word)\n        };\n      }\n    }\n  }\n  return null;\n};\nconst findEvolutionPath = (rootFamily, word) => {\n  // Find relevant evolution path based on root family\n  const path = rootFamily === 'LATIN' ? EVOLUTION_PATHS.ROMANCE : rootFamily === 'GERMANIC' ? EVOLUTION_PATHS.GERMANIC : null;\n  if (!path) return null;\n  return {\n    stages: path.path,\n    examples: path.examples[word] || null\n  };\n};\nexport default {\n  analyzeWord,\n  LANGUAGE_ROOTS,\n  EVOLUTION_PATHS\n};","map":{"version":3,"names":["LANGUAGE_ROOTS","LATIN","name","period","roots","meaning","derivatives","GREEK","SANSKRIT","GERMANIC","EVOLUTION_PATHS","ROMANCE","path","examples","analyzeWord","word","rootFamily","data","Object","entries","root","info","toLowerCase","includes","split","origin","evolutionPath","findEvolutionPath","stages"],"sources":["/Users/BrooksCole/Documents/reading-community/frontend/src/services/etymologyService.js"],"sourcesContent":["// // frontend/src/services/etymologyService.js\n\n// const LATIN_ROOTS = {\n//   'duc/duct': 'to lead',\n//   'fac/fact': 'to make or do',\n//   'mit/miss': 'to send',\n//   'port': 'to carry',\n//   'scrib/script': 'to write',\n//   'spec/spect': 'to look',\n//   'ten/tain': 'to hold',\n//   'vid/vis': 'to see',\n//   'voc/vok': 'to call',\n//   'am': 'love',\n//   'audi': 'to hear',\n//   'bene': 'good, well',\n//   'corp': 'body',\n//   'dic/dict': 'to say',\n//   'form': 'shape',\n//   'geo': 'earth',\n//   'graph': 'to write',\n//   'log/logy': 'study of',\n//   'multi': 'many',\n//   'phil': 'love'\n// };\n\n// const GREEK_ROOTS = {\n//   'auto': 'self',\n//   'bio': 'life',\n//   'chron': 'time',\n//   'demo': 'people',\n//   'hydro': 'water',\n//   'micro': 'small',\n//   'phon': 'sound',\n//   'photo': 'light',\n//   'tele': 'distant',\n//   'therm': 'heat'\n// };\n\n// const COMMON_PREFIXES = {\n//   'un': { meaning: 'not', origin: 'Old English' },\n//   're': { meaning: 'again', origin: 'Latin' },\n//   'dis': { meaning: 'not, opposite of', origin: 'Latin' },\n//   'pre': { meaning: 'before', origin: 'Latin' },\n//   'post': { meaning: 'after', origin: 'Latin' },\n//   'inter': { meaning: 'between', origin: 'Latin' },\n//   'super': { meaning: 'above, beyond', origin: 'Latin' },\n//   'sub': { meaning: 'under', origin: 'Latin' },\n//   'trans': { meaning: 'across', origin: 'Latin' },\n//   'anti': { meaning: 'against', origin: 'Greek' }\n// };\n\n// const COMMON_SUFFIXES = {\n//   'able/ible': { meaning: 'capable of being', origin: 'Latin' },\n//   'tion/sion': { meaning: 'state or quality', origin: 'Latin' },\n//   'ment': { meaning: 'state of', origin: 'Latin' },\n//   'ness': { meaning: 'state of being', origin: 'Old English' },\n//   'ity': { meaning: 'state or quality', origin: 'Latin' },\n//   'ize': { meaning: 'to make or become', origin: 'Greek' },\n//   'ist': { meaning: 'one who', origin: 'Greek' },\n//   'ology': { meaning: 'study of', origin: 'Greek' },\n//   'phobia': { meaning: 'fear of', origin: 'Greek' },\n//   'ism': { meaning: 'doctrine or belief', origin: 'Greek' }\n// };\n\n// const findRootInWord = (word) => {\n//   word = word.toLowerCase();\n  \n//   // Check Latin roots\n//   for (const [root, meaning] of Object.entries(LATIN_ROOTS)) {\n//     if (word.includes(root.split('/')[0])) {\n//       return { root, meaning, origin: 'Latin' };\n//     }\n//   }\n  \n//   // Check Greek roots\n//   for (const [root, meaning] of Object.entries(GREEK_ROOTS)) {\n//     if (word.includes(root)) {\n//       return { root, meaning, origin: 'Greek' };\n//     }\n//   }\n  \n//   return null;\n// };\n\n// const findAffixes = (word) => {\n//   word = word.toLowerCase();\n//   const affixes = [];\n  \n//   // Check prefixes\n//   for (const [prefix, info] of Object.entries(COMMON_PREFIXES)) {\n//     if (word.startsWith(prefix)) {\n//       affixes.push({ \n//         type: 'prefix', \n//         affix: prefix, \n//         ...info \n//       });\n//     }\n//   }\n  \n//   // Check suffixes\n//   for (const [suffix, info] of Object.entries(COMMON_SUFFIXES)) {\n//     const suffixVariants = suffix.split('/');\n//     if (suffixVariants.some(v => word.endsWith(v))) {\n//       affixes.push({ \n//         type: 'suffix', \n//         affix: suffix, \n//         ...info \n//       });\n//     }\n//   }\n  \n//   return affixes;\n// };\n\n// const generateWordEvolution = (root, word) => {\n//   const evolution = [];\n  \n//   if (root.origin === 'Latin') {\n//     evolution.push({\n//       period: 'Classical Latin',\n//       form: root.root.split('/')[0] + 'us'\n//     });\n//     evolution.push({\n//       period: 'Medieval Latin',\n//       form: root.root.split('/')[0] + 'um'\n//     });\n//     evolution.push({\n//       period: 'Old French',\n//       form: word.slice(0, -1) + 'e'\n//     });\n//   } else if (root.origin === 'Greek') {\n//     evolution.push({\n//       period: 'Ancient Greek',\n//       form: root.root + 'os'\n//     });\n//     evolution.push({\n//       period: 'Medieval Greek',\n//       form: root.root + 'us'\n//     });\n//   }\n  \n//   evolution.push({\n//     period: 'Modern English',\n//     form: word\n//   });\n  \n//   return evolution;\n// };\n\n// const analyzeWord = (word) => {\n//   const root = findRootInWord(word);\n//   const affixes = findAffixes(word);\n//   let meaning = '';\n//   let etymology = {};\n  \n//   if (root) {\n//     meaning = root.meaning;\n//     etymology = {\n//       root: root.root,\n//       originLanguage: root.origin,\n//       meaning: root.meaning,\n//       evolution: generateWordEvolution(root, word)\n//     };\n    \n//     // Add affix information to meaning\n//     affixes.forEach(affix => {\n//       if (affix.type === 'prefix') {\n//         meaning = `${affix.meaning} + ${meaning}`;\n//       } else {\n//         meaning = `${meaning} + ${affix.meaning}`;\n//       }\n//     });\n//   } else {\n//     // If no root found, use the first affix as the base\n//     const primaryAffix = affixes[0];\n//     if (primaryAffix) {\n//       etymology = {\n//         root: primaryAffix.affix,\n//         originLanguage: primaryAffix.origin,\n//         meaning: primaryAffix.meaning,\n//         evolution: [{\n//           period: 'Modern English',\n//           form: word\n//         }]\n//       };\n//     } else {\n//       // Default case when no etymology information is found\n//       etymology = {\n//         root: word,\n//         originLanguage: 'Unknown',\n//         meaning: 'No known etymology',\n//         evolution: [{\n//           period: 'Modern English',\n//           form: word\n//         }]\n//       };\n//     }\n//   }\n  \n//   return {\n//     etymology,\n//     affixes\n//   };\n// };\n\n// export default analyzeWord;\n\nconst LANGUAGE_ROOTS = {\n  LATIN: {\n    name: 'Latin',\n    period: 'Classical',\n    roots: {\n      'duc/duct': { meaning: 'to lead', derivatives: ['conduct', 'deduce', 'produce'] },\n      'mit/miss': { meaning: 'to send', derivatives: ['submit', 'mission', 'transmit'] },\n      'port': { meaning: 'to carry', derivatives: ['transport', 'portable', 'export'] },\n      'spec/spect': { meaning: 'to look', derivatives: ['inspect', 'spectacle', 'perspective'] },\n      'vid/vis': { meaning: 'to see', derivatives: ['video', 'vision', 'visible'] },\n      // ... existing Latin roots\n    }\n  },\n  GREEK: {\n    name: 'Ancient Greek',\n    period: 'Classical',\n    roots: {\n      'bio': { meaning: 'life', derivatives: ['biology', 'biography', 'symbiotic'] },\n      'phil': { meaning: 'love', derivatives: ['philosophy', 'philanthropy', 'philology'] },\n      'logos': { meaning: 'study/word', derivatives: ['psychology', 'biology', 'mythology'] },\n      'demos': { meaning: 'people', derivatives: ['democracy', 'demographic', 'epidemic'] },\n      // ... more Greek roots\n    }\n  },\n  SANSKRIT: {\n    name: 'Sanskrit',\n    period: 'Ancient',\n    roots: {\n      'guru': { meaning: 'teacher', derivatives: ['guru'] },\n      'yoga': { meaning: 'union', derivatives: ['yoga', 'yogic'] },\n      'karma': { meaning: 'action/deed', derivatives: ['karma', 'karmic'] },\n      'man/manas': { meaning: 'to think', derivatives: ['mantra', 'mental'] },\n    }\n  },\n  GERMANIC: {\n    name: 'Proto-Germanic',\n    period: 'Ancient',\n    roots: {\n      'ber': { meaning: 'to carry', derivatives: ['bear', 'burden'] },\n      'kom': { meaning: 'to come', derivatives: ['come', 'become', 'welcome'] },\n      'seg': { meaning: 'to say', derivatives: ['say', 'saga'] },\n      'wer': { meaning: 'man/person', derivatives: ['werewolf', 'world'] },\n    }\n  }\n};\n\nconst EVOLUTION_PATHS = {\n  ROMANCE: {\n    path: ['Latin', 'Vulgar Latin', 'Old French/Spanish/Italian', 'Modern Romance'],\n    examples: {\n      'porta': {\n        'Latin': 'porta',\n        'Vulgar Latin': 'porta',\n        'Old French': 'porte',\n        'Modern French': 'porte',\n        'Spanish': 'puerta',\n        'Italian': 'porta',\n        'Portuguese': 'porta'\n      }\n    }\n  },\n  GERMANIC: {\n    path: ['Proto-Germanic', 'Old English/Old High German', 'Middle English/Middle High German', 'Modern Germanic'],\n    examples: {\n      'water': {\n        'Proto-Germanic': '*watōr',\n        'Old English': 'wæter',\n        'Middle English': 'water',\n        'Modern English': 'water',\n        'German': 'Wasser',\n        'Dutch': 'water'\n      }\n    }\n  }\n};\n\nexport const analyzeWord = (word) => {\n  // Search through all language roots\n  for (const [rootFamily, data] of Object.entries(LANGUAGE_ROOTS)) {\n    for (const [root, info] of Object.entries(data.roots)) {\n      if (word.toLowerCase().includes(root.split('/')[0].toLowerCase())) {\n        return {\n          root: root,\n          origin: data.name,\n          period: data.period,\n          meaning: info.meaning,\n          derivatives: info.derivatives,\n          evolutionPath: findEvolutionPath(rootFamily, word)\n        };\n      }\n    }\n  }\n  \n  return null;\n};\n\nconst findEvolutionPath = (rootFamily, word) => {\n  // Find relevant evolution path based on root family\n  const path = rootFamily === 'LATIN' ? EVOLUTION_PATHS.ROMANCE : \n               rootFamily === 'GERMANIC' ? EVOLUTION_PATHS.GERMANIC : null;\n  \n  if (!path) return null;\n  \n  return {\n    stages: path.path,\n    examples: path.examples[word] || null\n  };\n};\n\nexport default {\n  analyzeWord,\n  LANGUAGE_ROOTS,\n  EVOLUTION_PATHS\n};"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,MAAMA,cAAc,GAAG;EACrBC,KAAK,EAAE;IACLC,IAAI,EAAE,OAAO;IACbC,MAAM,EAAE,WAAW;IACnBC,KAAK,EAAE;MACL,UAAU,EAAE;QAAEC,OAAO,EAAE,SAAS;QAAEC,WAAW,EAAE,CAAC,SAAS,EAAE,QAAQ,EAAE,SAAS;MAAE,CAAC;MACjF,UAAU,EAAE;QAAED,OAAO,EAAE,SAAS;QAAEC,WAAW,EAAE,CAAC,QAAQ,E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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}