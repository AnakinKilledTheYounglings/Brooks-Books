{"ast":null,"code":"/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nimport { Color, Vector2, Vector3, Vector4, Matrix3, Matrix4, EventDispatcher, MathUtils, ColorManagement, SRGBTransfer, NoToneMapping, StaticDrawUsage, InterleavedBuffer, DynamicDrawUsage, InterleavedBufferAttribute, NoColorSpace, UnsignedIntType, IntType, WebGLCoordinateSystem, BackSide, CubeReflectionMapping, CubeRefractionMapping, WebGPUCoordinateSystem, TangentSpaceNormalMap, ObjectSpaceNormalMap, InstancedInterleavedBuffer, InstancedBufferAttribute, DataArrayTexture, FloatType, FramebufferTexture, LinearMipmapLinearFilter, DepthTexture, Material, NormalBlending, PointsMaterial, LineBasicMaterial, LineDashedMaterial, NoBlending, MeshNormalMaterial, WebGLCubeRenderTarget, BoxGeometry, Mesh, Scene, LinearFilter, CubeCamera, CubeTexture, EquirectangularReflectionMapping, EquirectangularRefractionMapping, AddOperation, MixOperation, MultiplyOperation, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, Texture, MeshStandardMaterial, MeshPhysicalMaterial, MeshToonMaterial, MeshMatcapMaterial, SpriteMaterial, ShadowMaterial, Uint32BufferAttribute, Uint16BufferAttribute, DoubleSide, DepthStencilFormat, DepthFormat, UnsignedInt248Type, UnsignedByteType, RenderTarget, Plane, Object3D, HalfFloatType, LinearMipMapLinearFilter, OrthographicCamera, BufferGeometry, Float32BufferAttribute, BufferAttribute, UVMapping, Euler, LinearSRGBColorSpace, LessCompare, VSMShadowMap, RGFormat, BasicShadowMap, SphereGeometry, CubeUVReflectionMapping, PerspectiveCamera, RGBAFormat, LinearMipmapNearestFilter, NearestMipmapLinearFilter, Float16BufferAttribute, REVISION, SRGBColorSpace, PCFShadowMap, FrontSide, Frustum, DataTexture, RedIntegerFormat, RedFormat, RGIntegerFormat, RGBIntegerFormat, RGBFormat, RGBAIntegerFormat, UnsignedShortType, ByteType, ShortType, createCanvasElement, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, SrcAlphaFactor, SrcAlphaSaturateFactor, DstColorFactor, DstAlphaFactor, OneMinusSrcColorFactor, OneMinusSrcAlphaFactor, OneMinusDstColorFactor, OneMinusDstAlphaFactor, CullFaceNone, CullFaceBack, CullFaceFront, CustomBlending, MultiplyBlending, SubtractiveBlending, AdditiveBlending, NotEqualDepth, GreaterDepth, GreaterEqualDepth, EqualDepth, LessEqualDepth, LessDepth, AlwaysDepth, NeverDepth, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt5999Type, AlphaFormat, LuminanceFormat, LuminanceAlphaFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, RED_RGTC1_Format, SIGNED_RED_RGTC1_Format, RED_GREEN_RGTC2_Format, SIGNED_RED_GREEN_RGTC2_Format, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NeverCompare, AlwaysCompare, LessEqualCompare, EqualCompare, GreaterEqualCompare, GreaterCompare, NotEqualCompare, warnOnce, NotEqualStencilFunc, GreaterStencilFunc, GreaterEqualStencilFunc, EqualStencilFunc, LessEqualStencilFunc, LessStencilFunc, AlwaysStencilFunc, NeverStencilFunc, DecrementWrapStencilOp, IncrementWrapStencilOp, DecrementStencilOp, IncrementStencilOp, InvertStencilOp, ReplaceStencilOp, ZeroStencilOp, KeepStencilOp, MaxEquation, MinEquation, SpotLight, PointLight, DirectionalLight, RectAreaLight, AmbientLight, HemisphereLight, LightProbe, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, AgXToneMapping, NeutralToneMapping, Group, Loader, FileLoader, MaterialLoader, ObjectLoader } from './three.core.js';\nexport { AdditiveAnimationBlendMode, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BasicDepthPacking, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxHelper, BufferGeometryLoader, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CircleGeometry, Clock, ColorKeyframeTrack, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeTextureLoader, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceFrontBack, Curve, CurvePath, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataTextureLoader, DataUtils, DefaultLoadingManager, DetachedBindMode, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DynamicCopyUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, ExtrudeGeometry, Fog, FogExp2, GLBufferAttribute, GLSL1, GLSL3, GridHelper, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, InstancedBufferGeometry, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, KeyframeTrack, LOD, LatheGeometry, Layers, Light, Line, Line3, LineCurve, LineCurve3, LineLoop, LineSegments, LinearInterpolant, LinearMipMapNearestFilter, LinearTransfer, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, MOUSE, Matrix2, MeshDepthMaterial, MeshDistanceMaterial, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NormalAnimationBlendMode, NumberKeyframeTrack, OctahedronGeometry, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, PCFSoftShadowMap, Path, PlaneGeometry, PlaneHelper, PointLightHelper, Points, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RGBADepthPacking, RGBDepthPacking, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGDepthPacking, RawShaderMaterial, Ray, Raycaster, RingGeometry, ShaderMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, Spherical, SphericalHarmonics3, SplineCurve, SpotLightHelper, Sprite, StaticCopyUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, TOUCH, TetrahedronGeometry, TextureLoader, TextureUtils, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, VectorKeyframeTrack, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLMultipleRenderTargets, WebGLRenderTarget, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding } from './three.core.js';\nconst refreshUniforms = ['alphaMap', 'alphaTest', 'anisotropy', 'anisotropyMap', 'anisotropyRotation', 'aoMap', 'attenuationColor', 'attenuationDistance', 'bumpMap', 'clearcoat', 'clearcoatMap', 'clearcoatNormalMap', 'clearcoatNormalScale', 'clearcoatRoughness', 'color', 'dispersion', 'displacementMap', 'emissive', 'emissiveMap', 'envMap', 'gradientMap', 'ior', 'iridescence', 'iridescenceIOR', 'iridescenceMap', 'iridescenceThicknessMap', 'lightMap', 'map', 'matcap', 'metalness', 'metalnessMap', 'normalMap', 'normalScale', 'opacity', 'roughness', 'roughnessMap', 'sheen', 'sheenColor', 'sheenColorMap', 'sheenRoughnessMap', 'shininess', 'specular', 'specularColor', 'specularColorMap', 'specularIntensity', 'specularIntensityMap', 'specularMap', 'thickness', 'transmission', 'transmissionMap'];\nclass NodeMaterialObserver {\n  constructor(builder) {\n    this.renderObjects = new WeakMap();\n    this.hasNode = this.containsNode(builder);\n    this.hasAnimation = builder.object.isSkinnedMesh === true;\n    this.refreshUniforms = refreshUniforms;\n    this.renderId = 0;\n  }\n  firstInitialization(renderObject) {\n    const hasInitialized = this.renderObjects.has(renderObject);\n    if (hasInitialized === false) {\n      this.getRenderObjectData(renderObject);\n      return true;\n    }\n    return false;\n  }\n  getRenderObjectData(renderObject) {\n    let data = this.renderObjects.get(renderObject);\n    if (data === undefined) {\n      const {\n        geometry,\n        material,\n        object\n      } = renderObject;\n      data = {\n        material: this.getMaterialData(material),\n        geometry: {\n          attributes: this.getAttributesData(geometry.attributes),\n          indexVersion: geometry.index ? geometry.index.version : null,\n          drawRange: {\n            start: geometry.drawRange.start,\n            count: geometry.drawRange.count\n          }\n        },\n        worldMatrix: object.matrixWorld.clone()\n      };\n      if (object.center) {\n        data.center = object.center.clone();\n      }\n      if (object.morphTargetInfluences) {\n        data.morphTargetInfluences = object.morphTargetInfluences.slice();\n      }\n      if (renderObject.bundle !== null) {\n        data.version = renderObject.bundle.version;\n      }\n      if (data.material.transmission > 0) {\n        const {\n          width,\n          height\n        } = renderObject.context;\n        data.bufferWidth = width;\n        data.bufferHeight = height;\n      }\n      this.renderObjects.set(renderObject, data);\n    }\n    return data;\n  }\n  getAttributesData(attributes) {\n    const attributesData = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      attributesData[name] = {\n        version: attribute.version\n      };\n    }\n    return attributesData;\n  }\n  containsNode(builder) {\n    const material = builder.material;\n    for (const property in material) {\n      if (material[property] && material[property].isNode) return true;\n    }\n    if (builder.renderer.nodes.modelViewMatrix !== null || builder.renderer.nodes.modelNormalViewMatrix !== null) return true;\n    return false;\n  }\n  getMaterialData(material) {\n    const data = {};\n    for (const property of this.refreshUniforms) {\n      const value = material[property];\n      if (value === null || value === undefined) continue;\n      if (typeof value === 'object' && value.clone !== undefined) {\n        if (value.isTexture === true) {\n          data[property] = {\n            id: value.id,\n            version: value.version\n          };\n        } else {\n          data[property] = value.clone();\n        }\n      } else {\n        data[property] = value;\n      }\n    }\n    return data;\n  }\n  equals(renderObject) {\n    const {\n      object,\n      material,\n      geometry\n    } = renderObject;\n    const renderObjectData = this.getRenderObjectData(renderObject);\n\n    // world matrix\n\n    if (renderObjectData.worldMatrix.equals(object.matrixWorld) !== true) {\n      renderObjectData.worldMatrix.copy(object.matrixWorld);\n      return false;\n    }\n\n    // material\n\n    const materialData = renderObjectData.material;\n    for (const property in materialData) {\n      const value = materialData[property];\n      const mtlValue = material[property];\n      if (value.equals !== undefined) {\n        if (value.equals(mtlValue) === false) {\n          value.copy(mtlValue);\n          return false;\n        }\n      } else if (mtlValue.isTexture === true) {\n        if (value.id !== mtlValue.id || value.version !== mtlValue.version) {\n          value.id = mtlValue.id;\n          value.version = mtlValue.version;\n          return false;\n        }\n      } else if (value !== mtlValue) {\n        materialData[property] = mtlValue;\n        return false;\n      }\n    }\n    if (materialData.transmission > 0) {\n      const {\n        width,\n        height\n      } = renderObject.context;\n      if (renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height) {\n        renderObjectData.bufferWidth = width;\n        renderObjectData.bufferHeight = height;\n        return false;\n      }\n    }\n\n    // geometry\n\n    const storedGeometryData = renderObjectData.geometry;\n    const attributes = geometry.attributes;\n    const storedAttributes = storedGeometryData.attributes;\n    const storedAttributeNames = Object.keys(storedAttributes);\n    const currentAttributeNames = Object.keys(attributes);\n    if (storedAttributeNames.length !== currentAttributeNames.length) {\n      renderObjectData.geometry.attributes = this.getAttributesData(attributes);\n      return false;\n    }\n\n    // compare each attribute\n\n    for (const name of storedAttributeNames) {\n      const storedAttributeData = storedAttributes[name];\n      const attribute = attributes[name];\n      if (attribute === undefined) {\n        // attribute was removed\n        delete storedAttributes[name];\n        return false;\n      }\n      if (storedAttributeData.version !== attribute.version) {\n        storedAttributeData.version = attribute.version;\n        return false;\n      }\n    }\n\n    // check index\n\n    const index = geometry.index;\n    const storedIndexVersion = storedGeometryData.indexVersion;\n    const currentIndexVersion = index ? index.version : null;\n    if (storedIndexVersion !== currentIndexVersion) {\n      storedGeometryData.indexVersion = currentIndexVersion;\n      return false;\n    }\n\n    // check drawRange\n\n    if (storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count) {\n      storedGeometryData.drawRange.start = geometry.drawRange.start;\n      storedGeometryData.drawRange.count = geometry.drawRange.count;\n      return false;\n    }\n\n    // morph targets\n\n    if (renderObjectData.morphTargetInfluences) {\n      let morphChanged = false;\n      for (let i = 0; i < renderObjectData.morphTargetInfluences.length; i++) {\n        if (renderObjectData.morphTargetInfluences[i] !== object.morphTargetInfluences[i]) {\n          morphChanged = true;\n        }\n      }\n      if (morphChanged) return true;\n    }\n\n    // center\n\n    if (renderObjectData.center) {\n      if (renderObjectData.center.equals(object.center) === false) {\n        renderObjectData.center.copy(object.center);\n        return true;\n      }\n    }\n\n    // bundle\n\n    if (renderObject.bundle !== null) {\n      renderObjectData.version = renderObject.bundle.version;\n    }\n    return true;\n  }\n  needsRefresh(renderObject, nodeFrame) {\n    if (this.hasNode || this.hasAnimation || this.firstInitialization(renderObject)) return true;\n    const {\n      renderId\n    } = nodeFrame;\n    if (this.renderId !== renderId) {\n      this.renderId = renderId;\n      return true;\n    }\n    const isStatic = renderObject.object.static === true;\n    const isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData(renderObject).version === renderObject.bundle.version;\n    if (isStatic || isBundle) return false;\n    const notEqual = this.equals(renderObject) !== true;\n    return notEqual;\n  }\n}\n\n// cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.\n// A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.\n// Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.\n// See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480\n// https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\nfunction cyrb53(value) {\n  let seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let h1 = 0xdeadbeef ^ seed,\n    h2 = 0x41c6ce57 ^ seed;\n  if (value instanceof Array) {\n    for (let i = 0, val; i < value.length; i++) {\n      val = value[i];\n      h1 = Math.imul(h1 ^ val, 2654435761);\n      h2 = Math.imul(h2 ^ val, 1597334677);\n    }\n  } else {\n    for (let i = 0, ch; i < value.length; i++) {\n      ch = value.charCodeAt(i);\n      h1 = Math.imul(h1 ^ ch, 2654435761);\n      h2 = Math.imul(h2 ^ ch, 1597334677);\n    }\n  }\n  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);\n  h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);\n  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);\n  h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);\n  return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n}\nconst hashString = str => cyrb53(str);\nconst hashArray = array => cyrb53(array);\nconst hash$1 = function () {\n  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n    params[_key] = arguments[_key];\n  }\n  return cyrb53(params);\n};\nfunction getCacheKey$1(object) {\n  let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const values = [];\n  if (object.isNode === true) {\n    values.push(object.id);\n    object = object.getSelf();\n  }\n  for (const {\n    property,\n    childNode\n  } of getNodeChildren(object)) {\n    values.push(values, cyrb53(property.slice(0, -4)), childNode.getCacheKey(force));\n  }\n  return cyrb53(values);\n}\nfunction getNodeChildren(node) {\n  let toJSON = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return function* () {\n    for (const property in node) {\n      // Ignore private properties.\n      if (property.startsWith('_') === true) continue;\n      const object = node[property];\n      if (Array.isArray(object) === true) {\n        for (let i = 0; i < object.length; i++) {\n          const child = object[i];\n          if (child && (child.isNode === true || toJSON && typeof child.toJSON === 'function')) {\n            yield {\n              property,\n              index: i,\n              childNode: child\n            };\n          }\n        }\n      } else if (object && object.isNode === true) {\n        yield {\n          property,\n          childNode: object\n        };\n      } else if (typeof object === 'object') {\n        for (const subProperty in object) {\n          const child = object[subProperty];\n          if (child && (child.isNode === true || toJSON && typeof child.toJSON === 'function')) {\n            yield {\n              property,\n              index: subProperty,\n              childNode: child\n            };\n          }\n        }\n      }\n    }\n  }();\n}\nconst typeFromLength = /*@__PURE__*/new Map([[1, 'float'], [2, 'vec2'], [3, 'vec3'], [4, 'vec4'], [9, 'mat3'], [16, 'mat4']]);\nfunction getTypeFromLength(length) {\n  return typeFromLength.get(length);\n}\nfunction getLengthFromType(type) {\n  if (/float|int|uint/.test(type)) return 1;\n  if (/vec2/.test(type)) return 2;\n  if (/vec3/.test(type)) return 3;\n  if (/vec4/.test(type)) return 4;\n  if (/mat3/.test(type)) return 9;\n  if (/mat4/.test(type)) return 16;\n  console.error('THREE.TSL: Unsupported type:', type);\n}\nfunction getValueType(value) {\n  if (value === undefined || value === null) return null;\n  const typeOf = typeof value;\n  if (value.isNode === true) {\n    return 'node';\n  } else if (typeOf === 'number') {\n    return 'float';\n  } else if (typeOf === 'boolean') {\n    return 'bool';\n  } else if (typeOf === 'string') {\n    return 'string';\n  } else if (typeOf === 'function') {\n    return 'shader';\n  } else if (value.isVector2 === true) {\n    return 'vec2';\n  } else if (value.isVector3 === true) {\n    return 'vec3';\n  } else if (value.isVector4 === true) {\n    return 'vec4';\n  } else if (value.isMatrix3 === true) {\n    return 'mat3';\n  } else if (value.isMatrix4 === true) {\n    return 'mat4';\n  } else if (value.isColor === true) {\n    return 'color';\n  } else if (value instanceof ArrayBuffer) {\n    return 'ArrayBuffer';\n  }\n  return null;\n}\nfunction getValueFromType(type) {\n  for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    params[_key2 - 1] = arguments[_key2];\n  }\n  const last4 = type ? type.slice(-4) : undefined;\n  if (params.length === 1) {\n    // ensure same behaviour as in NodeBuilder.format()\n\n    if (last4 === 'vec2') params = [params[0], params[0]];else if (last4 === 'vec3') params = [params[0], params[0], params[0]];else if (last4 === 'vec4') params = [params[0], params[0], params[0], params[0]];\n  }\n  if (type === 'color') {\n    return new Color(...params);\n  } else if (last4 === 'vec2') {\n    return new Vector2(...params);\n  } else if (last4 === 'vec3') {\n    return new Vector3(...params);\n  } else if (last4 === 'vec4') {\n    return new Vector4(...params);\n  } else if (last4 === 'mat3') {\n    return new Matrix3(...params);\n  } else if (last4 === 'mat4') {\n    return new Matrix4(...params);\n  } else if (type === 'bool') {\n    return params[0] || false;\n  } else if (type === 'float' || type === 'int' || type === 'uint') {\n    return params[0] || 0;\n  } else if (type === 'string') {\n    return params[0] || '';\n  } else if (type === 'ArrayBuffer') {\n    return base64ToArrayBuffer(params[0]);\n  }\n  return null;\n}\nfunction arrayBufferToBase64(arrayBuffer) {\n  let chars = '';\n  const array = new Uint8Array(arrayBuffer);\n  for (let i = 0; i < array.length; i++) {\n    chars += String.fromCharCode(array[i]);\n  }\n  return btoa(chars);\n}\nfunction base64ToArrayBuffer(base64) {\n  return Uint8Array.from(atob(base64), c => c.charCodeAt(0)).buffer;\n}\nvar NodeUtils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  arrayBufferToBase64: arrayBufferToBase64,\n  base64ToArrayBuffer: base64ToArrayBuffer,\n  getCacheKey: getCacheKey$1,\n  getLengthFromType: getLengthFromType,\n  getNodeChildren: getNodeChildren,\n  getTypeFromLength: getTypeFromLength,\n  getValueFromType: getValueFromType,\n  getValueType: getValueType,\n  hash: hash$1,\n  hashArray: hashArray,\n  hashString: hashString\n});\nconst NodeShaderStage = {\n  VERTEX: 'vertex',\n  FRAGMENT: 'fragment'\n};\nconst NodeUpdateType = {\n  NONE: 'none',\n  FRAME: 'frame',\n  RENDER: 'render',\n  OBJECT: 'object'\n};\nconst NodeType = {\n  BOOLEAN: 'bool',\n  INTEGER: 'int',\n  FLOAT: 'float',\n  VECTOR2: 'vec2',\n  VECTOR3: 'vec3',\n  VECTOR4: 'vec4',\n  MATRIX2: 'mat2',\n  MATRIX3: 'mat3',\n  MATRIX4: 'mat4'\n};\nconst NodeAccess = {\n  READ_ONLY: 'readOnly',\n  WRITE_ONLY: 'writeOnly',\n  READ_WRITE: 'readWrite'\n};\nconst defaultShaderStages = ['fragment', 'vertex'];\nconst defaultBuildStages = ['setup', 'analyze', 'generate'];\nconst shaderStages = [...defaultShaderStages, 'compute'];\nconst vectorComponents = ['x', 'y', 'z', 'w'];\nlet _nodeId = 0;\nclass Node extends EventDispatcher {\n  static get type() {\n    return 'Node';\n  }\n  constructor() {\n    let nodeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this.nodeType = nodeType;\n    this.updateType = NodeUpdateType.NONE;\n    this.updateBeforeType = NodeUpdateType.NONE;\n    this.updateAfterType = NodeUpdateType.NONE;\n    this.uuid = MathUtils.generateUUID();\n    this.version = 0;\n    this._cacheKey = null;\n    this._cacheKeyVersion = 0;\n    this.global = false;\n    this.isNode = true;\n    Object.defineProperty(this, 'id', {\n      value: _nodeId++\n    });\n  }\n  set needsUpdate(value) {\n    if (value === true) {\n      this.version++;\n    }\n  }\n  get type() {\n    return this.constructor.type;\n  }\n  onUpdate(callback, updateType) {\n    this.updateType = updateType;\n    this.update = callback.bind(this.getSelf());\n    return this;\n  }\n  onFrameUpdate(callback) {\n    return this.onUpdate(callback, NodeUpdateType.FRAME);\n  }\n  onRenderUpdate(callback) {\n    return this.onUpdate(callback, NodeUpdateType.RENDER);\n  }\n  onObjectUpdate(callback) {\n    return this.onUpdate(callback, NodeUpdateType.OBJECT);\n  }\n  onReference(callback) {\n    this.updateReference = callback.bind(this.getSelf());\n    return this;\n  }\n  getSelf() {\n    // Returns non-node object.\n\n    return this.self || this;\n  }\n  updateReference(/*state*/\n  ) {\n    return this;\n  }\n  isGlobal(/*builder*/\n  ) {\n    return this.global;\n  }\n  *getChildren() {\n    for (const {\n      childNode\n    } of getNodeChildren(this)) {\n      yield childNode;\n    }\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n  traverse(callback) {\n    callback(this);\n    for (const childNode of this.getChildren()) {\n      childNode.traverse(callback);\n    }\n  }\n  getCacheKey() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    force = force || this.version !== this._cacheKeyVersion;\n    if (force === true || this._cacheKey === null) {\n      this._cacheKey = getCacheKey$1(this, force);\n      this._cacheKeyVersion = this.version;\n    }\n    return this._cacheKey;\n  }\n  getScope() {\n    return this;\n  }\n  getHash(/*builder*/\n  ) {\n    return this.uuid;\n  }\n  getUpdateType() {\n    return this.updateType;\n  }\n  getUpdateBeforeType() {\n    return this.updateBeforeType;\n  }\n  getUpdateAfterType() {\n    return this.updateAfterType;\n  }\n  getElementType(builder) {\n    const type = this.getNodeType(builder);\n    const elementType = builder.getElementType(type);\n    return elementType;\n  }\n  getNodeType(builder) {\n    const nodeProperties = builder.getNodeProperties(this);\n    if (nodeProperties.outputNode) {\n      return nodeProperties.outputNode.getNodeType(builder);\n    }\n    return this.nodeType;\n  }\n  getShared(builder) {\n    const hash = this.getHash(builder);\n    const nodeFromHash = builder.getNodeFromHash(hash);\n    return nodeFromHash || this;\n  }\n  setup(builder) {\n    const nodeProperties = builder.getNodeProperties(this);\n    let index = 0;\n    for (const childNode of this.getChildren()) {\n      nodeProperties['node' + index++] = childNode;\n    }\n\n    // return a outputNode if exists\n    return null;\n  }\n  analyze(builder) {\n    const usageCount = builder.increaseUsage(this);\n    if (usageCount === 1) {\n      // node flow children\n\n      const nodeProperties = builder.getNodeProperties(this);\n      for (const childNode of Object.values(nodeProperties)) {\n        if (childNode && childNode.isNode === true) {\n          childNode.build(builder);\n        }\n      }\n    }\n  }\n  generate(builder, output) {\n    const {\n      outputNode\n    } = builder.getNodeProperties(this);\n    if (outputNode && outputNode.isNode === true) {\n      return outputNode.build(builder, output);\n    }\n  }\n  updateBefore(/*frame*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  updateAfter(/*frame*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  update(/*frame*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  build(builder) {\n    let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const refNode = this.getShared(builder);\n    if (this !== refNode) {\n      return refNode.build(builder, output);\n    }\n    builder.addNode(this);\n    builder.addChain(this);\n\n    /* Build stages expected results:\n    \t- \"setup\"\t\t-> Node\n    \t- \"analyze\"\t\t-> null\n    \t- \"generate\"\t-> String\n    */\n    let result = null;\n    const buildStage = builder.getBuildStage();\n    if (buildStage === 'setup') {\n      this.updateReference(builder);\n      const properties = builder.getNodeProperties(this);\n      if (properties.initialized !== true) {\n        const stackNodesBeforeSetup = builder.stack.nodes.length;\n        properties.initialized = true;\n        properties.outputNode = this.setup(builder);\n        if (properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeSetup) ;\n        for (const childNode of Object.values(properties)) {\n          if (childNode && childNode.isNode === true) {\n            childNode.build(builder);\n          }\n        }\n      }\n    } else if (buildStage === 'analyze') {\n      this.analyze(builder);\n    } else if (buildStage === 'generate') {\n      const isGenerateOnce = this.generate.length === 1;\n      if (isGenerateOnce) {\n        const type = this.getNodeType(builder);\n        const nodeData = builder.getDataFromNode(this);\n        result = nodeData.snippet;\n        if (result === undefined) {\n          result = this.generate(builder) || '';\n          nodeData.snippet = result;\n        } else if (nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined) {\n          builder.addFlowCodeHierarchy(this, builder.context.nodeBlock);\n        }\n        result = builder.format(result, type, output);\n      } else {\n        result = this.generate(builder, output) || '';\n      }\n    }\n    builder.removeChain(this);\n    builder.addSequentialNode(this);\n    return result;\n  }\n  getSerializeChildren() {\n    return getNodeChildren(this);\n  }\n  serialize(json) {\n    const nodeChildren = this.getSerializeChildren();\n    const inputNodes = {};\n    for (const {\n      property,\n      index,\n      childNode\n    } of nodeChildren) {\n      if (index !== undefined) {\n        if (inputNodes[property] === undefined) {\n          inputNodes[property] = Number.isInteger(index) ? [] : {};\n        }\n        inputNodes[property][index] = childNode.toJSON(json.meta).uuid;\n      } else {\n        inputNodes[property] = childNode.toJSON(json.meta).uuid;\n      }\n    }\n    if (Object.keys(inputNodes).length > 0) {\n      json.inputNodes = inputNodes;\n    }\n  }\n  deserialize(json) {\n    if (json.inputNodes !== undefined) {\n      const nodes = json.meta.nodes;\n      for (const property in json.inputNodes) {\n        if (Array.isArray(json.inputNodes[property])) {\n          const inputArray = [];\n          for (const uuid of json.inputNodes[property]) {\n            inputArray.push(nodes[uuid]);\n          }\n          this[property] = inputArray;\n        } else if (typeof json.inputNodes[property] === 'object') {\n          const inputObject = {};\n          for (const subProperty in json.inputNodes[property]) {\n            const uuid = json.inputNodes[property][subProperty];\n            inputObject[subProperty] = nodes[uuid];\n          }\n          this[property] = inputObject;\n        } else {\n          const uuid = json.inputNodes[property];\n          this[property] = nodes[uuid];\n        }\n      }\n    }\n  }\n  toJSON(meta) {\n    const {\n      uuid,\n      type\n    } = this;\n    const isRoot = meta === undefined || typeof meta === 'string';\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n\n    // serialize\n\n    let data = meta.nodes[uuid];\n    if (data === undefined) {\n      data = {\n        uuid,\n        type,\n        meta,\n        metadata: {\n          version: 4.6,\n          type: 'Node',\n          generator: 'Node.toJSON'\n        }\n      };\n      if (isRoot !== true) meta.nodes[data.uuid] = data;\n      this.serialize(data);\n      delete data.meta;\n    }\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n}\nclass ArrayElementNode extends Node {\n  static get type() {\n    return 'ArrayElementNode';\n  } // @TODO: If extending from TempNode it breaks webgpu_compute\n\n  constructor(node, indexNode) {\n    super();\n    this.node = node;\n    this.indexNode = indexNode;\n    this.isArrayElementNode = true;\n  }\n  getNodeType(builder) {\n    return this.node.getElementType(builder);\n  }\n  generate(builder) {\n    const nodeSnippet = this.node.build(builder);\n    const indexSnippet = this.indexNode.build(builder, 'uint');\n    return `${nodeSnippet}[ ${indexSnippet} ]`;\n  }\n}\nclass ConvertNode extends Node {\n  static get type() {\n    return 'ConvertNode';\n  }\n  constructor(node, convertTo) {\n    super();\n    this.node = node;\n    this.convertTo = convertTo;\n  }\n  getNodeType(builder) {\n    const requestType = this.node.getNodeType(builder);\n    let convertTo = null;\n    for (const overloadingType of this.convertTo.split('|')) {\n      if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {\n        convertTo = overloadingType;\n      }\n    }\n    return convertTo;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.convertTo = this.convertTo;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.convertTo = data.convertTo;\n  }\n  generate(builder, output) {\n    const node = this.node;\n    const type = this.getNodeType(builder);\n    const snippet = node.build(builder, type);\n    return builder.format(snippet, type, output);\n  }\n}\nclass TempNode extends Node {\n  static get type() {\n    return 'TempNode';\n  }\n  constructor(type) {\n    super(type);\n    this.isTempNode = true;\n  }\n  hasDependencies(builder) {\n    return builder.getDataFromNode(this).usageCount > 1;\n  }\n  build(builder, output) {\n    const buildStage = builder.getBuildStage();\n    if (buildStage === 'generate') {\n      const type = builder.getVectorType(this.getNodeType(builder, output));\n      const nodeData = builder.getDataFromNode(this);\n      if (nodeData.propertyName !== undefined) {\n        return builder.format(nodeData.propertyName, type, output);\n      } else if (type !== 'void' && output !== 'void' && this.hasDependencies(builder)) {\n        const snippet = super.build(builder, type);\n        const nodeVar = builder.getVarFromNode(this, null, type);\n        const propertyName = builder.getPropertyName(nodeVar);\n        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);\n        nodeData.snippet = snippet;\n        nodeData.propertyName = propertyName;\n        return builder.format(nodeData.propertyName, type, output);\n      }\n    }\n    return super.build(builder, output);\n  }\n}\nclass JoinNode extends TempNode {\n  static get type() {\n    return 'JoinNode';\n  }\n  constructor() {\n    let nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(nodeType);\n    this.nodes = nodes;\n  }\n  getNodeType(builder) {\n    if (this.nodeType !== null) {\n      return builder.getVectorType(this.nodeType);\n    }\n    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    const nodes = this.nodes;\n    const primitiveType = builder.getComponentType(type);\n    const snippetValues = [];\n    for (const input of nodes) {\n      let inputSnippet = input.build(builder);\n      const inputPrimitiveType = builder.getComponentType(input.getNodeType(builder));\n      if (inputPrimitiveType !== primitiveType) {\n        inputSnippet = builder.format(inputSnippet, inputPrimitiveType, primitiveType);\n      }\n      snippetValues.push(inputSnippet);\n    }\n    const snippet = `${builder.getType(type)}( ${snippetValues.join(', ')} )`;\n    return builder.format(snippet, type, output);\n  }\n}\nconst stringVectorComponents = vectorComponents.join('');\nclass SplitNode extends Node {\n  static get type() {\n    return 'SplitNode';\n  }\n  constructor(node) {\n    let components = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';\n    super();\n    this.node = node;\n    this.components = components;\n    this.isSplitNode = true;\n  }\n  getVectorLength() {\n    let vectorLength = this.components.length;\n    for (const c of this.components) {\n      vectorLength = Math.max(vectorComponents.indexOf(c) + 1, vectorLength);\n    }\n    return vectorLength;\n  }\n  getComponentType(builder) {\n    return builder.getComponentType(this.node.getNodeType(builder));\n  }\n  getNodeType(builder) {\n    return builder.getTypeFromLength(this.components.length, this.getComponentType(builder));\n  }\n  generate(builder, output) {\n    const node = this.node;\n    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));\n    let snippet = null;\n    if (nodeTypeLength > 1) {\n      let type = null;\n      const componentsLength = this.getVectorLength();\n      if (componentsLength >= nodeTypeLength) {\n        // needed expand the input node\n\n        type = builder.getTypeFromLength(this.getVectorLength(), this.getComponentType(builder));\n      }\n      const nodeSnippet = node.build(builder, type);\n      if (this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice(0, this.components.length)) {\n        // unnecessary swizzle\n\n        snippet = builder.format(nodeSnippet, type, output);\n      } else {\n        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output);\n      }\n    } else {\n      // ignore .components if .node returns float/integer\n\n      snippet = node.build(builder, output);\n    }\n    return snippet;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.components = this.components;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.components = data.components;\n  }\n}\nclass SetNode extends TempNode {\n  static get type() {\n    return 'SetNode';\n  }\n  constructor(sourceNode, components, targetNode) {\n    super();\n    this.sourceNode = sourceNode;\n    this.components = components;\n    this.targetNode = targetNode;\n  }\n  getNodeType(builder) {\n    return this.sourceNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const {\n      sourceNode,\n      components,\n      targetNode\n    } = this;\n    const sourceType = this.getNodeType(builder);\n    const targetType = builder.getTypeFromLength(components.length, targetNode.getNodeType(builder));\n    const targetSnippet = targetNode.build(builder, targetType);\n    const sourceSnippet = sourceNode.build(builder, sourceType);\n    const length = builder.getTypeLength(sourceType);\n    const snippetValues = [];\n    for (let i = 0; i < length; i++) {\n      const component = vectorComponents[i];\n      if (component === components[0]) {\n        snippetValues.push(targetSnippet);\n        i += components.length - 1;\n      } else {\n        snippetValues.push(sourceSnippet + '.' + component);\n      }\n    }\n    return `${builder.getType(sourceType)}( ${snippetValues.join(', ')} )`;\n  }\n}\nclass FlipNode extends TempNode {\n  static get type() {\n    return 'FlipNode';\n  }\n  constructor(sourceNode, components) {\n    super();\n    this.sourceNode = sourceNode;\n    this.components = components;\n  }\n  getNodeType(builder) {\n    return this.sourceNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const {\n      components,\n      sourceNode\n    } = this;\n    const sourceType = this.getNodeType(builder);\n    const sourceSnippet = sourceNode.build(builder);\n    const sourceCache = builder.getVarFromNode(this);\n    const sourceProperty = builder.getPropertyName(sourceCache);\n    builder.addLineFlowCode(sourceProperty + ' = ' + sourceSnippet, this);\n    const length = builder.getTypeLength(sourceType);\n    const snippetValues = [];\n    let componentIndex = 0;\n    for (let i = 0; i < length; i++) {\n      const component = vectorComponents[i];\n      if (component === components[componentIndex]) {\n        snippetValues.push('1.0 - ' + (sourceProperty + '.' + component));\n        componentIndex++;\n      } else {\n        snippetValues.push(sourceProperty + '.' + component);\n      }\n    }\n    return `${builder.getType(sourceType)}( ${snippetValues.join(', ')} )`;\n  }\n}\nclass InputNode extends Node {\n  static get type() {\n    return 'InputNode';\n  }\n  constructor(value) {\n    let nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(nodeType);\n    this.isInputNode = true;\n    this.value = value;\n    this.precision = null;\n  }\n  getNodeType(/*builder*/\n  ) {\n    if (this.nodeType === null) {\n      return getValueType(this.value);\n    }\n    return this.nodeType;\n  }\n  getInputType(builder) {\n    return this.getNodeType(builder);\n  }\n  setPrecision(precision) {\n    this.precision = precision;\n    return this;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.value = this.value;\n    if (this.value && this.value.toArray) data.value = this.value.toArray();\n    data.valueType = getValueType(this.value);\n    data.nodeType = this.nodeType;\n    if (data.valueType === 'ArrayBuffer') data.value = arrayBufferToBase64(data.value);\n    data.precision = this.precision;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.nodeType = data.nodeType;\n    this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;\n    this.precision = data.precision || null;\n    if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);\n  }\n  generate(/*builder, output*/\n  ) {\n    console.warn('Abstract function.');\n  }\n}\nclass ConstNode extends InputNode {\n  static get type() {\n    return 'ConstNode';\n  }\n  constructor(value) {\n    let nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(value, nodeType);\n    this.isConstNode = true;\n  }\n  generateConst(builder) {\n    return builder.generateConst(this.getNodeType(builder), this.value);\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    return builder.format(this.generateConst(builder), type, output);\n  }\n}\n\n//\n\nlet currentStack = null;\nconst NodeElements = new Map();\nfunction addMethodChaining(name, nodeElement) {\n  if (NodeElements.has(name)) {\n    console.warn(`Redefinition of method chaining ${name}`);\n    return;\n  }\n  if (typeof nodeElement !== 'function') throw new Error(`Node element ${name} is not a function`);\n  NodeElements.set(name, nodeElement);\n}\nconst parseSwizzle = props => props.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\nconst parseSwizzleAndSort = props => parseSwizzle(props).split('').sort().join('');\nconst shaderNodeHandler = {\n  setup(NodeClosure, params) {\n    const inputs = params.shift();\n    return NodeClosure(nodeObjects(inputs), ...params);\n  },\n  get(node, prop, nodeObj) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (node.isStackNode !== true && prop === 'assign') {\n        return function () {\n          for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            params[_key3] = arguments[_key3];\n          }\n          currentStack.assign(nodeObj, ...params);\n          return nodeObj;\n        };\n      } else if (NodeElements.has(prop)) {\n        const nodeElement = NodeElements.get(prop);\n        return node.isStackNode ? function () {\n          return nodeObj.add(nodeElement(...arguments));\n        } : function () {\n          for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n            params[_key4] = arguments[_key4];\n          }\n          return nodeElement(nodeObj, ...params);\n        };\n      } else if (prop === 'self') {\n        return node;\n      } else if (prop.endsWith('Assign') && NodeElements.has(prop.slice(0, prop.length - 'Assign'.length))) {\n        const nodeElement = NodeElements.get(prop.slice(0, prop.length - 'Assign'.length));\n        return node.isStackNode ? function () {\n          return nodeObj.assign(arguments.length <= 0 ? undefined : arguments[0], nodeElement(...arguments));\n        } : function () {\n          for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n            params[_key5] = arguments[_key5];\n          }\n          return nodeObj.assign(nodeElement(nodeObj, ...params));\n        };\n      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n\n        prop = parseSwizzle(prop);\n        return nodeObject(new SplitNode(nodeObj, prop));\n      } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {\n        // set properties ( swizzle ) and sort to xyzw sequence\n\n        prop = parseSwizzleAndSort(prop.slice(3).toLowerCase());\n        return value => nodeObject(new SetNode(node, prop, value));\n      } else if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {\n        // set properties ( swizzle ) and sort to xyzw sequence\n\n        prop = parseSwizzleAndSort(prop.slice(4).toLowerCase());\n        return () => nodeObject(new FlipNode(nodeObject(node), prop));\n      } else if (prop === 'width' || prop === 'height' || prop === 'depth') {\n        // accessing property\n\n        if (prop === 'width') prop = 'x';else if (prop === 'height') prop = 'y';else if (prop === 'depth') prop = 'z';\n        return nodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n\n        return nodeObject(new ArrayElementNode(nodeObj, new ConstNode(Number(prop), 'uint')));\n      }\n    }\n    return Reflect.get(node, prop, nodeObj);\n  },\n  set(node, prop, value, nodeObj) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      // setting properties\n\n      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\\d+$/.test(prop) === true) {\n        nodeObj[prop].assign(value);\n        return true;\n      }\n    }\n    return Reflect.set(node, prop, value, nodeObj);\n  }\n};\nconst nodeObjectsCacheMap = new WeakMap();\nconst nodeBuilderFunctionsCacheMap = new WeakMap();\nconst ShaderNodeObject = function (obj) {\n  let altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const type = getValueType(obj);\n  if (type === 'node') {\n    let nodeObject = nodeObjectsCacheMap.get(obj);\n    if (nodeObject === undefined) {\n      nodeObject = new Proxy(obj, shaderNodeHandler);\n      nodeObjectsCacheMap.set(obj, nodeObject);\n      nodeObjectsCacheMap.set(nodeObject, nodeObject);\n    }\n    return nodeObject;\n  } else if (altType === null && (type === 'float' || type === 'boolean') || type && type !== 'shader' && type !== 'string') {\n    return nodeObject(getConstNode(obj, altType));\n  } else if (type === 'shader') {\n    return Fn(obj);\n  }\n  return obj;\n};\nconst ShaderNodeObjects = function (objects) {\n  let altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  for (const name in objects) {\n    objects[name] = nodeObject(objects[name], altType);\n  }\n  return objects;\n};\nconst ShaderNodeArray = function (array) {\n  let altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const len = array.length;\n  for (let i = 0; i < len; i++) {\n    array[i] = nodeObject(array[i], altType);\n  }\n  return array;\n};\nconst ShaderNodeProxy = function (NodeClass) {\n  let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let factor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let settings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  const assignNode = node => nodeObject(settings !== null ? Object.assign(node, settings) : node);\n  if (scope === null) {\n    return function () {\n      for (var _len6 = arguments.length, params = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        params[_key6] = arguments[_key6];\n      }\n      return assignNode(new NodeClass(...nodeArray(params)));\n    };\n  } else if (factor !== null) {\n    factor = nodeObject(factor);\n    return function () {\n      for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        params[_key7] = arguments[_key7];\n      }\n      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));\n    };\n  } else {\n    return function () {\n      for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        params[_key8] = arguments[_key8];\n      }\n      return assignNode(new NodeClass(scope, ...nodeArray(params)));\n    };\n  }\n};\nconst ShaderNodeImmutable = function (NodeClass) {\n  for (var _len9 = arguments.length, params = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n    params[_key9 - 1] = arguments[_key9];\n  }\n  return nodeObject(new NodeClass(...nodeArray(params)));\n};\nclass ShaderCallNodeInternal extends Node {\n  constructor(shaderNode, inputNodes) {\n    super();\n    this.shaderNode = shaderNode;\n    this.inputNodes = inputNodes;\n  }\n  getNodeType(builder) {\n    return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);\n  }\n  call(builder) {\n    const {\n      shaderNode,\n      inputNodes\n    } = this;\n    const properties = builder.getNodeProperties(shaderNode);\n    if (properties.onceOutput) return properties.onceOutput;\n\n    //\n\n    let result = null;\n    if (shaderNode.layout) {\n      let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);\n      if (functionNodesCacheMap === undefined) {\n        functionNodesCacheMap = new WeakMap();\n        nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);\n      }\n      let functionNode = functionNodesCacheMap.get(shaderNode);\n      if (functionNode === undefined) {\n        functionNode = nodeObject(builder.buildFunctionNode(shaderNode));\n        functionNodesCacheMap.set(shaderNode, functionNode);\n      }\n      if (builder.currentFunctionNode !== null) {\n        builder.currentFunctionNode.includes.push(functionNode);\n      }\n      result = nodeObject(functionNode.call(inputNodes));\n    } else {\n      const jsFunc = shaderNode.jsFunc;\n      const outputNode = inputNodes !== null ? jsFunc(inputNodes, builder) : jsFunc(builder);\n      result = nodeObject(outputNode);\n    }\n    if (shaderNode.once) {\n      properties.onceOutput = result;\n    }\n    return result;\n  }\n  getOutputNode(builder) {\n    const properties = builder.getNodeProperties(this);\n    if (properties.outputNode === null) {\n      properties.outputNode = this.setupOutput(builder);\n    }\n    return properties.outputNode;\n  }\n  setup(builder) {\n    return this.getOutputNode(builder);\n  }\n  setupOutput(builder) {\n    builder.addStack();\n    builder.stack.outputNode = this.call(builder);\n    return builder.removeStack();\n  }\n  generate(builder, output) {\n    const outputNode = this.getOutputNode(builder);\n    return outputNode.build(builder, output);\n  }\n}\nclass ShaderNodeInternal extends Node {\n  constructor(jsFunc, nodeType) {\n    super(nodeType);\n    this.jsFunc = jsFunc;\n    this.layout = null;\n    this.global = true;\n    this.once = false;\n  }\n  setLayout(layout) {\n    this.layout = layout;\n    return this;\n  }\n  call() {\n    let inputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    nodeObjects(inputs);\n    return nodeObject(new ShaderCallNodeInternal(this, inputs));\n  }\n  setup() {\n    return this.call();\n  }\n}\nconst bools = [false, true];\nconst uints = [0, 1, 2, 3];\nconst ints = [-1, -2];\nconst floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nconst boolsCacheMap = new Map();\nfor (const bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));\nconst uintsCacheMap = new Map();\nfor (const uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));\nconst intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));\nfor (const int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));\nconst floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));\nfor (const float of floats) floatsCacheMap.set(float, new ConstNode(float));\nfor (const float of floats) floatsCacheMap.set(-float, new ConstNode(-float));\nconst cacheMaps = {\n  bool: boolsCacheMap,\n  uint: uintsCacheMap,\n  ints: intsCacheMap,\n  float: floatsCacheMap\n};\nconst constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\nconst getConstNode = (value, type) => {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value, type);\n  }\n};\nconst safeGetNodeType = node => {\n  try {\n    return node.getNodeType();\n  } catch (_) {\n    return undefined;\n  }\n};\nconst ConvertType = function (type) {\n  let cacheMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function () {\n    for (var _len10 = arguments.length, params = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      params[_key10] = arguments[_key10];\n    }\n    if (params.length === 0 || !['bool', 'float', 'int', 'uint'].includes(type) && params.every(param => typeof param !== 'object')) {\n      params = [getValueFromType(type, ...params)];\n    }\n    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n      return nodeObject(cacheMap.get(params[0]));\n    }\n    if (params.length === 1) {\n      const node = getConstNode(params[0], type);\n      if (safeGetNodeType(node) === type) return nodeObject(node);\n      return nodeObject(new ConvertNode(node, type));\n    }\n    const nodes = params.map(param => getConstNode(param));\n    return nodeObject(new JoinNode(nodes, type));\n  };\n};\n\n// exports\n\nconst defined = v => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function\n\n// utils\n\nconst getConstNodeType = value => value !== undefined && value !== null ? value.nodeType || value.convertTo || (typeof value === 'string' ? value : null) : null;\n\n// shader node base\n\nfunction ShaderNode(jsFunc, nodeType) {\n  return new Proxy(new ShaderNodeInternal(jsFunc, nodeType), shaderNodeHandler);\n}\nconst nodeObject = function (val) {\n  let altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return /* new */ShaderNodeObject(val, altType);\n};\nconst nodeObjects = function (val) {\n  let altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return new ShaderNodeObjects(val, altType);\n};\nconst nodeArray = function (val) {\n  let altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return new ShaderNodeArray(val, altType);\n};\nconst nodeProxy = function () {\n  for (var _len11 = arguments.length, params = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n    params[_key11] = arguments[_key11];\n  }\n  return new ShaderNodeProxy(...params);\n};\nconst nodeImmutable = function () {\n  for (var _len12 = arguments.length, params = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n    params[_key12] = arguments[_key12];\n  }\n  return new ShaderNodeImmutable(...params);\n};\nconst Fn = (jsFunc, nodeType) => {\n  const shaderNode = new ShaderNode(jsFunc, nodeType);\n  const fn = function () {\n    let inputs;\n    for (var _len13 = arguments.length, params = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n      params[_key13] = arguments[_key13];\n    }\n    nodeObjects(params);\n    if (params[0] && params[0].isNode) {\n      inputs = [...params];\n    } else {\n      inputs = params[0];\n    }\n    return shaderNode.call(inputs);\n  };\n  fn.shaderNode = shaderNode;\n  fn.setLayout = layout => {\n    shaderNode.setLayout(layout);\n    return fn;\n  };\n  fn.once = () => {\n    shaderNode.once = true;\n    return fn;\n  };\n  return fn;\n};\nconst tslFn = function () {\n  // @deprecated, r168\n\n  console.warn('TSL.ShaderNode: tslFn() has been renamed to Fn().');\n  return Fn(...arguments);\n};\n\n//\n\naddMethodChaining('toGlobal', node => {\n  node.global = true;\n  return node;\n});\n\n//\n\nconst setCurrentStack = stack => {\n  currentStack = stack;\n};\nconst getCurrentStack = () => currentStack;\nconst If = function () {\n  return currentStack.If(...arguments);\n};\nfunction append(node) {\n  if (currentStack) currentStack.add(node);\n  return node;\n}\naddMethodChaining('append', append);\n\n// types\n\nconst color = new ConvertType('color');\nconst float = new ConvertType('float', cacheMaps.float);\nconst int = new ConvertType('int', cacheMaps.ints);\nconst uint = new ConvertType('uint', cacheMaps.uint);\nconst bool = new ConvertType('bool', cacheMaps.bool);\nconst vec2 = new ConvertType('vec2');\nconst ivec2 = new ConvertType('ivec2');\nconst uvec2 = new ConvertType('uvec2');\nconst bvec2 = new ConvertType('bvec2');\nconst vec3 = new ConvertType('vec3');\nconst ivec3 = new ConvertType('ivec3');\nconst uvec3 = new ConvertType('uvec3');\nconst bvec3 = new ConvertType('bvec3');\nconst vec4 = new ConvertType('vec4');\nconst ivec4 = new ConvertType('ivec4');\nconst uvec4 = new ConvertType('uvec4');\nconst bvec4 = new ConvertType('bvec4');\nconst mat2 = new ConvertType('mat2');\nconst mat3 = new ConvertType('mat3');\nconst mat4 = new ConvertType('mat4');\nconst string = function () {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return nodeObject(new ConstNode(value, 'string'));\n};\nconst arrayBuffer = value => nodeObject(new ConstNode(value, 'ArrayBuffer'));\naddMethodChaining('toColor', color);\naddMethodChaining('toFloat', float);\naddMethodChaining('toInt', int);\naddMethodChaining('toUint', uint);\naddMethodChaining('toBool', bool);\naddMethodChaining('toVec2', vec2);\naddMethodChaining('toIVec2', ivec2);\naddMethodChaining('toUVec2', uvec2);\naddMethodChaining('toBVec2', bvec2);\naddMethodChaining('toVec3', vec3);\naddMethodChaining('toIVec3', ivec3);\naddMethodChaining('toUVec3', uvec3);\naddMethodChaining('toBVec3', bvec3);\naddMethodChaining('toVec4', vec4);\naddMethodChaining('toIVec4', ivec4);\naddMethodChaining('toUVec4', uvec4);\naddMethodChaining('toBVec4', bvec4);\naddMethodChaining('toMat2', mat2);\naddMethodChaining('toMat3', mat3);\naddMethodChaining('toMat4', mat4);\n\n// basic nodes\n\nconst element = /*@__PURE__*/nodeProxy(ArrayElementNode);\nconst convert = (node, types) => nodeObject(new ConvertNode(nodeObject(node), types));\nconst split = (node, channels) => nodeObject(new SplitNode(nodeObject(node), channels));\naddMethodChaining('element', element);\naddMethodChaining('convert', convert);\nclass UniformGroupNode extends Node {\n  static get type() {\n    return 'UniformGroupNode';\n  }\n  constructor(name) {\n    let shared = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    super('string');\n    this.name = name;\n    this.version = 0;\n    this.shared = shared;\n    this.order = order;\n    this.isUniformGroup = true;\n  }\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.name = this.name;\n    data.version = this.version;\n    data.shared = this.shared;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.name = data.name;\n    this.version = data.version;\n    this.shared = data.shared;\n  }\n}\nconst uniformGroup = name => new UniformGroupNode(name);\nconst sharedUniformGroup = function (name) {\n  let order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return new UniformGroupNode(name, true, order);\n};\nconst frameGroup = /*@__PURE__*/sharedUniformGroup('frame');\nconst renderGroup = /*@__PURE__*/sharedUniformGroup('render');\nconst objectGroup = /*@__PURE__*/uniformGroup('object');\nclass UniformNode extends InputNode {\n  static get type() {\n    return 'UniformNode';\n  }\n  constructor(value) {\n    let nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(value, nodeType);\n    this.isUniformNode = true;\n    this.name = '';\n    this.groupNode = objectGroup;\n  }\n  label(name) {\n    this.name = name;\n    return this;\n  }\n  setGroup(group) {\n    this.groupNode = group;\n    return this;\n  }\n  getGroup() {\n    return this.groupNode;\n  }\n  getUniformHash(builder) {\n    return this.getHash(builder);\n  }\n  onUpdate(callback, updateType) {\n    const self = this.getSelf();\n    callback = callback.bind(self);\n    return super.onUpdate(frame => {\n      const value = callback(frame, self);\n      if (value !== undefined) {\n        this.value = value;\n      }\n    }, updateType);\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    const hash = this.getUniformHash(builder);\n    let sharedNode = builder.getNodeFromHash(hash);\n    if (sharedNode === undefined) {\n      builder.setHashNode(this, hash);\n      sharedNode = this;\n    }\n    const sharedNodeType = sharedNode.getInputType(builder);\n    const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label);\n    const propertyName = builder.getPropertyName(nodeUniform);\n    if (builder.context.label !== undefined) delete builder.context.label;\n    return builder.format(propertyName, type, output);\n  }\n}\nconst uniform = (arg1, arg2) => {\n  const nodeType = getConstNodeType(arg2 || arg1);\n\n  // @TODO: get ConstNode from .traverse() in the future\n  const value = arg1 && arg1.isNode === true ? arg1.node && arg1.node.value || arg1.value : arg1;\n  return nodeObject(new UniformNode(value, nodeType));\n};\nclass PropertyNode extends Node {\n  static get type() {\n    return 'PropertyNode';\n  }\n  constructor(nodeType) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let varying = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    super(nodeType);\n    this.name = name;\n    this.varying = varying;\n    this.isPropertyNode = true;\n  }\n  getHash(builder) {\n    return this.name || super.getHash(builder);\n  }\n  isGlobal(/*builder*/\n  ) {\n    return true;\n  }\n  generate(builder) {\n    let nodeVar;\n    if (this.varying === true) {\n      nodeVar = builder.getVaryingFromNode(this, this.name);\n      nodeVar.needsInterpolation = true;\n    } else {\n      nodeVar = builder.getVarFromNode(this, this.name);\n    }\n    return builder.getPropertyName(nodeVar);\n  }\n}\nconst property = (type, name) => nodeObject(new PropertyNode(type, name));\nconst varyingProperty = (type, name) => nodeObject(new PropertyNode(type, name, true));\nconst diffuseColor = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec4', 'DiffuseColor');\nconst emissive = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'EmissiveColor');\nconst roughness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Roughness');\nconst metalness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Metalness');\nconst clearcoat = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Clearcoat');\nconst clearcoatRoughness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'ClearcoatRoughness');\nconst sheen = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'Sheen');\nconst sheenRoughness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'SheenRoughness');\nconst iridescence = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Iridescence');\nconst iridescenceIOR = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'IridescenceIOR');\nconst iridescenceThickness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'IridescenceThickness');\nconst alphaT = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'AlphaT');\nconst anisotropy = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Anisotropy');\nconst anisotropyT = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'AnisotropyT');\nconst anisotropyB = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'AnisotropyB');\nconst specularColor = /*@__PURE__*/nodeImmutable(PropertyNode, 'color', 'SpecularColor');\nconst specularF90 = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'SpecularF90');\nconst shininess = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Shininess');\nconst output = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec4', 'Output');\nconst dashSize = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'dashSize');\nconst gapSize = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'gapSize');\nconst pointWidth = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'pointWidth');\nconst ior = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'IOR');\nconst transmission = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Transmission');\nconst thickness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Thickness');\nconst attenuationDistance = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'AttenuationDistance');\nconst attenuationColor = /*@__PURE__*/nodeImmutable(PropertyNode, 'color', 'AttenuationColor');\nconst dispersion = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Dispersion');\nclass AssignNode extends TempNode {\n  static get type() {\n    return 'AssignNode';\n  }\n  constructor(targetNode, sourceNode) {\n    super();\n    this.targetNode = targetNode;\n    this.sourceNode = sourceNode;\n  }\n  hasDependencies() {\n    return false;\n  }\n  getNodeType(builder, output) {\n    return output !== 'void' ? this.targetNode.getNodeType(builder) : 'void';\n  }\n  needsSplitAssign(builder) {\n    const {\n      targetNode\n    } = this;\n    if (builder.isAvailable('swizzleAssign') === false && targetNode.isSplitNode && targetNode.components.length > 1) {\n      const targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));\n      const assignDiferentVector = vectorComponents.join('').slice(0, targetLength) !== targetNode.components;\n      return assignDiferentVector;\n    }\n    return false;\n  }\n  generate(builder, output) {\n    const {\n      targetNode,\n      sourceNode\n    } = this;\n    const needsSplitAssign = this.needsSplitAssign(builder);\n    const targetType = targetNode.getNodeType(builder);\n    const target = targetNode.context({\n      assign: true\n    }).build(builder);\n    const source = sourceNode.build(builder, targetType);\n    const sourceType = sourceNode.getNodeType(builder);\n    const nodeData = builder.getDataFromNode(this);\n\n    //\n\n    let snippet;\n    if (nodeData.initialized === true) {\n      if (output !== 'void') {\n        snippet = target;\n      }\n    } else if (needsSplitAssign) {\n      const sourceVar = builder.getVarFromNode(this, null, targetType);\n      const sourceProperty = builder.getPropertyName(sourceVar);\n      builder.addLineFlowCode(`${sourceProperty} = ${source}`, this);\n      const targetRoot = targetNode.node.context({\n        assign: true\n      }).build(builder);\n      for (let i = 0; i < targetNode.components.length; i++) {\n        const component = targetNode.components[i];\n        builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} ]`, this);\n      }\n      if (output !== 'void') {\n        snippet = target;\n      }\n    } else {\n      snippet = `${target} = ${source}`;\n      if (output === 'void' || sourceType === 'void') {\n        builder.addLineFlowCode(snippet, this);\n        if (output !== 'void') {\n          snippet = target;\n        }\n      }\n    }\n    nodeData.initialized = true;\n    return builder.format(snippet, targetType, output);\n  }\n}\nconst assign = /*@__PURE__*/nodeProxy(AssignNode);\naddMethodChaining('assign', assign);\nclass FunctionCallNode extends TempNode {\n  static get type() {\n    return 'FunctionCallNode';\n  }\n  constructor() {\n    let functionNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.functionNode = functionNode;\n    this.parameters = parameters;\n  }\n  setParameters(parameters) {\n    this.parameters = parameters;\n    return this;\n  }\n  getParameters() {\n    return this.parameters;\n  }\n  getNodeType(builder) {\n    return this.functionNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const params = [];\n    const functionNode = this.functionNode;\n    const inputs = functionNode.getInputs(builder);\n    const parameters = this.parameters;\n    const generateInput = (node, inputNode) => {\n      const type = inputNode.type;\n      const pointer = type === 'pointer';\n      let output;\n      if (pointer) output = '&' + node.build(builder);else output = node.build(builder, type);\n      return output;\n    };\n    if (Array.isArray(parameters)) {\n      for (let i = 0; i < parameters.length; i++) {\n        params.push(generateInput(parameters[i], inputs[i]));\n      }\n    } else {\n      for (const inputNode of inputs) {\n        const node = parameters[inputNode.name];\n        if (node !== undefined) {\n          params.push(generateInput(node, inputNode));\n        } else {\n          throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);\n        }\n      }\n    }\n    const functionName = functionNode.build(builder, 'property');\n    return `${functionName}( ${params.join(', ')} )`;\n  }\n}\nconst call = function (func) {\n  for (var _len14 = arguments.length, params = new Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {\n    params[_key14 - 1] = arguments[_key14];\n  }\n  params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);\n  return nodeObject(new FunctionCallNode(nodeObject(func), params));\n};\naddMethodChaining('call', call);\nclass OperatorNode extends TempNode {\n  static get type() {\n    return 'OperatorNode';\n  }\n  constructor(op, aNode, bNode) {\n    super();\n    if ((arguments.length <= 3 ? 0 : arguments.length - 3) > 0) {\n      var _ref;\n      let finalOp = new OperatorNode(op, aNode, bNode);\n      for (let i = 0; i < (arguments.length <= 3 ? 0 : arguments.length - 3) - 1; i++) {\n        finalOp = new OperatorNode(op, finalOp, i + 3 < 3 || arguments.length <= i + 3 ? undefined : arguments[i + 3]);\n      }\n      aNode = finalOp;\n      bNode = (_ref = (arguments.length <= 3 ? 0 : arguments.length - 3) - 1 + 3, _ref < 3 || arguments.length <= _ref ? undefined : arguments[_ref]);\n    }\n    this.op = op;\n    this.aNode = aNode;\n    this.bNode = bNode;\n  }\n  getNodeType(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const typeA = aNode.getNodeType(builder);\n    const typeB = typeof bNode !== 'undefined' ? bNode.getNodeType(builder) : null;\n    if (typeA === 'void' || typeB === 'void') {\n      return 'void';\n    } else if (op === '%') {\n      return typeA;\n    } else if (op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<') {\n      return builder.getIntegerType(typeA);\n    } else if (op === '!' || op === '==' || op === '&&' || op === '||' || op === '^^') {\n      return 'bool';\n    } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {\n      const typeLength = output ? builder.getTypeLength(output) : Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));\n      return typeLength > 1 ? `bvec${typeLength}` : 'bool';\n    } else {\n      if (typeA === 'float' && builder.isMatrix(typeB)) {\n        return typeB;\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n\n        return builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n\n        return builder.getVectorFromMatrix(typeB);\n      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {\n        // anytype x anytype: use the greater length vector\n\n        return typeB;\n      }\n      return typeA;\n    }\n  }\n  generate(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const type = this.getNodeType(builder, output);\n    let typeA = null;\n    let typeB = null;\n    if (type !== 'void') {\n      typeA = aNode.getNodeType(builder);\n      typeB = typeof bNode !== 'undefined' ? bNode.getNodeType(builder) : null;\n      if (op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==') {\n        if (builder.isVector(typeA)) {\n          typeB = typeA;\n        } else if (typeA !== typeB) {\n          typeA = typeB = 'float';\n        }\n      } else if (op === '>>' || op === '<<') {\n        typeA = type;\n        typeB = builder.changeComponentType(typeB, 'uint');\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n\n        typeB = builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n\n        typeA = builder.getVectorFromMatrix(typeB);\n      } else {\n        // anytype x anytype\n\n        typeA = typeB = type;\n      }\n    } else {\n      typeA = typeB = type;\n    }\n    const a = aNode.build(builder, typeA);\n    const b = typeof bNode !== 'undefined' ? bNode.build(builder, typeB) : null;\n    const outputLength = builder.getTypeLength(output);\n    const fnOpSnippet = builder.getFunctionOperator(op);\n    if (output !== 'void') {\n      if (op === '<' && outputLength > 1) {\n        if (builder.useComparisonMethod) {\n          return builder.format(`${builder.getMethod('lessThan', output)}( ${a}, ${b} )`, type, output);\n        } else {\n          return builder.format(`( ${a} < ${b} )`, type, output);\n        }\n      } else if (op === '<=' && outputLength > 1) {\n        if (builder.useComparisonMethod) {\n          return builder.format(`${builder.getMethod('lessThanEqual', output)}( ${a}, ${b} )`, type, output);\n        } else {\n          return builder.format(`( ${a} <= ${b} )`, type, output);\n        }\n      } else if (op === '>' && outputLength > 1) {\n        if (builder.useComparisonMethod) {\n          return builder.format(`${builder.getMethod('greaterThan', output)}( ${a}, ${b} )`, type, output);\n        } else {\n          return builder.format(`( ${a} > ${b} )`, type, output);\n        }\n      } else if (op === '>=' && outputLength > 1) {\n        if (builder.useComparisonMethod) {\n          return builder.format(`${builder.getMethod('greaterThanEqual', output)}( ${a}, ${b} )`, type, output);\n        } else {\n          return builder.format(`( ${a} >= ${b} )`, type, output);\n        }\n      } else if (op === '!' || op === '~') {\n        return builder.format(`(${op}${a})`, typeA, output);\n      } else if (fnOpSnippet) {\n        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output);\n      } else {\n        return builder.format(`( ${a} ${op} ${b} )`, type, output);\n      }\n    } else if (typeA !== 'void') {\n      if (fnOpSnippet) {\n        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output);\n      } else {\n        return builder.format(`${a} ${op} ${b}`, type, output);\n      }\n    }\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.op = this.op;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.op = data.op;\n  }\n}\nconst add = /*@__PURE__*/nodeProxy(OperatorNode, '+');\nconst sub = /*@__PURE__*/nodeProxy(OperatorNode, '-');\nconst mul = /*@__PURE__*/nodeProxy(OperatorNode, '*');\nconst div = /*@__PURE__*/nodeProxy(OperatorNode, '/');\nconst modInt = /*@__PURE__*/nodeProxy(OperatorNode, '%');\nconst equal = /*@__PURE__*/nodeProxy(OperatorNode, '==');\nconst notEqual = /*@__PURE__*/nodeProxy(OperatorNode, '!=');\nconst lessThan = /*@__PURE__*/nodeProxy(OperatorNode, '<');\nconst greaterThan = /*@__PURE__*/nodeProxy(OperatorNode, '>');\nconst lessThanEqual = /*@__PURE__*/nodeProxy(OperatorNode, '<=');\nconst greaterThanEqual = /*@__PURE__*/nodeProxy(OperatorNode, '>=');\nconst and = /*@__PURE__*/nodeProxy(OperatorNode, '&&');\nconst or = /*@__PURE__*/nodeProxy(OperatorNode, '||');\nconst not = /*@__PURE__*/nodeProxy(OperatorNode, '!');\nconst xor = /*@__PURE__*/nodeProxy(OperatorNode, '^^');\nconst bitAnd = /*@__PURE__*/nodeProxy(OperatorNode, '&');\nconst bitNot = /*@__PURE__*/nodeProxy(OperatorNode, '~');\nconst bitOr = /*@__PURE__*/nodeProxy(OperatorNode, '|');\nconst bitXor = /*@__PURE__*/nodeProxy(OperatorNode, '^');\nconst shiftLeft = /*@__PURE__*/nodeProxy(OperatorNode, '<<');\nconst shiftRight = /*@__PURE__*/nodeProxy(OperatorNode, '>>');\naddMethodChaining('add', add);\naddMethodChaining('sub', sub);\naddMethodChaining('mul', mul);\naddMethodChaining('div', div);\naddMethodChaining('modInt', modInt);\naddMethodChaining('equal', equal);\naddMethodChaining('notEqual', notEqual);\naddMethodChaining('lessThan', lessThan);\naddMethodChaining('greaterThan', greaterThan);\naddMethodChaining('lessThanEqual', lessThanEqual);\naddMethodChaining('greaterThanEqual', greaterThanEqual);\naddMethodChaining('and', and);\naddMethodChaining('or', or);\naddMethodChaining('not', not);\naddMethodChaining('xor', xor);\naddMethodChaining('bitAnd', bitAnd);\naddMethodChaining('bitNot', bitNot);\naddMethodChaining('bitOr', bitOr);\naddMethodChaining('bitXor', bitXor);\naddMethodChaining('shiftLeft', shiftLeft);\naddMethodChaining('shiftRight', shiftRight);\nconst remainder = function () {\n  // @deprecated, r168\n\n  console.warn('TSL.OperatorNode: .remainder() has been renamed to .modInt().');\n  return modInt(...arguments);\n};\naddMethodChaining('remainder', remainder);\nclass MathNode extends TempNode {\n  static get type() {\n    return 'MathNode';\n  }\n  constructor(method, aNode) {\n    let bNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let cNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    super();\n    this.method = method;\n    this.aNode = aNode;\n    this.bNode = bNode;\n    this.cNode = cNode;\n  }\n  getInputType(builder) {\n    const aType = this.aNode.getNodeType(builder);\n    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;\n    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;\n    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);\n    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);\n    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);\n    if (aLen > bLen && aLen > cLen) {\n      return aType;\n    } else if (bLen > cLen) {\n      return bType;\n    } else if (cLen > aLen) {\n      return cType;\n    }\n    return aType;\n  }\n  getNodeType(builder) {\n    const method = this.method;\n    if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {\n      return 'float';\n    } else if (method === MathNode.CROSS) {\n      return 'vec3';\n    } else if (method === MathNode.ALL) {\n      return 'bool';\n    } else if (method === MathNode.EQUALS) {\n      return builder.changeComponentType(this.aNode.getNodeType(builder), 'bool');\n    } else if (method === MathNode.MOD) {\n      return this.aNode.getNodeType(builder);\n    } else {\n      return this.getInputType(builder);\n    }\n  }\n  generate(builder, output) {\n    const method = this.method;\n    const type = this.getNodeType(builder);\n    const inputType = this.getInputType(builder);\n    const a = this.aNode;\n    const b = this.bNode;\n    const c = this.cNode;\n    const isWebGL = builder.renderer.isWebGLRenderer === true;\n    if (method === MathNode.TRANSFORM_DIRECTION) {\n      // dir can be either a direction vector or a normal vector\n      // upper-left 3x3 of matrix is assumed to be orthogonal\n\n      let tA = a;\n      let tB = b;\n      if (builder.isMatrix(tA.getNodeType(builder))) {\n        tB = vec4(vec3(tB), 0.0);\n      } else {\n        tA = vec4(vec3(tA), 0.0);\n      }\n      const mulNode = mul(tA, tB).xyz;\n      return normalize(mulNode).build(builder, output);\n    } else if (method === MathNode.NEGATE) {\n      return builder.format('( - ' + a.build(builder, inputType) + ' )', type, output);\n    } else if (method === MathNode.ONE_MINUS) {\n      return sub(1.0, a).build(builder, output);\n    } else if (method === MathNode.RECIPROCAL) {\n      return div(1.0, a).build(builder, output);\n    } else if (method === MathNode.DIFFERENCE) {\n      return abs(sub(a, b)).build(builder, output);\n    } else {\n      const params = [];\n      if (method === MathNode.CROSS || method === MathNode.MOD) {\n        params.push(a.build(builder, type), b.build(builder, type));\n      } else if (isWebGL && method === MathNode.STEP) {\n        params.push(a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? 'float' : inputType), b.build(builder, inputType));\n      } else if (isWebGL && (method === MathNode.MIN || method === MathNode.MAX) || method === MathNode.MOD) {\n        params.push(a.build(builder, inputType), b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? 'float' : inputType));\n      } else if (method === MathNode.REFRACT) {\n        params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, 'float'));\n      } else if (method === MathNode.MIX) {\n        params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? 'float' : inputType));\n      } else {\n        params.push(a.build(builder, inputType));\n        if (b !== null) params.push(b.build(builder, inputType));\n        if (c !== null) params.push(c.build(builder, inputType));\n      }\n      return builder.format(`${builder.getMethod(method, type)}( ${params.join(', ')} )`, type, output);\n    }\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.method = this.method;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.method = data.method;\n  }\n}\n\n// 1 input\n\nMathNode.ALL = 'all';\nMathNode.ANY = 'any';\nMathNode.EQUALS = 'equals';\nMathNode.RADIANS = 'radians';\nMathNode.DEGREES = 'degrees';\nMathNode.EXP = 'exp';\nMathNode.EXP2 = 'exp2';\nMathNode.LOG = 'log';\nMathNode.LOG2 = 'log2';\nMathNode.SQRT = 'sqrt';\nMathNode.INVERSE_SQRT = 'inversesqrt';\nMathNode.FLOOR = 'floor';\nMathNode.CEIL = 'ceil';\nMathNode.NORMALIZE = 'normalize';\nMathNode.FRACT = 'fract';\nMathNode.SIN = 'sin';\nMathNode.COS = 'cos';\nMathNode.TAN = 'tan';\nMathNode.ASIN = 'asin';\nMathNode.ACOS = 'acos';\nMathNode.ATAN = 'atan';\nMathNode.ABS = 'abs';\nMathNode.SIGN = 'sign';\nMathNode.LENGTH = 'length';\nMathNode.NEGATE = 'negate';\nMathNode.ONE_MINUS = 'oneMinus';\nMathNode.DFDX = 'dFdx';\nMathNode.DFDY = 'dFdy';\nMathNode.ROUND = 'round';\nMathNode.RECIPROCAL = 'reciprocal';\nMathNode.TRUNC = 'trunc';\nMathNode.FWIDTH = 'fwidth';\nMathNode.BITCAST = 'bitcast';\nMathNode.TRANSPOSE = 'transpose';\n\n// 2 inputs\n\nMathNode.ATAN2 = 'atan2';\nMathNode.MIN = 'min';\nMathNode.MAX = 'max';\nMathNode.MOD = 'mod';\nMathNode.STEP = 'step';\nMathNode.REFLECT = 'reflect';\nMathNode.DISTANCE = 'distance';\nMathNode.DIFFERENCE = 'difference';\nMathNode.DOT = 'dot';\nMathNode.CROSS = 'cross';\nMathNode.POW = 'pow';\nMathNode.TRANSFORM_DIRECTION = 'transformDirection';\n\n// 3 inputs\n\nMathNode.MIX = 'mix';\nMathNode.CLAMP = 'clamp';\nMathNode.REFRACT = 'refract';\nMathNode.SMOOTHSTEP = 'smoothstep';\nMathNode.FACEFORWARD = 'faceforward';\nconst EPSILON = /*@__PURE__*/float(1e-6);\nconst INFINITY = /*@__PURE__*/float(1e6);\nconst PI = /*@__PURE__*/float(Math.PI);\nconst PI2 = /*@__PURE__*/float(Math.PI * 2);\nconst all = /*@__PURE__*/nodeProxy(MathNode, MathNode.ALL);\nconst any = /*@__PURE__*/nodeProxy(MathNode, MathNode.ANY);\nconst equals = /*@__PURE__*/nodeProxy(MathNode, MathNode.EQUALS);\nconst radians = /*@__PURE__*/nodeProxy(MathNode, MathNode.RADIANS);\nconst degrees = /*@__PURE__*/nodeProxy(MathNode, MathNode.DEGREES);\nconst exp = /*@__PURE__*/nodeProxy(MathNode, MathNode.EXP);\nconst exp2 = /*@__PURE__*/nodeProxy(MathNode, MathNode.EXP2);\nconst log = /*@__PURE__*/nodeProxy(MathNode, MathNode.LOG);\nconst log2 = /*@__PURE__*/nodeProxy(MathNode, MathNode.LOG2);\nconst sqrt = /*@__PURE__*/nodeProxy(MathNode, MathNode.SQRT);\nconst inverseSqrt = /*@__PURE__*/nodeProxy(MathNode, MathNode.INVERSE_SQRT);\nconst floor = /*@__PURE__*/nodeProxy(MathNode, MathNode.FLOOR);\nconst ceil = /*@__PURE__*/nodeProxy(MathNode, MathNode.CEIL);\nconst normalize = /*@__PURE__*/nodeProxy(MathNode, MathNode.NORMALIZE);\nconst fract = /*@__PURE__*/nodeProxy(MathNode, MathNode.FRACT);\nconst sin = /*@__PURE__*/nodeProxy(MathNode, MathNode.SIN);\nconst cos = /*@__PURE__*/nodeProxy(MathNode, MathNode.COS);\nconst tan = /*@__PURE__*/nodeProxy(MathNode, MathNode.TAN);\nconst asin = /*@__PURE__*/nodeProxy(MathNode, MathNode.ASIN);\nconst acos = /*@__PURE__*/nodeProxy(MathNode, MathNode.ACOS);\nconst atan = /*@__PURE__*/nodeProxy(MathNode, MathNode.ATAN);\nconst abs = /*@__PURE__*/nodeProxy(MathNode, MathNode.ABS);\nconst sign = /*@__PURE__*/nodeProxy(MathNode, MathNode.SIGN);\nconst length = /*@__PURE__*/nodeProxy(MathNode, MathNode.LENGTH);\nconst negate = /*@__PURE__*/nodeProxy(MathNode, MathNode.NEGATE);\nconst oneMinus = /*@__PURE__*/nodeProxy(MathNode, MathNode.ONE_MINUS);\nconst dFdx = /*@__PURE__*/nodeProxy(MathNode, MathNode.DFDX);\nconst dFdy = /*@__PURE__*/nodeProxy(MathNode, MathNode.DFDY);\nconst round = /*@__PURE__*/nodeProxy(MathNode, MathNode.ROUND);\nconst reciprocal = /*@__PURE__*/nodeProxy(MathNode, MathNode.RECIPROCAL);\nconst trunc = /*@__PURE__*/nodeProxy(MathNode, MathNode.TRUNC);\nconst fwidth = /*@__PURE__*/nodeProxy(MathNode, MathNode.FWIDTH);\nconst bitcast = /*@__PURE__*/nodeProxy(MathNode, MathNode.BITCAST);\nconst transpose = /*@__PURE__*/nodeProxy(MathNode, MathNode.TRANSPOSE);\nconst atan2 = /*@__PURE__*/nodeProxy(MathNode, MathNode.ATAN2);\nconst min$1 = /*@__PURE__*/nodeProxy(MathNode, MathNode.MIN);\nconst max$1 = /*@__PURE__*/nodeProxy(MathNode, MathNode.MAX);\nconst mod = /*@__PURE__*/nodeProxy(MathNode, MathNode.MOD);\nconst step = /*@__PURE__*/nodeProxy(MathNode, MathNode.STEP);\nconst reflect = /*@__PURE__*/nodeProxy(MathNode, MathNode.REFLECT);\nconst distance = /*@__PURE__*/nodeProxy(MathNode, MathNode.DISTANCE);\nconst difference = /*@__PURE__*/nodeProxy(MathNode, MathNode.DIFFERENCE);\nconst dot = /*@__PURE__*/nodeProxy(MathNode, MathNode.DOT);\nconst cross = /*@__PURE__*/nodeProxy(MathNode, MathNode.CROSS);\nconst pow = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW);\nconst pow2 = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW, 2);\nconst pow3 = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW, 3);\nconst pow4 = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW, 4);\nconst transformDirection = /*@__PURE__*/nodeProxy(MathNode, MathNode.TRANSFORM_DIRECTION);\nconst cbrt = a => mul(sign(a), pow(abs(a), 1.0 / 3.0));\nconst lengthSq = a => dot(a, a);\nconst mix = /*@__PURE__*/nodeProxy(MathNode, MathNode.MIX);\nconst clamp = function (value) {\n  let low = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let high = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));\n};\nconst saturate = value => clamp(value);\nconst refract = /*@__PURE__*/nodeProxy(MathNode, MathNode.REFRACT);\nconst smoothstep = /*@__PURE__*/nodeProxy(MathNode, MathNode.SMOOTHSTEP);\nconst faceForward = /*@__PURE__*/nodeProxy(MathNode, MathNode.FACEFORWARD);\nconst rand = /*@__PURE__*/Fn(_ref2 => {\n  let [uv] = _ref2;\n  const a = 12.9898,\n    b = 78.233,\n    c = 43758.5453;\n  const dt = dot(uv.xy, vec2(a, b)),\n    sn = mod(dt, PI);\n  return fract(sin(sn).mul(c));\n});\nconst mixElement = (t, e1, e2) => mix(e1, e2, t);\nconst smoothstepElement = (x, low, high) => smoothstep(low, high, x);\naddMethodChaining('all', all);\naddMethodChaining('any', any);\naddMethodChaining('equals', equals);\naddMethodChaining('radians', radians);\naddMethodChaining('degrees', degrees);\naddMethodChaining('exp', exp);\naddMethodChaining('exp2', exp2);\naddMethodChaining('log', log);\naddMethodChaining('log2', log2);\naddMethodChaining('sqrt', sqrt);\naddMethodChaining('inverseSqrt', inverseSqrt);\naddMethodChaining('floor', floor);\naddMethodChaining('ceil', ceil);\naddMethodChaining('normalize', normalize);\naddMethodChaining('fract', fract);\naddMethodChaining('sin', sin);\naddMethodChaining('cos', cos);\naddMethodChaining('tan', tan);\naddMethodChaining('asin', asin);\naddMethodChaining('acos', acos);\naddMethodChaining('atan', atan);\naddMethodChaining('abs', abs);\naddMethodChaining('sign', sign);\naddMethodChaining('length', length);\naddMethodChaining('lengthSq', lengthSq);\naddMethodChaining('negate', negate);\naddMethodChaining('oneMinus', oneMinus);\naddMethodChaining('dFdx', dFdx);\naddMethodChaining('dFdy', dFdy);\naddMethodChaining('round', round);\naddMethodChaining('reciprocal', reciprocal);\naddMethodChaining('trunc', trunc);\naddMethodChaining('fwidth', fwidth);\naddMethodChaining('atan2', atan2);\naddMethodChaining('min', min$1);\naddMethodChaining('max', max$1);\naddMethodChaining('mod', mod);\naddMethodChaining('step', step);\naddMethodChaining('reflect', reflect);\naddMethodChaining('distance', distance);\naddMethodChaining('dot', dot);\naddMethodChaining('cross', cross);\naddMethodChaining('pow', pow);\naddMethodChaining('pow2', pow2);\naddMethodChaining('pow3', pow3);\naddMethodChaining('pow4', pow4);\naddMethodChaining('transformDirection', transformDirection);\naddMethodChaining('mix', mixElement);\naddMethodChaining('clamp', clamp);\naddMethodChaining('refract', refract);\naddMethodChaining('smoothstep', smoothstepElement);\naddMethodChaining('faceForward', faceForward);\naddMethodChaining('difference', difference);\naddMethodChaining('saturate', saturate);\naddMethodChaining('cbrt', cbrt);\naddMethodChaining('transpose', transpose);\naddMethodChaining('rand', rand);\nclass ConditionalNode extends Node {\n  static get type() {\n    return 'ConditionalNode';\n  }\n  constructor(condNode, ifNode) {\n    let elseNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    super();\n    this.condNode = condNode;\n    this.ifNode = ifNode;\n    this.elseNode = elseNode;\n  }\n  getNodeType(builder) {\n    const ifType = this.ifNode.getNodeType(builder);\n    if (this.elseNode !== null) {\n      const elseType = this.elseNode.getNodeType(builder);\n      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {\n        return elseType;\n      }\n    }\n    return ifType;\n  }\n  setup(builder) {\n    const condNode = this.condNode.cache();\n    const ifNode = this.ifNode.cache();\n    const elseNode = this.elseNode ? this.elseNode.cache() : null;\n\n    //\n\n    const currentNodeBlock = builder.context.nodeBlock;\n    builder.getDataFromNode(ifNode).parentNodeBlock = currentNodeBlock;\n    if (elseNode !== null) builder.getDataFromNode(elseNode).parentNodeBlock = currentNodeBlock;\n\n    //\n\n    const properties = builder.getNodeProperties(this);\n    properties.condNode = condNode;\n    properties.ifNode = ifNode.context({\n      nodeBlock: ifNode\n    });\n    properties.elseNode = elseNode ? elseNode.context({\n      nodeBlock: elseNode\n    }) : null;\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    const nodeData = builder.getDataFromNode(this);\n    if (nodeData.nodeProperty !== undefined) {\n      return nodeData.nodeProperty;\n    }\n    const {\n      condNode,\n      ifNode,\n      elseNode\n    } = builder.getNodeProperties(this);\n    const needsOutput = output !== 'void';\n    const nodeProperty = needsOutput ? property(type).build(builder) : '';\n    nodeData.nodeProperty = nodeProperty;\n    const nodeSnippet = condNode.build(builder, 'bool');\n    builder.addFlowCode(`\\n${builder.tab}if ( ${nodeSnippet} ) {\\n\\n`).addFlowTab();\n    let ifSnippet = ifNode.build(builder, type);\n    if (ifSnippet) {\n      if (needsOutput) {\n        ifSnippet = nodeProperty + ' = ' + ifSnippet + ';';\n      } else {\n        ifSnippet = 'return ' + ifSnippet + ';';\n      }\n    }\n    builder.removeFlowTab().addFlowCode(builder.tab + '\\t' + ifSnippet + '\\n\\n' + builder.tab + '}');\n    if (elseNode !== null) {\n      builder.addFlowCode(' else {\\n\\n').addFlowTab();\n      let elseSnippet = elseNode.build(builder, type);\n      if (elseSnippet) {\n        if (needsOutput) {\n          elseSnippet = nodeProperty + ' = ' + elseSnippet + ';';\n        } else {\n          elseSnippet = 'return ' + elseSnippet + ';';\n        }\n      }\n      builder.removeFlowTab().addFlowCode(builder.tab + '\\t' + elseSnippet + '\\n\\n' + builder.tab + '}\\n\\n');\n    } else {\n      builder.addFlowCode('\\n\\n');\n    }\n    return builder.format(nodeProperty, type, output);\n  }\n}\nconst select = /*@__PURE__*/nodeProxy(ConditionalNode);\naddMethodChaining('select', select);\n\n//\n\nconst cond = function () {\n  // @deprecated, r168\n\n  console.warn('TSL.ConditionalNode: cond() has been renamed to select().');\n  return select(...arguments);\n};\naddMethodChaining('cond', cond);\nclass ContextNode extends Node {\n  static get type() {\n    return 'ContextNode';\n  }\n  constructor(node) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.isContextNode = true;\n    this.node = node;\n    this.value = value;\n  }\n  getScope() {\n    return this.node.getScope();\n  }\n  getNodeType(builder) {\n    return this.node.getNodeType(builder);\n  }\n  analyze(builder) {\n    this.node.build(builder);\n  }\n  setup(builder) {\n    const previousContext = builder.getContext();\n    builder.setContext({\n      ...builder.context,\n      ...this.value\n    });\n    const node = this.node.build(builder);\n    builder.setContext(previousContext);\n    return node;\n  }\n  generate(builder, output) {\n    const previousContext = builder.getContext();\n    builder.setContext({\n      ...builder.context,\n      ...this.value\n    });\n    const snippet = this.node.build(builder, output);\n    builder.setContext(previousContext);\n    return snippet;\n  }\n}\nconst context = /*@__PURE__*/nodeProxy(ContextNode);\nconst label = (node, name) => context(node, {\n  label: name\n});\naddMethodChaining('context', context);\naddMethodChaining('label', label);\nclass VarNode extends Node {\n  static get type() {\n    return 'VarNode';\n  }\n  constructor(node) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super();\n    this.node = node;\n    this.name = name;\n    this.global = true;\n    this.isVarNode = true;\n  }\n  getHash(builder) {\n    return this.name || super.getHash(builder);\n  }\n  getNodeType(builder) {\n    return this.node.getNodeType(builder);\n  }\n  generate(builder) {\n    const {\n      node,\n      name\n    } = this;\n    const nodeVar = builder.getVarFromNode(this, name, builder.getVectorType(this.getNodeType(builder)));\n    const propertyName = builder.getPropertyName(nodeVar);\n    const snippet = node.build(builder, nodeVar.type);\n    builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);\n    return propertyName;\n  }\n}\nconst createVar = /*@__PURE__*/nodeProxy(VarNode);\naddMethodChaining('toVar', function () {\n  return createVar(...arguments).append();\n});\n\n// Deprecated\n\nconst temp = node => {\n  // @deprecated, r170\n\n  console.warn('TSL: \"temp\" is deprecated. Use \".toVar()\" instead.');\n  return createVar(node);\n};\naddMethodChaining('temp', temp);\nclass VaryingNode extends Node {\n  static get type() {\n    return 'VaryingNode';\n  }\n  constructor(node) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super();\n    this.node = node;\n    this.name = name;\n    this.isVaryingNode = true;\n  }\n  isGlobal() {\n    return true;\n  }\n  getHash(builder) {\n    return this.name || super.getHash(builder);\n  }\n  getNodeType(builder) {\n    // VaryingNode is auto type\n\n    return this.node.getNodeType(builder);\n  }\n  setupVarying(builder) {\n    const properties = builder.getNodeProperties(this);\n    let varying = properties.varying;\n    if (varying === undefined) {\n      const name = this.name;\n      const type = this.getNodeType(builder);\n      properties.varying = varying = builder.getVaryingFromNode(this, name, type);\n      properties.node = this.node;\n    }\n\n    // this property can be used to check if the varying can be optimized for a variable\n    varying.needsInterpolation || (varying.needsInterpolation = builder.shaderStage === 'fragment');\n    return varying;\n  }\n  setup(builder) {\n    this.setupVarying(builder);\n  }\n  analyze(builder) {\n    this.setupVarying(builder);\n    return this.node.analyze(builder);\n  }\n  generate(builder) {\n    const properties = builder.getNodeProperties(this);\n    const varying = this.setupVarying(builder);\n    if (properties.propertyName === undefined) {\n      const type = this.getNodeType(builder);\n      const propertyName = builder.getPropertyName(varying, NodeShaderStage.VERTEX);\n\n      // force node run in vertex stage\n      builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node, type, propertyName);\n      properties.propertyName = propertyName;\n    }\n    return builder.getPropertyName(varying);\n  }\n}\nconst varying = /*@__PURE__*/nodeProxy(VaryingNode);\naddMethodChaining('varying', varying);\nconst sRGBTransferEOTF = /*@__PURE__*/Fn(_ref3 => {\n  let [color] = _ref3;\n  const a = color.mul(0.9478672986).add(0.0521327014).pow(2.4);\n  const b = color.mul(0.0773993808);\n  const factor = color.lessThanEqual(0.04045);\n  const rgbResult = mix(a, b, factor);\n  return rgbResult;\n}).setLayout({\n  name: 'sRGBTransferEOTF',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }]\n});\nconst sRGBTransferOETF = /*@__PURE__*/Fn(_ref4 => {\n  let [color] = _ref4;\n  const a = color.pow(0.41666).mul(1.055).sub(0.055);\n  const b = color.mul(12.92);\n  const factor = color.lessThanEqual(0.0031308);\n  const rgbResult = mix(a, b, factor);\n  return rgbResult;\n}).setLayout({\n  name: 'sRGBTransferOETF',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }]\n});\nconst WORKING_COLOR_SPACE = 'WorkingColorSpace';\nconst OUTPUT_COLOR_SPACE = 'OutputColorSpace';\nclass ColorSpaceNode extends TempNode {\n  static get type() {\n    return 'ColorSpaceNode';\n  }\n  constructor(colorNode, source, target) {\n    super('vec4');\n    this.colorNode = colorNode;\n    this.source = source;\n    this.target = target;\n  }\n  resolveColorSpace(builder, colorSpace) {\n    if (colorSpace === WORKING_COLOR_SPACE) {\n      return ColorManagement.workingColorSpace;\n    } else if (colorSpace === OUTPUT_COLOR_SPACE) {\n      return builder.context.outputColorSpace || builder.renderer.outputColorSpace;\n    }\n    return colorSpace;\n  }\n  setup(builder) {\n    const {\n      colorNode\n    } = this;\n    const source = this.resolveColorSpace(builder, this.source);\n    const target = this.resolveColorSpace(builder, this.target);\n    let outputNode = colorNode;\n    if (ColorManagement.enabled === false || source === target || !source || !target) {\n      return outputNode;\n    }\n    if (ColorManagement.getTransfer(source) === SRGBTransfer) {\n      outputNode = vec4(sRGBTransferEOTF(outputNode.rgb), outputNode.a);\n    }\n    if (ColorManagement.getPrimaries(source) !== ColorManagement.getPrimaries(target)) {\n      outputNode = vec4(mat3(ColorManagement._getMatrix(new Matrix3(), source, target)).mul(outputNode.rgb), outputNode.a);\n    }\n    if (ColorManagement.getTransfer(target) === SRGBTransfer) {\n      outputNode = vec4(sRGBTransferOETF(outputNode.rgb), outputNode.a);\n    }\n    return outputNode;\n  }\n}\nconst toOutputColorSpace = node => nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, OUTPUT_COLOR_SPACE));\nconst toWorkingColorSpace = node => nodeObject(new ColorSpaceNode(nodeObject(node), OUTPUT_COLOR_SPACE, WORKING_COLOR_SPACE));\nconst workingToColorSpace = (node, colorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, colorSpace));\nconst colorSpaceToWorking = (node, colorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), colorSpace, WORKING_COLOR_SPACE));\nconst convertColorSpace = (node, sourceColorSpace, targetColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), sourceColorSpace, targetColorSpace));\naddMethodChaining('toOutputColorSpace', toOutputColorSpace);\naddMethodChaining('toWorkingColorSpace', toWorkingColorSpace);\naddMethodChaining('workingToColorSpace', workingToColorSpace);\naddMethodChaining('colorSpaceToWorking', colorSpaceToWorking);\nlet ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {\n  static get type() {\n    return 'ReferenceElementNode';\n  }\n  constructor(referenceNode, indexNode) {\n    super(referenceNode, indexNode);\n    this.referenceNode = referenceNode;\n    this.isReferenceElementNode = true;\n  }\n  getNodeType() {\n    return this.referenceNode.uniformType;\n  }\n  generate(builder) {\n    const snippet = super.generate(builder);\n    const arrayType = this.referenceNode.getNodeType();\n    const elementType = this.getNodeType();\n    return builder.format(snippet, arrayType, elementType);\n  }\n};\nclass ReferenceBaseNode extends Node {\n  static get type() {\n    return 'ReferenceBaseNode';\n  }\n  constructor(property, uniformType) {\n    let object = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    super();\n    this.property = property;\n    this.uniformType = uniformType;\n    this.object = object;\n    this.count = count;\n    this.properties = property.split('.');\n    this.reference = object;\n    this.node = null;\n    this.group = null;\n    this.updateType = NodeUpdateType.OBJECT;\n  }\n  setGroup(group) {\n    this.group = group;\n    return this;\n  }\n  element(indexNode) {\n    return nodeObject(new ReferenceElementNode$1(this, nodeObject(indexNode)));\n  }\n  setNodeType(uniformType) {\n    const node = uniform(null, uniformType).getSelf();\n    if (this.group !== null) {\n      node.setGroup(this.group);\n    }\n    this.node = node;\n  }\n  getNodeType(builder) {\n    if (this.node === null) {\n      this.updateReference(builder);\n      this.updateValue();\n    }\n    return this.node.getNodeType(builder);\n  }\n  getValueFromReference() {\n    let object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.reference;\n    const {\n      properties\n    } = this;\n    let value = object[properties[0]];\n    for (let i = 1; i < properties.length; i++) {\n      value = value[properties[i]];\n    }\n    return value;\n  }\n  updateReference(state) {\n    this.reference = this.object !== null ? this.object : state.object;\n    return this.reference;\n  }\n  setup() {\n    this.updateValue();\n    return this.node;\n  }\n  update(/*frame*/\n  ) {\n    this.updateValue();\n  }\n  updateValue() {\n    if (this.node === null) this.setNodeType(this.uniformType);\n    const value = this.getValueFromReference();\n    if (Array.isArray(value)) {\n      this.node.array = value;\n    } else {\n      this.node.value = value;\n    }\n  }\n}\nconst reference$1 = (name, type, object) => nodeObject(new ReferenceBaseNode(name, type, object));\nclass RendererReferenceNode extends ReferenceBaseNode {\n  static get type() {\n    return 'RendererReferenceNode';\n  }\n  constructor(property, inputType) {\n    let renderer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    super(property, inputType, renderer);\n    this.renderer = renderer;\n    this.setGroup(renderGroup);\n  }\n  updateReference(state) {\n    this.reference = this.renderer !== null ? this.renderer : state.renderer;\n    return this.reference;\n  }\n}\nconst rendererReference = (name, type, renderer) => nodeObject(new RendererReferenceNode(name, type, renderer));\nclass ToneMappingNode extends TempNode {\n  static get type() {\n    return 'ToneMappingNode';\n  }\n  constructor(toneMapping) {\n    let exposureNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : toneMappingExposure;\n    let colorNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    super('vec3');\n    this.toneMapping = toneMapping;\n    this.exposureNode = exposureNode;\n    this.colorNode = colorNode;\n  }\n  getCacheKey() {\n    return hash$1(super.getCacheKey(), this.toneMapping);\n  }\n  setup(builder) {\n    const colorNode = this.colorNode || builder.context.color;\n    const toneMapping = this.toneMapping;\n    if (toneMapping === NoToneMapping) return colorNode;\n    let outputNode = null;\n    const toneMappingFn = builder.renderer.library.getToneMappingFunction(toneMapping);\n    if (toneMappingFn !== null) {\n      outputNode = vec4(toneMappingFn(colorNode.rgb, this.exposureNode), colorNode.a);\n    } else {\n      console.error('ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping);\n      outputNode = colorNode;\n    }\n    return outputNode;\n  }\n}\nconst toneMapping = (mapping, exposure, color) => nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color)));\nconst toneMappingExposure = /*@__PURE__*/rendererReference('toneMappingExposure', 'float');\naddMethodChaining('toneMapping', (color, mapping, exposure) => toneMapping(mapping, exposure, color));\nclass BufferAttributeNode extends InputNode {\n  static get type() {\n    return 'BufferAttributeNode';\n  }\n  constructor(value) {\n    let bufferType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let bufferStride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let bufferOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    super(value, bufferType);\n    this.isBufferNode = true;\n    this.bufferType = bufferType;\n    this.bufferStride = bufferStride;\n    this.bufferOffset = bufferOffset;\n    this.usage = StaticDrawUsage;\n    this.instanced = false;\n    this.attribute = null;\n    this.global = true;\n    if (value && value.isBufferAttribute === true) {\n      this.attribute = value;\n      this.usage = value.usage;\n      this.instanced = value.isInstancedBufferAttribute;\n    }\n  }\n  getHash(builder) {\n    if (this.bufferStride === 0 && this.bufferOffset === 0) {\n      let bufferData = builder.globalCache.getData(this.value);\n      if (bufferData === undefined) {\n        bufferData = {\n          node: this\n        };\n        builder.globalCache.setData(this.value, bufferData);\n      }\n      return bufferData.node.uuid;\n    }\n    return this.uuid;\n  }\n  getNodeType(builder) {\n    if (this.bufferType === null) {\n      this.bufferType = builder.getTypeFromAttribute(this.attribute);\n    }\n    return this.bufferType;\n  }\n  setup(builder) {\n    if (this.attribute !== null) return;\n    const type = this.getNodeType(builder);\n    const array = this.value;\n    const itemSize = builder.getTypeLength(type);\n    const stride = this.bufferStride || itemSize;\n    const offset = this.bufferOffset;\n    const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer(array, stride);\n    const bufferAttribute = new InterleavedBufferAttribute(buffer, itemSize, offset);\n    buffer.setUsage(this.usage);\n    this.attribute = bufferAttribute;\n    this.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute\n  }\n  generate(builder) {\n    const nodeType = this.getNodeType(builder);\n    const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);\n    const propertyName = builder.getPropertyName(nodeAttribute);\n    let output = null;\n    if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {\n      this.name = propertyName;\n      output = propertyName;\n    } else {\n      const nodeVarying = varying(this);\n      output = nodeVarying.build(builder, nodeType);\n    }\n    return output;\n  }\n  getInputType(/*builder*/\n  ) {\n    return 'bufferAttribute';\n  }\n  setUsage(value) {\n    this.usage = value;\n    if (this.attribute && this.attribute.isBufferAttribute === true) {\n      this.attribute.usage = value;\n    }\n    return this;\n  }\n  setInstanced(value) {\n    this.instanced = value;\n    return this;\n  }\n}\nconst bufferAttribute = (array, type, stride, offset) => nodeObject(new BufferAttributeNode(array, type, stride, offset));\nconst dynamicBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);\nconst instancedBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setInstanced(true);\nconst instancedDynamicBufferAttribute = (array, type, stride, offset) => dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);\naddMethodChaining('toAttribute', bufferNode => bufferAttribute(bufferNode.value));\nclass ComputeNode extends Node {\n  static get type() {\n    return 'ComputeNode';\n  }\n  constructor(computeNode, count) {\n    let workgroupSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [64];\n    super('void');\n    this.isComputeNode = true;\n    this.computeNode = computeNode;\n    this.count = count;\n    this.workgroupSize = workgroupSize;\n    this.dispatchCount = 0;\n    this.version = 1;\n    this.updateBeforeType = NodeUpdateType.OBJECT;\n    this.onInitFunction = null;\n    this.updateDispatchCount();\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  updateDispatchCount() {\n    const {\n      count,\n      workgroupSize\n    } = this;\n    let size = workgroupSize[0];\n    for (let i = 1; i < workgroupSize.length; i++) size *= workgroupSize[i];\n    this.dispatchCount = Math.ceil(count / size);\n  }\n  onInit(callback) {\n    this.onInitFunction = callback;\n    return this;\n  }\n  updateBefore(_ref5) {\n    let {\n      renderer\n    } = _ref5;\n    renderer.compute(this);\n  }\n  generate(builder) {\n    const {\n      shaderStage\n    } = builder;\n    if (shaderStage === 'compute') {\n      const snippet = this.computeNode.build(builder, 'void');\n      if (snippet !== '') {\n        builder.addLineFlowCode(snippet, this);\n      }\n    }\n  }\n}\nconst compute = (node, count, workgroupSize) => nodeObject(new ComputeNode(nodeObject(node), count, workgroupSize));\naddMethodChaining('compute', compute);\nclass CacheNode extends Node {\n  static get type() {\n    return 'CacheNode';\n  }\n  constructor(node) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    super();\n    this.node = node;\n    this.parent = parent;\n    this.isCacheNode = true;\n  }\n  getNodeType(builder) {\n    return this.node.getNodeType(builder);\n  }\n  build(builder) {\n    const previousCache = builder.getCache();\n    const cache = builder.getCacheFromNode(this, this.parent);\n    builder.setCache(cache);\n    for (var _len15 = arguments.length, params = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {\n      params[_key15 - 1] = arguments[_key15];\n    }\n    const data = this.node.build(builder, ...params);\n    builder.setCache(previousCache);\n    return data;\n  }\n}\nconst cache = function (node) {\n  for (var _len16 = arguments.length, params = new Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) {\n    params[_key16 - 1] = arguments[_key16];\n  }\n  return nodeObject(new CacheNode(nodeObject(node), ...params));\n};\naddMethodChaining('cache', cache);\nclass BypassNode extends Node {\n  static get type() {\n    return 'BypassNode';\n  }\n  constructor(returnNode, callNode) {\n    super();\n    this.isBypassNode = true;\n    this.outputNode = returnNode;\n    this.callNode = callNode;\n  }\n  getNodeType(builder) {\n    return this.outputNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const snippet = this.callNode.build(builder, 'void');\n    if (snippet !== '') {\n      builder.addLineFlowCode(snippet, this);\n    }\n    return this.outputNode.build(builder);\n  }\n}\nconst bypass = /*@__PURE__*/nodeProxy(BypassNode);\naddMethodChaining('bypass', bypass);\nclass RemapNode extends Node {\n  static get type() {\n    return 'RemapNode';\n  }\n  constructor(node, inLowNode, inHighNode) {\n    let outLowNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : float(0);\n    let outHighNode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : float(1);\n    super();\n    this.node = node;\n    this.inLowNode = inLowNode;\n    this.inHighNode = inHighNode;\n    this.outLowNode = outLowNode;\n    this.outHighNode = outHighNode;\n    this.doClamp = true;\n  }\n  setup() {\n    const {\n      node,\n      inLowNode,\n      inHighNode,\n      outLowNode,\n      outHighNode,\n      doClamp\n    } = this;\n    let t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));\n    if (doClamp === true) t = t.clamp();\n    return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);\n  }\n}\nconst remap = /*@__PURE__*/nodeProxy(RemapNode, null, null, {\n  doClamp: false\n});\nconst remapClamp = /*@__PURE__*/nodeProxy(RemapNode);\naddMethodChaining('remap', remap);\naddMethodChaining('remapClamp', remapClamp);\nclass ExpressionNode extends Node {\n  static get type() {\n    return 'ExpressionNode';\n  }\n  constructor() {\n    let snippet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'void';\n    super(nodeType);\n    this.snippet = snippet;\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    const snippet = this.snippet;\n    if (type === 'void') {\n      builder.addLineFlowCode(snippet, this);\n    } else {\n      return builder.format(`( ${snippet} )`, type, output);\n    }\n  }\n}\nconst expression = /*@__PURE__*/nodeProxy(ExpressionNode);\nconst Discard = conditional => (conditional ? select(conditional, expression('discard')) : expression('discard')).append();\nconst Return = () => expression('return').append();\naddMethodChaining('discard', Discard);\nclass RenderOutputNode extends TempNode {\n  static get type() {\n    return 'RenderOutputNode';\n  }\n  constructor(colorNode, toneMapping, outputColorSpace) {\n    super('vec4');\n    this.colorNode = colorNode;\n    this.toneMapping = toneMapping;\n    this.outputColorSpace = outputColorSpace;\n    this.isRenderOutput = true;\n  }\n  setup(_ref6) {\n    let {\n      context\n    } = _ref6;\n    let outputNode = this.colorNode || context.color;\n\n    // tone mapping\n\n    const toneMapping = (this.toneMapping !== null ? this.toneMapping : context.toneMapping) || NoToneMapping;\n    const outputColorSpace = (this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace) || NoColorSpace;\n    if (toneMapping !== NoToneMapping) {\n      outputNode = outputNode.toneMapping(toneMapping);\n    }\n\n    // working to output color space\n\n    if (outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace) {\n      outputNode = outputNode.workingToColorSpace(outputColorSpace);\n    }\n    return outputNode;\n  }\n}\nconst renderOutput = function (color) {\n  let toneMapping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let outputColorSpace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return nodeObject(new RenderOutputNode(nodeObject(color), toneMapping, outputColorSpace));\n};\naddMethodChaining('renderOutput', renderOutput);\n\n// Non-PURE exports list, side-effects are required here.\n// TSL Base Syntax\n\nfunction addNodeElement(name /*, nodeElement*/) {\n  console.warn('THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add', name);\n}\nclass AttributeNode extends Node {\n  static get type() {\n    return 'AttributeNode';\n  }\n  constructor(attributeName) {\n    let nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(nodeType);\n    this.global = true;\n    this._attributeName = attributeName;\n  }\n  getHash(builder) {\n    return this.getAttributeName(builder);\n  }\n  getNodeType(builder) {\n    let nodeType = this.nodeType;\n    if (nodeType === null) {\n      const attributeName = this.getAttributeName(builder);\n      if (builder.hasGeometryAttribute(attributeName)) {\n        const attribute = builder.geometry.getAttribute(attributeName);\n        nodeType = builder.getTypeFromAttribute(attribute);\n      } else {\n        nodeType = 'float';\n      }\n    }\n    return nodeType;\n  }\n  setAttributeName(attributeName) {\n    this._attributeName = attributeName;\n    return this;\n  }\n  getAttributeName(/*builder*/\n  ) {\n    return this._attributeName;\n  }\n  generate(builder) {\n    const attributeName = this.getAttributeName(builder);\n    const nodeType = this.getNodeType(builder);\n    const geometryAttribute = builder.hasGeometryAttribute(attributeName);\n    if (geometryAttribute === true) {\n      const attribute = builder.geometry.getAttribute(attributeName);\n      const attributeType = builder.getTypeFromAttribute(attribute);\n      const nodeAttribute = builder.getAttribute(attributeName, attributeType);\n      if (builder.shaderStage === 'vertex') {\n        return builder.format(nodeAttribute.name, attributeType, nodeType);\n      } else {\n        const nodeVarying = varying(this);\n        return nodeVarying.build(builder, nodeType);\n      }\n    } else {\n      console.warn(`AttributeNode: Vertex attribute \"${attributeName}\" not found on geometry.`);\n      return builder.generateConst(nodeType);\n    }\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.global = this.global;\n    data._attributeName = this._attributeName;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.global = data.global;\n    this._attributeName = data._attributeName;\n  }\n}\nconst attribute = (name, nodeType) => nodeObject(new AttributeNode(name, nodeType));\nconst uv = index => attribute('uv' + (index > 0 ? index : ''), 'vec2');\nclass TextureSizeNode extends Node {\n  static get type() {\n    return 'TextureSizeNode';\n  }\n  constructor(textureNode) {\n    let levelNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super('uvec2');\n    this.isTextureSizeNode = true;\n    this.textureNode = textureNode;\n    this.levelNode = levelNode;\n  }\n  generate(builder, output) {\n    const textureProperty = this.textureNode.build(builder, 'property');\n    const level = this.levelNode === null ? '0' : this.levelNode.build(builder, 'int');\n    return builder.format(`${builder.getMethod('textureDimensions')}( ${textureProperty}, ${level} )`, this.getNodeType(builder), output);\n  }\n}\nconst textureSize = /*@__PURE__*/nodeProxy(TextureSizeNode);\nclass MaxMipLevelNode extends UniformNode {\n  static get type() {\n    return 'MaxMipLevelNode';\n  }\n  constructor(textureNode) {\n    super(0);\n    this._textureNode = textureNode;\n    this.updateType = NodeUpdateType.FRAME;\n  }\n  get textureNode() {\n    return this._textureNode;\n  }\n  get texture() {\n    return this._textureNode.value;\n  }\n  update() {\n    const texture = this.texture;\n    const images = texture.images;\n    const image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture.image;\n    if (image && image.width !== undefined) {\n      const {\n        width,\n        height\n      } = image;\n      this.value = Math.log2(Math.max(width, height));\n    }\n  }\n}\nconst maxMipLevel = /*@__PURE__*/nodeProxy(MaxMipLevelNode);\nclass TextureNode extends UniformNode {\n  static get type() {\n    return 'TextureNode';\n  }\n  constructor(value) {\n    let uvNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let levelNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let biasNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    super(value);\n    this.isTextureNode = true;\n    this.uvNode = uvNode;\n    this.levelNode = levelNode;\n    this.biasNode = biasNode;\n    this.compareNode = null;\n    this.depthNode = null;\n    this.gradNode = null;\n    this.sampler = true;\n    this.updateMatrix = false;\n    this.updateType = NodeUpdateType.NONE;\n    this.referenceNode = null;\n    this._value = value;\n    this._matrixUniform = null;\n    this.setUpdateMatrix(uvNode === null);\n  }\n  set value(value) {\n    if (this.referenceNode) {\n      this.referenceNode.value = value;\n    } else {\n      this._value = value;\n    }\n  }\n  get value() {\n    return this.referenceNode ? this.referenceNode.value : this._value;\n  }\n  getUniformHash(/*builder*/\n  ) {\n    return this.value.uuid;\n  }\n  getNodeType(/*builder*/\n  ) {\n    if (this.value.isDepthTexture === true) return 'float';\n    if (this.value.type === UnsignedIntType) {\n      return 'uvec4';\n    } else if (this.value.type === IntType) {\n      return 'ivec4';\n    }\n    return 'vec4';\n  }\n  getInputType(/*builder*/\n  ) {\n    return 'texture';\n  }\n  getDefaultUV() {\n    return uv(this.value.channel);\n  }\n  updateReference(/*state*/\n  ) {\n    return this.value;\n  }\n  getTransformedUV(uvNode) {\n    if (this._matrixUniform === null) this._matrixUniform = uniform(this.value.matrix);\n    return this._matrixUniform.mul(vec3(uvNode, 1)).xy;\n  }\n  setUpdateMatrix(value) {\n    this.updateMatrix = value;\n    this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;\n    return this;\n  }\n  setupUV(builder, uvNode) {\n    const texture = this.value;\n    if (builder.isFlipY() && (texture.image instanceof ImageBitmap && texture.flipY === true || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true)) {\n      if (this.sampler) {\n        uvNode = uvNode.flipY();\n      } else {\n        uvNode = uvNode.setY(int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1));\n      }\n    }\n    return uvNode;\n  }\n  setup(builder) {\n    const properties = builder.getNodeProperties(this);\n    properties.referenceNode = this.referenceNode;\n\n    //\n\n    let uvNode = this.uvNode;\n    if ((uvNode === null || builder.context.forceUVContext === true) && builder.context.getUV) {\n      uvNode = builder.context.getUV(this);\n    }\n    if (!uvNode) uvNode = this.getDefaultUV();\n    if (this.updateMatrix === true) {\n      uvNode = this.getTransformedUV(uvNode);\n    }\n    uvNode = this.setupUV(builder, uvNode);\n\n    //\n\n    let levelNode = this.levelNode;\n    if (levelNode === null && builder.context.getTextureLevel) {\n      levelNode = builder.context.getTextureLevel(this);\n    }\n\n    //\n\n    properties.uvNode = uvNode;\n    properties.levelNode = levelNode;\n    properties.biasNode = this.biasNode;\n    properties.compareNode = this.compareNode;\n    properties.gradNode = this.gradNode;\n    properties.depthNode = this.depthNode;\n  }\n  generateUV(builder, uvNode) {\n    return uvNode.build(builder, this.sampler === true ? 'vec2' : 'ivec2');\n  }\n  generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet) {\n    const texture = this.value;\n    let snippet;\n    if (levelSnippet) {\n      snippet = builder.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet);\n    } else if (biasSnippet) {\n      snippet = builder.generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, depthSnippet);\n    } else if (gradSnippet) {\n      snippet = builder.generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet);\n    } else if (compareSnippet) {\n      snippet = builder.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet);\n    } else if (this.sampler === false) {\n      snippet = builder.generateTextureLoad(texture, textureProperty, uvSnippet, depthSnippet);\n    } else {\n      snippet = builder.generateTexture(texture, textureProperty, uvSnippet, depthSnippet);\n    }\n    return snippet;\n  }\n  generate(builder, output) {\n    const properties = builder.getNodeProperties(this);\n    const texture = this.value;\n    if (!texture || texture.isTexture !== true) {\n      throw new Error('TextureNode: Need a three.js texture.');\n    }\n    const textureProperty = super.generate(builder, 'property');\n    if (output === 'sampler') {\n      return textureProperty + '_sampler';\n    } else if (builder.isReference(output)) {\n      return textureProperty;\n    } else {\n      const nodeData = builder.getDataFromNode(this);\n      let propertyName = nodeData.propertyName;\n      if (propertyName === undefined) {\n        const {\n          uvNode,\n          levelNode,\n          biasNode,\n          compareNode,\n          depthNode,\n          gradNode\n        } = properties;\n        const uvSnippet = this.generateUV(builder, uvNode);\n        const levelSnippet = levelNode ? levelNode.build(builder, 'float') : null;\n        const biasSnippet = biasNode ? biasNode.build(builder, 'float') : null;\n        const depthSnippet = depthNode ? depthNode.build(builder, 'int') : null;\n        const compareSnippet = compareNode ? compareNode.build(builder, 'float') : null;\n        const gradSnippet = gradNode ? [gradNode[0].build(builder, 'vec2'), gradNode[1].build(builder, 'vec2')] : null;\n        const nodeVar = builder.getVarFromNode(this);\n        propertyName = builder.getPropertyName(nodeVar);\n        const snippet = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet);\n        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);\n        nodeData.snippet = snippet;\n        nodeData.propertyName = propertyName;\n      }\n      let snippet = propertyName;\n      const nodeType = this.getNodeType(builder);\n      if (builder.needsToWorkingColorSpace(texture)) {\n        snippet = colorSpaceToWorking(expression(snippet, nodeType), texture.colorSpace).setup(builder).build(builder, nodeType);\n      }\n      return builder.format(snippet, nodeType, output);\n    }\n  }\n  setSampler(value) {\n    this.sampler = value;\n    return this;\n  }\n  getSampler() {\n    return this.sampler;\n  }\n\n  // @TODO: Move to TSL\n\n  uv(uvNode) {\n    const textureNode = this.clone();\n    textureNode.uvNode = nodeObject(uvNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n  blur(amountNode) {\n    const textureNode = this.clone();\n    textureNode.biasNode = nodeObject(amountNode).mul(maxMipLevel(textureNode));\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n  level(levelNode) {\n    const textureNode = this.clone();\n    textureNode.levelNode = nodeObject(levelNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n  size(levelNode) {\n    return textureSize(this, levelNode);\n  }\n  bias(biasNode) {\n    const textureNode = this.clone();\n    textureNode.biasNode = nodeObject(biasNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n  compare(compareNode) {\n    const textureNode = this.clone();\n    textureNode.compareNode = nodeObject(compareNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n  grad(gradNodeX, gradNodeY) {\n    const textureNode = this.clone();\n    textureNode.gradNode = [nodeObject(gradNodeX), nodeObject(gradNodeY)];\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n  depth(depthNode) {\n    const textureNode = this.clone();\n    textureNode.depthNode = nodeObject(depthNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n\n  // --\n\n  serialize(data) {\n    super.serialize(data);\n    data.value = this.value.toJSON(data.meta).uuid;\n    data.sampler = this.sampler;\n    data.updateMatrix = this.updateMatrix;\n    data.updateType = this.updateType;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.value = data.meta.textures[data.value];\n    this.sampler = data.sampler;\n    this.updateMatrix = data.updateMatrix;\n    this.updateType = data.updateType;\n  }\n  update() {\n    const texture = this.value;\n    const matrixUniform = this._matrixUniform;\n    if (matrixUniform !== null) matrixUniform.value = texture.matrix;\n    if (texture.matrixAutoUpdate === true) {\n      texture.updateMatrix();\n    }\n  }\n  clone() {\n    const newNode = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);\n    newNode.sampler = this.sampler;\n    return newNode;\n  }\n}\nconst texture = /*@__PURE__*/nodeProxy(TextureNode);\nconst textureLoad = function () {\n  return texture(...arguments).setSampler(false);\n};\n\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\nconst sampler = aTexture => (aTexture.isNode === true ? aTexture : texture(aTexture)).convert('sampler');\nconst cameraNear = /*@__PURE__*/uniform('float').label('cameraNear').setGroup(renderGroup).onRenderUpdate(_ref7 => {\n  let {\n    camera\n  } = _ref7;\n  return camera.near;\n});\nconst cameraFar = /*@__PURE__*/uniform('float').label('cameraFar').setGroup(renderGroup).onRenderUpdate(_ref8 => {\n  let {\n    camera\n  } = _ref8;\n  return camera.far;\n});\nconst cameraProjectionMatrix = /*@__PURE__*/uniform('mat4').label('cameraProjectionMatrix').setGroup(renderGroup).onRenderUpdate(_ref9 => {\n  let {\n    camera\n  } = _ref9;\n  return camera.projectionMatrix;\n});\nconst cameraProjectionMatrixInverse = /*@__PURE__*/uniform('mat4').label('cameraProjectionMatrixInverse').setGroup(renderGroup).onRenderUpdate(_ref10 => {\n  let {\n    camera\n  } = _ref10;\n  return camera.projectionMatrixInverse;\n});\nconst cameraViewMatrix = /*@__PURE__*/uniform('mat4').label('cameraViewMatrix').setGroup(renderGroup).onRenderUpdate(_ref11 => {\n  let {\n    camera\n  } = _ref11;\n  return camera.matrixWorldInverse;\n});\nconst cameraWorldMatrix = /*@__PURE__*/uniform('mat4').label('cameraWorldMatrix').setGroup(renderGroup).onRenderUpdate(_ref12 => {\n  let {\n    camera\n  } = _ref12;\n  return camera.matrixWorld;\n});\nconst cameraNormalMatrix = /*@__PURE__*/uniform('mat3').label('cameraNormalMatrix').setGroup(renderGroup).onRenderUpdate(_ref13 => {\n  let {\n    camera\n  } = _ref13;\n  return camera.normalMatrix;\n});\nconst cameraPosition = /*@__PURE__*/uniform(new Vector3()).label('cameraPosition').setGroup(renderGroup).onRenderUpdate((_ref14, self) => {\n  let {\n    camera\n  } = _ref14;\n  return self.value.setFromMatrixPosition(camera.matrixWorld);\n});\nclass Object3DNode extends Node {\n  static get type() {\n    return 'Object3DNode';\n  }\n  constructor(scope) {\n    let object3d = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super();\n    this.scope = scope;\n    this.object3d = object3d;\n    this.updateType = NodeUpdateType.OBJECT;\n    this._uniformNode = new UniformNode(null);\n  }\n  getNodeType() {\n    const scope = this.scope;\n    if (scope === Object3DNode.WORLD_MATRIX) {\n      return 'mat4';\n    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE) {\n      return 'vec3';\n    }\n  }\n  update(frame) {\n    const object = this.object3d;\n    const uniformNode = this._uniformNode;\n    const scope = this.scope;\n    if (scope === Object3DNode.WORLD_MATRIX) {\n      uniformNode.value = object.matrixWorld;\n    } else if (scope === Object3DNode.POSITION) {\n      uniformNode.value = uniformNode.value || new Vector3();\n      uniformNode.value.setFromMatrixPosition(object.matrixWorld);\n    } else if (scope === Object3DNode.SCALE) {\n      uniformNode.value = uniformNode.value || new Vector3();\n      uniformNode.value.setFromMatrixScale(object.matrixWorld);\n    } else if (scope === Object3DNode.DIRECTION) {\n      uniformNode.value = uniformNode.value || new Vector3();\n      object.getWorldDirection(uniformNode.value);\n    } else if (scope === Object3DNode.VIEW_POSITION) {\n      const camera = frame.camera;\n      uniformNode.value = uniformNode.value || new Vector3();\n      uniformNode.value.setFromMatrixPosition(object.matrixWorld);\n      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);\n    }\n  }\n  generate(builder) {\n    const scope = this.scope;\n    if (scope === Object3DNode.WORLD_MATRIX) {\n      this._uniformNode.nodeType = 'mat4';\n    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE) {\n      this._uniformNode.nodeType = 'vec3';\n    }\n    return this._uniformNode.build(builder);\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.scope = this.scope;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.scope = data.scope;\n  }\n}\nObject3DNode.WORLD_MATRIX = 'worldMatrix';\nObject3DNode.POSITION = 'position';\nObject3DNode.SCALE = 'scale';\nObject3DNode.VIEW_POSITION = 'viewPosition';\nObject3DNode.DIRECTION = 'direction';\nconst objectDirection = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.DIRECTION);\nconst objectWorldMatrix = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX);\nconst objectPosition = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.POSITION);\nconst objectScale = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.SCALE);\nconst objectViewPosition = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.VIEW_POSITION);\nclass ModelNode extends Object3DNode {\n  static get type() {\n    return 'ModelNode';\n  }\n  constructor(scope) {\n    super(scope);\n  }\n  update(frame) {\n    this.object3d = frame.object;\n    super.update(frame);\n  }\n}\nconst modelDirection = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.DIRECTION);\nconst modelWorldMatrix = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.WORLD_MATRIX);\nconst modelPosition = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.POSITION);\nconst modelScale = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.SCALE);\nconst modelViewPosition = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);\nconst modelNormalMatrix = /*@__PURE__*/uniform(new Matrix3()).onObjectUpdate((_ref15, self) => {\n  let {\n    object\n  } = _ref15;\n  return self.value.getNormalMatrix(object.matrixWorld);\n});\nconst modelWorldMatrixInverse = /*@__PURE__*/uniform(new Matrix4()).onObjectUpdate((_ref16, self) => {\n  let {\n    object\n  } = _ref16;\n  return self.value.copy(object.matrixWorld).invert();\n});\nconst modelViewMatrix = /*@__PURE__*/cameraViewMatrix.mul(modelWorldMatrix).toVar('modelViewMatrix');\nconst highPrecisionModelViewMatrix = /*@__PURE__*/Fn(builder => {\n  builder.context.isHighPrecisionModelViewMatrix = true;\n  return uniform('mat4').onObjectUpdate(_ref17 => {\n    let {\n      object,\n      camera\n    } = _ref17;\n    return object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n  });\n}).once()().toVar('highPrecisionModelViewMatrix');\nconst highPrecisionModelNormalViewMatrix = /*@__PURE__*/Fn(builder => {\n  const isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;\n  return uniform('mat3').onObjectUpdate(_ref18 => {\n    let {\n      object,\n      camera\n    } = _ref18;\n    if (isHighPrecisionModelViewMatrix !== true) {\n      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n    }\n    return object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n  });\n}).once()().toVar('highPrecisionModelNormalMatrix');\nconst positionGeometry = /*@__PURE__*/attribute('position', 'vec3');\nconst positionLocal = /*@__PURE__*/positionGeometry.varying('positionLocal');\nconst positionPrevious = /*@__PURE__*/positionGeometry.varying('positionPrevious');\nconst positionWorld = /*@__PURE__*/modelWorldMatrix.mul(positionLocal).xyz.varying('v_positionWorld');\nconst positionWorldDirection = /*@__PURE__*/positionLocal.transformDirection(modelWorldMatrix).varying('v_positionWorldDirection').normalize().toVar('positionWorldDirection');\nconst positionView = /*@__PURE__*/modelViewMatrix.mul(positionLocal).xyz.varying('v_positionView');\nconst positionViewDirection = /*@__PURE__*/positionView.negate().varying('v_positionViewDirection').normalize().toVar('positionViewDirection');\nclass FrontFacingNode extends Node {\n  static get type() {\n    return 'FrontFacingNode';\n  }\n  constructor() {\n    super('bool');\n    this.isFrontFacingNode = true;\n  }\n  generate(builder) {\n    const {\n      renderer,\n      material\n    } = builder;\n    if (renderer.coordinateSystem === WebGLCoordinateSystem) {\n      if (material.side === BackSide) {\n        return 'false';\n      }\n    }\n    return builder.getFrontFacing();\n  }\n}\nconst frontFacing = /*@__PURE__*/nodeImmutable(FrontFacingNode);\nconst faceDirection = /*@__PURE__*/float(frontFacing).mul(2.0).sub(1.0);\nconst normalGeometry = /*@__PURE__*/attribute('normal', 'vec3');\nconst normalLocal = /*@__PURE__*/Fn(builder => {\n  if (builder.geometry.hasAttribute('normal') === false) {\n    console.warn('TSL.NormalNode: Vertex attribute \"normal\" not found on geometry.');\n    return vec3(0, 1, 0);\n  }\n  return normalGeometry;\n}, 'vec3').once()().toVar('normalLocal');\nconst normalFlat = /*@__PURE__*/positionView.dFdx().cross(positionView.dFdy()).normalize().toVar('normalFlat');\nconst normalView = /*@__PURE__*/Fn(builder => {\n  let node;\n  if (builder.material.flatShading === true) {\n    node = normalFlat;\n  } else {\n    node = varying(transformNormalToView(normalLocal), 'v_normalView').normalize();\n  }\n  return node;\n}, 'vec3').once()().toVar('normalView');\nconst normalWorld = /*@__PURE__*/varying(normalView.transformDirection(cameraViewMatrix), 'v_normalWorld').normalize().toVar('normalWorld');\nconst transformedNormalView = /*@__PURE__*/Fn(builder => {\n  return builder.context.setupNormal();\n}, 'vec3').once()().mul(faceDirection).toVar('transformedNormalView');\nconst transformedNormalWorld = /*@__PURE__*/transformedNormalView.transformDirection(cameraViewMatrix).toVar('transformedNormalWorld');\nconst transformedClearcoatNormalView = /*@__PURE__*/Fn(builder => {\n  return builder.context.setupClearcoatNormal();\n}, 'vec3').once()().mul(faceDirection).toVar('transformedClearcoatNormalView');\nconst transformNormal = /*@__PURE__*/Fn(_ref19 => {\n  let [normal, matrix = modelWorldMatrix] = _ref19;\n  const m = mat3(matrix);\n  const transformedNormal = normal.div(vec3(m[0].dot(m[0]), m[1].dot(m[1]), m[2].dot(m[2])));\n  return m.mul(transformedNormal).xyz;\n});\nconst transformNormalToView = /*@__PURE__*/Fn((_ref20, builder) => {\n  let [normal] = _ref20;\n  const modelNormalViewMatrix = builder.renderer.nodes.modelNormalViewMatrix;\n  if (modelNormalViewMatrix !== null) {\n    return modelNormalViewMatrix.transformDirection(normal);\n  }\n\n  //\n\n  const transformedNormal = modelNormalMatrix.mul(normal);\n  return cameraViewMatrix.transformDirection(transformedNormal);\n});\nconst materialRefractionRatio = /*@__PURE__*/uniform(0).onReference(_ref21 => {\n  let {\n    material\n  } = _ref21;\n  return material;\n}).onRenderUpdate(_ref22 => {\n  let {\n    material\n  } = _ref22;\n  return material.refractionRatio;\n});\nconst reflectView = /*@__PURE__*/positionViewDirection.negate().reflect(transformedNormalView);\nconst refractView = /*@__PURE__*/positionViewDirection.negate().refract(transformedNormalView, materialRefractionRatio);\nconst reflectVector = /*@__PURE__*/reflectView.transformDirection(cameraViewMatrix).toVar('reflectVector');\nconst refractVector = /*@__PURE__*/refractView.transformDirection(cameraViewMatrix).toVar('reflectVector');\nclass CubeTextureNode extends TextureNode {\n  static get type() {\n    return 'CubeTextureNode';\n  }\n  constructor(value) {\n    let uvNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let levelNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let biasNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    super(value, uvNode, levelNode, biasNode);\n    this.isCubeTextureNode = true;\n  }\n  getInputType(/*builder*/\n  ) {\n    return 'cubeTexture';\n  }\n  getDefaultUV() {\n    const texture = this.value;\n    if (texture.mapping === CubeReflectionMapping) {\n      return reflectVector;\n    } else if (texture.mapping === CubeRefractionMapping) {\n      return refractVector;\n    } else {\n      console.error('THREE.CubeTextureNode: Mapping \"%s\" not supported.', texture.mapping);\n      return vec3(0, 0, 0);\n    }\n  }\n  setUpdateMatrix(/*updateMatrix*/) {} // Ignore .updateMatrix for CubeTextureNode\n\n  setupUV(builder, uvNode) {\n    const texture = this.value;\n    if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem || !texture.isRenderTargetTexture) {\n      return vec3(uvNode.x.negate(), uvNode.yz);\n    } else {\n      return uvNode;\n    }\n  }\n  generateUV(builder, cubeUV) {\n    return cubeUV.build(builder, 'vec3');\n  }\n}\nconst cubeTexture = /*@__PURE__*/nodeProxy(CubeTextureNode);\nclass BufferNode extends UniformNode {\n  static get type() {\n    return 'BufferNode';\n  }\n  constructor(value, bufferType) {\n    let bufferCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    super(value, bufferType);\n    this.isBufferNode = true;\n    this.bufferType = bufferType;\n    this.bufferCount = bufferCount;\n  }\n  getElementType(builder) {\n    return this.getNodeType(builder);\n  }\n  getInputType(/*builder*/\n  ) {\n    return 'buffer';\n  }\n}\nconst buffer = (value, type, count) => nodeObject(new BufferNode(value, type, count));\nclass UniformArrayElementNode extends ArrayElementNode {\n  static get type() {\n    return 'UniformArrayElementNode';\n  }\n  constructor(arrayBuffer, indexNode) {\n    super(arrayBuffer, indexNode);\n    this.isArrayBufferElementNode = true;\n  }\n  generate(builder) {\n    const snippet = super.generate(builder);\n    const type = this.getNodeType();\n    return builder.format(snippet, 'vec4', type);\n  }\n}\nclass UniformArrayNode extends BufferNode {\n  static get type() {\n    return 'UniformArrayNode';\n  }\n  constructor(value) {\n    let elementType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(null, 'vec4');\n    this.array = value;\n    this.elementType = elementType;\n    this._elementType = null;\n    this._elementLength = 0;\n    this.updateType = NodeUpdateType.RENDER;\n    this.isArrayBufferNode = true;\n  }\n  getElementType() {\n    return this.elementType || this._elementType;\n  }\n  getElementLength() {\n    return this._elementLength;\n  }\n  update(/*frame*/\n  ) {\n    const {\n      array,\n      value\n    } = this;\n    const elementLength = this.getElementLength();\n    const elementType = this.getElementType();\n    if (elementLength === 1) {\n      for (let i = 0; i < array.length; i++) {\n        const index = i * 4;\n        value[index] = array[i];\n      }\n    } else if (elementType === 'color') {\n      for (let i = 0; i < array.length; i++) {\n        const index = i * 4;\n        const vector = array[i];\n        value[index] = vector.r;\n        value[index + 1] = vector.g;\n        value[index + 2] = vector.b || 0;\n        //value[ index + 3 ] = vector.a || 0;\n      }\n    } else {\n      for (let i = 0; i < array.length; i++) {\n        const index = i * 4;\n        const vector = array[i];\n        value[index] = vector.x;\n        value[index + 1] = vector.y;\n        value[index + 2] = vector.z || 0;\n        value[index + 3] = vector.w || 0;\n      }\n    }\n  }\n  setup(builder) {\n    const length = this.array.length;\n    this._elementType = this.elementType === null ? getValueType(this.array[0]) : this.elementType;\n    this._elementLength = builder.getTypeLength(this._elementType);\n    let arrayType = Float32Array;\n    if (this._elementType.charAt(0) === 'i') arrayType = Int32Array;else if (this._elementType.charAt(0) === 'u') arrayType = Uint32Array;\n    this.value = new arrayType(length * 4);\n    this.bufferCount = length;\n    this.bufferType = builder.changeComponentType('vec4', builder.getComponentType(this._elementType));\n    return super.setup(builder);\n  }\n  element(indexNode) {\n    return nodeObject(new UniformArrayElementNode(this, nodeObject(indexNode)));\n  }\n}\nconst uniformArray = (values, nodeType) => nodeObject(new UniformArrayNode(values, nodeType));\n\n//\n\nconst uniforms = (values, nodeType) => {\n  // @deprecated, r168\n\n  console.warn('TSL.UniformArrayNode: uniforms() has been renamed to uniformArray().');\n  return nodeObject(new UniformArrayNode(values, nodeType));\n};\nclass ReferenceElementNode extends ArrayElementNode {\n  static get type() {\n    return 'ReferenceElementNode';\n  }\n  constructor(referenceNode, indexNode) {\n    super(referenceNode, indexNode);\n    this.referenceNode = referenceNode;\n    this.isReferenceElementNode = true;\n  }\n  getNodeType() {\n    return this.referenceNode.uniformType;\n  }\n  generate(builder) {\n    const snippet = super.generate(builder);\n    const arrayType = this.referenceNode.getNodeType();\n    const elementType = this.getNodeType();\n    return builder.format(snippet, arrayType, elementType);\n  }\n}\n\n// TODO: Extends this from ReferenceBaseNode\nclass ReferenceNode extends Node {\n  static get type() {\n    return 'ReferenceNode';\n  }\n  constructor(property, uniformType) {\n    let object = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    super();\n    this.property = property;\n    this.uniformType = uniformType;\n    this.object = object;\n    this.count = count;\n    this.properties = property.split('.');\n    this.reference = object;\n    this.node = null;\n    this.group = null;\n    this.name = null;\n    this.updateType = NodeUpdateType.OBJECT;\n  }\n  element(indexNode) {\n    return nodeObject(new ReferenceElementNode(this, nodeObject(indexNode)));\n  }\n  setGroup(group) {\n    this.group = group;\n    return this;\n  }\n  label(name) {\n    this.name = name;\n    return this;\n  }\n  setNodeType(uniformType) {\n    let node = null;\n    if (this.count !== null) {\n      node = buffer(null, uniformType, this.count);\n    } else if (Array.isArray(this.getValueFromReference())) {\n      node = uniformArray(null, uniformType);\n    } else if (uniformType === 'texture') {\n      node = texture(null);\n    } else if (uniformType === 'cubeTexture') {\n      node = cubeTexture(null);\n    } else {\n      node = uniform(null, uniformType);\n    }\n    if (this.group !== null) {\n      node.setGroup(this.group);\n    }\n    if (this.name !== null) node.label(this.name);\n    this.node = node.getSelf();\n  }\n  getNodeType(builder) {\n    if (this.node === null) {\n      this.updateReference(builder);\n      this.updateValue();\n    }\n    return this.node.getNodeType(builder);\n  }\n  getValueFromReference() {\n    let object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.reference;\n    const {\n      properties\n    } = this;\n    let value = object[properties[0]];\n    for (let i = 1; i < properties.length; i++) {\n      value = value[properties[i]];\n    }\n    return value;\n  }\n  updateReference(state) {\n    this.reference = this.object !== null ? this.object : state.object;\n    return this.reference;\n  }\n  setup() {\n    this.updateValue();\n    return this.node;\n  }\n  update(/*frame*/\n  ) {\n    this.updateValue();\n  }\n  updateValue() {\n    if (this.node === null) this.setNodeType(this.uniformType);\n    const value = this.getValueFromReference();\n    if (Array.isArray(value)) {\n      this.node.array = value;\n    } else {\n      this.node.value = value;\n    }\n  }\n}\nconst reference = (name, type, object) => nodeObject(new ReferenceNode(name, type, object));\nconst referenceBuffer = (name, type, count, object) => nodeObject(new ReferenceNode(name, type, object, count));\nclass MaterialReferenceNode extends ReferenceNode {\n  static get type() {\n    return 'MaterialReferenceNode';\n  }\n  constructor(property, inputType) {\n    let material = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    super(property, inputType, material);\n    this.material = material;\n\n    //this.updateType = NodeUpdateType.RENDER;\n\n    this.isMaterialReferenceNode = true;\n  }\n\n  /*setNodeType( node ) {\n  \t\tsuper.setNodeType( node );\n  \t\tthis.node.groupNode = renderGroup;\n  \t}*/\n\n  updateReference(state) {\n    this.reference = this.material !== null ? this.material : state.material;\n    return this.reference;\n  }\n}\nconst materialReference = (name, type, material) => nodeObject(new MaterialReferenceNode(name, type, material));\nconst tangentGeometry = /*@__PURE__*/Fn(builder => {\n  if (builder.geometry.hasAttribute('tangent') === false) {\n    builder.geometry.computeTangents();\n  }\n  return attribute('tangent', 'vec4');\n})();\nconst tangentLocal = /*@__PURE__*/tangentGeometry.xyz.toVar('tangentLocal');\nconst tangentView = /*@__PURE__*/modelViewMatrix.mul(vec4(tangentLocal, 0)).xyz.varying('v_tangentView').normalize().toVar('tangentView');\nconst tangentWorld = /*@__PURE__*/tangentView.transformDirection(cameraViewMatrix).varying('v_tangentWorld').normalize().toVar('tangentWorld');\nconst transformedTangentView = /*@__PURE__*/tangentView.toVar('transformedTangentView');\nconst transformedTangentWorld = /*@__PURE__*/transformedTangentView.transformDirection(cameraViewMatrix).normalize().toVar('transformedTangentWorld');\nconst getBitangent = crossNormalTangent => crossNormalTangent.mul(tangentGeometry.w).xyz;\nconst bitangentGeometry = /*@__PURE__*/varying(getBitangent(normalGeometry.cross(tangentGeometry)), 'v_bitangentGeometry').normalize().toVar('bitangentGeometry');\nconst bitangentLocal = /*@__PURE__*/varying(getBitangent(normalLocal.cross(tangentLocal)), 'v_bitangentLocal').normalize().toVar('bitangentLocal');\nconst bitangentView = /*@__PURE__*/varying(getBitangent(normalView.cross(tangentView)), 'v_bitangentView').normalize().toVar('bitangentView');\nconst bitangentWorld = /*@__PURE__*/varying(getBitangent(normalWorld.cross(tangentWorld)), 'v_bitangentWorld').normalize().toVar('bitangentWorld');\nconst transformedBitangentView = /*@__PURE__*/getBitangent(transformedNormalView.cross(transformedTangentView)).normalize().toVar('transformedBitangentView');\nconst transformedBitangentWorld = /*@__PURE__*/transformedBitangentView.transformDirection(cameraViewMatrix).normalize().toVar('transformedBitangentWorld');\nconst TBNViewMatrix = /*@__PURE__*/mat3(tangentView, bitangentView, normalView);\nconst parallaxDirection = /*@__PURE__*/positionViewDirection.mul(TBNViewMatrix) /*.normalize()*/;\nconst parallaxUV = (uv, scale) => uv.sub(parallaxDirection.mul(scale));\nconst transformedBentNormalView = /*@__PURE__*/(() => {\n  // https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy\n\n  let bentNormal = anisotropyB.cross(positionViewDirection);\n  bentNormal = bentNormal.cross(anisotropyB).normalize();\n  bentNormal = mix(bentNormal, transformedNormalView, anisotropy.mul(roughness.oneMinus()).oneMinus().pow2().pow2()).normalize();\n  return bentNormal;\n})();\n\n// Normal Mapping Without Precomputed Tangents\n// http://www.thetenthplanet.de/archives/1180\n\nconst perturbNormal2Arb = /*@__PURE__*/Fn(inputs => {\n  const {\n    eye_pos,\n    surf_norm,\n    mapN,\n    uv\n  } = inputs;\n  const q0 = eye_pos.dFdx();\n  const q1 = eye_pos.dFdy();\n  const st0 = uv.dFdx();\n  const st1 = uv.dFdy();\n  const N = surf_norm; // normalized\n\n  const q1perp = q1.cross(N);\n  const q0perp = N.cross(q0);\n  const T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));\n  const B = q1perp.mul(st0.y).add(q0perp.mul(st1.y));\n  const det = T.dot(T).max(B.dot(B));\n  const scale = faceDirection.mul(det.inverseSqrt());\n  return add(T.mul(mapN.x, scale), B.mul(mapN.y, scale), N.mul(mapN.z)).normalize();\n});\nclass NormalMapNode extends TempNode {\n  static get type() {\n    return 'NormalMapNode';\n  }\n  constructor(node) {\n    let scaleNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super('vec3');\n    this.node = node;\n    this.scaleNode = scaleNode;\n    this.normalMapType = TangentSpaceNormalMap;\n  }\n  setup(builder) {\n    const {\n      normalMapType,\n      scaleNode\n    } = this;\n    let normalMap = this.node.mul(2.0).sub(1.0);\n    if (scaleNode !== null) {\n      normalMap = vec3(normalMap.xy.mul(scaleNode), normalMap.z);\n    }\n    let outputNode = null;\n    if (normalMapType === ObjectSpaceNormalMap) {\n      outputNode = transformNormalToView(normalMap);\n    } else if (normalMapType === TangentSpaceNormalMap) {\n      const tangent = builder.hasGeometryAttribute('tangent');\n      if (tangent === true) {\n        outputNode = TBNViewMatrix.mul(normalMap).normalize();\n      } else {\n        outputNode = perturbNormal2Arb({\n          eye_pos: positionView,\n          surf_norm: normalView,\n          mapN: normalMap,\n          uv: uv()\n        });\n      }\n    }\n    return outputNode;\n  }\n}\nconst normalMap = /*@__PURE__*/nodeProxy(NormalMapNode);\n\n// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\nconst dHdxy_fwd = Fn(_ref23 => {\n  let {\n    textureNode,\n    bumpScale\n  } = _ref23;\n  // It's used to preserve the same TextureNode instance\n  const sampleTexture = callback => textureNode.cache().context({\n    getUV: texNode => callback(texNode.uvNode || uv()),\n    forceUVContext: true\n  });\n  const Hll = float(sampleTexture(uvNode => uvNode));\n  return vec2(float(sampleTexture(uvNode => uvNode.add(uvNode.dFdx()))).sub(Hll), float(sampleTexture(uvNode => uvNode.add(uvNode.dFdy()))).sub(Hll)).mul(bumpScale);\n});\n\n// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\nconst perturbNormalArb = Fn(inputs => {\n  const {\n    surf_pos,\n    surf_norm,\n    dHdxy\n  } = inputs;\n\n  // normalize is done to ensure that the bump map looks the same regardless of the texture's scale\n  const vSigmaX = surf_pos.dFdx().normalize();\n  const vSigmaY = surf_pos.dFdy().normalize();\n  const vN = surf_norm; // normalized\n\n  const R1 = vSigmaY.cross(vN);\n  const R2 = vN.cross(vSigmaX);\n  const fDet = vSigmaX.dot(R1).mul(faceDirection);\n  const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));\n  return fDet.abs().mul(surf_norm).sub(vGrad).normalize();\n});\nclass BumpMapNode extends TempNode {\n  static get type() {\n    return 'BumpMapNode';\n  }\n  constructor(textureNode) {\n    let scaleNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super('vec3');\n    this.textureNode = textureNode;\n    this.scaleNode = scaleNode;\n  }\n  setup() {\n    const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;\n    const dHdxy = dHdxy_fwd({\n      textureNode: this.textureNode,\n      bumpScale\n    });\n    return perturbNormalArb({\n      surf_pos: positionView,\n      surf_norm: normalView,\n      dHdxy\n    });\n  }\n}\nconst bumpMap = /*@__PURE__*/nodeProxy(BumpMapNode);\nconst _propertyCache = new Map();\nclass MaterialNode extends Node {\n  static get type() {\n    return 'MaterialNode';\n  }\n  constructor(scope) {\n    super();\n    this.scope = scope;\n  }\n  getCache(property, type) {\n    let node = _propertyCache.get(property);\n    if (node === undefined) {\n      node = materialReference(property, type);\n      _propertyCache.set(property, node);\n    }\n    return node;\n  }\n  getFloat(property) {\n    return this.getCache(property, 'float');\n  }\n  getColor(property) {\n    return this.getCache(property, 'color');\n  }\n  getTexture(property) {\n    return this.getCache(property === 'map' ? 'map' : property + 'Map', 'texture');\n  }\n  setup(builder) {\n    const material = builder.context.material;\n    const scope = this.scope;\n    let node = null;\n    if (scope === MaterialNode.COLOR) {\n      const colorNode = material.color !== undefined ? this.getColor(scope) : vec3();\n      if (material.map && material.map.isTexture === true) {\n        node = colorNode.mul(this.getTexture('map'));\n      } else {\n        node = colorNode;\n      }\n    } else if (scope === MaterialNode.OPACITY) {\n      const opacityNode = this.getFloat(scope);\n      if (material.alphaMap && material.alphaMap.isTexture === true) {\n        node = opacityNode.mul(this.getTexture('alpha'));\n      } else {\n        node = opacityNode;\n      }\n    } else if (scope === MaterialNode.SPECULAR_STRENGTH) {\n      if (material.specularMap && material.specularMap.isTexture === true) {\n        node = this.getTexture('specular').r;\n      } else {\n        node = float(1);\n      }\n    } else if (scope === MaterialNode.SPECULAR_INTENSITY) {\n      const specularIntensity = this.getFloat(scope);\n      if (material.specularMap) {\n        node = specularIntensity.mul(this.getTexture(scope).a);\n      } else {\n        node = specularIntensity;\n      }\n    } else if (scope === MaterialNode.SPECULAR_COLOR) {\n      const specularColorNode = this.getColor(scope);\n      if (material.specularColorMap && material.specularColorMap.isTexture === true) {\n        node = specularColorNode.mul(this.getTexture(scope).rgb);\n      } else {\n        node = specularColorNode;\n      }\n    } else if (scope === MaterialNode.ROUGHNESS) {\n      // TODO: cleanup similar branches\n\n      const roughnessNode = this.getFloat(scope);\n      if (material.roughnessMap && material.roughnessMap.isTexture === true) {\n        node = roughnessNode.mul(this.getTexture(scope).g);\n      } else {\n        node = roughnessNode;\n      }\n    } else if (scope === MaterialNode.METALNESS) {\n      const metalnessNode = this.getFloat(scope);\n      if (material.metalnessMap && material.metalnessMap.isTexture === true) {\n        node = metalnessNode.mul(this.getTexture(scope).b);\n      } else {\n        node = metalnessNode;\n      }\n    } else if (scope === MaterialNode.EMISSIVE) {\n      const emissiveIntensityNode = this.getFloat('emissiveIntensity');\n      const emissiveNode = this.getColor(scope).mul(emissiveIntensityNode);\n      if (material.emissiveMap && material.emissiveMap.isTexture === true) {\n        node = emissiveNode.mul(this.getTexture(scope));\n      } else {\n        node = emissiveNode;\n      }\n    } else if (scope === MaterialNode.NORMAL) {\n      if (material.normalMap) {\n        node = normalMap(this.getTexture('normal'), this.getCache('normalScale', 'vec2'));\n        node.normalMapType = material.normalMapType;\n      } else if (material.bumpMap) {\n        node = bumpMap(this.getTexture('bump').r, this.getFloat('bumpScale'));\n      } else {\n        node = normalView;\n      }\n    } else if (scope === MaterialNode.CLEARCOAT) {\n      const clearcoatNode = this.getFloat(scope);\n      if (material.clearcoatMap && material.clearcoatMap.isTexture === true) {\n        node = clearcoatNode.mul(this.getTexture(scope).r);\n      } else {\n        node = clearcoatNode;\n      }\n    } else if (scope === MaterialNode.CLEARCOAT_ROUGHNESS) {\n      const clearcoatRoughnessNode = this.getFloat(scope);\n      if (material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true) {\n        node = clearcoatRoughnessNode.mul(this.getTexture(scope).r);\n      } else {\n        node = clearcoatRoughnessNode;\n      }\n    } else if (scope === MaterialNode.CLEARCOAT_NORMAL) {\n      if (material.clearcoatNormalMap) {\n        node = normalMap(this.getTexture(scope), this.getCache(scope + 'Scale', 'vec2'));\n      } else {\n        node = normalView;\n      }\n    } else if (scope === MaterialNode.SHEEN) {\n      const sheenNode = this.getColor('sheenColor').mul(this.getFloat('sheen')); // Move this mul() to CPU\n\n      if (material.sheenColorMap && material.sheenColorMap.isTexture === true) {\n        node = sheenNode.mul(this.getTexture('sheenColor').rgb);\n      } else {\n        node = sheenNode;\n      }\n    } else if (scope === MaterialNode.SHEEN_ROUGHNESS) {\n      const sheenRoughnessNode = this.getFloat(scope);\n      if (material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true) {\n        node = sheenRoughnessNode.mul(this.getTexture(scope).a);\n      } else {\n        node = sheenRoughnessNode;\n      }\n      node = node.clamp(0.07, 1.0);\n    } else if (scope === MaterialNode.ANISOTROPY) {\n      if (material.anisotropyMap && material.anisotropyMap.isTexture === true) {\n        const anisotropyPolar = this.getTexture(scope);\n        const anisotropyMat = mat2(materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x);\n        node = anisotropyMat.mul(anisotropyPolar.rg.mul(2.0).sub(vec2(1.0)).normalize().mul(anisotropyPolar.b));\n      } else {\n        node = materialAnisotropyVector;\n      }\n    } else if (scope === MaterialNode.IRIDESCENCE_THICKNESS) {\n      const iridescenceThicknessMaximum = reference('1', 'float', material.iridescenceThicknessRange);\n      if (material.iridescenceThicknessMap) {\n        const iridescenceThicknessMinimum = reference('0', 'float', material.iridescenceThicknessRange);\n        node = iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(scope).g).add(iridescenceThicknessMinimum);\n      } else {\n        node = iridescenceThicknessMaximum;\n      }\n    } else if (scope === MaterialNode.TRANSMISSION) {\n      const transmissionNode = this.getFloat(scope);\n      if (material.transmissionMap) {\n        node = transmissionNode.mul(this.getTexture(scope).r);\n      } else {\n        node = transmissionNode;\n      }\n    } else if (scope === MaterialNode.THICKNESS) {\n      const thicknessNode = this.getFloat(scope);\n      if (material.thicknessMap) {\n        node = thicknessNode.mul(this.getTexture(scope).g);\n      } else {\n        node = thicknessNode;\n      }\n    } else if (scope === MaterialNode.IOR) {\n      node = this.getFloat(scope);\n    } else if (scope === MaterialNode.LIGHT_MAP) {\n      node = this.getTexture(scope).rgb.mul(this.getFloat('lightMapIntensity'));\n    } else if (scope === MaterialNode.AO_MAP) {\n      node = this.getTexture(scope).r.sub(1.0).mul(this.getFloat('aoMapIntensity')).add(1.0);\n    } else {\n      const outputType = this.getNodeType(builder);\n      node = this.getCache(scope, outputType);\n    }\n    return node;\n  }\n}\nMaterialNode.ALPHA_TEST = 'alphaTest';\nMaterialNode.COLOR = 'color';\nMaterialNode.OPACITY = 'opacity';\nMaterialNode.SHININESS = 'shininess';\nMaterialNode.SPECULAR = 'specular';\nMaterialNode.SPECULAR_STRENGTH = 'specularStrength';\nMaterialNode.SPECULAR_INTENSITY = 'specularIntensity';\nMaterialNode.SPECULAR_COLOR = 'specularColor';\nMaterialNode.REFLECTIVITY = 'reflectivity';\nMaterialNode.ROUGHNESS = 'roughness';\nMaterialNode.METALNESS = 'metalness';\nMaterialNode.NORMAL = 'normal';\nMaterialNode.CLEARCOAT = 'clearcoat';\nMaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';\nMaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';\nMaterialNode.EMISSIVE = 'emissive';\nMaterialNode.ROTATION = 'rotation';\nMaterialNode.SHEEN = 'sheen';\nMaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';\nMaterialNode.ANISOTROPY = 'anisotropy';\nMaterialNode.IRIDESCENCE = 'iridescence';\nMaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';\nMaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';\nMaterialNode.IOR = 'ior';\nMaterialNode.TRANSMISSION = 'transmission';\nMaterialNode.THICKNESS = 'thickness';\nMaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';\nMaterialNode.ATTENUATION_COLOR = 'attenuationColor';\nMaterialNode.LINE_SCALE = 'scale';\nMaterialNode.LINE_DASH_SIZE = 'dashSize';\nMaterialNode.LINE_GAP_SIZE = 'gapSize';\nMaterialNode.LINE_WIDTH = 'linewidth';\nMaterialNode.LINE_DASH_OFFSET = 'dashOffset';\nMaterialNode.POINT_WIDTH = 'pointWidth';\nMaterialNode.DISPERSION = 'dispersion';\nMaterialNode.LIGHT_MAP = 'light';\nMaterialNode.AO_MAP = 'ao';\nconst materialAlphaTest = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ALPHA_TEST);\nconst materialColor = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.COLOR);\nconst materialShininess = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SHININESS);\nconst materialEmissive = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.EMISSIVE);\nconst materialOpacity = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.OPACITY);\nconst materialSpecular = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR);\nconst materialSpecularIntensity = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR_INTENSITY);\nconst materialSpecularColor = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);\nconst materialSpecularStrength = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR_STRENGTH);\nconst materialReflectivity = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);\nconst materialRoughness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ROUGHNESS);\nconst materialMetalness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.METALNESS);\nconst materialNormal = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.NORMAL).context({\n  getUV: null\n});\nconst materialClearcoat = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT);\nconst materialClearcoatRoughness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS);\nconst materialClearcoatNormal = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_NORMAL).context({\n  getUV: null\n});\nconst materialRotation = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ROTATION);\nconst materialSheen = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SHEEN);\nconst materialSheenRoughness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SHEEN_ROUGHNESS);\nconst materialAnisotropy = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ANISOTROPY);\nconst materialIridescence = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE);\nconst materialIridescenceIOR = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_IOR);\nconst materialIridescenceThickness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS);\nconst materialTransmission = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.TRANSMISSION);\nconst materialThickness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.THICKNESS);\nconst materialIOR = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IOR);\nconst materialAttenuationDistance = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_DISTANCE);\nconst materialAttenuationColor = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_COLOR);\nconst materialLineScale = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_SCALE);\nconst materialLineDashSize = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_SIZE);\nconst materialLineGapSize = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_GAP_SIZE);\nconst materialLineWidth = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_WIDTH);\nconst materialLineDashOffset = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_OFFSET);\nconst materialPointWidth = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.POINT_WIDTH);\nconst materialDispersion = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.DISPERSION);\nconst materialLightMap = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LIGHT_MAP);\nconst materialAOMap = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.AO_MAP);\nconst materialAnisotropyVector = /*@__PURE__*/uniform(new Vector2()).onReference(function (frame) {\n  return frame.material;\n}).onRenderUpdate(function (_ref24) {\n  let {\n    material\n  } = _ref24;\n  this.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));\n});\nclass ModelViewProjectionNode extends TempNode {\n  static get type() {\n    return 'ModelViewProjectionNode';\n  }\n  constructor() {\n    let positionNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super('vec4');\n    this.positionNode = positionNode;\n  }\n  setup(builder) {\n    if (builder.shaderStage === 'fragment') {\n      return varying(builder.context.mvp);\n    }\n    const position = this.positionNode || positionLocal;\n    const viewMatrix = builder.renderer.nodes.modelViewMatrix || modelViewMatrix;\n    return cameraProjectionMatrix.mul(viewMatrix).mul(position);\n  }\n}\nconst modelViewProjection = /*@__PURE__*/nodeProxy(ModelViewProjectionNode);\nclass IndexNode extends Node {\n  static get type() {\n    return 'IndexNode';\n  }\n  constructor(scope) {\n    super('uint');\n    this.scope = scope;\n    this.isInstanceIndexNode = true;\n  }\n  generate(builder) {\n    const nodeType = this.getNodeType(builder);\n    const scope = this.scope;\n    let propertyName;\n    if (scope === IndexNode.VERTEX) {\n      // The index of a vertex within a mesh.\n      propertyName = builder.getVertexIndex();\n    } else if (scope === IndexNode.INSTANCE) {\n      // The index of either a mesh instance or an invocation of a compute shader.\n      propertyName = builder.getInstanceIndex();\n    } else if (scope === IndexNode.DRAW) {\n      // The index of a draw call.\n      propertyName = builder.getDrawIndex();\n    } else if (scope === IndexNode.INVOCATION_LOCAL) {\n      // The index of a compute invocation within the scope of a workgroup load.\n      propertyName = builder.getInvocationLocalIndex();\n    } else if (scope === IndexNode.INVOCATION_SUBGROUP) {\n      // The index of a compute invocation within the scope of a subgroup.\n      propertyName = builder.getInvocationSubgroupIndex();\n    } else if (scope === IndexNode.SUBGROUP) {\n      // The index of the subgroup the current compute invocation belongs to.\n      propertyName = builder.getSubgroupIndex();\n    } else {\n      throw new Error('THREE.IndexNode: Unknown scope: ' + scope);\n    }\n    let output;\n    if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {\n      output = propertyName;\n    } else {\n      const nodeVarying = varying(this);\n      output = nodeVarying.build(builder, nodeType);\n    }\n    return output;\n  }\n}\nIndexNode.VERTEX = 'vertex';\nIndexNode.INSTANCE = 'instance';\nIndexNode.SUBGROUP = 'subgroup';\nIndexNode.INVOCATION_LOCAL = 'invocationLocal';\nIndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';\nIndexNode.DRAW = 'draw';\nconst vertexIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.VERTEX);\nconst instanceIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.INSTANCE);\nconst subgroupIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.SUBGROUP);\nconst invocationSubgroupIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.INVOCATION_SUBGROUP);\nconst invocationLocalIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.INVOCATION_LOCAL);\nconst drawIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.DRAW);\nclass InstanceNode extends Node {\n  static get type() {\n    return 'InstanceNode';\n  }\n  constructor(count, instanceMatrix, instanceColor) {\n    super('void');\n    this.count = count;\n    this.instanceMatrix = instanceMatrix;\n    this.instanceColor = instanceColor;\n    this.instanceMatrixNode = null;\n    this.instanceColorNode = null;\n    this.updateType = NodeUpdateType.FRAME;\n    this.buffer = null;\n    this.bufferColor = null;\n  }\n  setup(builder) {\n    const {\n      count,\n      instanceMatrix,\n      instanceColor\n    } = this;\n    let {\n      instanceMatrixNode,\n      instanceColorNode\n    } = this;\n    if (instanceMatrixNode === null) {\n      // Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.\n\n      if (count <= 1000) {\n        instanceMatrixNode = buffer(instanceMatrix.array, 'mat4', Math.max(count, 1)).element(instanceIndex);\n      } else {\n        const buffer = new InstancedInterleavedBuffer(instanceMatrix.array, 16, 1);\n        this.buffer = buffer;\n        const bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n        const instanceBuffers = [\n        // F.Signature -> bufferAttribute( array, type, stride, offset )\n        bufferFn(buffer, 'vec4', 16, 0), bufferFn(buffer, 'vec4', 16, 4), bufferFn(buffer, 'vec4', 16, 8), bufferFn(buffer, 'vec4', 16, 12)];\n        instanceMatrixNode = mat4(...instanceBuffers);\n      }\n      this.instanceMatrixNode = instanceMatrixNode;\n    }\n    if (instanceColor && instanceColorNode === null) {\n      const buffer = new InstancedBufferAttribute(instanceColor.array, 3);\n      const bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n      this.bufferColor = buffer;\n      instanceColorNode = vec3(bufferFn(buffer, 'vec3', 3, 0));\n      this.instanceColorNode = instanceColorNode;\n    }\n\n    // POSITION\n\n    const instancePosition = instanceMatrixNode.mul(positionLocal).xyz;\n    positionLocal.assign(instancePosition);\n\n    // NORMAL\n\n    if (builder.hasGeometryAttribute('normal')) {\n      const instanceNormal = transformNormal(normalLocal, instanceMatrixNode);\n\n      // ASSIGNS\n\n      normalLocal.assign(instanceNormal);\n    }\n\n    // COLOR\n\n    if (this.instanceColorNode !== null) {\n      varyingProperty('vec3', 'vInstanceColor').assign(this.instanceColorNode);\n    }\n  }\n  update(/*frame*/\n  ) {\n    if (this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer != null && this.instanceMatrix.version !== this.buffer.version) {\n      this.buffer.version = this.instanceMatrix.version;\n    }\n    if (this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor != null && this.instanceColor.version !== this.bufferColor.version) {\n      this.bufferColor.version = this.instanceColor.version;\n    }\n  }\n}\nconst instance = /*@__PURE__*/nodeProxy(InstanceNode);\nclass InstancedMeshNode extends InstanceNode {\n  static get type() {\n    return 'InstancedMeshNode';\n  }\n  constructor(instanceMesh) {\n    const {\n      count,\n      instanceMatrix,\n      instanceColor\n    } = instanceMesh;\n    super(count, instanceMatrix, instanceColor);\n    this.instanceMesh = instanceMesh;\n  }\n}\nconst instancedMesh = /*@__PURE__*/nodeProxy(InstancedMeshNode);\nclass BatchNode extends Node {\n  static get type() {\n    return 'BatchNode';\n  }\n  constructor(batchMesh) {\n    super('void');\n    this.batchMesh = batchMesh;\n    this.batchingIdNode = null;\n  }\n  setup(builder) {\n    // POSITION\n\n    if (this.batchingIdNode === null) {\n      if (builder.getDrawIndex() === null) {\n        this.batchingIdNode = instanceIndex;\n      } else {\n        this.batchingIdNode = drawIndex;\n      }\n    }\n    const getIndirectIndex = Fn(_ref25 => {\n      let [id] = _ref25;\n      const size = textureSize(textureLoad(this.batchMesh._indirectTexture), 0);\n      const x = int(id).modInt(int(size));\n      const y = int(id).div(int(size));\n      return textureLoad(this.batchMesh._indirectTexture, ivec2(x, y)).x;\n    }).setLayout({\n      name: 'getIndirectIndex',\n      type: 'uint',\n      inputs: [{\n        name: 'id',\n        type: 'int'\n      }]\n    });\n    const indirectId = getIndirectIndex(int(this.batchingIdNode));\n    const matricesTexture = this.batchMesh._matricesTexture;\n    const size = textureSize(textureLoad(matricesTexture), 0);\n    const j = float(indirectId).mul(4).toInt().toVar();\n    const x = j.modInt(size);\n    const y = j.div(int(size));\n    const batchingMatrix = mat4(textureLoad(matricesTexture, ivec2(x, y)), textureLoad(matricesTexture, ivec2(x.add(1), y)), textureLoad(matricesTexture, ivec2(x.add(2), y)), textureLoad(matricesTexture, ivec2(x.add(3), y)));\n    const colorsTexture = this.batchMesh._colorsTexture;\n    if (colorsTexture !== null) {\n      const getBatchingColor = Fn(_ref26 => {\n        let [id] = _ref26;\n        const size = textureSize(textureLoad(colorsTexture), 0).x;\n        const j = id;\n        const x = j.modInt(size);\n        const y = j.div(size);\n        return textureLoad(colorsTexture, ivec2(x, y)).rgb;\n      }).setLayout({\n        name: 'getBatchingColor',\n        type: 'vec3',\n        inputs: [{\n          name: 'id',\n          type: 'int'\n        }]\n      });\n      const color = getBatchingColor(indirectId);\n      varyingProperty('vec3', 'vBatchColor').assign(color);\n    }\n    const bm = mat3(batchingMatrix);\n    positionLocal.assign(batchingMatrix.mul(positionLocal));\n    const transformedNormal = normalLocal.div(vec3(bm[0].dot(bm[0]), bm[1].dot(bm[1]), bm[2].dot(bm[2])));\n    const batchingNormal = bm.mul(transformedNormal).xyz;\n    normalLocal.assign(batchingNormal);\n    if (builder.hasGeometryAttribute('tangent')) {\n      tangentLocal.mulAssign(bm);\n    }\n  }\n}\nconst batch = /*@__PURE__*/nodeProxy(BatchNode);\nconst _frameId = new WeakMap();\nclass SkinningNode extends Node {\n  static get type() {\n    return 'SkinningNode';\n  }\n  constructor(skinnedMesh) {\n    let useReference = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super('void');\n    this.skinnedMesh = skinnedMesh;\n    this.useReference = useReference;\n    this.updateType = NodeUpdateType.OBJECT;\n\n    //\n\n    this.skinIndexNode = attribute('skinIndex', 'uvec4');\n    this.skinWeightNode = attribute('skinWeight', 'vec4');\n    let bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;\n    if (useReference) {\n      bindMatrixNode = reference('bindMatrix', 'mat4');\n      bindMatrixInverseNode = reference('bindMatrixInverse', 'mat4');\n      boneMatricesNode = referenceBuffer('skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length);\n    } else {\n      bindMatrixNode = uniform(skinnedMesh.bindMatrix, 'mat4');\n      bindMatrixInverseNode = uniform(skinnedMesh.bindMatrixInverse, 'mat4');\n      boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length);\n    }\n    this.bindMatrixNode = bindMatrixNode;\n    this.bindMatrixInverseNode = bindMatrixInverseNode;\n    this.boneMatricesNode = boneMatricesNode;\n    this.previousBoneMatricesNode = null;\n  }\n  getSkinnedPosition() {\n    let boneMatrices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.boneMatricesNode;\n    let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : positionLocal;\n    const {\n      skinIndexNode,\n      skinWeightNode,\n      bindMatrixNode,\n      bindMatrixInverseNode\n    } = this;\n    const boneMatX = boneMatrices.element(skinIndexNode.x);\n    const boneMatY = boneMatrices.element(skinIndexNode.y);\n    const boneMatZ = boneMatrices.element(skinIndexNode.z);\n    const boneMatW = boneMatrices.element(skinIndexNode.w);\n\n    // POSITION\n\n    const skinVertex = bindMatrixNode.mul(position);\n    const skinned = add(boneMatX.mul(skinWeightNode.x).mul(skinVertex), boneMatY.mul(skinWeightNode.y).mul(skinVertex), boneMatZ.mul(skinWeightNode.z).mul(skinVertex), boneMatW.mul(skinWeightNode.w).mul(skinVertex));\n    return bindMatrixInverseNode.mul(skinned).xyz;\n  }\n  getSkinnedNormal() {\n    let boneMatrices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.boneMatricesNode;\n    let normal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : normalLocal;\n    const {\n      skinIndexNode,\n      skinWeightNode,\n      bindMatrixNode,\n      bindMatrixInverseNode\n    } = this;\n    const boneMatX = boneMatrices.element(skinIndexNode.x);\n    const boneMatY = boneMatrices.element(skinIndexNode.y);\n    const boneMatZ = boneMatrices.element(skinIndexNode.z);\n    const boneMatW = boneMatrices.element(skinIndexNode.w);\n\n    // NORMAL\n\n    let skinMatrix = add(skinWeightNode.x.mul(boneMatX), skinWeightNode.y.mul(boneMatY), skinWeightNode.z.mul(boneMatZ), skinWeightNode.w.mul(boneMatW));\n    skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);\n    return skinMatrix.transformDirection(normal).xyz;\n  }\n  getPreviousSkinnedPosition(builder) {\n    const skinnedMesh = builder.object;\n    if (this.previousBoneMatricesNode === null) {\n      skinnedMesh.skeleton.previousBoneMatrices = new Float32Array(skinnedMesh.skeleton.boneMatrices);\n      this.previousBoneMatricesNode = referenceBuffer('skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length);\n    }\n    return this.getSkinnedPosition(this.previousBoneMatricesNode, positionPrevious);\n  }\n  needsPreviousBoneMatrices(builder) {\n    const mrt = builder.renderer.getMRT();\n    return mrt && mrt.has('velocity');\n  }\n  setup(builder) {\n    if (this.needsPreviousBoneMatrices(builder)) {\n      positionPrevious.assign(this.getPreviousSkinnedPosition(builder));\n    }\n    const skinPosition = this.getSkinnedPosition();\n    positionLocal.assign(skinPosition);\n    if (builder.hasGeometryAttribute('normal')) {\n      const skinNormal = this.getSkinnedNormal();\n      normalLocal.assign(skinNormal);\n      if (builder.hasGeometryAttribute('tangent')) {\n        tangentLocal.assign(skinNormal);\n      }\n    }\n  }\n  generate(builder, output) {\n    if (output !== 'void') {\n      return positionLocal.build(builder, output);\n    }\n  }\n  update(frame) {\n    const object = this.useReference ? frame.object : this.skinnedMesh;\n    const skeleton = object.skeleton;\n    if (_frameId.get(skeleton) === frame.frameId) return;\n    _frameId.set(skeleton, frame.frameId);\n    if (this.previousBoneMatricesNode !== null) skeleton.previousBoneMatrices.set(skeleton.boneMatrices);\n    skeleton.update();\n  }\n}\nconst skinning = skinnedMesh => nodeObject(new SkinningNode(skinnedMesh));\nconst skinningReference = skinnedMesh => nodeObject(new SkinningNode(skinnedMesh, true));\nclass LoopNode extends Node {\n  static get type() {\n    return 'LoopNode';\n  }\n  constructor() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    super();\n    this.params = params;\n  }\n  getVarName(index) {\n    return String.fromCharCode('i'.charCodeAt() + index);\n  }\n  getProperties(builder) {\n    const properties = builder.getNodeProperties(this);\n    if (properties.stackNode !== undefined) return properties;\n\n    //\n\n    const inputs = {};\n    for (let i = 0, l = this.params.length - 1; i < l; i++) {\n      const param = this.params[i];\n      const name = param.isNode !== true && param.name || this.getVarName(i);\n      const type = param.isNode !== true && param.type || 'int';\n      inputs[name] = expression(name, type);\n    }\n    const stack = builder.addStack(); // TODO: cache() it\n\n    properties.returnsNode = this.params[this.params.length - 1](inputs, stack, builder);\n    properties.stackNode = stack;\n    builder.removeStack();\n    return properties;\n  }\n  getNodeType(builder) {\n    const {\n      returnsNode\n    } = this.getProperties(builder);\n    return returnsNode ? returnsNode.getNodeType(builder) : 'void';\n  }\n  setup(builder) {\n    // setup properties\n\n    this.getProperties(builder);\n  }\n  generate(builder) {\n    const properties = this.getProperties(builder);\n    const params = this.params;\n    const stackNode = properties.stackNode;\n    for (let i = 0, l = params.length - 1; i < l; i++) {\n      const param = params[i];\n      let start = null,\n        end = null,\n        name = null,\n        type = null,\n        condition = null,\n        update = null;\n      if (param.isNode) {\n        type = 'int';\n        name = this.getVarName(i);\n        start = '0';\n        end = param.build(builder, type);\n        condition = '<';\n      } else {\n        type = param.type || 'int';\n        name = param.name || this.getVarName(i);\n        start = param.start;\n        end = param.end;\n        condition = param.condition;\n        update = param.update;\n        if (typeof start === 'number') start = builder.generateConst(type, start);else if (start && start.isNode) start = start.build(builder, type);\n        if (typeof end === 'number') end = builder.generateConst(type, end);else if (end && end.isNode) end = end.build(builder, type);\n        if (start !== undefined && end === undefined) {\n          start = start + ' - 1';\n          end = '0';\n          condition = '>=';\n        } else if (end !== undefined && start === undefined) {\n          start = '0';\n          condition = '<';\n        }\n        if (condition === undefined) {\n          if (Number(start) > Number(end)) {\n            condition = '>=';\n          } else {\n            condition = '<';\n          }\n        }\n      }\n      const internalParam = {\n        start,\n        end,\n        condition\n      };\n\n      //\n\n      const startSnippet = internalParam.start;\n      const endSnippet = internalParam.end;\n      let declarationSnippet = '';\n      let conditionalSnippet = '';\n      let updateSnippet = '';\n      if (!update) {\n        if (type === 'int' || type === 'uint') {\n          if (condition.includes('<')) update = '++';else update = '--';\n        } else {\n          if (condition.includes('<')) update = '+= 1.';else update = '-= 1.';\n        }\n      }\n      declarationSnippet += builder.getVar(type, name) + ' = ' + startSnippet;\n      conditionalSnippet += name + ' ' + condition + ' ' + endSnippet;\n      updateSnippet += name + ' ' + update;\n      const forSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;\n      builder.addFlowCode((i === 0 ? '\\n' : '') + builder.tab + forSnippet + ' {\\n\\n').addFlowTab();\n    }\n    const stackSnippet = stackNode.build(builder, 'void');\n    const returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : '';\n    builder.removeFlowTab().addFlowCode('\\n' + builder.tab + stackSnippet);\n    for (let i = 0, l = this.params.length - 1; i < l; i++) {\n      builder.addFlowCode((i === 0 ? '' : builder.tab) + '}\\n\\n').removeFlowTab();\n    }\n    builder.addFlowTab();\n    return returnsSnippet;\n  }\n}\nconst Loop = function () {\n  for (var _len17 = arguments.length, params = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n    params[_key17] = arguments[_key17];\n  }\n  return nodeObject(new LoopNode(nodeArray(params, 'int'))).append();\n};\nconst Continue = () => expression('continue').append();\nconst Break = () => expression('break').append();\n\n//\n\nconst loop = function () {\n  // @deprecated, r168\n\n  console.warn('TSL.LoopNode: loop() has been renamed to Loop().');\n  return Loop(...arguments);\n};\nconst _morphTextures = /*@__PURE__*/new WeakMap();\nconst _morphVec4 = /*@__PURE__*/new Vector4();\nconst getMorph = /*@__PURE__*/Fn(_ref27 => {\n  let {\n    bufferMap,\n    influence,\n    stride,\n    width,\n    depth,\n    offset\n  } = _ref27;\n  const texelIndex = int(vertexIndex).mul(stride).add(offset);\n  const y = texelIndex.div(width);\n  const x = texelIndex.sub(y.mul(width));\n  const bufferAttrib = textureLoad(bufferMap, ivec2(x, y)).depth(depth);\n  return bufferAttrib.mul(influence);\n});\nfunction getEntry(geometry) {\n  const hasMorphPosition = geometry.morphAttributes.position !== undefined;\n  const hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n  const hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n  // instead of using attributes, the WebGL 2 code path encodes morph targets\n  // into an array of data textures. Each layer represents a single morph target.\n\n  const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n  const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n  let entry = _morphTextures.get(geometry);\n  if (entry === undefined || entry.count !== morphTargetsCount) {\n    if (entry !== undefined) entry.texture.dispose();\n    const morphTargets = geometry.morphAttributes.position || [];\n    const morphNormals = geometry.morphAttributes.normal || [];\n    const morphColors = geometry.morphAttributes.color || [];\n    let vertexDataCount = 0;\n    if (hasMorphPosition === true) vertexDataCount = 1;\n    if (hasMorphNormals === true) vertexDataCount = 2;\n    if (hasMorphColors === true) vertexDataCount = 3;\n    let width = geometry.attributes.position.count * vertexDataCount;\n    let height = 1;\n    const maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'\n\n    if (width > maxTextureSize) {\n      height = Math.ceil(width / maxTextureSize);\n      width = maxTextureSize;\n    }\n    const buffer = new Float32Array(width * height * 4 * morphTargetsCount);\n    const bufferTexture = new DataArrayTexture(buffer, width, height, morphTargetsCount);\n    bufferTexture.type = FloatType;\n    bufferTexture.needsUpdate = true;\n\n    // fill buffer\n\n    const vertexDataStride = vertexDataCount * 4;\n    for (let i = 0; i < morphTargetsCount; i++) {\n      const morphTarget = morphTargets[i];\n      const morphNormal = morphNormals[i];\n      const morphColor = morphColors[i];\n      const offset = width * height * 4 * i;\n      for (let j = 0; j < morphTarget.count; j++) {\n        const stride = j * vertexDataStride;\n        if (hasMorphPosition === true) {\n          _morphVec4.fromBufferAttribute(morphTarget, j);\n          buffer[offset + stride + 0] = _morphVec4.x;\n          buffer[offset + stride + 1] = _morphVec4.y;\n          buffer[offset + stride + 2] = _morphVec4.z;\n          buffer[offset + stride + 3] = 0;\n        }\n        if (hasMorphNormals === true) {\n          _morphVec4.fromBufferAttribute(morphNormal, j);\n          buffer[offset + stride + 4] = _morphVec4.x;\n          buffer[offset + stride + 5] = _morphVec4.y;\n          buffer[offset + stride + 6] = _morphVec4.z;\n          buffer[offset + stride + 7] = 0;\n        }\n        if (hasMorphColors === true) {\n          _morphVec4.fromBufferAttribute(morphColor, j);\n          buffer[offset + stride + 8] = _morphVec4.x;\n          buffer[offset + stride + 9] = _morphVec4.y;\n          buffer[offset + stride + 10] = _morphVec4.z;\n          buffer[offset + stride + 11] = morphColor.itemSize === 4 ? _morphVec4.w : 1;\n        }\n      }\n    }\n    entry = {\n      count: morphTargetsCount,\n      texture: bufferTexture,\n      stride: vertexDataCount,\n      size: new Vector2(width, height)\n    };\n    _morphTextures.set(geometry, entry);\n    function disposeTexture() {\n      bufferTexture.dispose();\n      _morphTextures.delete(geometry);\n      geometry.removeEventListener('dispose', disposeTexture);\n    }\n    geometry.addEventListener('dispose', disposeTexture);\n  }\n  return entry;\n}\nclass MorphNode extends Node {\n  static get type() {\n    return 'MorphNode';\n  }\n  constructor(mesh) {\n    super('void');\n    this.mesh = mesh;\n    this.morphBaseInfluence = uniform(1);\n    this.updateType = NodeUpdateType.OBJECT;\n  }\n  setup(builder) {\n    const {\n      geometry\n    } = builder;\n    const hasMorphPosition = geometry.morphAttributes.position !== undefined;\n    const hasMorphNormals = geometry.hasAttribute('normal') && geometry.morphAttributes.normal !== undefined;\n    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n    const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n\n    // nodes\n\n    const {\n      texture: bufferMap,\n      stride,\n      size\n    } = getEntry(geometry);\n    if (hasMorphPosition === true) positionLocal.mulAssign(this.morphBaseInfluence);\n    if (hasMorphNormals === true) normalLocal.mulAssign(this.morphBaseInfluence);\n    const width = int(size.width);\n    Loop(morphTargetsCount, _ref28 => {\n      let {\n        i\n      } = _ref28;\n      const influence = float(0).toVar();\n      if (this.mesh.count > 1 && this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined) {\n        influence.assign(textureLoad(this.mesh.morphTexture, ivec2(int(i).add(1), int(instanceIndex))).r);\n      } else {\n        influence.assign(reference('morphTargetInfluences', 'float').element(i).toVar());\n      }\n      if (hasMorphPosition === true) {\n        positionLocal.addAssign(getMorph({\n          bufferMap,\n          influence,\n          stride,\n          width,\n          depth: i,\n          offset: int(0)\n        }));\n      }\n      if (hasMorphNormals === true) {\n        normalLocal.addAssign(getMorph({\n          bufferMap,\n          influence,\n          stride,\n          width,\n          depth: i,\n          offset: int(1)\n        }));\n      }\n    });\n  }\n  update() {\n    const morphBaseInfluence = this.morphBaseInfluence;\n    if (this.mesh.geometry.morphTargetsRelative) {\n      morphBaseInfluence.value = 1;\n    } else {\n      morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a, b) => a + b, 0);\n    }\n  }\n}\nconst morphReference = /*@__PURE__*/nodeProxy(MorphNode);\nclass LightingNode extends Node {\n  static get type() {\n    return 'LightingNode';\n  }\n  constructor() {\n    super('vec3');\n    this.isLightingNode = true;\n  }\n  generate(/*builder*/\n  ) {\n    console.warn('Abstract function.');\n  }\n}\nclass AONode extends LightingNode {\n  static get type() {\n    return 'AONode';\n  }\n  constructor() {\n    let aoNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this.aoNode = aoNode;\n  }\n  setup(builder) {\n    builder.context.ambientOcclusion.mulAssign(this.aoNode);\n  }\n}\nclass LightingContextNode extends ContextNode {\n  static get type() {\n    return 'LightingContextNode';\n  }\n  constructor(node) {\n    let lightingModel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let backdropNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let backdropAlphaNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    super(node);\n    this.lightingModel = lightingModel;\n    this.backdropNode = backdropNode;\n    this.backdropAlphaNode = backdropAlphaNode;\n    this._value = null;\n  }\n  getContext() {\n    const {\n      backdropNode,\n      backdropAlphaNode\n    } = this;\n    const directDiffuse = vec3().toVar('directDiffuse'),\n      directSpecular = vec3().toVar('directSpecular'),\n      indirectDiffuse = vec3().toVar('indirectDiffuse'),\n      indirectSpecular = vec3().toVar('indirectSpecular');\n    const reflectedLight = {\n      directDiffuse,\n      directSpecular,\n      indirectDiffuse,\n      indirectSpecular\n    };\n    const context = {\n      radiance: vec3().toVar('radiance'),\n      irradiance: vec3().toVar('irradiance'),\n      iblIrradiance: vec3().toVar('iblIrradiance'),\n      ambientOcclusion: float(1).toVar('ambientOcclusion'),\n      reflectedLight,\n      backdrop: backdropNode,\n      backdropAlpha: backdropAlphaNode\n    };\n    return context;\n  }\n  setup(builder) {\n    this.value = this._value || (this._value = this.getContext());\n    this.value.lightingModel = this.lightingModel || builder.context.lightingModel;\n    return super.setup(builder);\n  }\n}\nconst lightingContext = /*@__PURE__*/nodeProxy(LightingContextNode);\nclass IrradianceNode extends LightingNode {\n  static get type() {\n    return 'IrradianceNode';\n  }\n  constructor(node) {\n    super();\n    this.node = node;\n  }\n  setup(builder) {\n    builder.context.irradiance.addAssign(this.node);\n  }\n}\nlet screenSizeVec, viewportVec;\nclass ScreenNode extends Node {\n  static get type() {\n    return 'ScreenNode';\n  }\n  constructor(scope) {\n    super();\n    this.scope = scope;\n    this.isViewportNode = true;\n  }\n  getNodeType() {\n    if (this.scope === ScreenNode.VIEWPORT) return 'vec4';else return 'vec2';\n  }\n  getUpdateType() {\n    let updateType = NodeUpdateType.NONE;\n    if (this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT) {\n      updateType = NodeUpdateType.RENDER;\n    }\n    this.updateType = updateType;\n    return updateType;\n  }\n  update(_ref29) {\n    let {\n      renderer\n    } = _ref29;\n    const renderTarget = renderer.getRenderTarget();\n    if (this.scope === ScreenNode.VIEWPORT) {\n      if (renderTarget !== null) {\n        viewportVec.copy(renderTarget.viewport);\n      } else {\n        renderer.getViewport(viewportVec);\n        viewportVec.multiplyScalar(renderer.getPixelRatio());\n      }\n    } else {\n      if (renderTarget !== null) {\n        screenSizeVec.width = renderTarget.width;\n        screenSizeVec.height = renderTarget.height;\n      } else {\n        renderer.getDrawingBufferSize(screenSizeVec);\n      }\n    }\n  }\n  setup(/*builder*/\n  ) {\n    const scope = this.scope;\n    let output = null;\n    if (scope === ScreenNode.SIZE) {\n      output = uniform(screenSizeVec || (screenSizeVec = new Vector2()));\n    } else if (scope === ScreenNode.VIEWPORT) {\n      output = uniform(viewportVec || (viewportVec = new Vector4()));\n    } else {\n      output = vec2(screenCoordinate.div(screenSize));\n    }\n    return output;\n  }\n  generate(builder) {\n    if (this.scope === ScreenNode.COORDINATE) {\n      let coord = builder.getFragCoord();\n      if (builder.isFlipY()) {\n        // follow webgpu standards\n\n        const size = builder.getNodeProperties(screenSize).outputNode.build(builder);\n        coord = `${builder.getType('vec2')}( ${coord}.x, ${size}.y - ${coord}.y )`;\n      }\n      return coord;\n    }\n    return super.generate(builder);\n  }\n}\nScreenNode.COORDINATE = 'coordinate';\nScreenNode.VIEWPORT = 'viewport';\nScreenNode.SIZE = 'size';\nScreenNode.UV = 'uv';\n\n// Screen\n\nconst screenUV = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.UV);\nconst screenSize = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.SIZE);\nconst screenCoordinate = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.COORDINATE);\n\n// Viewport\n\nconst viewport = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.VIEWPORT);\nconst viewportSize = viewport.zw;\nconst viewportCoordinate = /*@__PURE__*/screenCoordinate.sub(viewport.xy);\nconst viewportUV = /*@__PURE__*/viewportCoordinate.div(viewportSize);\n\n// Deprecated\n\nconst viewportResolution = /*@__PURE__*/Fn(() => {\n  // @deprecated, r169\n\n  console.warn('TSL.ViewportNode: \"viewportResolution\" is deprecated. Use \"screenSize\" instead.');\n  return screenSize;\n}, 'vec2').once()();\nconst viewportTopLeft = /*@__PURE__*/Fn(() => {\n  // @deprecated, r168\n\n  console.warn('TSL.ViewportNode: \"viewportTopLeft\" is deprecated. Use \"screenUV\" instead.');\n  return screenUV;\n}, 'vec2').once()();\nconst viewportBottomLeft = /*@__PURE__*/Fn(() => {\n  // @deprecated, r168\n\n  console.warn('TSL.ViewportNode: \"viewportBottomLeft\" is deprecated. Use \"screenUV.flipY()\" instead.');\n  return screenUV.flipY();\n}, 'vec2').once()();\nconst _size$4 = /*@__PURE__*/new Vector2();\nclass ViewportTextureNode extends TextureNode {\n  static get type() {\n    return 'ViewportTextureNode';\n  }\n  constructor() {\n    let uvNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenUV;\n    let levelNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let framebufferTexture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (framebufferTexture === null) {\n      framebufferTexture = new FramebufferTexture();\n      framebufferTexture.minFilter = LinearMipmapLinearFilter;\n    }\n    super(framebufferTexture, uvNode, levelNode);\n    this.generateMipmaps = false;\n    this.isOutputTextureNode = true;\n    this.updateBeforeType = NodeUpdateType.FRAME;\n  }\n  updateBefore(frame) {\n    const renderer = frame.renderer;\n    renderer.getDrawingBufferSize(_size$4);\n\n    //\n\n    const framebufferTexture = this.value;\n    if (framebufferTexture.image.width !== _size$4.width || framebufferTexture.image.height !== _size$4.height) {\n      framebufferTexture.image.width = _size$4.width;\n      framebufferTexture.image.height = _size$4.height;\n      framebufferTexture.needsUpdate = true;\n    }\n\n    //\n\n    const currentGenerateMipmaps = framebufferTexture.generateMipmaps;\n    framebufferTexture.generateMipmaps = this.generateMipmaps;\n    renderer.copyFramebufferToTexture(framebufferTexture);\n    framebufferTexture.generateMipmaps = currentGenerateMipmaps;\n  }\n  clone() {\n    const viewportTextureNode = new this.constructor(this.uvNode, this.levelNode, this.value);\n    viewportTextureNode.generateMipmaps = this.generateMipmaps;\n    return viewportTextureNode;\n  }\n}\nconst viewportTexture = /*@__PURE__*/nodeProxy(ViewportTextureNode);\nconst viewportMipTexture = /*@__PURE__*/nodeProxy(ViewportTextureNode, null, null, {\n  generateMipmaps: true\n});\nlet sharedDepthbuffer = null;\nclass ViewportDepthTextureNode extends ViewportTextureNode {\n  static get type() {\n    return 'ViewportDepthTextureNode';\n  }\n  constructor() {\n    let uvNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenUV;\n    let levelNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (sharedDepthbuffer === null) {\n      sharedDepthbuffer = new DepthTexture();\n    }\n    super(uvNode, levelNode, sharedDepthbuffer);\n  }\n}\nconst viewportDepthTexture = /*@__PURE__*/nodeProxy(ViewportDepthTextureNode);\nclass ViewportDepthNode extends Node {\n  static get type() {\n    return 'ViewportDepthNode';\n  }\n  constructor(scope) {\n    let valueNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super('float');\n    this.scope = scope;\n    this.valueNode = valueNode;\n    this.isViewportDepthNode = true;\n  }\n  generate(builder) {\n    const {\n      scope\n    } = this;\n    if (scope === ViewportDepthNode.DEPTH_BASE) {\n      return builder.getFragDepth();\n    }\n    return super.generate(builder);\n  }\n  setup(_ref30) {\n    let {\n      camera\n    } = _ref30;\n    const {\n      scope\n    } = this;\n    const value = this.valueNode;\n    let node = null;\n    if (scope === ViewportDepthNode.DEPTH_BASE) {\n      if (value !== null) {\n        node = depthBase().assign(value);\n      }\n    } else if (scope === ViewportDepthNode.DEPTH) {\n      if (camera.isPerspectiveCamera) {\n        node = viewZToPerspectiveDepth(positionView.z, cameraNear, cameraFar);\n      } else {\n        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);\n      }\n    } else if (scope === ViewportDepthNode.LINEAR_DEPTH) {\n      if (value !== null) {\n        if (camera.isPerspectiveCamera) {\n          const viewZ = perspectiveDepthToViewZ(value, cameraNear, cameraFar);\n          node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\n        } else {\n          node = value;\n        }\n      } else {\n        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);\n      }\n    }\n    return node;\n  }\n}\nViewportDepthNode.DEPTH_BASE = 'depthBase';\nViewportDepthNode.DEPTH = 'depth';\nViewportDepthNode.LINEAR_DEPTH = 'linearDepth';\n\n// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera\n\n// -near maps to 0; -far maps to 1\nconst viewZToOrthographicDepth = (viewZ, near, far) => viewZ.add(near).div(near.sub(far));\n\n// maps orthographic depth in [ 0, 1 ] to viewZ\nconst orthographicDepthToViewZ = (depth, near, far) => near.sub(far).mul(depth).sub(near);\n\n// NOTE: https://twitter.com/gonnavis/status/1377183786949959682\n\n// -near maps to 0; -far maps to 1\nconst viewZToPerspectiveDepth = (viewZ, near, far) => near.add(viewZ).mul(far).div(far.sub(near).mul(viewZ));\n\n// maps perspective depth in [ 0, 1 ] to viewZ\nconst perspectiveDepthToViewZ = (depth, near, far) => near.mul(far).div(far.sub(near).mul(depth).sub(far));\n\n// -near maps to 0; -far maps to 1\nconst viewZToLogarithmicDepth = (viewZ, near, far) => {\n  // NOTE: viewZ must be negative--see explanation at the end of this comment block.\n  // The final logarithmic depth formula used here is adapted from one described in an\n  // article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),\n  // which was an improvement upon an earlier formula one described in an\n  // Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).\n  // Ulrich's formula is the following:\n  //     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )\n  //     where K = 2^k - 1, and k is the number of bits in the depth buffer.\n  // The Outerra variant ignored the camera near plane (it assumed it was 0) and instead\n  // opted for a \"C-constant\" for resolution adjustment of objects near the camera.\n  // Outerra states: \"Notice that the 'C' variant doesnt use a near plane distance, it has it\n  // set at 0\" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).\n  // Ulrich's variant has the benefit of constant relative precision over the whole near-far range.\n  // It was debated here whether Outerra's \"C-constant\" or Ulrich's \"near plane\" variant should\n  // be used, and ultimately Ulrich's \"near plane\" version was chosen.\n  // Outerra eventually made another improvement to their original \"C-constant\" variant,\n  // but it still does not incorporate the camera near plane (for this version,\n  // see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).\n  // Here we make 4 changes to Ulrich's formula:\n  // 1. Clamp the camera near plane so we don't divide by 0.\n  // 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).\n  // 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).\n  // 4. To maintain consistency with the functions \"viewZToOrthographicDepth\" and \"viewZToPerspectiveDepth\",\n  //    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,\n  //    so we do the same here, hence the 'viewZ.negate()' call.\n  // For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u\n  near = near.max(1e-6).toVar();\n  const numerator = log2(viewZ.negate().div(near));\n  const denominator = log2(far.div(near));\n  return numerator.div(denominator);\n};\n\n// maps logarithmic depth in [ 0, 1 ] to viewZ\nconst logarithmicDepthToViewZ = (depth, near, far) => {\n  // NOTE: we add a 'negate()' call to the return value here to maintain consistency with\n  // the functions \"orthographicDepthToViewZ\" and \"perspectiveDepthToViewZ\" (they return\n  // a negative viewZ).\n  const exponent = depth.mul(log(far.div(near)));\n  return float(Math.E).pow(exponent).mul(near).negate();\n};\nconst depthBase = /*@__PURE__*/nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_BASE);\nconst depth = /*@__PURE__*/nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);\nconst linearDepth = /*@__PURE__*/nodeProxy(ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH);\nconst viewportLinearDepth = /*@__PURE__*/linearDepth(viewportDepthTexture());\ndepth.assign = value => depthBase(value);\nclass BuiltinNode extends Node {\n  constructor(name) {\n    super('float');\n    this.name = name;\n    this.isBuiltinNode = true;\n  }\n  generate(/* builder */\n  ) {\n    return this.name;\n  }\n}\nconst builtin = nodeProxy(BuiltinNode);\nclass ClippingNode extends Node {\n  static get type() {\n    return 'ClippingNode';\n  }\n  constructor() {\n    let scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ClippingNode.DEFAULT;\n    super();\n    this.scope = scope;\n  }\n  setup(builder) {\n    super.setup(builder);\n    const clippingContext = builder.clippingContext;\n    const {\n      intersectionPlanes,\n      unionPlanes\n    } = clippingContext;\n    this.hardwareClipping = builder.material.hardwareClipping;\n    if (this.scope === ClippingNode.ALPHA_TO_COVERAGE) {\n      return this.setupAlphaToCoverage(intersectionPlanes, unionPlanes);\n    } else if (this.scope === ClippingNode.HARDWARE) {\n      return this.setupHardwareClipping(unionPlanes, builder);\n    } else {\n      return this.setupDefault(intersectionPlanes, unionPlanes);\n    }\n  }\n  setupAlphaToCoverage(intersectionPlanes, unionPlanes) {\n    return Fn(() => {\n      const distanceToPlane = float().toVar('distanceToPlane');\n      const distanceGradient = float().toVar('distanceToGradient');\n      const clipOpacity = float(1).toVar('clipOpacity');\n      const numUnionPlanes = unionPlanes.length;\n      if (!this.hardwareClipping && numUnionPlanes > 0) {\n        const clippingPlanes = uniformArray(unionPlanes);\n        Loop(numUnionPlanes, _ref31 => {\n          let {\n            i\n          } = _ref31;\n          const plane = clippingPlanes.element(i);\n          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));\n          distanceGradient.assign(distanceToPlane.fwidth().div(2.0));\n          clipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane));\n        });\n      }\n      const numIntersectionPlanes = intersectionPlanes.length;\n      if (numIntersectionPlanes > 0) {\n        const clippingPlanes = uniformArray(intersectionPlanes);\n        const intersectionClipOpacity = float(1).toVar('intersectionClipOpacity');\n        Loop(numIntersectionPlanes, _ref32 => {\n          let {\n            i\n          } = _ref32;\n          const plane = clippingPlanes.element(i);\n          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));\n          distanceGradient.assign(distanceToPlane.fwidth().div(2.0));\n          intersectionClipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane).oneMinus());\n        });\n        clipOpacity.mulAssign(intersectionClipOpacity.oneMinus());\n      }\n      diffuseColor.a.mulAssign(clipOpacity);\n      diffuseColor.a.equal(0.0).discard();\n    })();\n  }\n  setupDefault(intersectionPlanes, unionPlanes) {\n    return Fn(() => {\n      const numUnionPlanes = unionPlanes.length;\n      if (!this.hardwareClipping && numUnionPlanes > 0) {\n        const clippingPlanes = uniformArray(unionPlanes);\n        Loop(numUnionPlanes, _ref33 => {\n          let {\n            i\n          } = _ref33;\n          const plane = clippingPlanes.element(i);\n          positionView.dot(plane.xyz).greaterThan(plane.w).discard();\n        });\n      }\n      const numIntersectionPlanes = intersectionPlanes.length;\n      if (numIntersectionPlanes > 0) {\n        const clippingPlanes = uniformArray(intersectionPlanes);\n        const clipped = bool(true).toVar('clipped');\n        Loop(numIntersectionPlanes, _ref34 => {\n          let {\n            i\n          } = _ref34;\n          const plane = clippingPlanes.element(i);\n          clipped.assign(positionView.dot(plane.xyz).greaterThan(plane.w).and(clipped));\n        });\n        clipped.discard();\n      }\n    })();\n  }\n  setupHardwareClipping(unionPlanes, builder) {\n    const numUnionPlanes = unionPlanes.length;\n    builder.enableHardwareClipping(numUnionPlanes);\n    return Fn(() => {\n      const clippingPlanes = uniformArray(unionPlanes);\n      const hw_clip_distances = builtin(builder.getClipDistance());\n      Loop(numUnionPlanes, _ref35 => {\n        let {\n          i\n        } = _ref35;\n        const plane = clippingPlanes.element(i);\n        const distance = positionView.dot(plane.xyz).sub(plane.w).negate();\n        hw_clip_distances.element(i).assign(distance);\n      });\n    })();\n  }\n}\nClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';\nClippingNode.DEFAULT = 'default';\nClippingNode.HARDWARE = 'hardware';\nconst clipping = () => nodeObject(new ClippingNode());\nconst clippingAlpha = () => nodeObject(new ClippingNode(ClippingNode.ALPHA_TO_COVERAGE));\nconst hardwareClipping = () => nodeObject(new ClippingNode(ClippingNode.HARDWARE));\n\n/**\n * See: https://casual-effects.com/research/Wyman2017Hashed/index.html\n */\n\nconst ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.\n\nconst hash2D = /*@__PURE__*/Fn(_ref36 => {\n  let [value] = _ref36;\n  return fract(mul(1.0e4, sin(mul(17.0, value.x).add(mul(0.1, value.y)))).mul(add(0.1, abs(sin(mul(13.0, value.y).add(value.x))))));\n});\nconst hash3D = /*@__PURE__*/Fn(_ref37 => {\n  let [value] = _ref37;\n  return hash2D(vec2(hash2D(value.xy), value.z));\n});\nconst getAlphaHashThreshold = /*@__PURE__*/Fn(_ref38 => {\n  let [position] = _ref38;\n  // Find the discretized derivatives of our coordinates\n  const maxDeriv = max$1(length(dFdx(position.xyz)), length(dFdy(position.xyz)));\n  const pixScale = float(1).div(float(ALPHA_HASH_SCALE).mul(maxDeriv)).toVar('pixScale');\n\n  // Find two nearest log-discretized noise scales\n  const pixScales = vec2(exp2(floor(log2(pixScale))), exp2(ceil(log2(pixScale))));\n\n  // Compute alpha thresholds at our two noise scales\n  const alpha = vec2(hash3D(floor(pixScales.x.mul(position.xyz))), hash3D(floor(pixScales.y.mul(position.xyz))));\n\n  // Factor to interpolate lerp with\n  const lerpFactor = fract(log2(pixScale));\n\n  // Interpolate alpha threshold from noise at two scales\n  const x = add(mul(lerpFactor.oneMinus(), alpha.x), mul(lerpFactor, alpha.y));\n\n  // Pass into CDF to compute uniformly distrib threshold\n  const a = min$1(lerpFactor, lerpFactor.oneMinus());\n  const cases = vec3(x.mul(x).div(mul(2.0, a).mul(sub(1.0, a))), x.sub(mul(0.5, a)).div(sub(1.0, a)), sub(1.0, sub(1.0, x).mul(sub(1.0, x)).div(mul(2.0, a).mul(sub(1.0, a)))));\n\n  // Find our final, uniformly distributed alpha threshold ()\n  const threshold = x.lessThan(a.oneMinus()).select(x.lessThan(a).select(cases.x, cases.y), cases.z);\n\n  // Avoids  == 0. Could also do  =1-\n  return clamp(threshold, 1.0e-6, 1.0);\n}).setLayout({\n  name: 'getAlphaHashThreshold',\n  type: 'float',\n  inputs: [{\n    name: 'position',\n    type: 'vec3'\n  }]\n});\nclass NodeMaterial extends Material {\n  static get type() {\n    return 'NodeMaterial';\n  }\n  get type() {\n    return this.constructor.type;\n  }\n  set type(_value) {/* */}\n  constructor() {\n    super();\n    this.isNodeMaterial = true;\n    this.forceSinglePass = false;\n    this.fog = true;\n    this.lights = false;\n    this.hardwareClipping = false;\n    this.lightsNode = null;\n    this.envNode = null;\n    this.aoNode = null;\n    this.colorNode = null;\n    this.normalNode = null;\n    this.opacityNode = null;\n    this.backdropNode = null;\n    this.backdropAlphaNode = null;\n    this.alphaTestNode = null;\n    this.positionNode = null;\n    this.geometryNode = null;\n    this.depthNode = null;\n    this.shadowPositionNode = null;\n    this.receivedShadowNode = null;\n    this.castShadowNode = null;\n    this.outputNode = null;\n    this.mrtNode = null;\n    this.fragmentNode = null;\n    this.vertexNode = null;\n  }\n  customProgramCacheKey() {\n    return this.type + getCacheKey$1(this);\n  }\n  build(builder) {\n    this.setup(builder);\n  }\n  setupObserver(builder) {\n    return new NodeMaterialObserver(builder);\n  }\n  setup(builder) {\n    builder.context.setupNormal = () => this.setupNormal(builder);\n    const renderer = builder.renderer;\n    const renderTarget = renderer.getRenderTarget();\n\n    // < VERTEX STAGE >\n\n    builder.addStack();\n    builder.stack.outputNode = this.vertexNode || this.setupPosition(builder);\n    if (this.geometryNode !== null) {\n      builder.stack.outputNode = builder.stack.outputNode.bypass(this.geometryNode);\n    }\n    builder.addFlow('vertex', builder.removeStack());\n\n    // < FRAGMENT STAGE >\n\n    builder.addStack();\n    let resultNode;\n    const clippingNode = this.setupClipping(builder);\n    if (this.depthWrite === true) {\n      // only write depth if depth buffer is configured\n\n      if (renderTarget !== null) {\n        if (renderTarget.depthBuffer === true) this.setupDepth(builder);\n      } else {\n        if (renderer.depth === true) this.setupDepth(builder);\n      }\n    }\n    if (this.fragmentNode === null) {\n      this.setupDiffuseColor(builder);\n      this.setupVariants(builder);\n      const outgoingLightNode = this.setupLighting(builder);\n      if (clippingNode !== null) builder.stack.add(clippingNode);\n\n      // force unsigned floats - useful for RenderTargets\n\n      const basicOutput = vec4(outgoingLightNode, diffuseColor.a).max(0);\n      resultNode = this.setupOutput(builder, basicOutput);\n\n      // OUTPUT NODE\n\n      output.assign(resultNode);\n\n      //\n\n      if (this.outputNode !== null) resultNode = this.outputNode;\n\n      // MRT\n\n      if (renderTarget !== null) {\n        const mrt = renderer.getMRT();\n        const materialMRT = this.mrtNode;\n        if (mrt !== null) {\n          resultNode = mrt;\n          if (materialMRT !== null) {\n            resultNode = mrt.merge(materialMRT);\n          }\n        } else if (materialMRT !== null) {\n          resultNode = materialMRT;\n        }\n      }\n    } else {\n      let fragmentNode = this.fragmentNode;\n      if (fragmentNode.isOutputStructNode !== true) {\n        fragmentNode = vec4(fragmentNode);\n      }\n      resultNode = this.setupOutput(builder, fragmentNode);\n    }\n    builder.stack.outputNode = resultNode;\n    builder.addFlow('fragment', builder.removeStack());\n\n    // < MONITOR >\n\n    builder.monitor = this.setupObserver(builder);\n  }\n  setupClipping(builder) {\n    if (builder.clippingContext === null) return null;\n    const {\n      unionPlanes,\n      intersectionPlanes\n    } = builder.clippingContext;\n    let result = null;\n    if (unionPlanes.length > 0 || intersectionPlanes.length > 0) {\n      const samples = builder.renderer.samples;\n      if (this.alphaToCoverage && samples > 1) {\n        // to be added to flow when the color/alpha value has been determined\n        result = clippingAlpha();\n      } else {\n        builder.stack.add(clipping());\n      }\n    }\n    return result;\n  }\n  setupHardwareClipping(builder) {\n    this.hardwareClipping = false;\n    if (builder.clippingContext === null) return;\n    const candidateCount = builder.clippingContext.unionPlanes.length;\n\n    // 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances\n\n    if (candidateCount > 0 && candidateCount <= 8 && builder.isAvailable('clipDistance')) {\n      builder.stack.add(hardwareClipping());\n      this.hardwareClipping = true;\n    }\n    return;\n  }\n  setupDepth(builder) {\n    const {\n      renderer,\n      camera\n    } = builder;\n\n    // Depth\n\n    let depthNode = this.depthNode;\n    if (depthNode === null) {\n      const mrt = renderer.getMRT();\n      if (mrt && mrt.has('depth')) {\n        depthNode = mrt.get('depth');\n      } else if (renderer.logarithmicDepthBuffer === true) {\n        if (camera.isPerspectiveCamera) {\n          depthNode = viewZToLogarithmicDepth(positionView.z, cameraNear, cameraFar);\n        } else {\n          depthNode = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);\n        }\n      }\n    }\n    if (depthNode !== null) {\n      depth.assign(depthNode).append();\n    }\n  }\n  setupPosition(builder) {\n    const {\n      object\n    } = builder;\n    const geometry = object.geometry;\n    builder.addStack();\n\n    // Vertex\n\n    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {\n      morphReference(object).append();\n    }\n    if (object.isSkinnedMesh === true) {\n      skinningReference(object).append();\n    }\n    if (this.displacementMap) {\n      const displacementMap = materialReference('displacementMap', 'texture');\n      const displacementScale = materialReference('displacementScale', 'float');\n      const displacementBias = materialReference('displacementBias', 'float');\n      positionLocal.addAssign(normalLocal.normalize().mul(displacementMap.x.mul(displacementScale).add(displacementBias)));\n    }\n    if (object.isBatchedMesh) {\n      batch(object).append();\n    }\n    if (object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true) {\n      instancedMesh(object).append();\n    }\n    if (this.positionNode !== null) {\n      positionLocal.assign(this.positionNode);\n    }\n    this.setupHardwareClipping(builder);\n    const mvp = modelViewProjection();\n    builder.context.vertex = builder.removeStack();\n    builder.context.mvp = mvp;\n    return mvp;\n  }\n  setupDiffuseColor(_ref39) {\n    let {\n      object,\n      geometry\n    } = _ref39;\n    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;\n\n    // VERTEX COLORS\n\n    if (this.vertexColors === true && geometry.hasAttribute('color')) {\n      colorNode = vec4(colorNode.xyz.mul(attribute('color', 'vec3')), colorNode.a);\n    }\n\n    // Instanced colors\n\n    if (object.instanceColor) {\n      const instanceColor = varyingProperty('vec3', 'vInstanceColor');\n      colorNode = instanceColor.mul(colorNode);\n    }\n    if (object.isBatchedMesh && object._colorsTexture) {\n      const batchColor = varyingProperty('vec3', 'vBatchColor');\n      colorNode = batchColor.mul(colorNode);\n    }\n\n    // COLOR\n\n    diffuseColor.assign(colorNode);\n\n    // OPACITY\n\n    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n    diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));\n\n    // ALPHA TEST\n\n    if (this.alphaTestNode !== null || this.alphaTest > 0) {\n      const alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;\n      diffuseColor.a.lessThanEqual(alphaTestNode).discard();\n    }\n\n    // ALPHA HASH\n\n    if (this.alphaHash === true) {\n      diffuseColor.a.lessThan(getAlphaHashThreshold(positionLocal)).discard();\n    }\n    if (this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false) {\n      diffuseColor.a.assign(1.0);\n    }\n  }\n  setupVariants(/*builder*/\n  ) {\n\n    // Interface function.\n  }\n  setupOutgoingLight() {\n    return this.lights === true ? vec3(0) : diffuseColor.rgb;\n  }\n  setupNormal() {\n    return this.normalNode ? vec3(this.normalNode) : materialNormal;\n  }\n  setupEnvironment(/*builder*/\n  ) {\n    let node = null;\n    if (this.envNode) {\n      node = this.envNode;\n    } else if (this.envMap) {\n      node = this.envMap.isCubeTexture ? materialReference('envMap', 'cubeTexture') : materialReference('envMap', 'texture');\n    }\n    return node;\n  }\n  setupLightMap(builder) {\n    let node = null;\n    if (builder.material.lightMap) {\n      node = new IrradianceNode(materialLightMap);\n    }\n    return node;\n  }\n  setupLights(builder) {\n    const materialLightsNode = [];\n\n    //\n\n    const envNode = this.setupEnvironment(builder);\n    if (envNode && envNode.isLightingNode) {\n      materialLightsNode.push(envNode);\n    }\n    const lightMapNode = this.setupLightMap(builder);\n    if (lightMapNode && lightMapNode.isLightingNode) {\n      materialLightsNode.push(lightMapNode);\n    }\n    if (this.aoNode !== null || builder.material.aoMap) {\n      const aoNode = this.aoNode !== null ? this.aoNode : materialAOMap;\n      materialLightsNode.push(new AONode(aoNode));\n    }\n    let lightsN = this.lightsNode || builder.lightsNode;\n    if (materialLightsNode.length > 0) {\n      lightsN = builder.renderer.lighting.createNode([...lightsN.getLights(), ...materialLightsNode]);\n    }\n    return lightsN;\n  }\n  setupLightingModel(/*builder*/\n  ) {\n\n    // Interface function.\n  }\n  setupLighting(builder) {\n    const {\n      material\n    } = builder;\n    const {\n      backdropNode,\n      backdropAlphaNode,\n      emissiveNode\n    } = this;\n\n    // OUTGOING LIGHT\n\n    const lights = this.lights === true || this.lightsNode !== null;\n    const lightsNode = lights ? this.setupLights(builder) : null;\n    let outgoingLightNode = this.setupOutgoingLight(builder);\n    if (lightsNode && lightsNode.getScope().hasLights) {\n      const lightingModel = this.setupLightingModel(builder);\n      outgoingLightNode = lightingContext(lightsNode, lightingModel, backdropNode, backdropAlphaNode);\n    } else if (backdropNode !== null) {\n      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);\n    }\n\n    // EMISSIVE\n\n    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {\n      emissive.assign(vec3(emissiveNode ? emissiveNode : materialEmissive));\n      outgoingLightNode = outgoingLightNode.add(emissive);\n    }\n    return outgoingLightNode;\n  }\n  setupOutput(builder, outputNode) {\n    // FOG\n\n    if (this.fog === true) {\n      const fogNode = builder.fogNode;\n      if (fogNode) outputNode = vec4(fogNode.mix(outputNode.rgb, fogNode.colorNode), outputNode.a);\n    }\n    return outputNode;\n  }\n  setDefaultValues(material) {\n    // This approach is to reuse the native refreshUniforms*\n    // and turn available the use of features like transmission and environment in core\n\n    for (const property in material) {\n      const value = material[property];\n      if (this[property] === undefined) {\n        this[property] = value;\n        if (value && value.clone) this[property] = value.clone();\n      }\n    }\n    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);\n    for (const key in descriptors) {\n      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === undefined && descriptors[key].get !== undefined) {\n        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRoot = meta === undefined || typeof meta === 'string';\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n    const data = Material.prototype.toJSON.call(this, meta);\n    const nodeChildren = getNodeChildren(this);\n    data.inputNodes = {};\n    for (const {\n      property,\n      childNode\n    } of nodeChildren) {\n      data.inputNodes[property] = childNode.toJSON(meta).uuid;\n    }\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n  copy(source) {\n    this.lightsNode = source.lightsNode;\n    this.envNode = source.envNode;\n    this.colorNode = source.colorNode;\n    this.normalNode = source.normalNode;\n    this.opacityNode = source.opacityNode;\n    this.backdropNode = source.backdropNode;\n    this.backdropAlphaNode = source.backdropAlphaNode;\n    this.alphaTestNode = source.alphaTestNode;\n    this.positionNode = source.positionNode;\n    this.geometryNode = source.geometryNode;\n    this.depthNode = source.depthNode;\n    this.shadowPositionNode = source.shadowPositionNode;\n    this.receivedShadowNode = source.receivedShadowNode;\n    this.castShadowNode = source.castShadowNode;\n    this.outputNode = source.outputNode;\n    this.mrtNode = source.mrtNode;\n    this.fragmentNode = source.fragmentNode;\n    this.vertexNode = source.vertexNode;\n    return super.copy(source);\n  }\n}\nconst _defaultValues$e = /*@__PURE__*/new PointsMaterial();\nclass InstancedPointsNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'InstancedPointsNodeMaterial';\n  }\n  constructor() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.lights = false;\n    this.useAlphaToCoverage = true;\n    this.useColor = params.vertexColors;\n    this.pointWidth = 1;\n    this.pointColorNode = null;\n    this.pointWidthNode = null;\n    this.setDefaultValues(_defaultValues$e);\n    this.setValues(params);\n  }\n  setup(builder) {\n    this.setupShaders(builder);\n    super.setup(builder);\n  }\n  setupShaders(_ref40) {\n    let {\n      renderer\n    } = _ref40;\n    const useAlphaToCoverage = this.alphaToCoverage;\n    const useColor = this.useColor;\n    this.vertexNode = Fn(() => {\n      const instancePosition = attribute('instancePosition').xyz;\n\n      // camera space\n      const mvPos = vec4(modelViewMatrix.mul(vec4(instancePosition, 1.0)));\n      const aspect = viewport.z.div(viewport.w);\n\n      // clip space\n      const clipPos = cameraProjectionMatrix.mul(mvPos);\n\n      // offset in ndc space\n      const offset = positionGeometry.xy.toVar();\n      offset.mulAssign(this.pointWidthNode ? this.pointWidthNode : materialPointWidth);\n      offset.assign(offset.div(viewport.z));\n      offset.y.assign(offset.y.mul(aspect));\n\n      // back to clip space\n      offset.assign(offset.mul(clipPos.w));\n\n      //clipPos.xy += offset;\n      clipPos.addAssign(vec4(offset, 0, 0));\n      return clipPos;\n    })();\n    this.fragmentNode = Fn(() => {\n      const alpha = float(1).toVar();\n      const len2 = lengthSq(uv().mul(2).sub(1));\n      if (useAlphaToCoverage && renderer.samples > 1) {\n        const dlen = float(len2.fwidth()).toVar();\n        alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());\n      } else {\n        len2.greaterThan(1.0).discard();\n      }\n      let pointColorNode;\n      if (this.pointColorNode) {\n        pointColorNode = this.pointColorNode;\n      } else {\n        if (useColor) {\n          const instanceColor = attribute('instanceColor');\n          pointColorNode = instanceColor.mul(materialColor);\n        } else {\n          pointColorNode = materialColor;\n        }\n      }\n      alpha.mulAssign(materialOpacity);\n      return vec4(pointColorNode, alpha);\n    })();\n  }\n  get alphaToCoverage() {\n    return this.useAlphaToCoverage;\n  }\n  set alphaToCoverage(value) {\n    if (this.useAlphaToCoverage !== value) {\n      this.useAlphaToCoverage = value;\n      this.needsUpdate = true;\n    }\n  }\n}\nconst _defaultValues$d = /*@__PURE__*/new LineBasicMaterial();\nclass LineBasicNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'LineBasicNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isLineBasicNodeMaterial = true;\n    this.lights = false;\n    this.setDefaultValues(_defaultValues$d);\n    this.setValues(parameters);\n  }\n}\nconst _defaultValues$c = /*@__PURE__*/new LineDashedMaterial();\nclass LineDashedNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'LineDashedNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isLineDashedNodeMaterial = true;\n    this.lights = false;\n    this.setDefaultValues(_defaultValues$c);\n    this.dashOffset = 0;\n    this.offsetNode = null;\n    this.dashScaleNode = null;\n    this.dashSizeNode = null;\n    this.gapSizeNode = null;\n    this.setValues(parameters);\n  }\n  setupVariants() {\n    const offsetNode = this.offsetNode ? float(this.offsetNodeNode) : materialLineDashOffset;\n    const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;\n    const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;\n    const gapSizeNode = this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;\n    dashSize.assign(dashSizeNode);\n    gapSize.assign(gapSizeNode);\n    const vLineDistance = varying(attribute('lineDistance').mul(dashScaleNode));\n    const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;\n    vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard();\n  }\n}\nlet _sharedFramebuffer = null;\nclass ViewportSharedTextureNode extends ViewportTextureNode {\n  static get type() {\n    return 'ViewportSharedTextureNode';\n  }\n  constructor() {\n    let uvNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenUV;\n    let levelNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (_sharedFramebuffer === null) {\n      _sharedFramebuffer = new FramebufferTexture();\n    }\n    super(uvNode, levelNode, _sharedFramebuffer);\n  }\n  updateReference() {\n    return this;\n  }\n}\nconst viewportSharedTexture = /*@__PURE__*/nodeProxy(ViewportSharedTextureNode);\nconst _defaultValues$b = /*@__PURE__*/new LineDashedMaterial();\nclass Line2NodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'Line2NodeMaterial';\n  }\n  constructor() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.lights = false;\n    this.setDefaultValues(_defaultValues$b);\n    this.useAlphaToCoverage = true;\n    this.useColor = params.vertexColors;\n    this.useDash = params.dashed;\n    this.useWorldUnits = false;\n    this.dashOffset = 0;\n    this.lineWidth = 1;\n    this.lineColorNode = null;\n    this.offsetNode = null;\n    this.dashScaleNode = null;\n    this.dashSizeNode = null;\n    this.gapSizeNode = null;\n    this.blending = NoBlending;\n    this.setValues(params);\n  }\n  setup(builder) {\n    this.setupShaders(builder);\n    super.setup(builder);\n  }\n  setupShaders(_ref41) {\n    let {\n      renderer\n    } = _ref41;\n    const useAlphaToCoverage = this.alphaToCoverage;\n    const useColor = this.useColor;\n    const useDash = this.dashed;\n    const useWorldUnits = this.worldUnits;\n    const trimSegment = Fn(_ref42 => {\n      let {\n        start,\n        end\n      } = _ref42;\n      const a = cameraProjectionMatrix.element(2).element(2); // 3nd entry in 3th column\n      const b = cameraProjectionMatrix.element(3).element(2); // 3nd entry in 4th column\n      const nearEstimate = b.mul(-0.5).div(a);\n      const alpha = nearEstimate.sub(start.z).div(end.z.sub(start.z));\n      return vec4(mix(start.xyz, end.xyz, alpha), end.w);\n    }).setLayout({\n      name: 'trimSegment',\n      type: 'vec4',\n      inputs: [{\n        name: 'start',\n        type: 'vec4'\n      }, {\n        name: 'end',\n        type: 'vec4'\n      }]\n    });\n    this.vertexNode = Fn(() => {\n      const instanceStart = attribute('instanceStart');\n      const instanceEnd = attribute('instanceEnd');\n\n      // camera space\n\n      const start = vec4(modelViewMatrix.mul(vec4(instanceStart, 1.0))).toVar('start');\n      const end = vec4(modelViewMatrix.mul(vec4(instanceEnd, 1.0))).toVar('end');\n      if (useDash) {\n        const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;\n        const offsetNode = this.offsetNode ? float(this.offsetNodeNode) : materialLineDashOffset;\n        const instanceDistanceStart = attribute('instanceDistanceStart');\n        const instanceDistanceEnd = attribute('instanceDistanceEnd');\n        let lineDistance = positionGeometry.y.lessThan(0.5).select(dashScaleNode.mul(instanceDistanceStart), dashScaleNode.mul(instanceDistanceEnd));\n        lineDistance = lineDistance.add(offsetNode);\n        varyingProperty('float', 'lineDistance').assign(lineDistance);\n      }\n      if (useWorldUnits) {\n        varyingProperty('vec3', 'worldStart').assign(start.xyz);\n        varyingProperty('vec3', 'worldEnd').assign(end.xyz);\n      }\n      const aspect = viewport.z.div(viewport.w);\n\n      // special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n      // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n      // but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n      // perhaps there is a more elegant solution -- WestLangley\n\n      const perspective = cameraProjectionMatrix.element(2).element(3).equal(-1.0); // 4th entry in the 3rd column\n\n      If(perspective, () => {\n        If(start.z.lessThan(0.0).and(end.z.greaterThan(0.0)), () => {\n          end.assign(trimSegment({\n            start: start,\n            end: end\n          }));\n        }).ElseIf(end.z.lessThan(0.0).and(start.z.greaterThanEqual(0.0)), () => {\n          start.assign(trimSegment({\n            start: end,\n            end: start\n          }));\n        });\n      });\n\n      // clip space\n      const clipStart = cameraProjectionMatrix.mul(start);\n      const clipEnd = cameraProjectionMatrix.mul(end);\n\n      // ndc space\n      const ndcStart = clipStart.xyz.div(clipStart.w);\n      const ndcEnd = clipEnd.xyz.div(clipEnd.w);\n\n      // direction\n      const dir = ndcEnd.xy.sub(ndcStart.xy).toVar();\n\n      // account for clip-space aspect ratio\n      dir.x.assign(dir.x.mul(aspect));\n      dir.assign(dir.normalize());\n      const clip = vec4().toVar();\n      if (useWorldUnits) {\n        // get the offset direction as perpendicular to the view vector\n\n        const worldDir = end.xyz.sub(start.xyz).normalize();\n        const tmpFwd = mix(start.xyz, end.xyz, 0.5).normalize();\n        const worldUp = worldDir.cross(tmpFwd).normalize();\n        const worldFwd = worldDir.cross(worldUp);\n        const worldPos = varyingProperty('vec4', 'worldPos');\n        worldPos.assign(positionGeometry.y.lessThan(0.5).select(start, end));\n\n        // height offset\n        const hw = materialLineWidth.mul(0.5);\n        worldPos.addAssign(vec4(positionGeometry.x.lessThan(0.0).select(worldUp.mul(hw), worldUp.mul(hw).negate()), 0));\n\n        // don't extend the line if we're rendering dashes because we\n        // won't be rendering the endcaps\n        if (!useDash) {\n          // cap extension\n          worldPos.addAssign(vec4(positionGeometry.y.lessThan(0.5).select(worldDir.mul(hw).negate(), worldDir.mul(hw)), 0));\n\n          // add width to the box\n          worldPos.addAssign(vec4(worldFwd.mul(hw), 0));\n\n          // endcaps\n          If(positionGeometry.y.greaterThan(1.0).or(positionGeometry.y.lessThan(0.0)), () => {\n            worldPos.subAssign(vec4(worldFwd.mul(2.0).mul(hw), 0));\n          });\n        }\n\n        // project the worldpos\n        clip.assign(cameraProjectionMatrix.mul(worldPos));\n\n        // shift the depth of the projected points so the line\n        // segments overlap neatly\n        const clipPose = vec3().toVar();\n        clipPose.assign(positionGeometry.y.lessThan(0.5).select(ndcStart, ndcEnd));\n        clip.z.assign(clipPose.z.mul(clip.w));\n      } else {\n        const offset = vec2(dir.y, dir.x.negate()).toVar('offset');\n\n        // undo aspect ratio adjustment\n        dir.x.assign(dir.x.div(aspect));\n        offset.x.assign(offset.x.div(aspect));\n\n        // sign flip\n        offset.assign(positionGeometry.x.lessThan(0.0).select(offset.negate(), offset));\n\n        // endcaps\n        If(positionGeometry.y.lessThan(0.0), () => {\n          offset.assign(offset.sub(dir));\n        }).ElseIf(positionGeometry.y.greaterThan(1.0), () => {\n          offset.assign(offset.add(dir));\n        });\n\n        // adjust for linewidth\n        offset.assign(offset.mul(materialLineWidth));\n\n        // adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n        offset.assign(offset.div(viewport.w));\n\n        // select end\n        clip.assign(positionGeometry.y.lessThan(0.5).select(clipStart, clipEnd));\n\n        // back to clip space\n        offset.assign(offset.mul(clip.w));\n        clip.assign(clip.add(vec4(offset, 0, 0)));\n      }\n      return clip;\n    })();\n    const closestLineToLine = Fn(_ref43 => {\n      let {\n        p1,\n        p2,\n        p3,\n        p4\n      } = _ref43;\n      const p13 = p1.sub(p3);\n      const p43 = p4.sub(p3);\n      const p21 = p2.sub(p1);\n      const d1343 = p13.dot(p43);\n      const d4321 = p43.dot(p21);\n      const d1321 = p13.dot(p21);\n      const d4343 = p43.dot(p43);\n      const d2121 = p21.dot(p21);\n      const denom = d2121.mul(d4343).sub(d4321.mul(d4321));\n      const numer = d1343.mul(d4321).sub(d1321.mul(d4343));\n      const mua = numer.div(denom).clamp();\n      const mub = d1343.add(d4321.mul(mua)).div(d4343).clamp();\n      return vec2(mua, mub);\n    });\n    this.colorNode = Fn(() => {\n      const vUv = uv();\n      if (useDash) {\n        const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;\n        const gapSizeNode = this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;\n        dashSize.assign(dashSizeNode);\n        gapSize.assign(gapSizeNode);\n        const vLineDistance = varyingProperty('float', 'lineDistance');\n        vUv.y.lessThan(-1.0).or(vUv.y.greaterThan(1.0)).discard(); // discard endcaps\n        vLineDistance.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard(); // todo - FIX\n      }\n      const alpha = float(1).toVar('alpha');\n      if (useWorldUnits) {\n        const worldStart = varyingProperty('vec3', 'worldStart');\n        const worldEnd = varyingProperty('vec3', 'worldEnd');\n\n        // Find the closest points on the view ray and the line segment\n        const rayEnd = varyingProperty('vec4', 'worldPos').xyz.normalize().mul(1e5);\n        const lineDir = worldEnd.sub(worldStart);\n        const params = closestLineToLine({\n          p1: worldStart,\n          p2: worldEnd,\n          p3: vec3(0.0, 0.0, 0.0),\n          p4: rayEnd\n        });\n        const p1 = worldStart.add(lineDir.mul(params.x));\n        const p2 = rayEnd.mul(params.y);\n        const delta = p1.sub(p2);\n        const len = delta.length();\n        const norm = len.div(materialLineWidth);\n        if (!useDash) {\n          if (useAlphaToCoverage && renderer.samples > 1) {\n            const dnorm = norm.fwidth();\n            alpha.assign(smoothstep(dnorm.negate().add(0.5), dnorm.add(0.5), norm).oneMinus());\n          } else {\n            norm.greaterThan(0.5).discard();\n          }\n        }\n      } else {\n        // round endcaps\n\n        if (useAlphaToCoverage && renderer.samples > 1) {\n          const a = vUv.x;\n          const b = vUv.y.greaterThan(0.0).select(vUv.y.sub(1.0), vUv.y.add(1.0));\n          const len2 = a.mul(a).add(b.mul(b));\n          const dlen = float(len2.fwidth()).toVar('dlen');\n          If(vUv.y.abs().greaterThan(1.0), () => {\n            alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());\n          });\n        } else {\n          If(vUv.y.abs().greaterThan(1.0), () => {\n            const a = vUv.x;\n            const b = vUv.y.greaterThan(0.0).select(vUv.y.sub(1.0), vUv.y.add(1.0));\n            const len2 = a.mul(a).add(b.mul(b));\n            len2.greaterThan(1.0).discard();\n          });\n        }\n      }\n      let lineColorNode;\n      if (this.lineColorNode) {\n        lineColorNode = this.lineColorNode;\n      } else {\n        if (useColor) {\n          const instanceColorStart = attribute('instanceColorStart');\n          const instanceColorEnd = attribute('instanceColorEnd');\n          const instanceColor = positionGeometry.y.lessThan(0.5).select(instanceColorStart, instanceColorEnd);\n          lineColorNode = instanceColor.mul(materialColor);\n        } else {\n          lineColorNode = materialColor;\n        }\n      }\n      return vec4(lineColorNode, alpha);\n    })();\n    if (this.transparent) {\n      const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n      this.outputNode = vec4(this.colorNode.rgb.mul(opacityNode).add(viewportSharedTexture().rgb.mul(opacityNode.oneMinus())), this.colorNode.a);\n    }\n  }\n  get worldUnits() {\n    return this.useWorldUnits;\n  }\n  set worldUnits(value) {\n    if (this.useWorldUnits !== value) {\n      this.useWorldUnits = value;\n      this.needsUpdate = true;\n    }\n  }\n  get dashed() {\n    return this.useDash;\n  }\n  set dashed(value) {\n    if (this.useDash !== value) {\n      this.useDash = value;\n      this.needsUpdate = true;\n    }\n  }\n  get alphaToCoverage() {\n    return this.useAlphaToCoverage;\n  }\n  set alphaToCoverage(value) {\n    if (this.useAlphaToCoverage !== value) {\n      this.useAlphaToCoverage = value;\n      this.needsUpdate = true;\n    }\n  }\n}\nconst directionToColor = node => nodeObject(node).mul(0.5).add(0.5);\nconst colorToDirection = node => nodeObject(node).mul(2.0).sub(1);\nconst _defaultValues$a = /*@__PURE__*/new MeshNormalMaterial();\nclass MeshNormalNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshNormalNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.lights = false;\n    this.isMeshNormalNodeMaterial = true;\n    this.setDefaultValues(_defaultValues$a);\n    this.setValues(parameters);\n  }\n  setupDiffuseColor() {\n    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n    diffuseColor.assign(vec4(directionToColor(transformedNormalView), opacityNode));\n  }\n}\nclass EquirectUVNode extends TempNode {\n  static get type() {\n    return 'EquirectUVNode';\n  }\n  constructor() {\n    let dirNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : positionWorldDirection;\n    super('vec2');\n    this.dirNode = dirNode;\n  }\n  setup() {\n    const dir = this.dirNode;\n    const u = dir.z.atan2(dir.x).mul(1 / (Math.PI * 2)).add(0.5);\n    const v = dir.y.clamp(-1.0, 1.0).asin().mul(1 / Math.PI).add(0.5);\n    return vec2(u, v);\n  }\n}\nconst equirectUV = /*@__PURE__*/nodeProxy(EquirectUVNode);\n\n// @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget\n\nclass CubeRenderTarget extends WebGLCubeRenderTarget {\n  constructor() {\n    let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(size, options);\n    this.isCubeRenderTarget = true;\n  }\n  fromEquirectangularTexture(renderer, texture$1) {\n    const currentMinFilter = texture$1.minFilter;\n    const currentGenerateMipmaps = texture$1.generateMipmaps;\n    texture$1.generateMipmaps = true;\n    this.texture.type = texture$1.type;\n    this.texture.colorSpace = texture$1.colorSpace;\n    this.texture.generateMipmaps = texture$1.generateMipmaps;\n    this.texture.minFilter = texture$1.minFilter;\n    this.texture.magFilter = texture$1.magFilter;\n    const geometry = new BoxGeometry(5, 5, 5);\n    const uvNode = equirectUV(positionWorldDirection);\n    const material = new NodeMaterial();\n    material.colorNode = texture(texture$1, uvNode, 0);\n    material.side = BackSide;\n    material.blending = NoBlending;\n    const mesh = new Mesh(geometry, material);\n    const scene = new Scene();\n    scene.add(mesh);\n\n    // Avoid blurred poles\n    if (texture$1.minFilter === LinearMipmapLinearFilter) texture$1.minFilter = LinearFilter;\n    const camera = new CubeCamera(1, 10, this);\n    const currentMRT = renderer.getMRT();\n    renderer.setMRT(null);\n    camera.update(renderer, scene);\n    renderer.setMRT(currentMRT);\n    texture$1.minFilter = currentMinFilter;\n    texture$1.currentGenerateMipmaps = currentGenerateMipmaps;\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    return this;\n  }\n}\nconst _cache$1 = new WeakMap();\nclass CubeMapNode extends TempNode {\n  static get type() {\n    return 'CubeMapNode';\n  }\n  constructor(envNode) {\n    super('vec3');\n    this.envNode = envNode;\n    this._cubeTexture = null;\n    this._cubeTextureNode = cubeTexture();\n    const defaultTexture = new CubeTexture();\n    defaultTexture.isRenderTargetTexture = true;\n    this._defaultTexture = defaultTexture;\n    this.updateBeforeType = NodeUpdateType.RENDER;\n  }\n  updateBefore(frame) {\n    const {\n      renderer,\n      material\n    } = frame;\n    const envNode = this.envNode;\n    if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {\n      const texture = envNode.isTextureNode ? envNode.value : material[envNode.property];\n      if (texture && texture.isTexture) {\n        const mapping = texture.mapping;\n        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {\n          // check for converted cubemap map\n\n          if (_cache$1.has(texture)) {\n            const cubeMap = _cache$1.get(texture);\n            mapTextureMapping(cubeMap, texture.mapping);\n            this._cubeTexture = cubeMap;\n          } else {\n            // create cube map from equirectangular map\n\n            const image = texture.image;\n            if (isEquirectangularMapReady$1(image)) {\n              const renderTarget = new CubeRenderTarget(image.height);\n              renderTarget.fromEquirectangularTexture(renderer, texture);\n              mapTextureMapping(renderTarget.texture, texture.mapping);\n              this._cubeTexture = renderTarget.texture;\n              _cache$1.set(texture, renderTarget.texture);\n              texture.addEventListener('dispose', onTextureDispose);\n            } else {\n              // default cube texture as fallback when equirectangular texture is not yet loaded\n\n              this._cubeTexture = this._defaultTexture;\n            }\n          }\n\n          //\n\n          this._cubeTextureNode.value = this._cubeTexture;\n        } else {\n          // envNode already refers to a cube map\n\n          this._cubeTextureNode = this.envNode;\n        }\n      }\n    }\n  }\n  setup(builder) {\n    this.updateBefore(builder);\n    return this._cubeTextureNode;\n  }\n}\nfunction isEquirectangularMapReady$1(image) {\n  if (image === null || image === undefined) return false;\n  return image.height > 0;\n}\nfunction onTextureDispose(event) {\n  const texture = event.target;\n  texture.removeEventListener('dispose', onTextureDispose);\n  const renderTarget = _cache$1.get(texture);\n  if (renderTarget !== undefined) {\n    _cache$1.delete(texture);\n    renderTarget.dispose();\n  }\n}\nfunction mapTextureMapping(texture, mapping) {\n  if (mapping === EquirectangularReflectionMapping) {\n    texture.mapping = CubeReflectionMapping;\n  } else if (mapping === EquirectangularRefractionMapping) {\n    texture.mapping = CubeRefractionMapping;\n  }\n}\nconst cubeMapNode = /*@__PURE__*/nodeProxy(CubeMapNode);\nclass BasicEnvironmentNode extends LightingNode {\n  static get type() {\n    return 'BasicEnvironmentNode';\n  }\n  constructor() {\n    let envNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this.envNode = envNode;\n  }\n  setup(builder) {\n    // environment property is used in the finish() method of BasicLightingModel\n\n    builder.context.environment = cubeMapNode(this.envNode);\n  }\n}\nclass BasicLightMapNode extends LightingNode {\n  static get type() {\n    return 'BasicLightMapNode';\n  }\n  constructor() {\n    let lightMapNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this.lightMapNode = lightMapNode;\n  }\n  setup(builder) {\n    // irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel\n\n    const RECIPROCAL_PI = float(1 / Math.PI);\n    builder.context.irradianceLightMap = this.lightMapNode.mul(RECIPROCAL_PI);\n  }\n}\nclass LightingModel {\n  start(/*input, stack, builder*/) {}\n  finish(/*input, stack, builder*/) {}\n  direct(/*input, stack, builder*/) {}\n  directRectArea(/*input, stack, builder*/) {}\n  indirect(/*input, stack, builder*/) {}\n  ambientOcclusion(/*input, stack, builder*/) {}\n}\nclass BasicLightingModel extends LightingModel {\n  constructor() {\n    super();\n  }\n  indirect(context, stack, builder) {\n    const ambientOcclusion = context.ambientOcclusion;\n    const reflectedLight = context.reflectedLight;\n    const irradianceLightMap = builder.context.irradianceLightMap;\n    reflectedLight.indirectDiffuse.assign(vec4(0.0));\n\n    // accumulation (baked indirect lighting only)\n\n    if (irradianceLightMap) {\n      reflectedLight.indirectDiffuse.addAssign(irradianceLightMap);\n    } else {\n      reflectedLight.indirectDiffuse.addAssign(vec4(1.0, 1.0, 1.0, 0.0));\n    }\n\n    // modulation\n\n    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n    reflectedLight.indirectDiffuse.mulAssign(diffuseColor.rgb);\n  }\n  finish(context, stack, builder) {\n    const material = builder.material;\n    const outgoingLight = context.outgoingLight;\n    const envNode = builder.context.environment;\n    if (envNode) {\n      switch (material.combine) {\n        case MultiplyOperation:\n          outgoingLight.rgb.assign(mix(outgoingLight.rgb, outgoingLight.rgb.mul(envNode.rgb), materialSpecularStrength.mul(materialReflectivity)));\n          break;\n        case MixOperation:\n          outgoingLight.rgb.assign(mix(outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul(materialReflectivity)));\n          break;\n        case AddOperation:\n          outgoingLight.rgb.addAssign(envNode.rgb.mul(materialSpecularStrength.mul(materialReflectivity)));\n          break;\n        default:\n          console.warn('THREE.BasicLightingModel: Unsupported .combine value:', material.combine);\n          break;\n      }\n    }\n  }\n}\nconst _defaultValues$9 = /*@__PURE__*/new MeshBasicMaterial();\nclass MeshBasicNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshBasicNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshBasicNodeMaterial = true;\n    this.lights = true;\n    this.setDefaultValues(_defaultValues$9);\n    this.setValues(parameters);\n  }\n  setupNormal() {\n    return normalView; // see #28839\n  }\n  setupEnvironment(builder) {\n    const envNode = super.setupEnvironment(builder);\n    return envNode ? new BasicEnvironmentNode(envNode) : null;\n  }\n  setupLightMap(builder) {\n    let node = null;\n    if (builder.material.lightMap) {\n      node = new BasicLightMapNode(materialLightMap);\n    }\n    return node;\n  }\n  setupOutgoingLight() {\n    return diffuseColor.rgb;\n  }\n  setupLightingModel() {\n    return new BasicLightingModel();\n  }\n}\nconst F_Schlick = /*@__PURE__*/Fn(_ref44 => {\n  let {\n    f0,\n    f90,\n    dotVH\n  } = _ref44;\n  // Original approximation by Christophe Schlick '94\n  // float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n  // Optimized variant (presented by Epic at SIGGRAPH '13)\n  // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n  const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();\n  return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));\n}); // validated\n\nconst BRDF_Lambert = /*@__PURE__*/Fn(inputs => {\n  return inputs.diffuseColor.mul(1 / Math.PI); // punctual light\n}); // validated\n\nconst G_BlinnPhong_Implicit = () => float(0.25);\nconst D_BlinnPhong = /*@__PURE__*/Fn(_ref45 => {\n  let {\n    dotNH\n  } = _ref45;\n  return shininess.mul(float(0.5)).add(1.0).mul(float(1 / Math.PI)).mul(dotNH.pow(shininess));\n});\nconst BRDF_BlinnPhong = /*@__PURE__*/Fn(_ref46 => {\n  let {\n    lightDirection\n  } = _ref46;\n  const halfDir = lightDirection.add(positionViewDirection).normalize();\n  const dotNH = transformedNormalView.dot(halfDir).clamp();\n  const dotVH = positionViewDirection.dot(halfDir).clamp();\n  const F = F_Schlick({\n    f0: specularColor,\n    f90: 1.0,\n    dotVH\n  });\n  const G = G_BlinnPhong_Implicit();\n  const D = D_BlinnPhong({\n    dotNH\n  });\n  return F.mul(G).mul(D);\n});\nclass PhongLightingModel extends BasicLightingModel {\n  constructor() {\n    let specular = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    super();\n    this.specular = specular;\n  }\n  direct(_ref47) {\n    let {\n      lightDirection,\n      lightColor,\n      reflectedLight\n    } = _ref47;\n    const dotNL = transformedNormalView.dot(lightDirection).clamp();\n    const irradiance = dotNL.mul(lightColor);\n    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor: diffuseColor.rgb\n    })));\n    if (this.specular === true) {\n      reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong({\n        lightDirection\n      })).mul(materialSpecularStrength));\n    }\n  }\n  indirect(_ref48) {\n    let {\n      ambientOcclusion,\n      irradiance,\n      reflectedLight\n    } = _ref48;\n    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor\n    })));\n    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n  }\n}\nconst _defaultValues$8 = /*@__PURE__*/new MeshLambertMaterial();\nclass MeshLambertNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshLambertNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshLambertNodeMaterial = true;\n    this.lights = true;\n    this.setDefaultValues(_defaultValues$8);\n    this.setValues(parameters);\n  }\n  setupEnvironment(builder) {\n    const envNode = super.setupEnvironment(builder);\n    return envNode ? new BasicEnvironmentNode(envNode) : null;\n  }\n  setupLightingModel(/*builder*/\n  ) {\n    return new PhongLightingModel(false); // ( specular ) -> force lambert\n  }\n}\nconst _defaultValues$7 = /*@__PURE__*/new MeshPhongMaterial();\nclass MeshPhongNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshPhongNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshPhongNodeMaterial = true;\n    this.lights = true;\n    this.shininessNode = null;\n    this.specularNode = null;\n    this.setDefaultValues(_defaultValues$7);\n    this.setValues(parameters);\n  }\n  setupEnvironment(builder) {\n    const envNode = super.setupEnvironment(builder);\n    return envNode ? new BasicEnvironmentNode(envNode) : null;\n  }\n  setupLightingModel(/*builder*/\n  ) {\n    return new PhongLightingModel();\n  }\n  setupVariants() {\n    // SHININESS\n\n    const shininessNode = (this.shininessNode ? float(this.shininessNode) : materialShininess).max(1e-4); // to prevent pow( 0.0, 0.0 )\n\n    shininess.assign(shininessNode);\n\n    // SPECULAR COLOR\n\n    const specularNode = this.specularNode || materialSpecular;\n    specularColor.assign(specularNode);\n  }\n  copy(source) {\n    this.shininessNode = source.shininessNode;\n    this.specularNode = source.specularNode;\n    return super.copy(source);\n  }\n}\nconst getGeometryRoughness = /*@__PURE__*/Fn(builder => {\n  if (builder.geometry.hasAttribute('normal') === false) {\n    return float(0);\n  }\n  const dxy = normalView.dFdx().abs().max(normalView.dFdy().abs());\n  const geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);\n  return geometryRoughness;\n});\nconst getRoughness = /*@__PURE__*/Fn(inputs => {\n  const {\n    roughness\n  } = inputs;\n  const geometryRoughness = getGeometryRoughness();\n  let roughnessFactor = roughness.max(0.0525); // 0.0525 corresponds to the base mip of a 256 cubemap.\n  roughnessFactor = roughnessFactor.add(geometryRoughness);\n  roughnessFactor = roughnessFactor.min(1.0);\n  return roughnessFactor;\n});\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nconst V_GGX_SmithCorrelated = /*@__PURE__*/Fn(_ref49 => {\n  let {\n    alpha,\n    dotNL,\n    dotNV\n  } = _ref49;\n  const a2 = alpha.pow2();\n  const gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());\n  const gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());\n  return div(0.5, gv.add(gl).max(EPSILON));\n}).setLayout({\n  name: 'V_GGX_SmithCorrelated',\n  type: 'float',\n  inputs: [{\n    name: 'alpha',\n    type: 'float'\n  }, {\n    name: 'dotNL',\n    type: 'float'\n  }, {\n    name: 'dotNV',\n    type: 'float'\n  }]\n}); // validated\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/Fn(_ref50 => {\n  let {\n    alphaT,\n    alphaB,\n    dotTV,\n    dotBV,\n    dotTL,\n    dotBL,\n    dotNV,\n    dotNL\n  } = _ref50;\n  const gv = dotNL.mul(vec3(alphaT.mul(dotTV), alphaB.mul(dotBV), dotNV).length());\n  const gl = dotNV.mul(vec3(alphaT.mul(dotTL), alphaB.mul(dotBL), dotNL).length());\n  const v = div(0.5, gv.add(gl));\n  return v.saturate();\n}).setLayout({\n  name: 'V_GGX_SmithCorrelated_Anisotropic',\n  type: 'float',\n  inputs: [{\n    name: 'alphaT',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'alphaB',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotTV',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotBV',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotTL',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotBL',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotNV',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotNL',\n    type: 'float',\n    qualifier: 'in'\n  }]\n});\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneys reparameterization\nconst D_GGX = /*@__PURE__*/Fn(_ref51 => {\n  let {\n    alpha,\n    dotNH\n  } = _ref51;\n  const a2 = alpha.pow2();\n  const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus(); // avoid alpha = 0 with dotNH = 1\n\n  return a2.div(denom.pow2()).mul(1 / Math.PI);\n}).setLayout({\n  name: 'D_GGX',\n  type: 'float',\n  inputs: [{\n    name: 'alpha',\n    type: 'float'\n  }, {\n    name: 'dotNH',\n    type: 'float'\n  }]\n}); // validated\n\nconst RECIPROCAL_PI = /*@__PURE__*/float(1 / Math.PI);\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst D_GGX_Anisotropic = /*@__PURE__*/Fn(_ref52 => {\n  let {\n    alphaT,\n    alphaB,\n    dotNH,\n    dotTH,\n    dotBH\n  } = _ref52;\n  const a2 = alphaT.mul(alphaB);\n  const v = vec3(alphaB.mul(dotTH), alphaT.mul(dotBH), a2.mul(dotNH));\n  const v2 = v.dot(v);\n  const w2 = a2.div(v2);\n  return RECIPROCAL_PI.mul(a2.mul(w2.pow2()));\n}).setLayout({\n  name: 'D_GGX_Anisotropic',\n  type: 'float',\n  inputs: [{\n    name: 'alphaT',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'alphaB',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotNH',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotTH',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotBH',\n    type: 'float',\n    qualifier: 'in'\n  }]\n});\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nconst BRDF_GGX = /*@__PURE__*/Fn(inputs => {\n  const {\n    lightDirection,\n    f0,\n    f90,\n    roughness,\n    f,\n    USE_IRIDESCENCE,\n    USE_ANISOTROPY\n  } = inputs;\n  const normalView = inputs.normalView || transformedNormalView;\n  const alpha = roughness.pow2(); // UE4's roughness\n\n  const halfDir = lightDirection.add(positionViewDirection).normalize();\n  const dotNL = normalView.dot(lightDirection).clamp();\n  const dotNV = normalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV\n  const dotNH = normalView.dot(halfDir).clamp();\n  const dotVH = positionViewDirection.dot(halfDir).clamp();\n  let F = F_Schlick({\n    f0,\n    f90,\n    dotVH\n  });\n  let V, D;\n  if (defined(USE_IRIDESCENCE)) {\n    F = iridescence.mix(F, f);\n  }\n  if (defined(USE_ANISOTROPY)) {\n    const dotTL = anisotropyT.dot(lightDirection);\n    const dotTV = anisotropyT.dot(positionViewDirection);\n    const dotTH = anisotropyT.dot(halfDir);\n    const dotBL = anisotropyB.dot(lightDirection);\n    const dotBV = anisotropyB.dot(positionViewDirection);\n    const dotBH = anisotropyB.dot(halfDir);\n    V = V_GGX_SmithCorrelated_Anisotropic({\n      alphaT,\n      alphaB: alpha,\n      dotTV,\n      dotBV,\n      dotTL,\n      dotBL,\n      dotNV,\n      dotNL\n    });\n    D = D_GGX_Anisotropic({\n      alphaT,\n      alphaB: alpha,\n      dotNH,\n      dotTH,\n      dotBH\n    });\n  } else {\n    V = V_GGX_SmithCorrelated({\n      alpha,\n      dotNL,\n      dotNV\n    });\n    D = D_GGX({\n      alpha,\n      dotNH\n    });\n  }\n  return F.mul(V).mul(D);\n}); // validated\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from \"Physically Based Shading on Mobile\"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nconst DFGApprox = /*@__PURE__*/Fn(_ref53 => {\n  let {\n    roughness,\n    dotNV\n  } = _ref53;\n  const c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const c1 = vec4(1, 0.0425, 1.04, -0.04);\n  const r = roughness.mul(c0).add(c1);\n  const a004 = r.x.mul(r.x).min(dotNV.mul(-9.28).exp2()).mul(r.x).add(r.y);\n  const fab = vec2(-1.04, 1.04).mul(a004).add(r.zw);\n  return fab;\n}).setLayout({\n  name: 'DFGApprox',\n  type: 'vec2',\n  inputs: [{\n    name: 'roughness',\n    type: 'float'\n  }, {\n    name: 'dotNV',\n    type: 'vec3'\n  }]\n});\nconst EnvironmentBRDF = /*@__PURE__*/Fn(inputs => {\n  const {\n    dotNV,\n    specularColor,\n    specularF90,\n    roughness\n  } = inputs;\n  const fab = DFGApprox({\n    dotNV,\n    roughness\n  });\n  return specularColor.mul(fab.x).add(specularF90.mul(fab.y));\n});\nconst Schlick_to_F0 = /*@__PURE__*/Fn(_ref54 => {\n  let {\n    f,\n    f90,\n    dotVH\n  } = _ref54;\n  const x = dotVH.oneMinus().saturate();\n  const x2 = x.mul(x);\n  const x5 = x.mul(x2, x2).clamp(0, .9999);\n  return f.sub(vec3(f90).mul(x5)).div(x5.oneMinus());\n}).setLayout({\n  name: 'Schlick_to_F0',\n  type: 'vec3',\n  inputs: [{\n    name: 'f',\n    type: 'vec3'\n  }, {\n    name: 'f90',\n    type: 'float'\n  }, {\n    name: 'dotVH',\n    type: 'float'\n  }]\n});\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst D_Charlie = /*@__PURE__*/Fn(_ref55 => {\n  let {\n    roughness,\n    dotNH\n  } = _ref55;\n  const alpha = roughness.pow2();\n\n  // Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n  const invAlpha = float(1.0).div(alpha);\n  const cos2h = dotNH.pow2();\n  const sin2h = cos2h.oneMinus().max(0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\n  return float(2.0).add(invAlpha).mul(sin2h.pow(invAlpha.mul(0.5))).div(2.0 * Math.PI);\n}).setLayout({\n  name: 'D_Charlie',\n  type: 'float',\n  inputs: [{\n    name: 'roughness',\n    type: 'float'\n  }, {\n    name: 'dotNH',\n    type: 'float'\n  }]\n});\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst V_Neubelt = /*@__PURE__*/Fn(_ref56 => {\n  let {\n    dotNV,\n    dotNL\n  } = _ref56;\n  // Neubelt and Pettineo 2013, \"Crafting a Next-gen Material Pipeline for The Order: 1886\"\n  return float(1.0).div(float(4.0).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));\n}).setLayout({\n  name: 'V_Neubelt',\n  type: 'float',\n  inputs: [{\n    name: 'dotNV',\n    type: 'float'\n  }, {\n    name: 'dotNL',\n    type: 'float'\n  }]\n});\nconst BRDF_Sheen = /*@__PURE__*/Fn(_ref57 => {\n  let {\n    lightDirection\n  } = _ref57;\n  const halfDir = lightDirection.add(positionViewDirection).normalize();\n  const dotNL = transformedNormalView.dot(lightDirection).clamp();\n  const dotNV = transformedNormalView.dot(positionViewDirection).clamp();\n  const dotNH = transformedNormalView.dot(halfDir).clamp();\n  const D = D_Charlie({\n    roughness: sheenRoughness,\n    dotNH\n  });\n  const V = V_Neubelt({\n    dotNV,\n    dotNL\n  });\n  return sheen.mul(D).mul(V);\n});\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nconst LTC_Uv = /*@__PURE__*/Fn(_ref58 => {\n  let {\n    N,\n    V,\n    roughness\n  } = _ref58;\n  const LUT_SIZE = 64.0;\n  const LUT_SCALE = (LUT_SIZE - 1.0) / LUT_SIZE;\n  const LUT_BIAS = 0.5 / LUT_SIZE;\n  const dotNV = N.dot(V).saturate();\n\n  // texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n  const uv = vec2(roughness, dotNV.oneMinus().sqrt());\n  uv.assign(uv.mul(LUT_SCALE).add(LUT_BIAS));\n  return uv;\n}).setLayout({\n  name: 'LTC_Uv',\n  type: 'vec2',\n  inputs: [{\n    name: 'N',\n    type: 'vec3'\n  }, {\n    name: 'V',\n    type: 'vec3'\n  }, {\n    name: 'roughness',\n    type: 'float'\n  }]\n});\nconst LTC_ClippedSphereFormFactor = /*@__PURE__*/Fn(_ref59 => {\n  let {\n    f\n  } = _ref59;\n  // Real-Time Area Lighting: a Journey from Research to Production (p.102)\n  // An approximation of the form factor of a horizon-clipped rectangle.\n\n  const l = f.length();\n  return max$1(l.mul(l).add(f.z).div(l.add(1.0)), 0);\n}).setLayout({\n  name: 'LTC_ClippedSphereFormFactor',\n  type: 'float',\n  inputs: [{\n    name: 'f',\n    type: 'vec3'\n  }]\n});\nconst LTC_EdgeVectorFormFactor = /*@__PURE__*/Fn(_ref60 => {\n  let {\n    v1,\n    v2\n  } = _ref60;\n  const x = v1.dot(v2);\n  const y = x.abs().toVar();\n\n  // rational polynomial approximation to theta / sin( theta ) / 2PI\n  const a = y.mul(0.0145206).add(0.4965155).mul(y).add(0.8543985).toVar();\n  const b = y.add(4.1616724).mul(y).add(3.4175940).toVar();\n  const v = a.div(b);\n  const theta_sintheta = x.greaterThan(0.0).select(v, max$1(x.mul(x).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(v));\n  return v1.cross(v2).mul(theta_sintheta);\n}).setLayout({\n  name: 'LTC_EdgeVectorFormFactor',\n  type: 'vec3',\n  inputs: [{\n    name: 'v1',\n    type: 'vec3'\n  }, {\n    name: 'v2',\n    type: 'vec3'\n  }]\n});\nconst LTC_Evaluate = /*@__PURE__*/Fn(_ref61 => {\n  let {\n    N,\n    V,\n    P,\n    mInv,\n    p0,\n    p1,\n    p2,\n    p3\n  } = _ref61;\n  // bail if point is on back side of plane of light\n  // assumes ccw winding order of light vertices\n  const v1 = p1.sub(p0).toVar();\n  const v2 = p3.sub(p0).toVar();\n  const lightNormal = v1.cross(v2);\n  const result = vec3().toVar();\n  If(lightNormal.dot(P.sub(p0)).greaterThanEqual(0.0), () => {\n    // construct orthonormal basis around N\n    const T1 = V.sub(N.mul(V.dot(N))).normalize();\n    const T2 = N.cross(T1).negate(); // negated from paper; possibly due to a different handedness of world coordinate system\n\n    // compute transform\n    const mat = mInv.mul(mat3(T1, T2, N).transpose()).toVar();\n\n    // transform rect\n    // & project rect onto sphere\n    const coords0 = mat.mul(p0.sub(P)).normalize().toVar();\n    const coords1 = mat.mul(p1.sub(P)).normalize().toVar();\n    const coords2 = mat.mul(p2.sub(P)).normalize().toVar();\n    const coords3 = mat.mul(p3.sub(P)).normalize().toVar();\n\n    // calculate vector form factor\n    const vectorFormFactor = vec3(0).toVar();\n    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({\n      v1: coords0,\n      v2: coords1\n    }));\n    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({\n      v1: coords1,\n      v2: coords2\n    }));\n    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({\n      v1: coords2,\n      v2: coords3\n    }));\n    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({\n      v1: coords3,\n      v2: coords0\n    }));\n\n    // adjust for horizon clipping\n    result.assign(vec3(LTC_ClippedSphereFormFactor({\n      f: vectorFormFactor\n    })));\n  });\n  return result;\n}).setLayout({\n  name: 'LTC_Evaluate',\n  type: 'vec3',\n  inputs: [{\n    name: 'N',\n    type: 'vec3'\n  }, {\n    name: 'V',\n    type: 'vec3'\n  }, {\n    name: 'P',\n    type: 'vec3'\n  }, {\n    name: 'mInv',\n    type: 'mat3'\n  }, {\n    name: 'p0',\n    type: 'vec3'\n  }, {\n    name: 'p1',\n    type: 'vec3'\n  }, {\n    name: 'p2',\n    type: 'vec3'\n  }, {\n    name: 'p3',\n    type: 'vec3'\n  }]\n});\n\n// Mipped Bicubic Texture Filtering by N8\n// https://www.shadertoy.com/view/Dl2SDW\n\nconst bC = 1.0 / 6.0;\nconst w0 = a => mul(bC, mul(a, mul(a, a.negate().add(3.0)).sub(3.0)).add(1.0));\nconst w1 = a => mul(bC, mul(a, mul(a, mul(3.0, a).sub(6.0))).add(4.0));\nconst w2 = a => mul(bC, mul(a, mul(a, mul(-3.0, a).add(3.0)).add(3.0)).add(1.0));\nconst w3 = a => mul(bC, pow(a, 3));\nconst g0 = a => w0(a).add(w1(a));\nconst g1 = a => w2(a).add(w3(a));\n\n// h0 and h1 are the two offset functions\nconst h0 = a => add(-1.0, w1(a).div(w0(a).add(w1(a))));\nconst h1 = a => add(1.0, w3(a).div(w2(a).add(w3(a))));\nconst bicubic = (textureNode, texelSize, lod) => {\n  const uv = textureNode.uvNode;\n  const uvScaled = mul(uv, texelSize.zw).add(0.5);\n  const iuv = floor(uvScaled);\n  const fuv = fract(uvScaled);\n  const g0x = g0(fuv.x);\n  const g1x = g1(fuv.x);\n  const h0x = h0(fuv.x);\n  const h1x = h1(fuv.x);\n  const h0y = h0(fuv.y);\n  const h1y = h1(fuv.y);\n  const p0 = vec2(iuv.x.add(h0x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);\n  const p1 = vec2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);\n  const p2 = vec2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);\n  const p3 = vec2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);\n  const a = g0(fuv.y).mul(add(g0x.mul(textureNode.uv(p0).level(lod)), g1x.mul(textureNode.uv(p1).level(lod))));\n  const b = g1(fuv.y).mul(add(g0x.mul(textureNode.uv(p2).level(lod)), g1x.mul(textureNode.uv(p3).level(lod))));\n  return a.add(b);\n};\nconst textureBicubic = /*@__PURE__*/Fn(_ref62 => {\n  let [textureNode, lodNode = float(3)] = _ref62;\n  const fLodSize = vec2(textureNode.size(int(lodNode)));\n  const cLodSize = vec2(textureNode.size(int(lodNode.add(1.0))));\n  const fLodSizeInv = div(1.0, fLodSize);\n  const cLodSizeInv = div(1.0, cLodSize);\n  const fSample = bicubic(textureNode, vec4(fLodSizeInv, fLodSize), floor(lodNode));\n  const cSample = bicubic(textureNode, vec4(cLodSizeInv, cLodSize), ceil(lodNode));\n  return fract(lodNode).mix(fSample, cSample);\n});\n\n//\n// Transmission\n//\n\nconst getVolumeTransmissionRay = /*@__PURE__*/Fn(_ref63 => {\n  let [n, v, thickness, ior, modelMatrix] = _ref63;\n  // Direction of refracted light.\n  const refractionVector = vec3(refract(v.negate(), normalize(n), div(1.0, ior)));\n\n  // Compute rotation-independant scaling of the model matrix.\n  const modelScale = vec3(length(modelMatrix[0].xyz), length(modelMatrix[1].xyz), length(modelMatrix[2].xyz));\n\n  // The thickness is specified in local space.\n  return normalize(refractionVector).mul(thickness.mul(modelScale));\n}).setLayout({\n  name: 'getVolumeTransmissionRay',\n  type: 'vec3',\n  inputs: [{\n    name: 'n',\n    type: 'vec3'\n  }, {\n    name: 'v',\n    type: 'vec3'\n  }, {\n    name: 'thickness',\n    type: 'float'\n  }, {\n    name: 'ior',\n    type: 'float'\n  }, {\n    name: 'modelMatrix',\n    type: 'mat4'\n  }]\n});\nconst applyIorToRoughness = /*@__PURE__*/Fn(_ref64 => {\n  let [roughness, ior] = _ref64;\n  // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n  // an IOR of 1.5 results in the default amount of microfacet refraction.\n  return roughness.mul(clamp(ior.mul(2.0).sub(2.0), 0.0, 1.0));\n}).setLayout({\n  name: 'applyIorToRoughness',\n  type: 'float',\n  inputs: [{\n    name: 'roughness',\n    type: 'float'\n  }, {\n    name: 'ior',\n    type: 'float'\n  }]\n});\nconst viewportBackSideTexture = /*@__PURE__*/viewportMipTexture();\nconst viewportFrontSideTexture = /*@__PURE__*/viewportMipTexture();\nconst getTransmissionSample = /*@__PURE__*/Fn((_ref65, _ref66) => {\n  let [fragCoord, roughness, ior] = _ref65;\n  let {\n    material\n  } = _ref66;\n  const vTexture = material.side == BackSide ? viewportBackSideTexture : viewportFrontSideTexture;\n  const transmissionSample = vTexture.uv(fragCoord);\n  //const transmissionSample = viewportMipTexture( fragCoord );\n\n  const lod = log2(screenSize.x).mul(applyIorToRoughness(roughness, ior));\n  return textureBicubic(transmissionSample, lod);\n});\nconst volumeAttenuation = /*@__PURE__*/Fn(_ref67 => {\n  let [transmissionDistance, attenuationColor, attenuationDistance] = _ref67;\n  If(attenuationDistance.notEqual(0), () => {\n    // Compute light attenuation using Beer's law.\n    const attenuationCoefficient = log(attenuationColor).negate().div(attenuationDistance);\n    const transmittance = exp(attenuationCoefficient.negate().mul(transmissionDistance));\n    return transmittance;\n  });\n\n  // Attenuation distance is +, i.e. the transmitted color is not attenuated at all.\n  return vec3(1.0);\n}).setLayout({\n  name: 'volumeAttenuation',\n  type: 'vec3',\n  inputs: [{\n    name: 'transmissionDistance',\n    type: 'float'\n  }, {\n    name: 'attenuationColor',\n    type: 'vec3'\n  }, {\n    name: 'attenuationDistance',\n    type: 'float'\n  }]\n});\nconst getIBLVolumeRefraction = /*@__PURE__*/Fn(_ref68 => {\n  let [n, v, roughness, diffuseColor, specularColor, specularF90, position, modelMatrix, viewMatrix, projMatrix, ior, thickness, attenuationColor, attenuationDistance, dispersion] = _ref68;\n  let transmittedLight, transmittance;\n  if (dispersion) {\n    transmittedLight = vec4().toVar();\n    transmittance = vec3().toVar();\n    const halfSpread = ior.sub(1.0).mul(dispersion.mul(0.025));\n    const iors = vec3(ior.sub(halfSpread), ior, ior.add(halfSpread));\n    Loop({\n      start: 0,\n      end: 3\n    }, _ref69 => {\n      let {\n        i\n      } = _ref69;\n      const ior = iors.element(i);\n      const transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n      const refractedRayExit = position.add(transmissionRay);\n\n      // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n      const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1.0)));\n      const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();\n      refractionCoords.addAssign(1.0);\n      refractionCoords.divAssign(2.0);\n      refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus())); // webgpu\n\n      // Sample framebuffer to get pixel the refracted ray hits.\n      const transmissionSample = getTransmissionSample(refractionCoords, roughness, ior);\n      transmittedLight.element(i).assign(transmissionSample.element(i));\n      transmittedLight.a.addAssign(transmissionSample.a);\n      transmittance.element(i).assign(diffuseColor.element(i).mul(volumeAttenuation(length(transmissionRay), attenuationColor, attenuationDistance).element(i)));\n    });\n    transmittedLight.a.divAssign(3.0);\n  } else {\n    const transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n    const refractedRayExit = position.add(transmissionRay);\n\n    // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n    const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1.0)));\n    const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();\n    refractionCoords.addAssign(1.0);\n    refractionCoords.divAssign(2.0);\n    refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus())); // webgpu\n\n    // Sample framebuffer to get pixel the refracted ray hits.\n    transmittedLight = getTransmissionSample(refractionCoords, roughness, ior);\n    transmittance = diffuseColor.mul(volumeAttenuation(length(transmissionRay), attenuationColor, attenuationDistance));\n  }\n  const attenuatedColor = transmittance.rgb.mul(transmittedLight.rgb);\n  const dotNV = n.dot(v).clamp();\n\n  // Get the specular component.\n  const F = vec3(EnvironmentBRDF({\n    // n, v, specularColor, specularF90, roughness\n    dotNV,\n    specularColor,\n    specularF90,\n    roughness\n  }));\n\n  // As less light is transmitted, the opacity should be increased. This simple approximation does a decent job\n  // of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.\n  const transmittanceFactor = transmittance.r.add(transmittance.g, transmittance.b).div(3.0);\n  return vec4(F.oneMinus().mul(attenuatedColor), transmittedLight.a.oneMinus().mul(transmittanceFactor).oneMinus());\n});\n\n//\n// Iridescence\n//\n\n// XYZ to linear-sRGB color space\nconst XYZ_TO_REC709 = /*@__PURE__*/mat3(3.2404542, -0.9692660, 0.0556434, -1.5371385, 1.8760108, -0.2040259, -0.4985314, 0.0415560, 1.0572252);\n\n// Assume air interface for top\n// Note: We don't handle the case fresnel0 == 1\nconst Fresnel0ToIor = fresnel0 => {\n  const sqrtF0 = fresnel0.sqrt();\n  return vec3(1.0).add(sqrtF0).div(vec3(1.0).sub(sqrtF0));\n};\n\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nconst IorToFresnel0 = (transmittedIor, incidentIor) => {\n  return transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();\n};\n\n// Fresnel equations for dielectric/dielectric interfaces.\n// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n// Evaluation XYZ sensitivity curves in Fourier space\nconst evalSensitivity = (OPD, shift) => {\n  const phase = OPD.mul(2.0 * Math.PI * 1.0e-9);\n  const val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n  const pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n  const VAR = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n  const x = float(9.7470e-14 * Math.sqrt(2.0 * Math.PI * 4.5282e+09)).mul(phase.mul(2.2399e+06).add(shift.x).cos()).mul(phase.pow2().mul(-4.5282e+09).exp());\n  let xyz = val.mul(VAR.mul(2.0 * Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());\n  xyz = vec3(xyz.x.add(x), xyz.y, xyz.z).div(1.0685e-7);\n  const rgb = XYZ_TO_REC709.mul(xyz);\n  return rgb;\n};\nconst evalIridescence = /*@__PURE__*/Fn(_ref70 => {\n  let {\n    outsideIOR,\n    eta2,\n    cosTheta1,\n    thinFilmThickness,\n    baseF0\n  } = _ref70;\n  // Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\n  const iridescenceIOR = mix(outsideIOR, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\n  // Evaluate the cosTheta on the base layer (Snell law)\n  const sinTheta2Sq = outsideIOR.div(iridescenceIOR).pow2().mul(cosTheta1.pow2().oneMinus());\n\n  // Handle TIR:\n  const cosTheta2Sq = sinTheta2Sq.oneMinus();\n  If(cosTheta2Sq.lessThan(0), () => {\n    return vec3(1.0);\n  });\n  const cosTheta2 = cosTheta2Sq.sqrt();\n\n  // First interface\n  const R0 = IorToFresnel0(iridescenceIOR, outsideIOR);\n  const R12 = F_Schlick({\n    f0: R0,\n    f90: 1.0,\n    dotVH: cosTheta1\n  });\n  //const R21 = R12;\n  const T121 = R12.oneMinus();\n  const phi12 = iridescenceIOR.lessThan(outsideIOR).select(Math.PI, 0.0);\n  const phi21 = float(Math.PI).sub(phi12);\n\n  // Second interface\n  const baseIOR = Fresnel0ToIor(baseF0.clamp(0.0, 0.9999)); // guard against 1.0\n  const R1 = IorToFresnel0(baseIOR, iridescenceIOR.toVec3());\n  const R23 = F_Schlick({\n    f0: R1,\n    f90: 1.0,\n    dotVH: cosTheta2\n  });\n  const phi23 = vec3(baseIOR.x.lessThan(iridescenceIOR).select(Math.PI, 0.0), baseIOR.y.lessThan(iridescenceIOR).select(Math.PI, 0.0), baseIOR.z.lessThan(iridescenceIOR).select(Math.PI, 0.0));\n\n  // Phase shift\n  const OPD = iridescenceIOR.mul(thinFilmThickness, cosTheta2, 2.0);\n  const phi = vec3(phi21).add(phi23);\n\n  // Compound terms\n  const R123 = R12.mul(R23).clamp(1e-5, 0.9999);\n  const r123 = R123.sqrt();\n  const Rs = T121.pow2().mul(R23).div(vec3(1.0).sub(R123));\n\n  // Reflectance term for m = 0 (DC term amplitude)\n  const C0 = R12.add(Rs);\n  const I = C0.toVar();\n\n  // Reflectance term for m > 0 (pairs of diracs)\n  const Cm = Rs.sub(T121).toVar();\n  Loop({\n    start: 1,\n    end: 2,\n    condition: '<=',\n    name: 'm'\n  }, _ref71 => {\n    let {\n      m\n    } = _ref71;\n    Cm.mulAssign(r123);\n    const Sm = evalSensitivity(float(m).mul(OPD), float(m).mul(phi)).mul(2.0);\n    I.addAssign(Cm.mul(Sm));\n  });\n\n  // Since out of gamut colors might be produced, negative color values are clamped to 0.\n  return I.max(vec3(0.0));\n}).setLayout({\n  name: 'evalIridescence',\n  type: 'vec3',\n  inputs: [{\n    name: 'outsideIOR',\n    type: 'float'\n  }, {\n    name: 'eta2',\n    type: 'float'\n  }, {\n    name: 'cosTheta1',\n    type: 'float'\n  }, {\n    name: 'thinFilmThickness',\n    type: 'float'\n  }, {\n    name: 'baseF0',\n    type: 'vec3'\n  }]\n});\n\n//\n//\tSheen\n//\n\n// This is a curve-fit approxmation to the \"Charlie sheen\" BRDF integrated over the hemisphere from\n// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\". The analysis can be found\n// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nconst IBLSheenBRDF = /*@__PURE__*/Fn(_ref72 => {\n  let {\n    normal,\n    viewDir,\n    roughness\n  } = _ref72;\n  const dotNV = normal.dot(viewDir).saturate();\n  const r2 = roughness.pow2();\n  const a = select(roughness.lessThan(0.25), float(-339.2).mul(r2).add(float(161.4).mul(roughness)).sub(25.9), float(-8.48).mul(r2).add(float(14.3).mul(roughness)).sub(9.95));\n  const b = select(roughness.lessThan(0.25), float(44.0).mul(r2).sub(float(23.7).mul(roughness)).add(3.26), float(1.97).mul(r2).sub(float(3.27).mul(roughness)).add(0.72));\n  const DG = select(roughness.lessThan(0.25), 0.0, float(0.1).mul(roughness).sub(0.025)).add(a.mul(dotNV).add(b).exp());\n  return DG.mul(1.0 / Math.PI).saturate();\n});\nconst clearcoatF0 = vec3(0.04);\nconst clearcoatF90 = float(1);\n\n//\n\nclass PhysicalLightingModel extends LightingModel {\n  constructor() {\n    let clearcoat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let sheen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let iridescence = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let anisotropy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let transmission = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let dispersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    super();\n    this.clearcoat = clearcoat;\n    this.sheen = sheen;\n    this.iridescence = iridescence;\n    this.anisotropy = anisotropy;\n    this.transmission = transmission;\n    this.dispersion = dispersion;\n    this.clearcoatRadiance = null;\n    this.clearcoatSpecularDirect = null;\n    this.clearcoatSpecularIndirect = null;\n    this.sheenSpecularDirect = null;\n    this.sheenSpecularIndirect = null;\n    this.iridescenceFresnel = null;\n    this.iridescenceF0 = null;\n  }\n  start(context) {\n    if (this.clearcoat === true) {\n      this.clearcoatRadiance = vec3().toVar('clearcoatRadiance');\n      this.clearcoatSpecularDirect = vec3().toVar('clearcoatSpecularDirect');\n      this.clearcoatSpecularIndirect = vec3().toVar('clearcoatSpecularIndirect');\n    }\n    if (this.sheen === true) {\n      this.sheenSpecularDirect = vec3().toVar('sheenSpecularDirect');\n      this.sheenSpecularIndirect = vec3().toVar('sheenSpecularIndirect');\n    }\n    if (this.iridescence === true) {\n      const dotNVi = transformedNormalView.dot(positionViewDirection).clamp();\n      this.iridescenceFresnel = evalIridescence({\n        outsideIOR: float(1.0),\n        eta2: iridescenceIOR,\n        cosTheta1: dotNVi,\n        thinFilmThickness: iridescenceThickness,\n        baseF0: specularColor\n      });\n      this.iridescenceF0 = Schlick_to_F0({\n        f: this.iridescenceFresnel,\n        f90: 1.0,\n        dotVH: dotNVi\n      });\n    }\n    if (this.transmission === true) {\n      const position = positionWorld;\n      const v = cameraPosition.sub(positionWorld).normalize(); // TODO: Create Node for this, same issue in MaterialX\n      const n = transformedNormalWorld;\n      context.backdrop = getIBLVolumeRefraction(n, v, roughness, diffuseColor, specularColor, specularF90,\n      // specularF90\n      position,\n      // positionWorld\n      modelWorldMatrix,\n      // modelMatrix\n      cameraViewMatrix,\n      // viewMatrix\n      cameraProjectionMatrix,\n      // projMatrix\n      ior, thickness, attenuationColor, attenuationDistance, this.dispersion ? dispersion : null);\n      context.backdropAlpha = transmission;\n      diffuseColor.a.mulAssign(mix(1, context.backdrop.a, transmission));\n    }\n  }\n\n  // Fdez-Agera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n  // Approximates multiscattering in order to preserve energy.\n  // http://www.jcgt.org/published/0008/01/03/\n\n  computeMultiscattering(singleScatter, multiScatter, specularF90) {\n    const dotNV = transformedNormalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV\n\n    const fab = DFGApprox({\n      roughness,\n      dotNV\n    });\n    const Fr = this.iridescenceF0 ? iridescence.mix(specularColor, this.iridescenceF0) : specularColor;\n    const FssEss = Fr.mul(fab.x).add(specularF90.mul(fab.y));\n    const Ess = fab.x.add(fab.y);\n    const Ems = Ess.oneMinus();\n    const Favg = specularColor.add(specularColor.oneMinus().mul(0.047619)); // 1/21\n    const Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());\n    singleScatter.addAssign(FssEss);\n    multiScatter.addAssign(Fms.mul(Ems));\n  }\n  direct(_ref73) {\n    let {\n      lightDirection,\n      lightColor,\n      reflectedLight\n    } = _ref73;\n    const dotNL = transformedNormalView.dot(lightDirection).clamp();\n    const irradiance = dotNL.mul(lightColor);\n    if (this.sheen === true) {\n      this.sheenSpecularDirect.addAssign(irradiance.mul(BRDF_Sheen({\n        lightDirection\n      })));\n    }\n    if (this.clearcoat === true) {\n      const dotNLcc = transformedClearcoatNormalView.dot(lightDirection).clamp();\n      const ccIrradiance = dotNLcc.mul(lightColor);\n      this.clearcoatSpecularDirect.addAssign(ccIrradiance.mul(BRDF_GGX({\n        lightDirection,\n        f0: clearcoatF0,\n        f90: clearcoatF90,\n        roughness: clearcoatRoughness,\n        normalView: transformedClearcoatNormalView\n      })));\n    }\n    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor: diffuseColor.rgb\n    })));\n    reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX({\n      lightDirection,\n      f0: specularColor,\n      f90: 1,\n      roughness,\n      iridescence: this.iridescence,\n      f: this.iridescenceFresnel,\n      USE_IRIDESCENCE: this.iridescence,\n      USE_ANISOTROPY: this.anisotropy\n    })));\n  }\n  directRectArea(_ref74) {\n    let {\n      lightColor,\n      lightPosition,\n      halfWidth,\n      halfHeight,\n      reflectedLight,\n      ltc_1,\n      ltc_2\n    } = _ref74;\n    const p0 = lightPosition.add(halfWidth).sub(halfHeight); // counterclockwise; light shines in local neg z direction\n    const p1 = lightPosition.sub(halfWidth).sub(halfHeight);\n    const p2 = lightPosition.sub(halfWidth).add(halfHeight);\n    const p3 = lightPosition.add(halfWidth).add(halfHeight);\n    const N = transformedNormalView;\n    const V = positionViewDirection;\n    const P = positionView.toVar();\n    const uv = LTC_Uv({\n      N,\n      V,\n      roughness\n    });\n    const t1 = ltc_1.uv(uv).toVar();\n    const t2 = ltc_2.uv(uv).toVar();\n    const mInv = mat3(vec3(t1.x, 0, t1.y), vec3(0, 1, 0), vec3(t1.z, 0, t1.w)).toVar();\n\n    // LTC Fresnel Approximation by Stephen Hill\n    // http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n    const fresnel = specularColor.mul(t2.x).add(specularColor.oneMinus().mul(t2.y)).toVar();\n    reflectedLight.directSpecular.addAssign(lightColor.mul(fresnel).mul(LTC_Evaluate({\n      N,\n      V,\n      P,\n      mInv,\n      p0,\n      p1,\n      p2,\n      p3\n    })));\n    reflectedLight.directDiffuse.addAssign(lightColor.mul(diffuseColor).mul(LTC_Evaluate({\n      N,\n      V,\n      P,\n      mInv: mat3(1, 0, 0, 0, 1, 0, 0, 0, 1),\n      p0,\n      p1,\n      p2,\n      p3\n    })));\n  }\n  indirect(context, stack, builder) {\n    this.indirectDiffuse(context, stack, builder);\n    this.indirectSpecular(context, stack, builder);\n    this.ambientOcclusion(context, stack, builder);\n  }\n  indirectDiffuse(_ref75) {\n    let {\n      irradiance,\n      reflectedLight\n    } = _ref75;\n    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor\n    })));\n  }\n  indirectSpecular(_ref76) {\n    let {\n      radiance,\n      iblIrradiance,\n      reflectedLight\n    } = _ref76;\n    if (this.sheen === true) {\n      this.sheenSpecularIndirect.addAssign(iblIrradiance.mul(sheen, IBLSheenBRDF({\n        normal: transformedNormalView,\n        viewDir: positionViewDirection,\n        roughness: sheenRoughness\n      })));\n    }\n    if (this.clearcoat === true) {\n      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();\n      const clearcoatEnv = EnvironmentBRDF({\n        dotNV: dotNVcc,\n        specularColor: clearcoatF0,\n        specularF90: clearcoatF90,\n        roughness: clearcoatRoughness\n      });\n      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(clearcoatEnv));\n    }\n\n    // Both indirect specular and indirect diffuse light accumulate here\n\n    const singleScattering = vec3().toVar('singleScattering');\n    const multiScattering = vec3().toVar('multiScattering');\n    const cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);\n    this.computeMultiscattering(singleScattering, multiScattering, specularF90);\n    const totalScattering = singleScattering.add(multiScattering);\n    const diffuse = diffuseColor.mul(totalScattering.r.max(totalScattering.g).max(totalScattering.b).oneMinus());\n    reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));\n    reflectedLight.indirectSpecular.addAssign(multiScattering.mul(cosineWeightedIrradiance));\n    reflectedLight.indirectDiffuse.addAssign(diffuse.mul(cosineWeightedIrradiance));\n  }\n  ambientOcclusion(_ref77) {\n    let {\n      ambientOcclusion,\n      reflectedLight\n    } = _ref77;\n    const dotNV = transformedNormalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV\n\n    const aoNV = dotNV.add(ambientOcclusion);\n    const aoExp = roughness.mul(-16.0).oneMinus().negate().exp2();\n    const aoNode = ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();\n    if (this.clearcoat === true) {\n      this.clearcoatSpecularIndirect.mulAssign(ambientOcclusion);\n    }\n    if (this.sheen === true) {\n      this.sheenSpecularIndirect.mulAssign(ambientOcclusion);\n    }\n    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n    reflectedLight.indirectSpecular.mulAssign(aoNode);\n  }\n  finish(context) {\n    const {\n      outgoingLight\n    } = context;\n    if (this.clearcoat === true) {\n      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();\n      const Fcc = F_Schlick({\n        dotVH: dotNVcc,\n        f0: clearcoatF0,\n        f90: clearcoatF90\n      });\n      const clearcoatLight = outgoingLight.mul(clearcoat.mul(Fcc).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(clearcoat));\n      outgoingLight.assign(clearcoatLight);\n    }\n    if (this.sheen === true) {\n      const sheenEnergyComp = sheen.r.max(sheen.g).max(sheen.b).mul(0.157).oneMinus();\n      const sheenLight = outgoingLight.mul(sheenEnergyComp).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);\n      outgoingLight.assign(sheenLight);\n    }\n  }\n}\n\n// These defines must match with PMREMGenerator\n\nconst cubeUV_r0 = /*@__PURE__*/float(1.0);\nconst cubeUV_m0 = /*@__PURE__*/float(-2.0);\nconst cubeUV_r1 = /*@__PURE__*/float(0.8);\nconst cubeUV_m1 = /*@__PURE__*/float(-1.0);\nconst cubeUV_r4 = /*@__PURE__*/float(0.4);\nconst cubeUV_m4 = /*@__PURE__*/float(2.0);\nconst cubeUV_r5 = /*@__PURE__*/float(0.305);\nconst cubeUV_m5 = /*@__PURE__*/float(3.0);\nconst cubeUV_r6 = /*@__PURE__*/float(0.21);\nconst cubeUV_m6 = /*@__PURE__*/float(4.0);\nconst cubeUV_minMipLevel = /*@__PURE__*/float(4.0);\nconst cubeUV_minTileSize = /*@__PURE__*/float(16.0);\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized ).\n\nconst getFace = /*@__PURE__*/Fn(_ref78 => {\n  let [direction] = _ref78;\n  const absDirection = vec3(abs(direction)).toVar();\n  const face = float(-1.0).toVar();\n  If(absDirection.x.greaterThan(absDirection.z), () => {\n    If(absDirection.x.greaterThan(absDirection.y), () => {\n      face.assign(select(direction.x.greaterThan(0.0), 0.0, 3.0));\n    }).Else(() => {\n      face.assign(select(direction.y.greaterThan(0.0), 1.0, 4.0));\n    });\n  }).Else(() => {\n    If(absDirection.z.greaterThan(absDirection.y), () => {\n      face.assign(select(direction.z.greaterThan(0.0), 2.0, 5.0));\n    }).Else(() => {\n      face.assign(select(direction.y.greaterThan(0.0), 1.0, 4.0));\n    });\n  });\n  return face;\n}).setLayout({\n  name: 'getFace',\n  type: 'float',\n  inputs: [{\n    name: 'direction',\n    type: 'vec3'\n  }]\n});\n\n// RH coordinate system; PMREM face-indexing convention\nconst getUV = /*@__PURE__*/Fn(_ref79 => {\n  let [direction, face] = _ref79;\n  const uv = vec2().toVar();\n  If(face.equal(0.0), () => {\n    uv.assign(vec2(direction.z, direction.y).div(abs(direction.x))); // pos x\n  }).ElseIf(face.equal(1.0), () => {\n    uv.assign(vec2(direction.x.negate(), direction.z.negate()).div(abs(direction.y))); // pos y\n  }).ElseIf(face.equal(2.0), () => {\n    uv.assign(vec2(direction.x.negate(), direction.y).div(abs(direction.z))); // pos z\n  }).ElseIf(face.equal(3.0), () => {\n    uv.assign(vec2(direction.z.negate(), direction.y).div(abs(direction.x))); // neg x\n  }).ElseIf(face.equal(4.0), () => {\n    uv.assign(vec2(direction.x.negate(), direction.z).div(abs(direction.y))); // neg y\n  }).Else(() => {\n    uv.assign(vec2(direction.x, direction.y).div(abs(direction.z))); // neg z\n  });\n  return mul(0.5, uv.add(1.0));\n}).setLayout({\n  name: 'getUV',\n  type: 'vec2',\n  inputs: [{\n    name: 'direction',\n    type: 'vec3'\n  }, {\n    name: 'face',\n    type: 'float'\n  }]\n});\nconst roughnessToMip = /*@__PURE__*/Fn(_ref80 => {\n  let [roughness] = _ref80;\n  const mip = float(0.0).toVar();\n  If(roughness.greaterThanEqual(cubeUV_r1), () => {\n    mip.assign(cubeUV_r0.sub(roughness).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0));\n  }).ElseIf(roughness.greaterThanEqual(cubeUV_r4), () => {\n    mip.assign(cubeUV_r1.sub(roughness).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1));\n  }).ElseIf(roughness.greaterThanEqual(cubeUV_r5), () => {\n    mip.assign(cubeUV_r4.sub(roughness).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4));\n  }).ElseIf(roughness.greaterThanEqual(cubeUV_r6), () => {\n    mip.assign(cubeUV_r5.sub(roughness).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5));\n  }).Else(() => {\n    mip.assign(float(-2.0).mul(log2(mul(1.16, roughness)))); // 1.16 = 1.79^0.25\n  });\n  return mip;\n}).setLayout({\n  name: 'roughnessToMip',\n  type: 'float',\n  inputs: [{\n    name: 'roughness',\n    type: 'float'\n  }]\n});\n\n// RH coordinate system; PMREM face-indexing convention\nconst getDirection = /*@__PURE__*/Fn(_ref81 => {\n  let [uv_immutable, face] = _ref81;\n  const uv = uv_immutable.toVar();\n  uv.assign(mul(2.0, uv).sub(1.0));\n  const direction = vec3(uv, 1.0).toVar();\n  If(face.equal(0.0), () => {\n    direction.assign(direction.zyx); // ( 1, v, u ) pos x\n  }).ElseIf(face.equal(1.0), () => {\n    direction.assign(direction.xzy);\n    direction.xz.mulAssign(-1.0); // ( -u, 1, -v ) pos y\n  }).ElseIf(face.equal(2.0), () => {\n    direction.x.mulAssign(-1.0); // ( -u, v, 1 ) pos z\n  }).ElseIf(face.equal(3.0), () => {\n    direction.assign(direction.zyx);\n    direction.xz.mulAssign(-1.0); // ( -1, v, -u ) neg x\n  }).ElseIf(face.equal(4.0), () => {\n    direction.assign(direction.xzy);\n    direction.xy.mulAssign(-1.0); // ( -u, -1, v ) neg y\n  }).ElseIf(face.equal(5.0), () => {\n    direction.z.mulAssign(-1.0); // ( u, v, -1 ) neg zS\n  });\n  return direction;\n}).setLayout({\n  name: 'getDirection',\n  type: 'vec3',\n  inputs: [{\n    name: 'uv',\n    type: 'vec2'\n  }, {\n    name: 'face',\n    type: 'float'\n  }]\n});\n\n//\n\nconst textureCubeUV = /*@__PURE__*/Fn(_ref82 => {\n  let [envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP] = _ref82;\n  const roughness = float(roughness_immutable);\n  const sampleDir = vec3(sampleDir_immutable);\n  const mip = clamp(roughnessToMip(roughness), cubeUV_m0, CUBEUV_MAX_MIP);\n  const mipF = fract(mip);\n  const mipInt = floor(mip);\n  const color0 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();\n  If(mipF.notEqual(0.0), () => {\n    const color1 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt.add(1.0), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();\n    color0.assign(mix(color0, color1, mipF));\n  });\n  return color0;\n});\nconst bilinearCubeUV = /*@__PURE__*/Fn(_ref83 => {\n  let [envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP] = _ref83;\n  const mipInt = float(mipInt_immutable).toVar();\n  const direction = vec3(direction_immutable);\n  const face = float(getFace(direction)).toVar();\n  const filterInt = float(max$1(cubeUV_minMipLevel.sub(mipInt), 0.0)).toVar();\n  mipInt.assign(max$1(mipInt, cubeUV_minMipLevel));\n  const faceSize = float(exp2(mipInt)).toVar();\n  const uv = vec2(getUV(direction, face).mul(faceSize.sub(2.0)).add(1.0)).toVar();\n  If(face.greaterThan(2.0), () => {\n    uv.y.addAssign(faceSize);\n    face.subAssign(3.0);\n  });\n  uv.x.addAssign(face.mul(faceSize));\n  uv.x.addAssign(filterInt.mul(mul(3.0, cubeUV_minTileSize)));\n  uv.y.addAssign(mul(4.0, exp2(CUBEUV_MAX_MIP).sub(faceSize)));\n  uv.x.mulAssign(CUBEUV_TEXEL_WIDTH);\n  uv.y.mulAssign(CUBEUV_TEXEL_HEIGHT);\n  return envMap.uv(uv).grad(vec2(), vec2()); // disable anisotropic filtering\n});\nconst getSample = /*@__PURE__*/Fn(_ref84 => {\n  let {\n    envMap,\n    mipInt,\n    outputDirection,\n    theta,\n    axis,\n    CUBEUV_TEXEL_WIDTH,\n    CUBEUV_TEXEL_HEIGHT,\n    CUBEUV_MAX_MIP\n  } = _ref84;\n  const cosTheta = cos(theta);\n\n  // Rodrigues' axis-angle rotation\n  const sampleDirection = outputDirection.mul(cosTheta).add(axis.cross(outputDirection).mul(sin(theta))).add(axis.mul(axis.dot(outputDirection).mul(cosTheta.oneMinus())));\n  return bilinearCubeUV(envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);\n});\nconst blur = /*@__PURE__*/Fn(_ref85 => {\n  let {\n    n,\n    latitudinal,\n    poleAxis,\n    outputDirection,\n    weights,\n    samples,\n    dTheta,\n    mipInt,\n    envMap,\n    CUBEUV_TEXEL_WIDTH,\n    CUBEUV_TEXEL_HEIGHT,\n    CUBEUV_MAX_MIP\n  } = _ref85;\n  const axis = vec3(select(latitudinal, poleAxis, cross(poleAxis, outputDirection))).toVar();\n  If(all(axis.equals(vec3(0.0))), () => {\n    axis.assign(vec3(outputDirection.z, 0.0, outputDirection.x.negate()));\n  });\n  axis.assign(normalize(axis));\n  const gl_FragColor = vec3().toVar();\n  gl_FragColor.addAssign(weights.element(int(0)).mul(getSample({\n    theta: 0.0,\n    axis,\n    outputDirection,\n    mipInt,\n    envMap,\n    CUBEUV_TEXEL_WIDTH,\n    CUBEUV_TEXEL_HEIGHT,\n    CUBEUV_MAX_MIP\n  })));\n  Loop({\n    start: int(1),\n    end: n\n  }, _ref86 => {\n    let {\n      i\n    } = _ref86;\n    If(i.greaterThanEqual(samples), () => {\n      Break();\n    });\n    const theta = float(dTheta.mul(float(i))).toVar();\n    gl_FragColor.addAssign(weights.element(i).mul(getSample({\n      theta: theta.mul(-1.0),\n      axis,\n      outputDirection,\n      mipInt,\n      envMap,\n      CUBEUV_TEXEL_WIDTH,\n      CUBEUV_TEXEL_HEIGHT,\n      CUBEUV_MAX_MIP\n    })));\n    gl_FragColor.addAssign(weights.element(i).mul(getSample({\n      theta,\n      axis,\n      outputDirection,\n      mipInt,\n      envMap,\n      CUBEUV_TEXEL_WIDTH,\n      CUBEUV_TEXEL_HEIGHT,\n      CUBEUV_MAX_MIP\n    })));\n  });\n  return vec4(gl_FragColor, 1);\n});\nlet _generator = null;\nconst _cache = new WeakMap();\nfunction _generateCubeUVSize(imageHeight) {\n  const maxMip = Math.log2(imageHeight) - 2;\n  const texelHeight = 1.0 / imageHeight;\n  const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));\n  return {\n    texelWidth,\n    texelHeight,\n    maxMip\n  };\n}\nfunction _getPMREMFromTexture(texture) {\n  let cacheTexture = _cache.get(texture);\n  const pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : -1;\n  if (pmremVersion !== texture.pmremVersion) {\n    const image = texture.image;\n    if (texture.isCubeTexture) {\n      if (isCubeMapReady(image)) {\n        cacheTexture = _generator.fromCubemap(texture, cacheTexture);\n      } else {\n        return null;\n      }\n    } else {\n      if (isEquirectangularMapReady(image)) {\n        cacheTexture = _generator.fromEquirectangular(texture, cacheTexture);\n      } else {\n        return null;\n      }\n    }\n    cacheTexture.pmremVersion = texture.pmremVersion;\n    _cache.set(texture, cacheTexture);\n  }\n  return cacheTexture.texture;\n}\nclass PMREMNode extends TempNode {\n  static get type() {\n    return 'PMREMNode';\n  }\n  constructor(value) {\n    let uvNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let levelNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    super('vec3');\n    this._value = value;\n    this._pmrem = null;\n    this.uvNode = uvNode;\n    this.levelNode = levelNode;\n    this._generator = null;\n    const defaultTexture = new Texture();\n    defaultTexture.isRenderTargetTexture = true;\n    this._texture = texture(defaultTexture);\n    this._width = uniform(0);\n    this._height = uniform(0);\n    this._maxMip = uniform(0);\n    this.updateBeforeType = NodeUpdateType.RENDER;\n  }\n  set value(value) {\n    this._value = value;\n    this._pmrem = null;\n  }\n  get value() {\n    return this._value;\n  }\n  updateFromTexture(texture) {\n    const cubeUVSize = _generateCubeUVSize(texture.image.height);\n    this._texture.value = texture;\n    this._width.value = cubeUVSize.texelWidth;\n    this._height.value = cubeUVSize.texelHeight;\n    this._maxMip.value = cubeUVSize.maxMip;\n  }\n  updateBefore() {\n    let pmrem = this._pmrem;\n    const pmremVersion = pmrem ? pmrem.pmremVersion : -1;\n    const texture = this._value;\n    if (pmremVersion !== texture.pmremVersion) {\n      if (texture.isPMREMTexture === true) {\n        pmrem = texture;\n      } else {\n        pmrem = _getPMREMFromTexture(texture);\n      }\n      if (pmrem !== null) {\n        this._pmrem = pmrem;\n        this.updateFromTexture(pmrem);\n      }\n    }\n  }\n  setup(builder) {\n    if (_generator === null) {\n      _generator = builder.createPMREMGenerator();\n    }\n\n    //\n\n    this.updateBefore(builder);\n\n    //\n\n    let uvNode = this.uvNode;\n    if (uvNode === null && builder.context.getUV) {\n      uvNode = builder.context.getUV(this);\n    }\n\n    //\n\n    const texture = this.value;\n    if (builder.renderer.coordinateSystem === WebGLCoordinateSystem && texture.isPMREMTexture !== true && texture.isRenderTargetTexture === true) {\n      uvNode = vec3(uvNode.x.negate(), uvNode.yz);\n    }\n\n    //\n\n    let levelNode = this.levelNode;\n    if (levelNode === null && builder.context.getTextureLevel) {\n      levelNode = builder.context.getTextureLevel(this);\n    }\n\n    //\n\n    return textureCubeUV(this._texture, uvNode, levelNode, this._width, this._height, this._maxMip);\n  }\n}\nfunction isCubeMapReady(image) {\n  if (image === null || image === undefined) return false;\n  let count = 0;\n  const length = 6;\n  for (let i = 0; i < length; i++) {\n    if (image[i] !== undefined) count++;\n  }\n  return count === length;\n}\nfunction isEquirectangularMapReady(image) {\n  if (image === null || image === undefined) return false;\n  return image.height > 0;\n}\nconst pmremTexture = /*@__PURE__*/nodeProxy(PMREMNode);\nconst _envNodeCache = new WeakMap();\nclass EnvironmentNode extends LightingNode {\n  static get type() {\n    return 'EnvironmentNode';\n  }\n  constructor() {\n    let envNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this.envNode = envNode;\n  }\n  setup(builder) {\n    const {\n      material\n    } = builder;\n    let envNode = this.envNode;\n    if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {\n      const value = envNode.isTextureNode ? envNode.value : material[envNode.property];\n      let cacheEnvNode = _envNodeCache.get(value);\n      if (cacheEnvNode === undefined) {\n        cacheEnvNode = pmremTexture(value);\n        _envNodeCache.set(value, cacheEnvNode);\n      }\n      envNode = cacheEnvNode;\n    }\n\n    //\n\n    const envMap = material.envMap;\n    const intensity = envMap ? reference('envMapIntensity', 'float', builder.material) : reference('environmentIntensity', 'float', builder.scene); // @TODO: Add materialEnvIntensity in MaterialNode\n\n    const useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;\n    const radianceNormalView = useAnisotropy ? transformedBentNormalView : transformedNormalView;\n    const radiance = envNode.context(createRadianceContext(roughness, radianceNormalView)).mul(intensity);\n    const irradiance = envNode.context(createIrradianceContext(transformedNormalWorld)).mul(Math.PI).mul(intensity);\n    const isolateRadiance = cache(radiance);\n    const isolateIrradiance = cache(irradiance);\n\n    //\n\n    builder.context.radiance.addAssign(isolateRadiance);\n    builder.context.iblIrradiance.addAssign(isolateIrradiance);\n\n    //\n\n    const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;\n    if (clearcoatRadiance) {\n      const clearcoatRadianceContext = envNode.context(createRadianceContext(clearcoatRoughness, transformedClearcoatNormalView)).mul(intensity);\n      const isolateClearcoatRadiance = cache(clearcoatRadianceContext);\n      clearcoatRadiance.addAssign(isolateClearcoatRadiance);\n    }\n  }\n}\nconst createRadianceContext = (roughnessNode, normalViewNode) => {\n  let reflectVec = null;\n  return {\n    getUV: () => {\n      if (reflectVec === null) {\n        reflectVec = positionViewDirection.negate().reflect(normalViewNode);\n\n        // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n        reflectVec = roughnessNode.mul(roughnessNode).mix(reflectVec, normalViewNode).normalize();\n        reflectVec = reflectVec.transformDirection(cameraViewMatrix);\n      }\n      return reflectVec;\n    },\n    getTextureLevel: () => {\n      return roughnessNode;\n    }\n  };\n};\nconst createIrradianceContext = normalWorldNode => {\n  return {\n    getUV: () => {\n      return normalWorldNode;\n    },\n    getTextureLevel: () => {\n      return float(1.0);\n    }\n  };\n};\nconst _defaultValues$6 = /*@__PURE__*/new MeshStandardMaterial();\nclass MeshStandardNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshStandardNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshStandardNodeMaterial = true;\n    this.lights = true;\n    this.emissiveNode = null;\n    this.metalnessNode = null;\n    this.roughnessNode = null;\n    this.setDefaultValues(_defaultValues$6);\n    this.setValues(parameters);\n  }\n  setupEnvironment(builder) {\n    let envNode = super.setupEnvironment(builder);\n    if (envNode === null && builder.environmentNode) {\n      envNode = builder.environmentNode;\n    }\n    return envNode ? new EnvironmentNode(envNode) : null;\n  }\n  setupLightingModel(/*builder*/\n  ) {\n    return new PhysicalLightingModel();\n  }\n  setupSpecular() {\n    const specularColorNode = mix(vec3(0.04), diffuseColor.rgb, metalness);\n    specularColor.assign(specularColorNode);\n    specularF90.assign(1.0);\n  }\n  setupVariants() {\n    // METALNESS\n\n    const metalnessNode = this.metalnessNode ? float(this.metalnessNode) : materialMetalness;\n    metalness.assign(metalnessNode);\n\n    // ROUGHNESS\n\n    let roughnessNode = this.roughnessNode ? float(this.roughnessNode) : materialRoughness;\n    roughnessNode = getRoughness({\n      roughness: roughnessNode\n    });\n    roughness.assign(roughnessNode);\n\n    // SPECULAR COLOR\n\n    this.setupSpecular();\n\n    // DIFFUSE COLOR\n\n    diffuseColor.assign(vec4(diffuseColor.rgb.mul(metalnessNode.oneMinus()), diffuseColor.a));\n  }\n  copy(source) {\n    this.emissiveNode = source.emissiveNode;\n    this.metalnessNode = source.metalnessNode;\n    this.roughnessNode = source.roughnessNode;\n    return super.copy(source);\n  }\n}\nconst _defaultValues$5 = /*@__PURE__*/new MeshPhysicalMaterial();\nclass MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {\n  static get type() {\n    return 'MeshPhysicalNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshPhysicalNodeMaterial = true;\n    this.clearcoatNode = null;\n    this.clearcoatRoughnessNode = null;\n    this.clearcoatNormalNode = null;\n    this.sheenNode = null;\n    this.sheenRoughnessNode = null;\n    this.iridescenceNode = null;\n    this.iridescenceIORNode = null;\n    this.iridescenceThicknessNode = null;\n    this.specularIntensityNode = null;\n    this.specularColorNode = null;\n    this.iorNode = null;\n    this.transmissionNode = null;\n    this.thicknessNode = null;\n    this.attenuationDistanceNode = null;\n    this.attenuationColorNode = null;\n    this.dispersionNode = null;\n    this.anisotropyNode = null;\n    this.setDefaultValues(_defaultValues$5);\n    this.setValues(parameters);\n  }\n  get useClearcoat() {\n    return this.clearcoat > 0 || this.clearcoatNode !== null;\n  }\n  get useIridescence() {\n    return this.iridescence > 0 || this.iridescenceNode !== null;\n  }\n  get useSheen() {\n    return this.sheen > 0 || this.sheenNode !== null;\n  }\n  get useAnisotropy() {\n    return this.anisotropy > 0 || this.anisotropyNode !== null;\n  }\n  get useTransmission() {\n    return this.transmission > 0 || this.transmissionNode !== null;\n  }\n  get useDispersion() {\n    return this.dispersion > 0 || this.dispersionNode !== null;\n  }\n  setupSpecular() {\n    const iorNode = this.iorNode ? float(this.iorNode) : materialIOR;\n    ior.assign(iorNode);\n    specularColor.assign(mix(min$1(pow2(ior.sub(1.0).div(ior.add(1.0))).mul(materialSpecularColor), vec3(1.0)).mul(materialSpecularIntensity), diffuseColor.rgb, metalness));\n    specularF90.assign(mix(materialSpecularIntensity, 1.0, metalness));\n  }\n  setupLightingModel(/*builder*/\n  ) {\n    return new PhysicalLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);\n  }\n  setupVariants(builder) {\n    super.setupVariants(builder);\n\n    // CLEARCOAT\n\n    if (this.useClearcoat) {\n      const clearcoatNode = this.clearcoatNode ? float(this.clearcoatNode) : materialClearcoat;\n      const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float(this.clearcoatRoughnessNode) : materialClearcoatRoughness;\n      clearcoat.assign(clearcoatNode);\n      clearcoatRoughness.assign(getRoughness({\n        roughness: clearcoatRoughnessNode\n      }));\n    }\n\n    // SHEEN\n\n    if (this.useSheen) {\n      const sheenNode = this.sheenNode ? vec3(this.sheenNode) : materialSheen;\n      const sheenRoughnessNode = this.sheenRoughnessNode ? float(this.sheenRoughnessNode) : materialSheenRoughness;\n      sheen.assign(sheenNode);\n      sheenRoughness.assign(sheenRoughnessNode);\n    }\n\n    // IRIDESCENCE\n\n    if (this.useIridescence) {\n      const iridescenceNode = this.iridescenceNode ? float(this.iridescenceNode) : materialIridescence;\n      const iridescenceIORNode = this.iridescenceIORNode ? float(this.iridescenceIORNode) : materialIridescenceIOR;\n      const iridescenceThicknessNode = this.iridescenceThicknessNode ? float(this.iridescenceThicknessNode) : materialIridescenceThickness;\n      iridescence.assign(iridescenceNode);\n      iridescenceIOR.assign(iridescenceIORNode);\n      iridescenceThickness.assign(iridescenceThicknessNode);\n    }\n\n    // ANISOTROPY\n\n    if (this.useAnisotropy) {\n      const anisotropyV = (this.anisotropyNode ? vec2(this.anisotropyNode) : materialAnisotropy).toVar();\n      anisotropy.assign(anisotropyV.length());\n      If(anisotropy.equal(0.0), () => {\n        anisotropyV.assign(vec2(1.0, 0.0));\n      }).Else(() => {\n        anisotropyV.divAssign(vec2(anisotropy));\n        anisotropy.assign(anisotropy.saturate());\n      });\n\n      // Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.\n      alphaT.assign(anisotropy.pow2().mix(roughness.pow2(), 1.0));\n      anisotropyT.assign(TBNViewMatrix[0].mul(anisotropyV.x).add(TBNViewMatrix[1].mul(anisotropyV.y)));\n      anisotropyB.assign(TBNViewMatrix[1].mul(anisotropyV.x).sub(TBNViewMatrix[0].mul(anisotropyV.y)));\n    }\n\n    // TRANSMISSION\n\n    if (this.useTransmission) {\n      const transmissionNode = this.transmissionNode ? float(this.transmissionNode) : materialTransmission;\n      const thicknessNode = this.thicknessNode ? float(this.thicknessNode) : materialThickness;\n      const attenuationDistanceNode = this.attenuationDistanceNode ? float(this.attenuationDistanceNode) : materialAttenuationDistance;\n      const attenuationColorNode = this.attenuationColorNode ? vec3(this.attenuationColorNode) : materialAttenuationColor;\n      transmission.assign(transmissionNode);\n      thickness.assign(thicknessNode);\n      attenuationDistance.assign(attenuationDistanceNode);\n      attenuationColor.assign(attenuationColorNode);\n      if (this.useDispersion) {\n        const dispersionNode = this.dispersionNode ? float(this.dispersionNode) : materialDispersion;\n        dispersion.assign(dispersionNode);\n      }\n    }\n  }\n  setupClearcoatNormal() {\n    return this.clearcoatNormalNode ? vec3(this.clearcoatNormalNode) : materialClearcoatNormal;\n  }\n  setup(builder) {\n    builder.context.setupClearcoatNormal = () => this.setupClearcoatNormal(builder);\n    super.setup(builder);\n  }\n  copy(source) {\n    this.clearcoatNode = source.clearcoatNode;\n    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;\n    this.clearcoatNormalNode = source.clearcoatNormalNode;\n    this.sheenNode = source.sheenNode;\n    this.sheenRoughnessNode = source.sheenRoughnessNode;\n    this.iridescenceNode = source.iridescenceNode;\n    this.iridescenceIORNode = source.iridescenceIORNode;\n    this.iridescenceThicknessNode = source.iridescenceThicknessNode;\n    this.specularIntensityNode = source.specularIntensityNode;\n    this.specularColorNode = source.specularColorNode;\n    this.transmissionNode = source.transmissionNode;\n    this.thicknessNode = source.thicknessNode;\n    this.attenuationDistanceNode = source.attenuationDistanceNode;\n    this.attenuationColorNode = source.attenuationColorNode;\n    this.dispersionNode = source.dispersionNode;\n    this.anisotropyNode = source.anisotropyNode;\n    return super.copy(source);\n  }\n}\nclass SSSLightingModel extends PhysicalLightingModel {\n  constructor(useClearcoat, useSheen, useIridescence, useSSS) {\n    super(useClearcoat, useSheen, useIridescence);\n    this.useSSS = useSSS;\n  }\n  direct(_ref87, stack, builder) {\n    let {\n      lightDirection,\n      lightColor,\n      reflectedLight\n    } = _ref87;\n    if (this.useSSS === true) {\n      const material = builder.material;\n      const {\n        thicknessColorNode,\n        thicknessDistortionNode,\n        thicknessAmbientNode,\n        thicknessAttenuationNode,\n        thicknessPowerNode,\n        thicknessScaleNode\n      } = material;\n      const scatteringHalf = lightDirection.add(transformedNormalView.mul(thicknessDistortionNode)).normalize();\n      const scatteringDot = float(positionViewDirection.dot(scatteringHalf.negate()).saturate().pow(thicknessPowerNode).mul(thicknessScaleNode));\n      const scatteringIllu = vec3(scatteringDot.add(thicknessAmbientNode).mul(thicknessColorNode));\n      reflectedLight.directDiffuse.addAssign(scatteringIllu.mul(thicknessAttenuationNode.mul(lightColor)));\n    }\n    super.direct({\n      lightDirection,\n      lightColor,\n      reflectedLight\n    }, stack, builder);\n  }\n}\nclass MeshSSSNodeMaterial extends MeshPhysicalNodeMaterial {\n  static get type() {\n    return 'MeshSSSNodeMaterial';\n  }\n  constructor(parameters) {\n    super(parameters);\n    this.thicknessColorNode = null;\n    this.thicknessDistortionNode = float(0.1);\n    this.thicknessAmbientNode = float(0.0);\n    this.thicknessAttenuationNode = float(.1);\n    this.thicknessPowerNode = float(2.0);\n    this.thicknessScaleNode = float(10.0);\n  }\n  get useSSS() {\n    return this.thicknessColorNode !== null;\n  }\n  setupLightingModel(/*builder*/\n  ) {\n    return new SSSLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useSSS);\n  }\n  copy(source) {\n    this.thicknessColorNode = source.thicknessColorNode;\n    this.thicknessDistortionNode = source.thicknessDistortionNode;\n    this.thicknessAmbientNode = source.thicknessAmbientNode;\n    this.thicknessAttenuationNode = source.thicknessAttenuationNode;\n    this.thicknessPowerNode = source.thicknessPowerNode;\n    this.thicknessScaleNode = source.thicknessScaleNode;\n    return super.copy(source);\n  }\n}\nconst getGradientIrradiance = /*@__PURE__*/Fn(_ref88 => {\n  let {\n    normal,\n    lightDirection,\n    builder\n  } = _ref88;\n  // dotNL will be from -1.0 to 1.0\n  const dotNL = normal.dot(lightDirection);\n  const coord = vec2(dotNL.mul(0.5).add(0.5), 0.0);\n  if (builder.material.gradientMap) {\n    const gradientMap = materialReference('gradientMap', 'texture').context({\n      getUV: () => coord\n    });\n    return vec3(gradientMap.r);\n  } else {\n    const fw = coord.fwidth().mul(0.5);\n    return mix(vec3(0.7), vec3(1.0), smoothstep(float(0.7).sub(fw.x), float(0.7).add(fw.x), coord.x));\n  }\n});\nclass ToonLightingModel extends LightingModel {\n  direct(_ref89, stack, builder) {\n    let {\n      lightDirection,\n      lightColor,\n      reflectedLight\n    } = _ref89;\n    const irradiance = getGradientIrradiance({\n      normal: normalGeometry,\n      lightDirection,\n      builder\n    }).mul(lightColor);\n    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor: diffuseColor.rgb\n    })));\n  }\n  indirect(_ref90) {\n    let {\n      ambientOcclusion,\n      irradiance,\n      reflectedLight\n    } = _ref90;\n    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor\n    })));\n    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n  }\n}\nconst _defaultValues$4 = /*@__PURE__*/new MeshToonMaterial();\nclass MeshToonNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshToonNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshToonNodeMaterial = true;\n    this.lights = true;\n    this.setDefaultValues(_defaultValues$4);\n    this.setValues(parameters);\n  }\n  setupLightingModel(/*builder*/\n  ) {\n    return new ToonLightingModel();\n  }\n}\nclass MatcapUVNode extends TempNode {\n  static get type() {\n    return 'MatcapUVNode';\n  }\n  constructor() {\n    super('vec2');\n  }\n  setup() {\n    const x = vec3(positionViewDirection.z, 0, positionViewDirection.x.negate()).normalize();\n    const y = positionViewDirection.cross(x);\n    return vec2(x.dot(transformedNormalView), y.dot(transformedNormalView)).mul(0.495).add(0.5); // 0.495 to remove artifacts caused by undersized matcap disks\n  }\n}\nconst matcapUV = /*@__PURE__*/nodeImmutable(MatcapUVNode);\nconst _defaultValues$3 = /*@__PURE__*/new MeshMatcapMaterial();\nclass MeshMatcapNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshMatcapNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.lights = false;\n    this.isMeshMatcapNodeMaterial = true;\n    this.setDefaultValues(_defaultValues$3);\n    this.setValues(parameters);\n  }\n  setupVariants(builder) {\n    const uv = matcapUV;\n    let matcapColor;\n    if (builder.material.matcap) {\n      matcapColor = materialReference('matcap', 'texture').context({\n        getUV: () => uv\n      });\n    } else {\n      matcapColor = vec3(mix(0.2, 0.8, uv.y)); // default if matcap is missing\n    }\n    diffuseColor.rgb.mulAssign(matcapColor.rgb);\n  }\n}\nconst _defaultValues$2 = /*@__PURE__*/new PointsMaterial();\nclass PointsNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'PointsNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isPointsNodeMaterial = true;\n    this.lights = false;\n    this.transparent = true;\n    this.sizeNode = null;\n    this.setDefaultValues(_defaultValues$2);\n    this.setValues(parameters);\n  }\n  copy(source) {\n    this.sizeNode = source.sizeNode;\n    return super.copy(source);\n  }\n}\nclass RotateNode extends TempNode {\n  static get type() {\n    return 'RotateNode';\n  }\n  constructor(positionNode, rotationNode) {\n    super();\n    this.positionNode = positionNode;\n    this.rotationNode = rotationNode;\n  }\n  getNodeType(builder) {\n    return this.positionNode.getNodeType(builder);\n  }\n  setup(builder) {\n    const {\n      rotationNode,\n      positionNode\n    } = this;\n    const nodeType = this.getNodeType(builder);\n    if (nodeType === 'vec2') {\n      const cosAngle = rotationNode.cos();\n      const sinAngle = rotationNode.sin();\n      const rotationMatrix = mat2(cosAngle, sinAngle, sinAngle.negate(), cosAngle);\n      return rotationMatrix.mul(positionNode);\n    } else {\n      const rotation = rotationNode;\n      const rotationXMatrix = mat4(vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, cos(rotation.x), sin(rotation.x).negate(), 0.0), vec4(0.0, sin(rotation.x), cos(rotation.x), 0.0), vec4(0.0, 0.0, 0.0, 1.0));\n      const rotationYMatrix = mat4(vec4(cos(rotation.y), 0.0, sin(rotation.y), 0.0), vec4(0.0, 1.0, 0.0, 0.0), vec4(sin(rotation.y).negate(), 0.0, cos(rotation.y), 0.0), vec4(0.0, 0.0, 0.0, 1.0));\n      const rotationZMatrix = mat4(vec4(cos(rotation.z), sin(rotation.z).negate(), 0.0, 0.0), vec4(sin(rotation.z), cos(rotation.z), 0.0, 0.0), vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0));\n      return rotationXMatrix.mul(rotationYMatrix).mul(rotationZMatrix).mul(vec4(positionNode, 1.0)).xyz;\n    }\n  }\n}\nconst rotate = /*@__PURE__*/nodeProxy(RotateNode);\nconst _defaultValues$1 = /*@__PURE__*/new SpriteMaterial();\nclass SpriteNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'SpriteNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isSpriteNodeMaterial = true;\n    this.lights = false;\n    this._useSizeAttenuation = true;\n    this.positionNode = null;\n    this.rotationNode = null;\n    this.scaleNode = null;\n    this.setDefaultValues(_defaultValues$1);\n    this.setValues(parameters);\n  }\n  setupPosition(_ref91) {\n    let {\n      object,\n      camera,\n      context\n    } = _ref91;\n    const sizeAttenuation = this.sizeAttenuation;\n\n    // < VERTEX STAGE >\n\n    const {\n      positionNode,\n      rotationNode,\n      scaleNode\n    } = this;\n    const vertex = positionLocal;\n    let mvPosition = modelViewMatrix.mul(vec3(positionNode || 0));\n    let scale = vec2(modelWorldMatrix[0].xyz.length(), modelWorldMatrix[1].xyz.length());\n    if (scaleNode !== null) {\n      scale = scale.mul(scaleNode);\n    }\n    if (!sizeAttenuation) {\n      if (camera.isPerspectiveCamera) {\n        scale = scale.mul(mvPosition.z.negate());\n      } else {\n        const orthoScale = float(2.0).div(cameraProjectionMatrix.element(1).element(1));\n        scale = scale.mul(orthoScale.mul(2));\n      }\n    }\n    let alignedPosition = vertex.xy;\n    if (object.center && object.center.isVector2 === true) {\n      const center = reference$1('center', 'vec2');\n      alignedPosition = alignedPosition.sub(center.sub(0.5));\n    }\n    alignedPosition = alignedPosition.mul(scale);\n    const rotation = float(rotationNode || materialRotation);\n    const rotatedPosition = rotate(alignedPosition, rotation);\n    mvPosition = vec4(mvPosition.xy.add(rotatedPosition), mvPosition.zw);\n    const modelViewProjection = cameraProjectionMatrix.mul(mvPosition);\n    context.vertex = vertex;\n    return modelViewProjection;\n  }\n  copy(source) {\n    this.positionNode = source.positionNode;\n    this.rotationNode = source.rotationNode;\n    this.scaleNode = source.scaleNode;\n    return super.copy(source);\n  }\n  get sizeAttenuation() {\n    return this._useSizeAttenuation;\n  }\n  set sizeAttenuation(value) {\n    if (this._useSizeAttenuation !== value) {\n      this._useSizeAttenuation = value;\n      this.needsUpdate = true;\n    }\n  }\n}\nclass ShadowMaskModel extends LightingModel {\n  constructor() {\n    super();\n    this.shadowNode = float(1).toVar('shadowMask');\n  }\n  direct(_ref92) {\n    let {\n      shadowMask\n    } = _ref92;\n    this.shadowNode.mulAssign(shadowMask);\n  }\n  finish(context) {\n    diffuseColor.a.mulAssign(this.shadowNode.oneMinus());\n    context.outgoingLight.rgb.assign(diffuseColor.rgb); // TODO: Optimize LightsNode to avoid this assignment\n  }\n}\nconst _defaultValues = /*@__PURE__*/new ShadowMaterial();\nclass ShadowNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'ShadowNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isShadowNodeMaterial = true;\n    this.lights = true;\n    this.setDefaultValues(_defaultValues);\n    this.setValues(parameters);\n  }\n  setupLightingModel(/*builder*/\n  ) {\n    return new ShadowMaskModel();\n  }\n}\nconst normal = Fn(_ref93 => {\n  let {\n    texture,\n    uv\n  } = _ref93;\n  const epsilon = 0.0001;\n  const ret = vec3().toVar();\n  If(uv.x.lessThan(epsilon), () => {\n    ret.assign(vec3(1, 0, 0));\n  }).ElseIf(uv.y.lessThan(epsilon), () => {\n    ret.assign(vec3(0, 1, 0));\n  }).ElseIf(uv.z.lessThan(epsilon), () => {\n    ret.assign(vec3(0, 0, 1));\n  }).ElseIf(uv.x.greaterThan(1 - epsilon), () => {\n    ret.assign(vec3(-1, 0, 0));\n  }).ElseIf(uv.y.greaterThan(1 - epsilon), () => {\n    ret.assign(vec3(0, -1, 0));\n  }).ElseIf(uv.z.greaterThan(1 - epsilon), () => {\n    ret.assign(vec3(0, 0, -1));\n  }).Else(() => {\n    const step = 0.01;\n    const x = texture.uv(uv.add(vec3(-step, 0.0, 0.0))).r.sub(texture.uv(uv.add(vec3(step, 0.0, 0.0))).r);\n    const y = texture.uv(uv.add(vec3(0.0, -step, 0.0))).r.sub(texture.uv(uv.add(vec3(0.0, step, 0.0))).r);\n    const z = texture.uv(uv.add(vec3(0.0, 0.0, -step))).r.sub(texture.uv(uv.add(vec3(0.0, 0.0, step))).r);\n    ret.assign(vec3(x, y, z));\n  });\n  return ret.normalize();\n});\nclass Texture3DNode extends TextureNode {\n  static get type() {\n    return 'Texture3DNode';\n  }\n  constructor(value) {\n    let uvNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let levelNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    super(value, uvNode, levelNode);\n    this.isTexture3DNode = true;\n  }\n  getInputType(/*builder*/\n  ) {\n    return 'texture3D';\n  }\n  getDefaultUV() {\n    return vec3(0.5, 0.5, 0.5);\n  }\n  setUpdateMatrix(/*updateMatrix*/) {} // Ignore .updateMatrix for 3d TextureNode\n\n  setupUV(builder, uvNode) {\n    return uvNode;\n  }\n  generateUV(builder, uvNode) {\n    return uvNode.build(builder, 'vec3');\n  }\n  normal(uvNode) {\n    return normal({\n      texture: this,\n      uv: uvNode\n    });\n  }\n}\nconst texture3D = /*@__PURE__*/nodeProxy(Texture3DNode);\nclass VolumeNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'VolumeNodeMaterial';\n  }\n  constructor() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.lights = false;\n    this.isVolumeNodeMaterial = true;\n    this.testNode = null;\n    this.setValues(params);\n  }\n  setup(builder) {\n    const map = texture3D(this.map, null, 0);\n    const hitBox = Fn(_ref94 => {\n      let {\n        orig,\n        dir\n      } = _ref94;\n      const box_min = vec3(-0.5);\n      const box_max = vec3(0.5);\n      const inv_dir = dir.reciprocal();\n      const tmin_tmp = box_min.sub(orig).mul(inv_dir);\n      const tmax_tmp = box_max.sub(orig).mul(inv_dir);\n      const tmin = min$1(tmin_tmp, tmax_tmp);\n      const tmax = max$1(tmin_tmp, tmax_tmp);\n      const t0 = max$1(tmin.x, max$1(tmin.y, tmin.z));\n      const t1 = min$1(tmax.x, min$1(tmax.y, tmax.z));\n      return vec2(t0, t1);\n    });\n    this.fragmentNode = Fn(() => {\n      const vOrigin = varying(vec3(modelWorldMatrixInverse.mul(vec4(cameraPosition, 1.0))));\n      const vDirection = varying(positionGeometry.sub(vOrigin));\n      const rayDir = vDirection.normalize();\n      const bounds = vec2(hitBox({\n        orig: vOrigin,\n        dir: rayDir\n      })).toVar();\n      bounds.x.greaterThan(bounds.y).discard();\n      bounds.assign(vec2(max$1(bounds.x, 0.0), bounds.y));\n      const p = vec3(vOrigin.add(bounds.x.mul(rayDir))).toVar();\n      const inc = vec3(rayDir.abs().reciprocal()).toVar();\n      const delta = float(min$1(inc.x, min$1(inc.y, inc.z))).toVar('delta'); // used 'delta' name in loop\n\n      delta.divAssign(materialReference('steps', 'float'));\n      const ac = vec4(materialReference('base', 'color'), 0.0).toVar();\n      Loop({\n        type: 'float',\n        start: bounds.x,\n        end: bounds.y,\n        update: '+= delta'\n      }, () => {\n        const d = property('float', 'd').assign(map.uv(p.add(0.5)).r);\n        if (this.testNode !== null) {\n          this.testNode({\n            map: map,\n            mapValue: d,\n            probe: p,\n            finalColor: ac\n          }).append();\n        } else {\n          // default to show surface of mesh\n          ac.a.assign(1);\n          Break();\n        }\n        p.addAssign(rayDir.mul(delta));\n      });\n      ac.a.equal(0).discard();\n      return vec4(ac);\n    })();\n    super.setup(builder);\n  }\n}\nclass Animation {\n  constructor(nodes, info) {\n    this.nodes = nodes;\n    this.info = info;\n    this._context = self;\n    this._animationLoop = null;\n    this._requestId = null;\n  }\n  start() {\n    const update = (time, frame) => {\n      this._requestId = this._context.requestAnimationFrame(update);\n      if (this.info.autoReset === true) this.info.reset();\n      this.nodes.nodeFrame.update();\n      this.info.frame = this.nodes.nodeFrame.frameId;\n      if (this._animationLoop !== null) this._animationLoop(time, frame);\n    };\n    update();\n  }\n  stop() {\n    this._context.cancelAnimationFrame(this._requestId);\n    this._requestId = null;\n  }\n  setAnimationLoop(callback) {\n    this._animationLoop = callback;\n  }\n  setContext(context) {\n    this._context = context;\n  }\n  dispose() {\n    this.stop();\n  }\n}\nclass ChainMap {\n  constructor() {\n    this.weakMap = new WeakMap();\n  }\n  get(keys) {\n    let map = this.weakMap;\n    for (let i = 0; i < keys.length; i++) {\n      map = map.get(keys[i]);\n      if (map === undefined) return undefined;\n    }\n    return map.get(keys[keys.length - 1]);\n  }\n  set(keys, value) {\n    let map = this.weakMap;\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (map.has(key) === false) map.set(key, new WeakMap());\n      map = map.get(key);\n    }\n    return map.set(keys[keys.length - 1], value);\n  }\n  delete(keys) {\n    let map = this.weakMap;\n    for (let i = 0; i < keys.length; i++) {\n      map = map.get(keys[i]);\n      if (map === undefined) return false;\n    }\n    return map.delete(keys[keys.length - 1]);\n  }\n}\nlet _id$7 = 0;\nfunction getKeys(obj) {\n  const keys = Object.keys(obj);\n  let proto = Object.getPrototypeOf(obj);\n  while (proto) {\n    const descriptors = Object.getOwnPropertyDescriptors(proto);\n    for (const key in descriptors) {\n      if (descriptors[key] !== undefined) {\n        const descriptor = descriptors[key];\n        if (descriptor && typeof descriptor.get === 'function') {\n          keys.push(key);\n        }\n      }\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n  return keys;\n}\nclass RenderObject {\n  constructor(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext) {\n    this._nodes = nodes;\n    this._geometries = geometries;\n    this.id = _id$7++;\n    this.renderer = renderer;\n    this.object = object;\n    this.material = material;\n    this.scene = scene;\n    this.camera = camera;\n    this.lightsNode = lightsNode;\n    this.context = renderContext;\n    this.geometry = object.geometry;\n    this.version = material.version;\n    this.drawRange = null;\n    this.attributes = null;\n    this.pipeline = null;\n    this.vertexBuffers = null;\n    this.drawParams = null;\n    this.bundle = null;\n    this.clippingContext = clippingContext;\n    this.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';\n    this.initialNodesCacheKey = this.getDynamicCacheKey();\n    this.initialCacheKey = this.getCacheKey();\n    this._nodeBuilderState = null;\n    this._bindings = null;\n    this._monitor = null;\n    this.onDispose = null;\n    this.isRenderObject = true;\n    this.onMaterialDispose = () => {\n      this.dispose();\n    };\n    this.material.addEventListener('dispose', this.onMaterialDispose);\n  }\n  updateClipping(parent) {\n    this.clippingContext = parent;\n  }\n  get clippingNeedsUpdate() {\n    if (this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey) return false;\n    this.clippingContextCacheKey = this.clippingContext.cacheKey;\n    return true;\n  }\n  get hardwareClippingPlanes() {\n    return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;\n  }\n  getNodeBuilderState() {\n    return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));\n  }\n  getMonitor() {\n    return this._monitor || (this._monitor = this.getNodeBuilderState().monitor);\n  }\n  getBindings() {\n    return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());\n  }\n  getIndex() {\n    return this._geometries.getIndex(this);\n  }\n  getIndirect() {\n    return this._geometries.getIndirect(this);\n  }\n  getChainArray() {\n    return [this.object, this.material, this.context, this.lightsNode];\n  }\n  setGeometry(geometry) {\n    this.geometry = geometry;\n    this.attributes = null;\n  }\n  getAttributes() {\n    if (this.attributes !== null) return this.attributes;\n    const nodeAttributes = this.getNodeBuilderState().nodeAttributes;\n    const geometry = this.geometry;\n    const attributes = [];\n    const vertexBuffers = new Set();\n    for (const nodeAttribute of nodeAttributes) {\n      const attribute = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute(nodeAttribute.name);\n      if (attribute === undefined) continue;\n      attributes.push(attribute);\n      const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n      vertexBuffers.add(bufferAttribute);\n    }\n    this.attributes = attributes;\n    this.vertexBuffers = Array.from(vertexBuffers.values());\n    return attributes;\n  }\n  getVertexBuffers() {\n    if (this.vertexBuffers === null) this.getAttributes();\n    return this.vertexBuffers;\n  }\n  getDrawParameters() {\n    const {\n      object,\n      material,\n      geometry,\n      group,\n      drawRange\n    } = this;\n    const drawParams = this.drawParams || (this.drawParams = {\n      vertexCount: 0,\n      firstVertex: 0,\n      instanceCount: 0,\n      firstInstance: 0\n    });\n    const index = this.getIndex();\n    const hasIndex = index !== null;\n    const instanceCount = geometry.isInstancedBufferGeometry ? geometry.instanceCount : object.count > 1 ? object.count : 1;\n    if (instanceCount === 0) return null;\n    drawParams.instanceCount = instanceCount;\n    if (object.isBatchedMesh === true) return drawParams;\n    let rangeFactor = 1;\n    if (material.wireframe === true && !object.isPoints && !object.isLineSegments && !object.isLine && !object.isLineLoop) {\n      rangeFactor = 2;\n    }\n    let firstVertex = drawRange.start * rangeFactor;\n    let lastVertex = (drawRange.start + drawRange.count) * rangeFactor;\n    if (group !== null) {\n      firstVertex = Math.max(firstVertex, group.start * rangeFactor);\n      lastVertex = Math.min(lastVertex, (group.start + group.count) * rangeFactor);\n    }\n    const position = geometry.attributes.position;\n    let itemCount = Infinity;\n    if (hasIndex) {\n      itemCount = index.count;\n    } else if (position !== undefined && position !== null) {\n      itemCount = position.count;\n    }\n    firstVertex = Math.max(firstVertex, 0);\n    lastVertex = Math.min(lastVertex, itemCount);\n    const count = lastVertex - firstVertex;\n    if (count < 0 || count === Infinity) return null;\n    drawParams.vertexCount = count;\n    drawParams.firstVertex = firstVertex;\n    return drawParams;\n  }\n  getGeometryCacheKey() {\n    const {\n      geometry\n    } = this;\n    let cacheKey = '';\n    for (const name of Object.keys(geometry.attributes).sort()) {\n      const attribute = geometry.attributes[name];\n      cacheKey += name + ',';\n      if (attribute.data) cacheKey += attribute.data.stride + ',';\n      if (attribute.offset) cacheKey += attribute.offset + ',';\n      if (attribute.itemSize) cacheKey += attribute.itemSize + ',';\n      if (attribute.normalized) cacheKey += 'n,';\n    }\n    if (geometry.index) {\n      cacheKey += 'index,';\n    }\n    return cacheKey;\n  }\n  getMaterialCacheKey() {\n    const {\n      object,\n      material\n    } = this;\n    let cacheKey = material.customProgramCacheKey();\n    for (const property of getKeys(material)) {\n      if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(property)) continue;\n      const value = material[property];\n      let valueKey;\n      if (value !== null) {\n        // some material values require a formatting\n\n        const type = typeof value;\n        if (type === 'number') {\n          valueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc\n        } else if (type === 'object') {\n          valueKey = '{';\n          if (value.isTexture) {\n            valueKey += value.mapping;\n          }\n          valueKey += '}';\n        } else {\n          valueKey = String(value);\n        }\n      } else {\n        valueKey = String(value);\n      }\n      cacheKey += /*property + ':' +*/valueKey + ',';\n    }\n    cacheKey += this.clippingContextCacheKey + ',';\n    if (object.geometry) {\n      cacheKey += this.getGeometryCacheKey();\n    }\n    if (object.skeleton) {\n      cacheKey += object.skeleton.bones.length + ',';\n    }\n    if (object.morphTargetInfluences) {\n      cacheKey += object.morphTargetInfluences.length + ',';\n    }\n    if (object.isBatchedMesh) {\n      cacheKey += object._matricesTexture.uuid + ',';\n      if (object._colorsTexture !== null) {\n        cacheKey += object._colorsTexture.uuid + ',';\n      }\n    }\n    if (object.count > 1) {\n      // TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850\n\n      cacheKey += object.uuid + ',';\n    }\n    cacheKey += object.receiveShadow + ',';\n    return hashString(cacheKey);\n  }\n  get needsGeometryUpdate() {\n    return this.geometry.id !== this.object.geometry.id;\n  }\n  get needsUpdate() {\n    return /*this.object.static !== true &&*/this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate;\n  }\n  getDynamicCacheKey() {\n    // Environment Nodes Cache Key\n\n    let cacheKey = this._nodes.getCacheKey(this.scene, this.lightsNode);\n    if (this.object.receiveShadow) {\n      cacheKey += 1;\n    }\n    return cacheKey;\n  }\n  getCacheKey() {\n    return this.getMaterialCacheKey() + this.getDynamicCacheKey();\n  }\n  dispose() {\n    this.material.removeEventListener('dispose', this.onMaterialDispose);\n    this.onDispose();\n  }\n}\nconst chainArray = [];\nclass RenderObjects {\n  constructor(renderer, nodes, geometries, pipelines, bindings, info) {\n    this.renderer = renderer;\n    this.nodes = nodes;\n    this.geometries = geometries;\n    this.pipelines = pipelines;\n    this.bindings = bindings;\n    this.info = info;\n    this.chainMaps = {};\n  }\n  get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {\n    const chainMap = this.getChainMap(passId);\n\n    // reuse chainArray\n    chainArray[0] = object;\n    chainArray[1] = material;\n    chainArray[2] = renderContext;\n    chainArray[3] = lightsNode;\n    let renderObject = chainMap.get(chainArray);\n    if (renderObject === undefined) {\n      renderObject = this.createRenderObject(this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId);\n      chainMap.set(chainArray, renderObject);\n    } else {\n      renderObject.updateClipping(clippingContext);\n      if (renderObject.needsGeometryUpdate) {\n        renderObject.setGeometry(object.geometry);\n      }\n      if (renderObject.version !== material.version || renderObject.needsUpdate) {\n        if (renderObject.initialCacheKey !== renderObject.getCacheKey()) {\n          renderObject.dispose();\n          renderObject = this.get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId);\n        } else {\n          renderObject.version = material.version;\n        }\n      }\n    }\n    return renderObject;\n  }\n  getChainMap() {\n    let passId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';\n    return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());\n  }\n  dispose() {\n    this.chainMaps = {};\n  }\n  createRenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {\n    const chainMap = this.getChainMap(passId);\n    const renderObject = new RenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext);\n    renderObject.onDispose = () => {\n      this.pipelines.delete(renderObject);\n      this.bindings.delete(renderObject);\n      this.nodes.delete(renderObject);\n      chainMap.delete(renderObject.getChainArray());\n    };\n    return renderObject;\n  }\n}\nclass DataMap {\n  constructor() {\n    this.data = new WeakMap();\n  }\n  get(object) {\n    let map = this.data.get(object);\n    if (map === undefined) {\n      map = {};\n      this.data.set(object, map);\n    }\n    return map;\n  }\n  delete(object) {\n    let map;\n    if (this.data.has(object)) {\n      map = this.data.get(object);\n      this.data.delete(object);\n    }\n    return map;\n  }\n  has(object) {\n    return this.data.has(object);\n  }\n  dispose() {\n    this.data = new WeakMap();\n  }\n}\nconst AttributeType = {\n  VERTEX: 1,\n  INDEX: 2,\n  STORAGE: 3,\n  INDIRECT: 4\n};\n\n// size of a chunk in bytes (STD140 layout)\n\nconst GPU_CHUNK_BYTES = 16;\n\n// @TODO: Move to src/constants.js\n\nconst BlendColorFactor = 211;\nconst OneMinusBlendColorFactor = 212;\nclass Attributes extends DataMap {\n  constructor(backend) {\n    super();\n    this.backend = backend;\n  }\n  delete(attribute) {\n    const attributeData = super.delete(attribute);\n    if (attributeData !== undefined) {\n      this.backend.destroyAttribute(attribute);\n    }\n    return attributeData;\n  }\n  update(attribute, type) {\n    const data = this.get(attribute);\n    if (data.version === undefined) {\n      if (type === AttributeType.VERTEX) {\n        this.backend.createAttribute(attribute);\n      } else if (type === AttributeType.INDEX) {\n        this.backend.createIndexAttribute(attribute);\n      } else if (type === AttributeType.STORAGE) {\n        this.backend.createStorageAttribute(attribute);\n      } else if (type === AttributeType.INDIRECT) {\n        this.backend.createIndirectStorageAttribute(attribute);\n      }\n      data.version = this._getBufferAttribute(attribute).version;\n    } else {\n      const bufferAttribute = this._getBufferAttribute(attribute);\n      if (data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage) {\n        this.backend.updateAttribute(attribute);\n        data.version = bufferAttribute.version;\n      }\n    }\n  }\n  _getBufferAttribute(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    return attribute;\n  }\n}\nfunction arrayNeedsUint32(array) {\n  // assumes larger values usually on last\n\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n  }\n  return false;\n}\nfunction getWireframeVersion(geometry) {\n  return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;\n}\nfunction getWireframeIndex(geometry) {\n  const indices = [];\n  const geometryIndex = geometry.index;\n  const geometryPosition = geometry.attributes.position;\n  if (geometryIndex !== null) {\n    const array = geometryIndex.array;\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      const a = array[i + 0];\n      const b = array[i + 1];\n      const c = array[i + 2];\n      indices.push(a, b, b, c, c, a);\n    }\n  } else {\n    const array = geometryPosition.array;\n    for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {\n      const a = i + 0;\n      const b = i + 1;\n      const c = i + 2;\n      indices.push(a, b, b, c, c, a);\n    }\n  }\n  const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);\n  attribute.version = getWireframeVersion(geometry);\n  return attribute;\n}\nclass Geometries extends DataMap {\n  constructor(attributes, info) {\n    super();\n    this.attributes = attributes;\n    this.info = info;\n    this.wireframes = new WeakMap();\n    this.attributeCall = new WeakMap();\n  }\n  has(renderObject) {\n    const geometry = renderObject.geometry;\n    return super.has(geometry) && this.get(geometry).initialized === true;\n  }\n  updateForRender(renderObject) {\n    if (this.has(renderObject) === false) this.initGeometry(renderObject);\n    this.updateAttributes(renderObject);\n  }\n  initGeometry(renderObject) {\n    const geometry = renderObject.geometry;\n    const geometryData = this.get(geometry);\n    geometryData.initialized = true;\n    this.info.memory.geometries++;\n    const onDispose = () => {\n      this.info.memory.geometries--;\n      const index = geometry.index;\n      const geometryAttributes = renderObject.getAttributes();\n      if (index !== null) {\n        this.attributes.delete(index);\n      }\n      for (const geometryAttribute of geometryAttributes) {\n        this.attributes.delete(geometryAttribute);\n      }\n      const wireframeAttribute = this.wireframes.get(geometry);\n      if (wireframeAttribute !== undefined) {\n        this.attributes.delete(wireframeAttribute);\n      }\n      geometry.removeEventListener('dispose', onDispose);\n    };\n    geometry.addEventListener('dispose', onDispose);\n  }\n  updateAttributes(renderObject) {\n    // attributes\n\n    const attributes = renderObject.getAttributes();\n    for (const attribute of attributes) {\n      if (attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute) {\n        this.updateAttribute(attribute, AttributeType.STORAGE);\n      } else {\n        this.updateAttribute(attribute, AttributeType.VERTEX);\n      }\n    }\n\n    // indexes\n\n    const index = this.getIndex(renderObject);\n    if (index !== null) {\n      this.updateAttribute(index, AttributeType.INDEX);\n    }\n\n    // indirect\n\n    const indirect = renderObject.geometry.indirect;\n    if (indirect !== null) {\n      this.updateAttribute(indirect, AttributeType.INDIRECT);\n    }\n  }\n  updateAttribute(attribute, type) {\n    const callId = this.info.render.calls;\n    if (!attribute.isInterleavedBufferAttribute) {\n      if (this.attributeCall.get(attribute) !== callId) {\n        this.attributes.update(attribute, type);\n        this.attributeCall.set(attribute, callId);\n      }\n    } else {\n      if (this.attributeCall.get(attribute) === undefined) {\n        this.attributes.update(attribute, type);\n        this.attributeCall.set(attribute, callId);\n      } else if (this.attributeCall.get(attribute.data) !== callId) {\n        this.attributes.update(attribute, type);\n        this.attributeCall.set(attribute.data, callId);\n        this.attributeCall.set(attribute, callId);\n      }\n    }\n  }\n  getIndirect(renderObject) {\n    return renderObject.geometry.indirect;\n  }\n  getIndex(renderObject) {\n    const {\n      geometry,\n      material\n    } = renderObject;\n    let index = geometry.index;\n    if (material.wireframe === true) {\n      const wireframes = this.wireframes;\n      let wireframeAttribute = wireframes.get(geometry);\n      if (wireframeAttribute === undefined) {\n        wireframeAttribute = getWireframeIndex(geometry);\n        wireframes.set(geometry, wireframeAttribute);\n      } else if (wireframeAttribute.version !== getWireframeVersion(geometry)) {\n        this.attributes.delete(wireframeAttribute);\n        wireframeAttribute = getWireframeIndex(geometry);\n        wireframes.set(geometry, wireframeAttribute);\n      }\n      index = wireframeAttribute;\n    }\n    return index;\n  }\n}\nclass Info {\n  constructor() {\n    this.autoReset = true;\n    this.frame = 0;\n    this.calls = 0;\n    this.render = {\n      calls: 0,\n      frameCalls: 0,\n      drawCalls: 0,\n      triangles: 0,\n      points: 0,\n      lines: 0,\n      timestamp: 0,\n      previousFrameCalls: 0,\n      timestampCalls: 0\n    };\n    this.compute = {\n      calls: 0,\n      frameCalls: 0,\n      timestamp: 0,\n      previousFrameCalls: 0,\n      timestampCalls: 0\n    };\n    this.memory = {\n      geometries: 0,\n      textures: 0\n    };\n  }\n  update(object, count, instanceCount) {\n    this.render.drawCalls++;\n    if (object.isMesh || object.isSprite) {\n      this.render.triangles += instanceCount * (count / 3);\n    } else if (object.isPoints) {\n      this.render.points += instanceCount * count;\n    } else if (object.isLineSegments) {\n      this.render.lines += instanceCount * (count / 2);\n    } else if (object.isLine) {\n      this.render.lines += instanceCount * (count - 1);\n    } else {\n      console.error('THREE.WebGPUInfo: Unknown object type.');\n    }\n  }\n  updateTimestamp(type, time) {\n    if (this[type].timestampCalls === 0) {\n      this[type].timestamp = 0;\n    }\n    this[type].timestamp += time;\n    this[type].timestampCalls++;\n    if (this[type].timestampCalls >= this[type].previousFrameCalls) {\n      this[type].timestampCalls = 0;\n    }\n  }\n  reset() {\n    const previousRenderFrameCalls = this.render.frameCalls;\n    this.render.previousFrameCalls = previousRenderFrameCalls;\n    const previousComputeFrameCalls = this.compute.frameCalls;\n    this.compute.previousFrameCalls = previousComputeFrameCalls;\n    this.render.drawCalls = 0;\n    this.render.frameCalls = 0;\n    this.compute.frameCalls = 0;\n    this.render.triangles = 0;\n    this.render.points = 0;\n    this.render.lines = 0;\n  }\n  dispose() {\n    this.reset();\n    this.calls = 0;\n    this.render.calls = 0;\n    this.compute.calls = 0;\n    this.render.timestamp = 0;\n    this.compute.timestamp = 0;\n    this.memory.geometries = 0;\n    this.memory.textures = 0;\n  }\n}\nclass Pipeline {\n  constructor(cacheKey) {\n    this.cacheKey = cacheKey;\n    this.usedTimes = 0;\n  }\n}\nclass RenderPipeline extends Pipeline {\n  constructor(cacheKey, vertexProgram, fragmentProgram) {\n    super(cacheKey);\n    this.vertexProgram = vertexProgram;\n    this.fragmentProgram = fragmentProgram;\n  }\n}\nclass ComputePipeline extends Pipeline {\n  constructor(cacheKey, computeProgram) {\n    super(cacheKey);\n    this.computeProgram = computeProgram;\n    this.isComputePipeline = true;\n  }\n}\nlet _id$6 = 0;\nclass ProgrammableStage {\n  constructor(code, type) {\n    let transforms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    this.id = _id$6++;\n    this.code = code;\n    this.stage = type;\n    this.transforms = transforms;\n    this.attributes = attributes;\n    this.usedTimes = 0;\n  }\n}\nclass Pipelines extends DataMap {\n  constructor(backend, nodes) {\n    super();\n    this.backend = backend;\n    this.nodes = nodes;\n    this.bindings = null; // set by the bindings\n\n    this.caches = new Map();\n    this.programs = {\n      vertex: new Map(),\n      fragment: new Map(),\n      compute: new Map()\n    };\n  }\n  getForCompute(computeNode, bindings) {\n    const {\n      backend\n    } = this;\n    const data = this.get(computeNode);\n    if (this._needsComputeUpdate(computeNode)) {\n      const previousPipeline = data.pipeline;\n      if (previousPipeline) {\n        previousPipeline.usedTimes--;\n        previousPipeline.computeProgram.usedTimes--;\n      }\n\n      // get shader\n\n      const nodeBuilderState = this.nodes.getForCompute(computeNode);\n\n      // programmable stage\n\n      let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);\n      if (stageCompute === undefined) {\n        if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0) this._releaseProgram(previousPipeline.computeProgram);\n        stageCompute = new ProgrammableStage(nodeBuilderState.computeShader, 'compute', nodeBuilderState.transforms, nodeBuilderState.nodeAttributes);\n        this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);\n        backend.createProgram(stageCompute);\n      }\n\n      // determine compute pipeline\n\n      const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);\n      let pipeline = this.caches.get(cacheKey);\n      if (pipeline === undefined) {\n        if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);\n        pipeline = this._getComputePipeline(computeNode, stageCompute, cacheKey, bindings);\n      }\n\n      // keep track of all used times\n\n      pipeline.usedTimes++;\n      stageCompute.usedTimes++;\n\n      //\n\n      data.version = computeNode.version;\n      data.pipeline = pipeline;\n    }\n    return data.pipeline;\n  }\n  getForRender(renderObject) {\n    let promises = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const {\n      backend\n    } = this;\n    const data = this.get(renderObject);\n    if (this._needsRenderUpdate(renderObject)) {\n      const previousPipeline = data.pipeline;\n      if (previousPipeline) {\n        previousPipeline.usedTimes--;\n        previousPipeline.vertexProgram.usedTimes--;\n        previousPipeline.fragmentProgram.usedTimes--;\n      }\n\n      // get shader\n\n      const nodeBuilderState = renderObject.getNodeBuilderState();\n\n      // programmable stages\n\n      let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);\n      if (stageVertex === undefined) {\n        if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0) this._releaseProgram(previousPipeline.vertexProgram);\n        stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader, 'vertex');\n        this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);\n        backend.createProgram(stageVertex);\n      }\n      let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);\n      if (stageFragment === undefined) {\n        if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(previousPipeline.fragmentProgram);\n        stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, 'fragment');\n        this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);\n        backend.createProgram(stageFragment);\n      }\n\n      // determine render pipeline\n\n      const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);\n      let pipeline = this.caches.get(cacheKey);\n      if (pipeline === undefined) {\n        if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);\n        pipeline = this._getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises);\n      } else {\n        renderObject.pipeline = pipeline;\n      }\n\n      // keep track of all used times\n\n      pipeline.usedTimes++;\n      stageVertex.usedTimes++;\n      stageFragment.usedTimes++;\n\n      //\n\n      data.pipeline = pipeline;\n    }\n    return data.pipeline;\n  }\n  delete(object) {\n    const pipeline = this.get(object).pipeline;\n    if (pipeline) {\n      // pipeline\n\n      pipeline.usedTimes--;\n      if (pipeline.usedTimes === 0) this._releasePipeline(pipeline);\n\n      // programs\n\n      if (pipeline.isComputePipeline) {\n        pipeline.computeProgram.usedTimes--;\n        if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);\n      } else {\n        pipeline.fragmentProgram.usedTimes--;\n        pipeline.vertexProgram.usedTimes--;\n        if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);\n        if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);\n      }\n    }\n    return super.delete(object);\n  }\n  dispose() {\n    super.dispose();\n    this.caches = new Map();\n    this.programs = {\n      vertex: new Map(),\n      fragment: new Map(),\n      compute: new Map()\n    };\n  }\n  updateForRender(renderObject) {\n    this.getForRender(renderObject);\n  }\n  _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {\n    // check for existing pipeline\n\n    cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);\n    let pipeline = this.caches.get(cacheKey);\n    if (pipeline === undefined) {\n      pipeline = new ComputePipeline(cacheKey, stageCompute);\n      this.caches.set(cacheKey, pipeline);\n      this.backend.createComputePipeline(pipeline, bindings);\n    }\n    return pipeline;\n  }\n  _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises) {\n    // check for existing pipeline\n\n    cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);\n    let pipeline = this.caches.get(cacheKey);\n    if (pipeline === undefined) {\n      pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);\n      this.caches.set(cacheKey, pipeline);\n      renderObject.pipeline = pipeline;\n      this.backend.createRenderPipeline(renderObject, promises);\n    }\n    return pipeline;\n  }\n  _getComputeCacheKey(computeNode, stageCompute) {\n    return computeNode.id + ',' + stageCompute.id;\n  }\n  _getRenderCacheKey(renderObject, stageVertex, stageFragment) {\n    return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey(renderObject);\n  }\n  _releasePipeline(pipeline) {\n    this.caches.delete(pipeline.cacheKey);\n  }\n  _releaseProgram(program) {\n    const code = program.code;\n    const stage = program.stage;\n    this.programs[stage].delete(code);\n  }\n  _needsComputeUpdate(computeNode) {\n    const data = this.get(computeNode);\n    return data.pipeline === undefined || data.version !== computeNode.version;\n  }\n  _needsRenderUpdate(renderObject) {\n    const data = this.get(renderObject);\n    return data.pipeline === undefined || this.backend.needsRenderUpdate(renderObject);\n  }\n}\nclass Bindings extends DataMap {\n  constructor(backend, nodes, textures, attributes, pipelines, info) {\n    super();\n    this.backend = backend;\n    this.textures = textures;\n    this.pipelines = pipelines;\n    this.attributes = attributes;\n    this.nodes = nodes;\n    this.info = info;\n    this.pipelines.bindings = this; // assign bindings to pipelines\n  }\n  getForRender(renderObject) {\n    const bindings = renderObject.getBindings();\n    for (const bindGroup of bindings) {\n      const groupData = this.get(bindGroup);\n      if (groupData.bindGroup === undefined) {\n        // each object defines an array of bindings (ubos, textures, samplers etc.)\n\n        this._init(bindGroup);\n        this.backend.createBindings(bindGroup, bindings, 0);\n        groupData.bindGroup = bindGroup;\n      }\n    }\n    return bindings;\n  }\n  getForCompute(computeNode) {\n    const bindings = this.nodes.getForCompute(computeNode).bindings;\n    for (const bindGroup of bindings) {\n      const groupData = this.get(bindGroup);\n      if (groupData.bindGroup === undefined) {\n        this._init(bindGroup);\n        this.backend.createBindings(bindGroup, bindings, 0);\n        groupData.bindGroup = bindGroup;\n      }\n    }\n    return bindings;\n  }\n  updateForCompute(computeNode) {\n    this._updateBindings(this.getForCompute(computeNode));\n  }\n  updateForRender(renderObject) {\n    this._updateBindings(this.getForRender(renderObject));\n  }\n  _updateBindings(bindings) {\n    for (const bindGroup of bindings) {\n      this._update(bindGroup, bindings);\n    }\n  }\n  _init(bindGroup) {\n    for (const binding of bindGroup.bindings) {\n      if (binding.isSampledTexture) {\n        this.textures.updateTexture(binding.texture);\n      } else if (binding.isStorageBuffer) {\n        const attribute = binding.attribute;\n        const attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;\n        this.attributes.update(attribute, attributeType);\n      }\n    }\n  }\n  _update(bindGroup, bindings) {\n    const {\n      backend\n    } = this;\n    let needsBindingsUpdate = false;\n    let cacheBindings = true;\n    let cacheIndex = 0;\n    let version = 0;\n\n    // iterate over all bindings and check if buffer updates or a new binding group is required\n\n    for (const binding of bindGroup.bindings) {\n      if (binding.isNodeUniformsGroup) {\n        const updated = this.nodes.updateGroup(binding);\n        if (!updated) continue;\n      }\n      if (binding.isUniformBuffer) {\n        const updated = binding.update();\n        if (updated) {\n          backend.updateBinding(binding);\n        }\n      } else if (binding.isSampler) {\n        binding.update();\n      } else if (binding.isSampledTexture) {\n        const texturesTextureData = this.textures.get(binding.texture);\n        if (binding.needsBindingsUpdate(texturesTextureData.generation)) needsBindingsUpdate = true;\n        const updated = binding.update();\n        const texture = binding.texture;\n        if (updated) {\n          this.textures.updateTexture(texture);\n        }\n        const textureData = backend.get(texture);\n        if (textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture) {\n          cacheBindings = false;\n        } else {\n          cacheIndex = cacheIndex * 10 + texture.id;\n          version += texture.version;\n        }\n        if (backend.isWebGPUBackend === true && textureData.texture === undefined && textureData.externalTexture === undefined) {\n          // TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend\n          console.error('Bindings._update: binding should be available:', binding, updated, texture, binding.textureNode.value, needsBindingsUpdate);\n          this.textures.updateTexture(texture);\n          needsBindingsUpdate = true;\n        }\n        if (texture.isStorageTexture === true) {\n          const textureData = this.get(texture);\n          if (binding.store === true) {\n            textureData.needsMipmap = true;\n          } else if (this.textures.needsMipmaps(texture) && textureData.needsMipmap === true) {\n            this.backend.generateMipmaps(texture);\n            textureData.needsMipmap = false;\n          }\n        }\n      }\n    }\n    if (needsBindingsUpdate === true) {\n      this.backend.updateBindings(bindGroup, bindings, cacheBindings ? cacheIndex : 0, version);\n    }\n  }\n}\nfunction painterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.material.id !== b.material.id) {\n    return a.material.id - b.material.id;\n  } else if (a.z !== b.z) {\n    return a.z - b.z;\n  } else {\n    return a.id - b.id;\n  }\n}\nfunction reversePainterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.z !== b.z) {\n    return b.z - a.z;\n  } else {\n    return a.id - b.id;\n  }\n}\nfunction needsDoublePass(material) {\n  const hasTransmission = material.transmission > 0 || material.transmissionNode;\n  return hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;\n}\nclass RenderList {\n  constructor(lighting, scene, camera) {\n    this.renderItems = [];\n    this.renderItemsIndex = 0;\n    this.opaque = [];\n    this.transparentDoublePass = [];\n    this.transparent = [];\n    this.bundles = [];\n    this.lightsNode = lighting.getNode(scene, camera);\n    this.lightsArray = [];\n    this.scene = scene;\n    this.camera = camera;\n    this.occlusionQueryCount = 0;\n  }\n  begin() {\n    this.renderItemsIndex = 0;\n    this.opaque.length = 0;\n    this.transparentDoublePass.length = 0;\n    this.transparent.length = 0;\n    this.bundles.length = 0;\n    this.lightsArray.length = 0;\n    this.occlusionQueryCount = 0;\n    return this;\n  }\n  getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext) {\n    let renderItem = this.renderItems[this.renderItemsIndex];\n    if (renderItem === undefined) {\n      renderItem = {\n        id: object.id,\n        object: object,\n        geometry: geometry,\n        material: material,\n        groupOrder: groupOrder,\n        renderOrder: object.renderOrder,\n        z: z,\n        group: group,\n        clippingContext: clippingContext\n      };\n      this.renderItems[this.renderItemsIndex] = renderItem;\n    } else {\n      renderItem.id = object.id;\n      renderItem.object = object;\n      renderItem.geometry = geometry;\n      renderItem.material = material;\n      renderItem.groupOrder = groupOrder;\n      renderItem.renderOrder = object.renderOrder;\n      renderItem.z = z;\n      renderItem.group = group;\n      renderItem.clippingContext = clippingContext;\n    }\n    this.renderItemsIndex++;\n    return renderItem;\n  }\n  push(object, geometry, material, groupOrder, z, group, clippingContext) {\n    const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);\n    if (object.occlusionTest === true) this.occlusionQueryCount++;\n    if (material.transparent === true || material.transmission > 0) {\n      if (needsDoublePass(material)) this.transparentDoublePass.push(renderItem);\n      this.transparent.push(renderItem);\n    } else {\n      this.opaque.push(renderItem);\n    }\n  }\n  unshift(object, geometry, material, groupOrder, z, group, clippingContext) {\n    const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);\n    if (material.transparent === true || material.transmission > 0) {\n      if (needsDoublePass(material)) this.transparentDoublePass.unshift(renderItem);\n      this.transparent.unshift(renderItem);\n    } else {\n      this.opaque.unshift(renderItem);\n    }\n  }\n  pushBundle(group) {\n    this.bundles.push(group);\n  }\n  pushLight(light) {\n    this.lightsArray.push(light);\n  }\n  sort(customOpaqueSort, customTransparentSort) {\n    if (this.opaque.length > 1) this.opaque.sort(customOpaqueSort || painterSortStable);\n    if (this.transparentDoublePass.length > 1) this.transparentDoublePass.sort(customTransparentSort || reversePainterSortStable);\n    if (this.transparent.length > 1) this.transparent.sort(customTransparentSort || reversePainterSortStable);\n  }\n  finish() {\n    // update lights\n\n    this.lightsNode.setLights(this.lightsArray);\n\n    // Clear references from inactive renderItems in the list\n\n    for (let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i++) {\n      const renderItem = this.renderItems[i];\n      if (renderItem.id === null) break;\n      renderItem.id = null;\n      renderItem.object = null;\n      renderItem.geometry = null;\n      renderItem.material = null;\n      renderItem.groupOrder = null;\n      renderItem.renderOrder = null;\n      renderItem.z = null;\n      renderItem.group = null;\n      renderItem.clippingContext = null;\n    }\n  }\n}\nclass RenderLists {\n  constructor(lighting) {\n    this.lighting = lighting;\n    this.lists = new ChainMap();\n  }\n  get(scene, camera) {\n    const lists = this.lists;\n    const keys = [scene, camera];\n    let list = lists.get(keys);\n    if (list === undefined) {\n      list = new RenderList(this.lighting, scene, camera);\n      lists.set(keys, list);\n    }\n    return list;\n  }\n  dispose() {\n    this.lists = new ChainMap();\n  }\n}\nlet id$1 = 0;\nclass RenderContext {\n  constructor() {\n    this.id = id$1++;\n    this.color = true;\n    this.clearColor = true;\n    this.clearColorValue = {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 1\n    };\n    this.depth = true;\n    this.clearDepth = true;\n    this.clearDepthValue = 1;\n    this.stencil = false;\n    this.clearStencil = true;\n    this.clearStencilValue = 1;\n    this.viewport = false;\n    this.viewportValue = new Vector4();\n    this.scissor = false;\n    this.scissorValue = new Vector4();\n    this.textures = null;\n    this.depthTexture = null;\n    this.activeCubeFace = 0;\n    this.sampleCount = 1;\n    this.width = 0;\n    this.height = 0;\n    this.isRenderContext = true;\n  }\n  getCacheKey() {\n    return getCacheKey(this);\n  }\n}\nfunction getCacheKey(renderContext) {\n  const {\n    textures,\n    activeCubeFace\n  } = renderContext;\n  const values = [activeCubeFace];\n  for (const texture of textures) {\n    values.push(texture.id);\n  }\n  return hashArray(values);\n}\nclass RenderContexts {\n  constructor() {\n    this.chainMaps = {};\n  }\n  get(scene, camera) {\n    let renderTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    const chainKey = [scene, camera];\n    let attachmentState;\n    if (renderTarget === null) {\n      attachmentState = 'default';\n    } else {\n      const format = renderTarget.texture.format;\n      const count = renderTarget.textures.length;\n      attachmentState = `${count}:${format}:${renderTarget.samples}:${renderTarget.depthBuffer}:${renderTarget.stencilBuffer}`;\n    }\n    const chainMap = this.getChainMap(attachmentState);\n    let renderState = chainMap.get(chainKey);\n    if (renderState === undefined) {\n      renderState = new RenderContext();\n      chainMap.set(chainKey, renderState);\n    }\n    if (renderTarget !== null) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n    return renderState;\n  }\n  getChainMap(attachmentState) {\n    return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());\n  }\n  dispose() {\n    this.chainMaps = {};\n  }\n}\nconst _size$3 = /*@__PURE__*/new Vector3();\nclass Textures extends DataMap {\n  constructor(renderer, backend, info) {\n    super();\n    this.renderer = renderer;\n    this.backend = backend;\n    this.info = info;\n  }\n  updateRenderTarget(renderTarget) {\n    let activeMipmapLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const renderTargetData = this.get(renderTarget);\n    const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n    const depthTextureMips = renderTargetData.depthTextureMips || (renderTargetData.depthTextureMips = {});\n    const textures = renderTarget.textures;\n    const size = this.getSize(textures[0]);\n    const mipWidth = size.width >> activeMipmapLevel;\n    const mipHeight = size.height >> activeMipmapLevel;\n    let depthTexture = renderTarget.depthTexture || depthTextureMips[activeMipmapLevel];\n    const useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;\n    let textureNeedsUpdate = false;\n    if (depthTexture === undefined && useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;\n      depthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType\n      depthTexture.image.width = mipWidth;\n      depthTexture.image.height = mipHeight;\n      depthTextureMips[activeMipmapLevel] = depthTexture;\n    }\n    if (renderTargetData.width !== size.width || size.height !== renderTargetData.height) {\n      textureNeedsUpdate = true;\n      if (depthTexture) {\n        depthTexture.needsUpdate = true;\n        depthTexture.image.width = mipWidth;\n        depthTexture.image.height = mipHeight;\n      }\n    }\n    renderTargetData.width = size.width;\n    renderTargetData.height = size.height;\n    renderTargetData.textures = textures;\n    renderTargetData.depthTexture = depthTexture || null;\n    renderTargetData.depth = renderTarget.depthBuffer;\n    renderTargetData.stencil = renderTarget.stencilBuffer;\n    renderTargetData.renderTarget = renderTarget;\n    if (renderTargetData.sampleCount !== sampleCount) {\n      textureNeedsUpdate = true;\n      if (depthTexture) {\n        depthTexture.needsUpdate = true;\n      }\n      renderTargetData.sampleCount = sampleCount;\n    }\n\n    //\n\n    const options = {\n      sampleCount\n    };\n    for (let i = 0; i < textures.length; i++) {\n      const texture = textures[i];\n      if (textureNeedsUpdate) texture.needsUpdate = true;\n      this.updateTexture(texture, options);\n    }\n    if (depthTexture) {\n      this.updateTexture(depthTexture, options);\n    }\n\n    // dispose handler\n\n    if (renderTargetData.initialized !== true) {\n      renderTargetData.initialized = true;\n\n      // dispose\n\n      const onDispose = () => {\n        renderTarget.removeEventListener('dispose', onDispose);\n        for (let i = 0; i < textures.length; i++) {\n          this._destroyTexture(textures[i]);\n        }\n        if (depthTexture) {\n          this._destroyTexture(depthTexture);\n        }\n        this.delete(renderTarget);\n      };\n      renderTarget.addEventListener('dispose', onDispose);\n    }\n  }\n  updateTexture(texture) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const textureData = this.get(texture);\n    if (textureData.initialized === true && textureData.version === texture.version) return;\n    const isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;\n    const backend = this.backend;\n    if (isRenderTarget && textureData.initialized === true) {\n      // it's an update\n\n      backend.destroySampler(texture);\n      backend.destroyTexture(texture);\n    }\n\n    //\n\n    if (texture.isFramebufferTexture) {\n      const renderTarget = this.renderer.getRenderTarget();\n      if (renderTarget) {\n        texture.type = renderTarget.texture.type;\n      } else {\n        texture.type = UnsignedByteType;\n      }\n    }\n\n    //\n\n    const {\n      width,\n      height,\n      depth\n    } = this.getSize(texture);\n    options.width = width;\n    options.height = height;\n    options.depth = depth;\n    options.needsMipmaps = this.needsMipmaps(texture);\n    options.levels = options.needsMipmaps ? this.getMipLevels(texture, width, height) : 1;\n\n    //\n\n    if (isRenderTarget || texture.isStorageTexture === true) {\n      backend.createSampler(texture);\n      backend.createTexture(texture, options);\n      textureData.generation = texture.version;\n    } else {\n      const needsCreate = textureData.initialized !== true;\n      if (needsCreate) backend.createSampler(texture);\n      if (texture.version > 0) {\n        const image = texture.image;\n        if (image === undefined) {\n          console.warn('THREE.Renderer: Texture marked for update but image is undefined.');\n        } else if (image.complete === false) {\n          console.warn('THREE.Renderer: Texture marked for update but image is incomplete.');\n        } else {\n          if (texture.images) {\n            const images = [];\n            for (const image of texture.images) {\n              images.push(image);\n            }\n            options.images = images;\n          } else {\n            options.image = image;\n          }\n          if (textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true) {\n            backend.createTexture(texture, options);\n            textureData.isDefaultTexture = false;\n            textureData.generation = texture.version;\n          }\n          if (texture.source.dataReady === true) backend.updateTexture(texture, options);\n          if (options.needsMipmaps && texture.mipmaps.length === 0) backend.generateMipmaps(texture);\n        }\n      } else {\n        // async update\n\n        backend.createDefaultTexture(texture);\n        textureData.isDefaultTexture = true;\n        textureData.generation = texture.version;\n      }\n    }\n\n    // dispose handler\n\n    if (textureData.initialized !== true) {\n      textureData.initialized = true;\n      textureData.generation = texture.version;\n\n      //\n\n      this.info.memory.textures++;\n\n      // dispose\n\n      const onDispose = () => {\n        texture.removeEventListener('dispose', onDispose);\n        this._destroyTexture(texture);\n        this.info.memory.textures--;\n      };\n      texture.addEventListener('dispose', onDispose);\n    }\n\n    //\n\n    textureData.version = texture.version;\n  }\n  getSize(texture) {\n    let target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _size$3;\n    let image = texture.images ? texture.images[0] : texture.image;\n    if (image) {\n      if (image.image !== undefined) image = image.image;\n      target.width = image.width || 1;\n      target.height = image.height || 1;\n      target.depth = texture.isCubeTexture ? 6 : image.depth || 1;\n    } else {\n      target.width = target.height = target.depth = 1;\n    }\n    return target;\n  }\n  getMipLevels(texture, width, height) {\n    let mipLevelCount;\n    if (texture.isCompressedTexture) {\n      if (texture.mipmaps) {\n        mipLevelCount = texture.mipmaps.length;\n      } else {\n        mipLevelCount = 1;\n      }\n    } else {\n      mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;\n    }\n    return mipLevelCount;\n  }\n  needsMipmaps(texture) {\n    return this.isEnvironmentTexture(texture) || texture.isCompressedTexture === true || texture.generateMipmaps;\n  }\n  isEnvironmentTexture(texture) {\n    const mapping = texture.mapping;\n    return mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping || mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;\n  }\n  _destroyTexture(texture) {\n    this.backend.destroySampler(texture);\n    this.backend.destroyTexture(texture);\n    this.delete(texture);\n  }\n}\nclass Color4 extends Color {\n  constructor(r, g, b) {\n    let a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    super(r, g, b);\n    this.a = a;\n  }\n  set(r, g, b) {\n    let a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    this.a = a;\n    return super.set(r, g, b);\n  }\n  copy(color) {\n    if (color.a !== undefined) this.a = color.a;\n    return super.copy(color);\n  }\n  clone() {\n    return new this.constructor(this.r, this.g, this.b, this.a);\n  }\n}\nclass ParameterNode extends PropertyNode {\n  static get type() {\n    return 'ParameterNode';\n  }\n  constructor(nodeType) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(nodeType, name);\n    this.isParameterNode = true;\n  }\n  getHash() {\n    return this.uuid;\n  }\n  generate() {\n    return this.name;\n  }\n}\nconst parameter = (type, name) => nodeObject(new ParameterNode(type, name));\nclass StackNode extends Node {\n  static get type() {\n    return 'StackNode';\n  }\n  constructor() {\n    let parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this.nodes = [];\n    this.outputNode = null;\n    this.parent = parent;\n    this._currentCond = null;\n    this.isStackNode = true;\n  }\n  getNodeType(builder) {\n    return this.outputNode ? this.outputNode.getNodeType(builder) : 'void';\n  }\n  add(node) {\n    this.nodes.push(node);\n    return this;\n  }\n  If(boolNode, method) {\n    const methodNode = new ShaderNode(method);\n    this._currentCond = select(boolNode, methodNode);\n    return this.add(this._currentCond);\n  }\n  ElseIf(boolNode, method) {\n    const methodNode = new ShaderNode(method);\n    const ifNode = select(boolNode, methodNode);\n    this._currentCond.elseNode = ifNode;\n    this._currentCond = ifNode;\n    return this;\n  }\n  Else(method) {\n    this._currentCond.elseNode = new ShaderNode(method);\n    return this;\n  }\n  build(builder) {\n    const previousStack = getCurrentStack();\n    setCurrentStack(this);\n    for (const node of this.nodes) {\n      node.build(builder, 'void');\n    }\n    setCurrentStack(previousStack);\n    for (var _len18 = arguments.length, params = new Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {\n      params[_key18 - 1] = arguments[_key18];\n    }\n    return this.outputNode ? this.outputNode.build(builder, ...params) : super.build(builder, ...params);\n  }\n\n  //\n\n  else() {\n    // @deprecated, r168\n\n    console.warn('TSL.StackNode: .else() has been renamed to .Else().');\n    return this.Else(...arguments);\n  }\n  elseif() {\n    // @deprecated, r168\n\n    console.warn('TSL.StackNode: .elseif() has been renamed to .ElseIf().');\n    return this.ElseIf(...arguments);\n  }\n}\nconst stack = /*@__PURE__*/nodeProxy(StackNode);\nclass StructTypeNode extends Node {\n  static get type() {\n    return 'StructTypeNode';\n  }\n  constructor(types) {\n    super();\n    this.types = types;\n    this.isStructTypeNode = true;\n  }\n  getMemberTypes() {\n    return this.types;\n  }\n}\nclass OutputStructNode extends Node {\n  static get type() {\n    return 'OutputStructNode';\n  }\n  constructor() {\n    super();\n    for (var _len19 = arguments.length, members = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n      members[_key19] = arguments[_key19];\n    }\n    this.members = members;\n    this.isOutputStructNode = true;\n  }\n  setup(builder) {\n    super.setup(builder);\n    const members = this.members;\n    const types = [];\n    for (let i = 0; i < members.length; i++) {\n      types.push(members[i].getNodeType(builder));\n    }\n    this.nodeType = builder.getStructTypeFromNode(new StructTypeNode(types)).name;\n  }\n  generate(builder, output) {\n    const propertyName = builder.getOutputStructName();\n    const members = this.members;\n    const structPrefix = propertyName !== '' ? propertyName + '.' : '';\n    for (let i = 0; i < members.length; i++) {\n      const snippet = members[i].build(builder, output);\n      builder.addLineFlowCode(`${structPrefix}m${i} = ${snippet}`, this);\n    }\n    return propertyName;\n  }\n}\nconst outputStruct = /*@__PURE__*/nodeProxy(OutputStructNode);\nfunction getTextureIndex(textures, name) {\n  for (let i = 0; i < textures.length; i++) {\n    if (textures[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\nclass MRTNode extends OutputStructNode {\n  static get type() {\n    return 'MRTNode';\n  }\n  constructor(outputNodes) {\n    super();\n    this.outputNodes = outputNodes;\n    this.isMRTNode = true;\n  }\n  has(name) {\n    return this.outputNodes[name] !== undefined;\n  }\n  get(name) {\n    return this.outputNodes[name];\n  }\n  merge(mrtNode) {\n    const outputs = {\n      ...this.outputNodes,\n      ...mrtNode.outputNodes\n    };\n    return mrt(outputs);\n  }\n  setup(builder) {\n    const outputNodes = this.outputNodes;\n    const mrt = builder.renderer.getRenderTarget();\n    const members = [];\n    const textures = mrt.textures;\n    for (const name in outputNodes) {\n      const index = getTextureIndex(textures, name);\n      members[index] = vec4(outputNodes[name]);\n    }\n    this.members = members;\n    return super.setup(builder);\n  }\n}\nconst mrt = /*@__PURE__*/nodeProxy(MRTNode);\nconst hash = /*@__PURE__*/Fn(_ref95 => {\n  let [seed] = _ref95;\n  // Taken from https://www.shadertoy.com/view/XlGcRh, originally from pcg-random.org\n\n  const state = seed.toUint().mul(747796405).add(2891336453);\n  const word = state.shiftRight(state.shiftRight(28).add(4)).bitXor(state).mul(277803737);\n  const result = word.shiftRight(22).bitXor(word);\n  return result.toFloat().mul(1 / 2 ** 32); // Convert to range [0, 1)\n});\n\n// remapping functions https://iquilezles.org/articles/functions/\nconst parabola = (x, k) => pow(mul(4.0, x.mul(sub(1.0, x))), k);\nconst gain = (x, k) => x.lessThan(0.5) ? parabola(x.mul(2.0), k).div(2.0) : sub(1.0, parabola(mul(sub(1.0, x), 2.0), k).div(2.0));\nconst pcurve = (x, a, b) => pow(div(pow(x, a), add(pow(x, a), pow(sub(1.0, x), b))), 1.0 / a);\nconst sinc = (x, k) => sin(PI.mul(k.mul(x).sub(1.0))).div(PI.mul(k.mul(x).sub(1.0)));\n\n// https://github.com/cabbibo/glsl-tri-noise-3d\n\nconst tri = /*@__PURE__*/Fn(_ref96 => {\n  let [x] = _ref96;\n  return x.fract().sub(.5).abs();\n}).setLayout({\n  name: 'tri',\n  type: 'float',\n  inputs: [{\n    name: 'x',\n    type: 'float'\n  }]\n});\nconst tri3 = /*@__PURE__*/Fn(_ref97 => {\n  let [p] = _ref97;\n  return vec3(tri(p.z.add(tri(p.y.mul(1.)))), tri(p.z.add(tri(p.x.mul(1.)))), tri(p.y.add(tri(p.x.mul(1.)))));\n}).setLayout({\n  name: 'tri3',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\nconst triNoise3D = /*@__PURE__*/Fn(_ref98 => {\n  let [p_immutable, spd, time] = _ref98;\n  const p = vec3(p_immutable).toVar();\n  const z = float(1.4).toVar();\n  const rz = float(0.0).toVar();\n  const bp = vec3(p).toVar();\n  Loop({\n    start: float(0.0),\n    end: float(3.0),\n    type: 'float',\n    condition: '<='\n  }, () => {\n    const dg = vec3(tri3(bp.mul(2.0))).toVar();\n    p.addAssign(dg.add(time.mul(float(0.1).mul(spd))));\n    bp.mulAssign(1.8);\n    z.mulAssign(1.5);\n    p.mulAssign(1.2);\n    const t = float(tri(p.z.add(tri(p.x.add(tri(p.y)))))).toVar();\n    rz.addAssign(t.div(z));\n    bp.addAssign(0.14);\n  });\n  return rz;\n}).setLayout({\n  name: 'triNoise3D',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'spd',\n    type: 'float'\n  }, {\n    name: 'time',\n    type: 'float'\n  }]\n});\nclass FunctionOverloadingNode extends Node {\n  static get type() {\n    return 'FunctionOverloadingNode';\n  }\n  constructor() {\n    let functionNodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    super();\n    this.functionNodes = functionNodes;\n    for (var _len20 = arguments.length, parametersNodes = new Array(_len20 > 1 ? _len20 - 1 : 0), _key20 = 1; _key20 < _len20; _key20++) {\n      parametersNodes[_key20 - 1] = arguments[_key20];\n    }\n    this.parametersNodes = parametersNodes;\n    this._candidateFnCall = null;\n    this.global = true;\n  }\n  getNodeType() {\n    return this.functionNodes[0].shaderNode.layout.type;\n  }\n  setup(builder) {\n    const params = this.parametersNodes;\n    let candidateFnCall = this._candidateFnCall;\n    if (candidateFnCall === null) {\n      let candidateFn = null;\n      let candidateScore = -1;\n      for (const functionNode of this.functionNodes) {\n        const shaderNode = functionNode.shaderNode;\n        const layout = shaderNode.layout;\n        if (layout === null) {\n          throw new Error('FunctionOverloadingNode: FunctionNode must be a layout.');\n        }\n        const inputs = layout.inputs;\n        if (params.length === inputs.length) {\n          let score = 0;\n          for (let i = 0; i < params.length; i++) {\n            const param = params[i];\n            const input = inputs[i];\n            if (param.getNodeType(builder) === input.type) {\n              score++;\n            } else {\n              score = 0;\n            }\n          }\n          if (score > candidateScore) {\n            candidateFn = functionNode;\n            candidateScore = score;\n          }\n        }\n      }\n      this._candidateFnCall = candidateFnCall = candidateFn(...params);\n    }\n    return candidateFnCall;\n  }\n}\nconst overloadingBaseFn = /*@__PURE__*/nodeProxy(FunctionOverloadingNode);\nconst overloadingFn = functionNodes => function () {\n  for (var _len21 = arguments.length, params = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n    params[_key21] = arguments[_key21];\n  }\n  return overloadingBaseFn(functionNodes, ...params);\n};\nconst time = /*@__PURE__*/uniform(0).setGroup(renderGroup).onRenderUpdate(frame => frame.time);\nconst deltaTime = /*@__PURE__*/uniform(0).setGroup(renderGroup).onRenderUpdate(frame => frame.deltaTime);\nconst frameId = /*@__PURE__*/uniform(0, 'uint').setGroup(renderGroup).onRenderUpdate(frame => frame.frameId);\n\n// Deprecated\n\nconst timerLocal = function () {\n  let timeScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  // @deprecated, r170\n\n  console.warn('TSL: timerLocal() is deprecated. Use \"time\" instead.');\n  return time.mul(timeScale);\n};\nconst timerGlobal = function () {\n  let timeScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  // @deprecated, r170\n\n  console.warn('TSL: timerGlobal() is deprecated. Use \"time\" instead.');\n  return time.mul(timeScale);\n};\nconst timerDelta = function () {\n  let timeScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  // @deprecated, r170\n\n  console.warn('TSL: timerDelta() is deprecated. Use \"deltaTime\" instead.');\n  return deltaTime.mul(timeScale);\n};\nconst oscSine = function () {\n  let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : time;\n  return t.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5);\n};\nconst oscSquare = function () {\n  let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : time;\n  return t.fract().round();\n};\nconst oscTriangle = function () {\n  let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : time;\n  return t.add(0.5).fract().mul(2).sub(1).abs();\n};\nconst oscSawtooth = function () {\n  let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : time;\n  return t.fract();\n};\nconst rotateUV = /*@__PURE__*/Fn(_ref99 => {\n  let [uv, rotation, center = vec2(0.5)] = _ref99;\n  return rotate(uv.sub(center), rotation).add(center);\n});\nconst spherizeUV = /*@__PURE__*/Fn(_ref100 => {\n  let [uv, strength, center = vec2(0.5)] = _ref100;\n  const delta = uv.sub(center);\n  const delta2 = delta.dot(delta);\n  const delta4 = delta2.mul(delta2);\n  const deltaOffset = delta4.mul(strength);\n  return uv.add(delta.mul(deltaOffset));\n});\nconst billboarding = /*@__PURE__*/Fn(_ref101 => {\n  let {\n    position = null,\n    horizontal = true,\n    vertical = false\n  } = _ref101;\n  let worldMatrix;\n  if (position !== null) {\n    worldMatrix = modelWorldMatrix.toVar();\n    worldMatrix[3][0] = position.x;\n    worldMatrix[3][1] = position.y;\n    worldMatrix[3][2] = position.z;\n  } else {\n    worldMatrix = modelWorldMatrix;\n  }\n  const modelViewMatrix = cameraViewMatrix.mul(worldMatrix);\n  if (defined(horizontal)) {\n    modelViewMatrix[0][0] = modelWorldMatrix[0].length();\n    modelViewMatrix[0][1] = 0;\n    modelViewMatrix[0][2] = 0;\n  }\n  if (defined(vertical)) {\n    modelViewMatrix[1][0] = 0;\n    modelViewMatrix[1][1] = modelWorldMatrix[1].length();\n    modelViewMatrix[1][2] = 0;\n  }\n  modelViewMatrix[2][0] = 0;\n  modelViewMatrix[2][1] = 0;\n  modelViewMatrix[2][2] = 1;\n  return cameraProjectionMatrix.mul(modelViewMatrix).mul(positionLocal);\n});\nconst viewportSafeUV = /*@__PURE__*/Fn(_ref102 => {\n  let [uv = null] = _ref102;\n  const depth = linearDepth();\n  const depthDiff = linearDepth(viewportDepthTexture(uv)).sub(depth);\n  const finalUV = depthDiff.lessThan(0).select(screenUV, uv);\n  return finalUV;\n});\nclass SpriteSheetUVNode extends Node {\n  static get type() {\n    return 'SpriteSheetUVNode';\n  }\n  constructor(countNode) {\n    let uvNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : uv();\n    let frameNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : float(0);\n    super('vec2');\n    this.countNode = countNode;\n    this.uvNode = uvNode;\n    this.frameNode = frameNode;\n  }\n  setup() {\n    const {\n      frameNode,\n      uvNode,\n      countNode\n    } = this;\n    const {\n      width,\n      height\n    } = countNode;\n    const frameNum = frameNode.mod(width.mul(height)).floor();\n    const column = frameNum.mod(width);\n    const row = height.sub(frameNum.add(1).div(width).ceil());\n    const scale = countNode.reciprocal();\n    const uvFrameOffset = vec2(column, row);\n    return uvNode.add(uvFrameOffset).mul(scale);\n  }\n}\nconst spritesheetUV = /*@__PURE__*/nodeProxy(SpriteSheetUVNode);\nclass TriplanarTexturesNode extends Node {\n  static get type() {\n    return 'TriplanarTexturesNode';\n  }\n  constructor(textureXNode) {\n    let textureYNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let textureZNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let scaleNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : float(1);\n    let positionNode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : positionLocal;\n    let normalNode = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : normalLocal;\n    super('vec4');\n    this.textureXNode = textureXNode;\n    this.textureYNode = textureYNode;\n    this.textureZNode = textureZNode;\n    this.scaleNode = scaleNode;\n    this.positionNode = positionNode;\n    this.normalNode = normalNode;\n  }\n  setup() {\n    const {\n      textureXNode,\n      textureYNode,\n      textureZNode,\n      scaleNode,\n      positionNode,\n      normalNode\n    } = this;\n\n    // Ref: https://github.com/keijiro/StandardTriplanar\n\n    // Blending factor of triplanar mapping\n    let bf = normalNode.abs().normalize();\n    bf = bf.div(bf.dot(vec3(1.0)));\n\n    // Triplanar mapping\n    const tx = positionNode.yz.mul(scaleNode);\n    const ty = positionNode.zx.mul(scaleNode);\n    const tz = positionNode.xy.mul(scaleNode);\n\n    // Base color\n    const textureX = textureXNode.value;\n    const textureY = textureYNode !== null ? textureYNode.value : textureX;\n    const textureZ = textureZNode !== null ? textureZNode.value : textureX;\n    const cx = texture(textureX, tx).mul(bf.x);\n    const cy = texture(textureY, ty).mul(bf.y);\n    const cz = texture(textureZ, tz).mul(bf.z);\n    return add(cx, cy, cz);\n  }\n}\nconst triplanarTextures = /*@__PURE__*/nodeProxy(TriplanarTexturesNode);\nconst triplanarTexture = function () {\n  return triplanarTextures(...arguments);\n};\nconst _reflectorPlane = new Plane();\nconst _normal = new Vector3();\nconst _reflectorWorldPosition = new Vector3();\nconst _cameraWorldPosition = new Vector3();\nconst _rotationMatrix = new Matrix4();\nconst _lookAtPosition = new Vector3(0, 0, -1);\nconst clipPlane = new Vector4();\nconst _view = new Vector3();\nconst _target = new Vector3();\nconst _q = new Vector4();\nconst _size$2 = new Vector2();\nconst _defaultRT = new RenderTarget();\nconst _defaultUV = screenUV.flipX();\n_defaultRT.depthTexture = new DepthTexture(1, 1);\nlet _inReflector = false;\nclass ReflectorNode extends TextureNode {\n  static get type() {\n    return 'ReflectorNode';\n  }\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters.defaultTexture || _defaultRT.texture, _defaultUV);\n    this._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode(this, parameters);\n    this._depthNode = null;\n    this.setUpdateMatrix(false);\n  }\n  get reflector() {\n    return this._reflectorBaseNode;\n  }\n  get target() {\n    return this._reflectorBaseNode.target;\n  }\n  getDepthNode() {\n    if (this._depthNode === null) {\n      if (this._reflectorBaseNode.depth !== true) {\n        throw new Error('THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ');\n      }\n      this._depthNode = nodeObject(new ReflectorNode({\n        defaultTexture: _defaultRT.depthTexture,\n        reflector: this._reflectorBaseNode\n      }));\n    }\n    return this._depthNode;\n  }\n  setup(builder) {\n    // ignore if used in post-processing\n    if (!builder.object.isQuadMesh) this._reflectorBaseNode.build(builder);\n    return super.setup(builder);\n  }\n  clone() {\n    const texture = new this.constructor(this.reflectorNode);\n    texture._reflectorBaseNode = this._reflectorBaseNode;\n    return texture;\n  }\n}\nclass ReflectorBaseNode extends Node {\n  static get type() {\n    return 'ReflectorBaseNode';\n  }\n  constructor(textureNode) {\n    let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    const {\n      target = new Object3D(),\n      resolution = 1,\n      generateMipmaps = false,\n      bounces = true,\n      depth = false\n    } = parameters;\n\n    //\n\n    this.textureNode = textureNode;\n    this.target = target;\n    this.resolution = resolution;\n    this.generateMipmaps = generateMipmaps;\n    this.bounces = bounces;\n    this.depth = depth;\n    this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n    this.virtualCameras = new WeakMap();\n    this.renderTargets = new WeakMap();\n  }\n  _updateResolution(renderTarget, renderer) {\n    const resolution = this.resolution;\n    renderer.getDrawingBufferSize(_size$2);\n    renderTarget.setSize(Math.round(_size$2.width * resolution), Math.round(_size$2.height * resolution));\n  }\n  setup(builder) {\n    this._updateResolution(_defaultRT, builder.renderer);\n    return super.setup(builder);\n  }\n  getVirtualCamera(camera) {\n    let virtualCamera = this.virtualCameras.get(camera);\n    if (virtualCamera === undefined) {\n      virtualCamera = camera.clone();\n      this.virtualCameras.set(camera, virtualCamera);\n    }\n    return virtualCamera;\n  }\n  getRenderTarget(camera) {\n    let renderTarget = this.renderTargets.get(camera);\n    if (renderTarget === undefined) {\n      renderTarget = new RenderTarget(0, 0, {\n        type: HalfFloatType\n      });\n      if (this.generateMipmaps === true) {\n        renderTarget.texture.minFilter = LinearMipMapLinearFilter;\n        renderTarget.texture.generateMipmaps = true;\n      }\n      if (this.depth === true) {\n        renderTarget.depthTexture = new DepthTexture();\n      }\n      this.renderTargets.set(camera, renderTarget);\n    }\n    return renderTarget;\n  }\n  updateBefore(frame) {\n    if (this.bounces === false && _inReflector) return;\n    _inReflector = true;\n    const {\n      scene,\n      camera,\n      renderer,\n      material\n    } = frame;\n    const {\n      target\n    } = this;\n    const virtualCamera = this.getVirtualCamera(camera);\n    const renderTarget = this.getRenderTarget(virtualCamera);\n    renderer.getDrawingBufferSize(_size$2);\n    this._updateResolution(renderTarget, renderer);\n\n    //\n\n    _reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);\n    _cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    _rotationMatrix.extractRotation(target.matrixWorld);\n    _normal.set(0, 0, 1);\n    _normal.applyMatrix4(_rotationMatrix);\n    _view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);\n\n    // Avoid rendering when reflector is facing away\n\n    if (_view.dot(_normal) > 0) return;\n    _view.reflect(_normal).negate();\n    _view.add(_reflectorWorldPosition);\n    _rotationMatrix.extractRotation(camera.matrixWorld);\n    _lookAtPosition.set(0, 0, -1);\n    _lookAtPosition.applyMatrix4(_rotationMatrix);\n    _lookAtPosition.add(_cameraWorldPosition);\n    _target.subVectors(_reflectorWorldPosition, _lookAtPosition);\n    _target.reflect(_normal).negate();\n    _target.add(_reflectorWorldPosition);\n\n    //\n\n    virtualCamera.coordinateSystem = camera.coordinateSystem;\n    virtualCamera.position.copy(_view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(_rotationMatrix);\n    virtualCamera.up.reflect(_normal);\n    virtualCamera.lookAt(_target);\n    virtualCamera.near = camera.near;\n    virtualCamera.far = camera.far;\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n\n    // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n    _reflectorPlane.setFromNormalAndCoplanarPoint(_normal, _reflectorWorldPosition);\n    _reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(_reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant);\n    const projectionMatrix = virtualCamera.projectionMatrix;\n    _q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    _q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    _q.z = -1.0;\n    _q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n    // Calculate the scaled plane vector\n    clipPlane.multiplyScalar(1.0 / clipPlane.dot(_q));\n    const clipBias = 0;\n\n    // Replacing the third row of the projection matrix\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = renderer.coordinateSystem === WebGPUCoordinateSystem ? clipPlane.z - clipBias : clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w;\n\n    //\n\n    this.textureNode.value = renderTarget.texture;\n    if (this.depth === true) {\n      this.textureNode.getDepthNode().value = renderTarget.depthTexture;\n    }\n    material.visible = false;\n    const currentRenderTarget = renderer.getRenderTarget();\n    const currentMRT = renderer.getMRT();\n    renderer.setMRT(null);\n    renderer.setRenderTarget(renderTarget);\n    renderer.render(scene, virtualCamera);\n    renderer.setMRT(currentMRT);\n    renderer.setRenderTarget(currentRenderTarget);\n    material.visible = true;\n    _inReflector = false;\n  }\n}\nconst reflector = parameters => nodeObject(new ReflectorNode(parameters));\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = /*@__PURE__*/new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nclass QuadGeometry extends BufferGeometry {\n  constructor() {\n    let flipY = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    super();\n    const uv = flipY === false ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];\n    this.setAttribute('position', new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uv, 2));\n  }\n}\nconst _geometry = /*@__PURE__*/new QuadGeometry();\nclass QuadMesh extends Mesh {\n  constructor() {\n    let material = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(_geometry, material);\n    this.camera = _camera;\n    this.isQuadMesh = true;\n  }\n  renderAsync(renderer) {\n    return renderer.renderAsync(this, _camera);\n  }\n  render(renderer) {\n    renderer.render(this, _camera);\n  }\n}\nconst _size$1 = /*@__PURE__*/new Vector2();\nclass RTTNode extends TextureNode {\n  static get type() {\n    return 'RTTNode';\n  }\n  constructor(node) {\n    let width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n      type: HalfFloatType\n    };\n    const renderTarget = new RenderTarget(width, height, options);\n    super(renderTarget.texture, uv());\n    this.node = node;\n    this.width = width;\n    this.height = height;\n    this.renderTarget = renderTarget;\n    this.textureNeedsUpdate = true;\n    this.autoUpdate = true;\n    this.updateMap = new WeakMap();\n    this._rttNode = null;\n    this._quadMesh = new QuadMesh(new NodeMaterial());\n    this.updateBeforeType = NodeUpdateType.RENDER;\n  }\n  get autoSize() {\n    return this.width === null;\n  }\n  setup(builder) {\n    this._rttNode = this.node.context(builder.getSharedContext());\n    this._quadMesh.material.name = 'RTT';\n    this._quadMesh.material.needsUpdate = true;\n    return super.setup(builder);\n  }\n  setSize(width, height) {\n    this.width = width;\n    this.height = height;\n    const effectiveWidth = width * this.pixelRatio;\n    const effectiveHeight = height * this.pixelRatio;\n    this.renderTarget.setSize(effectiveWidth, effectiveHeight);\n    this.textureNeedsUpdate = true;\n  }\n  setPixelRatio(pixelRatio) {\n    this.pixelRatio = pixelRatio;\n    this.setSize(this.width, this.height);\n  }\n  updateBefore(_ref103) {\n    let {\n      renderer\n    } = _ref103;\n    if (this.textureNeedsUpdate === false && this.autoUpdate === false) return;\n    this.textureNeedsUpdate = false;\n\n    //\n\n    if (this.autoSize === true) {\n      this.pixelRatio = renderer.getPixelRatio();\n      const size = renderer.getSize(_size$1);\n      this.setSize(size.width, size.height);\n    }\n\n    //\n\n    this._quadMesh.material.fragmentNode = this._rttNode;\n\n    //\n\n    const currentRenderTarget = renderer.getRenderTarget();\n    renderer.setRenderTarget(this.renderTarget);\n    this._quadMesh.render(renderer);\n    renderer.setRenderTarget(currentRenderTarget);\n  }\n  clone() {\n    const newNode = new TextureNode(this.value, this.uvNode, this.levelNode);\n    newNode.sampler = this.sampler;\n    newNode.referenceNode = this;\n    return newNode;\n  }\n}\nconst rtt = function (node) {\n  for (var _len22 = arguments.length, params = new Array(_len22 > 1 ? _len22 - 1 : 0), _key22 = 1; _key22 < _len22; _key22++) {\n    params[_key22 - 1] = arguments[_key22];\n  }\n  return nodeObject(new RTTNode(nodeObject(node), ...params));\n};\nconst convertToTexture = function (node) {\n  if (node.isTextureNode) return node;\n  if (node.isPassNode) return node.getTextureNode();\n  for (var _len23 = arguments.length, params = new Array(_len23 > 1 ? _len23 - 1 : 0), _key23 = 1; _key23 < _len23; _key23++) {\n    params[_key23 - 1] = arguments[_key23];\n  }\n  return rtt(node, ...params);\n};\n\n/**\n* Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments\n* depth value and the camera's inverse projection matrix.\n*\n* @param {vec2} screenPosition - The fragment's screen position expressed as uv coordinates.\n* @param {float} depth - The fragment's depth value.\n* @param {mat4} projectionMatrixInverse - The camera's inverse projection matrix.\n* @return {vec3} The fragments position in view space.\n*/\nconst getViewPosition = /*@__PURE__*/Fn((_ref104, builder) => {\n  let [screenPosition, depth, projectionMatrixInverse] = _ref104;\n  let clipSpacePosition;\n  if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {\n    screenPosition = vec2(screenPosition.x, screenPosition.y.oneMinus()).mul(2.0).sub(1.0);\n    clipSpacePosition = vec4(vec3(screenPosition, depth), 1.0);\n  } else {\n    clipSpacePosition = vec4(vec3(screenPosition.x, screenPosition.y.oneMinus(), depth).mul(2.0).sub(1.0), 1.0);\n  }\n  const viewSpacePosition = vec4(projectionMatrixInverse.mul(clipSpacePosition));\n  return viewSpacePosition.xyz.div(viewSpacePosition.w);\n});\n\n/**\n* Computes a screen position expressed as uv coordinates based on a fragment's position in view space\n* and the camera's projection matrix\n*\n* @param {vec3} viewPosition - The fragments position in view space.\n* @param {mat4} projectionMatrix - The camera's projection matrix.\n* @return {vec2} The fragment's screen position expressed as uv coordinates.\n*/\nconst getScreenPosition = /*@__PURE__*/Fn(_ref105 => {\n  let [viewPosition, projectionMatrix] = _ref105;\n  const sampleClipPos = projectionMatrix.mul(vec4(viewPosition, 1.0));\n  const sampleUv = sampleClipPos.xy.div(sampleClipPos.w).mul(0.5).add(0.5).toVar();\n  return vec2(sampleUv.x, sampleUv.y.oneMinus());\n});\n\n/**\n* Computes a normal vector based on depth data. Can be used as a fallback when no normal render\n* target is available or if flat surface normals are required.\n*\n* @param {vec2} uv - The texture coordinate.\n* @param {DepthTexture} depthTexture - The depth texture.\n* @param {mat4} projectionMatrixInverse - The camera's inverse projection matrix.\n* @return {vec3} The computed normal vector.\n*/\nconst getNormalFromDepth = /*@__PURE__*/Fn(_ref106 => {\n  let [uv, depthTexture, projectionMatrixInverse] = _ref106;\n  const size = textureSize(textureLoad(depthTexture));\n  const p = ivec2(uv.mul(size)).toVar();\n  const c0 = textureLoad(depthTexture, p).toVar();\n  const l2 = textureLoad(depthTexture, p.sub(ivec2(2, 0))).toVar();\n  const l1 = textureLoad(depthTexture, p.sub(ivec2(1, 0))).toVar();\n  const r1 = textureLoad(depthTexture, p.add(ivec2(1, 0))).toVar();\n  const r2 = textureLoad(depthTexture, p.add(ivec2(2, 0))).toVar();\n  const b2 = textureLoad(depthTexture, p.add(ivec2(0, 2))).toVar();\n  const b1 = textureLoad(depthTexture, p.add(ivec2(0, 1))).toVar();\n  const t1 = textureLoad(depthTexture, p.sub(ivec2(0, 1))).toVar();\n  const t2 = textureLoad(depthTexture, p.sub(ivec2(0, 2))).toVar();\n  const dl = abs(sub(float(2).mul(l1).sub(l2), c0)).toVar();\n  const dr = abs(sub(float(2).mul(r1).sub(r2), c0)).toVar();\n  const db = abs(sub(float(2).mul(b1).sub(b2), c0)).toVar();\n  const dt = abs(sub(float(2).mul(t1).sub(t2), c0)).toVar();\n  const ce = getViewPosition(uv, c0, projectionMatrixInverse).toVar();\n  const dpdx = dl.lessThan(dr).select(ce.sub(getViewPosition(uv.sub(vec2(float(1).div(size.x), 0)), l1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv.add(vec2(float(1).div(size.x), 0)), r1, projectionMatrixInverse)));\n  const dpdy = db.lessThan(dt).select(ce.sub(getViewPosition(uv.add(vec2(0, float(1).div(size.y))), b1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv.sub(vec2(0, float(1).div(size.y))), t1, projectionMatrixInverse)));\n  return normalize(cross(dpdx, dpdy));\n});\nclass StorageInstancedBufferAttribute extends InstancedBufferAttribute {\n  constructor(array, itemSize) {\n    let typeClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Float32Array;\n    if (ArrayBuffer.isView(array) === false) array = new typeClass(array * itemSize);\n    super(array, itemSize);\n    this.isStorageInstancedBufferAttribute = true;\n  }\n}\nclass StorageBufferAttribute extends BufferAttribute {\n  constructor(array, itemSize) {\n    let typeClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Float32Array;\n    if (ArrayBuffer.isView(array) === false) array = new typeClass(array * itemSize);\n    super(array, itemSize);\n    this.isStorageBufferAttribute = true;\n  }\n}\nclass StorageArrayElementNode extends ArrayElementNode {\n  static get type() {\n    return 'StorageArrayElementNode';\n  }\n  constructor(storageBufferNode, indexNode) {\n    super(storageBufferNode, indexNode);\n    this.isStorageArrayElementNode = true;\n  }\n  set storageBufferNode(value) {\n    this.node = value;\n  }\n  get storageBufferNode() {\n    return this.node;\n  }\n  setup(builder) {\n    if (builder.isAvailable('storageBuffer') === false) {\n      if (this.node.isPBO === true) {\n        builder.setupPBO(this.node);\n      }\n    }\n    return super.setup(builder);\n  }\n  generate(builder, output) {\n    let snippet;\n    const isAssignContext = builder.context.assign;\n\n    //\n\n    if (builder.isAvailable('storageBuffer') === false) {\n      if (this.node.isPBO === true && isAssignContext !== true && (this.node.value.isInstancedBufferAttribute || builder.shaderStage !== 'compute')) {\n        snippet = builder.generatePBO(this);\n      } else {\n        snippet = this.node.build(builder);\n      }\n    } else {\n      snippet = super.generate(builder);\n    }\n    if (isAssignContext !== true) {\n      const type = this.getNodeType(builder);\n      snippet = builder.format(snippet, type, output);\n    }\n    return snippet;\n  }\n}\nconst storageElement = /*@__PURE__*/nodeProxy(StorageArrayElementNode);\nclass StorageBufferNode extends BufferNode {\n  static get type() {\n    return 'StorageBufferNode';\n  }\n  constructor(value) {\n    let bufferType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let bufferCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    if (bufferType === null && (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute)) {\n      bufferType = getTypeFromLength(value.itemSize);\n      bufferCount = value.count;\n    }\n    super(value, bufferType, bufferCount);\n    this.isStorageBufferNode = true;\n    this.access = NodeAccess.READ_WRITE;\n    this.isAtomic = false;\n    this.isPBO = false;\n    this.bufferCount = bufferCount;\n    this._attribute = null;\n    this._varying = null;\n    this.global = true;\n    if (value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true) {\n      // TOOD: Improve it, possibly adding a new property to the BufferAttribute to identify it as a storage buffer read-only attribute in Renderer\n\n      if (value.isInstancedBufferAttribute) value.isStorageInstancedBufferAttribute = true;else value.isStorageBufferAttribute = true;\n    }\n  }\n  getHash(builder) {\n    if (this.bufferCount === 0) {\n      let bufferData = builder.globalCache.getData(this.value);\n      if (bufferData === undefined) {\n        bufferData = {\n          node: this\n        };\n        builder.globalCache.setData(this.value, bufferData);\n      }\n      return bufferData.node.uuid;\n    }\n    return this.uuid;\n  }\n  getInputType(/*builder*/\n  ) {\n    return this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer';\n  }\n  element(indexNode) {\n    return storageElement(this, indexNode);\n  }\n  setPBO(value) {\n    this.isPBO = value;\n    return this;\n  }\n  getPBO() {\n    return this.isPBO;\n  }\n  setAccess(value) {\n    this.access = value;\n    return this;\n  }\n  toReadOnly() {\n    return this.setAccess(NodeAccess.READ_ONLY);\n  }\n  setAtomic(value) {\n    this.isAtomic = value;\n    return this;\n  }\n  toAtomic() {\n    return this.setAtomic(true);\n  }\n  getAttributeData() {\n    if (this._attribute === null) {\n      this._attribute = bufferAttribute(this.value);\n      this._varying = varying(this._attribute);\n    }\n    return {\n      attribute: this._attribute,\n      varying: this._varying\n    };\n  }\n  getNodeType(builder) {\n    if (builder.isAvailable('storageBuffer') || builder.isAvailable('indirectStorageBuffer')) {\n      return super.getNodeType(builder);\n    }\n    const {\n      attribute\n    } = this.getAttributeData();\n    return attribute.getNodeType(builder);\n  }\n  generate(builder) {\n    if (builder.isAvailable('storageBuffer') || builder.isAvailable('indirectStorageBuffer')) {\n      return super.generate(builder);\n    }\n    const {\n      attribute,\n      varying\n    } = this.getAttributeData();\n    const output = varying.build(builder);\n    builder.registerTransform(output, attribute);\n    return output;\n  }\n}\nconst storage = (value, type, count) => nodeObject(new StorageBufferNode(value, type, count));\nconst storageObject = (value, type, count) => {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"storageObject()\" is deprecated. Use \"storage().setPBO( true )\" instead.');\n  return storage(value, type, count).setPBO(true);\n};\nconst attributeArray = function (count) {\n  let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'float';\n  const itemSize = getLengthFromType(type);\n  const buffer = new StorageBufferAttribute(count, itemSize);\n  const node = storage(buffer, type, count);\n  return node;\n};\nconst instancedArray = function (count) {\n  let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'float';\n  const itemSize = getLengthFromType(type);\n  const buffer = new StorageInstancedBufferAttribute(count, itemSize);\n  const node = storage(buffer, type, count);\n  return node;\n};\nclass VertexColorNode extends AttributeNode {\n  static get type() {\n    return 'VertexColorNode';\n  }\n  constructor() {\n    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    super(null, 'vec4');\n    this.isVertexColorNode = true;\n    this.index = index;\n  }\n  getAttributeName(/*builder*/\n  ) {\n    const index = this.index;\n    return 'color' + (index > 0 ? index : '');\n  }\n  generate(builder) {\n    const attributeName = this.getAttributeName(builder);\n    const geometryAttribute = builder.hasGeometryAttribute(attributeName);\n    let result;\n    if (geometryAttribute === true) {\n      result = super.generate(builder);\n    } else {\n      // Vertex color fallback should be white\n      result = builder.generateConst(this.nodeType, new Vector4(1, 1, 1, 1));\n    }\n    return result;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.index = this.index;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.index = data.index;\n  }\n}\nconst vertexColor = function () {\n  for (var _len24 = arguments.length, params = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n    params[_key24] = arguments[_key24];\n  }\n  return nodeObject(new VertexColorNode(...params));\n};\nclass PointUVNode extends Node {\n  static get type() {\n    return 'PointUVNode';\n  }\n  constructor() {\n    super('vec2');\n    this.isPointUVNode = true;\n  }\n  generate(/*builder*/\n  ) {\n    return 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';\n  }\n}\nconst pointUV = /*@__PURE__*/nodeImmutable(PointUVNode);\nconst _e1 = /*@__PURE__*/new Euler();\nconst _m1 = /*@__PURE__*/new Matrix4();\nclass SceneNode extends Node {\n  static get type() {\n    return 'SceneNode';\n  }\n  constructor() {\n    let scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SceneNode.BACKGROUND_BLURRINESS;\n    let scene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super();\n    this.scope = scope;\n    this.scene = scene;\n  }\n  setup(builder) {\n    const scope = this.scope;\n    const scene = this.scene !== null ? this.scene : builder.scene;\n    let output;\n    if (scope === SceneNode.BACKGROUND_BLURRINESS) {\n      output = reference('backgroundBlurriness', 'float', scene);\n    } else if (scope === SceneNode.BACKGROUND_INTENSITY) {\n      output = reference('backgroundIntensity', 'float', scene);\n    } else if (scope === SceneNode.BACKGROUND_ROTATION) {\n      output = uniform('mat4').label('backgroundRotation').setGroup(renderGroup).onRenderUpdate(() => {\n        const background = scene.background;\n        if (background !== null && background.isTexture && background.mapping !== UVMapping) {\n          _e1.copy(scene.backgroundRotation);\n\n          // accommodate left-handed frame\n          _e1.x *= -1;\n          _e1.y *= -1;\n          _e1.z *= -1;\n          _m1.makeRotationFromEuler(_e1);\n        } else {\n          _m1.identity();\n        }\n        return _m1;\n      });\n    } else {\n      console.error('THREE.SceneNode: Unknown scope:', scope);\n    }\n    return output;\n  }\n}\nSceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';\nSceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';\nSceneNode.BACKGROUND_ROTATION = 'backgroundRotation';\nconst backgroundBlurriness = /*@__PURE__*/nodeImmutable(SceneNode, SceneNode.BACKGROUND_BLURRINESS);\nconst backgroundIntensity = /*@__PURE__*/nodeImmutable(SceneNode, SceneNode.BACKGROUND_INTENSITY);\nconst backgroundRotation = /*@__PURE__*/nodeImmutable(SceneNode, SceneNode.BACKGROUND_ROTATION);\nclass StorageTextureNode extends TextureNode {\n  static get type() {\n    return 'StorageTextureNode';\n  }\n  constructor(value, uvNode) {\n    let storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    super(value, uvNode);\n    this.storeNode = storeNode;\n    this.isStorageTextureNode = true;\n    this.access = NodeAccess.WRITE_ONLY;\n  }\n  getInputType(/*builder*/\n  ) {\n    return 'storageTexture';\n  }\n  setup(builder) {\n    super.setup(builder);\n    const properties = builder.getNodeProperties(this);\n    properties.storeNode = this.storeNode;\n  }\n  setAccess(value) {\n    this.access = value;\n    return this;\n  }\n  generate(builder, output) {\n    let snippet;\n    if (this.storeNode !== null) {\n      snippet = this.generateStore(builder);\n    } else {\n      snippet = super.generate(builder, output);\n    }\n    return snippet;\n  }\n  toReadWrite() {\n    return this.setAccess(NodeAccess.READ_WRITE);\n  }\n  toReadOnly() {\n    return this.setAccess(NodeAccess.READ_ONLY);\n  }\n  toWriteOnly() {\n    return this.setAccess(NodeAccess.WRITE_ONLY);\n  }\n  generateStore(builder) {\n    const properties = builder.getNodeProperties(this);\n    const {\n      uvNode,\n      storeNode\n    } = properties;\n    const textureProperty = super.generate(builder, 'property');\n    const uvSnippet = uvNode.build(builder, 'uvec2');\n    const storeSnippet = storeNode.build(builder, 'vec4');\n    const snippet = builder.generateTextureStore(builder, textureProperty, uvSnippet, storeSnippet);\n    builder.addLineFlowCode(snippet, this);\n  }\n}\nconst storageTexture = /*@__PURE__*/nodeProxy(StorageTextureNode);\nconst textureStore = (value, uvNode, storeNode) => {\n  const node = storageTexture(value, uvNode, storeNode);\n  if (storeNode !== null) node.append();\n  return node;\n};\nclass UserDataNode extends ReferenceNode {\n  static get type() {\n    return 'UserDataNode';\n  }\n  constructor(property, inputType) {\n    let userData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    super(property, inputType, userData);\n    this.userData = userData;\n  }\n  updateReference(state) {\n    this.reference = this.userData !== null ? this.userData : state.object.userData;\n    return this.reference;\n  }\n}\nconst userData = (name, inputType, userData) => nodeObject(new UserDataNode(name, inputType, userData));\nconst _objectData = new WeakMap();\nclass VelocityNode extends TempNode {\n  static get type() {\n    return 'VelocityNode';\n  }\n  constructor() {\n    super('vec2');\n    this.projectionMatrix = null;\n    this.updateType = NodeUpdateType.OBJECT;\n    this.updateAfterType = NodeUpdateType.OBJECT;\n    this.previousModelWorldMatrix = uniform(new Matrix4());\n    this.previousProjectionMatrix = uniform(new Matrix4()).setGroup(renderGroup);\n    this.previousCameraViewMatrix = uniform(new Matrix4());\n  }\n  setProjectionMatrix(projectionMatrix) {\n    this.projectionMatrix = projectionMatrix;\n  }\n  update(_ref107) {\n    let {\n      frameId,\n      camera,\n      object\n    } = _ref107;\n    const previousModelMatrix = getPreviousMatrix(object);\n    this.previousModelWorldMatrix.value.copy(previousModelMatrix);\n\n    //\n\n    const cameraData = getData(camera);\n    if (cameraData.frameId !== frameId) {\n      cameraData.frameId = frameId;\n      if (cameraData.previousProjectionMatrix === undefined) {\n        cameraData.previousProjectionMatrix = new Matrix4();\n        cameraData.previousCameraViewMatrix = new Matrix4();\n        cameraData.currentProjectionMatrix = new Matrix4();\n        cameraData.currentCameraViewMatrix = new Matrix4();\n        cameraData.previousProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);\n        cameraData.previousCameraViewMatrix.copy(camera.matrixWorldInverse);\n      } else {\n        cameraData.previousProjectionMatrix.copy(cameraData.currentProjectionMatrix);\n        cameraData.previousCameraViewMatrix.copy(cameraData.currentCameraViewMatrix);\n      }\n      cameraData.currentProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);\n      cameraData.currentCameraViewMatrix.copy(camera.matrixWorldInverse);\n      this.previousProjectionMatrix.value.copy(cameraData.previousProjectionMatrix);\n      this.previousCameraViewMatrix.value.copy(cameraData.previousCameraViewMatrix);\n    }\n  }\n  updateAfter(_ref108) {\n    let {\n      object\n    } = _ref108;\n    getPreviousMatrix(object).copy(object.matrixWorld);\n  }\n  setup(/*builder*/\n  ) {\n    const projectionMatrix = this.projectionMatrix === null ? cameraProjectionMatrix : uniform(this.projectionMatrix);\n    const previousModelViewMatrix = this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix);\n    const clipPositionCurrent = projectionMatrix.mul(modelViewMatrix).mul(positionLocal);\n    const clipPositionPrevious = this.previousProjectionMatrix.mul(previousModelViewMatrix).mul(positionPrevious);\n    const ndcPositionCurrent = clipPositionCurrent.xy.div(clipPositionCurrent.w);\n    const ndcPositionPrevious = clipPositionPrevious.xy.div(clipPositionPrevious.w);\n    const velocity = sub(ndcPositionCurrent, ndcPositionPrevious);\n    return velocity;\n  }\n}\nfunction getData(object) {\n  let objectData = _objectData.get(object);\n  if (objectData === undefined) {\n    objectData = {};\n    _objectData.set(object, objectData);\n  }\n  return objectData;\n}\nfunction getPreviousMatrix(object) {\n  let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const objectData = getData(object);\n  let matrix = objectData[index];\n  if (matrix === undefined) {\n    objectData[index] = matrix = new Matrix4();\n  }\n  return matrix;\n}\nconst velocity = /*@__PURE__*/nodeImmutable(VelocityNode);\nconst blendBurn = /*@__PURE__*/Fn(_ref109 => {\n  let [base, blend] = _ref109;\n  return min$1(1.0, base.oneMinus().div(blend)).oneMinus();\n}).setLayout({\n  name: 'blendBurn',\n  type: 'vec3',\n  inputs: [{\n    name: 'base',\n    type: 'vec3'\n  }, {\n    name: 'blend',\n    type: 'vec3'\n  }]\n});\nconst blendDodge = /*@__PURE__*/Fn(_ref110 => {\n  let [base, blend] = _ref110;\n  return min$1(base.div(blend.oneMinus()), 1.0);\n}).setLayout({\n  name: 'blendDodge',\n  type: 'vec3',\n  inputs: [{\n    name: 'base',\n    type: 'vec3'\n  }, {\n    name: 'blend',\n    type: 'vec3'\n  }]\n});\nconst blendScreen = /*@__PURE__*/Fn(_ref111 => {\n  let [base, blend] = _ref111;\n  return base.oneMinus().mul(blend.oneMinus()).oneMinus();\n}).setLayout({\n  name: 'blendScreen',\n  type: 'vec3',\n  inputs: [{\n    name: 'base',\n    type: 'vec3'\n  }, {\n    name: 'blend',\n    type: 'vec3'\n  }]\n});\nconst blendOverlay = /*@__PURE__*/Fn(_ref112 => {\n  let [base, blend] = _ref112;\n  return mix(base.mul(2.0).mul(blend), base.oneMinus().mul(2.0).mul(blend.oneMinus()).oneMinus(), step(0.5, base));\n}).setLayout({\n  name: 'blendOverlay',\n  type: 'vec3',\n  inputs: [{\n    name: 'base',\n    type: 'vec3'\n  }, {\n    name: 'blend',\n    type: 'vec3'\n  }]\n});\nconst blendColor = /*@__PURE__*/Fn(_ref113 => {\n  let [base, blend] = _ref113;\n  const outAlpha = blend.a.add(base.a.mul(blend.a.oneMinus()));\n  return vec4(blend.rgb.mul(blend.a).add(base.rgb.mul(base.a).mul(blend.a.oneMinus())).div(outAlpha), outAlpha);\n}).setLayout({\n  name: 'blendColor',\n  type: 'vec4',\n  inputs: [{\n    name: 'base',\n    type: 'vec4'\n  }, {\n    name: 'blend',\n    type: 'vec4'\n  }]\n});\n\n// deprecated\n\nconst burn = function () {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"burn\" has been renamed. Use \"blendBurn\" instead.');\n  for (var _len25 = arguments.length, params = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n    params[_key25] = arguments[_key25];\n  }\n  return blendBurn(params);\n};\nconst dodge = function () {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"dodge\" has been renamed. Use \"blendDodge\" instead.');\n  for (var _len26 = arguments.length, params = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n    params[_key26] = arguments[_key26];\n  }\n  return blendDodge(params);\n};\nconst screen = function () {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"screen\" has been renamed. Use \"blendScreen\" instead.');\n  for (var _len27 = arguments.length, params = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n    params[_key27] = arguments[_key27];\n  }\n  return blendScreen(params);\n};\nconst overlay = function () {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"overlay\" has been renamed. Use \"blendOverlay\" instead.');\n  for (var _len28 = arguments.length, params = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {\n    params[_key28] = arguments[_key28];\n  }\n  return blendOverlay(params);\n};\nconst grayscale = /*@__PURE__*/Fn(_ref114 => {\n  let [color] = _ref114;\n  return luminance(color.rgb);\n});\nconst saturation = /*@__PURE__*/Fn(_ref115 => {\n  let [color, adjustment = float(1)] = _ref115;\n  return adjustment.mix(luminance(color.rgb), color.rgb);\n});\nconst vibrance = /*@__PURE__*/Fn(_ref116 => {\n  let [color, adjustment = float(1)] = _ref116;\n  const average = add(color.r, color.g, color.b).div(3.0);\n  const mx = color.r.max(color.g.max(color.b));\n  const amt = mx.sub(average).mul(adjustment).mul(-3.0);\n  return mix(color.rgb, mx, amt);\n});\nconst hue = /*@__PURE__*/Fn(_ref117 => {\n  let [color, adjustment = float(1)] = _ref117;\n  const k = vec3(0.57735, 0.57735, 0.57735);\n  const cosAngle = adjustment.cos();\n  return vec3(color.rgb.mul(cosAngle).add(k.cross(color.rgb).mul(adjustment.sin()).add(k.mul(dot(k, color.rgb).mul(cosAngle.oneMinus())))));\n});\nconst luminance = function (color) {\n  let luminanceCoefficients = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : vec3(ColorManagement.getLuminanceCoefficients(new Vector3()));\n  return dot(color, luminanceCoefficients);\n};\nconst threshold = (color, threshold) => mix(vec3(0.0), color, luminance(color).sub(threshold).max(0));\n\n/**\n * Color Decision List (CDL) v1.2\n *\n * Compact representation of color grading information, defined by slope, offset, power, and\n * saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,\n * or AgX Log), and will return output in the same space. Output may require clamping >=0.\n *\n * @param {vec4} color Input (-Infinity < input < +Infinity)\n * @param {number | vec3} slope Slope (0  slope < +Infinity)\n * @param {number | vec3} offset Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1)\n * @param {number | vec3} power Power (0 < power < +Infinity)\n * @param {number} saturation Saturation (0  saturation < +Infinity; typically 0  saturation < 4)\n * @param {vec3} luminanceCoefficients Luminance coefficients for saturation term, typically Rec. 709\n * @return Output, -Infinity < output < +Infinity\n *\n * References:\n * - ASC CDL v1.2\n * - https://blender.stackexchange.com/a/55239/43930\n * - https://docs.acescentral.com/specifications/acescc/\n */\nconst cdl = /*@__PURE__*/Fn(_ref118 => {\n  let [color, slope = vec3(1), offset = vec3(0), power = vec3(1), saturation = float(1),\n  // ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.\n  luminanceCoefficients = vec3(ColorManagement.getLuminanceCoefficients(new Vector3(), LinearSRGBColorSpace))] = _ref118;\n  // NOTE: The ASC CDL v1.2 defines a [0, 1] clamp on the slope+offset term, and another on the\n  // saturation term. Per the ACEScc specification and Filament, limits may be omitted to support\n  // values outside [0, 1], requiring a workaround for negative values in the power expression.\n\n  const luma = color.rgb.dot(vec3(luminanceCoefficients));\n  const v = max$1(color.rgb.mul(slope).add(offset), 0.0).toVar();\n  const pv = v.pow(power).toVar();\n  If(v.r.greaterThan(0.0), () => {\n    v.r.assign(pv.r);\n  }); // eslint-disable-line\n  If(v.g.greaterThan(0.0), () => {\n    v.g.assign(pv.g);\n  }); // eslint-disable-line\n  If(v.b.greaterThan(0.0), () => {\n    v.b.assign(pv.b);\n  }); // eslint-disable-line\n\n  v.assign(luma.add(v.sub(luma).mul(saturation)));\n  return vec4(v.rgb, color.a);\n});\nclass PosterizeNode extends TempNode {\n  static get type() {\n    return 'PosterizeNode';\n  }\n  constructor(sourceNode, stepsNode) {\n    super();\n    this.sourceNode = sourceNode;\n    this.stepsNode = stepsNode;\n  }\n  setup() {\n    const {\n      sourceNode,\n      stepsNode\n    } = this;\n    return sourceNode.mul(stepsNode).floor().div(stepsNode);\n  }\n}\nconst posterize = /*@__PURE__*/nodeProxy(PosterizeNode);\nconst _size = /*@__PURE__*/new Vector2();\nclass PassTextureNode extends TextureNode {\n  static get type() {\n    return 'PassTextureNode';\n  }\n  constructor(passNode, texture) {\n    super(texture);\n    this.passNode = passNode;\n    this.setUpdateMatrix(false);\n  }\n  setup(builder) {\n    if (builder.object.isQuadMesh) this.passNode.build(builder);\n    return super.setup(builder);\n  }\n  clone() {\n    return new this.constructor(this.passNode, this.value);\n  }\n}\nclass PassMultipleTextureNode extends PassTextureNode {\n  static get type() {\n    return 'PassMultipleTextureNode';\n  }\n  constructor(passNode, textureName) {\n    let previousTexture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    super(passNode, null);\n    this.textureName = textureName;\n    this.previousTexture = previousTexture;\n  }\n  updateTexture() {\n    this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);\n  }\n  setup(builder) {\n    this.updateTexture();\n    return super.setup(builder);\n  }\n  clone() {\n    return new this.constructor(this.passNode, this.textureName, this.previousTexture);\n  }\n}\nclass PassNode extends TempNode {\n  static get type() {\n    return 'PassNode';\n  }\n  constructor(scope, scene, camera) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super('vec4');\n    this.scope = scope;\n    this.scene = scene;\n    this.camera = camera;\n    this.options = options;\n    this._pixelRatio = 1;\n    this._width = 1;\n    this._height = 1;\n    const depthTexture = new DepthTexture();\n    depthTexture.isRenderTargetTexture = true;\n    //depthTexture.type = FloatType;\n    depthTexture.name = 'depth';\n    const renderTarget = new RenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, {\n      type: HalfFloatType,\n      ...options\n    });\n    renderTarget.texture.name = 'output';\n    renderTarget.depthTexture = depthTexture;\n    this.renderTarget = renderTarget;\n    this.updateBeforeType = NodeUpdateType.FRAME;\n    this._textures = {\n      output: renderTarget.texture,\n      depth: depthTexture\n    };\n    this._textureNodes = {};\n    this._linearDepthNodes = {};\n    this._viewZNodes = {};\n    this._previousTextures = {};\n    this._previousTextureNodes = {};\n    this._cameraNear = uniform(0);\n    this._cameraFar = uniform(0);\n    this._mrt = null;\n    this.isPassNode = true;\n  }\n  setMRT(mrt) {\n    this._mrt = mrt;\n    return this;\n  }\n  getMRT() {\n    return this._mrt;\n  }\n  isGlobal() {\n    return true;\n  }\n  getTexture(name) {\n    let texture = this._textures[name];\n    if (texture === undefined) {\n      const refTexture = this.renderTarget.texture;\n      texture = refTexture.clone();\n      texture.isRenderTargetTexture = true;\n      texture.name = name;\n      this._textures[name] = texture;\n      this.renderTarget.textures.push(texture);\n    }\n    return texture;\n  }\n  getPreviousTexture(name) {\n    let texture = this._previousTextures[name];\n    if (texture === undefined) {\n      texture = this.getTexture(name).clone();\n      texture.isRenderTargetTexture = true;\n      this._previousTextures[name] = texture;\n    }\n    return texture;\n  }\n  toggleTexture(name) {\n    const prevTexture = this._previousTextures[name];\n    if (prevTexture !== undefined) {\n      const texture = this._textures[name];\n      const index = this.renderTarget.textures.indexOf(texture);\n      this.renderTarget.textures[index] = prevTexture;\n      this._textures[name] = prevTexture;\n      this._previousTextures[name] = texture;\n      this._textureNodes[name].updateTexture();\n      this._previousTextureNodes[name].updateTexture();\n    }\n  }\n  getTextureNode() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'output';\n    let textureNode = this._textureNodes[name];\n    if (textureNode === undefined) {\n      textureNode = nodeObject(new PassMultipleTextureNode(this, name));\n      textureNode.updateTexture();\n      this._textureNodes[name] = textureNode;\n    }\n    return textureNode;\n  }\n  getPreviousTextureNode() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'output';\n    let textureNode = this._previousTextureNodes[name];\n    if (textureNode === undefined) {\n      if (this._textureNodes[name] === undefined) this.getTextureNode(name);\n      textureNode = nodeObject(new PassMultipleTextureNode(this, name, true));\n      textureNode.updateTexture();\n      this._previousTextureNodes[name] = textureNode;\n    }\n    return textureNode;\n  }\n  getViewZNode() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'depth';\n    let viewZNode = this._viewZNodes[name];\n    if (viewZNode === undefined) {\n      const cameraNear = this._cameraNear;\n      const cameraFar = this._cameraFar;\n      this._viewZNodes[name] = viewZNode = perspectiveDepthToViewZ(this.getTextureNode(name), cameraNear, cameraFar);\n    }\n    return viewZNode;\n  }\n  getLinearDepthNode() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'depth';\n    let linearDepthNode = this._linearDepthNodes[name];\n    if (linearDepthNode === undefined) {\n      const cameraNear = this._cameraNear;\n      const cameraFar = this._cameraFar;\n      const viewZNode = this.getViewZNode(name);\n\n      // TODO: just if ( builder.camera.isPerspectiveCamera )\n\n      this._linearDepthNodes[name] = linearDepthNode = viewZToOrthographicDepth(viewZNode, cameraNear, cameraFar);\n    }\n    return linearDepthNode;\n  }\n  setup(_ref119) {\n    let {\n      renderer\n    } = _ref119;\n    this.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;\n\n    // Disable MSAA for WebGL backend for now\n    if (renderer.backend.isWebGLBackend === true) {\n      this.renderTarget.samples = 0;\n    }\n    this.renderTarget.depthTexture.isMultisampleRenderTargetTexture = this.renderTarget.samples > 1;\n    return this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();\n  }\n  updateBefore(frame) {\n    const {\n      renderer\n    } = frame;\n    const {\n      scene,\n      camera\n    } = this;\n    this._pixelRatio = renderer.getPixelRatio();\n    const size = renderer.getSize(_size);\n    this.setSize(size.width, size.height);\n    const currentRenderTarget = renderer.getRenderTarget();\n    const currentMRT = renderer.getMRT();\n    this._cameraNear.value = camera.near;\n    this._cameraFar.value = camera.far;\n    for (const name in this._previousTextures) {\n      this.toggleTexture(name);\n    }\n    renderer.setRenderTarget(this.renderTarget);\n    renderer.setMRT(this._mrt);\n    renderer.render(scene, camera);\n    renderer.setRenderTarget(currentRenderTarget);\n    renderer.setMRT(currentMRT);\n  }\n  setSize(width, height) {\n    this._width = width;\n    this._height = height;\n    const effectiveWidth = this._width * this._pixelRatio;\n    const effectiveHeight = this._height * this._pixelRatio;\n    this.renderTarget.setSize(effectiveWidth, effectiveHeight);\n  }\n  setPixelRatio(pixelRatio) {\n    this._pixelRatio = pixelRatio;\n    this.setSize(this._width, this._height);\n  }\n  dispose() {\n    this.renderTarget.dispose();\n  }\n}\nPassNode.COLOR = 'color';\nPassNode.DEPTH = 'depth';\nconst pass = (scene, camera, options) => nodeObject(new PassNode(PassNode.COLOR, scene, camera, options));\nconst passTexture = (pass, texture) => nodeObject(new PassTextureNode(pass, texture));\nconst depthPass = (scene, camera) => nodeObject(new PassNode(PassNode.DEPTH, scene, camera));\nclass ToonOutlinePassNode extends PassNode {\n  static get type() {\n    return 'ToonOutlinePassNode';\n  }\n  constructor(scene, camera, colorNode, thicknessNode, alphaNode) {\n    super(PassNode.COLOR, scene, camera);\n    this.colorNode = colorNode;\n    this.thicknessNode = thicknessNode;\n    this.alphaNode = alphaNode;\n    this._materialCache = new WeakMap();\n  }\n  updateBefore(frame) {\n    const {\n      renderer\n    } = frame;\n    const currentRenderObjectFunction = renderer.getRenderObjectFunction();\n    renderer.setRenderObjectFunction((object, scene, camera, geometry, material, group, lightsNode, clippingContext) => {\n      // only render outline for supported materials\n\n      if (material.isMeshToonMaterial || material.isMeshToonNodeMaterial) {\n        if (material.wireframe === false) {\n          const outlineMaterial = this._getOutlineMaterial(material);\n          renderer.renderObject(object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext);\n        }\n      }\n\n      // default\n\n      renderer.renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext);\n    });\n    super.updateBefore(frame);\n    renderer.setRenderObjectFunction(currentRenderObjectFunction);\n  }\n  _createMaterial() {\n    const material = new NodeMaterial();\n    material.isMeshToonOutlineMaterial = true;\n    material.name = 'Toon_Outline';\n    material.side = BackSide;\n\n    // vertex node\n\n    const outlineNormal = normalLocal.negate();\n    const mvp = cameraProjectionMatrix.mul(modelViewMatrix);\n    const ratio = float(1.0); // TODO: support outline thickness ratio for each vertex\n    const pos = mvp.mul(vec4(positionLocal, 1.0));\n    const pos2 = mvp.mul(vec4(positionLocal.add(outlineNormal), 1.0));\n    const norm = normalize(pos.sub(pos2)); // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\n    material.vertexNode = pos.add(norm.mul(this.thicknessNode).mul(pos.w).mul(ratio));\n\n    // color node\n\n    material.colorNode = vec4(this.colorNode, this.alphaNode);\n    return material;\n  }\n  _getOutlineMaterial(originalMaterial) {\n    let outlineMaterial = this._materialCache.get(originalMaterial);\n    if (outlineMaterial === undefined) {\n      outlineMaterial = this._createMaterial();\n      this._materialCache.set(originalMaterial, outlineMaterial);\n    }\n    return outlineMaterial;\n  }\n}\nconst toonOutlinePass = function (scene, camera) {\n  let color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Color(0, 0, 0);\n  let thickness = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.003;\n  let alpha = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  return nodeObject(new ToonOutlinePassNode(scene, camera, nodeObject(color), nodeObject(thickness), nodeObject(alpha)));\n};\n\n// exposure only\n\nconst linearToneMapping = /*@__PURE__*/Fn(_ref120 => {\n  let [color, exposure] = _ref120;\n  return color.mul(exposure).clamp();\n}).setLayout({\n  name: 'linearToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\n\n// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf\n\nconst reinhardToneMapping = /*@__PURE__*/Fn(_ref121 => {\n  let [color, exposure] = _ref121;\n  color = color.mul(exposure);\n  return color.div(color.add(1.0)).clamp();\n}).setLayout({\n  name: 'reinhardToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n\nconst cineonToneMapping = /*@__PURE__*/Fn(_ref122 => {\n  let [color, exposure] = _ref122;\n  // filmic operator by Jim Hejl and Richard Burgess-Dawson\n  color = color.mul(exposure);\n  color = color.sub(0.004).max(0.0);\n  const a = color.mul(color.mul(6.2).add(0.5));\n  const b = color.mul(color.mul(6.2).add(1.7)).add(0.06);\n  return a.div(b).pow(2.2);\n}).setLayout({\n  name: 'cineonToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n\nconst RRTAndODTFit = /*@__PURE__*/Fn(_ref123 => {\n  let [color] = _ref123;\n  const a = color.mul(color.add(0.0245786)).sub(0.000090537);\n  const b = color.mul(color.add(0.4329510).mul(0.983729)).add(0.238081);\n  return a.div(b);\n});\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n\nconst acesFilmicToneMapping = /*@__PURE__*/Fn(_ref124 => {\n  let [color, exposure] = _ref124;\n  // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n  const ACESInputMat = mat3(0.59719, 0.35458, 0.04823, 0.07600, 0.90834, 0.01566, 0.02840, 0.13383, 0.83777);\n\n  // ODT_SAT => XYZ => D60_2_D65 => sRGB\n  const ACESOutputMat = mat3(1.60475, -0.53108, -0.07367, -0.10208, 1.10813, -0.00605, -0.00327, -0.07276, 1.07602);\n  color = color.mul(exposure).div(0.6);\n  color = ACESInputMat.mul(color);\n\n  // Apply RRT and ODT\n  color = RRTAndODTFit(color);\n  color = ACESOutputMat.mul(color);\n\n  // Clamp to [0, 1]\n  return color.clamp();\n}).setLayout({\n  name: 'acesFilmicToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\nconst LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/mat3(vec3(1.6605, -0.1246, -0.0182), vec3(-0.5876, 1.1329, -0.1006), vec3(-0.0728, -0.0083, 1.1187));\nconst LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/mat3(vec3(0.6274, 0.0691, 0.0164), vec3(0.3293, 0.9195, 0.0880), vec3(0.0433, 0.0113, 0.8956));\nconst agxDefaultContrastApprox = /*@__PURE__*/Fn(_ref125 => {\n  let [x_immutable] = _ref125;\n  const x = vec3(x_immutable).toVar();\n  const x2 = vec3(x.mul(x)).toVar();\n  const x4 = vec3(x2.mul(x2)).toVar();\n  return float(15.5).mul(x4.mul(x2)).sub(mul(40.14, x4.mul(x))).add(mul(31.96, x4).sub(mul(6.868, x2.mul(x))).add(mul(0.4298, x2).add(mul(0.1191, x).sub(0.00232))));\n});\nconst agxToneMapping = /*@__PURE__*/Fn(_ref126 => {\n  let [color, exposure] = _ref126;\n  const colortone = vec3(color).toVar();\n  const AgXInsetMatrix = mat3(vec3(0.856627153315983, 0.137318972929847, 0.11189821299995), vec3(0.0951212405381588, 0.761241990602591, 0.0767994186031903), vec3(0.0482516061458583, 0.101439036467562, 0.811302368396859));\n  const AgXOutsetMatrix = mat3(vec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), vec3(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), vec3(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405));\n  const AgxMinEv = float(-12.47393);\n  const AgxMaxEv = float(4.026069);\n  colortone.mulAssign(exposure);\n  colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone));\n  colortone.assign(AgXInsetMatrix.mul(colortone));\n  colortone.assign(max$1(colortone, 1e-10));\n  colortone.assign(log2(colortone));\n  colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv)));\n  colortone.assign(clamp(colortone, 0.0, 1.0));\n  colortone.assign(agxDefaultContrastApprox(colortone));\n  colortone.assign(AgXOutsetMatrix.mul(colortone));\n  colortone.assign(pow(max$1(vec3(0.0), colortone), vec3(2.2)));\n  colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone));\n  colortone.assign(clamp(colortone, 0.0, 1.0));\n  return colortone;\n}).setLayout({\n  name: 'agxToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\n\n// https://modelviewer.dev/examples/tone-mapping\n\nconst neutralToneMapping = /*@__PURE__*/Fn(_ref127 => {\n  let [color, exposure] = _ref127;\n  const StartCompression = float(0.8 - 0.04);\n  const Desaturation = float(0.15);\n  color = color.mul(exposure);\n  const x = min$1(color.r, min$1(color.g, color.b));\n  const offset = select(x.lessThan(0.08), x.sub(mul(6.25, x.mul(x))), 0.04);\n  color.subAssign(offset);\n  const peak = max$1(color.r, max$1(color.g, color.b));\n  If(peak.lessThan(StartCompression), () => {\n    return color;\n  });\n  const d = sub(1, StartCompression);\n  const newPeak = sub(1, d.mul(d).div(peak.add(d.sub(StartCompression))));\n  color.mulAssign(newPeak.div(peak));\n  const g = sub(1, div(1, Desaturation.mul(peak.sub(newPeak)).add(1)));\n  return mix(color, vec3(newPeak), g);\n}).setLayout({\n  name: 'neutralToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\nclass CodeNode extends Node {\n  static get type() {\n    return 'CodeNode';\n  }\n  constructor() {\n    let code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let includes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let language = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    super('code');\n    this.isCodeNode = true;\n    this.code = code;\n    this.language = language;\n    this.includes = includes;\n  }\n  isGlobal() {\n    return true;\n  }\n  setIncludes(includes) {\n    this.includes = includes;\n    return this;\n  }\n  getIncludes(/*builder*/\n  ) {\n    return this.includes;\n  }\n  generate(builder) {\n    const includes = this.getIncludes(builder);\n    for (const include of includes) {\n      include.build(builder);\n    }\n    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));\n    nodeCode.code = this.code;\n    return nodeCode.code;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.code = this.code;\n    data.language = this.language;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.code = data.code;\n    this.language = data.language;\n  }\n}\nconst code = /*@__PURE__*/nodeProxy(CodeNode);\nconst js = (src, includes) => code(src, includes, 'js');\nconst wgsl = (src, includes) => code(src, includes, 'wgsl');\nconst glsl = (src, includes) => code(src, includes, 'glsl');\nclass FunctionNode extends CodeNode {\n  static get type() {\n    return 'FunctionNode';\n  }\n  constructor() {\n    let code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let includes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let language = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    super(code, includes, language);\n  }\n  getNodeType(builder) {\n    return this.getNodeFunction(builder).type;\n  }\n  getInputs(builder) {\n    return this.getNodeFunction(builder).inputs;\n  }\n  getNodeFunction(builder) {\n    const nodeData = builder.getDataFromNode(this);\n    let nodeFunction = nodeData.nodeFunction;\n    if (nodeFunction === undefined) {\n      nodeFunction = builder.parser.parseFunction(this.code);\n      nodeData.nodeFunction = nodeFunction;\n    }\n    return nodeFunction;\n  }\n  generate(builder, output) {\n    super.generate(builder);\n    const nodeFunction = this.getNodeFunction(builder);\n    const name = nodeFunction.name;\n    const type = nodeFunction.type;\n    const nodeCode = builder.getCodeFromNode(this, type);\n    if (name !== '') {\n      // use a custom property name\n\n      nodeCode.name = name;\n    }\n    const propertyName = builder.getPropertyName(nodeCode);\n    const code = this.getNodeFunction(builder).getCode(propertyName);\n    nodeCode.code = code + '\\n';\n    if (output === 'property') {\n      return propertyName;\n    } else {\n      return builder.format(`${propertyName}()`, type, output);\n    }\n  }\n}\nconst nativeFn = function (code) {\n  let includes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let language = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  for (let i = 0; i < includes.length; i++) {\n    const include = includes[i];\n\n    // TSL Function: glslFn, wgslFn\n\n    if (typeof include === 'function') {\n      includes[i] = include.functionNode;\n    }\n  }\n  const functionNode = nodeObject(new FunctionNode(code, includes, language));\n  const fn = function () {\n    return functionNode.call(...arguments);\n  };\n  fn.functionNode = functionNode;\n  return fn;\n};\nconst glslFn = (code, includes) => nativeFn(code, includes, 'glsl');\nconst wgslFn = (code, includes) => nativeFn(code, includes, 'wgsl');\nclass ScriptableValueNode extends Node {\n  static get type() {\n    return 'ScriptableValueNode';\n  }\n  constructor() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this._value = value;\n    this._cache = null;\n    this.inputType = null;\n    this.outpuType = null;\n    this.events = new EventDispatcher();\n    this.isScriptableValueNode = true;\n  }\n  get isScriptableOutputNode() {\n    return this.outputType !== null;\n  }\n  set value(val) {\n    if (this._value === val) return;\n    if (this._cache && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer) {\n      URL.revokeObjectURL(this._cache);\n      this._cache = null;\n    }\n    this._value = val;\n    this.events.dispatchEvent({\n      type: 'change'\n    });\n    this.refresh();\n  }\n  get value() {\n    return this._value;\n  }\n  refresh() {\n    this.events.dispatchEvent({\n      type: 'refresh'\n    });\n  }\n  getValue() {\n    const value = this.value;\n    if (value && this._cache === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer) {\n      this._cache = URL.createObjectURL(new Blob([value.value]));\n    } else if (value && value.value !== null && value.value !== undefined && ((this.inputType === 'URL' || this.inputType === 'String') && typeof value.value === 'string' || this.inputType === 'Number' && typeof value.value === 'number' || this.inputType === 'Vector2' && value.value.isVector2 || this.inputType === 'Vector3' && value.value.isVector3 || this.inputType === 'Vector4' && value.value.isVector4 || this.inputType === 'Color' && value.value.isColor || this.inputType === 'Matrix3' && value.value.isMatrix3 || this.inputType === 'Matrix4' && value.value.isMatrix4)) {\n      return value.value;\n    }\n    return this._cache || value;\n  }\n  getNodeType(builder) {\n    return this.value && this.value.isNode ? this.value.getNodeType(builder) : 'float';\n  }\n  setup() {\n    return this.value && this.value.isNode ? this.value : float();\n  }\n  serialize(data) {\n    super.serialize(data);\n    if (this.value !== null) {\n      if (this.inputType === 'ArrayBuffer') {\n        data.value = arrayBufferToBase64(this.value);\n      } else {\n        data.value = this.value ? this.value.toJSON(data.meta).uuid : null;\n      }\n    } else {\n      data.value = null;\n    }\n    data.inputType = this.inputType;\n    data.outputType = this.outputType;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    let value = null;\n    if (data.value !== null) {\n      if (data.inputType === 'ArrayBuffer') {\n        value = base64ToArrayBuffer(data.value);\n      } else if (data.inputType === 'Texture') {\n        value = data.meta.textures[data.value];\n      } else {\n        value = data.meta.nodes[data.value] || null;\n      }\n    }\n    this.value = value;\n    this.inputType = data.inputType;\n    this.outputType = data.outputType;\n  }\n}\nconst scriptableValue = /*@__PURE__*/nodeProxy(ScriptableValueNode);\nclass Resources extends Map {\n  get(key) {\n    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (this.has(key)) return super.get(key);\n    if (callback !== null) {\n      for (var _len29 = arguments.length, params = new Array(_len29 > 2 ? _len29 - 2 : 0), _key29 = 2; _key29 < _len29; _key29++) {\n        params[_key29 - 2] = arguments[_key29];\n      }\n      const value = callback(...params);\n      this.set(key, value);\n      return value;\n    }\n  }\n}\nclass Parameters {\n  constructor(scriptableNode) {\n    this.scriptableNode = scriptableNode;\n  }\n  get parameters() {\n    return this.scriptableNode.parameters;\n  }\n  get layout() {\n    return this.scriptableNode.getLayout();\n  }\n  getInputLayout(id) {\n    return this.scriptableNode.getInputLayout(id);\n  }\n  get(name) {\n    const param = this.parameters[name];\n    const value = param ? param.getValue() : null;\n    return value;\n  }\n}\nconst ScriptableNodeResources = new Resources();\nclass ScriptableNode extends Node {\n  static get type() {\n    return 'ScriptableNode';\n  }\n  constructor() {\n    let codeNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.codeNode = codeNode;\n    this.parameters = parameters;\n    this._local = new Resources();\n    this._output = scriptableValue();\n    this._outputs = {};\n    this._source = this.source;\n    this._method = null;\n    this._object = null;\n    this._value = null;\n    this._needsOutputUpdate = true;\n    this.onRefresh = this.onRefresh.bind(this);\n    this.isScriptableNode = true;\n  }\n  get source() {\n    return this.codeNode ? this.codeNode.code : '';\n  }\n  setLocal(name, value) {\n    return this._local.set(name, value);\n  }\n  getLocal(name) {\n    return this._local.get(name);\n  }\n  onRefresh() {\n    this._refresh();\n  }\n  getInputLayout(id) {\n    for (const element of this.getLayout()) {\n      if (element.inputType && (element.id === id || element.name === id)) {\n        return element;\n      }\n    }\n  }\n  getOutputLayout(id) {\n    for (const element of this.getLayout()) {\n      if (element.outputType && (element.id === id || element.name === id)) {\n        return element;\n      }\n    }\n  }\n  setOutput(name, value) {\n    const outputs = this._outputs;\n    if (outputs[name] === undefined) {\n      outputs[name] = scriptableValue(value);\n    } else {\n      outputs[name].value = value;\n    }\n    return this;\n  }\n  getOutput(name) {\n    return this._outputs[name];\n  }\n  getParameter(name) {\n    return this.parameters[name];\n  }\n  setParameter(name, value) {\n    const parameters = this.parameters;\n    if (value && value.isScriptableNode) {\n      this.deleteParameter(name);\n      parameters[name] = value;\n      parameters[name].getDefaultOutput().events.addEventListener('refresh', this.onRefresh);\n    } else if (value && value.isScriptableValueNode) {\n      this.deleteParameter(name);\n      parameters[name] = value;\n      parameters[name].events.addEventListener('refresh', this.onRefresh);\n    } else if (parameters[name] === undefined) {\n      parameters[name] = scriptableValue(value);\n      parameters[name].events.addEventListener('refresh', this.onRefresh);\n    } else {\n      parameters[name].value = value;\n    }\n    return this;\n  }\n  getValue() {\n    return this.getDefaultOutput().getValue();\n  }\n  deleteParameter(name) {\n    let valueNode = this.parameters[name];\n    if (valueNode) {\n      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();\n      valueNode.events.removeEventListener('refresh', this.onRefresh);\n    }\n    return this;\n  }\n  clearParameters() {\n    for (const name of Object.keys(this.parameters)) {\n      this.deleteParameter(name);\n    }\n    this.needsUpdate = true;\n    return this;\n  }\n  call(name) {\n    const object = this.getObject();\n    const method = object[name];\n    if (typeof method === 'function') {\n      for (var _len30 = arguments.length, params = new Array(_len30 > 1 ? _len30 - 1 : 0), _key30 = 1; _key30 < _len30; _key30++) {\n        params[_key30 - 1] = arguments[_key30];\n      }\n      return method(...params);\n    }\n  }\n  async callAsync(name) {\n    const object = this.getObject();\n    const method = object[name];\n    if (typeof method === 'function') {\n      for (var _len31 = arguments.length, params = new Array(_len31 > 1 ? _len31 - 1 : 0), _key31 = 1; _key31 < _len31; _key31++) {\n        params[_key31 - 1] = arguments[_key31];\n      }\n      return method.constructor.name === 'AsyncFunction' ? await method(...params) : method(...params);\n    }\n  }\n  getNodeType(builder) {\n    return this.getDefaultOutputNode().getNodeType(builder);\n  }\n  refresh() {\n    let output = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (output !== null) {\n      this.getOutput(output).refresh();\n    } else {\n      this._refresh();\n    }\n  }\n  getObject() {\n    if (this.needsUpdate) this.dispose();\n    if (this._object !== null) return this._object;\n\n    //\n\n    const refresh = () => this.refresh();\n    const setOutput = (id, value) => this.setOutput(id, value);\n    const parameters = new Parameters(this);\n    const THREE = ScriptableNodeResources.get('THREE');\n    const TSL = ScriptableNodeResources.get('TSL');\n    const method = this.getMethod(this.codeNode);\n    const params = [parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE, TSL];\n    this._object = method(...params);\n    const layout = this._object.layout;\n    if (layout) {\n      if (layout.cache === false) {\n        this._local.clear();\n      }\n\n      // default output\n      this._output.outputType = layout.outputType || null;\n      if (Array.isArray(layout.elements)) {\n        for (const element of layout.elements) {\n          const id = element.id || element.name;\n          if (element.inputType) {\n            if (this.getParameter(id) === undefined) this.setParameter(id, null);\n            this.getParameter(id).inputType = element.inputType;\n          }\n          if (element.outputType) {\n            if (this.getOutput(id) === undefined) this.setOutput(id, null);\n            this.getOutput(id).outputType = element.outputType;\n          }\n        }\n      }\n    }\n    return this._object;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    for (const name in this.parameters) {\n      let valueNode = this.parameters[name];\n      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();\n      valueNode.events.addEventListener('refresh', this.onRefresh);\n    }\n  }\n  getLayout() {\n    return this.getObject().layout;\n  }\n  getDefaultOutputNode() {\n    const output = this.getDefaultOutput().value;\n    if (output && output.isNode) {\n      return output;\n    }\n    return float();\n  }\n  getDefaultOutput() {\n    return this._exec()._output;\n  }\n  getMethod() {\n    if (this.needsUpdate) this.dispose();\n    if (this._method !== null) return this._method;\n\n    //\n\n    const parametersProps = ['parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL'];\n    const interfaceProps = ['layout', 'init', 'main', 'dispose'];\n    const properties = interfaceProps.join(', ');\n    const declarations = 'var ' + properties + '; var output = {};\\n';\n    const returns = '\\nreturn { ...output, ' + properties + ' };';\n    const code = declarations + this.codeNode.code + returns;\n\n    //\n\n    this._method = new Function(...parametersProps, code);\n    return this._method;\n  }\n  dispose() {\n    if (this._method === null) return;\n    if (this._object && typeof this._object.dispose === 'function') {\n      this._object.dispose();\n    }\n    this._method = null;\n    this._object = null;\n    this._source = null;\n    this._value = null;\n    this._needsOutputUpdate = true;\n    this._output.value = null;\n    this._outputs = {};\n  }\n  setup() {\n    return this.getDefaultOutputNode();\n  }\n  getCacheKey(force) {\n    const values = [hashString(this.source), this.getDefaultOutputNode().getCacheKey(force)];\n    for (const param in this.parameters) {\n      values.push(this.parameters[param].getCacheKey(force));\n    }\n    return hashArray(values);\n  }\n  set needsUpdate(value) {\n    if (value === true) this.dispose();\n  }\n  get needsUpdate() {\n    return this.source !== this._source;\n  }\n  _exec() {\n    if (this.codeNode === null) return this;\n    if (this._needsOutputUpdate === true) {\n      this._value = this.call('main');\n      this._needsOutputUpdate = false;\n    }\n    this._output.value = this._value;\n    return this;\n  }\n  _refresh() {\n    this.needsUpdate = true;\n    this._exec();\n    this._output.refresh();\n  }\n}\nconst scriptable = /*@__PURE__*/nodeProxy(ScriptableNode);\nclass FogNode extends Node {\n  static get type() {\n    return 'FogNode';\n  }\n  constructor(colorNode, factorNode) {\n    super('float');\n    this.isFogNode = true;\n    this.colorNode = colorNode;\n    this.factorNode = factorNode;\n  }\n  getViewZNode(builder) {\n    let viewZ;\n    const getViewZ = builder.context.getViewZ;\n    if (getViewZ !== undefined) {\n      viewZ = getViewZ(this);\n    }\n    return (viewZ || positionView.z).negate();\n  }\n  setup() {\n    return this.factorNode;\n  }\n}\nconst fog = /*@__PURE__*/nodeProxy(FogNode);\nclass FogRangeNode extends FogNode {\n  static get type() {\n    return 'FogRangeNode';\n  }\n  constructor(colorNode, nearNode, farNode) {\n    super(colorNode);\n    this.isFogRangeNode = true;\n    this.nearNode = nearNode;\n    this.farNode = farNode;\n  }\n  setup(builder) {\n    const viewZ = this.getViewZNode(builder);\n    return smoothstep(this.nearNode, this.farNode, viewZ);\n  }\n}\nconst rangeFog = /*@__PURE__*/nodeProxy(FogRangeNode);\nclass FogExp2Node extends FogNode {\n  static get type() {\n    return 'FogExp2Node';\n  }\n  constructor(colorNode, densityNode) {\n    super(colorNode);\n    this.isFogExp2Node = true;\n    this.densityNode = densityNode;\n  }\n  setup(builder) {\n    const viewZ = this.getViewZNode(builder);\n    const density = this.densityNode;\n    return density.mul(density, viewZ, viewZ).negate().exp().oneMinus();\n  }\n}\nconst densityFog = /*@__PURE__*/nodeProxy(FogExp2Node);\nlet min = null;\nlet max = null;\nclass RangeNode extends Node {\n  static get type() {\n    return 'RangeNode';\n  }\n  constructor() {\n    let minNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : float();\n    let maxNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : float();\n    super();\n    this.minNode = minNode;\n    this.maxNode = maxNode;\n  }\n  getVectorLength(builder) {\n    const minLength = builder.getTypeLength(getValueType(this.minNode.value));\n    const maxLength = builder.getTypeLength(getValueType(this.maxNode.value));\n    return minLength > maxLength ? minLength : maxLength;\n  }\n  getNodeType(builder) {\n    return builder.object.count > 1 ? builder.getTypeFromLength(this.getVectorLength(builder)) : 'float';\n  }\n  setup(builder) {\n    const object = builder.object;\n    let output = null;\n    if (object.count > 1) {\n      const minValue = this.minNode.value;\n      const maxValue = this.maxNode.value;\n      const minLength = builder.getTypeLength(getValueType(minValue));\n      const maxLength = builder.getTypeLength(getValueType(maxValue));\n      min = min || new Vector4();\n      max = max || new Vector4();\n      min.setScalar(0);\n      max.setScalar(0);\n      if (minLength === 1) min.setScalar(minValue);else if (minValue.isColor) min.set(minValue.r, minValue.g, minValue.b);else min.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);\n      if (maxLength === 1) max.setScalar(maxValue);else if (maxValue.isColor) max.set(maxValue.r, maxValue.g, maxValue.b);else max.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);\n      const stride = 4;\n      const length = stride * object.count;\n      const array = new Float32Array(length);\n      for (let i = 0; i < length; i++) {\n        const index = i % stride;\n        const minElementValue = min.getComponent(index);\n        const maxElementValue = max.getComponent(index);\n        array[i] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());\n      }\n      const nodeType = this.getNodeType(builder);\n      if (object.count <= 4096) {\n        output = buffer(array, 'vec4', object.count).element(instanceIndex).convert(nodeType);\n      } else {\n        // TODO: Improve anonymous buffer attribute creation removing this part\n        const bufferAttribute = new InstancedBufferAttribute(array, 4);\n        builder.geometry.setAttribute('__range' + this.id, bufferAttribute);\n        output = instancedBufferAttribute(bufferAttribute).convert(nodeType);\n      }\n    } else {\n      output = float(0);\n    }\n    return output;\n  }\n}\nconst range = /*@__PURE__*/nodeProxy(RangeNode);\nclass ComputeBuiltinNode extends Node {\n  static get type() {\n    return 'ComputeBuiltinNode';\n  }\n  constructor(builtinName, nodeType) {\n    super(nodeType);\n    this._builtinName = builtinName;\n  }\n  getHash(builder) {\n    return this.getBuiltinName(builder);\n  }\n  getNodeType(/*builder*/\n  ) {\n    return this.nodeType;\n  }\n  setBuiltinName(builtinName) {\n    this._builtinName = builtinName;\n    return this;\n  }\n  getBuiltinName(/*builder*/\n  ) {\n    return this._builtinName;\n  }\n  hasBuiltin(builder) {\n    builder.hasBuiltin(this._builtinName);\n  }\n  generate(builder, output) {\n    const builtinName = this.getBuiltinName(builder);\n    const nodeType = this.getNodeType(builder);\n    if (builder.shaderStage === 'compute') {\n      return builder.format(builtinName, nodeType, output);\n    } else {\n      console.warn(`ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage`);\n      return builder.generateConst(nodeType);\n    }\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.global = this.global;\n    data._builtinName = this._builtinName;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.global = data.global;\n    this._builtinName = data._builtinName;\n  }\n}\nconst computeBuiltin = (name, nodeType) => nodeObject(new ComputeBuiltinNode(name, nodeType));\nconst numWorkgroups = /*@__PURE__*/computeBuiltin('numWorkgroups', 'uvec3');\nconst workgroupId = /*@__PURE__*/computeBuiltin('workgroupId', 'uvec3');\nconst localId = /*@__PURE__*/computeBuiltin('localId', 'uvec3');\nconst subgroupSize = /*@__PURE__*/computeBuiltin('subgroupSize', 'uint');\nclass BarrierNode extends Node {\n  constructor(scope) {\n    super();\n    this.scope = scope;\n  }\n  generate(builder) {\n    const {\n      scope\n    } = this;\n    const {\n      renderer\n    } = builder;\n    if (renderer.backend.isWebGLBackend === true) {\n      builder.addFlowCode(`\\t// ${scope}Barrier \\n`);\n    } else {\n      builder.addLineFlowCode(`${scope}Barrier()`, this);\n    }\n  }\n}\nconst barrier = nodeProxy(BarrierNode);\nconst workgroupBarrier = () => barrier('workgroup').append();\nconst storageBarrier = () => barrier('storage').append();\nconst textureBarrier = () => barrier('texture').append();\nclass WorkgroupInfoElementNode extends ArrayElementNode {\n  constructor(workgroupInfoNode, indexNode) {\n    super(workgroupInfoNode, indexNode);\n    this.isWorkgroupInfoElementNode = true;\n  }\n  generate(builder, output) {\n    let snippet;\n    const isAssignContext = builder.context.assign;\n    snippet = super.generate(builder);\n    if (isAssignContext !== true) {\n      const type = this.getNodeType(builder);\n      snippet = builder.format(snippet, type, output);\n    }\n\n    // TODO: Possibly activate clip distance index on index access rather than from clipping context\n\n    return snippet;\n  }\n}\nclass WorkgroupInfoNode extends Node {\n  constructor(scope, bufferType) {\n    let bufferCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    super(bufferType);\n    this.bufferType = bufferType;\n    this.bufferCount = bufferCount;\n    this.isWorkgroupInfoNode = true;\n    this.scope = scope;\n  }\n  label(name) {\n    this.name = name;\n    return this;\n  }\n  getHash() {\n    return this.uuid;\n  }\n  setScope(scope) {\n    this.scope = scope;\n    return this;\n  }\n  getInputType(/*builder*/\n  ) {\n    return `${this.scope}Array`;\n  }\n  element(indexNode) {\n    return nodeObject(new WorkgroupInfoElementNode(this, indexNode));\n  }\n  generate(builder) {\n    return builder.getScopedArray(this.name || `${this.scope}Array_${this.id}`, this.scope.toLowerCase(), this.bufferType, this.bufferCount);\n  }\n}\nconst workgroupArray = (type, count) => nodeObject(new WorkgroupInfoNode('Workgroup', type, count));\nclass AtomicFunctionNode extends TempNode {\n  static get type() {\n    return 'AtomicFunctionNode';\n  }\n  constructor(method, pointerNode, valueNode) {\n    let storeNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    super('uint');\n    this.method = method;\n    this.pointerNode = pointerNode;\n    this.valueNode = valueNode;\n    this.storeNode = storeNode;\n  }\n  getInputType(builder) {\n    return this.pointerNode.getNodeType(builder);\n  }\n  getNodeType(builder) {\n    return this.getInputType(builder);\n  }\n  generate(builder) {\n    const method = this.method;\n    const type = this.getNodeType(builder);\n    const inputType = this.getInputType(builder);\n    const a = this.pointerNode;\n    const b = this.valueNode;\n    const params = [];\n    params.push(`&${a.build(builder, inputType)}`);\n    params.push(b.build(builder, inputType));\n    const methodSnippet = `${builder.getMethod(method, type)}( ${params.join(', ')} )`;\n    if (this.storeNode !== null) {\n      const varSnippet = this.storeNode.build(builder, inputType);\n      builder.addLineFlowCode(`${varSnippet} = ${methodSnippet}`, this);\n    } else {\n      builder.addLineFlowCode(methodSnippet, this);\n    }\n  }\n}\nAtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';\nAtomicFunctionNode.ATOMIC_STORE = 'atomicStore';\nAtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';\nAtomicFunctionNode.ATOMIC_SUB = 'atomicSub';\nAtomicFunctionNode.ATOMIC_MAX = 'atomicMax';\nAtomicFunctionNode.ATOMIC_MIN = 'atomicMin';\nAtomicFunctionNode.ATOMIC_AND = 'atomicAnd';\nAtomicFunctionNode.ATOMIC_OR = 'atomicOr';\nAtomicFunctionNode.ATOMIC_XOR = 'atomicXor';\nconst atomicNode = nodeProxy(AtomicFunctionNode);\nconst atomicFunc = (method, pointerNode, valueNode, storeNode) => {\n  const node = atomicNode(method, pointerNode, valueNode, storeNode);\n  node.append();\n  return node;\n};\nconst atomicStore = function (pointerNode, valueNode) {\n  let storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return atomicFunc(AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode, storeNode);\n};\nconst atomicAdd = function (pointerNode, valueNode) {\n  let storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return atomicFunc(AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode, storeNode);\n};\nconst atomicSub = function (pointerNode, valueNode) {\n  let storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return atomicFunc(AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode, storeNode);\n};\nconst atomicMax = function (pointerNode, valueNode) {\n  let storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return atomicFunc(AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode, storeNode);\n};\nconst atomicMin = function (pointerNode, valueNode) {\n  let storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return atomicFunc(AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode, storeNode);\n};\nconst atomicAnd = function (pointerNode, valueNode) {\n  let storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return atomicFunc(AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode, storeNode);\n};\nconst atomicOr = function (pointerNode, valueNode) {\n  let storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return atomicFunc(AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode, storeNode);\n};\nconst atomicXor = function (pointerNode, valueNode) {\n  let storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return atomicFunc(AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode, storeNode);\n};\nlet uniformsLib;\nfunction getLightData(light) {\n  uniformsLib = uniformsLib || new WeakMap();\n  let uniforms = uniformsLib.get(light);\n  if (uniforms === undefined) uniformsLib.set(light, uniforms = {});\n  return uniforms;\n}\nfunction lightShadowMatrix(light) {\n  const data = getLightData(light);\n  return data.shadowMatrix || (data.shadowMatrix = uniform('mat4').setGroup(renderGroup).onRenderUpdate(() => {\n    light.shadow.updateMatrices(light);\n    return light.shadow.matrix;\n  }));\n}\nfunction lightProjectionUV(light) {\n  const data = getLightData(light);\n  if (data.projectionUV === undefined) {\n    const spotLightCoord = lightShadowMatrix(light).mul(positionWorld);\n    data.projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);\n  }\n  return data.projectionUV;\n}\nfunction lightPosition(light) {\n  const data = getLightData(light);\n  return data.position || (data.position = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_, self) => self.value.setFromMatrixPosition(light.matrixWorld)));\n}\nfunction lightTargetPosition(light) {\n  const data = getLightData(light);\n  return data.targetPosition || (data.targetPosition = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_, self) => self.value.setFromMatrixPosition(light.target.matrixWorld)));\n}\nfunction lightViewPosition(light) {\n  const data = getLightData(light);\n  return data.viewPosition || (data.viewPosition = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_ref128, self) => {\n    let {\n      camera\n    } = _ref128;\n    self.value = self.value || new Vector3();\n    self.value.setFromMatrixPosition(light.matrixWorld);\n    self.value.applyMatrix4(camera.matrixWorldInverse);\n  }));\n}\nconst lightTargetDirection = light => cameraViewMatrix.transformDirection(lightPosition(light).sub(lightTargetPosition(light)));\nconst sortLights = lights => {\n  return lights.sort((a, b) => a.id - b.id);\n};\nconst getLightNodeById = (id, lightNodes) => {\n  for (const lightNode of lightNodes) {\n    if (lightNode.isAnalyticLightNode && lightNode.light.id === id) {\n      return lightNode;\n    }\n  }\n  return null;\n};\nconst _lightsNodeRef = /*@__PURE__*/new WeakMap();\nclass LightsNode extends Node {\n  static get type() {\n    return 'LightsNode';\n  }\n  constructor() {\n    super('vec3');\n    this.totalDiffuseNode = vec3().toVar('totalDiffuse');\n    this.totalSpecularNode = vec3().toVar('totalSpecular');\n    this.outgoingLightNode = vec3().toVar('outgoingLight');\n    this._lights = [];\n    this._lightNodes = null;\n    this._lightNodesHash = null;\n    this.global = true;\n  }\n  getHash(builder) {\n    if (this._lightNodesHash === null) {\n      if (this._lightNodes === null) this.setupLightsNode(builder);\n      const hash = [];\n      for (const lightNode of this._lightNodes) {\n        hash.push(lightNode.getSelf().getHash());\n      }\n      this._lightNodesHash = 'lights-' + hash.join(',');\n    }\n    return this._lightNodesHash;\n  }\n  analyze(builder) {\n    const properties = builder.getDataFromNode(this);\n    for (const node of properties.nodes) {\n      node.build(builder);\n    }\n  }\n  setupLightsNode(builder) {\n    const lightNodes = [];\n    const previousLightNodes = this._lightNodes;\n    const lights = sortLights(this._lights);\n    const nodeLibrary = builder.renderer.library;\n    for (const light of lights) {\n      if (light.isNode) {\n        lightNodes.push(nodeObject(light));\n      } else {\n        let lightNode = null;\n        if (previousLightNodes !== null) {\n          lightNode = getLightNodeById(light.id, previousLightNodes); // resuse existing light node\n        }\n        if (lightNode === null) {\n          const lightNodeClass = nodeLibrary.getLightNodeClass(light.constructor);\n          if (lightNodeClass === null) {\n            console.warn(`LightsNode.setupNodeLights: Light node not found for ${light.constructor.name}`);\n            continue;\n          }\n          let lightNode = null;\n          if (!_lightsNodeRef.has(light)) {\n            lightNode = nodeObject(new lightNodeClass(light));\n            _lightsNodeRef.set(light, lightNode);\n          } else {\n            lightNode = _lightsNodeRef.get(light);\n          }\n          lightNodes.push(lightNode);\n        }\n      }\n    }\n    this._lightNodes = lightNodes;\n  }\n  setupLights(builder, lightNodes) {\n    for (const lightNode of lightNodes) {\n      lightNode.build(builder);\n    }\n  }\n  setup(builder) {\n    if (this._lightNodes === null) this.setupLightsNode(builder);\n    const context = builder.context;\n    const lightingModel = context.lightingModel;\n    let outgoingLightNode = this.outgoingLightNode;\n    if (lightingModel) {\n      const {\n        _lightNodes,\n        totalDiffuseNode,\n        totalSpecularNode\n      } = this;\n      context.outgoingLight = outgoingLightNode;\n      const stack = builder.addStack();\n\n      //\n\n      const properties = builder.getDataFromNode(this);\n      properties.nodes = stack.nodes;\n\n      //\n\n      lightingModel.start(context, stack, builder);\n\n      // lights\n\n      this.setupLights(builder, _lightNodes);\n\n      //\n\n      lightingModel.indirect(context, stack, builder);\n\n      //\n\n      const {\n        backdrop,\n        backdropAlpha\n      } = context;\n      const {\n        directDiffuse,\n        directSpecular,\n        indirectDiffuse,\n        indirectSpecular\n      } = context.reflectedLight;\n      let totalDiffuse = directDiffuse.add(indirectDiffuse);\n      if (backdrop !== null) {\n        if (backdropAlpha !== null) {\n          totalDiffuse = vec3(backdropAlpha.mix(totalDiffuse, backdrop));\n        } else {\n          totalDiffuse = vec3(backdrop);\n        }\n        context.material.transparent = true;\n      }\n      totalDiffuseNode.assign(totalDiffuse);\n      totalSpecularNode.assign(directSpecular.add(indirectSpecular));\n      outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));\n\n      //\n\n      lightingModel.finish(context, stack, builder);\n\n      //\n\n      outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());\n    }\n    return outgoingLightNode;\n  }\n  setLights(lights) {\n    this._lights = lights;\n    this._lightNodes = null;\n    this._lightNodesHash = null;\n    return this;\n  }\n  getLights() {\n    return this._lights;\n  }\n  get hasLights() {\n    return this._lights.length > 0;\n  }\n}\nconst lights = function () {\n  let lights = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return nodeObject(new LightsNode()).setLights(lights);\n};\nconst shadowMaterialLib = /*@__PURE__*/new WeakMap();\nconst shadowWorldPosition = /*@__PURE__*/vec3().toVar('shadowWorldPosition');\nconst linearDistance = /*@__PURE__*/Fn(_ref129 => {\n  let [position, cameraNear, cameraFar] = _ref129;\n  let dist = positionWorld.sub(position).length();\n  dist = dist.sub(cameraNear).div(cameraFar.sub(cameraNear));\n  dist = dist.saturate(); // clamp to [ 0, 1 ]\n\n  return dist;\n});\nconst linearShadowDistance = light => {\n  const camera = light.shadow.camera;\n  const nearDistance = reference('near', 'float', camera).setGroup(renderGroup);\n  const farDistance = reference('far', 'float', camera).setGroup(renderGroup);\n  const referencePosition = objectPosition(light);\n  return linearDistance(referencePosition, nearDistance, farDistance);\n};\nconst getShadowMaterial = light => {\n  let material = shadowMaterialLib.get(light);\n  if (material === undefined) {\n    const depthNode = light.isPointLight ? linearShadowDistance(light) : null;\n    material = new NodeMaterial();\n    material.colorNode = vec4(0, 0, 0, 1);\n    material.depthNode = depthNode;\n    material.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode\n    material.blending = NoBlending;\n    material.name = 'ShadowMaterial';\n    shadowMaterialLib.set(light, material);\n  }\n  return material;\n};\nconst BasicShadowFilter = /*@__PURE__*/Fn(_ref130 => {\n  let {\n    depthTexture,\n    shadowCoord\n  } = _ref130;\n  return texture(depthTexture, shadowCoord.xy).compare(shadowCoord.z);\n});\nconst PCFShadowFilter = /*@__PURE__*/Fn(_ref131 => {\n  let {\n    depthTexture,\n    shadowCoord,\n    shadow\n  } = _ref131;\n  const depthCompare = (uv, compare) => texture(depthTexture, uv).compare(compare);\n  const mapSize = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);\n  const radius = reference('radius', 'float', shadow).setGroup(renderGroup);\n  const texelSize = vec2(1).div(mapSize);\n  const dx0 = texelSize.x.negate().mul(radius);\n  const dy0 = texelSize.y.negate().mul(radius);\n  const dx1 = texelSize.x.mul(radius);\n  const dy1 = texelSize.y.mul(radius);\n  const dx2 = dx0.div(2);\n  const dy2 = dy0.div(2);\n  const dx3 = dx1.div(2);\n  const dy3 = dy1.div(2);\n  return add(depthCompare(shadowCoord.xy.add(vec2(dx0, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx1, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx2, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx3, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx0, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx2, 0)), shadowCoord.z), depthCompare(shadowCoord.xy, shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx3, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx1, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx2, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx3, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx0, dy1)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy1)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx1, dy1)), shadowCoord.z)).mul(1 / 17);\n});\nconst PCFSoftShadowFilter = /*@__PURE__*/Fn(_ref132 => {\n  let {\n    depthTexture,\n    shadowCoord,\n    shadow\n  } = _ref132;\n  const depthCompare = (uv, compare) => texture(depthTexture, uv).compare(compare);\n  const mapSize = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);\n  const texelSize = vec2(1).div(mapSize);\n  const dx = texelSize.x;\n  const dy = texelSize.y;\n  const uv = shadowCoord.xy;\n  const f = fract(uv.mul(mapSize).add(0.5));\n  uv.subAssign(f.mul(texelSize));\n  return add(depthCompare(uv, shadowCoord.z), depthCompare(uv.add(vec2(dx, 0)), shadowCoord.z), depthCompare(uv.add(vec2(0, dy)), shadowCoord.z), depthCompare(uv.add(texelSize), shadowCoord.z), mix(depthCompare(uv.add(vec2(dx.negate(), 0)), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), 0)), shadowCoord.z), f.x), mix(depthCompare(uv.add(vec2(dx.negate(), dy)), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), dy)), shadowCoord.z), f.x), mix(depthCompare(uv.add(vec2(0, dy.negate())), shadowCoord.z), depthCompare(uv.add(vec2(0, dy.mul(2))), shadowCoord.z), f.y), mix(depthCompare(uv.add(vec2(dx, dy.negate())), shadowCoord.z), depthCompare(uv.add(vec2(dx, dy.mul(2))), shadowCoord.z), f.y), mix(mix(depthCompare(uv.add(vec2(dx.negate(), dy.negate())), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), dy.negate())), shadowCoord.z), f.x), mix(depthCompare(uv.add(vec2(dx.negate(), dy.mul(2))), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), dy.mul(2))), shadowCoord.z), f.x), f.y)).mul(1 / 9);\n});\n\n// VSM\n\nconst VSMShadowFilter = /*@__PURE__*/Fn(_ref133 => {\n  let {\n    depthTexture,\n    shadowCoord\n  } = _ref133;\n  const occlusion = float(1).toVar();\n  const distribution = texture(depthTexture).uv(shadowCoord.xy).rg;\n  const hardShadow = step(shadowCoord.z, distribution.x);\n  If(hardShadow.notEqual(float(1.0)), () => {\n    const distance = shadowCoord.z.sub(distribution.x);\n    const variance = max$1(0, distribution.y.mul(distribution.y));\n    let softnessProbability = variance.div(variance.add(distance.mul(distance))); // Chebeyshevs inequality\n    softnessProbability = clamp(sub(softnessProbability, 0.3).div(0.95 - 0.3));\n    occlusion.assign(clamp(max$1(hardShadow, softnessProbability)));\n  });\n  return occlusion;\n});\nconst VSMPassVertical = /*@__PURE__*/Fn(_ref134 => {\n  let {\n    samples,\n    radius,\n    size,\n    shadowPass\n  } = _ref134;\n  const mean = float(0).toVar();\n  const squaredMean = float(0).toVar();\n  const uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));\n  const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));\n  Loop({\n    start: int(0),\n    end: int(samples),\n    type: 'int',\n    condition: '<'\n  }, _ref135 => {\n    let {\n      i\n    } = _ref135;\n    const uvOffset = uvStart.add(float(i).mul(uvStride));\n    const depth = shadowPass.uv(add(screenCoordinate.xy, vec2(0, uvOffset).mul(radius)).div(size)).x;\n    mean.addAssign(depth);\n    squaredMean.addAssign(depth.mul(depth));\n  });\n  mean.divAssign(samples);\n  squaredMean.divAssign(samples);\n  const std_dev = sqrt(squaredMean.sub(mean.mul(mean)));\n  return vec2(mean, std_dev);\n});\nconst VSMPassHorizontal = /*@__PURE__*/Fn(_ref136 => {\n  let {\n    samples,\n    radius,\n    size,\n    shadowPass\n  } = _ref136;\n  const mean = float(0).toVar();\n  const squaredMean = float(0).toVar();\n  const uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));\n  const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));\n  Loop({\n    start: int(0),\n    end: int(samples),\n    type: 'int',\n    condition: '<'\n  }, _ref137 => {\n    let {\n      i\n    } = _ref137;\n    const uvOffset = uvStart.add(float(i).mul(uvStride));\n    const distribution = shadowPass.uv(add(screenCoordinate.xy, vec2(uvOffset, 0).mul(radius)).div(size));\n    mean.addAssign(distribution.x);\n    squaredMean.addAssign(add(distribution.y.mul(distribution.y), distribution.x.mul(distribution.x)));\n  });\n  mean.divAssign(samples);\n  squaredMean.divAssign(samples);\n  const std_dev = sqrt(squaredMean.sub(mean.mul(mean)));\n  return vec2(mean, std_dev);\n});\nconst _shadowFilterLib = [BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter];\n\n//\n\nconst _quadMesh$1 = /*@__PURE__*/new QuadMesh();\nclass ShadowNode extends Node {\n  static get type() {\n    return 'ShadowNode';\n  }\n  constructor(light) {\n    let shadow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super();\n    this.light = light;\n    this.shadow = shadow || light.shadow;\n    this.shadowMap = null;\n    this.vsmShadowMapVertical = null;\n    this.vsmShadowMapHorizontal = null;\n    this.vsmMaterialVertical = null;\n    this.vsmMaterialHorizontal = null;\n    this.updateBeforeType = NodeUpdateType.RENDER;\n    this._node = null;\n    this.isShadowNode = true;\n  }\n  setupShadowFilter(builder, _ref138) {\n    let {\n      filterFn,\n      depthTexture,\n      shadowCoord,\n      shadow\n    } = _ref138;\n    const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));\n    const shadowNode = filterFn({\n      depthTexture,\n      shadowCoord,\n      shadow\n    });\n    return frustumTest.select(shadowNode, float(1));\n  }\n  setupShadowCoord(builder, shadowPosition) {\n    const {\n      shadow\n    } = this;\n    const {\n      renderer\n    } = builder;\n    const bias = reference('bias', 'float', shadow).setGroup(renderGroup);\n    let shadowCoord = shadowPosition;\n    let coordZ;\n    if (shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true) {\n      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);\n      coordZ = shadowCoord.z;\n      if (renderer.coordinateSystem === WebGPUCoordinateSystem) {\n        coordZ = coordZ.mul(2).sub(1); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]\n      }\n    } else {\n      const w = shadowCoord.w;\n      shadowCoord = shadowCoord.xy.div(w); // <-- Only divide X/Y coords since we don't need Z\n\n      // The normally available \"cameraNear\" and \"cameraFar\" nodes cannot be used here because they do not get\n      // updated to use the shadow camera. So, we have to declare our own \"local\" ones here.\n      // TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?\n      const cameraNearLocal = reference('near', 'float', shadow.camera).setGroup(renderGroup);\n      const cameraFarLocal = reference('far', 'float', shadow.camera).setGroup(renderGroup);\n      coordZ = viewZToLogarithmicDepth(w.negate(), cameraNearLocal, cameraFarLocal);\n    }\n    shadowCoord = vec3(shadowCoord.x, shadowCoord.y.oneMinus(),\n    // follow webgpu standards\n    coordZ.add(bias));\n    return shadowCoord;\n  }\n  getShadowFilterFn(type) {\n    return _shadowFilterLib[type];\n  }\n  setupShadow(builder) {\n    const {\n      renderer\n    } = builder;\n    const {\n      light,\n      shadow\n    } = this;\n    const shadowMapType = renderer.shadowMap.type;\n    const depthTexture = new DepthTexture(shadow.mapSize.width, shadow.mapSize.height);\n    depthTexture.compareFunction = LessCompare;\n    const shadowMap = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height);\n    shadowMap.depthTexture = depthTexture;\n    shadow.camera.updateProjectionMatrix();\n\n    // VSM\n\n    if (shadowMapType === VSMShadowMap) {\n      depthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()\n\n      this.vsmShadowMapVertical = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height, {\n        format: RGFormat,\n        type: HalfFloatType\n      });\n      this.vsmShadowMapHorizontal = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height, {\n        format: RGFormat,\n        type: HalfFloatType\n      });\n      const shadowPassVertical = texture(depthTexture);\n      const shadowPassHorizontal = texture(this.vsmShadowMapVertical.texture);\n      const samples = reference('blurSamples', 'float', shadow).setGroup(renderGroup);\n      const radius = reference('radius', 'float', shadow).setGroup(renderGroup);\n      const size = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);\n      let material = this.vsmMaterialVertical || (this.vsmMaterialVertical = new NodeMaterial());\n      material.fragmentNode = VSMPassVertical({\n        samples,\n        radius,\n        size,\n        shadowPass: shadowPassVertical\n      }).context(builder.getSharedContext());\n      material.name = 'VSMVertical';\n      material = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new NodeMaterial());\n      material.fragmentNode = VSMPassHorizontal({\n        samples,\n        radius,\n        size,\n        shadowPass: shadowPassHorizontal\n      }).context(builder.getSharedContext());\n      material.name = 'VSMHorizontal';\n    }\n\n    //\n\n    const shadowIntensity = reference('intensity', 'float', shadow).setGroup(renderGroup);\n    const normalBias = reference('normalBias', 'float', shadow).setGroup(renderGroup);\n    const shadowPosition = lightShadowMatrix(light).mul(shadowWorldPosition.add(transformedNormalWorld.mul(normalBias)));\n    const shadowCoord = this.setupShadowCoord(builder, shadowPosition);\n\n    //\n\n    const filterFn = shadow.filterNode || this.getShadowFilterFn(renderer.shadowMap.type) || null;\n    if (filterFn === null) {\n      throw new Error('THREE.WebGPURenderer: Shadow map type not supported yet.');\n    }\n    const shadowDepthTexture = shadowMapType === VSMShadowMap ? this.vsmShadowMapHorizontal.texture : depthTexture;\n    const shadowNode = this.setupShadowFilter(builder, {\n      filterFn,\n      shadowTexture: shadowMap.texture,\n      depthTexture: shadowDepthTexture,\n      shadowCoord,\n      shadow\n    });\n    const shadowColor = texture(shadowMap.texture, shadowCoord);\n    const shadowOutput = mix(1, shadowNode.rgb.mix(shadowColor, 1), shadowIntensity.mul(shadowColor.a)).toVar();\n    this.shadowMap = shadowMap;\n    this.shadow.map = shadowMap;\n    return shadowOutput;\n  }\n  setup(builder) {\n    if (builder.renderer.shadowMap.enabled === false) return;\n    return Fn(_ref139 => {\n      let {\n        material\n      } = _ref139;\n      shadowWorldPosition.assign(material.shadowPositionNode || positionWorld);\n      let node = this._node;\n      if (node === null) {\n        this._node = node = this.setupShadow(builder);\n      }\n      if (builder.material.shadowNode) {\n        // @deprecated, r171\n\n        console.warn('THREE.NodeMaterial: \".shadowNode\" is deprecated. Use \".castShadowNode\" instead.');\n      }\n      if (builder.material.receivedShadowNode) {\n        node = builder.material.receivedShadowNode(node);\n      }\n      return node;\n    })();\n  }\n  renderShadow(frame) {\n    const {\n      shadow,\n      shadowMap\n    } = this;\n    const {\n      renderer,\n      scene\n    } = frame;\n    shadowMap.setSize(shadow.mapSize.width, shadow.mapSize.height);\n    renderer.render(scene, shadow.camera);\n  }\n  updateShadow(frame) {\n    const {\n      shadowMap,\n      light,\n      shadow\n    } = this;\n    const {\n      renderer,\n      scene,\n      camera\n    } = frame;\n    const shadowType = renderer.shadowMap.type;\n    const depthVersion = shadowMap.depthTexture.version;\n    this._depthVersionCached = depthVersion;\n    const currentOverrideMaterial = scene.overrideMaterial;\n    scene.overrideMaterial = getShadowMaterial(light);\n    shadow.camera.layers.mask = camera.layers.mask;\n    const currentRenderTarget = renderer.getRenderTarget();\n    const currentRenderObjectFunction = renderer.getRenderObjectFunction();\n    const currentMRT = renderer.getMRT();\n    renderer.setMRT(null);\n    renderer.setRenderObjectFunction(function (object) {\n      if (object.castShadow === true || object.receiveShadow && shadowType === VSMShadowMap) {\n        for (var _len32 = arguments.length, params = new Array(_len32 > 1 ? _len32 - 1 : 0), _key32 = 1; _key32 < _len32; _key32++) {\n          params[_key32 - 1] = arguments[_key32];\n        }\n        renderer.renderObject(object, ...params);\n      }\n    });\n    renderer.setRenderTarget(shadowMap);\n    this.renderShadow(frame);\n    renderer.setRenderObjectFunction(currentRenderObjectFunction);\n\n    // vsm blur pass\n\n    if (light.isPointLight !== true && shadowType === VSMShadowMap) {\n      this.vsmPass(renderer);\n    }\n    renderer.setRenderTarget(currentRenderTarget);\n    renderer.setMRT(currentMRT);\n    scene.overrideMaterial = currentOverrideMaterial;\n  }\n  vsmPass(renderer) {\n    const {\n      shadow\n    } = this;\n    this.vsmShadowMapVertical.setSize(shadow.mapSize.width, shadow.mapSize.height);\n    this.vsmShadowMapHorizontal.setSize(shadow.mapSize.width, shadow.mapSize.height);\n    renderer.setRenderTarget(this.vsmShadowMapVertical);\n    _quadMesh$1.material = this.vsmMaterialVertical;\n    _quadMesh$1.render(renderer);\n    renderer.setRenderTarget(this.vsmShadowMapHorizontal);\n    _quadMesh$1.material = this.vsmMaterialHorizontal;\n    _quadMesh$1.render(renderer);\n  }\n  dispose() {\n    this.shadowMap.dispose();\n    this.shadowMap = null;\n    if (this.vsmShadowMapVertical !== null) {\n      this.vsmShadowMapVertical.dispose();\n      this.vsmShadowMapVertical = null;\n      this.vsmMaterialVertical.dispose();\n      this.vsmMaterialVertical = null;\n    }\n    if (this.vsmShadowMapHorizontal !== null) {\n      this.vsmShadowMapHorizontal.dispose();\n      this.vsmShadowMapHorizontal = null;\n      this.vsmMaterialHorizontal.dispose();\n      this.vsmMaterialHorizontal = null;\n    }\n    this.updateBeforeType = NodeUpdateType.NONE;\n  }\n  updateBefore(frame) {\n    const {\n      shadow\n    } = this;\n    const needsUpdate = shadow.needsUpdate || shadow.autoUpdate;\n    if (needsUpdate) {\n      this.updateShadow(frame);\n      if (this.shadowMap.depthTexture.version === this._depthVersionCached) {\n        shadow.needsUpdate = false;\n      }\n    }\n  }\n}\nconst shadow = (light, shadow) => nodeObject(new ShadowNode(light, shadow));\nclass AnalyticLightNode extends LightingNode {\n  static get type() {\n    return 'AnalyticLightNode';\n  }\n  constructor() {\n    let light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this.light = light;\n    this.color = new Color();\n    this.colorNode = light && light.colorNode || uniform(this.color).setGroup(renderGroup);\n    this.baseColorNode = null;\n    this.shadowNode = null;\n    this.shadowColorNode = null;\n    this.isAnalyticLightNode = true;\n    this.updateType = NodeUpdateType.FRAME;\n  }\n  getCacheKey() {\n    return hash$1(super.getCacheKey(), this.light.id, this.light.castShadow ? 1 : 0);\n  }\n  getHash() {\n    return this.light.uuid;\n  }\n  setupShadowNode() {\n    return shadow(this.light);\n  }\n  setupShadow(builder) {\n    const {\n      renderer\n    } = builder;\n    if (renderer.shadowMap.enabled === false) return;\n    let shadowColorNode = this.shadowColorNode;\n    if (shadowColorNode === null) {\n      const customShadowNode = this.light.shadow.shadowNode;\n      let shadowNode;\n      if (customShadowNode !== undefined) {\n        shadowNode = nodeObject(customShadowNode);\n      } else {\n        shadowNode = this.setupShadowNode(builder);\n      }\n      this.shadowNode = shadowNode;\n      this.shadowColorNode = shadowColorNode = this.colorNode.mul(shadowNode);\n      this.baseColorNode = this.colorNode;\n    }\n\n    //\n\n    this.colorNode = shadowColorNode;\n  }\n  setup(builder) {\n    this.colorNode = this.baseColorNode || this.colorNode;\n    if (this.light.castShadow) {\n      if (builder.object.receiveShadow) {\n        this.setupShadow(builder);\n      }\n    } else if (this.shadowNode !== null) {\n      this.shadowNode.dispose();\n      this.shadowNode = null;\n      this.shadowColorNode = null;\n    }\n  }\n  update(/*frame*/\n  ) {\n    const {\n      light\n    } = this;\n    this.color.copy(light.color).multiplyScalar(light.intensity);\n  }\n}\nconst getDistanceAttenuation = /*@__PURE__*/Fn(inputs => {\n  const {\n    lightDistance,\n    cutoffDistance,\n    decayExponent\n  } = inputs;\n\n  // based upon Frostbite 3 Moving to Physically-based Rendering\n  // page 32, equation 26: E[window1]\n  // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n  const distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();\n  return cutoffDistance.greaterThan(0).select(distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()), distanceFalloff);\n}); // validated\n\nconst _clearColor$2 = /*@__PURE__*/new Color();\n\n// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n// vector suitable for 2D texture mapping. This code uses the following layout for the\n// 2D texture:\n//\n// xzXZ\n//  y Y\n//\n// Y - Positive y direction\n// y - Negative y direction\n// X - Positive x direction\n// x - Negative x direction\n// Z - Positive z direction\n// z - Negative z direction\n//\n// Source and test bed:\n// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\nconst cubeToUV = /*@__PURE__*/Fn(_ref140 => {\n  let [pos, texelSizeY] = _ref140;\n  const v = pos.toVar();\n\n  // Number of texels to avoid at the edge of each square\n\n  const absV = abs(v);\n\n  // Intersect unit cube\n\n  const scaleToCube = div(1.0, max$1(absV.x, max$1(absV.y, absV.z)));\n  absV.mulAssign(scaleToCube);\n\n  // Apply scale to avoid seams\n\n  // two texels less per square (one texel will do for NEAREST)\n  v.mulAssign(scaleToCube.mul(texelSizeY.mul(2).oneMinus()));\n\n  // Unwrap\n\n  // space: -1 ... 1 range for each square\n  //\n  // #X##\t\tdim    := ( 4 , 2 )\n  //  # #\t\tcenter := ( 1 , 1 )\n\n  const planar = vec2(v.xy).toVar();\n  const almostATexel = texelSizeY.mul(1.5);\n  const almostOne = almostATexel.oneMinus();\n  If(absV.z.greaterThanEqual(almostOne), () => {\n    If(v.z.greaterThan(0.0), () => {\n      planar.x.assign(sub(4.0, v.x));\n    });\n  }).ElseIf(absV.x.greaterThanEqual(almostOne), () => {\n    const signX = sign(v.x);\n    planar.x.assign(v.z.mul(signX).add(signX.mul(2.0)));\n  }).ElseIf(absV.y.greaterThanEqual(almostOne), () => {\n    const signY = sign(v.y);\n    planar.x.assign(v.x.add(signY.mul(2.0)).add(2.0));\n    planar.y.assign(v.z.mul(signY).sub(2.0));\n  });\n\n  // Transform to UV space\n\n  // scale := 0.5 / dim\n  // translate := ( center + 0.5 ) / dim\n  return vec2(0.125, 0.25).mul(planar).add(vec2(0.375, 0.75)).flipY();\n}).setLayout({\n  name: 'cubeToUV',\n  type: 'vec2',\n  inputs: [{\n    name: 'pos',\n    type: 'vec3'\n  }, {\n    name: 'texelSizeY',\n    type: 'float'\n  }]\n});\nconst BasicPointShadowFilter = /*@__PURE__*/Fn(_ref141 => {\n  let {\n    depthTexture,\n    bd3D,\n    dp,\n    texelSize\n  } = _ref141;\n  return texture(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp);\n});\nconst PointShadowFilter = /*@__PURE__*/Fn(_ref142 => {\n  let {\n    depthTexture,\n    bd3D,\n    dp,\n    texelSize,\n    shadow\n  } = _ref142;\n  const radius = reference('radius', 'float', shadow).setGroup(renderGroup);\n  const offset = vec2(-1.0, 1.0).mul(radius).mul(texelSize.y);\n  return texture(depthTexture, cubeToUV(bd3D.add(offset.xyy), texelSize.y)).compare(dp).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yyy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xyx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yyx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xxy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yxy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xxx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yxx), texelSize.y)).compare(dp)).mul(1.0 / 9.0);\n});\nconst pointShadowFilter = /*@__PURE__*/Fn(_ref143 => {\n  let {\n    filterFn,\n    depthTexture,\n    shadowCoord,\n    shadow\n  } = _ref143;\n  // for point lights, the uniform @vShadowCoord is re-purposed to hold\n  // the vector from the light to the world-space position of the fragment.\n  const lightToPosition = shadowCoord.xyz.toVar();\n  const lightToPositionLength = lightToPosition.length();\n  const cameraNearLocal = uniform('float').setGroup(renderGroup).onRenderUpdate(() => shadow.camera.near);\n  const cameraFarLocal = uniform('float').setGroup(renderGroup).onRenderUpdate(() => shadow.camera.far);\n  const bias = reference('bias', 'float', shadow).setGroup(renderGroup);\n  const mapSize = uniform(shadow.mapSize).setGroup(renderGroup);\n  const result = float(1.0).toVar();\n  If(lightToPositionLength.sub(cameraFarLocal).lessThanEqual(0.0).and(lightToPositionLength.sub(cameraNearLocal).greaterThanEqual(0.0)), () => {\n    // dp = normalized distance from light to fragment position\n    const dp = lightToPositionLength.sub(cameraNearLocal).div(cameraFarLocal.sub(cameraNearLocal)).toVar(); // need to clamp?\n    dp.addAssign(bias);\n\n    // bd3D = base direction 3D\n    const bd3D = lightToPosition.normalize();\n    const texelSize = vec2(1.0).div(mapSize.mul(vec2(4.0, 2.0)));\n\n    // percentage-closer filtering\n    result.assign(filterFn({\n      depthTexture,\n      bd3D,\n      dp,\n      texelSize,\n      shadow\n    }));\n  });\n  return result;\n});\nconst _viewport = /*@__PURE__*/new Vector4();\nconst _viewportSize = /*@__PURE__*/new Vector2();\nconst _shadowMapSize = /*@__PURE__*/new Vector2();\n\n//\n\nclass PointShadowNode extends ShadowNode {\n  static get type() {\n    return 'PointShadowNode';\n  }\n  constructor(light) {\n    let shadow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(light, shadow);\n  }\n  getShadowFilterFn(type) {\n    return type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;\n  }\n  setupShadowCoord(builder, shadowPosition) {\n    return shadowPosition;\n  }\n  setupShadowFilter(builder, _ref144) {\n    let {\n      filterFn,\n      shadowTexture,\n      depthTexture,\n      shadowCoord,\n      shadow\n    } = _ref144;\n    return pointShadowFilter({\n      filterFn,\n      shadowTexture,\n      depthTexture,\n      shadowCoord,\n      shadow\n    });\n  }\n  renderShadow(frame) {\n    const {\n      shadow,\n      shadowMap,\n      light\n    } = this;\n    const {\n      renderer,\n      scene\n    } = frame;\n    const shadowFrameExtents = shadow.getFrameExtents();\n    _shadowMapSize.copy(shadow.mapSize);\n    _shadowMapSize.multiply(shadowFrameExtents);\n    shadowMap.setSize(_shadowMapSize.width, _shadowMapSize.height);\n    _viewportSize.copy(shadow.mapSize);\n\n    //\n\n    const previousAutoClear = renderer.autoClear;\n    const previousClearColor = renderer.getClearColor(_clearColor$2);\n    const previousClearAlpha = renderer.getClearAlpha();\n    renderer.autoClear = false;\n    renderer.setClearColor(shadow.clearColor, shadow.clearAlpha);\n    renderer.clear();\n    const viewportCount = shadow.getViewportCount();\n    for (let vp = 0; vp < viewportCount; vp++) {\n      const viewport = shadow.getViewport(vp);\n      const x = _viewportSize.x * viewport.x;\n      const y = _shadowMapSize.y - _viewportSize.y - _viewportSize.y * viewport.y;\n      _viewport.set(x, y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);\n      shadowMap.viewport.copy(_viewport);\n      shadow.updateMatrices(light, vp);\n      renderer.render(scene, shadow.camera);\n    }\n\n    //\n\n    renderer.autoClear = previousAutoClear;\n    renderer.setClearColor(previousClearColor, previousClearAlpha);\n  }\n}\nconst pointShadow = (light, shadow) => nodeObject(new PointShadowNode(light, shadow));\nconst directPointLight = Fn((_ref145, builder) => {\n  let {\n    color,\n    lightViewPosition,\n    cutoffDistance,\n    decayExponent\n  } = _ref145;\n  const lightingModel = builder.context.lightingModel;\n  const lVector = lightViewPosition.sub(positionView); // @TODO: Add it into LightNode\n\n  const lightDirection = lVector.normalize();\n  const lightDistance = lVector.length();\n  const lightAttenuation = getDistanceAttenuation({\n    lightDistance,\n    cutoffDistance,\n    decayExponent\n  });\n  const lightColor = color.mul(lightAttenuation);\n  const reflectedLight = builder.context.reflectedLight;\n  lightingModel.direct({\n    lightDirection,\n    lightColor,\n    reflectedLight\n  }, builder.stack, builder);\n});\nclass PointLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'PointLightNode';\n  }\n  constructor() {\n    let light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(light);\n    this.cutoffDistanceNode = uniform(0).setGroup(renderGroup);\n    this.decayExponentNode = uniform(0).setGroup(renderGroup);\n  }\n  update(frame) {\n    const {\n      light\n    } = this;\n    super.update(frame);\n    this.cutoffDistanceNode.value = light.distance;\n    this.decayExponentNode.value = light.decay;\n  }\n  setupShadowNode() {\n    return pointShadow(this.light);\n  }\n  setup(builder) {\n    super.setup(builder);\n    directPointLight({\n      color: this.colorNode,\n      lightViewPosition: lightViewPosition(this.light),\n      cutoffDistance: this.cutoffDistanceNode,\n      decayExponent: this.decayExponentNode\n    }).append();\n  }\n}\nconst checker = /*@__PURE__*/Fn(_ref146 => {\n  let [coord = uv()] = _ref146;\n  return function () {\n    const uv = coord.mul(2.0);\n    const cx = uv.x.floor();\n    const cy = uv.y.floor();\n    const result = cx.add(cy).mod(2.0);\n    return result.sign();\n  }();\n});\n\n// Three.js Transpiler\n// https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/libraries/stdlib/genglsl/lib/mx_noise.glsl\n\nconst mx_select = /*@__PURE__*/Fn(_ref147 => {\n  let [b_immutable, t_immutable, f_immutable] = _ref147;\n  const f = float(f_immutable).toVar();\n  const t = float(t_immutable).toVar();\n  const b = bool(b_immutable).toVar();\n  return select(b, t, f);\n}).setLayout({\n  name: 'mx_select',\n  type: 'float',\n  inputs: [{\n    name: 'b',\n    type: 'bool'\n  }, {\n    name: 't',\n    type: 'float'\n  }, {\n    name: 'f',\n    type: 'float'\n  }]\n});\nconst mx_negate_if = /*@__PURE__*/Fn(_ref148 => {\n  let [val_immutable, b_immutable] = _ref148;\n  const b = bool(b_immutable).toVar();\n  const val = float(val_immutable).toVar();\n  return select(b, val.negate(), val);\n}).setLayout({\n  name: 'mx_negate_if',\n  type: 'float',\n  inputs: [{\n    name: 'val',\n    type: 'float'\n  }, {\n    name: 'b',\n    type: 'bool'\n  }]\n});\nconst mx_floor = /*@__PURE__*/Fn(_ref149 => {\n  let [x_immutable] = _ref149;\n  const x = float(x_immutable).toVar();\n  return int(floor(x));\n}).setLayout({\n  name: 'mx_floor',\n  type: 'int',\n  inputs: [{\n    name: 'x',\n    type: 'float'\n  }]\n});\nconst mx_floorfrac = /*@__PURE__*/Fn(_ref150 => {\n  let [x_immutable, i] = _ref150;\n  const x = float(x_immutable).toVar();\n  i.assign(mx_floor(x));\n  return x.sub(float(i));\n});\nconst mx_bilerp_0 = /*@__PURE__*/Fn(_ref151 => {\n  let [v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable] = _ref151;\n  const t = float(t_immutable).toVar();\n  const s = float(s_immutable).toVar();\n  const v3 = float(v3_immutable).toVar();\n  const v2 = float(v2_immutable).toVar();\n  const v1 = float(v1_immutable).toVar();\n  const v0 = float(v0_immutable).toVar();\n  const s1 = float(sub(1.0, s)).toVar();\n  return sub(1.0, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));\n}).setLayout({\n  name: 'mx_bilerp_0',\n  type: 'float',\n  inputs: [{\n    name: 'v0',\n    type: 'float'\n  }, {\n    name: 'v1',\n    type: 'float'\n  }, {\n    name: 'v2',\n    type: 'float'\n  }, {\n    name: 'v3',\n    type: 'float'\n  }, {\n    name: 's',\n    type: 'float'\n  }, {\n    name: 't',\n    type: 'float'\n  }]\n});\nconst mx_bilerp_1 = /*@__PURE__*/Fn(_ref152 => {\n  let [v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable] = _ref152;\n  const t = float(t_immutable).toVar();\n  const s = float(s_immutable).toVar();\n  const v3 = vec3(v3_immutable).toVar();\n  const v2 = vec3(v2_immutable).toVar();\n  const v1 = vec3(v1_immutable).toVar();\n  const v0 = vec3(v0_immutable).toVar();\n  const s1 = float(sub(1.0, s)).toVar();\n  return sub(1.0, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));\n}).setLayout({\n  name: 'mx_bilerp_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'v0',\n    type: 'vec3'\n  }, {\n    name: 'v1',\n    type: 'vec3'\n  }, {\n    name: 'v2',\n    type: 'vec3'\n  }, {\n    name: 'v3',\n    type: 'vec3'\n  }, {\n    name: 's',\n    type: 'float'\n  }, {\n    name: 't',\n    type: 'float'\n  }]\n});\nconst mx_bilerp = /*@__PURE__*/overloadingFn([mx_bilerp_0, mx_bilerp_1]);\nconst mx_trilerp_0 = /*@__PURE__*/Fn(_ref153 => {\n  let [v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable] = _ref153;\n  const r = float(r_immutable).toVar();\n  const t = float(t_immutable).toVar();\n  const s = float(s_immutable).toVar();\n  const v7 = float(v7_immutable).toVar();\n  const v6 = float(v6_immutable).toVar();\n  const v5 = float(v5_immutable).toVar();\n  const v4 = float(v4_immutable).toVar();\n  const v3 = float(v3_immutable).toVar();\n  const v2 = float(v2_immutable).toVar();\n  const v1 = float(v1_immutable).toVar();\n  const v0 = float(v0_immutable).toVar();\n  const s1 = float(sub(1.0, s)).toVar();\n  const t1 = float(sub(1.0, t)).toVar();\n  const r1 = float(sub(1.0, r)).toVar();\n  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));\n}).setLayout({\n  name: 'mx_trilerp_0',\n  type: 'float',\n  inputs: [{\n    name: 'v0',\n    type: 'float'\n  }, {\n    name: 'v1',\n    type: 'float'\n  }, {\n    name: 'v2',\n    type: 'float'\n  }, {\n    name: 'v3',\n    type: 'float'\n  }, {\n    name: 'v4',\n    type: 'float'\n  }, {\n    name: 'v5',\n    type: 'float'\n  }, {\n    name: 'v6',\n    type: 'float'\n  }, {\n    name: 'v7',\n    type: 'float'\n  }, {\n    name: 's',\n    type: 'float'\n  }, {\n    name: 't',\n    type: 'float'\n  }, {\n    name: 'r',\n    type: 'float'\n  }]\n});\nconst mx_trilerp_1 = /*@__PURE__*/Fn(_ref154 => {\n  let [v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable] = _ref154;\n  const r = float(r_immutable).toVar();\n  const t = float(t_immutable).toVar();\n  const s = float(s_immutable).toVar();\n  const v7 = vec3(v7_immutable).toVar();\n  const v6 = vec3(v6_immutable).toVar();\n  const v5 = vec3(v5_immutable).toVar();\n  const v4 = vec3(v4_immutable).toVar();\n  const v3 = vec3(v3_immutable).toVar();\n  const v2 = vec3(v2_immutable).toVar();\n  const v1 = vec3(v1_immutable).toVar();\n  const v0 = vec3(v0_immutable).toVar();\n  const s1 = float(sub(1.0, s)).toVar();\n  const t1 = float(sub(1.0, t)).toVar();\n  const r1 = float(sub(1.0, r)).toVar();\n  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));\n}).setLayout({\n  name: 'mx_trilerp_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'v0',\n    type: 'vec3'\n  }, {\n    name: 'v1',\n    type: 'vec3'\n  }, {\n    name: 'v2',\n    type: 'vec3'\n  }, {\n    name: 'v3',\n    type: 'vec3'\n  }, {\n    name: 'v4',\n    type: 'vec3'\n  }, {\n    name: 'v5',\n    type: 'vec3'\n  }, {\n    name: 'v6',\n    type: 'vec3'\n  }, {\n    name: 'v7',\n    type: 'vec3'\n  }, {\n    name: 's',\n    type: 'float'\n  }, {\n    name: 't',\n    type: 'float'\n  }, {\n    name: 'r',\n    type: 'float'\n  }]\n});\nconst mx_trilerp = /*@__PURE__*/overloadingFn([mx_trilerp_0, mx_trilerp_1]);\nconst mx_gradient_float_0 = /*@__PURE__*/Fn(_ref155 => {\n  let [hash_immutable, x_immutable, y_immutable] = _ref155;\n  const y = float(y_immutable).toVar();\n  const x = float(x_immutable).toVar();\n  const hash = uint(hash_immutable).toVar();\n  const h = uint(hash.bitAnd(uint(7))).toVar();\n  const u = float(mx_select(h.lessThan(uint(4)), x, y)).toVar();\n  const v = float(mul(2.0, mx_select(h.lessThan(uint(4)), y, x))).toVar();\n  return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));\n}).setLayout({\n  name: 'mx_gradient_float_0',\n  type: 'float',\n  inputs: [{\n    name: 'hash',\n    type: 'uint'\n  }, {\n    name: 'x',\n    type: 'float'\n  }, {\n    name: 'y',\n    type: 'float'\n  }]\n});\nconst mx_gradient_float_1 = /*@__PURE__*/Fn(_ref156 => {\n  let [hash_immutable, x_immutable, y_immutable, z_immutable] = _ref156;\n  const z = float(z_immutable).toVar();\n  const y = float(y_immutable).toVar();\n  const x = float(x_immutable).toVar();\n  const hash = uint(hash_immutable).toVar();\n  const h = uint(hash.bitAnd(uint(15))).toVar();\n  const u = float(mx_select(h.lessThan(uint(8)), x, y)).toVar();\n  const v = float(mx_select(h.lessThan(uint(4)), y, mx_select(h.equal(uint(12)).or(h.equal(uint(14))), x, z))).toVar();\n  return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));\n}).setLayout({\n  name: 'mx_gradient_float_1',\n  type: 'float',\n  inputs: [{\n    name: 'hash',\n    type: 'uint'\n  }, {\n    name: 'x',\n    type: 'float'\n  }, {\n    name: 'y',\n    type: 'float'\n  }, {\n    name: 'z',\n    type: 'float'\n  }]\n});\nconst mx_gradient_float = /*@__PURE__*/overloadingFn([mx_gradient_float_0, mx_gradient_float_1]);\nconst mx_gradient_vec3_0 = /*@__PURE__*/Fn(_ref157 => {\n  let [hash_immutable, x_immutable, y_immutable] = _ref157;\n  const y = float(y_immutable).toVar();\n  const x = float(x_immutable).toVar();\n  const hash = uvec3(hash_immutable).toVar();\n  return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));\n}).setLayout({\n  name: 'mx_gradient_vec3_0',\n  type: 'vec3',\n  inputs: [{\n    name: 'hash',\n    type: 'uvec3'\n  }, {\n    name: 'x',\n    type: 'float'\n  }, {\n    name: 'y',\n    type: 'float'\n  }]\n});\nconst mx_gradient_vec3_1 = /*@__PURE__*/Fn(_ref158 => {\n  let [hash_immutable, x_immutable, y_immutable, z_immutable] = _ref158;\n  const z = float(z_immutable).toVar();\n  const y = float(y_immutable).toVar();\n  const x = float(x_immutable).toVar();\n  const hash = uvec3(hash_immutable).toVar();\n  return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));\n}).setLayout({\n  name: 'mx_gradient_vec3_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'hash',\n    type: 'uvec3'\n  }, {\n    name: 'x',\n    type: 'float'\n  }, {\n    name: 'y',\n    type: 'float'\n  }, {\n    name: 'z',\n    type: 'float'\n  }]\n});\nconst mx_gradient_vec3 = /*@__PURE__*/overloadingFn([mx_gradient_vec3_0, mx_gradient_vec3_1]);\nconst mx_gradient_scale2d_0 = /*@__PURE__*/Fn(_ref159 => {\n  let [v_immutable] = _ref159;\n  const v = float(v_immutable).toVar();\n  return mul(0.6616, v);\n}).setLayout({\n  name: 'mx_gradient_scale2d_0',\n  type: 'float',\n  inputs: [{\n    name: 'v',\n    type: 'float'\n  }]\n});\nconst mx_gradient_scale3d_0 = /*@__PURE__*/Fn(_ref160 => {\n  let [v_immutable] = _ref160;\n  const v = float(v_immutable).toVar();\n  return mul(0.9820, v);\n}).setLayout({\n  name: 'mx_gradient_scale3d_0',\n  type: 'float',\n  inputs: [{\n    name: 'v',\n    type: 'float'\n  }]\n});\nconst mx_gradient_scale2d_1 = /*@__PURE__*/Fn(_ref161 => {\n  let [v_immutable] = _ref161;\n  const v = vec3(v_immutable).toVar();\n  return mul(0.6616, v);\n}).setLayout({\n  name: 'mx_gradient_scale2d_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'v',\n    type: 'vec3'\n  }]\n});\nconst mx_gradient_scale2d = /*@__PURE__*/overloadingFn([mx_gradient_scale2d_0, mx_gradient_scale2d_1]);\nconst mx_gradient_scale3d_1 = /*@__PURE__*/Fn(_ref162 => {\n  let [v_immutable] = _ref162;\n  const v = vec3(v_immutable).toVar();\n  return mul(0.9820, v);\n}).setLayout({\n  name: 'mx_gradient_scale3d_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'v',\n    type: 'vec3'\n  }]\n});\nconst mx_gradient_scale3d = /*@__PURE__*/overloadingFn([mx_gradient_scale3d_0, mx_gradient_scale3d_1]);\nconst mx_rotl32 = /*@__PURE__*/Fn(_ref163 => {\n  let [x_immutable, k_immutable] = _ref163;\n  const k = int(k_immutable).toVar();\n  const x = uint(x_immutable).toVar();\n  return x.shiftLeft(k).bitOr(x.shiftRight(int(32).sub(k)));\n}).setLayout({\n  name: 'mx_rotl32',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'uint'\n  }, {\n    name: 'k',\n    type: 'int'\n  }]\n});\nconst mx_bjmix = /*@__PURE__*/Fn(_ref164 => {\n  let [a, b, c] = _ref164;\n  a.subAssign(c);\n  a.bitXorAssign(mx_rotl32(c, int(4)));\n  c.addAssign(b);\n  b.subAssign(a);\n  b.bitXorAssign(mx_rotl32(a, int(6)));\n  a.addAssign(c);\n  c.subAssign(b);\n  c.bitXorAssign(mx_rotl32(b, int(8)));\n  b.addAssign(a);\n  a.subAssign(c);\n  a.bitXorAssign(mx_rotl32(c, int(16)));\n  c.addAssign(b);\n  b.subAssign(a);\n  b.bitXorAssign(mx_rotl32(a, int(19)));\n  a.addAssign(c);\n  c.subAssign(b);\n  c.bitXorAssign(mx_rotl32(b, int(4)));\n  b.addAssign(a);\n});\nconst mx_bjfinal = /*@__PURE__*/Fn(_ref165 => {\n  let [a_immutable, b_immutable, c_immutable] = _ref165;\n  const c = uint(c_immutable).toVar();\n  const b = uint(b_immutable).toVar();\n  const a = uint(a_immutable).toVar();\n  c.bitXorAssign(b);\n  c.subAssign(mx_rotl32(b, int(14)));\n  a.bitXorAssign(c);\n  a.subAssign(mx_rotl32(c, int(11)));\n  b.bitXorAssign(a);\n  b.subAssign(mx_rotl32(a, int(25)));\n  c.bitXorAssign(b);\n  c.subAssign(mx_rotl32(b, int(16)));\n  a.bitXorAssign(c);\n  a.subAssign(mx_rotl32(c, int(4)));\n  b.bitXorAssign(a);\n  b.subAssign(mx_rotl32(a, int(14)));\n  c.bitXorAssign(b);\n  c.subAssign(mx_rotl32(b, int(24)));\n  return c;\n}).setLayout({\n  name: 'mx_bjfinal',\n  type: 'uint',\n  inputs: [{\n    name: 'a',\n    type: 'uint'\n  }, {\n    name: 'b',\n    type: 'uint'\n  }, {\n    name: 'c',\n    type: 'uint'\n  }]\n});\nconst mx_bits_to_01 = /*@__PURE__*/Fn(_ref166 => {\n  let [bits_immutable] = _ref166;\n  const bits = uint(bits_immutable).toVar();\n  return float(bits).div(float(uint(int(0xffffffff))));\n}).setLayout({\n  name: 'mx_bits_to_01',\n  type: 'float',\n  inputs: [{\n    name: 'bits',\n    type: 'uint'\n  }]\n});\nconst mx_fade = /*@__PURE__*/Fn(_ref167 => {\n  let [t_immutable] = _ref167;\n  const t = float(t_immutable).toVar();\n  return t.mul(t).mul(t).mul(t.mul(t.mul(6.0).sub(15.0)).add(10.0));\n}).setLayout({\n  name: 'mx_fade',\n  type: 'float',\n  inputs: [{\n    name: 't',\n    type: 'float'\n  }]\n});\nconst mx_hash_int_0 = /*@__PURE__*/Fn(_ref168 => {\n  let [x_immutable] = _ref168;\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(1)).toVar();\n  const seed = uint(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13))).toVar();\n  return mx_bjfinal(seed.add(uint(x)), seed, seed);\n}).setLayout({\n  name: 'mx_hash_int_0',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }]\n});\nconst mx_hash_int_1 = /*@__PURE__*/Fn(_ref169 => {\n  let [x_immutable, y_immutable] = _ref169;\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(2)).toVar();\n  const a = uint().toVar(),\n    b = uint().toVar(),\n    c = uint().toVar();\n  a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));\n  a.addAssign(uint(x));\n  b.addAssign(uint(y));\n  return mx_bjfinal(a, b, c);\n}).setLayout({\n  name: 'mx_hash_int_1',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }]\n});\nconst mx_hash_int_2 = /*@__PURE__*/Fn(_ref170 => {\n  let [x_immutable, y_immutable, z_immutable] = _ref170;\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(3)).toVar();\n  const a = uint().toVar(),\n    b = uint().toVar(),\n    c = uint().toVar();\n  a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));\n  a.addAssign(uint(x));\n  b.addAssign(uint(y));\n  c.addAssign(uint(z));\n  return mx_bjfinal(a, b, c);\n}).setLayout({\n  name: 'mx_hash_int_2',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }]\n});\nconst mx_hash_int_3 = /*@__PURE__*/Fn(_ref171 => {\n  let [x_immutable, y_immutable, z_immutable, xx_immutable] = _ref171;\n  const xx = int(xx_immutable).toVar();\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(4)).toVar();\n  const a = uint().toVar(),\n    b = uint().toVar(),\n    c = uint().toVar();\n  a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));\n  a.addAssign(uint(x));\n  b.addAssign(uint(y));\n  c.addAssign(uint(z));\n  mx_bjmix(a, b, c);\n  a.addAssign(uint(xx));\n  return mx_bjfinal(a, b, c);\n}).setLayout({\n  name: 'mx_hash_int_3',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }, {\n    name: 'xx',\n    type: 'int'\n  }]\n});\nconst mx_hash_int_4 = /*@__PURE__*/Fn(_ref172 => {\n  let [x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable] = _ref172;\n  const yy = int(yy_immutable).toVar();\n  const xx = int(xx_immutable).toVar();\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(5)).toVar();\n  const a = uint().toVar(),\n    b = uint().toVar(),\n    c = uint().toVar();\n  a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));\n  a.addAssign(uint(x));\n  b.addAssign(uint(y));\n  c.addAssign(uint(z));\n  mx_bjmix(a, b, c);\n  a.addAssign(uint(xx));\n  b.addAssign(uint(yy));\n  return mx_bjfinal(a, b, c);\n}).setLayout({\n  name: 'mx_hash_int_4',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }, {\n    name: 'xx',\n    type: 'int'\n  }, {\n    name: 'yy',\n    type: 'int'\n  }]\n});\nconst mx_hash_int = /*@__PURE__*/overloadingFn([mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4]);\nconst mx_hash_vec3_0 = /*@__PURE__*/Fn(_ref173 => {\n  let [x_immutable, y_immutable] = _ref173;\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const h = uint(mx_hash_int(x, y)).toVar();\n  const result = uvec3().toVar();\n  result.x.assign(h.bitAnd(int(0xFF)));\n  result.y.assign(h.shiftRight(int(8)).bitAnd(int(0xFF)));\n  result.z.assign(h.shiftRight(int(16)).bitAnd(int(0xFF)));\n  return result;\n}).setLayout({\n  name: 'mx_hash_vec3_0',\n  type: 'uvec3',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }]\n});\nconst mx_hash_vec3_1 = /*@__PURE__*/Fn(_ref174 => {\n  let [x_immutable, y_immutable, z_immutable] = _ref174;\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const h = uint(mx_hash_int(x, y, z)).toVar();\n  const result = uvec3().toVar();\n  result.x.assign(h.bitAnd(int(0xFF)));\n  result.y.assign(h.shiftRight(int(8)).bitAnd(int(0xFF)));\n  result.z.assign(h.shiftRight(int(16)).bitAnd(int(0xFF)));\n  return result;\n}).setLayout({\n  name: 'mx_hash_vec3_1',\n  type: 'uvec3',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }]\n});\nconst mx_hash_vec3 = /*@__PURE__*/overloadingFn([mx_hash_vec3_0, mx_hash_vec3_1]);\nconst mx_perlin_noise_float_0 = /*@__PURE__*/Fn(_ref175 => {\n  let [p_immutable] = _ref175;\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const fx = float(mx_floorfrac(p.x, X)).toVar();\n  const fy = float(mx_floorfrac(p.y, Y)).toVar();\n  const u = float(mx_fade(fx)).toVar();\n  const v = float(mx_fade(fy)).toVar();\n  const result = float(mx_bilerp(mx_gradient_float(mx_hash_int(X, Y), fx, fy), mx_gradient_float(mx_hash_int(X.add(int(1)), Y), fx.sub(1.0), fy), mx_gradient_float(mx_hash_int(X, Y.add(int(1))), fx, fy.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1))), fx.sub(1.0), fy.sub(1.0)), u, v)).toVar();\n  return mx_gradient_scale2d(result);\n}).setLayout({\n  name: 'mx_perlin_noise_float_0',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }]\n});\nconst mx_perlin_noise_float_1 = /*@__PURE__*/Fn(_ref176 => {\n  let [p_immutable] = _ref176;\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const fx = float(mx_floorfrac(p.x, X)).toVar();\n  const fy = float(mx_floorfrac(p.y, Y)).toVar();\n  const fz = float(mx_floorfrac(p.z, Z)).toVar();\n  const u = float(mx_fade(fx)).toVar();\n  const v = float(mx_fade(fy)).toVar();\n  const w = float(mx_fade(fz)).toVar();\n  const result = float(mx_trilerp(mx_gradient_float(mx_hash_int(X, Y, Z), fx, fy, fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z), fx.sub(1.0), fy, fz), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z), fx, fy.sub(1.0), fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1.0), fy.sub(1.0), fz), mx_gradient_float(mx_hash_int(X, Y, Z.add(int(1))), fx, fy, fz.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1.0), fy, fz.sub(1.0)), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1.0), fz.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1.0), fy.sub(1.0), fz.sub(1.0)), u, v, w)).toVar();\n  return mx_gradient_scale3d(result);\n}).setLayout({\n  name: 'mx_perlin_noise_float_1',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\nconst mx_perlin_noise_float = /*@__PURE__*/overloadingFn([mx_perlin_noise_float_0, mx_perlin_noise_float_1]);\nconst mx_perlin_noise_vec3_0 = /*@__PURE__*/Fn(_ref177 => {\n  let [p_immutable] = _ref177;\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const fx = float(mx_floorfrac(p.x, X)).toVar();\n  const fy = float(mx_floorfrac(p.y, Y)).toVar();\n  const u = float(mx_fade(fx)).toVar();\n  const v = float(mx_fade(fy)).toVar();\n  const result = vec3(mx_bilerp(mx_gradient_vec3(mx_hash_vec3(X, Y), fx, fy), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y), fx.sub(1.0), fy), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1))), fx, fy.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1))), fx.sub(1.0), fy.sub(1.0)), u, v)).toVar();\n  return mx_gradient_scale2d(result);\n}).setLayout({\n  name: 'mx_perlin_noise_vec3_0',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }]\n});\nconst mx_perlin_noise_vec3_1 = /*@__PURE__*/Fn(_ref178 => {\n  let [p_immutable] = _ref178;\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const fx = float(mx_floorfrac(p.x, X)).toVar();\n  const fy = float(mx_floorfrac(p.y, Y)).toVar();\n  const fz = float(mx_floorfrac(p.z, Z)).toVar();\n  const u = float(mx_fade(fx)).toVar();\n  const v = float(mx_fade(fy)).toVar();\n  const w = float(mx_fade(fz)).toVar();\n  const result = vec3(mx_trilerp(mx_gradient_vec3(mx_hash_vec3(X, Y, Z), fx, fy, fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z), fx.sub(1.0), fy, fz), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z), fx, fy.sub(1.0), fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1.0), fy.sub(1.0), fz), mx_gradient_vec3(mx_hash_vec3(X, Y, Z.add(int(1))), fx, fy, fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1.0), fy, fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1.0), fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1.0), fy.sub(1.0), fz.sub(1.0)), u, v, w)).toVar();\n  return mx_gradient_scale3d(result);\n}).setLayout({\n  name: 'mx_perlin_noise_vec3_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\nconst mx_perlin_noise_vec3 = /*@__PURE__*/overloadingFn([mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1]);\nconst mx_cell_noise_float_0 = /*@__PURE__*/Fn(_ref179 => {\n  let [p_immutable] = _ref179;\n  const p = float(p_immutable).toVar();\n  const ix = int(mx_floor(p)).toVar();\n  return mx_bits_to_01(mx_hash_int(ix));\n}).setLayout({\n  name: 'mx_cell_noise_float_0',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'float'\n  }]\n});\nconst mx_cell_noise_float_1 = /*@__PURE__*/Fn(_ref180 => {\n  let [p_immutable] = _ref180;\n  const p = vec2(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  return mx_bits_to_01(mx_hash_int(ix, iy));\n}).setLayout({\n  name: 'mx_cell_noise_float_1',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }]\n});\nconst mx_cell_noise_float_2 = /*@__PURE__*/Fn(_ref181 => {\n  let [p_immutable] = _ref181;\n  const p = vec3(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  const iz = int(mx_floor(p.z)).toVar();\n  return mx_bits_to_01(mx_hash_int(ix, iy, iz));\n}).setLayout({\n  name: 'mx_cell_noise_float_2',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\nconst mx_cell_noise_float_3 = /*@__PURE__*/Fn(_ref182 => {\n  let [p_immutable] = _ref182;\n  const p = vec4(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  const iz = int(mx_floor(p.z)).toVar();\n  const iw = int(mx_floor(p.w)).toVar();\n  return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));\n}).setLayout({\n  name: 'mx_cell_noise_float_3',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec4'\n  }]\n});\nconst mx_cell_noise_float$1 = /*@__PURE__*/overloadingFn([mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3]);\nconst mx_cell_noise_vec3_0 = /*@__PURE__*/Fn(_ref183 => {\n  let [p_immutable] = _ref183;\n  const p = float(p_immutable).toVar();\n  const ix = int(mx_floor(p)).toVar();\n  return vec3(mx_bits_to_01(mx_hash_int(ix, int(0))), mx_bits_to_01(mx_hash_int(ix, int(1))), mx_bits_to_01(mx_hash_int(ix, int(2))));\n}).setLayout({\n  name: 'mx_cell_noise_vec3_0',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'float'\n  }]\n});\nconst mx_cell_noise_vec3_1 = /*@__PURE__*/Fn(_ref184 => {\n  let [p_immutable] = _ref184;\n  const p = vec2(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, int(2))));\n}).setLayout({\n  name: 'mx_cell_noise_vec3_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }]\n});\nconst mx_cell_noise_vec3_2 = /*@__PURE__*/Fn(_ref185 => {\n  let [p_immutable] = _ref185;\n  const p = vec3(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  const iz = int(mx_floor(p.z)).toVar();\n  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(2))));\n}).setLayout({\n  name: 'mx_cell_noise_vec3_2',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\nconst mx_cell_noise_vec3_3 = /*@__PURE__*/Fn(_ref186 => {\n  let [p_immutable] = _ref186;\n  const p = vec4(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  const iz = int(mx_floor(p.z)).toVar();\n  const iw = int(mx_floor(p.w)).toVar();\n  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(2))));\n}).setLayout({\n  name: 'mx_cell_noise_vec3_3',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec4'\n  }]\n});\nconst mx_cell_noise_vec3 = /*@__PURE__*/overloadingFn([mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3]);\nconst mx_fractal_noise_float$1 = /*@__PURE__*/Fn(_ref187 => {\n  let [p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable] = _ref187;\n  const diminish = float(diminish_immutable).toVar();\n  const lacunarity = float(lacunarity_immutable).toVar();\n  const octaves = int(octaves_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const result = float(0.0).toVar();\n  const amplitude = float(1.0).toVar();\n  Loop(octaves, () => {\n    result.addAssign(amplitude.mul(mx_perlin_noise_float(p)));\n    amplitude.mulAssign(diminish);\n    p.mulAssign(lacunarity);\n  });\n  return result;\n}).setLayout({\n  name: 'mx_fractal_noise_float',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'octaves',\n    type: 'int'\n  }, {\n    name: 'lacunarity',\n    type: 'float'\n  }, {\n    name: 'diminish',\n    type: 'float'\n  }]\n});\nconst mx_fractal_noise_vec3$1 = /*@__PURE__*/Fn(_ref188 => {\n  let [p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable] = _ref188;\n  const diminish = float(diminish_immutable).toVar();\n  const lacunarity = float(lacunarity_immutable).toVar();\n  const octaves = int(octaves_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const result = vec3(0.0).toVar();\n  const amplitude = float(1.0).toVar();\n  Loop(octaves, () => {\n    result.addAssign(amplitude.mul(mx_perlin_noise_vec3(p)));\n    amplitude.mulAssign(diminish);\n    p.mulAssign(lacunarity);\n  });\n  return result;\n}).setLayout({\n  name: 'mx_fractal_noise_vec3',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'octaves',\n    type: 'int'\n  }, {\n    name: 'lacunarity',\n    type: 'float'\n  }, {\n    name: 'diminish',\n    type: 'float'\n  }]\n});\nconst mx_fractal_noise_vec2$1 = /*@__PURE__*/Fn(_ref189 => {\n  let [p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable] = _ref189;\n  const diminish = float(diminish_immutable).toVar();\n  const lacunarity = float(lacunarity_immutable).toVar();\n  const octaves = int(octaves_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  return vec2(mx_fractal_noise_float$1(p, octaves, lacunarity, diminish), mx_fractal_noise_float$1(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish));\n}).setLayout({\n  name: 'mx_fractal_noise_vec2',\n  type: 'vec2',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'octaves',\n    type: 'int'\n  }, {\n    name: 'lacunarity',\n    type: 'float'\n  }, {\n    name: 'diminish',\n    type: 'float'\n  }]\n});\nconst mx_fractal_noise_vec4$1 = /*@__PURE__*/Fn(_ref190 => {\n  let [p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable] = _ref190;\n  const diminish = float(diminish_immutable).toVar();\n  const lacunarity = float(lacunarity_immutable).toVar();\n  const octaves = int(octaves_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const c = vec3(mx_fractal_noise_vec3$1(p, octaves, lacunarity, diminish)).toVar();\n  const f = float(mx_fractal_noise_float$1(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish)).toVar();\n  return vec4(c, f);\n}).setLayout({\n  name: 'mx_fractal_noise_vec4',\n  type: 'vec4',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'octaves',\n    type: 'int'\n  }, {\n    name: 'lacunarity',\n    type: 'float'\n  }, {\n    name: 'diminish',\n    type: 'float'\n  }]\n});\nconst mx_worley_distance_0 = /*@__PURE__*/Fn(_ref191 => {\n  let [p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable] = _ref191;\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const yoff = int(yoff_immutable).toVar();\n  const xoff = int(xoff_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const p = vec2(p_immutable).toVar();\n  const tmp = vec3(mx_cell_noise_vec3(vec2(x.add(xoff), y.add(yoff)))).toVar();\n  const off = vec2(tmp.x, tmp.y).toVar();\n  off.subAssign(0.5);\n  off.mulAssign(jitter);\n  off.addAssign(0.5);\n  const cellpos = vec2(vec2(float(x), float(y)).add(off)).toVar();\n  const diff = vec2(cellpos.sub(p)).toVar();\n  If(metric.equal(int(2)), () => {\n    return abs(diff.x).add(abs(diff.y));\n  });\n  If(metric.equal(int(3)), () => {\n    return max$1(abs(diff.x), abs(diff.y));\n  });\n  return dot(diff, diff);\n}).setLayout({\n  name: 'mx_worley_distance_0',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }, {\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'xoff',\n    type: 'int'\n  }, {\n    name: 'yoff',\n    type: 'int'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_distance_1 = /*@__PURE__*/Fn(_ref192 => {\n  let [p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable] = _ref192;\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const zoff = int(zoff_immutable).toVar();\n  const yoff = int(yoff_immutable).toVar();\n  const xoff = int(xoff_immutable).toVar();\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const off = vec3(mx_cell_noise_vec3(vec3(x.add(xoff), y.add(yoff), z.add(zoff)))).toVar();\n  off.subAssign(0.5);\n  off.mulAssign(jitter);\n  off.addAssign(0.5);\n  const cellpos = vec3(vec3(float(x), float(y), float(z)).add(off)).toVar();\n  const diff = vec3(cellpos.sub(p)).toVar();\n  If(metric.equal(int(2)), () => {\n    return abs(diff.x).add(abs(diff.y)).add(abs(diff.z));\n  });\n  If(metric.equal(int(3)), () => {\n    return max$1(max$1(abs(diff.x), abs(diff.y)), abs(diff.z));\n  });\n  return dot(diff, diff);\n}).setLayout({\n  name: 'mx_worley_distance_1',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }, {\n    name: 'xoff',\n    type: 'int'\n  }, {\n    name: 'yoff',\n    type: 'int'\n  }, {\n    name: 'zoff',\n    type: 'int'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_distance = /*@__PURE__*/overloadingFn([mx_worley_distance_0, mx_worley_distance_1]);\nconst mx_worley_noise_float_0 = /*@__PURE__*/Fn(_ref193 => {\n  let [p_immutable, jitter_immutable, metric_immutable] = _ref193;\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();\n  const sqdist = float(1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, _ref194 => {\n    let {\n      x\n    } = _ref194;\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, _ref195 => {\n      let {\n        y\n      } = _ref195;\n      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();\n      sqdist.assign(min$1(sqdist, dist));\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_float_0',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_vec2_0 = /*@__PURE__*/Fn(_ref196 => {\n  let [p_immutable, jitter_immutable, metric_immutable] = _ref196;\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();\n  const sqdist = vec2(1e6, 1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, _ref197 => {\n    let {\n      x\n    } = _ref197;\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, _ref198 => {\n      let {\n        y\n      } = _ref198;\n      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();\n      If(dist.lessThan(sqdist.x), () => {\n        sqdist.y.assign(sqdist.x);\n        sqdist.x.assign(dist);\n      }).ElseIf(dist.lessThan(sqdist.y), () => {\n        sqdist.y.assign(dist);\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_vec2_0',\n  type: 'vec2',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_vec3_0 = /*@__PURE__*/Fn(_ref199 => {\n  let [p_immutable, jitter_immutable, metric_immutable] = _ref199;\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();\n  const sqdist = vec3(1e6, 1e6, 1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, _ref200 => {\n    let {\n      x\n    } = _ref200;\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, _ref201 => {\n      let {\n        y\n      } = _ref201;\n      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();\n      If(dist.lessThan(sqdist.x), () => {\n        sqdist.z.assign(sqdist.y);\n        sqdist.y.assign(sqdist.x);\n        sqdist.x.assign(dist);\n      }).ElseIf(dist.lessThan(sqdist.y), () => {\n        sqdist.z.assign(sqdist.y);\n        sqdist.y.assign(dist);\n      }).ElseIf(dist.lessThan(sqdist.z), () => {\n        sqdist.z.assign(dist);\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_vec3_0',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_float_1 = /*@__PURE__*/Fn(_ref202 => {\n  let [p_immutable, jitter_immutable, metric_immutable] = _ref202;\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();\n  const sqdist = float(1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, _ref203 => {\n    let {\n      x\n    } = _ref203;\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, _ref204 => {\n      let {\n        y\n      } = _ref204;\n      Loop({\n        start: -1,\n        end: int(1),\n        name: 'z',\n        condition: '<='\n      }, _ref205 => {\n        let {\n          z\n        } = _ref205;\n        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();\n        sqdist.assign(min$1(sqdist, dist));\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_float_1',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_float$1 = /*@__PURE__*/overloadingFn([mx_worley_noise_float_0, mx_worley_noise_float_1]);\nconst mx_worley_noise_vec2_1 = /*@__PURE__*/Fn(_ref206 => {\n  let [p_immutable, jitter_immutable, metric_immutable] = _ref206;\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();\n  const sqdist = vec2(1e6, 1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, _ref207 => {\n    let {\n      x\n    } = _ref207;\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, _ref208 => {\n      let {\n        y\n      } = _ref208;\n      Loop({\n        start: -1,\n        end: int(1),\n        name: 'z',\n        condition: '<='\n      }, _ref209 => {\n        let {\n          z\n        } = _ref209;\n        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();\n        If(dist.lessThan(sqdist.x), () => {\n          sqdist.y.assign(sqdist.x);\n          sqdist.x.assign(dist);\n        }).ElseIf(dist.lessThan(sqdist.y), () => {\n          sqdist.y.assign(dist);\n        });\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_vec2_1',\n  type: 'vec2',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_vec2$1 = /*@__PURE__*/overloadingFn([mx_worley_noise_vec2_0, mx_worley_noise_vec2_1]);\nconst mx_worley_noise_vec3_1 = /*@__PURE__*/Fn(_ref210 => {\n  let [p_immutable, jitter_immutable, metric_immutable] = _ref210;\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();\n  const sqdist = vec3(1e6, 1e6, 1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, _ref211 => {\n    let {\n      x\n    } = _ref211;\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, _ref212 => {\n      let {\n        y\n      } = _ref212;\n      Loop({\n        start: -1,\n        end: int(1),\n        name: 'z',\n        condition: '<='\n      }, _ref213 => {\n        let {\n          z\n        } = _ref213;\n        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();\n        If(dist.lessThan(sqdist.x), () => {\n          sqdist.z.assign(sqdist.y);\n          sqdist.y.assign(sqdist.x);\n          sqdist.x.assign(dist);\n        }).ElseIf(dist.lessThan(sqdist.y), () => {\n          sqdist.z.assign(sqdist.y);\n          sqdist.y.assign(dist);\n        }).ElseIf(dist.lessThan(sqdist.z), () => {\n          sqdist.z.assign(dist);\n        });\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_vec3_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_vec3$1 = /*@__PURE__*/overloadingFn([mx_worley_noise_vec3_0, mx_worley_noise_vec3_1]);\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl\n\nconst mx_hsvtorgb = /*@__PURE__*/Fn(_ref214 => {\n  let [hsv] = _ref214;\n  const s = hsv.y;\n  const v = hsv.z;\n  const result = vec3().toVar();\n  If(s.lessThan(0.0001), () => {\n    result.assign(vec3(v, v, v));\n  }).Else(() => {\n    let h = hsv.x;\n    h = h.sub(floor(h)).mul(6.0).toVar(); // TODO: check what .toVar() is needed in node system cache\n    const hi = int(trunc(h));\n    const f = h.sub(float(hi));\n    const p = v.mul(s.oneMinus());\n    const q = v.mul(s.mul(f).oneMinus());\n    const t = v.mul(s.mul(f.oneMinus()).oneMinus());\n    If(hi.equal(int(0)), () => {\n      result.assign(vec3(v, t, p));\n    }).ElseIf(hi.equal(int(1)), () => {\n      result.assign(vec3(q, v, p));\n    }).ElseIf(hi.equal(int(2)), () => {\n      result.assign(vec3(p, v, t));\n    }).ElseIf(hi.equal(int(3)), () => {\n      result.assign(vec3(p, q, v));\n    }).ElseIf(hi.equal(int(4)), () => {\n      result.assign(vec3(t, p, v));\n    }).Else(() => {\n      result.assign(vec3(v, p, q));\n    });\n  });\n  return result;\n}).setLayout({\n  name: 'mx_hsvtorgb',\n  type: 'vec3',\n  inputs: [{\n    name: 'hsv',\n    type: 'vec3'\n  }]\n});\nconst mx_rgbtohsv = /*@__PURE__*/Fn(_ref215 => {\n  let [c_immutable] = _ref215;\n  const c = vec3(c_immutable).toVar();\n  const r = float(c.x).toVar();\n  const g = float(c.y).toVar();\n  const b = float(c.z).toVar();\n  const mincomp = float(min$1(r, min$1(g, b))).toVar();\n  const maxcomp = float(max$1(r, max$1(g, b))).toVar();\n  const delta = float(maxcomp.sub(mincomp)).toVar();\n  const h = float().toVar(),\n    s = float().toVar(),\n    v = float().toVar();\n  v.assign(maxcomp);\n  If(maxcomp.greaterThan(0.0), () => {\n    s.assign(delta.div(maxcomp));\n  }).Else(() => {\n    s.assign(0.0);\n  });\n  If(s.lessThanEqual(0.0), () => {\n    h.assign(0.0);\n  }).Else(() => {\n    If(r.greaterThanEqual(maxcomp), () => {\n      h.assign(g.sub(b).div(delta));\n    }).ElseIf(g.greaterThanEqual(maxcomp), () => {\n      h.assign(add(2.0, b.sub(r).div(delta)));\n    }).Else(() => {\n      h.assign(add(4.0, r.sub(g).div(delta)));\n    });\n    h.mulAssign(1.0 / 6.0);\n    If(h.lessThan(0.0), () => {\n      h.addAssign(1.0);\n    });\n  });\n  return vec3(h, s, v);\n}).setLayout({\n  name: 'mx_rgbtohsv',\n  type: 'vec3',\n  inputs: [{\n    name: 'c',\n    type: 'vec3'\n  }]\n});\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl\n\nconst mx_srgb_texture_to_lin_rec709 = /*@__PURE__*/Fn(_ref216 => {\n  let [color_immutable] = _ref216;\n  const color = vec3(color_immutable).toVar();\n  const isAbove = bvec3(greaterThan(color, vec3(0.04045))).toVar();\n  const linSeg = vec3(color.div(12.92)).toVar();\n  const powSeg = vec3(pow(max$1(color.add(vec3(0.055)), vec3(0.0)).div(1.055), vec3(2.4))).toVar();\n  return mix(linSeg, powSeg, isAbove);\n}).setLayout({\n  name: 'mx_srgb_texture_to_lin_rec709',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }]\n});\nconst mx_aastep = (threshold, value) => {\n  threshold = float(threshold);\n  value = float(value);\n  const afwidth = vec2(value.dFdx(), value.dFdy()).length().mul(0.70710678118654757);\n  return smoothstep(threshold.sub(afwidth), threshold.add(afwidth), value);\n};\nconst _ramp = (a, b, uv, p) => mix(a, b, uv[p].clamp());\nconst mx_ramplr = function (valuel, valuer) {\n  let texcoord = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : uv();\n  return _ramp(valuel, valuer, texcoord, 'x');\n};\nconst mx_ramptb = function (valuet, valueb) {\n  let texcoord = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : uv();\n  return _ramp(valuet, valueb, texcoord, 'y');\n};\nconst _split = (a, b, center, uv, p) => mix(a, b, mx_aastep(center, uv[p]));\nconst mx_splitlr = function (valuel, valuer, center) {\n  let texcoord = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : uv();\n  return _split(valuel, valuer, center, texcoord, 'x');\n};\nconst mx_splittb = function (valuet, valueb, center) {\n  let texcoord = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : uv();\n  return _split(valuet, valueb, center, texcoord, 'y');\n};\nconst mx_transform_uv = function () {\n  let uv_scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  let uv_offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let uv_geo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : uv();\n  return uv_geo.mul(uv_scale).add(uv_offset);\n};\nconst mx_safepower = function (in1) {\n  let in2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  in1 = float(in1);\n  return in1.abs().pow(in2).mul(in1.sign());\n};\nconst mx_contrast = function (input) {\n  let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let pivot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .5;\n  return float(input).sub(pivot).mul(amount).add(pivot);\n};\nconst mx_noise_float = function () {\n  let texcoord = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();\n  let amplitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let pivot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return mx_perlin_noise_float(texcoord.convert('vec2|vec3')).mul(amplitude).add(pivot);\n};\n//export const mx_noise_vec2 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\nconst mx_noise_vec3 = function () {\n  let texcoord = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();\n  let amplitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let pivot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return mx_perlin_noise_vec3(texcoord.convert('vec2|vec3')).mul(amplitude).add(pivot);\n};\nconst mx_noise_vec4 = function () {\n  let texcoord = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();\n  let amplitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let pivot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  texcoord = texcoord.convert('vec2|vec3'); // overloading type\n\n  const noise_vec4 = vec4(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(texcoord.add(vec2(19, 73))));\n  return noise_vec4.mul(amplitude).add(pivot);\n};\nconst mx_worley_noise_float = function () {\n  let texcoord = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();\n  let jitter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return mx_worley_noise_float$1(texcoord.convert('vec2|vec3'), jitter, int(1));\n};\nconst mx_worley_noise_vec2 = function () {\n  let texcoord = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();\n  let jitter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return mx_worley_noise_vec2$1(texcoord.convert('vec2|vec3'), jitter, int(1));\n};\nconst mx_worley_noise_vec3 = function () {\n  let texcoord = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();\n  let jitter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return mx_worley_noise_vec3$1(texcoord.convert('vec2|vec3'), jitter, int(1));\n};\nconst mx_cell_noise_float = function () {\n  let texcoord = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();\n  return mx_cell_noise_float$1(texcoord.convert('vec2|vec3'));\n};\nconst mx_fractal_noise_float = function () {\n  let position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();\n  let octaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  let lacunarity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  let diminish = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;\n  let amplitude = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  return mx_fractal_noise_float$1(position, int(octaves), lacunarity, diminish).mul(amplitude);\n};\nconst mx_fractal_noise_vec2 = function () {\n  let position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();\n  let octaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  let lacunarity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  let diminish = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;\n  let amplitude = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  return mx_fractal_noise_vec2$1(position, int(octaves), lacunarity, diminish).mul(amplitude);\n};\nconst mx_fractal_noise_vec3 = function () {\n  let position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();\n  let octaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  let lacunarity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  let diminish = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;\n  let amplitude = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  return mx_fractal_noise_vec3$1(position, int(octaves), lacunarity, diminish).mul(amplitude);\n};\nconst mx_fractal_noise_vec4 = function () {\n  let position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();\n  let octaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  let lacunarity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  let diminish = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;\n  let amplitude = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  return mx_fractal_noise_vec4$1(position, int(octaves), lacunarity, diminish).mul(amplitude);\n};\n\n// https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html\n\nconst getParallaxCorrectNormal = /*@__PURE__*/Fn(_ref217 => {\n  let [normal, cubeSize, cubePos] = _ref217;\n  const nDir = normalize(normal).toVar('nDir');\n  const rbmax = sub(float(0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar('rbmax');\n  const rbmin = sub(float(-0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar('rbmin');\n  const rbminmax = vec3().toVar('rbminmax');\n  rbminmax.x = nDir.x.greaterThan(float(0)).select(rbmax.x, rbmin.x);\n  rbminmax.y = nDir.y.greaterThan(float(0)).select(rbmax.y, rbmin.y);\n  rbminmax.z = nDir.z.greaterThan(float(0)).select(rbmax.z, rbmin.z);\n  const correction = min$1(min$1(rbminmax.x, rbminmax.y), rbminmax.z).toVar('correction');\n  const boxIntersection = positionWorld.add(nDir.mul(correction)).toVar('boxIntersection');\n  return boxIntersection.sub(cubePos);\n});\nconst getShIrradianceAt = /*@__PURE__*/Fn(_ref218 => {\n  let [normal, shCoefficients] = _ref218;\n  // normal is assumed to have unit length\n\n  const x = normal.x,\n    y = normal.y,\n    z = normal.z;\n\n  // band 0\n  let result = shCoefficients.element(0).mul(0.886227);\n\n  // band 1\n  result = result.add(shCoefficients.element(1).mul(2.0 * 0.511664).mul(y));\n  result = result.add(shCoefficients.element(2).mul(2.0 * 0.511664).mul(z));\n  result = result.add(shCoefficients.element(3).mul(2.0 * 0.511664).mul(x));\n\n  // band 2\n  result = result.add(shCoefficients.element(4).mul(2.0 * 0.429043).mul(x).mul(y));\n  result = result.add(shCoefficients.element(5).mul(2.0 * 0.429043).mul(y).mul(z));\n  result = result.add(shCoefficients.element(6).mul(z.mul(z).mul(0.743125).sub(0.247708)));\n  result = result.add(shCoefficients.element(7).mul(2.0 * 0.429043).mul(x).mul(z));\n  result = result.add(shCoefficients.element(8).mul(0.429043).mul(mul(x, x).sub(mul(y, y))));\n  return result;\n});\n\n// constants\n\nvar TSL = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  BRDF_GGX: BRDF_GGX,\n  BRDF_Lambert: BRDF_Lambert,\n  BasicShadowFilter: BasicShadowFilter,\n  Break: Break,\n  Continue: Continue,\n  DFGApprox: DFGApprox,\n  D_GGX: D_GGX,\n  Discard: Discard,\n  EPSILON: EPSILON,\n  F_Schlick: F_Schlick,\n  Fn: Fn,\n  INFINITY: INFINITY,\n  If: If,\n  Loop: Loop,\n  NodeAccess: NodeAccess,\n  NodeShaderStage: NodeShaderStage,\n  NodeType: NodeType,\n  NodeUpdateType: NodeUpdateType,\n  PCFShadowFilter: PCFShadowFilter,\n  PCFSoftShadowFilter: PCFSoftShadowFilter,\n  PI: PI,\n  PI2: PI2,\n  Return: Return,\n  Schlick_to_F0: Schlick_to_F0,\n  ScriptableNodeResources: ScriptableNodeResources,\n  ShaderNode: ShaderNode,\n  TBNViewMatrix: TBNViewMatrix,\n  VSMShadowFilter: VSMShadowFilter,\n  V_GGX_SmithCorrelated: V_GGX_SmithCorrelated,\n  abs: abs,\n  acesFilmicToneMapping: acesFilmicToneMapping,\n  acos: acos,\n  add: add,\n  addMethodChaining: addMethodChaining,\n  addNodeElement: addNodeElement,\n  agxToneMapping: agxToneMapping,\n  all: all,\n  alphaT: alphaT,\n  and: and,\n  anisotropy: anisotropy,\n  anisotropyB: anisotropyB,\n  anisotropyT: anisotropyT,\n  any: any,\n  append: append,\n  arrayBuffer: arrayBuffer,\n  asin: asin,\n  assign: assign,\n  atan: atan,\n  atan2: atan2,\n  atomicAdd: atomicAdd,\n  atomicAnd: atomicAnd,\n  atomicFunc: atomicFunc,\n  atomicMax: atomicMax,\n  atomicMin: atomicMin,\n  atomicOr: atomicOr,\n  atomicStore: atomicStore,\n  atomicSub: atomicSub,\n  atomicXor: atomicXor,\n  attenuationColor: attenuationColor,\n  attenuationDistance: attenuationDistance,\n  attribute: attribute,\n  attributeArray: attributeArray,\n  backgroundBlurriness: backgroundBlurriness,\n  backgroundIntensity: backgroundIntensity,\n  backgroundRotation: backgroundRotation,\n  batch: batch,\n  billboarding: billboarding,\n  bitAnd: bitAnd,\n  bitNot: bitNot,\n  bitOr: bitOr,\n  bitXor: bitXor,\n  bitangentGeometry: bitangentGeometry,\n  bitangentLocal: bitangentLocal,\n  bitangentView: bitangentView,\n  bitangentWorld: bitangentWorld,\n  bitcast: bitcast,\n  blendBurn: blendBurn,\n  blendColor: blendColor,\n  blendDodge: blendDodge,\n  blendOverlay: blendOverlay,\n  blendScreen: blendScreen,\n  blur: blur,\n  bool: bool,\n  buffer: buffer,\n  bufferAttribute: bufferAttribute,\n  bumpMap: bumpMap,\n  burn: burn,\n  bvec2: bvec2,\n  bvec3: bvec3,\n  bvec4: bvec4,\n  bypass: bypass,\n  cache: cache,\n  call: call,\n  cameraFar: cameraFar,\n  cameraNear: cameraNear,\n  cameraNormalMatrix: cameraNormalMatrix,\n  cameraPosition: cameraPosition,\n  cameraProjectionMatrix: cameraProjectionMatrix,\n  cameraProjectionMatrixInverse: cameraProjectionMatrixInverse,\n  cameraViewMatrix: cameraViewMatrix,\n  cameraWorldMatrix: cameraWorldMatrix,\n  cbrt: cbrt,\n  cdl: cdl,\n  ceil: ceil,\n  checker: checker,\n  cineonToneMapping: cineonToneMapping,\n  clamp: clamp,\n  clearcoat: clearcoat,\n  clearcoatRoughness: clearcoatRoughness,\n  code: code,\n  color: color,\n  colorSpaceToWorking: colorSpaceToWorking,\n  colorToDirection: colorToDirection,\n  compute: compute,\n  cond: cond,\n  context: context,\n  convert: convert,\n  convertColorSpace: convertColorSpace,\n  convertToTexture: convertToTexture,\n  cos: cos,\n  cross: cross,\n  cubeTexture: cubeTexture,\n  dFdx: dFdx,\n  dFdy: dFdy,\n  dashSize: dashSize,\n  defaultBuildStages: defaultBuildStages,\n  defaultShaderStages: defaultShaderStages,\n  defined: defined,\n  degrees: degrees,\n  deltaTime: deltaTime,\n  densityFog: densityFog,\n  depth: depth,\n  depthPass: depthPass,\n  difference: difference,\n  diffuseColor: diffuseColor,\n  directPointLight: directPointLight,\n  directionToColor: directionToColor,\n  dispersion: dispersion,\n  distance: distance,\n  div: div,\n  dodge: dodge,\n  dot: dot,\n  drawIndex: drawIndex,\n  dynamicBufferAttribute: dynamicBufferAttribute,\n  element: element,\n  emissive: emissive,\n  equal: equal,\n  equals: equals,\n  equirectUV: equirectUV,\n  exp: exp,\n  exp2: exp2,\n  expression: expression,\n  faceDirection: faceDirection,\n  faceForward: faceForward,\n  float: float,\n  floor: floor,\n  fog: fog,\n  fract: fract,\n  frameGroup: frameGroup,\n  frameId: frameId,\n  frontFacing: frontFacing,\n  fwidth: fwidth,\n  gain: gain,\n  gapSize: gapSize,\n  getConstNodeType: getConstNodeType,\n  getCurrentStack: getCurrentStack,\n  getDirection: getDirection,\n  getDistanceAttenuation: getDistanceAttenuation,\n  getGeometryRoughness: getGeometryRoughness,\n  getNormalFromDepth: getNormalFromDepth,\n  getParallaxCorrectNormal: getParallaxCorrectNormal,\n  getRoughness: getRoughness,\n  getScreenPosition: getScreenPosition,\n  getShIrradianceAt: getShIrradianceAt,\n  getTextureIndex: getTextureIndex,\n  getViewPosition: getViewPosition,\n  glsl: glsl,\n  glslFn: glslFn,\n  grayscale: grayscale,\n  greaterThan: greaterThan,\n  greaterThanEqual: greaterThanEqual,\n  hash: hash,\n  highPrecisionModelNormalViewMatrix: highPrecisionModelNormalViewMatrix,\n  highPrecisionModelViewMatrix: highPrecisionModelViewMatrix,\n  hue: hue,\n  instance: instance,\n  instanceIndex: instanceIndex,\n  instancedArray: instancedArray,\n  instancedBufferAttribute: instancedBufferAttribute,\n  instancedDynamicBufferAttribute: instancedDynamicBufferAttribute,\n  instancedMesh: instancedMesh,\n  int: int,\n  inverseSqrt: inverseSqrt,\n  invocationLocalIndex: invocationLocalIndex,\n  invocationSubgroupIndex: invocationSubgroupIndex,\n  ior: ior,\n  iridescence: iridescence,\n  iridescenceIOR: iridescenceIOR,\n  iridescenceThickness: iridescenceThickness,\n  ivec2: ivec2,\n  ivec3: ivec3,\n  ivec4: ivec4,\n  js: js,\n  label: label,\n  length: length,\n  lengthSq: lengthSq,\n  lessThan: lessThan,\n  lessThanEqual: lessThanEqual,\n  lightPosition: lightPosition,\n  lightProjectionUV: lightProjectionUV,\n  lightShadowMatrix: lightShadowMatrix,\n  lightTargetDirection: lightTargetDirection,\n  lightTargetPosition: lightTargetPosition,\n  lightViewPosition: lightViewPosition,\n  lightingContext: lightingContext,\n  lights: lights,\n  linearDepth: linearDepth,\n  linearToneMapping: linearToneMapping,\n  localId: localId,\n  log: log,\n  log2: log2,\n  logarithmicDepthToViewZ: logarithmicDepthToViewZ,\n  loop: loop,\n  luminance: luminance,\n  mat2: mat2,\n  mat3: mat3,\n  mat4: mat4,\n  matcapUV: matcapUV,\n  materialAOMap: materialAOMap,\n  materialAlphaTest: materialAlphaTest,\n  materialAnisotropy: materialAnisotropy,\n  materialAnisotropyVector: materialAnisotropyVector,\n  materialAttenuationColor: materialAttenuationColor,\n  materialAttenuationDistance: materialAttenuationDistance,\n  materialClearcoat: materialClearcoat,\n  materialClearcoatNormal: materialClearcoatNormal,\n  materialClearcoatRoughness: materialClearcoatRoughness,\n  materialColor: materialColor,\n  materialDispersion: materialDispersion,\n  materialEmissive: materialEmissive,\n  materialIOR: materialIOR,\n  materialIridescence: materialIridescence,\n  materialIridescenceIOR: materialIridescenceIOR,\n  materialIridescenceThickness: materialIridescenceThickness,\n  materialLightMap: materialLightMap,\n  materialLineDashOffset: materialLineDashOffset,\n  materialLineDashSize: materialLineDashSize,\n  materialLineGapSize: materialLineGapSize,\n  materialLineScale: materialLineScale,\n  materialLineWidth: materialLineWidth,\n  materialMetalness: materialMetalness,\n  materialNormal: materialNormal,\n  materialOpacity: materialOpacity,\n  materialPointWidth: materialPointWidth,\n  materialReference: materialReference,\n  materialReflectivity: materialReflectivity,\n  materialRefractionRatio: materialRefractionRatio,\n  materialRotation: materialRotation,\n  materialRoughness: materialRoughness,\n  materialSheen: materialSheen,\n  materialSheenRoughness: materialSheenRoughness,\n  materialShininess: materialShininess,\n  materialSpecular: materialSpecular,\n  materialSpecularColor: materialSpecularColor,\n  materialSpecularIntensity: materialSpecularIntensity,\n  materialSpecularStrength: materialSpecularStrength,\n  materialThickness: materialThickness,\n  materialTransmission: materialTransmission,\n  max: max$1,\n  maxMipLevel: maxMipLevel,\n  metalness: metalness,\n  min: min$1,\n  mix: mix,\n  mixElement: mixElement,\n  mod: mod,\n  modInt: modInt,\n  modelDirection: modelDirection,\n  modelNormalMatrix: modelNormalMatrix,\n  modelPosition: modelPosition,\n  modelScale: modelScale,\n  modelViewMatrix: modelViewMatrix,\n  modelViewPosition: modelViewPosition,\n  modelViewProjection: modelViewProjection,\n  modelWorldMatrix: modelWorldMatrix,\n  modelWorldMatrixInverse: modelWorldMatrixInverse,\n  morphReference: morphReference,\n  mrt: mrt,\n  mul: mul,\n  mx_aastep: mx_aastep,\n  mx_cell_noise_float: mx_cell_noise_float,\n  mx_contrast: mx_contrast,\n  mx_fractal_noise_float: mx_fractal_noise_float,\n  mx_fractal_noise_vec2: mx_fractal_noise_vec2,\n  mx_fractal_noise_vec3: mx_fractal_noise_vec3,\n  mx_fractal_noise_vec4: mx_fractal_noise_vec4,\n  mx_hsvtorgb: mx_hsvtorgb,\n  mx_noise_float: mx_noise_float,\n  mx_noise_vec3: mx_noise_vec3,\n  mx_noise_vec4: mx_noise_vec4,\n  mx_ramplr: mx_ramplr,\n  mx_ramptb: mx_ramptb,\n  mx_rgbtohsv: mx_rgbtohsv,\n  mx_safepower: mx_safepower,\n  mx_splitlr: mx_splitlr,\n  mx_splittb: mx_splittb,\n  mx_srgb_texture_to_lin_rec709: mx_srgb_texture_to_lin_rec709,\n  mx_transform_uv: mx_transform_uv,\n  mx_worley_noise_float: mx_worley_noise_float,\n  mx_worley_noise_vec2: mx_worley_noise_vec2,\n  mx_worley_noise_vec3: mx_worley_noise_vec3,\n  negate: negate,\n  neutralToneMapping: neutralToneMapping,\n  nodeArray: nodeArray,\n  nodeImmutable: nodeImmutable,\n  nodeObject: nodeObject,\n  nodeObjects: nodeObjects,\n  nodeProxy: nodeProxy,\n  normalFlat: normalFlat,\n  normalGeometry: normalGeometry,\n  normalLocal: normalLocal,\n  normalMap: normalMap,\n  normalView: normalView,\n  normalWorld: normalWorld,\n  normalize: normalize,\n  not: not,\n  notEqual: notEqual,\n  numWorkgroups: numWorkgroups,\n  objectDirection: objectDirection,\n  objectGroup: objectGroup,\n  objectPosition: objectPosition,\n  objectScale: objectScale,\n  objectViewPosition: objectViewPosition,\n  objectWorldMatrix: objectWorldMatrix,\n  oneMinus: oneMinus,\n  or: or,\n  orthographicDepthToViewZ: orthographicDepthToViewZ,\n  oscSawtooth: oscSawtooth,\n  oscSine: oscSine,\n  oscSquare: oscSquare,\n  oscTriangle: oscTriangle,\n  output: output,\n  outputStruct: outputStruct,\n  overlay: overlay,\n  overloadingFn: overloadingFn,\n  parabola: parabola,\n  parallaxDirection: parallaxDirection,\n  parallaxUV: parallaxUV,\n  parameter: parameter,\n  pass: pass,\n  passTexture: passTexture,\n  pcurve: pcurve,\n  perspectiveDepthToViewZ: perspectiveDepthToViewZ,\n  pmremTexture: pmremTexture,\n  pointUV: pointUV,\n  pointWidth: pointWidth,\n  positionGeometry: positionGeometry,\n  positionLocal: positionLocal,\n  positionPrevious: positionPrevious,\n  positionView: positionView,\n  positionViewDirection: positionViewDirection,\n  positionWorld: positionWorld,\n  positionWorldDirection: positionWorldDirection,\n  posterize: posterize,\n  pow: pow,\n  pow2: pow2,\n  pow3: pow3,\n  pow4: pow4,\n  property: property,\n  radians: radians,\n  rand: rand,\n  range: range,\n  rangeFog: rangeFog,\n  reciprocal: reciprocal,\n  reference: reference,\n  referenceBuffer: referenceBuffer,\n  reflect: reflect,\n  reflectVector: reflectVector,\n  reflectView: reflectView,\n  reflector: reflector,\n  refract: refract,\n  refractVector: refractVector,\n  refractView: refractView,\n  reinhardToneMapping: reinhardToneMapping,\n  remainder: remainder,\n  remap: remap,\n  remapClamp: remapClamp,\n  renderGroup: renderGroup,\n  renderOutput: renderOutput,\n  rendererReference: rendererReference,\n  rotate: rotate,\n  rotateUV: rotateUV,\n  roughness: roughness,\n  round: round,\n  rtt: rtt,\n  sRGBTransferEOTF: sRGBTransferEOTF,\n  sRGBTransferOETF: sRGBTransferOETF,\n  sampler: sampler,\n  saturate: saturate,\n  saturation: saturation,\n  screen: screen,\n  screenCoordinate: screenCoordinate,\n  screenSize: screenSize,\n  screenUV: screenUV,\n  scriptable: scriptable,\n  scriptableValue: scriptableValue,\n  select: select,\n  setCurrentStack: setCurrentStack,\n  shaderStages: shaderStages,\n  shadow: shadow,\n  sharedUniformGroup: sharedUniformGroup,\n  sheen: sheen,\n  sheenRoughness: sheenRoughness,\n  shiftLeft: shiftLeft,\n  shiftRight: shiftRight,\n  shininess: shininess,\n  sign: sign,\n  sin: sin,\n  sinc: sinc,\n  skinning: skinning,\n  skinningReference: skinningReference,\n  smoothstep: smoothstep,\n  smoothstepElement: smoothstepElement,\n  specularColor: specularColor,\n  specularF90: specularF90,\n  spherizeUV: spherizeUV,\n  split: split,\n  spritesheetUV: spritesheetUV,\n  sqrt: sqrt,\n  stack: stack,\n  step: step,\n  storage: storage,\n  storageBarrier: storageBarrier,\n  storageObject: storageObject,\n  storageTexture: storageTexture,\n  string: string,\n  sub: sub,\n  subgroupIndex: subgroupIndex,\n  subgroupSize: subgroupSize,\n  tan: tan,\n  tangentGeometry: tangentGeometry,\n  tangentLocal: tangentLocal,\n  tangentView: tangentView,\n  tangentWorld: tangentWorld,\n  temp: temp,\n  texture: texture,\n  texture3D: texture3D,\n  textureBarrier: textureBarrier,\n  textureBicubic: textureBicubic,\n  textureCubeUV: textureCubeUV,\n  textureLoad: textureLoad,\n  textureSize: textureSize,\n  textureStore: textureStore,\n  thickness: thickness,\n  threshold: threshold,\n  time: time,\n  timerDelta: timerDelta,\n  timerGlobal: timerGlobal,\n  timerLocal: timerLocal,\n  toOutputColorSpace: toOutputColorSpace,\n  toWorkingColorSpace: toWorkingColorSpace,\n  toneMapping: toneMapping,\n  toneMappingExposure: toneMappingExposure,\n  toonOutlinePass: toonOutlinePass,\n  transformDirection: transformDirection,\n  transformNormal: transformNormal,\n  transformNormalToView: transformNormalToView,\n  transformedBentNormalView: transformedBentNormalView,\n  transformedBitangentView: transformedBitangentView,\n  transformedBitangentWorld: transformedBitangentWorld,\n  transformedClearcoatNormalView: transformedClearcoatNormalView,\n  transformedNormalView: transformedNormalView,\n  transformedNormalWorld: transformedNormalWorld,\n  transformedTangentView: transformedTangentView,\n  transformedTangentWorld: transformedTangentWorld,\n  transmission: transmission,\n  transpose: transpose,\n  tri: tri,\n  tri3: tri3,\n  triNoise3D: triNoise3D,\n  triplanarTexture: triplanarTexture,\n  triplanarTextures: triplanarTextures,\n  trunc: trunc,\n  tslFn: tslFn,\n  uint: uint,\n  uniform: uniform,\n  uniformArray: uniformArray,\n  uniformGroup: uniformGroup,\n  uniforms: uniforms,\n  userData: userData,\n  uv: uv,\n  uvec2: uvec2,\n  uvec3: uvec3,\n  uvec4: uvec4,\n  varying: varying,\n  varyingProperty: varyingProperty,\n  vec2: vec2,\n  vec3: vec3,\n  vec4: vec4,\n  vectorComponents: vectorComponents,\n  velocity: velocity,\n  vertexColor: vertexColor,\n  vertexIndex: vertexIndex,\n  vibrance: vibrance,\n  viewZToLogarithmicDepth: viewZToLogarithmicDepth,\n  viewZToOrthographicDepth: viewZToOrthographicDepth,\n  viewZToPerspectiveDepth: viewZToPerspectiveDepth,\n  viewport: viewport,\n  viewportBottomLeft: viewportBottomLeft,\n  viewportCoordinate: viewportCoordinate,\n  viewportDepthTexture: viewportDepthTexture,\n  viewportLinearDepth: viewportLinearDepth,\n  viewportMipTexture: viewportMipTexture,\n  viewportResolution: viewportResolution,\n  viewportSafeUV: viewportSafeUV,\n  viewportSharedTexture: viewportSharedTexture,\n  viewportSize: viewportSize,\n  viewportTexture: viewportTexture,\n  viewportTopLeft: viewportTopLeft,\n  viewportUV: viewportUV,\n  wgsl: wgsl,\n  wgslFn: wgslFn,\n  workgroupArray: workgroupArray,\n  workgroupBarrier: workgroupBarrier,\n  workgroupId: workgroupId,\n  workingToColorSpace: workingToColorSpace,\n  xor: xor\n});\nconst _clearColor$1 = /*@__PURE__*/new Color4();\nclass Background extends DataMap {\n  constructor(renderer, nodes) {\n    super();\n    this.renderer = renderer;\n    this.nodes = nodes;\n  }\n  update(scene, renderList, renderContext) {\n    const renderer = this.renderer;\n    const background = this.nodes.getBackgroundNode(scene) || scene.background;\n    let forceClear = false;\n    if (background === null) {\n      // no background settings, use clear color configuration from the renderer\n\n      renderer._clearColor.getRGB(_clearColor$1, LinearSRGBColorSpace);\n      _clearColor$1.a = renderer._clearColor.a;\n    } else if (background.isColor === true) {\n      // background is an opaque color\n\n      background.getRGB(_clearColor$1, LinearSRGBColorSpace);\n      _clearColor$1.a = 1;\n      forceClear = true;\n    } else if (background.isNode === true) {\n      const sceneData = this.get(scene);\n      const backgroundNode = background;\n      _clearColor$1.copy(renderer._clearColor);\n      let backgroundMesh = sceneData.backgroundMesh;\n      if (backgroundMesh === undefined) {\n        const backgroundMeshNode = context(vec4(backgroundNode).mul(backgroundIntensity), {\n          // @TODO: Add Texture2D support using node context\n          getUV: () => backgroundRotation.mul(normalWorld),\n          getTextureLevel: () => backgroundBlurriness\n        });\n        let viewProj = modelViewProjection();\n        viewProj = viewProj.setZ(viewProj.w);\n        const nodeMaterial = new NodeMaterial();\n        nodeMaterial.name = 'Background.material';\n        nodeMaterial.side = BackSide;\n        nodeMaterial.depthTest = false;\n        nodeMaterial.depthWrite = false;\n        nodeMaterial.fog = false;\n        nodeMaterial.lights = false;\n        nodeMaterial.vertexNode = viewProj;\n        nodeMaterial.colorNode = backgroundMeshNode;\n        sceneData.backgroundMeshNode = backgroundMeshNode;\n        sceneData.backgroundMesh = backgroundMesh = new Mesh(new SphereGeometry(1, 32, 32), nodeMaterial);\n        backgroundMesh.frustumCulled = false;\n        backgroundMesh.name = 'Background.mesh';\n        backgroundMesh.onBeforeRender = function (renderer, scene, camera) {\n          this.matrixWorld.copyPosition(camera.matrixWorld);\n        };\n      }\n      const backgroundCacheKey = backgroundNode.getCacheKey();\n      if (sceneData.backgroundCacheKey !== backgroundCacheKey) {\n        sceneData.backgroundMeshNode.node = vec4(backgroundNode).mul(backgroundIntensity);\n        sceneData.backgroundMeshNode.needsUpdate = true;\n        backgroundMesh.material.needsUpdate = true;\n        sceneData.backgroundCacheKey = backgroundCacheKey;\n      }\n      renderList.unshift(backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null);\n    } else {\n      console.error('THREE.Renderer: Unsupported background configuration.', background);\n    }\n\n    //\n\n    if (renderer.autoClear === true || forceClear === true) {\n      const clearColorValue = renderContext.clearColorValue;\n      clearColorValue.r = _clearColor$1.r;\n      clearColorValue.g = _clearColor$1.g;\n      clearColorValue.b = _clearColor$1.b;\n      clearColorValue.a = _clearColor$1.a;\n\n      // premultiply alpha\n\n      if (renderer.backend.isWebGLBackend === true || renderer.alpha === true) {\n        clearColorValue.r *= clearColorValue.a;\n        clearColorValue.g *= clearColorValue.a;\n        clearColorValue.b *= clearColorValue.a;\n      }\n\n      //\n\n      renderContext.depthClearValue = renderer._clearDepth;\n      renderContext.stencilClearValue = renderer._clearStencil;\n      renderContext.clearColor = renderer.autoClearColor === true;\n      renderContext.clearDepth = renderer.autoClearDepth === true;\n      renderContext.clearStencil = renderer.autoClearStencil === true;\n    } else {\n      renderContext.clearColor = false;\n      renderContext.clearDepth = false;\n      renderContext.clearStencil = false;\n    }\n  }\n}\nlet _id$5 = 0;\nclass BindGroup {\n  constructor() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let bindings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let bindingsReference = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    this.name = name;\n    this.bindings = bindings;\n    this.index = index;\n    this.bindingsReference = bindingsReference;\n    this.id = _id$5++;\n  }\n}\nclass NodeBuilderState {\n  constructor(vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, monitor) {\n    let transforms = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : [];\n    this.vertexShader = vertexShader;\n    this.fragmentShader = fragmentShader;\n    this.computeShader = computeShader;\n    this.transforms = transforms;\n    this.nodeAttributes = nodeAttributes;\n    this.bindings = bindings;\n    this.updateNodes = updateNodes;\n    this.updateBeforeNodes = updateBeforeNodes;\n    this.updateAfterNodes = updateAfterNodes;\n    this.monitor = monitor;\n    this.usedTimes = 0;\n  }\n  createBindings() {\n    const bindings = [];\n    for (const instanceGroup of this.bindings) {\n      const shared = instanceGroup.bindings[0].groupNode.shared;\n      if (shared !== true) {\n        const bindingsGroup = new BindGroup(instanceGroup.name, [], instanceGroup.index, instanceGroup);\n        bindings.push(bindingsGroup);\n        for (const instanceBinding of instanceGroup.bindings) {\n          bindingsGroup.bindings.push(instanceBinding.clone());\n        }\n      } else {\n        bindings.push(instanceGroup);\n      }\n    }\n    return bindings;\n  }\n}\nclass NodeAttribute {\n  constructor(name, type) {\n    let node = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    this.isNodeAttribute = true;\n    this.name = name;\n    this.type = type;\n    this.node = node;\n  }\n}\nclass NodeUniform {\n  constructor(name, type, node) {\n    this.isNodeUniform = true;\n    this.name = name;\n    this.type = type;\n    this.node = node.getSelf();\n  }\n  get value() {\n    return this.node.value;\n  }\n  set value(val) {\n    this.node.value = val;\n  }\n  get id() {\n    return this.node.id;\n  }\n  get groupNode() {\n    return this.node.groupNode;\n  }\n}\nclass NodeVar {\n  constructor(name, type) {\n    this.isNodeVar = true;\n    this.name = name;\n    this.type = type;\n  }\n}\nclass NodeVarying extends NodeVar {\n  constructor(name, type) {\n    super(name, type);\n    this.needsInterpolation = false;\n    this.isNodeVarying = true;\n  }\n}\nclass NodeCode {\n  constructor(name, type) {\n    let code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    this.name = name;\n    this.type = type;\n    this.code = code;\n    Object.defineProperty(this, 'isNodeCode', {\n      value: true\n    });\n  }\n}\nlet id = 0;\nclass NodeCache {\n  constructor() {\n    let parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.id = id++;\n    this.nodesData = new WeakMap();\n    this.parent = parent;\n  }\n  getData(node) {\n    let data = this.nodesData.get(node);\n    if (data === undefined && this.parent !== null) {\n      data = this.parent.getData(node);\n    }\n    return data;\n  }\n  setData(node, data) {\n    this.nodesData.set(node, data);\n  }\n}\nclass Uniform {\n  constructor(name, value) {\n    this.name = name;\n    this.value = value;\n    this.boundary = 0; // used to build the uniform buffer according to the STD140 layout\n    this.itemSize = 0;\n    this.offset = 0; // this property is set by WebGPUUniformsGroup and marks the start position in the uniform buffer\n  }\n  setValue(value) {\n    this.value = value;\n  }\n  getValue() {\n    return this.value;\n  }\n}\nclass NumberUniform extends Uniform {\n  constructor(name) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    super(name, value);\n    this.isNumberUniform = true;\n    this.boundary = 4;\n    this.itemSize = 1;\n  }\n}\nclass Vector2Uniform extends Uniform {\n  constructor(name) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();\n    super(name, value);\n    this.isVector2Uniform = true;\n    this.boundary = 8;\n    this.itemSize = 2;\n  }\n}\nclass Vector3Uniform extends Uniform {\n  constructor(name) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n    super(name, value);\n    this.isVector3Uniform = true;\n    this.boundary = 16;\n    this.itemSize = 3;\n  }\n}\nclass Vector4Uniform extends Uniform {\n  constructor(name) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector4();\n    super(name, value);\n    this.isVector4Uniform = true;\n    this.boundary = 16;\n    this.itemSize = 4;\n  }\n}\nclass ColorUniform extends Uniform {\n  constructor(name) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Color();\n    super(name, value);\n    this.isColorUniform = true;\n    this.boundary = 16;\n    this.itemSize = 3;\n  }\n}\nclass Matrix3Uniform extends Uniform {\n  constructor(name) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Matrix3();\n    super(name, value);\n    this.isMatrix3Uniform = true;\n    this.boundary = 48;\n    this.itemSize = 12;\n  }\n}\nclass Matrix4Uniform extends Uniform {\n  constructor(name) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Matrix4();\n    super(name, value);\n    this.isMatrix4Uniform = true;\n    this.boundary = 64;\n    this.itemSize = 16;\n  }\n}\nclass NumberNodeUniform extends NumberUniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  }\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nclass Vector2NodeUniform extends Vector2Uniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  }\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nclass Vector3NodeUniform extends Vector3Uniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  }\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nclass Vector4NodeUniform extends Vector4Uniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  }\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nclass ColorNodeUniform extends ColorUniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  }\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nclass Matrix3NodeUniform extends Matrix3Uniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  }\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nclass Matrix4NodeUniform extends Matrix4Uniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  }\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\nconst _flatCamera = /*@__PURE__*/new OrthographicCamera(-1, 1, 1, -1, 0, 1);\nconst _cubeCamera = /*@__PURE__*/new PerspectiveCamera(90, 1);\nconst _clearColor = /*@__PURE__*/new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\n\n// Golden Ratio\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [/*@__PURE__*/new Vector3(-PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, 1)];\n\n//\n\n// WebGPU Face indices\nconst _faceLib = [3, 1, 5, 0, 4, 2];\nconst direction = getDirection(uv(), attribute('faceIndex')).normalize();\nconst outputDirection = vec3(direction.x, direction.y.negate(), direction.z);\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n    this._lodMax = 0;\n    this._cubeSize = 0;\n    this._lodPlanes = [];\n    this._sizeLods = [];\n    this._sigmas = [];\n    this._lodMeshes = [];\n    this._blurMaterial = null;\n    this._cubemapMaterial = null;\n    this._equirectMaterial = null;\n    this._backgroundBox = null;\n  }\n  get _hasInitialized() {\n    return this._renderer.hasInitialized();\n  }\n\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   */\n  fromScene(scene) {\n    let sigma = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n    let far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;\n    let renderTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    this._setSize(256);\n    if (this._hasInitialized === false) {\n      console.warn('THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.');\n      const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n      this.fromSceneAsync(scene, sigma, near, far, cubeUVRenderTarget);\n      return cubeUVRenderTarget;\n    }\n    _oldTarget = this._renderer.getRenderTarget();\n    _oldActiveCubeFace = this._renderer.getActiveCubeFace();\n    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n    const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n    cubeUVRenderTarget.depthBuffer = true;\n    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n    if (sigma > 0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  async fromSceneAsync(scene) {\n    let sigma = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n    let far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;\n    let renderTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    if (this._hasInitialized === false) await this._renderer.init();\n    return this.fromScene(scene, sigma, near, far, renderTarget);\n  }\n\n  /**\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\n   * or HDR. The ideal input image size is 1k (1024 x 512),\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n  fromEquirectangular(equirectangular) {\n    let renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (this._hasInitialized === false) {\n      console.warn('THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.');\n      this._setSizeFromTexture(equirectangular);\n      const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n      this.fromEquirectangularAsync(equirectangular, cubeUVRenderTarget);\n      return cubeUVRenderTarget;\n    }\n    return this._fromTexture(equirectangular, renderTarget);\n  }\n  async fromEquirectangularAsync(equirectangular) {\n    let renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (this._hasInitialized === false) await this._renderer.init();\n    return this._fromTexture(equirectangular, renderTarget);\n  }\n\n  /**\n   * Generates a PMREM from an cubemap texture, which can be either LDR\n   * or HDR. The ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n  fromCubemap(cubemap) {\n    let renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (this._hasInitialized === false) {\n      console.warn('THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.');\n      this._setSizeFromTexture(cubemap);\n      const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n      this.fromCubemapAsync(cubemap, renderTarget);\n      return cubeUVRenderTarget;\n    }\n    return this._fromTexture(cubemap, renderTarget);\n  }\n  async fromCubemapAsync(cubemap) {\n    let renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (this._hasInitialized === false) await this._renderer.init();\n    return this._fromTexture(cubemap, renderTarget);\n  }\n\n  /**\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  async compileCubemapShader() {\n    if (this._cubemapMaterial === null) {\n      this._cubemapMaterial = _getCubemapMaterial();\n      await this._compileMaterial(this._cubemapMaterial);\n    }\n  }\n\n  /**\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  async compileEquirectangularShader() {\n    if (this._equirectMaterial === null) {\n      this._equirectMaterial = _getEquirectMaterial();\n      await this._compileMaterial(this._equirectMaterial);\n    }\n  }\n\n  /**\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n   * one of them will cause any others to also become unusable.\n   */\n  dispose() {\n    this._dispose();\n    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();\n    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();\n    if (this._backgroundBox !== null) {\n      this._backgroundBox.geometry.dispose();\n      this._backgroundBox.material.dispose();\n    }\n  }\n\n  // private interface\n\n  _setSizeFromTexture(texture) {\n    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {\n      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);\n    } else {\n      // Equirectangular\n\n      this._setSize(texture.image.width / 4);\n    }\n  }\n  _setSize(cubeSize) {\n    this._lodMax = Math.floor(Math.log2(cubeSize));\n    this._cubeSize = Math.pow(2, this._lodMax);\n  }\n  _dispose() {\n    if (this._blurMaterial !== null) this._blurMaterial.dispose();\n    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();\n    for (let i = 0; i < this._lodPlanes.length; i++) {\n      this._lodPlanes[i].dispose();\n    }\n  }\n  _cleanup(outputTarget) {\n    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);\n    outputTarget.scissorTest = false;\n    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  }\n  _fromTexture(texture, renderTarget) {\n    this._setSizeFromTexture(texture);\n    _oldTarget = this._renderer.getRenderTarget();\n    _oldActiveCubeFace = this._renderer.getActiveCubeFace();\n    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n    const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n    this._textureToCubeUV(texture, cubeUVRenderTarget);\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  _allocateTargets() {\n    const width = 3 * Math.max(this._cubeSize, 16 * 7);\n    const height = 4 * this._cubeSize;\n    const params = {\n      magFilter: LinearFilter,\n      minFilter: LinearFilter,\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      colorSpace: LinearSRGBColorSpace\n      //depthBuffer: false\n    };\n    const cubeUVRenderTarget = _createRenderTarget(width, height, params);\n    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {\n      if (this._pingPongRenderTarget !== null) {\n        this._dispose();\n      }\n      this._pingPongRenderTarget = _createRenderTarget(width, height, params);\n      const {\n        _lodMax\n      } = this;\n      ({\n        sizeLods: this._sizeLods,\n        lodPlanes: this._lodPlanes,\n        sigmas: this._sigmas,\n        lodMeshes: this._lodMeshes\n      } = _createPlanes(_lodMax));\n      this._blurMaterial = _getBlurShader(_lodMax, width, height);\n    }\n    return cubeUVRenderTarget;\n  }\n  async _compileMaterial(material) {\n    const tmpMesh = new Mesh(this._lodPlanes[0], material);\n    await this._renderer.compile(tmpMesh, _flatCamera);\n  }\n  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n    const cubeCamera = _cubeCamera;\n    cubeCamera.near = near;\n    cubeCamera.far = far;\n\n    // px, py, pz, nx, ny, nz\n    const upSign = [-1, 1, -1, -1, -1, -1];\n    const forwardSign = [1, 1, 1, -1, -1, -1];\n    const renderer = this._renderer;\n    const originalAutoClear = renderer.autoClear;\n    renderer.getClearColor(_clearColor);\n    renderer.autoClear = false;\n    let backgroundBox = this._backgroundBox;\n    if (backgroundBox === null) {\n      const backgroundMaterial = new MeshBasicMaterial({\n        name: 'PMREM.Background',\n        side: BackSide,\n        depthWrite: false,\n        depthTest: false\n      });\n      backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);\n    }\n    let useSolidColor = false;\n    const background = scene.background;\n    if (background) {\n      if (background.isColor) {\n        backgroundBox.material.color.copy(background);\n        scene.background = null;\n        useSolidColor = true;\n      }\n    } else {\n      backgroundBox.material.color.copy(_clearColor);\n      useSolidColor = true;\n    }\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.clear();\n    if (useSolidColor) {\n      renderer.render(backgroundBox, cubeCamera);\n    }\n    for (let i = 0; i < 6; i++) {\n      const col = i % 3;\n      if (col === 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col === 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n      const size = this._cubeSize;\n      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);\n      renderer.render(scene, cubeCamera);\n    }\n    renderer.autoClear = originalAutoClear;\n    scene.background = background;\n  }\n  _textureToCubeUV(texture, cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;\n    if (isCubeTexture) {\n      if (this._cubemapMaterial === null) {\n        this._cubemapMaterial = _getCubemapMaterial(texture);\n      }\n    } else {\n      if (this._equirectMaterial === null) {\n        this._equirectMaterial = _getEquirectMaterial(texture);\n      }\n    }\n    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n    material.fragmentNode.value = texture;\n    const mesh = this._lodMeshes[0];\n    mesh.material = material;\n    const size = this._cubeSize;\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.render(mesh, _flatCamera);\n  }\n  _applyPMREM(cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    const n = this._lodPlanes.length;\n    for (let i = 1; i < n; i++) {\n      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);\n      const poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];\n      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n    }\n    renderer.autoClear = autoClear;\n  }\n\n  /**\n   * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n   * vertically and horizontally, but this breaks down on a cube. Here we apply\n   * the blur latitudinally (around the poles), and then longitudinally (towards\n   * the poles) to approximate the orthogonally-separable blur. It is least\n   * accurate at the poles, but still does a decent job.\n   */\n  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n    const pingPongRenderTarget = this._pingPongRenderTarget;\n    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n  }\n  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n    const renderer = this._renderer;\n    const blurMaterial = this._blurMaterial;\n    if (direction !== 'latitudinal' && direction !== 'longitudinal') {\n      console.error('blur direction must be either latitudinal or longitudinal!');\n    }\n\n    // Number of standard deviations at which to cut off the discrete approximation.\n    const STANDARD_DEVIATIONS = 3;\n    const blurMesh = this._lodMeshes[lodOut];\n    blurMesh.material = blurMaterial;\n    const blurUniforms = blurMaterial.uniforms;\n    const pixels = this._sizeLods[lodIn] - 1;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n    const weights = [];\n    let sum = 0;\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n      if (i === 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n    targetIn.texture.frame = (targetIn.texture.frame || 0) + 1;\n    blurUniforms.envMap.value = targetIn.texture;\n    blurUniforms.samples.value = samples;\n    blurUniforms.weights.array = weights;\n    blurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;\n    if (poleAxis) {\n      blurUniforms.poleAxis.value = poleAxis;\n    }\n    const {\n      _lodMax\n    } = this;\n    blurUniforms.dTheta.value = radiansPerPixel;\n    blurUniforms.mipInt.value = _lodMax - lodIn;\n    const outputSize = this._sizeLods[lodOut];\n    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);\n    const y = 4 * (this._cubeSize - outputSize);\n    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n    renderer.setRenderTarget(targetOut);\n    renderer.render(blurMesh, _flatCamera);\n  }\n}\nfunction _createPlanes(lodMax) {\n  const lodPlanes = [];\n  const sizeLods = [];\n  const sigmas = [];\n  const lodMeshes = [];\n  let lod = lodMax;\n  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n  for (let i = 0; i < totalLods; i++) {\n    const sizeLod = Math.pow(2, lod);\n    sizeLods.push(sizeLod);\n    let sigma = 1.0 / sizeLod;\n    if (i > lodMax - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];\n    } else if (i === 0) {\n      sigma = 0;\n    }\n    sigmas.push(sigma);\n    const texelSize = 1.0 / (sizeLod - 2);\n    const min = -texelSize;\n    const max = 1 + texelSize;\n    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    const cubeFaces = 6;\n    const vertices = 6;\n    const positionSize = 3;\n    const uvSize = 2;\n    const faceIndexSize = 1;\n    const position = new Float32Array(positionSize * vertices * cubeFaces);\n    const uv = new Float32Array(uvSize * vertices * cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n    for (let face = 0; face < cubeFaces; face++) {\n      const x = face % 3 * 2 / 3 - 1;\n      const y = face > 2 ? 0 : -1;\n      const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n      const faceIdx = _faceLib[face];\n      position.set(coordinates, positionSize * vertices * faceIdx);\n      uv.set(uv1, uvSize * vertices * faceIdx);\n      const fill = [faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx];\n      faceIndex.set(fill, faceIndexSize * vertices * faceIdx);\n    }\n    const planes = new BufferGeometry();\n    planes.setAttribute('position', new BufferAttribute(position, positionSize));\n    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));\n    lodPlanes.push(planes);\n    lodMeshes.push(new Mesh(planes, null));\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n  return {\n    lodPlanes,\n    sizeLods,\n    sigmas,\n    lodMeshes\n  };\n}\nfunction _createRenderTarget(width, height, params) {\n  const cubeUVRenderTarget = new RenderTarget(width, height, params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n  cubeUVRenderTarget.texture.isPMREMTexture = true;\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\nfunction _getMaterial(type) {\n  const material = new NodeMaterial();\n  material.depthTest = false;\n  material.depthWrite = false;\n  material.blending = NoBlending;\n  material.name = `PMREM_${type}`;\n  return material;\n}\nfunction _getBlurShader(lodMax, width, height) {\n  const weights = uniformArray(new Array(MAX_SAMPLES).fill(0));\n  const poleAxis = uniform(new Vector3(0, 1, 0));\n  const dTheta = uniform(0);\n  const n = float(MAX_SAMPLES);\n  const latitudinal = uniform(0); // false, bool\n  const samples = uniform(1); // int\n  const envMap = texture(null);\n  const mipInt = uniform(0); // int\n  const CUBEUV_TEXEL_WIDTH = float(1 / width);\n  const CUBEUV_TEXEL_HEIGHT = float(1 / height);\n  const CUBEUV_MAX_MIP = float(lodMax);\n  const materialUniforms = {\n    n,\n    latitudinal,\n    weights,\n    poleAxis,\n    outputDirection,\n    dTheta,\n    samples,\n    envMap,\n    mipInt,\n    CUBEUV_TEXEL_WIDTH,\n    CUBEUV_TEXEL_HEIGHT,\n    CUBEUV_MAX_MIP\n  };\n  const material = _getMaterial('blur');\n  material.uniforms = materialUniforms; // TODO: Move to outside of the material\n  material.fragmentNode = blur({\n    ...materialUniforms,\n    latitudinal: latitudinal.equal(1)\n  });\n  return material;\n}\nfunction _getCubemapMaterial(envTexture) {\n  const material = _getMaterial('cubemap');\n  material.fragmentNode = cubeTexture(envTexture, outputDirection);\n  return material;\n}\nfunction _getEquirectMaterial(envTexture) {\n  const material = _getMaterial('equirect');\n  material.fragmentNode = texture(envTexture, equirectUV(outputDirection), 0);\n  return material;\n}\nconst rendererCache = new WeakMap();\nconst typeFromArray = new Map([[Int8Array, 'int'], [Int16Array, 'int'], [Int32Array, 'int'], [Uint8Array, 'uint'], [Uint16Array, 'uint'], [Uint32Array, 'uint'], [Float32Array, 'float']]);\nconst toFloat = value => {\n  if (/e/g.test(value)) {\n    return String(value).replace(/\\+/g, '');\n  } else {\n    value = Number(value);\n    return value + (value % 1 ? '' : '.0');\n  }\n};\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object && object.material || null;\n    this.geometry = object && object.geometry || null;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.scene = null;\n    this.camera = null;\n    this.nodes = [];\n    this.sequentialNodes = [];\n    this.updateNodes = [];\n    this.updateBeforeNodes = [];\n    this.updateAfterNodes = [];\n    this.hashNodes = {};\n    this.monitor = null;\n    this.lightsNode = null;\n    this.environmentNode = null;\n    this.fogNode = null;\n    this.clippingContext = null;\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.computeShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: '',\n      compute: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.structs = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.bindings = {\n      vertex: {},\n      fragment: {},\n      compute: {}\n    };\n    this.bindingsIndexes = {};\n    this.bindGroups = null;\n    this.attributes = [];\n    this.bufferAttributes = [];\n    this.varyings = [];\n    this.codes = {};\n    this.vars = {};\n    this.flow = {\n      code: ''\n    };\n    this.chaining = [];\n    this.stack = stack();\n    this.stacks = [];\n    this.tab = '\\t';\n    this.currentFunctionNode = null;\n    this.context = {\n      material: this.material\n    };\n    this.cache = new NodeCache();\n    this.globalCache = this.cache;\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.buildStage = null;\n    this.useComparisonMethod = false;\n  }\n  getBindGroupsCache() {\n    let bindGroupsCache = rendererCache.get(this.renderer);\n    if (bindGroupsCache === undefined) {\n      bindGroupsCache = new ChainMap();\n      rendererCache.set(this.renderer, bindGroupsCache);\n    }\n    return bindGroupsCache;\n  }\n  createRenderTarget(width, height, options) {\n    return new RenderTarget(width, height, options);\n  }\n  createCubeRenderTarget(size, options) {\n    return new CubeRenderTarget(size, options);\n  }\n  createPMREMGenerator() {\n    // TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support\n\n    return new PMREMGenerator(this.renderer);\n  }\n  includes(node) {\n    return this.nodes.includes(node);\n  }\n  _getBindGroup(groupName, bindings) {\n    const bindGroupsCache = this.getBindGroupsCache();\n\n    //\n\n    const bindingsArray = [];\n    let sharedGroup = true;\n    for (const binding of bindings) {\n      bindingsArray.push(binding);\n      sharedGroup = sharedGroup && binding.groupNode.shared !== true;\n    }\n\n    //\n\n    let bindGroup;\n    if (sharedGroup) {\n      bindGroup = bindGroupsCache.get(bindingsArray);\n      if (bindGroup === undefined) {\n        bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);\n        bindGroupsCache.set(bindingsArray, bindGroup);\n      }\n    } else {\n      bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);\n    }\n    return bindGroup;\n  }\n  getBindGroupArray(groupName, shaderStage) {\n    const bindings = this.bindings[shaderStage];\n    let bindGroup = bindings[groupName];\n    if (bindGroup === undefined) {\n      if (this.bindingsIndexes[groupName] === undefined) {\n        this.bindingsIndexes[groupName] = {\n          binding: 0,\n          group: Object.keys(this.bindingsIndexes).length\n        };\n      }\n      bindings[groupName] = bindGroup = [];\n    }\n    return bindGroup;\n  }\n  getBindings() {\n    let bindingsGroups = this.bindGroups;\n    if (bindingsGroups === null) {\n      const groups = {};\n      const bindings = this.bindings;\n      for (const shaderStage of shaderStages) {\n        for (const groupName in bindings[shaderStage]) {\n          const uniforms = bindings[shaderStage][groupName];\n          const groupUniforms = groups[groupName] || (groups[groupName] = []);\n          groupUniforms.push(...uniforms);\n        }\n      }\n      bindingsGroups = [];\n      for (const groupName in groups) {\n        const group = groups[groupName];\n        const bindingsGroup = this._getBindGroup(groupName, group);\n        bindingsGroups.push(bindingsGroup);\n      }\n      this.bindGroups = bindingsGroups;\n    }\n    return bindingsGroups;\n  }\n  sortBindingGroups() {\n    const bindingsGroups = this.getBindings();\n    bindingsGroups.sort((a, b) => a.bindings[0].groupNode.order - b.bindings[0].groupNode.order);\n    for (let i = 0; i < bindingsGroups.length; i++) {\n      const bindingGroup = bindingsGroups[i];\n      this.bindingsIndexes[bindingGroup.name].group = i;\n      bindingGroup.index = i;\n    }\n  }\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n  addNode(node) {\n    if (this.nodes.includes(node) === false) {\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n  addSequentialNode(node) {\n    if (this.sequentialNodes.includes(node) === false) {\n      this.sequentialNodes.push(node);\n    }\n  }\n  buildUpdateNodes() {\n    for (const node of this.nodes) {\n      const updateType = node.getUpdateType();\n      if (updateType !== NodeUpdateType.NONE) {\n        this.updateNodes.push(node.getSelf());\n      }\n    }\n    for (const node of this.sequentialNodes) {\n      const updateBeforeType = node.getUpdateBeforeType();\n      const updateAfterType = node.getUpdateAfterType();\n      if (updateBeforeType !== NodeUpdateType.NONE) {\n        this.updateBeforeNodes.push(node.getSelf());\n      }\n      if (updateAfterType !== NodeUpdateType.NONE) {\n        this.updateAfterNodes.push(node.getSelf());\n      }\n    }\n  }\n  get currentNode() {\n    return this.chaining[this.chaining.length - 1];\n  }\n  isFilteredTexture(texture) {\n    return texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter;\n  }\n  addChain(node) {\n    /*\n    if ( this.chaining.indexOf( node ) !== - 1 ) {\n    \t\tconsole.warn( 'Recursive node: ', node );\n    \t}\n    */\n\n    this.chaining.push(node);\n  }\n  removeChain(node) {\n    const lastChain = this.chaining.pop();\n    if (lastChain !== node) {\n      throw new Error('NodeBuilder: Invalid node chaining!');\n    }\n  }\n  getMethod(method) {\n    return method;\n  }\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n  setContext(context) {\n    this.context = context;\n  }\n  getContext() {\n    return this.context;\n  }\n  getSharedContext() {\n    ({\n      ...this.context\n    });\n    return this.context;\n  }\n  setCache(cache) {\n    this.cache = cache;\n  }\n  getCache() {\n    return this.cache;\n  }\n  getCacheFromNode(node) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const data = this.getDataFromNode(node);\n    if (data.cache === undefined) data.cache = new NodeCache(parent ? this.getCache() : null);\n    return data.cache;\n  }\n  isAvailable(/*name*/\n  ) {\n    return false;\n  }\n  getVertexIndex() {\n    console.warn('Abstract function.');\n  }\n  getInstanceIndex() {\n    console.warn('Abstract function.');\n  }\n  getDrawIndex() {\n    console.warn('Abstract function.');\n  }\n  getFrontFacing() {\n    console.warn('Abstract function.');\n  }\n  getFragCoord() {\n    console.warn('Abstract function.');\n  }\n  isFlipY() {\n    return false;\n  }\n  increaseUsage(node) {\n    const nodeData = this.getDataFromNode(node);\n    nodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;\n    return nodeData.usageCount;\n  }\n  generateTexture(/* texture, textureProperty, uvSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n  generateTextureLod(/* texture, textureProperty, uvSnippet, levelSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n  generateConst(type) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (value === null) {\n      if (type === 'float' || type === 'int' || type === 'uint') value = 0;else if (type === 'bool') value = false;else if (type === 'color') value = new Color();else if (type === 'vec2') value = new Vector2();else if (type === 'vec3') value = new Vector3();else if (type === 'vec4') value = new Vector4();\n    }\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n    if (type === 'color') return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n    const generateConst = value => this.generateConst(componentType, value);\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;\n    } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {\n      return `${this.getType(type)}( ${value.elements.map(generateConst).join(', ')} )`;\n    } else if (typeLength > 4) {\n      return `${this.getType(type)}()`;\n    }\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n  getType(type) {\n    if (type === 'color') return 'vec3';\n    return type;\n  }\n  hasGeometryAttribute(name) {\n    return this.geometry && this.geometry.getAttribute(name) !== undefined;\n  }\n  getAttribute(name, type) {\n    const attributes = this.attributes;\n\n    // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    }\n\n    // create a new if no exist\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n  getPropertyName(node /*, shaderStage*/) {\n    return node.name;\n  }\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';\n  }\n  needsToWorkingColorSpace(/*texture*/\n  ) {\n    return false;\n  }\n  getComponentTypeFromTexture(texture) {\n    const type = texture.type;\n    if (texture.isDataTexture) {\n      if (type === IntType) return 'int';\n      if (type === UnsignedIntType) return 'uint';\n    }\n    return 'float';\n  }\n  getElementType(type) {\n    if (type === 'mat2') return 'vec2';\n    if (type === 'mat3') return 'vec3';\n    if (type === 'mat4') return 'vec4';\n    return this.getComponentType(type);\n  }\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') return 'vec4';\n    return type;\n  }\n  getTypeFromLength(length) {\n    let componentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'float';\n    if (length === 1) return componentType;\n    const baseType = getTypeFromLength(length);\n    const prefix = componentType === 'float' ? '' : componentType[0];\n    return prefix + baseType;\n  }\n  getTypeFromArray(array) {\n    return typeFromArray.get(array.constructor);\n  }\n  getTypeFromAttribute(attribute) {\n    let dataAttribute = attribute;\n    if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;\n    const array = dataAttribute.array;\n    const itemSize = attribute.itemSize;\n    const normalized = attribute.normalized;\n    let arrayType;\n    if (!(attribute instanceof Float16BufferAttribute) && normalized !== true) {\n      arrayType = this.getTypeFromArray(array);\n    }\n    return this.getTypeFromLength(itemSize, arrayType);\n  }\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    if (/mat2/.test(type) === true) return 4;\n    if (/mat3/.test(type) === true) return 9;\n    if (/mat4/.test(type) === true) return 16;\n    return 0;\n  }\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n  changeComponentType(type, newComponentType) {\n    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);\n  }\n  getIntegerType(type) {\n    const componentType = this.getComponentType(type);\n    if (componentType === 'int' || componentType === 'uint') return type;\n    return this.changeComponentType(type, 'int');\n  }\n  addStack() {\n    this.stack = stack(this.stack);\n    this.stacks.push(getCurrentStack() || this.stack);\n    setCurrentStack(this.stack);\n    return this.stack;\n  }\n  removeStack() {\n    const lastStack = this.stack;\n    this.stack = lastStack.parent;\n    setCurrentStack(this.stacks.pop());\n    return lastStack;\n  }\n  getDataFromNode(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    let cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    cache = cache === null ? node.isGlobal(this) ? this.globalCache : this.cache : cache;\n    let nodeData = cache.getData(node);\n    if (nodeData === undefined) {\n      nodeData = {};\n      cache.setData(node, nodeData);\n    }\n    if (nodeData[shaderStage] === undefined) nodeData[shaderStage] = {};\n    return nodeData[shaderStage];\n  }\n  getNodeProperties(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    return nodeData.properties || (nodeData.properties = {\n      outputNode: null\n    });\n  }\n  getBufferAttributeFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node);\n    let bufferAttribute = nodeData.bufferAttribute;\n    if (bufferAttribute === undefined) {\n      const index = this.uniforms.index++;\n      bufferAttribute = new NodeAttribute('nodeAttribute' + index, type, node);\n      this.bufferAttributes.push(bufferAttribute);\n      nodeData.bufferAttribute = bufferAttribute;\n    }\n    return bufferAttribute;\n  }\n  getStructTypeFromNode(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    if (nodeData.structType === undefined) {\n      const index = this.structs.index++;\n      node.name = `StructType${index}`;\n      this.structs[shaderStage].push(node);\n      nodeData.structType = node;\n    }\n    return node;\n  }\n  getUniformFromNode(node, type) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    let name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);\n    let nodeUniform = nodeData.uniform;\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform(name || 'nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n    return nodeUniform;\n  }\n  getVarFromNode(node) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.getNodeType(this);\n    let shaderStage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);\n      if (name === null) name = 'nodeVar' + vars.length;\n      nodeVar = new NodeVar(name, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n    return nodeVar;\n  }\n  getVaryingFromNode(node) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.getNodeType(this);\n    const nodeData = this.getDataFromNode(node, 'any');\n    let nodeVarying = nodeData.varying;\n    if (nodeVarying === undefined) {\n      const varyings = this.varyings;\n      const index = varyings.length;\n      if (name === null) name = 'nodeVarying' + index;\n      nodeVarying = new NodeVarying(name, type);\n      varyings.push(nodeVarying);\n      nodeData.varying = nodeVarying;\n    }\n    return nodeVarying;\n  }\n  getCodeFromNode(node, type) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n    return nodeCode;\n  }\n  addFlowCodeHierarchy(node, nodeBlock) {\n    const {\n      flowCodes,\n      flowCodeBlock\n    } = this.getDataFromNode(node);\n    let needsFlowCode = true;\n    let nodeBlockHierarchy = nodeBlock;\n    while (nodeBlockHierarchy) {\n      if (flowCodeBlock.get(nodeBlockHierarchy) === true) {\n        needsFlowCode = false;\n        break;\n      }\n      nodeBlockHierarchy = this.getDataFromNode(nodeBlockHierarchy).parentNodeBlock;\n    }\n    if (needsFlowCode) {\n      for (const flowCode of flowCodes) {\n        this.addLineFlowCode(flowCode);\n      }\n    }\n  }\n  addLineFlowCodeBlock(node, code, nodeBlock) {\n    const nodeData = this.getDataFromNode(node);\n    const flowCodes = nodeData.flowCodes || (nodeData.flowCodes = []);\n    const codeBlock = nodeData.flowCodeBlock || (nodeData.flowCodeBlock = new WeakMap());\n    flowCodes.push(code);\n    codeBlock.set(nodeBlock, true);\n  }\n  addLineFlowCode(code) {\n    let node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (code === '') return this;\n    if (node !== null && this.context.nodeBlock) {\n      this.addLineFlowCodeBlock(node, code, this.context.nodeBlock);\n    }\n    code = this.tab + code;\n    if (!/;\\s*$/.test(code)) {\n      code = code + ';\\n';\n    }\n    this.flow.code += code;\n    return this;\n  }\n  addFlowCode(code) {\n    this.flow.code += code;\n    return this;\n  }\n  addFlowTab() {\n    this.tab += '\\t';\n    return this;\n  }\n  removeFlowTab() {\n    this.tab = this.tab.slice(0, -1);\n    return this;\n  }\n  getFlowData(node /*, shaderStage*/) {\n    return this.flowsData.get(node);\n  }\n  flowNode(node) {\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    return flowData;\n  }\n  buildFunctionNode(shaderNode) {\n    const fn = new FunctionNode();\n    const previous = this.currentFunctionNode;\n    this.currentFunctionNode = fn;\n    fn.code = this.buildFunctionCode(shaderNode);\n    this.currentFunctionNode = previous;\n    return fn;\n  }\n  flowShaderNode(shaderNode) {\n    const layout = shaderNode.layout;\n    const inputs = {\n      [Symbol.iterator]() {\n        let index = 0;\n        const values = Object.values(this);\n        return {\n          next: () => ({\n            value: values[index],\n            done: index++ >= values.length\n          })\n        };\n      }\n    };\n    for (const input of layout.inputs) {\n      inputs[input.name] = new ParameterNode(input.type, input.name);\n    }\n\n    //\n\n    shaderNode.layout = null;\n    const callNode = shaderNode.call(inputs);\n    const flowData = this.flowStagesNode(callNode, layout.type);\n    shaderNode.layout = layout;\n    return flowData;\n  }\n  flowStagesNode(node) {\n    let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const previousFlow = this.flow;\n    const previousVars = this.vars;\n    const previousCache = this.cache;\n    const previousBuildStage = this.buildStage;\n    const previousStack = this.stack;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    this.vars = {};\n    this.cache = new NodeCache();\n    this.stack = stack();\n    for (const buildStage of defaultBuildStages) {\n      this.setBuildStage(buildStage);\n      flow.result = node.build(this, output);\n    }\n    flow.vars = this.getVars(this.shaderStage);\n    this.flow = previousFlow;\n    this.vars = previousVars;\n    this.cache = previousCache;\n    this.stack = previousStack;\n    this.setBuildStage(previousBuildStage);\n    return flow;\n  }\n  getFunctionOperator() {\n    return null;\n  }\n  flowChildNode(node) {\n    let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n  flowNodeFromShaderStage(shaderStage, node) {\n    let output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let propertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n    if (propertyName !== null) {\n      flowData.code += `${this.tab + propertyName} = ${flowData.result};\\n`;\n    }\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n  getAttributesArray() {\n    return this.attributes.concat(this.bufferAttributes);\n  }\n  getAttributes(/*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getVaryings(/*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getVar(type, name) {\n    return `${this.getType(type)} ${name}`;\n  }\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n    if (vars !== undefined) {\n      for (const variable of vars) {\n        snippet += `${this.getVar(variable.type, variable.name)}; `;\n      }\n    }\n    return snippet;\n  }\n  getUniforms(/*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n    if (codes !== undefined) {\n      for (const nodeCode of codes) {\n        code += nodeCode.code + '\\n';\n      }\n    }\n    return code;\n  }\n  getHash() {\n    return this.vertexShader + this.fragmentShader + this.computeShader;\n  }\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n  getShaderStage() {\n    return this.shaderStage;\n  }\n  setBuildStage(buildStage) {\n    this.buildStage = buildStage;\n  }\n  getBuildStage() {\n    return this.buildStage;\n  }\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n  build() {\n    const {\n      object,\n      material,\n      renderer\n    } = this;\n    if (material !== null) {\n      let nodeMaterial = renderer.library.fromMaterial(material);\n      if (nodeMaterial === null) {\n        console.error(`NodeMaterial: Material \"${material.type}\" is not compatible.`);\n        nodeMaterial = new NodeMaterial();\n      }\n      nodeMaterial.build(this);\n    } else {\n      this.addFlow('compute', object);\n    }\n\n    // setup() -> stage 1: create possible new nodes and returns an output reference node\n    // analyze()   -> stage 2: analyze nodes to possible optimization and validation\n    // generate()  -> stage 3: generate shader\n\n    for (const buildStage of defaultBuildStages) {\n      this.setBuildStage(buildStage);\n      if (this.context.vertex && this.context.vertex.isNode) {\n        this.flowNodeFromShaderStage('vertex', this.context.vertex);\n      }\n      for (const shaderStage of shaderStages) {\n        this.setShaderStage(shaderStage);\n        const flowNodes = this.flowNodes[shaderStage];\n        for (const node of flowNodes) {\n          if (buildStage === 'generate') {\n            this.flowNode(node);\n          } else {\n            node.build(this);\n          }\n        }\n      }\n    }\n    this.setBuildStage(null);\n    this.setShaderStage(null);\n\n    // stage 4: build code for a specific output\n\n    this.buildCode();\n    this.buildUpdateNodes();\n    return this;\n  }\n  getNodeUniform(uniformNode, type) {\n    if (type === 'float' || type === 'int' || type === 'uint') return new NumberNodeUniform(uniformNode);\n    if (type === 'vec2' || type === 'ivec2' || type === 'uvec2') return new Vector2NodeUniform(uniformNode);\n    if (type === 'vec3' || type === 'ivec3' || type === 'uvec3') return new Vector3NodeUniform(uniformNode);\n    if (type === 'vec4' || type === 'ivec4' || type === 'uvec4') return new Vector4NodeUniform(uniformNode);\n    if (type === 'color') return new ColorNodeUniform(uniformNode);\n    if (type === 'mat3') return new Matrix3NodeUniform(uniformNode);\n    if (type === 'mat4') return new Matrix4NodeUniform(uniformNode);\n    throw new Error(`Uniform \"${type}\" not declared.`);\n  }\n  createNodeMaterial() {\n    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'NodeMaterial';\n    // @deprecated, r168\n\n    throw new Error(`THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${type}() instead.`);\n  }\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n    if (fromTypeLength === 16 && toTypeLength === 9) {\n      return `${this.getType(toType)}(${snippet}[0].xyz, ${snippet}[1].xyz, ${snippet}[2].xyz)`;\n    }\n    if (fromTypeLength === 9 && toTypeLength === 4) {\n      return `${this.getType(toType)}(${snippet}[0].xy, ${snippet}[1].xy)`;\n    }\n    if (fromTypeLength > 4) {\n      // fromType is matrix-like\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (toTypeLength > 4 || toTypeLength === 0) {\n      // toType is matrix-like or unknown\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);\n    }\n    if (toTypeLength === 4 && fromTypeLength > 1) {\n      // toType is vec4-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n    if (fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType(toType)) {\n      // fromType is float-like\n\n      // convert a number value to vector type, e.g:\n      // vec3( 1u ) -> vec3( float( 1u ) )\n\n      snippet = `${this.getType(this.getComponentType(toType))}( ${snippet} )`;\n    }\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n  getSignature() {\n    return `// Three.js r${REVISION} - Node System\\n`;\n  }\n}\nclass NodeFrame {\n  constructor() {\n    this.time = 0;\n    this.deltaTime = 0;\n    this.frameId = 0;\n    this.renderId = 0;\n    this.startTime = null;\n    this.updateMap = new WeakMap();\n    this.updateBeforeMap = new WeakMap();\n    this.updateAfterMap = new WeakMap();\n    this.renderer = null;\n    this.material = null;\n    this.camera = null;\n    this.object = null;\n    this.scene = null;\n  }\n  _getMaps(referenceMap, nodeRef) {\n    let maps = referenceMap.get(nodeRef);\n    if (maps === undefined) {\n      maps = {\n        renderMap: new WeakMap(),\n        frameMap: new WeakMap()\n      };\n      referenceMap.set(nodeRef, maps);\n    }\n    return maps;\n  }\n  updateBeforeNode(node) {\n    const updateType = node.getUpdateBeforeType();\n    const reference = node.updateReference(this);\n    if (updateType === NodeUpdateType.FRAME) {\n      const {\n        frameMap\n      } = this._getMaps(this.updateBeforeMap, reference);\n      if (frameMap.get(reference) !== this.frameId) {\n        if (node.updateBefore(this) !== false) {\n          frameMap.set(reference, this.frameId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.RENDER) {\n      const {\n        renderMap\n      } = this._getMaps(this.updateBeforeMap, reference);\n      if (renderMap.get(reference) !== this.renderId) {\n        if (node.updateBefore(this) !== false) {\n          renderMap.set(reference, this.renderId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.OBJECT) {\n      node.updateBefore(this);\n    }\n  }\n  updateAfterNode(node) {\n    const updateType = node.getUpdateAfterType();\n    const reference = node.updateReference(this);\n    if (updateType === NodeUpdateType.FRAME) {\n      const {\n        frameMap\n      } = this._getMaps(this.updateAfterMap, reference);\n      if (frameMap.get(reference) !== this.frameId) {\n        if (node.updateAfter(this) !== false) {\n          frameMap.set(reference, this.frameId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.RENDER) {\n      const {\n        renderMap\n      } = this._getMaps(this.updateAfterMap, reference);\n      if (renderMap.get(reference) !== this.renderId) {\n        if (node.updateAfter(this) !== false) {\n          renderMap.set(reference, this.renderId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.OBJECT) {\n      node.updateAfter(this);\n    }\n  }\n  updateNode(node) {\n    const updateType = node.getUpdateType();\n    const reference = node.updateReference(this);\n    if (updateType === NodeUpdateType.FRAME) {\n      const {\n        frameMap\n      } = this._getMaps(this.updateMap, reference);\n      if (frameMap.get(reference) !== this.frameId) {\n        if (node.update(this) !== false) {\n          frameMap.set(reference, this.frameId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.RENDER) {\n      const {\n        renderMap\n      } = this._getMaps(this.updateMap, reference);\n      if (renderMap.get(reference) !== this.renderId) {\n        if (node.update(this) !== false) {\n          renderMap.set(reference, this.renderId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.OBJECT) {\n      node.update(this);\n    }\n  }\n  update() {\n    this.frameId++;\n    if (this.lastTime === undefined) this.lastTime = performance.now();\n    this.deltaTime = (performance.now() - this.lastTime) / 1000;\n    this.lastTime = performance.now();\n    this.time += this.deltaTime;\n  }\n}\nclass NodeFunctionInput {\n  constructor(type, name) {\n    let count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let qualifier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    let isConst = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    this.type = type;\n    this.name = name;\n    this.count = count;\n    this.qualifier = qualifier;\n    this.isConst = isConst;\n  }\n}\nNodeFunctionInput.isNodeFunctionInput = true;\nclass DirectionalLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'DirectionalLightNode';\n  }\n  constructor() {\n    let light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(light);\n  }\n  setup(builder) {\n    super.setup(builder);\n    const lightingModel = builder.context.lightingModel;\n    const lightColor = this.colorNode;\n    const lightDirection = lightTargetDirection(this.light);\n    const reflectedLight = builder.context.reflectedLight;\n    lightingModel.direct({\n      lightDirection,\n      lightColor,\n      reflectedLight\n    }, builder.stack, builder);\n  }\n}\nconst _matrix41 = /*@__PURE__*/new Matrix4();\nconst _matrix42 = /*@__PURE__*/new Matrix4();\nlet ltcLib = null;\nclass RectAreaLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'RectAreaLightNode';\n  }\n  constructor() {\n    let light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(light);\n    this.halfHeight = uniform(new Vector3()).setGroup(renderGroup);\n    this.halfWidth = uniform(new Vector3()).setGroup(renderGroup);\n    this.updateType = NodeUpdateType.RENDER;\n  }\n  update(frame) {\n    super.update(frame);\n    const {\n      light\n    } = this;\n    const viewMatrix = frame.camera.matrixWorldInverse;\n    _matrix42.identity();\n    _matrix41.copy(light.matrixWorld);\n    _matrix41.premultiply(viewMatrix);\n    _matrix42.extractRotation(_matrix41);\n    this.halfWidth.value.set(light.width * 0.5, 0.0, 0.0);\n    this.halfHeight.value.set(0.0, light.height * 0.5, 0.0);\n    this.halfWidth.value.applyMatrix4(_matrix42);\n    this.halfHeight.value.applyMatrix4(_matrix42);\n  }\n  setup(builder) {\n    super.setup(builder);\n    let ltc_1, ltc_2;\n    if (builder.isAvailable('float32Filterable')) {\n      ltc_1 = texture(ltcLib.LTC_FLOAT_1);\n      ltc_2 = texture(ltcLib.LTC_FLOAT_2);\n    } else {\n      ltc_1 = texture(ltcLib.LTC_HALF_1);\n      ltc_2 = texture(ltcLib.LTC_HALF_2);\n    }\n    const {\n      colorNode,\n      light\n    } = this;\n    const lightingModel = builder.context.lightingModel;\n    const lightPosition = lightViewPosition(light);\n    const reflectedLight = builder.context.reflectedLight;\n    lightingModel.directRectArea({\n      lightColor: colorNode,\n      lightPosition,\n      halfWidth: this.halfWidth,\n      halfHeight: this.halfHeight,\n      reflectedLight,\n      ltc_1,\n      ltc_2\n    }, builder.stack, builder);\n  }\n  static setLTC(ltc) {\n    ltcLib = ltc;\n  }\n}\nclass SpotLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'SpotLightNode';\n  }\n  constructor() {\n    let light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(light);\n    this.coneCosNode = uniform(0).setGroup(renderGroup);\n    this.penumbraCosNode = uniform(0).setGroup(renderGroup);\n    this.cutoffDistanceNode = uniform(0).setGroup(renderGroup);\n    this.decayExponentNode = uniform(0).setGroup(renderGroup);\n  }\n  update(frame) {\n    super.update(frame);\n    const {\n      light\n    } = this;\n    this.coneCosNode.value = Math.cos(light.angle);\n    this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));\n    this.cutoffDistanceNode.value = light.distance;\n    this.decayExponentNode.value = light.decay;\n  }\n  getSpotAttenuation(angleCosine) {\n    const {\n      coneCosNode,\n      penumbraCosNode\n    } = this;\n    return smoothstep(coneCosNode, penumbraCosNode, angleCosine);\n  }\n  setup(builder) {\n    super.setup(builder);\n    const lightingModel = builder.context.lightingModel;\n    const {\n      colorNode,\n      cutoffDistanceNode,\n      decayExponentNode,\n      light\n    } = this;\n    const lVector = lightViewPosition(light).sub(positionView); // @TODO: Add it into LightNode\n\n    const lightDirection = lVector.normalize();\n    const angleCos = lightDirection.dot(lightTargetDirection(light));\n    const spotAttenuation = this.getSpotAttenuation(angleCos);\n    const lightDistance = lVector.length();\n    const lightAttenuation = getDistanceAttenuation({\n      lightDistance,\n      cutoffDistance: cutoffDistanceNode,\n      decayExponent: decayExponentNode\n    });\n    let lightColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);\n    if (light.map) {\n      const spotLightCoord = lightProjectionUV(light);\n      const projectedTexture = texture(light.map, spotLightCoord.xy).onRenderUpdate(() => light.map);\n      const inSpotLightMap = spotLightCoord.mul(2.).sub(1.).abs().lessThan(1.).all();\n      lightColor = inSpotLightMap.select(lightColor.mul(projectedTexture), lightColor);\n    }\n    const reflectedLight = builder.context.reflectedLight;\n    lightingModel.direct({\n      lightDirection,\n      lightColor,\n      reflectedLight\n    }, builder.stack, builder);\n  }\n}\nclass IESSpotLightNode extends SpotLightNode {\n  static get type() {\n    return 'IESSpotLightNode';\n  }\n  getSpotAttenuation(angleCosine) {\n    const iesMap = this.light.iesMap;\n    let spotAttenuation = null;\n    if (iesMap && iesMap.isTexture === true) {\n      const angle = angleCosine.acos().mul(1.0 / Math.PI);\n      spotAttenuation = texture(iesMap, vec2(angle, 0), 0).r;\n    } else {\n      spotAttenuation = super.getSpotAttenuation(angleCosine);\n    }\n    return spotAttenuation;\n  }\n}\nclass AmbientLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'AmbientLightNode';\n  }\n  constructor() {\n    let light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(light);\n  }\n  setup(_ref219) {\n    let {\n      context\n    } = _ref219;\n    context.irradiance.addAssign(this.colorNode);\n  }\n}\nclass HemisphereLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'HemisphereLightNode';\n  }\n  constructor() {\n    let light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(light);\n    this.lightPositionNode = lightPosition(light);\n    this.lightDirectionNode = this.lightPositionNode.normalize();\n    this.groundColorNode = uniform(new Color()).setGroup(renderGroup);\n  }\n  update(frame) {\n    const {\n      light\n    } = this;\n    super.update(frame);\n    this.lightPositionNode.object3d = light;\n    this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);\n  }\n  setup(builder) {\n    const {\n      colorNode,\n      groundColorNode,\n      lightDirectionNode\n    } = this;\n    const dotNL = normalView.dot(lightDirectionNode);\n    const hemiDiffuseWeight = dotNL.mul(0.5).add(0.5);\n    const irradiance = mix(groundColorNode, colorNode, hemiDiffuseWeight);\n    builder.context.irradiance.addAssign(irradiance);\n  }\n}\nclass LightProbeNode extends AnalyticLightNode {\n  static get type() {\n    return 'LightProbeNode';\n  }\n  constructor() {\n    let light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(light);\n    const array = [];\n    for (let i = 0; i < 9; i++) array.push(new Vector3());\n    this.lightProbe = uniformArray(array);\n  }\n  update(frame) {\n    const {\n      light\n    } = this;\n    super.update(frame);\n\n    //\n\n    for (let i = 0; i < 9; i++) {\n      this.lightProbe.array[i].copy(light.sh.coefficients[i]).multiplyScalar(light.intensity);\n    }\n  }\n  setup(builder) {\n    const irradiance = getShIrradianceAt(normalWorld, this.lightProbe);\n    builder.context.irradiance.addAssign(irradiance);\n  }\n}\nclass NodeParser {\n  parseFunction(/*source*/\n  ) {\n    console.warn('Abstract function.');\n  }\n}\nclass NodeFunction {\n  constructor(type, inputs) {\n    let name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    this.type = type;\n    this.inputs = inputs;\n    this.name = name;\n    this.precision = precision;\n  }\n  getCode(/*name = this.name*/\n  ) {\n    console.warn('Abstract function.');\n  }\n}\nNodeFunction.isNodeFunction = true;\nconst declarationRegexp$1 = /^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)/i;\nconst propertiesRegexp$1 = /[a-z_0-9]+/ig;\nconst pragmaMain = '#pragma main';\nconst parse$1 = source => {\n  source = source.trim();\n  const pragmaMainIndex = source.indexOf(pragmaMain);\n  const mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;\n  const declaration = mainCode.match(declarationRegexp$1);\n  if (declaration !== null && declaration.length === 5) {\n    // tokenizer\n\n    const inputsCode = declaration[4];\n    const propsMatches = [];\n    let nameMatch = null;\n    while ((nameMatch = propertiesRegexp$1.exec(inputsCode)) !== null) {\n      propsMatches.push(nameMatch);\n    }\n\n    // parser\n\n    const inputs = [];\n    let i = 0;\n    while (i < propsMatches.length) {\n      const isConst = propsMatches[i][0] === 'const';\n      if (isConst === true) {\n        i++;\n      }\n      let qualifier = propsMatches[i][0];\n      if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {\n        i++;\n      } else {\n        qualifier = '';\n      }\n      const type = propsMatches[i++][0];\n      let count = Number.parseInt(propsMatches[i][0]);\n      if (Number.isNaN(count) === false) i++;else count = null;\n      const name = propsMatches[i++][0];\n      inputs.push(new NodeFunctionInput(type, name, count, qualifier, isConst));\n    }\n\n    //\n\n    const blockCode = mainCode.substring(declaration[0].length);\n    const name = declaration[3] !== undefined ? declaration[3] : '';\n    const type = declaration[2];\n    const precision = declaration[1] !== undefined ? declaration[1] : '';\n    const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : '';\n    return {\n      type,\n      inputs,\n      name,\n      precision,\n      inputsCode,\n      blockCode,\n      headerCode\n    };\n  } else {\n    throw new Error('FunctionNode: Function is not a GLSL code.');\n  }\n};\nclass GLSLNodeFunction extends NodeFunction {\n  constructor(source) {\n    const {\n      type,\n      inputs,\n      name,\n      precision,\n      inputsCode,\n      blockCode,\n      headerCode\n    } = parse$1(source);\n    super(type, inputs, name, precision);\n    this.inputsCode = inputsCode;\n    this.blockCode = blockCode;\n    this.headerCode = headerCode;\n  }\n  getCode() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.name;\n    let code;\n    const blockCode = this.blockCode;\n    if (blockCode !== '') {\n      const {\n        type,\n        inputsCode,\n        headerCode,\n        precision\n      } = this;\n      let declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;\n      if (precision !== '') {\n        declarationCode = `${precision} ${declarationCode}`;\n      }\n      code = headerCode + declarationCode + blockCode;\n    } else {\n      // interface function\n\n      code = '';\n    }\n    return code;\n  }\n}\nclass GLSLNodeParser extends NodeParser {\n  parseFunction(source) {\n    return new GLSLNodeFunction(source);\n  }\n}\nconst outputNodeMap = new WeakMap();\nclass Nodes extends DataMap {\n  constructor(renderer, backend) {\n    super();\n    this.renderer = renderer;\n    this.backend = backend;\n    this.nodeFrame = new NodeFrame();\n    this.nodeBuilderCache = new Map();\n    this.callHashCache = new ChainMap();\n    this.groupsData = new ChainMap();\n  }\n  updateGroup(nodeUniformsGroup) {\n    const groupNode = nodeUniformsGroup.groupNode;\n    const name = groupNode.name;\n\n    // objectGroup is every updated\n\n    if (name === objectGroup.name) return true;\n\n    // renderGroup is updated once per render/compute call\n\n    if (name === renderGroup.name) {\n      const uniformsGroupData = this.get(nodeUniformsGroup);\n      const renderId = this.nodeFrame.renderId;\n      if (uniformsGroupData.renderId !== renderId) {\n        uniformsGroupData.renderId = renderId;\n        return true;\n      }\n      return false;\n    }\n\n    // frameGroup is updated once per frame\n\n    if (name === frameGroup.name) {\n      const uniformsGroupData = this.get(nodeUniformsGroup);\n      const frameId = this.nodeFrame.frameId;\n      if (uniformsGroupData.frameId !== frameId) {\n        uniformsGroupData.frameId = frameId;\n        return true;\n      }\n      return false;\n    }\n\n    // other groups are updated just when groupNode.needsUpdate is true\n\n    const groupChain = [groupNode, nodeUniformsGroup];\n    let groupData = this.groupsData.get(groupChain);\n    if (groupData === undefined) this.groupsData.set(groupChain, groupData = {});\n    if (groupData.version !== groupNode.version) {\n      groupData.version = groupNode.version;\n      return true;\n    }\n    return false;\n  }\n  getForRenderCacheKey(renderObject) {\n    return renderObject.initialCacheKey;\n  }\n  getForRender(renderObject) {\n    const renderObjectData = this.get(renderObject);\n    let nodeBuilderState = renderObjectData.nodeBuilderState;\n    if (nodeBuilderState === undefined) {\n      const {\n        nodeBuilderCache\n      } = this;\n      const cacheKey = this.getForRenderCacheKey(renderObject);\n      nodeBuilderState = nodeBuilderCache.get(cacheKey);\n      if (nodeBuilderState === undefined) {\n        const nodeBuilder = this.backend.createNodeBuilder(renderObject.object, this.renderer);\n        nodeBuilder.scene = renderObject.scene;\n        nodeBuilder.material = renderObject.material;\n        nodeBuilder.camera = renderObject.camera;\n        nodeBuilder.context.material = renderObject.material;\n        nodeBuilder.lightsNode = renderObject.lightsNode;\n        nodeBuilder.environmentNode = this.getEnvironmentNode(renderObject.scene);\n        nodeBuilder.fogNode = this.getFogNode(renderObject.scene);\n        nodeBuilder.clippingContext = renderObject.clippingContext;\n        nodeBuilder.build();\n        nodeBuilderState = this._createNodeBuilderState(nodeBuilder);\n        nodeBuilderCache.set(cacheKey, nodeBuilderState);\n      }\n      nodeBuilderState.usedTimes++;\n      renderObjectData.nodeBuilderState = nodeBuilderState;\n    }\n    return nodeBuilderState;\n  }\n  delete(object) {\n    if (object.isRenderObject) {\n      const nodeBuilderState = this.get(object).nodeBuilderState;\n      nodeBuilderState.usedTimes--;\n      if (nodeBuilderState.usedTimes === 0) {\n        this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));\n      }\n    }\n    return super.delete(object);\n  }\n  getForCompute(computeNode) {\n    const computeData = this.get(computeNode);\n    let nodeBuilderState = computeData.nodeBuilderState;\n    if (nodeBuilderState === undefined) {\n      const nodeBuilder = this.backend.createNodeBuilder(computeNode, this.renderer);\n      nodeBuilder.build();\n      nodeBuilderState = this._createNodeBuilderState(nodeBuilder);\n      computeData.nodeBuilderState = nodeBuilderState;\n    }\n    return nodeBuilderState;\n  }\n  _createNodeBuilderState(nodeBuilder) {\n    return new NodeBuilderState(nodeBuilder.vertexShader, nodeBuilder.fragmentShader, nodeBuilder.computeShader, nodeBuilder.getAttributesArray(), nodeBuilder.getBindings(), nodeBuilder.updateNodes, nodeBuilder.updateBeforeNodes, nodeBuilder.updateAfterNodes, nodeBuilder.monitor, nodeBuilder.transforms);\n  }\n  getEnvironmentNode(scene) {\n    return scene.environmentNode || this.get(scene).environmentNode || null;\n  }\n  getBackgroundNode(scene) {\n    return scene.backgroundNode || this.get(scene).backgroundNode || null;\n  }\n  getFogNode(scene) {\n    return scene.fogNode || this.get(scene).fogNode || null;\n  }\n  getCacheKey(scene, lightsNode) {\n    const chain = [scene, lightsNode];\n    const callId = this.renderer.info.calls;\n    let cacheKeyData = this.callHashCache.get(chain);\n    if (cacheKeyData === undefined || cacheKeyData.callId !== callId) {\n      const environmentNode = this.getEnvironmentNode(scene);\n      const fogNode = this.getFogNode(scene);\n      const values = [];\n      if (lightsNode) values.push(lightsNode.getCacheKey(true));\n      if (environmentNode) values.push(environmentNode.getCacheKey());\n      if (fogNode) values.push(fogNode.getCacheKey());\n      values.push(this.renderer.shadowMap.enabled ? 1 : 0);\n      cacheKeyData = {\n        callId,\n        cacheKey: hashArray(values)\n      };\n      this.callHashCache.set(chain, cacheKeyData);\n    }\n    return cacheKeyData.cacheKey;\n  }\n  updateScene(scene) {\n    this.updateEnvironment(scene);\n    this.updateFog(scene);\n    this.updateBackground(scene);\n  }\n  get isToneMappingState() {\n    return this.renderer.getRenderTarget() ? false : true;\n  }\n  updateBackground(scene) {\n    const sceneData = this.get(scene);\n    const background = scene.background;\n    if (background) {\n      const forceUpdate = scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 || scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0;\n      if (sceneData.background !== background || forceUpdate) {\n        let backgroundNode = null;\n        if (background.isCubeTexture === true || background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping) {\n          if (scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping) {\n            backgroundNode = pmremTexture(background);\n          } else {\n            let envMap;\n            if (background.isCubeTexture === true) {\n              envMap = cubeTexture(background);\n            } else {\n              envMap = texture(background);\n            }\n            backgroundNode = cubeMapNode(envMap);\n          }\n        } else if (background.isTexture === true) {\n          backgroundNode = texture(background, screenUV.flipY()).setUpdateMatrix(true);\n        } else if (background.isColor !== true) {\n          console.error('WebGPUNodes: Unsupported background configuration.', background);\n        }\n        sceneData.backgroundNode = backgroundNode;\n        sceneData.background = background;\n        sceneData.backgroundBlurriness = scene.backgroundBlurriness;\n      }\n    } else if (sceneData.backgroundNode) {\n      delete sceneData.backgroundNode;\n      delete sceneData.background;\n    }\n  }\n  updateFog(scene) {\n    const sceneData = this.get(scene);\n    const fog = scene.fog;\n    if (fog) {\n      if (sceneData.fog !== fog) {\n        let fogNode = null;\n        if (fog.isFogExp2) {\n          const color = reference('color', 'color', fog).setGroup(renderGroup);\n          const density = reference('density', 'float', fog).setGroup(renderGroup);\n          fogNode = densityFog(color, density);\n        } else if (fog.isFog) {\n          const color = reference('color', 'color', fog).setGroup(renderGroup);\n          const near = reference('near', 'float', fog).setGroup(renderGroup);\n          const far = reference('far', 'float', fog).setGroup(renderGroup);\n          fogNode = rangeFog(color, near, far);\n        } else {\n          console.error('WebGPUNodes: Unsupported fog configuration.', fog);\n        }\n        sceneData.fogNode = fogNode;\n        sceneData.fog = fog;\n      }\n    } else {\n      delete sceneData.fogNode;\n      delete sceneData.fog;\n    }\n  }\n  updateEnvironment(scene) {\n    const sceneData = this.get(scene);\n    const environment = scene.environment;\n    if (environment) {\n      if (sceneData.environment !== environment) {\n        let environmentNode = null;\n        if (environment.isCubeTexture === true) {\n          environmentNode = cubeTexture(environment);\n        } else if (environment.isTexture === true) {\n          environmentNode = texture(environment);\n        } else {\n          console.error('Nodes: Unsupported environment configuration.', environment);\n        }\n        sceneData.environmentNode = environmentNode;\n        sceneData.environment = environment;\n      }\n    } else if (sceneData.environmentNode) {\n      delete sceneData.environmentNode;\n      delete sceneData.environment;\n    }\n  }\n  getNodeFrame() {\n    let renderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.renderer;\n    let scene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let object = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let camera = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let material = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    const nodeFrame = this.nodeFrame;\n    nodeFrame.renderer = renderer;\n    nodeFrame.scene = scene;\n    nodeFrame.object = object;\n    nodeFrame.camera = camera;\n    nodeFrame.material = material;\n    return nodeFrame;\n  }\n  getNodeFrameForRender(renderObject) {\n    return this.getNodeFrame(renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material);\n  }\n  getOutputCacheKey() {\n    const renderer = this.renderer;\n    return renderer.toneMapping + ',' + renderer.currentColorSpace;\n  }\n  hasOutputChange(outputTarget) {\n    const cacheKey = outputNodeMap.get(outputTarget);\n    return cacheKey !== this.getOutputCacheKey();\n  }\n  getOutputNode(outputTexture) {\n    const renderer = this.renderer;\n    const cacheKey = this.getOutputCacheKey();\n    const output = texture(outputTexture, screenUV).renderOutput(renderer.toneMapping, renderer.currentColorSpace);\n    outputNodeMap.set(outputTexture, cacheKey);\n    return output;\n  }\n  updateBefore(renderObject) {\n    const nodeBuilder = renderObject.getNodeBuilderState();\n    for (const node of nodeBuilder.updateBeforeNodes) {\n      // update frame state for each node\n\n      this.getNodeFrameForRender(renderObject).updateBeforeNode(node);\n    }\n  }\n  updateAfter(renderObject) {\n    const nodeBuilder = renderObject.getNodeBuilderState();\n    for (const node of nodeBuilder.updateAfterNodes) {\n      // update frame state for each node\n\n      this.getNodeFrameForRender(renderObject).updateAfterNode(node);\n    }\n  }\n  updateForCompute(computeNode) {\n    const nodeFrame = this.getNodeFrame();\n    const nodeBuilder = this.getForCompute(computeNode);\n    for (const node of nodeBuilder.updateNodes) {\n      nodeFrame.updateNode(node);\n    }\n  }\n  updateForRender(renderObject) {\n    const nodeFrame = this.getNodeFrameForRender(renderObject);\n    const nodeBuilder = renderObject.getNodeBuilderState();\n    for (const node of nodeBuilder.updateNodes) {\n      nodeFrame.updateNode(node);\n    }\n  }\n  needsRefresh(renderObject) {\n    const nodeFrame = this.getNodeFrameForRender(renderObject);\n    const monitor = renderObject.getMonitor();\n    return monitor.needsRefresh(renderObject, nodeFrame);\n  }\n  dispose() {\n    super.dispose();\n    this.nodeFrame = new NodeFrame();\n    this.nodeBuilderCache = new Map();\n  }\n}\nconst _plane = /*@__PURE__*/new Plane();\nclass ClippingContext {\n  constructor() {\n    let parentContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.version = 0;\n    this.clipIntersection = null;\n    this.cacheKey = '';\n    if (parentContext === null) {\n      this.intersectionPlanes = [];\n      this.unionPlanes = [];\n      this.viewNormalMatrix = new Matrix3();\n      this.clippingGroupContexts = new WeakMap();\n      this.shadowPass = false;\n    } else {\n      this.viewNormalMatrix = parentContext.viewNormalMatrix;\n      this.clippingGroupContexts = parentContext.clippingGroupContexts;\n      this.shadowPass = parentContext.shadowPass;\n      this.viewMatrix = parentContext.viewMatrix;\n    }\n    this.parentVersion = null;\n  }\n  projectPlanes(source, destination, offset) {\n    const l = source.length;\n    for (let i = 0; i < l; i++) {\n      _plane.copy(source[i]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);\n      const v = destination[offset + i];\n      const normal = _plane.normal;\n      v.x = -normal.x;\n      v.y = -normal.y;\n      v.z = -normal.z;\n      v.w = _plane.constant;\n    }\n  }\n  updateGlobal(scene, camera) {\n    this.shadowPass = scene.overrideMaterial !== null && scene.overrideMaterial.isShadowNodeMaterial;\n    this.viewMatrix = camera.matrixWorldInverse;\n    this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);\n  }\n  update(parentContext, clippingGroup) {\n    let update = false;\n    if (parentContext.version !== this.parentVersion) {\n      this.intersectionPlanes = Array.from(parentContext.intersectionPlanes);\n      this.unionPlanes = Array.from(parentContext.unionPlanes);\n      this.parentVersion = parentContext.version;\n    }\n    if (this.clipIntersection !== clippingGroup.clipIntersection) {\n      this.clipIntersection = clippingGroup.clipIntersection;\n      if (this.clipIntersection) {\n        this.unionPlanes.length = parentContext.unionPlanes.length;\n      } else {\n        this.intersectionPlanes.length = parentContext.intersectionPlanes.length;\n      }\n    }\n    const srcClippingPlanes = clippingGroup.clippingPlanes;\n    const l = srcClippingPlanes.length;\n    let dstClippingPlanes;\n    let offset;\n    if (this.clipIntersection) {\n      dstClippingPlanes = this.intersectionPlanes;\n      offset = parentContext.intersectionPlanes.length;\n    } else {\n      dstClippingPlanes = this.unionPlanes;\n      offset = parentContext.unionPlanes.length;\n    }\n    if (dstClippingPlanes.length !== offset + l) {\n      dstClippingPlanes.length = offset + l;\n      for (let i = 0; i < l; i++) {\n        dstClippingPlanes[offset + i] = new Vector4();\n      }\n      update = true;\n    }\n    this.projectPlanes(srcClippingPlanes, dstClippingPlanes, offset);\n    if (update) {\n      this.version++;\n      this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`;\n    }\n  }\n  getGroupContext(clippingGroup) {\n    if (this.shadowPass && !clippingGroup.clipShadows) return this;\n    let context = this.clippingGroupContexts.get(clippingGroup);\n    if (context === undefined) {\n      context = new ClippingContext(this);\n      this.clippingGroupContexts.set(clippingGroup, context);\n    }\n    context.update(this, clippingGroup);\n    return context;\n  }\n  get unionClippingCount() {\n    return this.unionPlanes.length;\n  }\n}\nclass RenderBundle {\n  constructor(scene, camera) {\n    this.scene = scene;\n    this.camera = camera;\n  }\n  clone() {\n    return Object.assign(new this.constructor(), this);\n  }\n}\nclass RenderBundles {\n  constructor() {\n    this.lists = new ChainMap();\n  }\n  get(scene, camera) {\n    const lists = this.lists;\n    const keys = [scene, camera];\n    let list = lists.get(keys);\n    if (list === undefined) {\n      list = new RenderBundle(scene, camera);\n      lists.set(keys, list);\n    }\n    return list;\n  }\n  dispose() {\n    this.lists = new ChainMap();\n  }\n}\nclass NodeLibrary {\n  constructor() {\n    this.lightNodes = new WeakMap();\n    this.materialNodes = new Map();\n    this.toneMappingNodes = new Map();\n  }\n  fromMaterial(material) {\n    if (material.isNodeMaterial) return material;\n    let nodeMaterial = null;\n    const nodeMaterialClass = this.getMaterialNodeClass(material.type);\n    if (nodeMaterialClass !== null) {\n      nodeMaterial = new nodeMaterialClass();\n      for (const key in material) {\n        nodeMaterial[key] = material[key];\n      }\n    }\n    return nodeMaterial;\n  }\n  addToneMapping(toneMappingNode, toneMapping) {\n    this.addType(toneMappingNode, toneMapping, this.toneMappingNodes);\n  }\n  getToneMappingFunction(toneMapping) {\n    return this.toneMappingNodes.get(toneMapping) || null;\n  }\n  getMaterialNodeClass(materialType) {\n    return this.materialNodes.get(materialType) || null;\n  }\n  addMaterial(materialNodeClass, materialClassType) {\n    this.addType(materialNodeClass, materialClassType, this.materialNodes);\n  }\n  getLightNodeClass(light) {\n    return this.lightNodes.get(light) || null;\n  }\n  addLight(lightNodeClass, lightClass) {\n    this.addClass(lightNodeClass, lightClass, this.lightNodes);\n  }\n  addType(nodeClass, type, library) {\n    if (library.has(type)) {\n      console.warn(`Redefinition of node ${type}`);\n      return;\n    }\n    if (typeof nodeClass !== 'function') throw new Error(`Node class ${nodeClass.name} is not a class.`);\n    if (typeof type === 'function' || typeof type === 'object') throw new Error(`Base class ${type} is not a class.`);\n    library.set(type, nodeClass);\n  }\n  addClass(nodeClass, baseClass, library) {\n    if (library.has(baseClass)) {\n      console.warn(`Redefinition of node ${baseClass.name}`);\n      return;\n    }\n    if (typeof nodeClass !== 'function') throw new Error(`Node class ${nodeClass.name} is not a class.`);\n    if (typeof baseClass !== 'function') throw new Error(`Base class ${baseClass.name} is not a class.`);\n    library.set(baseClass, nodeClass);\n  }\n}\nconst _defaultLights = /*@__PURE__*/new LightsNode();\nclass Lighting extends ChainMap {\n  constructor() {\n    super();\n  }\n  createNode() {\n    let lights = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    return new LightsNode().setLights(lights);\n  }\n  getNode(scene, camera) {\n    // ignore post-processing\n\n    if (scene.isQuadMesh) return _defaultLights;\n\n    // tiled lighting\n\n    const keys = [scene, camera];\n    let node = this.get(keys);\n    if (node === undefined) {\n      node = this.createNode();\n      this.set(keys, node);\n    }\n    return node;\n  }\n}\nconst _scene = /*@__PURE__*/new Scene();\nconst _drawingBufferSize = /*@__PURE__*/new Vector2();\nconst _screen = /*@__PURE__*/new Vector4();\nconst _frustum = /*@__PURE__*/new Frustum();\nconst _projScreenMatrix = /*@__PURE__*/new Matrix4();\nconst _vector4 = /*@__PURE__*/new Vector4();\nclass Renderer {\n  constructor(backend) {\n    let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.isRenderer = true;\n\n    //\n\n    const {\n      logarithmicDepthBuffer = false,\n      alpha = true,\n      depth = true,\n      stencil = false,\n      antialias = false,\n      samples = 0,\n      getFallback = null\n    } = parameters;\n\n    // public\n    this.domElement = backend.getDomElement();\n    this.backend = backend;\n    this.samples = samples || antialias === true ? 4 : 0;\n    this.autoClear = true;\n    this.autoClearColor = true;\n    this.autoClearDepth = true;\n    this.autoClearStencil = true;\n    this.alpha = alpha;\n    this.logarithmicDepthBuffer = logarithmicDepthBuffer;\n    this.outputColorSpace = SRGBColorSpace;\n    this.toneMapping = NoToneMapping;\n    this.toneMappingExposure = 1.0;\n    this.sortObjects = true;\n    this.depth = depth;\n    this.stencil = stencil;\n    this.info = new Info();\n    this.nodes = {\n      modelViewMatrix: null,\n      modelNormalViewMatrix: null\n    };\n    this.library = new NodeLibrary();\n    this.lighting = new Lighting();\n\n    // internals\n\n    this._getFallback = getFallback;\n    this._pixelRatio = 1;\n    this._width = this.domElement.width;\n    this._height = this.domElement.height;\n    this._viewport = new Vector4(0, 0, this._width, this._height);\n    this._scissor = new Vector4(0, 0, this._width, this._height);\n    this._scissorTest = false;\n    this._attributes = null;\n    this._geometries = null;\n    this._nodes = null;\n    this._animation = null;\n    this._bindings = null;\n    this._objects = null;\n    this._pipelines = null;\n    this._bundles = null;\n    this._renderLists = null;\n    this._renderContexts = null;\n    this._textures = null;\n    this._background = null;\n    this._quad = new QuadMesh(new NodeMaterial());\n    this._quad.material.type = 'Renderer_output';\n    this._currentRenderContext = null;\n    this._opaqueSort = null;\n    this._transparentSort = null;\n    this._frameBufferTarget = null;\n    const alphaClear = this.alpha === true ? 0 : 1;\n    this._clearColor = new Color4(0, 0, 0, alphaClear);\n    this._clearDepth = 1;\n    this._clearStencil = 0;\n    this._renderTarget = null;\n    this._activeCubeFace = 0;\n    this._activeMipmapLevel = 0;\n    this._mrt = null;\n    this._renderObjectFunction = null;\n    this._currentRenderObjectFunction = null;\n    this._currentRenderBundle = null;\n    this._handleObjectFunction = this._renderObjectDirect;\n    this._isDeviceLost = false;\n    this.onDeviceLost = this._onDeviceLost;\n    this._initialized = false;\n    this._initPromise = null;\n    this._compilationPromises = null;\n    this.transparent = true;\n    this.opaque = true;\n    this.shadowMap = {\n      enabled: false,\n      type: PCFShadowMap\n    };\n    this.xr = {\n      enabled: false\n    };\n    this.debug = {\n      checkShaderErrors: true,\n      onShaderError: null,\n      getShaderAsync: async (scene, camera, object) => {\n        await this.compileAsync(scene, camera);\n        const renderList = this._renderLists.get(scene, camera);\n        const renderContext = this._renderContexts.get(scene, camera, this._renderTarget);\n        const material = scene.overrideMaterial || object.material;\n        const renderObject = this._objects.get(object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext);\n        const {\n          fragmentShader,\n          vertexShader\n        } = renderObject.getNodeBuilderState();\n        return {\n          fragmentShader,\n          vertexShader\n        };\n      }\n    };\n  }\n  async init() {\n    if (this._initialized) {\n      throw new Error('Renderer: Backend has already been initialized.');\n    }\n    if (this._initPromise !== null) {\n      return this._initPromise;\n    }\n    this._initPromise = new Promise(async (resolve, reject) => {\n      let backend = this.backend;\n      try {\n        await backend.init(this);\n      } catch (error) {\n        if (this._getFallback !== null) {\n          // try the fallback\n\n          try {\n            this.backend = backend = this._getFallback(error);\n            await backend.init(this);\n          } catch (error) {\n            reject(error);\n            return;\n          }\n        } else {\n          reject(error);\n          return;\n        }\n      }\n      this._nodes = new Nodes(this, backend);\n      this._animation = new Animation(this._nodes, this.info);\n      this._attributes = new Attributes(backend);\n      this._background = new Background(this, this._nodes);\n      this._geometries = new Geometries(this._attributes, this.info);\n      this._textures = new Textures(this, backend, this.info);\n      this._pipelines = new Pipelines(backend, this._nodes);\n      this._bindings = new Bindings(backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info);\n      this._objects = new RenderObjects(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info);\n      this._renderLists = new RenderLists(this.lighting);\n      this._bundles = new RenderBundles();\n      this._renderContexts = new RenderContexts();\n\n      //\n\n      this._animation.start();\n      this._initialized = true;\n      resolve();\n    });\n    return this._initPromise;\n  }\n  get coordinateSystem() {\n    return this.backend.coordinateSystem;\n  }\n  async compileAsync(scene, camera) {\n    let targetScene = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (this._isDeviceLost === true) return;\n    if (this._initialized === false) await this.init();\n\n    // preserve render tree\n\n    const nodeFrame = this._nodes.nodeFrame;\n    const previousRenderId = nodeFrame.renderId;\n    const previousRenderContext = this._currentRenderContext;\n    const previousRenderObjectFunction = this._currentRenderObjectFunction;\n    const previousCompilationPromises = this._compilationPromises;\n\n    //\n\n    const sceneRef = scene.isScene === true ? scene : _scene;\n    if (targetScene === null) targetScene = scene;\n    const renderTarget = this._renderTarget;\n    const renderContext = this._renderContexts.get(targetScene, camera, renderTarget);\n    const activeMipmapLevel = this._activeMipmapLevel;\n    const compilationPromises = [];\n    this._currentRenderContext = renderContext;\n    this._currentRenderObjectFunction = this.renderObject;\n    this._handleObjectFunction = this._createObjectPipeline;\n    this._compilationPromises = compilationPromises;\n    nodeFrame.renderId++;\n\n    //\n\n    nodeFrame.update();\n\n    //\n\n    renderContext.depth = this.depth;\n    renderContext.stencil = this.stencil;\n    if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();\n    renderContext.clippingContext.updateGlobal(sceneRef, camera);\n\n    //\n\n    sceneRef.onBeforeRender(this, scene, camera, renderTarget);\n\n    //\n\n    const renderList = this._renderLists.get(scene, camera);\n    renderList.begin();\n    this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);\n\n    // include lights from target scene\n    if (targetScene !== scene) {\n      targetScene.traverseVisible(function (object) {\n        if (object.isLight && object.layers.test(camera.layers)) {\n          renderList.pushLight(object);\n        }\n      });\n    }\n    renderList.finish();\n\n    //\n\n    if (renderTarget !== null) {\n      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);\n      const renderTargetData = this._textures.get(renderTarget);\n      renderContext.textures = renderTargetData.textures;\n      renderContext.depthTexture = renderTargetData.depthTexture;\n    } else {\n      renderContext.textures = null;\n      renderContext.depthTexture = null;\n    }\n\n    //\n\n    this._nodes.updateScene(sceneRef);\n\n    //\n\n    this._background.update(sceneRef, renderList, renderContext);\n\n    // process render lists\n\n    const opaqueObjects = renderList.opaque;\n    const transparentObjects = renderList.transparent;\n    const transparentDoublePassObjects = renderList.transparentDoublePass;\n    const lightsNode = renderList.lightsNode;\n    if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);\n    if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);\n\n    // restore render tree\n\n    nodeFrame.renderId = previousRenderId;\n    this._currentRenderContext = previousRenderContext;\n    this._currentRenderObjectFunction = previousRenderObjectFunction;\n    this._compilationPromises = previousCompilationPromises;\n    this._handleObjectFunction = this._renderObjectDirect;\n\n    // wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete\n\n    await Promise.all(compilationPromises);\n  }\n  async renderAsync(scene, camera) {\n    if (this._initialized === false) await this.init();\n    const renderContext = this._renderScene(scene, camera);\n    await this.backend.resolveTimestampAsync(renderContext, 'render');\n  }\n  async waitForGPU() {\n    await this.backend.waitForGPU();\n  }\n  setMRT(mrt) {\n    this._mrt = mrt;\n    return this;\n  }\n  getMRT() {\n    return this._mrt;\n  }\n  _onDeviceLost(info) {\n    let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\\n\\nMessage: ${info.message}`;\n    if (info.reason) {\n      errorMessage += `\\nReason: ${info.reason}`;\n    }\n    console.error(errorMessage);\n    this._isDeviceLost = true;\n  }\n  _renderBundle(bundle, sceneRef, lightsNode) {\n    const {\n      bundleGroup,\n      camera,\n      renderList\n    } = bundle;\n    const renderContext = this._currentRenderContext;\n\n    //\n\n    const renderBundle = this._bundles.get(bundleGroup, camera);\n    const renderBundleData = this.backend.get(renderBundle);\n    if (renderBundleData.renderContexts === undefined) renderBundleData.renderContexts = new Set();\n\n    //\n\n    const needsUpdate = bundleGroup.version !== renderBundleData.version;\n    const renderBundleNeedsUpdate = renderBundleData.renderContexts.has(renderContext) === false || needsUpdate;\n    renderBundleData.renderContexts.add(renderContext);\n    if (renderBundleNeedsUpdate) {\n      this.backend.beginBundle(renderContext);\n      if (renderBundleData.renderObjects === undefined || needsUpdate) {\n        renderBundleData.renderObjects = [];\n      }\n      this._currentRenderBundle = renderBundle;\n      const opaqueObjects = renderList.opaque;\n      if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);\n      this._currentRenderBundle = null;\n\n      //\n\n      this.backend.finishBundle(renderContext, renderBundle);\n      renderBundleData.version = bundleGroup.version;\n    } else {\n      const {\n        renderObjects\n      } = renderBundleData;\n      for (let i = 0, l = renderObjects.length; i < l; i++) {\n        const renderObject = renderObjects[i];\n        if (this._nodes.needsRefresh(renderObject)) {\n          this._nodes.updateBefore(renderObject);\n          this._nodes.updateForRender(renderObject);\n          this._bindings.updateForRender(renderObject);\n          this._nodes.updateAfter(renderObject);\n        }\n      }\n    }\n    this.backend.addBundle(renderContext, renderBundle);\n  }\n  render(scene, camera) {\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.');\n      return this.renderAsync(scene, camera);\n    }\n    this._renderScene(scene, camera);\n  }\n  _getFrameBufferTarget() {\n    const {\n      currentToneMapping,\n      currentColorSpace\n    } = this;\n    const useToneMapping = currentToneMapping !== NoToneMapping;\n    const useColorSpace = currentColorSpace !== LinearSRGBColorSpace;\n    if (useToneMapping === false && useColorSpace === false) return null;\n    const {\n      width,\n      height\n    } = this.getDrawingBufferSize(_drawingBufferSize);\n    const {\n      depth,\n      stencil\n    } = this;\n    let frameBufferTarget = this._frameBufferTarget;\n    if (frameBufferTarget === null) {\n      frameBufferTarget = new RenderTarget(width, height, {\n        depthBuffer: depth,\n        stencilBuffer: stencil,\n        type: HalfFloatType,\n        // FloatType\n        format: RGBAFormat,\n        colorSpace: LinearSRGBColorSpace,\n        generateMipmaps: false,\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n        samples: this.samples\n      });\n      frameBufferTarget.isPostProcessingRenderTarget = true;\n      this._frameBufferTarget = frameBufferTarget;\n    }\n    frameBufferTarget.depthBuffer = depth;\n    frameBufferTarget.stencilBuffer = stencil;\n    frameBufferTarget.setSize(width, height);\n    frameBufferTarget.viewport.copy(this._viewport);\n    frameBufferTarget.scissor.copy(this._scissor);\n    frameBufferTarget.viewport.multiplyScalar(this._pixelRatio);\n    frameBufferTarget.scissor.multiplyScalar(this._pixelRatio);\n    frameBufferTarget.scissorTest = this._scissorTest;\n    return frameBufferTarget;\n  }\n  _renderScene(scene, camera) {\n    let useFrameBufferTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (this._isDeviceLost === true) return;\n    const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;\n\n    // preserve render tree\n\n    const nodeFrame = this._nodes.nodeFrame;\n    const previousRenderId = nodeFrame.renderId;\n    const previousRenderContext = this._currentRenderContext;\n    const previousRenderObjectFunction = this._currentRenderObjectFunction;\n\n    //\n\n    const sceneRef = scene.isScene === true ? scene : _scene;\n    const outputRenderTarget = this._renderTarget;\n    const activeCubeFace = this._activeCubeFace;\n    const activeMipmapLevel = this._activeMipmapLevel;\n\n    //\n\n    let renderTarget;\n    if (frameBufferTarget !== null) {\n      renderTarget = frameBufferTarget;\n      this.setRenderTarget(renderTarget);\n    } else {\n      renderTarget = outputRenderTarget;\n    }\n\n    //\n\n    const renderContext = this._renderContexts.get(scene, camera, renderTarget);\n    this._currentRenderContext = renderContext;\n    this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;\n\n    //\n\n    this.info.calls++;\n    this.info.render.calls++;\n    this.info.render.frameCalls++;\n    nodeFrame.renderId = this.info.calls;\n\n    //\n\n    const coordinateSystem = this.coordinateSystem;\n    if (camera.coordinateSystem !== coordinateSystem) {\n      camera.coordinateSystem = coordinateSystem;\n      camera.updateProjectionMatrix();\n    }\n\n    //\n\n    if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();\n    if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();\n\n    //\n\n    let viewport = this._viewport;\n    let scissor = this._scissor;\n    let pixelRatio = this._pixelRatio;\n    if (renderTarget !== null) {\n      viewport = renderTarget.viewport;\n      scissor = renderTarget.scissor;\n      pixelRatio = 1;\n    }\n    this.getDrawingBufferSize(_drawingBufferSize);\n    _screen.set(0, 0, _drawingBufferSize.width, _drawingBufferSize.height);\n    const minDepth = viewport.minDepth === undefined ? 0 : viewport.minDepth;\n    const maxDepth = viewport.maxDepth === undefined ? 1 : viewport.maxDepth;\n    renderContext.viewportValue.copy(viewport).multiplyScalar(pixelRatio).floor();\n    renderContext.viewportValue.width >>= activeMipmapLevel;\n    renderContext.viewportValue.height >>= activeMipmapLevel;\n    renderContext.viewportValue.minDepth = minDepth;\n    renderContext.viewportValue.maxDepth = maxDepth;\n    renderContext.viewport = renderContext.viewportValue.equals(_screen) === false;\n    renderContext.scissorValue.copy(scissor).multiplyScalar(pixelRatio).floor();\n    renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals(_screen) === false;\n    renderContext.scissorValue.width >>= activeMipmapLevel;\n    renderContext.scissorValue.height >>= activeMipmapLevel;\n    if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();\n    renderContext.clippingContext.updateGlobal(sceneRef, camera);\n\n    //\n\n    sceneRef.onBeforeRender(this, scene, camera, renderTarget);\n\n    //\n\n    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n    _frustum.setFromProjectionMatrix(_projScreenMatrix, coordinateSystem);\n    const renderList = this._renderLists.get(scene, camera);\n    renderList.begin();\n    this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);\n    renderList.finish();\n    if (this.sortObjects === true) {\n      renderList.sort(this._opaqueSort, this._transparentSort);\n    }\n\n    //\n\n    if (renderTarget !== null) {\n      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);\n      const renderTargetData = this._textures.get(renderTarget);\n      renderContext.textures = renderTargetData.textures;\n      renderContext.depthTexture = renderTargetData.depthTexture;\n      renderContext.width = renderTargetData.width;\n      renderContext.height = renderTargetData.height;\n      renderContext.renderTarget = renderTarget;\n      renderContext.depth = renderTarget.depthBuffer;\n      renderContext.stencil = renderTarget.stencilBuffer;\n    } else {\n      renderContext.textures = null;\n      renderContext.depthTexture = null;\n      renderContext.width = this.domElement.width;\n      renderContext.height = this.domElement.height;\n      renderContext.depth = this.depth;\n      renderContext.stencil = this.stencil;\n    }\n    renderContext.width >>= activeMipmapLevel;\n    renderContext.height >>= activeMipmapLevel;\n    renderContext.activeCubeFace = activeCubeFace;\n    renderContext.activeMipmapLevel = activeMipmapLevel;\n    renderContext.occlusionQueryCount = renderList.occlusionQueryCount;\n\n    //\n\n    this._nodes.updateScene(sceneRef);\n\n    //\n\n    this._background.update(sceneRef, renderList, renderContext);\n\n    //\n\n    this.backend.beginRender(renderContext);\n\n    // process render lists\n\n    const {\n      bundles,\n      lightsNode,\n      transparentDoublePass: transparentDoublePassObjects,\n      transparent: transparentObjects,\n      opaque: opaqueObjects\n    } = renderList;\n    if (bundles.length > 0) this._renderBundles(bundles, sceneRef, lightsNode);\n    if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);\n    if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);\n\n    // finish render pass\n\n    this.backend.finishRender(renderContext);\n\n    // restore render tree\n\n    nodeFrame.renderId = previousRenderId;\n    this._currentRenderContext = previousRenderContext;\n    this._currentRenderObjectFunction = previousRenderObjectFunction;\n\n    //\n\n    if (frameBufferTarget !== null) {\n      this.setRenderTarget(outputRenderTarget, activeCubeFace, activeMipmapLevel);\n      const quad = this._quad;\n      if (this._nodes.hasOutputChange(renderTarget.texture)) {\n        quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);\n        quad.material.needsUpdate = true;\n      }\n      this._renderScene(quad, quad.camera, false);\n    }\n\n    //\n\n    sceneRef.onAfterRender(this, scene, camera, renderTarget);\n\n    //\n\n    return renderContext;\n  }\n  getMaxAnisotropy() {\n    return this.backend.getMaxAnisotropy();\n  }\n  getActiveCubeFace() {\n    return this._activeCubeFace;\n  }\n  getActiveMipmapLevel() {\n    return this._activeMipmapLevel;\n  }\n  async setAnimationLoop(callback) {\n    if (this._initialized === false) await this.init();\n    this._animation.setAnimationLoop(callback);\n  }\n  async getArrayBufferAsync(attribute) {\n    return await this.backend.getArrayBufferAsync(attribute);\n  }\n  getContext() {\n    return this.backend.getContext();\n  }\n  getPixelRatio() {\n    return this._pixelRatio;\n  }\n  getDrawingBufferSize(target) {\n    return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();\n  }\n  getSize(target) {\n    return target.set(this._width, this._height);\n  }\n  setPixelRatio() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    if (this._pixelRatio === value) return;\n    this._pixelRatio = value;\n    this.setSize(this._width, this._height, false);\n  }\n  setDrawingBufferSize(width, height, pixelRatio) {\n    this._width = width;\n    this._height = height;\n    this._pixelRatio = pixelRatio;\n    this.domElement.width = Math.floor(width * pixelRatio);\n    this.domElement.height = Math.floor(height * pixelRatio);\n    this.setViewport(0, 0, width, height);\n    if (this._initialized) this.backend.updateSize();\n  }\n  setSize(width, height) {\n    let updateStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    this._width = width;\n    this._height = height;\n    this.domElement.width = Math.floor(width * this._pixelRatio);\n    this.domElement.height = Math.floor(height * this._pixelRatio);\n    if (updateStyle === true) {\n      this.domElement.style.width = width + 'px';\n      this.domElement.style.height = height + 'px';\n    }\n    this.setViewport(0, 0, width, height);\n    if (this._initialized) this.backend.updateSize();\n  }\n  setOpaqueSort(method) {\n    this._opaqueSort = method;\n  }\n  setTransparentSort(method) {\n    this._transparentSort = method;\n  }\n  getScissor(target) {\n    const scissor = this._scissor;\n    target.x = scissor.x;\n    target.y = scissor.y;\n    target.width = scissor.width;\n    target.height = scissor.height;\n    return target;\n  }\n  setScissor(x, y, width, height) {\n    const scissor = this._scissor;\n    if (x.isVector4) {\n      scissor.copy(x);\n    } else {\n      scissor.set(x, y, width, height);\n    }\n  }\n  getScissorTest() {\n    return this._scissorTest;\n  }\n  setScissorTest(boolean) {\n    this._scissorTest = boolean;\n    this.backend.setScissorTest(boolean);\n  }\n  getViewport(target) {\n    return target.copy(this._viewport);\n  }\n  setViewport(x, y, width, height) {\n    let minDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let maxDepth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    const viewport = this._viewport;\n    if (x.isVector4) {\n      viewport.copy(x);\n    } else {\n      viewport.set(x, y, width, height);\n    }\n    viewport.minDepth = minDepth;\n    viewport.maxDepth = maxDepth;\n  }\n  getClearColor(target) {\n    return target.copy(this._clearColor);\n  }\n  setClearColor(color) {\n    let alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this._clearColor.set(color);\n    this._clearColor.a = alpha;\n  }\n  getClearAlpha() {\n    return this._clearColor.a;\n  }\n  setClearAlpha(alpha) {\n    this._clearColor.a = alpha;\n  }\n  getClearDepth() {\n    return this._clearDepth;\n  }\n  setClearDepth(depth) {\n    this._clearDepth = depth;\n  }\n  getClearStencil() {\n    return this._clearStencil;\n  }\n  setClearStencil(stencil) {\n    this._clearStencil = stencil;\n  }\n  isOccluded(object) {\n    const renderContext = this._currentRenderContext;\n    return renderContext && this.backend.isOccluded(renderContext, object);\n  }\n  clear() {\n    let color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let stencil = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.');\n      return this.clearAsync(color, depth, stencil);\n    }\n    const renderTarget = this._renderTarget || this._getFrameBufferTarget();\n    let renderTargetData = null;\n    if (renderTarget !== null) {\n      this._textures.updateRenderTarget(renderTarget);\n      renderTargetData = this._textures.get(renderTarget);\n    }\n    this.backend.clear(color, depth, stencil, renderTargetData);\n    if (renderTarget !== null && this._renderTarget === null) {\n      // If a color space transform or tone mapping is required,\n      // the clear operation clears the intermediate renderTarget texture, but does not update the screen canvas.\n\n      const quad = this._quad;\n      if (this._nodes.hasOutputChange(renderTarget.texture)) {\n        quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);\n        quad.material.needsUpdate = true;\n      }\n      this._renderScene(quad, quad.camera, false);\n    }\n  }\n  clearColor() {\n    return this.clear(true, false, false);\n  }\n  clearDepth() {\n    return this.clear(false, true, false);\n  }\n  clearStencil() {\n    return this.clear(false, false, true);\n  }\n  async clearAsync() {\n    let color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let stencil = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (this._initialized === false) await this.init();\n    this.clear(color, depth, stencil);\n  }\n  clearColorAsync() {\n    return this.clearAsync(true, false, false);\n  }\n  clearDepthAsync() {\n    return this.clearAsync(false, true, false);\n  }\n  clearStencilAsync() {\n    return this.clearAsync(false, false, true);\n  }\n  get currentToneMapping() {\n    return this._renderTarget !== null ? NoToneMapping : this.toneMapping;\n  }\n  get currentColorSpace() {\n    return this._renderTarget !== null ? LinearSRGBColorSpace : this.outputColorSpace;\n  }\n  dispose() {\n    this.info.dispose();\n    this.backend.dispose();\n    this._animation.dispose();\n    this._objects.dispose();\n    this._pipelines.dispose();\n    this._nodes.dispose();\n    this._bindings.dispose();\n    this._renderLists.dispose();\n    this._renderContexts.dispose();\n    this._textures.dispose();\n    this.setRenderTarget(null);\n    this.setAnimationLoop(null);\n  }\n  setRenderTarget(renderTarget) {\n    let activeCubeFace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let activeMipmapLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this._renderTarget = renderTarget;\n    this._activeCubeFace = activeCubeFace;\n    this._activeMipmapLevel = activeMipmapLevel;\n  }\n  getRenderTarget() {\n    return this._renderTarget;\n  }\n  setRenderObjectFunction(renderObjectFunction) {\n    this._renderObjectFunction = renderObjectFunction;\n  }\n  getRenderObjectFunction() {\n    return this._renderObjectFunction;\n  }\n  compute(computeNodes) {\n    if (this.isDeviceLost === true) return;\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.');\n      return this.computeAsync(computeNodes);\n    }\n\n    //\n\n    const nodeFrame = this._nodes.nodeFrame;\n    const previousRenderId = nodeFrame.renderId;\n\n    //\n\n    this.info.calls++;\n    this.info.compute.calls++;\n    this.info.compute.frameCalls++;\n    nodeFrame.renderId = this.info.calls;\n\n    //\n\n    const backend = this.backend;\n    const pipelines = this._pipelines;\n    const bindings = this._bindings;\n    const nodes = this._nodes;\n    const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];\n    if (computeList[0] === undefined || computeList[0].isComputeNode !== true) {\n      throw new Error('THREE.Renderer: .compute() expects a ComputeNode.');\n    }\n    backend.beginCompute(computeNodes);\n    for (const computeNode of computeList) {\n      // onInit\n\n      if (pipelines.has(computeNode) === false) {\n        const dispose = () => {\n          computeNode.removeEventListener('dispose', dispose);\n          pipelines.delete(computeNode);\n          bindings.delete(computeNode);\n          nodes.delete(computeNode);\n        };\n        computeNode.addEventListener('dispose', dispose);\n\n        //\n\n        const onInitFn = computeNode.onInitFunction;\n        if (onInitFn !== null) {\n          onInitFn.call(computeNode, {\n            renderer: this\n          });\n        }\n      }\n      nodes.updateForCompute(computeNode);\n      bindings.updateForCompute(computeNode);\n      const computeBindings = bindings.getForCompute(computeNode);\n      const computePipeline = pipelines.getForCompute(computeNode, computeBindings);\n      backend.compute(computeNodes, computeNode, computeBindings, computePipeline);\n    }\n    backend.finishCompute(computeNodes);\n\n    //\n\n    nodeFrame.renderId = previousRenderId;\n  }\n  async computeAsync(computeNodes) {\n    if (this._initialized === false) await this.init();\n    this.compute(computeNodes);\n    await this.backend.resolveTimestampAsync(computeNodes, 'compute');\n  }\n  async hasFeatureAsync(name) {\n    if (this._initialized === false) await this.init();\n    return this.backend.hasFeature(name);\n  }\n  hasFeature(name) {\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.');\n      return false;\n    }\n    return this.backend.hasFeature(name);\n  }\n  hasInitialized() {\n    return this._initialized;\n  }\n  async initTextureAsync(texture) {\n    if (this._initialized === false) await this.init();\n    this._textures.updateTexture(texture);\n  }\n  initTexture(texture) {\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.');\n      return false;\n    }\n    this._textures.updateTexture(texture);\n  }\n  copyFramebufferToTexture(framebufferTexture) {\n    let rectangle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (rectangle !== null) {\n      if (rectangle.isVector2) {\n        rectangle = _vector4.set(rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height).floor();\n      } else if (rectangle.isVector4) {\n        rectangle = _vector4.copy(rectangle).floor();\n      } else {\n        console.error('THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.');\n        return;\n      }\n    } else {\n      rectangle = _vector4.set(0, 0, framebufferTexture.image.width, framebufferTexture.image.height);\n    }\n\n    //\n\n    let renderContext = this._currentRenderContext;\n    let renderTarget;\n    if (renderContext !== null) {\n      renderTarget = renderContext.renderTarget;\n    } else {\n      renderTarget = this._renderTarget || this._getFrameBufferTarget();\n      if (renderTarget !== null) {\n        this._textures.updateRenderTarget(renderTarget);\n        renderContext = this._textures.get(renderTarget);\n      }\n    }\n\n    //\n\n    this._textures.updateTexture(framebufferTexture, {\n      renderTarget\n    });\n    this.backend.copyFramebufferToTexture(framebufferTexture, renderContext, rectangle);\n  }\n  copyTextureToTexture(srcTexture, dstTexture) {\n    let srcRegion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let dstPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    this._textures.updateTexture(srcTexture);\n    this._textures.updateTexture(dstTexture);\n    this.backend.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);\n  }\n  readRenderTargetPixelsAsync(renderTarget, x, y, width, height) {\n    let index = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    let faceIndex = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    return this.backend.copyTextureToBuffer(renderTarget.textures[index], x, y, width, height, faceIndex);\n  }\n  _projectObject(object, camera, groupOrder, renderList, clippingContext) {\n    if (object.visible === false) return;\n    const visible = object.layers.test(camera.layers);\n    if (visible) {\n      if (object.isGroup) {\n        groupOrder = object.renderOrder;\n        if (object.isClippingGroup && object.enabled) clippingContext = clippingContext.getGroupContext(object);\n      } else if (object.isLOD) {\n        if (object.autoUpdate === true) object.update(camera);\n      } else if (object.isLight) {\n        renderList.pushLight(object);\n      } else if (object.isSprite) {\n        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n          if (this.sortObjects === true) {\n            _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n          const {\n            geometry,\n            material\n          } = object;\n          if (material.visible) {\n            renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);\n          }\n        }\n      } else if (object.isLineLoop) {\n        console.error('THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.');\n      } else if (object.isMesh || object.isLine || object.isPoints) {\n        if (!object.frustumCulled || _frustum.intersectsObject(object)) {\n          const {\n            geometry,\n            material\n          } = object;\n          if (this.sortObjects === true) {\n            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n            _vector4.copy(geometry.boundingSphere.center).applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n          if (Array.isArray(material)) {\n            const groups = geometry.groups;\n            for (let i = 0, l = groups.length; i < l; i++) {\n              const group = groups[i];\n              const groupMaterial = material[group.materialIndex];\n              if (groupMaterial && groupMaterial.visible) {\n                renderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext);\n              }\n            }\n          } else if (material.visible) {\n            renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);\n          }\n        }\n      }\n    }\n    if (object.isBundleGroup === true && this.backend.beginBundle !== undefined) {\n      const baseRenderList = renderList;\n\n      // replace render list\n      renderList = this._renderLists.get(object, camera);\n      renderList.begin();\n      baseRenderList.pushBundle({\n        bundleGroup: object,\n        camera,\n        renderList\n      });\n      renderList.finish();\n    }\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      this._projectObject(children[i], camera, groupOrder, renderList, clippingContext);\n    }\n  }\n  _renderBundles(bundles, sceneRef, lightsNode) {\n    for (const bundle of bundles) {\n      this._renderBundle(bundle, sceneRef, lightsNode);\n    }\n  }\n  _renderTransparents(renderList, doublePassList, camera, scene, lightsNode) {\n    if (doublePassList.length > 0) {\n      // render back side\n\n      for (const {\n        material\n      } of doublePassList) {\n        material.side = BackSide;\n      }\n      this._renderObjects(doublePassList, camera, scene, lightsNode, 'backSide');\n\n      // render front side\n\n      for (const {\n        material\n      } of doublePassList) {\n        material.side = FrontSide;\n      }\n      this._renderObjects(renderList, camera, scene, lightsNode);\n\n      // restore\n\n      for (const {\n        material\n      } of doublePassList) {\n        material.side = DoubleSide;\n      }\n    } else {\n      this._renderObjects(renderList, camera, scene, lightsNode);\n    }\n  }\n  _renderObjects(renderList, camera, scene, lightsNode) {\n    let passId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    // process renderable objects\n\n    for (let i = 0, il = renderList.length; i < il; i++) {\n      const renderItem = renderList[i];\n\n      // @TODO: Add support for multiple materials per object. This will require to extract\n      // the material from the renderItem object and pass it with its group data to renderObject().\n\n      const {\n        object,\n        geometry,\n        material,\n        group,\n        clippingContext\n      } = renderItem;\n      if (camera.isArrayCamera) {\n        const cameras = camera.cameras;\n        for (let j = 0, jl = cameras.length; j < jl; j++) {\n          const camera2 = cameras[j];\n          if (object.layers.test(camera2.layers)) {\n            const vp = camera2.viewport;\n            const minDepth = vp.minDepth === undefined ? 0 : vp.minDepth;\n            const maxDepth = vp.maxDepth === undefined ? 1 : vp.maxDepth;\n            const viewportValue = this._currentRenderContext.viewportValue;\n            viewportValue.copy(vp).multiplyScalar(this._pixelRatio).floor();\n            viewportValue.minDepth = minDepth;\n            viewportValue.maxDepth = maxDepth;\n            this.backend.updateViewport(this._currentRenderContext);\n            this._currentRenderObjectFunction(object, scene, camera2, geometry, material, group, lightsNode, clippingContext, passId);\n          }\n        }\n      } else {\n        this._currentRenderObjectFunction(object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId);\n      }\n    }\n  }\n  renderObject(object, scene, camera, geometry, material, group, lightsNode) {\n    let clippingContext = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    let passId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n    let overridePositionNode;\n    let overrideColorNode;\n    let overrideDepthNode;\n\n    //\n\n    object.onBeforeRender(this, scene, camera, geometry, material, group);\n\n    //\n\n    if (scene.overrideMaterial !== null) {\n      const overrideMaterial = scene.overrideMaterial;\n      if (material.positionNode && material.positionNode.isNode) {\n        overridePositionNode = overrideMaterial.positionNode;\n        overrideMaterial.positionNode = material.positionNode;\n      }\n      overrideMaterial.alphaTest = material.alphaTest;\n      overrideMaterial.alphaMap = material.alphaMap;\n      if (overrideMaterial.isShadowNodeMaterial) {\n        overrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;\n        if (material.depthNode && material.depthNode.isNode) {\n          overrideDepthNode = overrideMaterial.depthNode;\n          overrideMaterial.depthNode = material.depthNode;\n        }\n        if (material.castShadowNode && material.castShadowNode.isNode) {\n          overrideColorNode = overrideMaterial.colorNode;\n          overrideMaterial.colorNode = material.castShadowNode;\n        }\n      }\n      material = overrideMaterial;\n    }\n\n    //\n\n    if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {\n      material.side = BackSide;\n      this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, 'backSide'); // create backSide pass id\n\n      material.side = FrontSide;\n      this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, passId); // use default pass id\n\n      material.side = DoubleSide;\n    } else {\n      this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, passId);\n    }\n\n    //\n\n    if (overridePositionNode !== undefined) {\n      scene.overrideMaterial.positionNode = overridePositionNode;\n    }\n    if (overrideDepthNode !== undefined) {\n      scene.overrideMaterial.depthNode = overrideDepthNode;\n    }\n    if (overrideColorNode !== undefined) {\n      scene.overrideMaterial.colorNode = overrideColorNode;\n    }\n\n    //\n\n    object.onAfterRender(this, scene, camera, geometry, material, group);\n  }\n  _renderObjectDirect(object, material, scene, camera, lightsNode, group, clippingContext, passId) {\n    const renderObject = this._objects.get(object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId);\n    renderObject.drawRange = object.geometry.drawRange;\n    renderObject.group = group;\n\n    //\n\n    const needsRefresh = this._nodes.needsRefresh(renderObject);\n    if (needsRefresh) {\n      this._nodes.updateBefore(renderObject);\n      this._geometries.updateForRender(renderObject);\n      this._nodes.updateForRender(renderObject);\n      this._bindings.updateForRender(renderObject);\n    }\n    this._pipelines.updateForRender(renderObject);\n\n    //\n\n    if (this._currentRenderBundle !== null) {\n      const renderBundleData = this.backend.get(this._currentRenderBundle);\n      renderBundleData.renderObjects.push(renderObject);\n      renderObject.bundle = this._currentRenderBundle.scene;\n    }\n    this.backend.draw(renderObject, this.info);\n    if (needsRefresh) this._nodes.updateAfter(renderObject);\n  }\n  _createObjectPipeline(object, material, scene, camera, lightsNode, clippingContext, passId) {\n    const renderObject = this._objects.get(object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId);\n\n    //\n\n    this._nodes.updateBefore(renderObject);\n    this._geometries.updateForRender(renderObject);\n    this._nodes.updateForRender(renderObject);\n    this._bindings.updateForRender(renderObject);\n    this._pipelines.getForRender(renderObject, this._compilationPromises);\n    this._nodes.updateAfter(renderObject);\n  }\n  get compile() {\n    return this.compileAsync;\n  }\n}\nclass Binding {\n  constructor() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    this.name = name;\n    this.visibility = 0;\n  }\n  setVisibility(visibility) {\n    this.visibility |= visibility;\n  }\n  clone() {\n    return Object.assign(new this.constructor(), this);\n  }\n}\nfunction getFloatLength(floatLength) {\n  // ensure chunk size alignment (STD140 layout)\n\n  return floatLength + (GPU_CHUNK_BYTES - floatLength % GPU_CHUNK_BYTES) % GPU_CHUNK_BYTES;\n}\nclass Buffer extends Binding {\n  constructor(name) {\n    let buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(name);\n    this.isBuffer = true;\n    this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;\n    this._buffer = buffer;\n  }\n  get byteLength() {\n    return getFloatLength(this._buffer.byteLength);\n  }\n  get buffer() {\n    return this._buffer;\n  }\n  update() {\n    return true;\n  }\n}\nclass UniformBuffer extends Buffer {\n  constructor(name) {\n    let buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(name, buffer);\n    this.isUniformBuffer = true;\n  }\n}\nlet _id$4 = 0;\nclass NodeUniformBuffer extends UniformBuffer {\n  constructor(nodeUniform, groupNode) {\n    super('UniformBuffer_' + _id$4++, nodeUniform ? nodeUniform.value : null);\n    this.nodeUniform = nodeUniform;\n    this.groupNode = groupNode;\n  }\n  get buffer() {\n    return this.nodeUniform.value;\n  }\n}\nclass UniformsGroup extends UniformBuffer {\n  constructor(name) {\n    super(name);\n    this.isUniformsGroup = true;\n    this._values = null;\n\n    // the order of uniforms in this array must match the order of uniforms in the shader\n\n    this.uniforms = [];\n  }\n  addUniform(uniform) {\n    this.uniforms.push(uniform);\n    return this;\n  }\n  removeUniform(uniform) {\n    const index = this.uniforms.indexOf(uniform);\n    if (index !== -1) {\n      this.uniforms.splice(index, 1);\n    }\n    return this;\n  }\n  get values() {\n    if (this._values === null) {\n      this._values = Array.from(this.buffer);\n    }\n    return this._values;\n  }\n  get buffer() {\n    let buffer = this._buffer;\n    if (buffer === null) {\n      const byteLength = this.byteLength;\n      buffer = new Float32Array(new ArrayBuffer(byteLength));\n      this._buffer = buffer;\n    }\n    return buffer;\n  }\n  get byteLength() {\n    let offset = 0; // global buffer offset in bytes\n\n    for (let i = 0, l = this.uniforms.length; i < l; i++) {\n      const uniform = this.uniforms[i];\n      const {\n        boundary,\n        itemSize\n      } = uniform;\n\n      // offset within a single chunk in bytes\n\n      const chunkOffset = offset % GPU_CHUNK_BYTES;\n      const remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;\n\n      // conformance tests\n\n      if (chunkOffset !== 0 && remainingSizeInChunk - boundary < 0) {\n        // check for chunk overflow\n\n        offset += GPU_CHUNK_BYTES - chunkOffset;\n      } else if (chunkOffset % boundary !== 0) {\n        // check for correct alignment\n\n        offset += chunkOffset % boundary;\n      }\n      uniform.offset = offset / this.bytesPerElement;\n      offset += itemSize * this.bytesPerElement;\n    }\n    return Math.ceil(offset / GPU_CHUNK_BYTES) * GPU_CHUNK_BYTES;\n  }\n  update() {\n    let updated = false;\n    for (const uniform of this.uniforms) {\n      if (this.updateByType(uniform) === true) {\n        updated = true;\n      }\n    }\n    return updated;\n  }\n  updateByType(uniform) {\n    if (uniform.isNumberUniform) return this.updateNumber(uniform);\n    if (uniform.isVector2Uniform) return this.updateVector2(uniform);\n    if (uniform.isVector3Uniform) return this.updateVector3(uniform);\n    if (uniform.isVector4Uniform) return this.updateVector4(uniform);\n    if (uniform.isColorUniform) return this.updateColor(uniform);\n    if (uniform.isMatrix3Uniform) return this.updateMatrix3(uniform);\n    if (uniform.isMatrix4Uniform) return this.updateMatrix4(uniform);\n    console.error('THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform);\n  }\n  updateNumber(uniform) {\n    let updated = false;\n    const a = this.values;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    const type = uniform.getType();\n    if (a[offset] !== v) {\n      const b = this._getBufferForType(type);\n      b[offset] = a[offset] = v;\n      updated = true;\n    }\n    return updated;\n  }\n  updateVector2(uniform) {\n    let updated = false;\n    const a = this.values;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    const type = uniform.getType();\n    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y) {\n      const b = this._getBufferForType(type);\n      b[offset + 0] = a[offset + 0] = v.x;\n      b[offset + 1] = a[offset + 1] = v.y;\n      updated = true;\n    }\n    return updated;\n  }\n  updateVector3(uniform) {\n    let updated = false;\n    const a = this.values;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    const type = uniform.getType();\n    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z) {\n      const b = this._getBufferForType(type);\n      b[offset + 0] = a[offset + 0] = v.x;\n      b[offset + 1] = a[offset + 1] = v.y;\n      b[offset + 2] = a[offset + 2] = v.z;\n      updated = true;\n    }\n    return updated;\n  }\n  updateVector4(uniform) {\n    let updated = false;\n    const a = this.values;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    const type = uniform.getType();\n    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z || a[offset + 4] !== v.w) {\n      const b = this._getBufferForType(type);\n      b[offset + 0] = a[offset + 0] = v.x;\n      b[offset + 1] = a[offset + 1] = v.y;\n      b[offset + 2] = a[offset + 2] = v.z;\n      b[offset + 3] = a[offset + 3] = v.w;\n      updated = true;\n    }\n    return updated;\n  }\n  updateColor(uniform) {\n    let updated = false;\n    const a = this.values;\n    const c = uniform.getValue();\n    const offset = uniform.offset;\n    if (a[offset + 0] !== c.r || a[offset + 1] !== c.g || a[offset + 2] !== c.b) {\n      const b = this.buffer;\n      b[offset + 0] = a[offset + 0] = c.r;\n      b[offset + 1] = a[offset + 1] = c.g;\n      b[offset + 2] = a[offset + 2] = c.b;\n      updated = true;\n    }\n    return updated;\n  }\n  updateMatrix3(uniform) {\n    let updated = false;\n    const a = this.values;\n    const e = uniform.getValue().elements;\n    const offset = uniform.offset;\n    if (a[offset + 0] !== e[0] || a[offset + 1] !== e[1] || a[offset + 2] !== e[2] || a[offset + 4] !== e[3] || a[offset + 5] !== e[4] || a[offset + 6] !== e[5] || a[offset + 8] !== e[6] || a[offset + 9] !== e[7] || a[offset + 10] !== e[8]) {\n      const b = this.buffer;\n      b[offset + 0] = a[offset + 0] = e[0];\n      b[offset + 1] = a[offset + 1] = e[1];\n      b[offset + 2] = a[offset + 2] = e[2];\n      b[offset + 4] = a[offset + 4] = e[3];\n      b[offset + 5] = a[offset + 5] = e[4];\n      b[offset + 6] = a[offset + 6] = e[5];\n      b[offset + 8] = a[offset + 8] = e[6];\n      b[offset + 9] = a[offset + 9] = e[7];\n      b[offset + 10] = a[offset + 10] = e[8];\n      updated = true;\n    }\n    return updated;\n  }\n  updateMatrix4(uniform) {\n    let updated = false;\n    const a = this.values;\n    const e = uniform.getValue().elements;\n    const offset = uniform.offset;\n    if (arraysEqual(a, e, offset) === false) {\n      const b = this.buffer;\n      b.set(e, offset);\n      setArray(a, e, offset);\n      updated = true;\n    }\n    return updated;\n  }\n  _getBufferForType(type) {\n    if (type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4') return new Int32Array(this.buffer.buffer);\n    if (type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4') return new Uint32Array(this.buffer.buffer);\n    return this.buffer;\n  }\n}\nfunction setArray(a, b, offset) {\n  for (let i = 0, l = b.length; i < l; i++) {\n    a[offset + i] = b[i];\n  }\n}\nfunction arraysEqual(a, b, offset) {\n  for (let i = 0, l = b.length; i < l; i++) {\n    if (a[offset + i] !== b[i]) return false;\n  }\n  return true;\n}\nlet _id$3 = 0;\nclass NodeUniformsGroup extends UniformsGroup {\n  constructor(name, groupNode) {\n    super(name);\n    this.id = _id$3++;\n    this.groupNode = groupNode;\n    this.isNodeUniformsGroup = true;\n  }\n  getNodes() {\n    const nodes = [];\n    for (const uniform of this.uniforms) {\n      const node = uniform.nodeUniform.node;\n      if (!node) throw new Error('NodeUniformsGroup: Uniform has no node.');\n      nodes.push(node);\n    }\n    return nodes;\n  }\n}\nlet _id$2 = 0;\nclass SampledTexture extends Binding {\n  constructor(name, texture) {\n    super(name);\n    this.id = _id$2++;\n    this.texture = texture;\n    this.version = texture ? texture.version : 0;\n    this.store = false;\n    this.generation = null;\n    this.isSampledTexture = true;\n  }\n  needsBindingsUpdate(generation) {\n    const {\n      texture\n    } = this;\n    if (generation !== this.generation) {\n      this.generation = generation;\n      return true;\n    }\n    return texture.isVideoTexture;\n  }\n  update() {\n    const {\n      texture,\n      version\n    } = this;\n    if (version !== texture.version) {\n      this.version = texture.version;\n      return true;\n    }\n    return false;\n  }\n}\nclass NodeSampledTexture extends SampledTexture {\n  constructor(name, textureNode, groupNode) {\n    let access = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    super(name, textureNode ? textureNode.value : null);\n    this.textureNode = textureNode;\n    this.groupNode = groupNode;\n    this.access = access;\n  }\n  needsBindingsUpdate(generation) {\n    return this.textureNode.value !== this.texture || super.needsBindingsUpdate(generation);\n  }\n  update() {\n    const {\n      textureNode\n    } = this;\n    if (this.texture !== textureNode.value) {\n      this.texture = textureNode.value;\n      return true;\n    }\n    return super.update();\n  }\n}\nclass NodeSampledCubeTexture extends NodeSampledTexture {\n  constructor(name, textureNode, groupNode, access) {\n    super(name, textureNode, groupNode, access);\n    this.isSampledCubeTexture = true;\n  }\n}\nclass NodeSampledTexture3D extends NodeSampledTexture {\n  constructor(name, textureNode, groupNode, access) {\n    super(name, textureNode, groupNode, access);\n    this.isSampledTexture3D = true;\n  }\n}\nconst glslMethods = {\n  atan2: 'atan',\n  textureDimensions: 'textureSize',\n  equals: 'equal'\n};\nconst precisionLib = {\n  low: 'lowp',\n  medium: 'mediump',\n  high: 'highp'\n};\nconst supports$1 = {\n  swizzleAssign: true,\n  storageBuffer: false\n};\nconst defaultPrecisions = `\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler3D;\nprecision highp samplerCube;\nprecision highp sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp usampler3D;\nprecision highp usamplerCube;\nprecision highp usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp isampler3D;\nprecision highp isamplerCube;\nprecision highp isampler2DArray;\n\nprecision lowp sampler2DShadow;\n`;\nclass GLSLNodeBuilder extends NodeBuilder {\n  constructor(object, renderer) {\n    super(object, renderer, new GLSLNodeParser());\n    this.uniformGroups = {};\n    this.transforms = [];\n    this.extensions = {};\n    this.builtins = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.useComparisonMethod = true;\n  }\n  needsToWorkingColorSpace(texture) {\n    return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n  }\n  getMethod(method) {\n    return glslMethods[method] || method;\n  }\n  getOutputStructName() {\n    return '';\n  }\n  buildFunctionCode(shaderNode) {\n    const layout = shaderNode.layout;\n    const flowData = this.flowShaderNode(shaderNode);\n    const parameters = [];\n    for (const input of layout.inputs) {\n      parameters.push(this.getType(input.type) + ' ' + input.name);\n    }\n\n    //\n\n    const code = `${this.getType(layout.type)} ${layout.name}( ${parameters.join(', ')} ) {\n\n\t${flowData.vars}\n\n${flowData.code}\n\treturn ${flowData.result};\n\n}`;\n\n    //\n\n    return code;\n  }\n  setupPBO(storageBufferNode) {\n    const attribute = storageBufferNode.value;\n    if (attribute.pbo === undefined) {\n      const originalArray = attribute.array;\n      const numElements = attribute.count * attribute.itemSize;\n      const {\n        itemSize\n      } = attribute;\n      const isInteger = attribute.array.constructor.name.toLowerCase().includes('int');\n      let format = isInteger ? RedIntegerFormat : RedFormat;\n      if (itemSize === 2) {\n        format = isInteger ? RGIntegerFormat : RGFormat;\n      } else if (itemSize === 3) {\n        format = isInteger ? RGBIntegerFormat : RGBFormat;\n      } else if (itemSize === 4) {\n        format = isInteger ? RGBAIntegerFormat : RGBAFormat;\n      }\n      const typeMap = {\n        Float32Array: FloatType,\n        Uint8Array: UnsignedByteType,\n        Uint16Array: UnsignedShortType,\n        Uint32Array: UnsignedIntType,\n        Int8Array: ByteType,\n        Int16Array: ShortType,\n        Int32Array: IntType,\n        Uint8ClampedArray: UnsignedByteType\n      };\n      const width = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(numElements / itemSize))));\n      let height = Math.ceil(numElements / itemSize / width);\n      if (width * height * itemSize < numElements) height++; // Ensure enough space\n\n      const newSize = width * height * itemSize;\n      const newArray = new originalArray.constructor(newSize);\n      newArray.set(originalArray, 0);\n      attribute.array = newArray;\n      const pboTexture = new DataTexture(attribute.array, width, height, format, typeMap[attribute.array.constructor.name] || FloatType);\n      pboTexture.needsUpdate = true;\n      pboTexture.isPBOTexture = true;\n      const pbo = new TextureNode(pboTexture, null, null);\n      pbo.setPrecision('high');\n      attribute.pboNode = pbo;\n      attribute.pbo = pbo.value;\n      this.getUniformFromNode(attribute.pboNode, 'texture', this.shaderStage, this.context.label);\n    }\n  }\n  getPropertyName(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    if (node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true) {\n      return shaderStage.charAt(0) + '_' + node.name;\n    }\n    return super.getPropertyName(node, shaderStage);\n  }\n  generatePBO(storageArrayElementNode) {\n    const {\n      node,\n      indexNode\n    } = storageArrayElementNode;\n    const attribute = node.value;\n    if (this.renderer.backend.has(attribute)) {\n      const attributeData = this.renderer.backend.get(attribute);\n      attributeData.pbo = attribute.pbo;\n    }\n    const nodeUniform = this.getUniformFromNode(attribute.pboNode, 'texture', this.shaderStage, this.context.label);\n    const textureName = this.getPropertyName(nodeUniform);\n    this.increaseUsage(indexNode); // force cache generate to be used as index in x,y\n    const indexSnippet = indexNode.build(this, 'uint');\n    const elementNodeData = this.getDataFromNode(storageArrayElementNode);\n    let propertyName = elementNodeData.propertyName;\n    if (propertyName === undefined) {\n      // property element\n\n      const nodeVar = this.getVarFromNode(storageArrayElementNode);\n      propertyName = this.getPropertyName(nodeVar);\n\n      // property size\n\n      const bufferNodeData = this.getDataFromNode(node);\n      let propertySizeName = bufferNodeData.propertySizeName;\n      if (propertySizeName === undefined) {\n        propertySizeName = propertyName + 'Size';\n        this.getVarFromNode(node, propertySizeName, 'uint');\n        this.addLineFlowCode(`${propertySizeName} = uint( textureSize( ${textureName}, 0 ).x )`, storageArrayElementNode);\n        bufferNodeData.propertySizeName = propertySizeName;\n      }\n\n      //\n\n      const {\n        itemSize\n      } = attribute;\n      const channel = '.' + vectorComponents.join('').slice(0, itemSize);\n      const uvSnippet = `ivec2(${indexSnippet} % ${propertySizeName}, ${indexSnippet} / ${propertySizeName})`;\n      const snippet = this.generateTextureLoad(null, textureName, uvSnippet, null, '0');\n\n      //\n\n      let prefix = 'vec4';\n      if (attribute.pbo.type === UnsignedIntType) {\n        prefix = 'uvec4';\n      } else if (attribute.pbo.type === IntType) {\n        prefix = 'ivec4';\n      }\n      this.addLineFlowCode(`${propertyName} = ${prefix}(${snippet})${channel}`, storageArrayElementNode);\n      elementNodeData.propertyName = propertyName;\n    }\n    return propertyName;\n  }\n  generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet) {\n    let levelSnippet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '0';\n    if (depthSnippet) {\n      return `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`;\n    } else {\n      return `texelFetch( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;\n    }\n  }\n  generateTexture(texture, textureProperty, uvSnippet, depthSnippet) {\n    if (texture.isDepthTexture) {\n      return `texture( ${textureProperty}, ${uvSnippet} ).x`;\n    } else {\n      if (depthSnippet) uvSnippet = `vec3( ${uvSnippet}, ${depthSnippet} )`;\n      return `texture( ${textureProperty}, ${uvSnippet} )`;\n    }\n  }\n  generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet) {\n    return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;\n  }\n  generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet) {\n    return `texture( ${textureProperty}, ${uvSnippet}, ${biasSnippet} )`;\n  }\n  generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet) {\n    return `textureGrad( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]} )`;\n  }\n  generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet) {\n    let shaderStage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.shaderStage;\n    if (shaderStage === 'fragment') {\n      return `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);\n    }\n  }\n  getVars(shaderStage) {\n    const snippets = [];\n    const vars = this.vars[shaderStage];\n    if (vars !== undefined) {\n      for (const variable of vars) {\n        snippets.push(`${this.getVar(variable.type, variable.name)};`);\n      }\n    }\n    return snippets.join('\\n\\t');\n  }\n  getUniforms(shaderStage) {\n    const uniforms = this.uniforms[shaderStage];\n    const bindingSnippets = [];\n    const uniformGroups = {};\n    for (const uniform of uniforms) {\n      let snippet = null;\n      let group = false;\n      if (uniform.type === 'texture') {\n        const texture = uniform.node.value;\n        let typePrefix = '';\n        if (texture.isDataTexture === true) {\n          if (texture.type === UnsignedIntType) {\n            typePrefix = 'u';\n          } else if (texture.type === IntType) {\n            typePrefix = 'i';\n          }\n        }\n        if (texture.compareFunction) {\n          snippet = `sampler2DShadow ${uniform.name};`;\n        } else if (texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true) {\n          snippet = `${typePrefix}sampler2DArray ${uniform.name};`;\n        } else {\n          snippet = `${typePrefix}sampler2D ${uniform.name};`;\n        }\n      } else if (uniform.type === 'cubeTexture') {\n        snippet = `samplerCube ${uniform.name};`;\n      } else if (uniform.type === 'texture3D') {\n        snippet = `sampler3D ${uniform.name};`;\n      } else if (uniform.type === 'buffer') {\n        const bufferNode = uniform.node;\n        const bufferType = this.getType(bufferNode.bufferType);\n        const bufferCount = bufferNode.bufferCount;\n        const bufferCountSnippet = bufferCount > 0 ? bufferCount : '';\n        snippet = `${bufferNode.name} {\\n\\t${bufferType} ${uniform.name}[${bufferCountSnippet}];\\n};\\n`;\n      } else {\n        const vectorType = this.getVectorType(uniform.type);\n        snippet = `${vectorType} ${this.getPropertyName(uniform, shaderStage)};`;\n        group = true;\n      }\n      const precision = uniform.node.precision;\n      if (precision !== null) {\n        snippet = precisionLib[precision] + ' ' + snippet;\n      }\n      if (group) {\n        snippet = '\\t' + snippet;\n        const groupName = uniform.groupNode.name;\n        const groupSnippets = uniformGroups[groupName] || (uniformGroups[groupName] = []);\n        groupSnippets.push(snippet);\n      } else {\n        snippet = 'uniform ' + snippet;\n        bindingSnippets.push(snippet);\n      }\n    }\n    let output = '';\n    for (const name in uniformGroups) {\n      const groupSnippets = uniformGroups[name];\n      output += this._getGLSLUniformStruct(shaderStage + '_' + name, groupSnippets.join('\\n')) + '\\n';\n    }\n    output += bindingSnippets.join('\\n');\n    return output;\n  }\n  getTypeFromAttribute(attribute) {\n    let nodeType = super.getTypeFromAttribute(attribute);\n    if (/^[iu]/.test(nodeType) && attribute.gpuType !== IntType) {\n      let dataAttribute = attribute;\n      if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;\n      const array = dataAttribute.array;\n      if ((array instanceof Uint32Array || array instanceof Int32Array) === false) {\n        nodeType = nodeType.slice(1);\n      }\n    }\n    return nodeType;\n  }\n  getAttributes(shaderStage) {\n    let snippet = '';\n    if (shaderStage === 'vertex' || shaderStage === 'compute') {\n      const attributes = this.getAttributesArray();\n      let location = 0;\n      for (const attribute of attributes) {\n        snippet += `layout( location = ${location++} ) in ${attribute.type} ${attribute.name};\\n`;\n      }\n    }\n    return snippet;\n  }\n  getStructMembers(struct) {\n    const snippets = [];\n    const members = struct.getMemberTypes();\n    for (let i = 0; i < members.length; i++) {\n      const member = members[i];\n      snippets.push(`layout( location = ${i} ) out ${member} m${i};`);\n    }\n    return snippets.join('\\n');\n  }\n  getStructs(shaderStage) {\n    const snippets = [];\n    const structs = this.structs[shaderStage];\n    if (structs.length === 0) {\n      return 'layout( location = 0 ) out vec4 fragColor;\\n';\n    }\n    for (let index = 0, length = structs.length; index < length; index++) {\n      const struct = structs[index];\n      let snippet = '\\n';\n      snippet += this.getStructMembers(struct);\n      snippet += '\\n';\n      snippets.push(snippet);\n    }\n    return snippets.join('\\n\\n');\n  }\n  getVaryings(shaderStage) {\n    let snippet = '';\n    const varyings = this.varyings;\n    if (shaderStage === 'vertex' || shaderStage === 'compute') {\n      for (const varying of varyings) {\n        if (shaderStage === 'compute') varying.needsInterpolation = true;\n        const type = this.getType(varying.type);\n        const flat = type.includes('int') || type.includes('uv') || type.includes('iv') ? 'flat ' : '';\n        snippet += `${flat}${varying.needsInterpolation ? 'out' : '/*out*/'} ${type} ${varying.name};\\n`;\n      }\n    } else if (shaderStage === 'fragment') {\n      for (const varying of varyings) {\n        if (varying.needsInterpolation) {\n          const type = this.getType(varying.type);\n          const flat = type.includes('int') || type.includes('uv') || type.includes('iv') ? 'flat ' : '';\n          snippet += `${flat}in ${type} ${varying.name};\\n`;\n        }\n      }\n    }\n    for (const builtin of this.builtins[shaderStage]) {\n      snippet += `${builtin};\\n`;\n    }\n    return snippet;\n  }\n  getVertexIndex() {\n    return 'uint( gl_VertexID )';\n  }\n  getInstanceIndex() {\n    return 'uint( gl_InstanceID )';\n  }\n  getInvocationLocalIndex() {\n    const workgroupSize = this.object.workgroupSize;\n    const size = workgroupSize.reduce((acc, curr) => acc * curr, 1);\n    return `uint( gl_InstanceID ) % ${size}u`;\n  }\n  getDrawIndex() {\n    const extensions = this.renderer.backend.extensions;\n    if (extensions.has('WEBGL_multi_draw')) {\n      return 'uint( gl_DrawID )';\n    }\n    return null;\n  }\n  getFrontFacing() {\n    return 'gl_FrontFacing';\n  }\n  getFragCoord() {\n    return 'gl_FragCoord.xy';\n  }\n  getFragDepth() {\n    return 'gl_FragDepth';\n  }\n  enableExtension(name, behavior) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    const map = this.extensions[shaderStage] || (this.extensions[shaderStage] = new Map());\n    if (map.has(name) === false) {\n      map.set(name, {\n        name,\n        behavior\n      });\n    }\n  }\n  getExtensions(shaderStage) {\n    const snippets = [];\n    if (shaderStage === 'vertex') {\n      const ext = this.renderer.backend.extensions;\n      const isBatchedMesh = this.object.isBatchedMesh;\n      if (isBatchedMesh && ext.has('WEBGL_multi_draw')) {\n        this.enableExtension('GL_ANGLE_multi_draw', 'require', shaderStage);\n      }\n    }\n    const extensions = this.extensions[shaderStage];\n    if (extensions !== undefined) {\n      for (const {\n        name,\n        behavior\n      } of extensions.values()) {\n        snippets.push(`#extension ${name} : ${behavior}`);\n      }\n    }\n    return snippets.join('\\n');\n  }\n  getClipDistance() {\n    return 'gl_ClipDistance';\n  }\n  isAvailable(name) {\n    let result = supports$1[name];\n    if (result === undefined) {\n      let extensionName;\n      result = false;\n      switch (name) {\n        case 'float32Filterable':\n          extensionName = 'OES_texture_float_linear';\n          break;\n        case 'clipDistance':\n          extensionName = 'WEBGL_clip_cull_distance';\n          break;\n      }\n      if (extensionName !== undefined) {\n        const extensions = this.renderer.backend.extensions;\n        if (extensions.has(extensionName)) {\n          extensions.get(extensionName);\n          result = true;\n        }\n      }\n      supports$1[name] = result;\n    }\n    return result;\n  }\n  isFlipY() {\n    return true;\n  }\n  enableHardwareClipping(planeCount) {\n    this.enableExtension('GL_ANGLE_clip_cull_distance', 'require');\n    this.builtins['vertex'].push(`out float gl_ClipDistance[ ${planeCount} ]`);\n  }\n  registerTransform(varyingName, attributeNode) {\n    this.transforms.push({\n      varyingName,\n      attributeNode\n    });\n  }\n  getTransforms(/* shaderStage  */\n  ) {\n    const transforms = this.transforms;\n    let snippet = '';\n    for (let i = 0; i < transforms.length; i++) {\n      const transform = transforms[i];\n      const attributeName = this.getPropertyName(transform.attributeNode);\n      snippet += `${transform.varyingName} = ${attributeName};\\n\\t`;\n    }\n    return snippet;\n  }\n  _getGLSLUniformStruct(name, vars) {\n    return `\nlayout( std140 ) uniform ${name} {\n${vars}\n};`;\n  }\n  _getGLSLVertexCode(shaderData) {\n    return `#version 300 es\n\n${this.getSignature()}\n\n// extensions \n${shaderData.extensions}\n\n// precision\n${defaultPrecisions}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// attributes\n${shaderData.attributes}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// transforms\n\t${shaderData.transforms}\n\n\t// flow\n\t${shaderData.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`;\n  }\n  _getGLSLFragmentCode(shaderData) {\n    return `#version 300 es\n\n${this.getSignature()}\n\n// precision\n${defaultPrecisions}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\n${shaderData.structs}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  buildCode() {\n    const shadersData = this.material !== null ? {\n      fragment: {},\n      vertex: {}\n    } : {\n      compute: {}\n    };\n    this.sortBindingGroups();\n    for (const shaderStage in shadersData) {\n      let flow = '// code\\n\\n';\n      flow += this.flowCode[shaderStage];\n      const flowNodes = this.flowNodes[shaderStage];\n      const mainNode = flowNodes[flowNodes.length - 1];\n      for (const node of flowNodes) {\n        const flowSlotData = this.getFlowData(node /*, shaderStage*/);\n        const slotName = node.name;\n        if (slotName) {\n          if (flow.length > 0) flow += '\\n';\n          flow += `\\t// flow -> ${slotName}\\n\\t`;\n        }\n        flow += `${flowSlotData.code}\\n\\t`;\n        if (node === mainNode && shaderStage !== 'compute') {\n          flow += '// result\\n\\t';\n          if (shaderStage === 'vertex') {\n            flow += 'gl_Position = ';\n            flow += `${flowSlotData.result};`;\n          } else if (shaderStage === 'fragment') {\n            if (!node.outputNode.isOutputStructNode) {\n              flow += 'fragColor = ';\n              flow += `${flowSlotData.result};`;\n            }\n          }\n        }\n      }\n      const stageData = shadersData[shaderStage];\n      stageData.extensions = this.getExtensions(shaderStage);\n      stageData.uniforms = this.getUniforms(shaderStage);\n      stageData.attributes = this.getAttributes(shaderStage);\n      stageData.varyings = this.getVaryings(shaderStage);\n      stageData.vars = this.getVars(shaderStage);\n      stageData.structs = this.getStructs(shaderStage);\n      stageData.codes = this.getCodes(shaderStage);\n      stageData.transforms = this.getTransforms(shaderStage);\n      stageData.flow = flow;\n    }\n    if (this.material !== null) {\n      this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);\n      this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);\n    } else {\n      this.computeShader = this._getGLSLVertexCode(shadersData.compute);\n    }\n  }\n  getUniformFromNode(node, type, shaderStage) {\n    let name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);\n    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);\n    let uniformGPU = nodeData.uniformGPU;\n    if (uniformGPU === undefined) {\n      const group = node.groupNode;\n      const groupName = group.name;\n      const bindings = this.getBindGroupArray(groupName, shaderStage);\n      if (type === 'texture') {\n        uniformGPU = new NodeSampledTexture(uniformNode.name, uniformNode.node, group);\n        bindings.push(uniformGPU);\n      } else if (type === 'cubeTexture') {\n        uniformGPU = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group);\n        bindings.push(uniformGPU);\n      } else if (type === 'texture3D') {\n        uniformGPU = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group);\n        bindings.push(uniformGPU);\n      } else if (type === 'buffer') {\n        node.name = `NodeBuffer_${node.id}`;\n        uniformNode.name = `buffer${node.id}`;\n        const buffer = new NodeUniformBuffer(node, group);\n        buffer.name = node.name;\n        bindings.push(buffer);\n        uniformGPU = buffer;\n      } else {\n        const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});\n        let uniformsGroup = uniformsStage[groupName];\n        if (uniformsGroup === undefined) {\n          uniformsGroup = new NodeUniformsGroup(shaderStage + '_' + groupName, group);\n          //uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n          uniformsStage[groupName] = uniformsGroup;\n          bindings.push(uniformsGroup);\n        }\n        uniformGPU = this.getNodeUniform(uniformNode, type);\n        uniformsGroup.addUniform(uniformGPU);\n      }\n      nodeData.uniformGPU = uniformGPU;\n    }\n    return uniformNode;\n  }\n}\nlet vector2 = null;\nlet vector4 = null;\nlet color4 = null;\nclass Backend {\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.parameters = Object.assign({}, parameters);\n    this.data = new WeakMap();\n    this.renderer = null;\n    this.domElement = null;\n  }\n  async init(renderer) {\n    this.renderer = renderer;\n  }\n\n  // render context\n\n  begin(/*renderContext*/) {}\n  finish(/*renderContext*/) {}\n\n  // render object\n\n  draw(/*renderObject, info*/) {}\n\n  // program\n\n  createProgram(/*program*/) {}\n  destroyProgram(/*program*/) {}\n\n  // bindings\n\n  createBindings(/*bingGroup, bindings*/) {}\n  updateBindings(/*bingGroup, bindings*/) {}\n\n  // pipeline\n\n  createRenderPipeline(/*renderObject*/) {}\n  createComputePipeline(/*computeNode, pipeline*/) {}\n  destroyPipeline(/*pipeline*/) {}\n\n  // cache key\n\n  needsRenderUpdate(/*renderObject*/) {} // return Boolean ( fast test )\n\n  getRenderCacheKey(/*renderObject*/) {} // return String\n\n  // node builder\n\n  createNodeBuilder(/*renderObject*/) {} // return NodeBuilder (ADD IT)\n\n  // textures\n\n  createSampler(/*texture*/) {}\n  createDefaultTexture(/*texture*/) {}\n  createTexture(/*texture*/) {}\n  copyTextureToBuffer(/*texture, x, y, width, height*/) {}\n\n  // attributes\n\n  createAttribute(/*attribute*/) {}\n  createIndexAttribute(/*attribute*/) {}\n  updateAttribute(/*attribute*/) {}\n  destroyAttribute(/*attribute*/) {}\n\n  // canvas\n\n  getContext() {}\n  updateSize() {}\n\n  // utils\n\n  resolveTimestampAsync(/*renderContext, type*/) {}\n  hasFeatureAsync(/*name*/) {} // return Boolean\n\n  hasFeature(/*name*/) {} // return Boolean\n\n  getInstanceCount(renderObject) {\n    const {\n      object,\n      geometry\n    } = renderObject;\n    return geometry.isInstancedBufferGeometry ? geometry.instanceCount : object.count > 1 ? object.count : 1;\n  }\n  getDrawingBufferSize() {\n    vector2 = vector2 || new Vector2();\n    return this.renderer.getDrawingBufferSize(vector2);\n  }\n  getScissor() {\n    vector4 = vector4 || new Vector4();\n    return this.renderer.getScissor(vector4);\n  }\n  setScissorTest(/*boolean*/) {}\n  getClearColor() {\n    const renderer = this.renderer;\n    color4 = color4 || new Color4();\n    renderer.getClearColor(color4);\n    color4.getRGB(color4, this.renderer.currentColorSpace);\n    return color4;\n  }\n  getDomElement() {\n    let domElement = this.domElement;\n    if (domElement === null) {\n      domElement = this.parameters.canvas !== undefined ? this.parameters.canvas : createCanvasElement();\n\n      // OffscreenCanvas does not have setAttribute, see #22811\n      if ('setAttribute' in domElement) domElement.setAttribute('data-engine', `three.js r${REVISION} webgpu`);\n      this.domElement = domElement;\n    }\n    return domElement;\n  }\n\n  // resource properties\n\n  set(object, value) {\n    this.data.set(object, value);\n  }\n  get(object) {\n    let map = this.data.get(object);\n    if (map === undefined) {\n      map = {};\n      this.data.set(object, map);\n    }\n    return map;\n  }\n  has(object) {\n    return this.data.has(object);\n  }\n  delete(object) {\n    this.data.delete(object);\n  }\n  dispose() {}\n}\nlet _id$1 = 0;\nclass DualAttributeData {\n  constructor(attributeData, dualBuffer) {\n    this.buffers = [attributeData.bufferGPU, dualBuffer];\n    this.type = attributeData.type;\n    this.bufferType = attributeData.bufferType;\n    this.pbo = attributeData.pbo;\n    this.byteLength = attributeData.byteLength;\n    this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;\n    this.version = attributeData.version;\n    this.isInteger = attributeData.isInteger;\n    this.activeBufferIndex = 0;\n    this.baseId = attributeData.id;\n  }\n  get id() {\n    return `${this.baseId}|${this.activeBufferIndex}`;\n  }\n  get bufferGPU() {\n    return this.buffers[this.activeBufferIndex];\n  }\n  get transformBuffer() {\n    return this.buffers[this.activeBufferIndex ^ 1];\n  }\n  switchBuffers() {\n    this.activeBufferIndex ^= 1;\n  }\n}\nclass WebGLAttributeUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  createAttribute(attribute, bufferType) {\n    const backend = this.backend;\n    const {\n      gl\n    } = backend;\n    const array = attribute.array;\n    const usage = attribute.usage || gl.STATIC_DRAW;\n    const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n    const bufferData = backend.get(bufferAttribute);\n    let bufferGPU = bufferData.bufferGPU;\n    if (bufferGPU === undefined) {\n      bufferGPU = this._createBuffer(gl, bufferType, array, usage);\n      bufferData.bufferGPU = bufferGPU;\n      bufferData.bufferType = bufferType;\n      bufferData.version = bufferAttribute.version;\n    }\n\n    //attribute.onUploadCallback();\n\n    let type;\n    if (array instanceof Float32Array) {\n      type = gl.FLOAT;\n    } else if (array instanceof Uint16Array) {\n      if (attribute.isFloat16BufferAttribute) {\n        type = gl.HALF_FLOAT;\n      } else {\n        type = gl.UNSIGNED_SHORT;\n      }\n    } else if (array instanceof Int16Array) {\n      type = gl.SHORT;\n    } else if (array instanceof Uint32Array) {\n      type = gl.UNSIGNED_INT;\n    } else if (array instanceof Int32Array) {\n      type = gl.INT;\n    } else if (array instanceof Int8Array) {\n      type = gl.BYTE;\n    } else if (array instanceof Uint8Array) {\n      type = gl.UNSIGNED_BYTE;\n    } else if (array instanceof Uint8ClampedArray) {\n      type = gl.UNSIGNED_BYTE;\n    } else {\n      throw new Error('THREE.WebGLBackend: Unsupported buffer data format: ' + array);\n    }\n    let attributeData = {\n      bufferGPU,\n      bufferType,\n      type,\n      byteLength: array.byteLength,\n      bytesPerElement: array.BYTES_PER_ELEMENT,\n      version: attribute.version,\n      pbo: attribute.pbo,\n      isInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,\n      id: _id$1++\n    };\n    if (attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute) {\n      // create buffer for tranform feedback use\n      const bufferGPUDual = this._createBuffer(gl, bufferType, array, usage);\n      attributeData = new DualAttributeData(attributeData, bufferGPUDual);\n    }\n    backend.set(attribute, attributeData);\n  }\n  updateAttribute(attribute) {\n    const backend = this.backend;\n    const {\n      gl\n    } = backend;\n    const array = attribute.array;\n    const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n    const bufferData = backend.get(bufferAttribute);\n    const bufferType = bufferData.bufferType;\n    const updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;\n    gl.bindBuffer(bufferType, bufferData.bufferGPU);\n    if (updateRanges.length === 0) {\n      // Not using update ranges\n\n      gl.bufferSubData(bufferType, 0, array);\n    } else {\n      for (let i = 0, l = updateRanges.length; i < l; i++) {\n        const range = updateRanges[i];\n        gl.bufferSubData(bufferType, range.start * array.BYTES_PER_ELEMENT, array, range.start, range.count);\n      }\n      bufferAttribute.clearUpdateRanges();\n    }\n    gl.bindBuffer(bufferType, null);\n    bufferData.version = bufferAttribute.version;\n  }\n  destroyAttribute(attribute) {\n    const backend = this.backend;\n    const {\n      gl\n    } = backend;\n    if (attribute.isInterleavedBufferAttribute) {\n      backend.delete(attribute.data);\n    }\n    const attributeData = backend.get(attribute);\n    gl.deleteBuffer(attributeData.bufferGPU);\n    backend.delete(attribute);\n  }\n  async getArrayBufferAsync(attribute) {\n    const backend = this.backend;\n    const {\n      gl\n    } = backend;\n    const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n    const {\n      bufferGPU\n    } = backend.get(bufferAttribute);\n    const array = attribute.array;\n    const byteLength = array.byteLength;\n    gl.bindBuffer(gl.COPY_READ_BUFFER, bufferGPU);\n    const writeBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);\n    gl.bufferData(gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ);\n    gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength);\n    await backend.utils._clientWaitAsync();\n    const dstBuffer = new attribute.array.constructor(array.length);\n\n    // Ensure the buffer is bound before reading\n    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);\n    gl.getBufferSubData(gl.COPY_WRITE_BUFFER, 0, dstBuffer);\n    gl.deleteBuffer(writeBuffer);\n    gl.bindBuffer(gl.COPY_READ_BUFFER, null);\n    gl.bindBuffer(gl.COPY_WRITE_BUFFER, null);\n    return dstBuffer.buffer;\n  }\n  _createBuffer(gl, bufferType, array, usage) {\n    const bufferGPU = gl.createBuffer();\n    gl.bindBuffer(bufferType, bufferGPU);\n    gl.bufferData(bufferType, array, usage);\n    gl.bindBuffer(bufferType, null);\n    return bufferGPU;\n  }\n}\nlet initialized$1 = false,\n  equationToGL,\n  factorToGL;\nclass WebGLState {\n  constructor(backend) {\n    this.backend = backend;\n    this.gl = this.backend.gl;\n    this.enabled = {};\n    this.currentFlipSided = null;\n    this.currentCullFace = null;\n    this.currentProgram = null;\n    this.currentBlendingEnabled = false;\n    this.currentBlending = null;\n    this.currentBlendSrc = null;\n    this.currentBlendDst = null;\n    this.currentBlendSrcAlpha = null;\n    this.currentBlendDstAlpha = null;\n    this.currentPremultipledAlpha = null;\n    this.currentPolygonOffsetFactor = null;\n    this.currentPolygonOffsetUnits = null;\n    this.currentColorMask = null;\n    this.currentDepthFunc = null;\n    this.currentDepthMask = null;\n    this.currentStencilFunc = null;\n    this.currentStencilRef = null;\n    this.currentStencilFuncMask = null;\n    this.currentStencilFail = null;\n    this.currentStencilZFail = null;\n    this.currentStencilZPass = null;\n    this.currentStencilMask = null;\n    this.currentLineWidth = null;\n    this.currentClippingPlanes = 0;\n    this.currentBoundFramebuffers = {};\n    this.currentDrawbuffers = new WeakMap();\n    this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.currentTextureSlot = null;\n    this.currentBoundTextures = {};\n    this.currentBoundBufferBases = {};\n    if (initialized$1 === false) {\n      this._init(this.gl);\n      initialized$1 = true;\n    }\n  }\n  _init(gl) {\n    // Store only WebGL constants here.\n\n    equationToGL = {\n      [AddEquation]: gl.FUNC_ADD,\n      [SubtractEquation]: gl.FUNC_SUBTRACT,\n      [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT\n    };\n    factorToGL = {\n      [ZeroFactor]: gl.ZERO,\n      [OneFactor]: gl.ONE,\n      [SrcColorFactor]: gl.SRC_COLOR,\n      [SrcAlphaFactor]: gl.SRC_ALPHA,\n      [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,\n      [DstColorFactor]: gl.DST_COLOR,\n      [DstAlphaFactor]: gl.DST_ALPHA,\n      [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,\n      [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,\n      [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,\n      [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA\n    };\n  }\n  enable(id) {\n    const {\n      enabled\n    } = this;\n    if (enabled[id] !== true) {\n      this.gl.enable(id);\n      enabled[id] = true;\n    }\n  }\n  disable(id) {\n    const {\n      enabled\n    } = this;\n    if (enabled[id] !== false) {\n      this.gl.disable(id);\n      enabled[id] = false;\n    }\n  }\n  setFlipSided(flipSided) {\n    if (this.currentFlipSided !== flipSided) {\n      const {\n        gl\n      } = this;\n      if (flipSided) {\n        gl.frontFace(gl.CW);\n      } else {\n        gl.frontFace(gl.CCW);\n      }\n      this.currentFlipSided = flipSided;\n    }\n  }\n  setCullFace(cullFace) {\n    const {\n      gl\n    } = this;\n    if (cullFace !== CullFaceNone) {\n      this.enable(gl.CULL_FACE);\n      if (cullFace !== this.currentCullFace) {\n        if (cullFace === CullFaceBack) {\n          gl.cullFace(gl.BACK);\n        } else if (cullFace === CullFaceFront) {\n          gl.cullFace(gl.FRONT);\n        } else {\n          gl.cullFace(gl.FRONT_AND_BACK);\n        }\n      }\n    } else {\n      this.disable(gl.CULL_FACE);\n    }\n    this.currentCullFace = cullFace;\n  }\n  setLineWidth(width) {\n    const {\n      currentLineWidth,\n      gl\n    } = this;\n    if (width !== currentLineWidth) {\n      gl.lineWidth(width);\n      this.currentLineWidth = width;\n    }\n  }\n  setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {\n    const {\n      gl\n    } = this;\n    if (blending === NoBlending) {\n      if (this.currentBlendingEnabled === true) {\n        this.disable(gl.BLEND);\n        this.currentBlendingEnabled = false;\n      }\n      return;\n    }\n    if (this.currentBlendingEnabled === false) {\n      this.enable(gl.BLEND);\n      this.currentBlendingEnabled = true;\n    }\n    if (blending !== CustomBlending) {\n      if (blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha) {\n        if (this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation) {\n          gl.blendEquation(gl.FUNC_ADD);\n          this.currentBlendEquation = AddEquation;\n          this.currentBlendEquationAlpha = AddEquation;\n        }\n        if (premultipliedAlpha) {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n              break;\n            case AdditiveBlending:\n              gl.blendFunc(gl.ONE, gl.ONE);\n              break;\n            case SubtractiveBlending:\n              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);\n              break;\n            case MultiplyBlending:\n              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);\n              break;\n            default:\n              console.error('THREE.WebGLState: Invalid blending: ', blending);\n              break;\n          }\n        } else {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n              break;\n            case AdditiveBlending:\n              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n              break;\n            case SubtractiveBlending:\n              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);\n              break;\n            case MultiplyBlending:\n              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);\n              break;\n            default:\n              console.error('THREE.WebGLState: Invalid blending: ', blending);\n              break;\n          }\n        }\n        this.currentBlendSrc = null;\n        this.currentBlendDst = null;\n        this.currentBlendSrcAlpha = null;\n        this.currentBlendDstAlpha = null;\n        this.currentBlending = blending;\n        this.currentPremultipledAlpha = premultipliedAlpha;\n      }\n      return;\n    }\n\n    // custom blending\n\n    blendEquationAlpha = blendEquationAlpha || blendEquation;\n    blendSrcAlpha = blendSrcAlpha || blendSrc;\n    blendDstAlpha = blendDstAlpha || blendDst;\n    if (blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha) {\n      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);\n      this.currentBlendEquation = blendEquation;\n      this.currentBlendEquationAlpha = blendEquationAlpha;\n    }\n    if (blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha) {\n      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);\n      this.currentBlendSrc = blendSrc;\n      this.currentBlendDst = blendDst;\n      this.currentBlendSrcAlpha = blendSrcAlpha;\n      this.currentBlendDstAlpha = blendDstAlpha;\n    }\n    this.currentBlending = blending;\n    this.currentPremultipledAlpha = false;\n  }\n  setColorMask(colorMask) {\n    if (this.currentColorMask !== colorMask) {\n      this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);\n      this.currentColorMask = colorMask;\n    }\n  }\n  setDepthTest(depthTest) {\n    const {\n      gl\n    } = this;\n    if (depthTest) {\n      this.enable(gl.DEPTH_TEST);\n    } else {\n      this.disable(gl.DEPTH_TEST);\n    }\n  }\n  setDepthMask(depthMask) {\n    if (this.currentDepthMask !== depthMask) {\n      this.gl.depthMask(depthMask);\n      this.currentDepthMask = depthMask;\n    }\n  }\n  setDepthFunc(depthFunc) {\n    if (this.currentDepthFunc !== depthFunc) {\n      const {\n        gl\n      } = this;\n      switch (depthFunc) {\n        case NeverDepth:\n          gl.depthFunc(gl.NEVER);\n          break;\n        case AlwaysDepth:\n          gl.depthFunc(gl.ALWAYS);\n          break;\n        case LessDepth:\n          gl.depthFunc(gl.LESS);\n          break;\n        case LessEqualDepth:\n          gl.depthFunc(gl.LEQUAL);\n          break;\n        case EqualDepth:\n          gl.depthFunc(gl.EQUAL);\n          break;\n        case GreaterEqualDepth:\n          gl.depthFunc(gl.GEQUAL);\n          break;\n        case GreaterDepth:\n          gl.depthFunc(gl.GREATER);\n          break;\n        case NotEqualDepth:\n          gl.depthFunc(gl.NOTEQUAL);\n          break;\n        default:\n          gl.depthFunc(gl.LEQUAL);\n      }\n      this.currentDepthFunc = depthFunc;\n    }\n  }\n  setStencilTest(stencilTest) {\n    const {\n      gl\n    } = this;\n    if (stencilTest) {\n      this.enable(gl.STENCIL_TEST);\n    } else {\n      this.disable(gl.STENCIL_TEST);\n    }\n  }\n  setStencilMask(stencilMask) {\n    if (this.currentStencilMask !== stencilMask) {\n      this.gl.stencilMask(stencilMask);\n      this.currentStencilMask = stencilMask;\n    }\n  }\n  setStencilFunc(stencilFunc, stencilRef, stencilMask) {\n    if (this.currentStencilFunc !== stencilFunc || this.currentStencilRef !== stencilRef || this.currentStencilFuncMask !== stencilMask) {\n      this.gl.stencilFunc(stencilFunc, stencilRef, stencilMask);\n      this.currentStencilFunc = stencilFunc;\n      this.currentStencilRef = stencilRef;\n      this.currentStencilFuncMask = stencilMask;\n    }\n  }\n  setStencilOp(stencilFail, stencilZFail, stencilZPass) {\n    if (this.currentStencilFail !== stencilFail || this.currentStencilZFail !== stencilZFail || this.currentStencilZPass !== stencilZPass) {\n      this.gl.stencilOp(stencilFail, stencilZFail, stencilZPass);\n      this.currentStencilFail = stencilFail;\n      this.currentStencilZFail = stencilZFail;\n      this.currentStencilZPass = stencilZPass;\n    }\n  }\n  setMaterial(material, frontFaceCW, hardwareClippingPlanes) {\n    const {\n      gl\n    } = this;\n    material.side === DoubleSide ? this.disable(gl.CULL_FACE) : this.enable(gl.CULL_FACE);\n    let flipSided = material.side === BackSide;\n    if (frontFaceCW) flipSided = !flipSided;\n    this.setFlipSided(flipSided);\n    material.blending === NormalBlending && material.transparent === false ? this.setBlending(NoBlending) : this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);\n    this.setDepthFunc(material.depthFunc);\n    this.setDepthTest(material.depthTest);\n    this.setDepthMask(material.depthWrite);\n    this.setColorMask(material.colorWrite);\n    const stencilWrite = material.stencilWrite;\n    this.setStencilTest(stencilWrite);\n    if (stencilWrite) {\n      this.setStencilMask(material.stencilWriteMask);\n      this.setStencilFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);\n      this.setStencilOp(material.stencilFail, material.stencilZFail, material.stencilZPass);\n    }\n    this.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n    material.alphaToCoverage === true && this.backend.renderer.samples > 1 ? this.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n    if (hardwareClippingPlanes > 0) {\n      if (this.currentClippingPlanes !== hardwareClippingPlanes) {\n        const CLIP_DISTANCE0_WEBGL = 0x3000;\n        for (let i = 0; i < 8; i++) {\n          if (i < hardwareClippingPlanes) {\n            this.enable(CLIP_DISTANCE0_WEBGL + i);\n          } else {\n            this.disable(CLIP_DISTANCE0_WEBGL + i);\n          }\n        }\n      }\n    }\n  }\n  setPolygonOffset(polygonOffset, factor, units) {\n    const {\n      gl\n    } = this;\n    if (polygonOffset) {\n      this.enable(gl.POLYGON_OFFSET_FILL);\n      if (this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units) {\n        gl.polygonOffset(factor, units);\n        this.currentPolygonOffsetFactor = factor;\n        this.currentPolygonOffsetUnits = units;\n      }\n    } else {\n      this.disable(gl.POLYGON_OFFSET_FILL);\n    }\n  }\n  useProgram(program) {\n    if (this.currentProgram !== program) {\n      this.gl.useProgram(program);\n      this.currentProgram = program;\n      return true;\n    }\n    return false;\n  }\n\n  // framebuffer\n\n  bindFramebuffer(target, framebuffer) {\n    const {\n      gl,\n      currentBoundFramebuffers\n    } = this;\n    if (currentBoundFramebuffers[target] !== framebuffer) {\n      gl.bindFramebuffer(target, framebuffer);\n      currentBoundFramebuffers[target] = framebuffer;\n\n      // gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\n      if (target === gl.DRAW_FRAMEBUFFER) {\n        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;\n      }\n      if (target === gl.FRAMEBUFFER) {\n        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;\n      }\n      return true;\n    }\n    return false;\n  }\n  drawBuffers(renderContext, framebuffer) {\n    const {\n      gl\n    } = this;\n    let drawBuffers = [];\n    let needsUpdate = false;\n    if (renderContext.textures !== null) {\n      drawBuffers = this.currentDrawbuffers.get(framebuffer);\n      if (drawBuffers === undefined) {\n        drawBuffers = [];\n        this.currentDrawbuffers.set(framebuffer, drawBuffers);\n      }\n      const textures = renderContext.textures;\n      if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {\n        for (let i = 0, il = textures.length; i < il; i++) {\n          drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;\n        }\n        drawBuffers.length = textures.length;\n        needsUpdate = true;\n      }\n    } else {\n      if (drawBuffers[0] !== gl.BACK) {\n        drawBuffers[0] = gl.BACK;\n        needsUpdate = true;\n      }\n    }\n    if (needsUpdate) {\n      gl.drawBuffers(drawBuffers);\n    }\n  }\n\n  // texture\n\n  activeTexture(webglSlot) {\n    const {\n      gl,\n      currentTextureSlot,\n      maxTextures\n    } = this;\n    if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n    if (currentTextureSlot !== webglSlot) {\n      gl.activeTexture(webglSlot);\n      this.currentTextureSlot = webglSlot;\n    }\n  }\n  bindTexture(webglType, webglTexture, webglSlot) {\n    const {\n      gl,\n      currentTextureSlot,\n      currentBoundTextures,\n      maxTextures\n    } = this;\n    if (webglSlot === undefined) {\n      if (currentTextureSlot === null) {\n        webglSlot = gl.TEXTURE0 + maxTextures - 1;\n      } else {\n        webglSlot = currentTextureSlot;\n      }\n    }\n    let boundTexture = currentBoundTextures[webglSlot];\n    if (boundTexture === undefined) {\n      boundTexture = {\n        type: undefined,\n        texture: undefined\n      };\n      currentBoundTextures[webglSlot] = boundTexture;\n    }\n    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {\n      if (currentTextureSlot !== webglSlot) {\n        gl.activeTexture(webglSlot);\n        this.currentTextureSlot = webglSlot;\n      }\n      gl.bindTexture(webglType, webglTexture);\n      boundTexture.type = webglType;\n      boundTexture.texture = webglTexture;\n    }\n  }\n  bindBufferBase(target, index, buffer) {\n    const {\n      gl\n    } = this;\n    const key = `${target}-${index}`;\n    if (this.currentBoundBufferBases[key] !== buffer) {\n      gl.bindBufferBase(target, index, buffer);\n      this.currentBoundBufferBases[key] = buffer;\n      return true;\n    }\n    return false;\n  }\n  unbindTexture() {\n    const {\n      gl,\n      currentTextureSlot,\n      currentBoundTextures\n    } = this;\n    const boundTexture = currentBoundTextures[currentTextureSlot];\n    if (boundTexture !== undefined && boundTexture.type !== undefined) {\n      gl.bindTexture(boundTexture.type, null);\n      boundTexture.type = undefined;\n      boundTexture.texture = undefined;\n    }\n  }\n}\nclass WebGLUtils {\n  constructor(backend) {\n    this.backend = backend;\n    this.gl = this.backend.gl;\n    this.extensions = backend.extensions;\n  }\n  convert(p) {\n    let colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NoColorSpace;\n    const {\n      gl,\n      extensions\n    } = this;\n    let extension;\n    if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;\n    if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;\n    if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;\n    if (p === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;\n    if (p === ByteType) return gl.BYTE;\n    if (p === ShortType) return gl.SHORT;\n    if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;\n    if (p === IntType) return gl.INT;\n    if (p === UnsignedIntType) return gl.UNSIGNED_INT;\n    if (p === FloatType) return gl.FLOAT;\n    if (p === HalfFloatType) {\n      return gl.HALF_FLOAT;\n    }\n    if (p === AlphaFormat) return gl.ALPHA;\n    if (p === RGBFormat) return gl.RGB;\n    if (p === RGBAFormat) return gl.RGBA;\n    if (p === LuminanceFormat) return gl.LUMINANCE;\n    if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;\n    if (p === DepthFormat) return gl.DEPTH_COMPONENT;\n    if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;\n\n    // WebGL2 formats.\n\n    if (p === RedFormat) return gl.RED;\n    if (p === RedIntegerFormat) return gl.RED_INTEGER;\n    if (p === RGFormat) return gl.RG;\n    if (p === RGIntegerFormat) return gl.RG_INTEGER;\n    if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;\n\n    // S3TC\n\n    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {\n      if (colorSpace === SRGBColorSpace) {\n        extension = extensions.get('WEBGL_compressed_texture_s3tc_srgb');\n        if (extension !== null) {\n          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n        } else {\n          return null;\n        }\n      } else {\n        extension = extensions.get('WEBGL_compressed_texture_s3tc');\n        if (extension !== null) {\n          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n        } else {\n          return null;\n        }\n      }\n    }\n\n    // PVRTC\n\n    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_pvrtc');\n      if (extension !== null) {\n        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n      } else {\n        return null;\n      }\n    }\n\n    // ETC\n\n    if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_etc');\n      if (extension !== null) {\n        if (p === RGB_ETC1_Format || p === RGB_ETC2_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;\n        if (p === RGBA_ETC2_EAC_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;\n      } else {\n        return null;\n      }\n    }\n\n    // ASTC\n\n    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_astc');\n      if (extension !== null) {\n        if (p === RGBA_ASTC_4x4_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n        if (p === RGBA_ASTC_5x4_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n        if (p === RGBA_ASTC_5x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n        if (p === RGBA_ASTC_6x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n        if (p === RGBA_ASTC_6x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n        if (p === RGBA_ASTC_8x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n        if (p === RGBA_ASTC_8x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n        if (p === RGBA_ASTC_8x8_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n        if (p === RGBA_ASTC_10x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n        if (p === RGBA_ASTC_10x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n        if (p === RGBA_ASTC_10x8_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n        if (p === RGBA_ASTC_10x10_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n        if (p === RGBA_ASTC_12x10_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n        if (p === RGBA_ASTC_12x12_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n      } else {\n        return null;\n      }\n    }\n\n    // BPTC\n\n    if (p === RGBA_BPTC_Format) {\n      extension = extensions.get('EXT_texture_compression_bptc');\n      if (extension !== null) {\n        if (p === RGBA_BPTC_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n      } else {\n        return null;\n      }\n    }\n\n    // RGTC\n\n    if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {\n      extension = extensions.get('EXT_texture_compression_rgtc');\n      if (extension !== null) {\n        if (p === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;\n        if (p === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n        if (p === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n        if (p === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n      } else {\n        return null;\n      }\n    }\n\n    //\n\n    if (p === UnsignedInt248Type) {\n      return gl.UNSIGNED_INT_24_8;\n    }\n\n    // if \"p\" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)\n\n    return gl[p] !== undefined ? gl[p] : null;\n  }\n  _clientWaitAsync() {\n    const {\n      gl\n    } = this;\n    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n    gl.flush();\n    return new Promise((resolve, reject) => {\n      function test() {\n        const res = gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0);\n        if (res === gl.WAIT_FAILED) {\n          gl.deleteSync(sync);\n          reject();\n          return;\n        }\n        if (res === gl.TIMEOUT_EXPIRED) {\n          requestAnimationFrame(test);\n          return;\n        }\n        gl.deleteSync(sync);\n        resolve();\n      }\n      test();\n    });\n  }\n}\nlet initialized = false,\n  wrappingToGL,\n  filterToGL,\n  compareToGL;\nclass WebGLTextureUtils {\n  constructor(backend) {\n    this.backend = backend;\n    this.gl = backend.gl;\n    this.extensions = backend.extensions;\n    this.defaultTextures = {};\n    if (initialized === false) {\n      this._init(this.gl);\n      initialized = true;\n    }\n  }\n  _init(gl) {\n    // Store only WebGL constants here.\n\n    wrappingToGL = {\n      [RepeatWrapping]: gl.REPEAT,\n      [ClampToEdgeWrapping]: gl.CLAMP_TO_EDGE,\n      [MirroredRepeatWrapping]: gl.MIRRORED_REPEAT\n    };\n    filterToGL = {\n      [NearestFilter]: gl.NEAREST,\n      [NearestMipmapNearestFilter]: gl.NEAREST_MIPMAP_NEAREST,\n      [NearestMipmapLinearFilter]: gl.NEAREST_MIPMAP_LINEAR,\n      [LinearFilter]: gl.LINEAR,\n      [LinearMipmapNearestFilter]: gl.LINEAR_MIPMAP_NEAREST,\n      [LinearMipmapLinearFilter]: gl.LINEAR_MIPMAP_LINEAR\n    };\n    compareToGL = {\n      [NeverCompare]: gl.NEVER,\n      [AlwaysCompare]: gl.ALWAYS,\n      [LessCompare]: gl.LESS,\n      [LessEqualCompare]: gl.LEQUAL,\n      [EqualCompare]: gl.EQUAL,\n      [GreaterEqualCompare]: gl.GEQUAL,\n      [GreaterCompare]: gl.GREATER,\n      [NotEqualCompare]: gl.NOTEQUAL\n    };\n  }\n  filterFallback(f) {\n    const {\n      gl\n    } = this;\n    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {\n      return gl.NEAREST;\n    }\n    return gl.LINEAR;\n  }\n  getGLTextureType(texture) {\n    const {\n      gl\n    } = this;\n    let glTextureType;\n    if (texture.isCubeTexture === true) {\n      glTextureType = gl.TEXTURE_CUBE_MAP;\n    } else if (texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true) {\n      glTextureType = gl.TEXTURE_2D_ARRAY;\n    } else if (texture.isData3DTexture === true) {\n      // TODO: isCompressed3DTexture, wait for #26642\n\n      glTextureType = gl.TEXTURE_3D;\n    } else {\n      glTextureType = gl.TEXTURE_2D;\n    }\n    return glTextureType;\n  }\n  getInternalFormat(internalFormatName, glFormat, glType, colorSpace) {\n    let forceLinearTransfer = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const {\n      gl,\n      extensions\n    } = this;\n    if (internalFormatName !== null) {\n      if (gl[internalFormatName] !== undefined) return gl[internalFormatName];\n      console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'');\n    }\n    let internalFormat = glFormat;\n    if (glFormat === gl.RED) {\n      if (glType === gl.FLOAT) internalFormat = gl.R32F;\n      if (glType === gl.HALF_FLOAT) internalFormat = gl.R16F;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;\n      if (glType === gl.BYTE) internalFormat = gl.R8I;\n      if (glType === gl.SHORT) internalFormat = gl.R16I;\n      if (glType === gl.INT) internalFormat = gl.R32I;\n    }\n    if (glFormat === gl.RED_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8UI;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16UI;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;\n      if (glType === gl.BYTE) internalFormat = gl.R8I;\n      if (glType === gl.SHORT) internalFormat = gl.R16I;\n      if (glType === gl.INT) internalFormat = gl.R32I;\n    }\n    if (glFormat === gl.RG) {\n      if (glType === gl.FLOAT) internalFormat = gl.RG32F;\n      if (glType === gl.HALF_FLOAT) internalFormat = gl.RG16F;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RG8I;\n      if (glType === gl.SHORT) internalFormat = gl.RG16I;\n      if (glType === gl.INT) internalFormat = gl.RG32I;\n    }\n    if (glFormat === gl.RG_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8UI;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16UI;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RG8I;\n      if (glType === gl.SHORT) internalFormat = gl.RG16I;\n      if (glType === gl.INT) internalFormat = gl.RG32I;\n    }\n    if (glFormat === gl.RGB) {\n      if (glType === gl.FLOAT) internalFormat = gl.RGB32F;\n      if (glType === gl.HALF_FLOAT) internalFormat = gl.RGB16F;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RGB8I;\n      if (glType === gl.SHORT) internalFormat = gl.RGB16I;\n      if (glType === gl.INT) internalFormat = gl.RGB32I;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = colorSpace === SRGBColorSpace && forceLinearTransfer === false ? gl.SRGB8 : gl.RGB8;\n      if (glType === gl.UNSIGNED_SHORT_5_6_5) internalFormat = gl.RGB565;\n      if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;\n      if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGB4;\n      if (glType === gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = gl.RGB9_E5;\n    }\n    if (glFormat === gl.RGB_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8UI;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16UI;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RGB8I;\n      if (glType === gl.SHORT) internalFormat = gl.RGB16I;\n      if (glType === gl.INT) internalFormat = gl.RGB32I;\n    }\n    if (glFormat === gl.RGBA) {\n      if (glType === gl.FLOAT) internalFormat = gl.RGBA32F;\n      if (glType === gl.HALF_FLOAT) internalFormat = gl.RGBA16F;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RGBA8I;\n      if (glType === gl.SHORT) internalFormat = gl.RGBA16I;\n      if (glType === gl.INT) internalFormat = gl.RGBA32I;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = colorSpace === SRGBColorSpace && forceLinearTransfer === false ? gl.SRGB8_ALPHA8 : gl.RGBA8;\n      if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGBA4;\n      if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;\n    }\n    if (glFormat === gl.RGBA_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8UI;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16UI;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RGBA8I;\n      if (glType === gl.SHORT) internalFormat = gl.RGBA16I;\n      if (glType === gl.INT) internalFormat = gl.RGBA32I;\n    }\n    if (glFormat === gl.DEPTH_COMPONENT) {\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.DEPTH24_STENCIL8;\n      if (glType === gl.FLOAT) internalFormat = gl.DEPTH_COMPONENT32F;\n    }\n    if (glFormat === gl.DEPTH_STENCIL) {\n      if (glType === gl.UNSIGNED_INT_24_8) internalFormat = gl.DEPTH24_STENCIL8;\n    }\n    if (internalFormat === gl.R16F || internalFormat === gl.R32F || internalFormat === gl.RG16F || internalFormat === gl.RG32F || internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F) {\n      extensions.get('EXT_color_buffer_float');\n    }\n    return internalFormat;\n  }\n  setTextureParameters(textureType, texture) {\n    const {\n      gl,\n      extensions,\n      backend\n    } = this;\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);\n    gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);\n    if (textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY) {\n      gl.texParameteri(textureType, gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);\n    }\n    gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);\n    const hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;\n\n    // follow WebGPU backend mapping for texture filtering\n    const minFilter = texture.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture.minFilter;\n    gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, filterToGL[minFilter]);\n    if (texture.compareFunction) {\n      gl.texParameteri(textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);\n      gl.texParameteri(textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);\n    }\n    if (extensions.has('EXT_texture_filter_anisotropic') === true) {\n      if (texture.magFilter === NearestFilter) return;\n      if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;\n      if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2\n\n      if (texture.anisotropy > 1) {\n        const extension = extensions.get('EXT_texture_filter_anisotropic');\n        gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, backend.getMaxAnisotropy()));\n      }\n    }\n  }\n  createDefaultTexture(texture) {\n    const {\n      gl,\n      backend,\n      defaultTextures\n    } = this;\n    const glTextureType = this.getGLTextureType(texture);\n    let textureGPU = defaultTextures[glTextureType];\n    if (textureGPU === undefined) {\n      textureGPU = gl.createTexture();\n      backend.state.bindTexture(glTextureType, textureGPU);\n      gl.texParameteri(glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n      // gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n      defaultTextures[glTextureType] = textureGPU;\n    }\n    backend.set(texture, {\n      textureGPU,\n      glTextureType,\n      isDefault: true\n    });\n  }\n  createTexture(texture, options) {\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      levels,\n      width,\n      height,\n      depth\n    } = options;\n    const glFormat = backend.utils.convert(texture.format, texture.colorSpace);\n    const glType = backend.utils.convert(texture.type);\n    const glInternalFormat = this.getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);\n    const textureGPU = gl.createTexture();\n    const glTextureType = this.getGLTextureType(texture);\n    backend.state.bindTexture(glTextureType, textureGPU);\n    this.setTextureParameters(glTextureType, texture);\n    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {\n      gl.texStorage3D(gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth);\n    } else if (texture.isData3DTexture) {\n      gl.texStorage3D(gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth);\n    } else if (!texture.isVideoTexture) {\n      gl.texStorage2D(glTextureType, levels, glInternalFormat, width, height);\n    }\n    backend.set(texture, {\n      textureGPU,\n      glTextureType,\n      glFormat,\n      glType,\n      glInternalFormat\n    });\n  }\n  copyBufferToTexture(buffer, texture) {\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      textureGPU,\n      glTextureType,\n      glFormat,\n      glType\n    } = backend.get(texture);\n    const {\n      width,\n      height\n    } = texture.source.data;\n    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, buffer);\n    backend.state.bindTexture(glTextureType, textureGPU);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, 0);\n    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);\n    backend.state.unbindTexture();\n    // debug\n    // const framebuffer = gl.createFramebuffer();\n    // gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );\n    // gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );\n\n    // const readout = new Float32Array( width * height * 4 );\n\n    // const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );\n    // const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );\n\n    // gl.readPixels( 0, 0, width, height, altFormat, altType, readout );\n    // gl.bindFramebuffer( gl.FRAMEBUFFER, null );\n    // console.log( readout );\n  }\n  updateTexture(texture, options) {\n    const {\n      gl\n    } = this;\n    const {\n      width,\n      height\n    } = options;\n    const {\n      textureGPU,\n      glTextureType,\n      glFormat,\n      glType,\n      glInternalFormat\n    } = this.backend.get(texture);\n    if (texture.isRenderTargetTexture || textureGPU === undefined /* unsupported texture format */) return;\n    const getImage = source => {\n      if (source.isDataTexture) {\n        return source.image.data;\n      } else if (typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap || source instanceof OffscreenCanvas) {\n        return source;\n      }\n      return source.data;\n    };\n    this.backend.state.bindTexture(glTextureType, textureGPU);\n    this.setTextureParameters(glTextureType, texture);\n    if (texture.isCompressedTexture) {\n      const mipmaps = texture.mipmaps;\n      const image = options.image;\n      for (let i = 0; i < mipmaps.length; i++) {\n        const mipmap = mipmaps[i];\n        if (texture.isCompressedArrayTexture) {\n          if (texture.format !== gl.RGBA) {\n            if (glFormat !== null) {\n              gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);\n            } else {\n              console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');\n            }\n          } else {\n            gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);\n          }\n        } else {\n          if (glFormat !== null) {\n            gl.compressedTexSubImage2D(gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);\n          } else {\n            console.warn('Unsupported compressed texture format');\n          }\n        }\n      }\n    } else if (texture.isCubeTexture) {\n      const images = options.images;\n      for (let i = 0; i < 6; i++) {\n        const image = getImage(images[i]);\n        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image);\n      }\n    } else if (texture.isDataArrayTexture) {\n      const image = options.image;\n      gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);\n    } else if (texture.isData3DTexture) {\n      const image = options.image;\n      gl.texSubImage3D(gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);\n    } else if (texture.isVideoTexture) {\n      texture.update();\n      gl.texImage2D(glTextureType, 0, glInternalFormat, glFormat, glType, options.image);\n    } else {\n      const image = getImage(options.image);\n      gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, image);\n    }\n  }\n  generateMipmaps(texture) {\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      textureGPU,\n      glTextureType\n    } = backend.get(texture);\n    backend.state.bindTexture(glTextureType, textureGPU);\n    gl.generateMipmap(glTextureType);\n  }\n  deallocateRenderBuffers(renderTarget) {\n    const {\n      gl,\n      backend\n    } = this;\n\n    // remove framebuffer reference\n    if (renderTarget) {\n      const renderContextData = backend.get(renderTarget);\n      renderContextData.renderBufferStorageSetup = undefined;\n      if (renderContextData.framebuffers) {\n        for (const cacheKey in renderContextData.framebuffers) {\n          gl.deleteFramebuffer(renderContextData.framebuffers[cacheKey]);\n        }\n        delete renderContextData.framebuffers;\n      }\n      if (renderContextData.depthRenderbuffer) {\n        gl.deleteRenderbuffer(renderContextData.depthRenderbuffer);\n        delete renderContextData.depthRenderbuffer;\n      }\n      if (renderContextData.stencilRenderbuffer) {\n        gl.deleteRenderbuffer(renderContextData.stencilRenderbuffer);\n        delete renderContextData.stencilRenderbuffer;\n      }\n      if (renderContextData.msaaFrameBuffer) {\n        gl.deleteFramebuffer(renderContextData.msaaFrameBuffer);\n        delete renderContextData.msaaFrameBuffer;\n      }\n      if (renderContextData.msaaRenderbuffers) {\n        for (let i = 0; i < renderContextData.msaaRenderbuffers.length; i++) {\n          gl.deleteRenderbuffer(renderContextData.msaaRenderbuffers[i]);\n        }\n        delete renderContextData.msaaRenderbuffers;\n      }\n    }\n  }\n  destroyTexture(texture) {\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      textureGPU,\n      renderTarget\n    } = backend.get(texture);\n    this.deallocateRenderBuffers(renderTarget);\n    gl.deleteTexture(textureGPU);\n    backend.delete(texture);\n  }\n  copyTextureToTexture(srcTexture, dstTexture) {\n    let srcRegion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let dstPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      state\n    } = this.backend;\n    const {\n      textureGPU: dstTextureGPU,\n      glTextureType,\n      glType,\n      glFormat\n    } = backend.get(dstTexture);\n    let width, height, minX, minY;\n    let dstX, dstY;\n    if (srcRegion !== null) {\n      width = srcRegion.max.x - srcRegion.min.x;\n      height = srcRegion.max.y - srcRegion.min.y;\n      minX = srcRegion.min.x;\n      minY = srcRegion.min.y;\n    } else {\n      width = srcTexture.image.width;\n      height = srcTexture.image.height;\n      minX = 0;\n      minY = 0;\n    }\n    if (dstPosition !== null) {\n      dstX = dstPosition.x;\n      dstY = dstPosition.y;\n    } else {\n      dstX = 0;\n      dstY = 0;\n    }\n    state.bindTexture(glTextureType, dstTextureGPU);\n\n    // As another texture upload may have changed pixelStorei\n    // parameters, make sure they are correct for the dstTexture\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n    const currentUnpackRowLen = gl.getParameter(gl.UNPACK_ROW_LENGTH);\n    const currentUnpackImageHeight = gl.getParameter(gl.UNPACK_IMAGE_HEIGHT);\n    const currentUnpackSkipPixels = gl.getParameter(gl.UNPACK_SKIP_PIXELS);\n    const currentUnpackSkipRows = gl.getParameter(gl.UNPACK_SKIP_ROWS);\n    const currentUnpackSkipImages = gl.getParameter(gl.UNPACK_SKIP_IMAGES);\n    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;\n    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, image.width);\n    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, image.height);\n    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, minX);\n    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, minY);\n    if (srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture) {\n      const srcTextureData = backend.get(srcTexture);\n      const dstTextureData = backend.get(dstTexture);\n      const srcRenderContextData = backend.get(srcTextureData.renderTarget);\n      const dstRenderContextData = backend.get(dstTextureData.renderTarget);\n      const srcFramebuffer = srcRenderContextData.framebuffers[srcTextureData.cacheKey];\n      const dstFramebuffer = dstRenderContextData.framebuffers[dstTextureData.cacheKey];\n      state.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFramebuffer);\n      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFramebuffer);\n      let mask = gl.COLOR_BUFFER_BIT;\n      if (srcTexture.isDepthTexture) mask = gl.DEPTH_BUFFER_BIT;\n      gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, mask, gl.NEAREST);\n      state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n    } else {\n      if (srcTexture.isDataTexture) {\n        gl.texSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data);\n      } else {\n        if (srcTexture.isCompressedTexture) {\n          gl.compressedTexSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data);\n        } else {\n          gl.texSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image);\n        }\n      }\n    }\n    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);\n    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);\n    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);\n    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);\n    gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);\n\n    // Generate mipmaps only when copying level 0\n    if (level === 0 && dstTexture.generateMipmaps) gl.generateMipmap(gl.TEXTURE_2D);\n    state.unbindTexture();\n  }\n  copyFramebufferToTexture(texture, renderContext, rectangle) {\n    const {\n      gl\n    } = this;\n    const {\n      state\n    } = this.backend;\n    const {\n      textureGPU\n    } = this.backend.get(texture);\n    const {\n      x,\n      y,\n      z: width,\n      w: height\n    } = rectangle;\n    const requireDrawFrameBuffer = texture.isDepthTexture === true || renderContext.renderTarget && renderContext.renderTarget.samples > 0;\n    const srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.gerDrawingBufferSize().y;\n    if (requireDrawFrameBuffer) {\n      const partial = x !== 0 || y !== 0;\n      let mask;\n      let attachment;\n      if (texture.isDepthTexture === true) {\n        mask = gl.DEPTH_BUFFER_BIT;\n        attachment = gl.DEPTH_ATTACHMENT;\n        if (renderContext.stencil) {\n          mask |= gl.STENCIL_BUFFER_BIT;\n        }\n      } else {\n        mask = gl.COLOR_BUFFER_BIT;\n        attachment = gl.COLOR_ATTACHMENT0;\n      }\n      if (partial) {\n        const renderTargetContextData = this.backend.get(renderContext.renderTarget);\n        const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];\n        const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);\n        state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);\n        const flippedY = srcHeight - y - height;\n        gl.blitFramebuffer(x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST);\n        state.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);\n        state.bindTexture(gl.TEXTURE_2D, textureGPU);\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height);\n        state.unbindTexture();\n      } else {\n        const fb = gl.createFramebuffer();\n        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);\n        gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0);\n        gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);\n        gl.deleteFramebuffer(fb);\n      }\n    } else {\n      state.bindTexture(gl.TEXTURE_2D, textureGPU);\n      gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height);\n      state.unbindTexture();\n    }\n    if (texture.generateMipmaps) this.generateMipmaps(texture);\n    this.backend._setFramebuffer(renderContext);\n  }\n\n  // Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n  setupRenderBufferStorage(renderbuffer, renderContext) {\n    const {\n      gl\n    } = this;\n    const renderTarget = renderContext.renderTarget;\n    const {\n      samples,\n      depthTexture,\n      depthBuffer,\n      stencilBuffer,\n      width,\n      height\n    } = renderTarget;\n    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n    if (depthBuffer && !stencilBuffer) {\n      let glInternalFormat = gl.DEPTH_COMPONENT24;\n      if (samples > 0) {\n        if (depthTexture && depthTexture.isDepthTexture) {\n          if (depthTexture.type === gl.FLOAT) {\n            glInternalFormat = gl.DEPTH_COMPONENT32F;\n          }\n        }\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, glInternalFormat, width, height);\n      } else {\n        gl.renderbufferStorage(gl.RENDERBUFFER, glInternalFormat, width, height);\n      }\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n    } else if (depthBuffer && stencilBuffer) {\n      if (samples > 0) {\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height);\n      } else {\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\n      }\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n    }\n  }\n  async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {\n    const {\n      backend,\n      gl\n    } = this;\n    const {\n      textureGPU,\n      glFormat,\n      glType\n    } = this.backend.get(texture);\n    const fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);\n    const target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;\n    gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0);\n    const typedArrayType = this._getTypedArrayType(glType);\n    const bytesPerTexel = this._getBytesPerTexel(glType, glFormat);\n    const elementCount = width * height;\n    const byteLength = elementCount * bytesPerTexel;\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);\n    gl.bufferData(gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ);\n    gl.readPixels(x, y, width, height, glFormat, glType, 0);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n    await backend.utils._clientWaitAsync();\n    const dstBuffer = new typedArrayType(byteLength / typedArrayType.BYTES_PER_ELEMENT);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);\n    gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dstBuffer);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n    gl.deleteFramebuffer(fb);\n    return dstBuffer;\n  }\n  _getTypedArrayType(glType) {\n    const {\n      gl\n    } = this;\n    if (glType === gl.UNSIGNED_BYTE) return Uint8Array;\n    if (glType === gl.UNSIGNED_SHORT_4_4_4_4) return Uint16Array;\n    if (glType === gl.UNSIGNED_SHORT_5_5_5_1) return Uint16Array;\n    if (glType === gl.UNSIGNED_SHORT_5_6_5) return Uint16Array;\n    if (glType === gl.UNSIGNED_SHORT) return Uint16Array;\n    if (glType === gl.UNSIGNED_INT) return Uint32Array;\n    if (glType === gl.HALF_FLOAT) return Uint16Array;\n    if (glType === gl.FLOAT) return Float32Array;\n    throw new Error(`Unsupported WebGL type: ${glType}`);\n  }\n  _getBytesPerTexel(glType, glFormat) {\n    const {\n      gl\n    } = this;\n    let bytesPerComponent = 0;\n    if (glType === gl.UNSIGNED_BYTE) bytesPerComponent = 1;\n    if (glType === gl.UNSIGNED_SHORT_4_4_4_4 || glType === gl.UNSIGNED_SHORT_5_5_5_1 || glType === gl.UNSIGNED_SHORT_5_6_5 || glType === gl.UNSIGNED_SHORT || glType === gl.HALF_FLOAT) bytesPerComponent = 2;\n    if (glType === gl.UNSIGNED_INT || glType === gl.FLOAT) bytesPerComponent = 4;\n    if (glFormat === gl.RGBA) return bytesPerComponent * 4;\n    if (glFormat === gl.RGB) return bytesPerComponent * 3;\n    if (glFormat === gl.ALPHA) return bytesPerComponent;\n  }\n}\nclass WebGLExtensions {\n  constructor(backend) {\n    this.backend = backend;\n    this.gl = this.backend.gl;\n    this.availableExtensions = this.gl.getSupportedExtensions();\n    this.extensions = {};\n  }\n  get(name) {\n    let extension = this.extensions[name];\n    if (extension === undefined) {\n      extension = this.gl.getExtension(name);\n      this.extensions[name] = extension;\n    }\n    return extension;\n  }\n  has(name) {\n    return this.availableExtensions.includes(name);\n  }\n}\nclass WebGLCapabilities {\n  constructor(backend) {\n    this.backend = backend;\n    this.maxAnisotropy = null;\n  }\n  getMaxAnisotropy() {\n    if (this.maxAnisotropy !== null) return this.maxAnisotropy;\n    const gl = this.backend.gl;\n    const extensions = this.backend.extensions;\n    if (extensions.has('EXT_texture_filter_anisotropic') === true) {\n      const extension = extensions.get('EXT_texture_filter_anisotropic');\n      this.maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n    } else {\n      this.maxAnisotropy = 0;\n    }\n    return this.maxAnisotropy;\n  }\n}\nconst GLFeatureName = {\n  'WEBGL_multi_draw': 'WEBGL_multi_draw',\n  'WEBGL_compressed_texture_astc': 'texture-compression-astc',\n  'WEBGL_compressed_texture_etc': 'texture-compression-etc2',\n  'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',\n  'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n  'WEBKIT_WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n  'WEBGL_compressed_texture_s3tc': 'texture-compression-bc',\n  'EXT_texture_compression_bptc': 'texture-compression-bptc',\n  'EXT_disjoint_timer_query_webgl2': 'timestamp-query'\n};\nclass WebGLBufferRenderer {\n  constructor(backend) {\n    this.gl = backend.gl;\n    this.extensions = backend.extensions;\n    this.info = backend.renderer.info;\n    this.mode = null;\n    this.index = 0;\n    this.type = null;\n    this.object = null;\n  }\n  render(start, count) {\n    const {\n      gl,\n      mode,\n      object,\n      type,\n      info,\n      index\n    } = this;\n    if (index !== 0) {\n      gl.drawElements(mode, count, type, start);\n    } else {\n      gl.drawArrays(mode, start, count);\n    }\n    info.update(object, count, mode, 1);\n  }\n  renderInstances(start, count, primcount) {\n    const {\n      gl,\n      mode,\n      type,\n      index,\n      object,\n      info\n    } = this;\n    if (primcount === 0) return;\n    if (index !== 0) {\n      gl.drawElementsInstanced(mode, count, type, start, primcount);\n    } else {\n      gl.drawArraysInstanced(mode, start, count, primcount);\n    }\n    info.update(object, count, mode, primcount);\n  }\n  renderMultiDraw(starts, counts, drawCount) {\n    const {\n      extensions,\n      mode,\n      object,\n      info\n    } = this;\n    if (drawCount === 0) return;\n    const extension = extensions.get('WEBGL_multi_draw');\n    if (extension === null) {\n      for (let i = 0; i < drawCount; i++) {\n        this.render(starts[i], counts[i]);\n      }\n    } else {\n      if (this.index !== 0) {\n        extension.multiDrawElementsWEBGL(mode, counts, 0, this.type, starts, 0, drawCount);\n      } else {\n        extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);\n      }\n      let elementCount = 0;\n      for (let i = 0; i < drawCount; i++) {\n        elementCount += counts[i];\n      }\n      info.update(object, elementCount, mode, 1);\n    }\n  }\n  renderMultiDrawInstances(starts, counts, drawCount, primcount) {\n    const {\n      extensions,\n      mode,\n      object,\n      info\n    } = this;\n    if (drawCount === 0) return;\n    const extension = extensions.get('WEBGL_multi_draw');\n    if (extension === null) {\n      for (let i = 0; i < drawCount; i++) {\n        this.renderInstances(starts[i], counts[i], primcount[i]);\n      }\n    } else {\n      if (this.index !== 0) {\n        extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount);\n      } else {\n        extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);\n      }\n      let elementCount = 0;\n      for (let i = 0; i < drawCount; i++) {\n        elementCount += counts[i] * primcount[i];\n      }\n      info.update(object, elementCount, mode, 1);\n    }\n  }\n\n  //\n}\n\n//\n\nclass WebGLBackend extends Backend {\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.isWebGLBackend = true;\n  }\n  init(renderer) {\n    super.init(renderer);\n\n    //\n\n    const parameters = this.parameters;\n    const glContext = parameters.context !== undefined ? parameters.context : renderer.domElement.getContext('webgl2');\n    function onContextLost(event) {\n      event.preventDefault();\n      const contextLossInfo = {\n        api: 'WebGL',\n        message: event.statusMessage || 'Unknown reason',\n        reason: null,\n        originalEvent: event\n      };\n      renderer.onDeviceLost(contextLossInfo);\n    }\n    this._onContextLost = onContextLost;\n    renderer.domElement.addEventListener('webglcontextlost', onContextLost, false);\n    this.gl = glContext;\n    this.extensions = new WebGLExtensions(this);\n    this.capabilities = new WebGLCapabilities(this);\n    this.attributeUtils = new WebGLAttributeUtils(this);\n    this.textureUtils = new WebGLTextureUtils(this);\n    this.bufferRenderer = new WebGLBufferRenderer(this);\n    this.state = new WebGLState(this);\n    this.utils = new WebGLUtils(this);\n    this.vaoCache = {};\n    this.transformFeedbackCache = {};\n    this.discard = false;\n    this.trackTimestamp = parameters.trackTimestamp === true;\n    this.extensions.get('EXT_color_buffer_float');\n    this.extensions.get('WEBGL_clip_cull_distance');\n    this.extensions.get('OES_texture_float_linear');\n    this.extensions.get('EXT_color_buffer_half_float');\n    this.extensions.get('WEBGL_multisampled_render_to_texture');\n    this.extensions.get('WEBGL_render_shared_exponent');\n    this.extensions.get('WEBGL_multi_draw');\n    this.disjoint = this.extensions.get('EXT_disjoint_timer_query_webgl2');\n    this.parallel = this.extensions.get('KHR_parallel_shader_compile');\n    this._knownBindings = new WeakSet();\n    this._currentContext = null;\n  }\n  get coordinateSystem() {\n    return WebGLCoordinateSystem;\n  }\n  async getArrayBufferAsync(attribute) {\n    return await this.attributeUtils.getArrayBufferAsync(attribute);\n  }\n  async waitForGPU() {\n    await this.utils._clientWaitAsync();\n  }\n  initTimestampQuery(renderContext) {\n    if (!this.disjoint || !this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (this.queryRunning) {\n      if (!renderContextData.queryQueue) renderContextData.queryQueue = [];\n      renderContextData.queryQueue.push(renderContext);\n      return;\n    }\n    if (renderContextData.activeQuery) {\n      this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT);\n      renderContextData.activeQuery = null;\n    }\n    renderContextData.activeQuery = this.gl.createQuery();\n    if (renderContextData.activeQuery !== null) {\n      this.gl.beginQuery(this.disjoint.TIME_ELAPSED_EXT, renderContextData.activeQuery);\n      this.queryRunning = true;\n    }\n  }\n\n  // timestamp utils\n\n  prepareTimestampBuffer(renderContext) {\n    if (!this.disjoint || !this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (renderContextData.activeQuery) {\n      this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT);\n      if (!renderContextData.gpuQueries) renderContextData.gpuQueries = [];\n      renderContextData.gpuQueries.push({\n        query: renderContextData.activeQuery\n      });\n      renderContextData.activeQuery = null;\n      this.queryRunning = false;\n      if (renderContextData.queryQueue && renderContextData.queryQueue.length > 0) {\n        const nextRenderContext = renderContextData.queryQueue.shift();\n        this.initTimestampQuery(nextRenderContext);\n      }\n    }\n  }\n  async resolveTimestampAsync(renderContext) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'render';\n    if (!this.disjoint || !this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (!renderContextData.gpuQueries) renderContextData.gpuQueries = [];\n    for (let i = 0; i < renderContextData.gpuQueries.length; i++) {\n      const queryInfo = renderContextData.gpuQueries[i];\n      const available = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE);\n      const disjoint = this.gl.getParameter(this.disjoint.GPU_DISJOINT_EXT);\n      if (available && !disjoint) {\n        const elapsed = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT);\n        const duration = Number(elapsed) / 1000000; // Convert nanoseconds to milliseconds\n        this.gl.deleteQuery(queryInfo.query);\n        renderContextData.gpuQueries.splice(i, 1); // Remove the processed query\n        i--;\n        this.renderer.info.updateTimestamp(type, duration);\n      }\n    }\n  }\n  getContext() {\n    return this.gl;\n  }\n  beginRender(renderContext) {\n    const {\n      gl\n    } = this;\n    const renderContextData = this.get(renderContext);\n\n    //\n\n    //\n\n    this.initTimestampQuery(renderContext);\n    renderContextData.previousContext = this._currentContext;\n    this._currentContext = renderContext;\n    this._setFramebuffer(renderContext);\n    this.clear(renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false);\n\n    //\n    if (renderContext.viewport) {\n      this.updateViewport(renderContext);\n    } else {\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    }\n    if (renderContext.scissor) {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = renderContext.scissorValue;\n      gl.scissor(x, renderContext.height - height - y, width, height);\n    }\n    const occlusionQueryCount = renderContext.occlusionQueryCount;\n    if (occlusionQueryCount > 0) {\n      // Get a reference to the array of objects with queries. The renderContextData property\n      // can be changed by another render pass before the async reading of all previous queries complete\n      renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;\n      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n      renderContextData.lastOcclusionObject = null;\n      renderContextData.occlusionQueries = new Array(occlusionQueryCount);\n      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);\n      renderContextData.occlusionQueryIndex = 0;\n    }\n  }\n  finishRender(renderContext) {\n    const {\n      gl,\n      state\n    } = this;\n    const renderContextData = this.get(renderContext);\n    const previousContext = renderContextData.previousContext;\n    const occlusionQueryCount = renderContext.occlusionQueryCount;\n    if (occlusionQueryCount > 0) {\n      if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {\n        gl.endQuery(gl.ANY_SAMPLES_PASSED);\n      }\n      this.resolveOccludedAsync(renderContext);\n    }\n    const textures = renderContext.textures;\n    if (textures !== null) {\n      for (let i = 0; i < textures.length; i++) {\n        const texture = textures[i];\n        if (texture.generateMipmaps) {\n          this.generateMipmaps(texture);\n        }\n      }\n    }\n    this._currentContext = previousContext;\n    if (renderContext.textures !== null && renderContext.renderTarget) {\n      const renderTargetContextData = this.get(renderContext.renderTarget);\n      const {\n        samples\n      } = renderContext.renderTarget;\n      if (samples > 0) {\n        const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];\n        const mask = gl.COLOR_BUFFER_BIT;\n        const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n        const textures = renderContext.textures;\n        state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);\n        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);\n        for (let i = 0; i < textures.length; i++) {\n          // TODO Add support for MRT\n\n          if (renderContext.scissor) {\n            const {\n              x,\n              y,\n              width,\n              height\n            } = renderContext.scissorValue;\n            const viewY = renderContext.height - height - y;\n            gl.blitFramebuffer(x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST);\n            gl.invalidateSubFramebuffer(gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray, x, viewY, width, height);\n          } else {\n            gl.blitFramebuffer(0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST);\n            gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray);\n          }\n        }\n      }\n    }\n    if (previousContext !== null) {\n      this._setFramebuffer(previousContext);\n      if (previousContext.viewport) {\n        this.updateViewport(previousContext);\n      } else {\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n      }\n    }\n    this.prepareTimestampBuffer(renderContext);\n  }\n  resolveOccludedAsync(renderContext) {\n    const renderContextData = this.get(renderContext);\n\n    // handle occlusion query results\n\n    const {\n      currentOcclusionQueries,\n      currentOcclusionQueryObjects\n    } = renderContextData;\n    if (currentOcclusionQueries && currentOcclusionQueryObjects) {\n      const occluded = new WeakSet();\n      const {\n        gl\n      } = this;\n      renderContextData.currentOcclusionQueryObjects = null;\n      renderContextData.currentOcclusionQueries = null;\n      const check = () => {\n        let completed = 0;\n\n        // check all queries and requeue as appropriate\n        for (let i = 0; i < currentOcclusionQueries.length; i++) {\n          const query = currentOcclusionQueries[i];\n          if (query === null) continue;\n          if (gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {\n            if (gl.getQueryParameter(query, gl.QUERY_RESULT) > 0) occluded.add(currentOcclusionQueryObjects[i]);\n            currentOcclusionQueries[i] = null;\n            gl.deleteQuery(query);\n            completed++;\n          }\n        }\n        if (completed < currentOcclusionQueries.length) {\n          requestAnimationFrame(check);\n        } else {\n          renderContextData.occluded = occluded;\n        }\n      };\n      check();\n    }\n  }\n  isOccluded(renderContext, object) {\n    const renderContextData = this.get(renderContext);\n    return renderContextData.occluded && renderContextData.occluded.has(object);\n  }\n  updateViewport(renderContext) {\n    const gl = this.gl;\n    const {\n      x,\n      y,\n      width,\n      height\n    } = renderContext.viewportValue;\n    gl.viewport(x, renderContext.height - height - y, width, height);\n  }\n  setScissorTest(boolean) {\n    const gl = this.gl;\n    if (boolean) {\n      gl.enable(gl.SCISSOR_TEST);\n    } else {\n      gl.disable(gl.SCISSOR_TEST);\n    }\n  }\n  clear(color, depth, stencil) {\n    let descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let setFrameBuffer = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    const {\n      gl\n    } = this;\n    if (descriptor === null) {\n      const clearColor = this.getClearColor();\n\n      // premultiply alpha\n\n      clearColor.r *= clearColor.a;\n      clearColor.g *= clearColor.a;\n      clearColor.b *= clearColor.a;\n      descriptor = {\n        textures: null,\n        clearColorValue: clearColor\n      };\n    }\n\n    //\n\n    let clear = 0;\n    if (color) clear |= gl.COLOR_BUFFER_BIT;\n    if (depth) clear |= gl.DEPTH_BUFFER_BIT;\n    if (stencil) clear |= gl.STENCIL_BUFFER_BIT;\n    if (clear !== 0) {\n      let clearColor;\n      if (descriptor.clearColorValue) {\n        clearColor = descriptor.clearColorValue;\n      } else {\n        clearColor = this.getClearColor();\n\n        // premultiply alpha\n\n        clearColor.r *= clearColor.a;\n        clearColor.g *= clearColor.a;\n        clearColor.b *= clearColor.a;\n      }\n      if (depth) this.state.setDepthMask(true);\n      if (descriptor.textures === null) {\n        gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);\n        gl.clear(clear);\n      } else {\n        if (setFrameBuffer) this._setFramebuffer(descriptor);\n        if (color) {\n          for (let i = 0; i < descriptor.textures.length; i++) {\n            gl.clearBufferfv(gl.COLOR, i, [clearColor.r, clearColor.g, clearColor.b, clearColor.a]);\n          }\n        }\n        if (depth && stencil) {\n          gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1, 0);\n        } else if (depth) {\n          gl.clearBufferfv(gl.DEPTH, 0, [1.0]);\n        } else if (stencil) {\n          gl.clearBufferiv(gl.STENCIL, 0, [0]);\n        }\n      }\n    }\n  }\n  beginCompute(computeGroup) {\n    const {\n      state,\n      gl\n    } = this;\n    state.bindFramebuffer(gl.FRAMEBUFFER, null);\n    this.initTimestampQuery(computeGroup);\n  }\n  compute(computeGroup, computeNode, bindings, pipeline) {\n    const {\n      state,\n      gl\n    } = this;\n    if (!this.discard) {\n      // required here to handle async behaviour of render.compute()\n      gl.enable(gl.RASTERIZER_DISCARD);\n      this.discard = true;\n    }\n    const {\n      programGPU,\n      transformBuffers,\n      attributes\n    } = this.get(pipeline);\n    const vaoKey = this._getVaoKey(null, attributes);\n    const vaoGPU = this.vaoCache[vaoKey];\n    if (vaoGPU === undefined) {\n      this._createVao(null, attributes);\n    } else {\n      gl.bindVertexArray(vaoGPU);\n    }\n    state.useProgram(programGPU);\n    this._bindUniforms(bindings);\n    const transformFeedbackGPU = this._getTransformFeedback(transformBuffers);\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);\n    gl.beginTransformFeedback(gl.POINTS);\n    if (attributes[0].isStorageInstancedBufferAttribute) {\n      gl.drawArraysInstanced(gl.POINTS, 0, 1, computeNode.count);\n    } else {\n      gl.drawArrays(gl.POINTS, 0, computeNode.count);\n    }\n    gl.endTransformFeedback();\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n\n    // switch active buffers\n\n    for (let i = 0; i < transformBuffers.length; i++) {\n      const dualAttributeData = transformBuffers[i];\n      if (dualAttributeData.pbo) {\n        this.textureUtils.copyBufferToTexture(dualAttributeData.transformBuffer, dualAttributeData.pbo);\n      }\n      dualAttributeData.switchBuffers();\n    }\n  }\n  finishCompute(computeGroup) {\n    const gl = this.gl;\n    this.discard = false;\n    gl.disable(gl.RASTERIZER_DISCARD);\n    this.prepareTimestampBuffer(computeGroup);\n    if (this._currentContext) {\n      this._setFramebuffer(this._currentContext);\n    }\n  }\n  draw(renderObject /*, info*/) {\n    const {\n      object,\n      pipeline,\n      material,\n      context,\n      hardwareClippingPlanes\n    } = renderObject;\n    const {\n      programGPU\n    } = this.get(pipeline);\n    const {\n      gl,\n      state\n    } = this;\n    const contextData = this.get(context);\n    const drawParams = renderObject.getDrawParameters();\n    if (drawParams === null) return;\n\n    //\n\n    this._bindUniforms(renderObject.getBindings());\n    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n    state.setMaterial(material, frontFaceCW, hardwareClippingPlanes);\n    state.useProgram(programGPU);\n\n    //\n\n    const renderObjectData = this.get(renderObject);\n    let vaoGPU = renderObjectData.staticVao;\n    if (vaoGPU === undefined || renderObjectData.geometryId !== renderObject.geometry.id) {\n      const vaoKey = this._getVaoKey(renderObject.getIndex(), renderObject.getAttributes());\n      vaoGPU = this.vaoCache[vaoKey];\n      if (vaoGPU === undefined) {\n        let staticVao;\n        ({\n          vaoGPU,\n          staticVao\n        } = this._createVao(renderObject.getIndex(), renderObject.getAttributes()));\n        if (staticVao) {\n          renderObjectData.staticVao = vaoGPU;\n          renderObjectData.geometryId = renderObject.geometry.id;\n        }\n      }\n    }\n    gl.bindVertexArray(vaoGPU);\n\n    //\n\n    const index = renderObject.getIndex();\n\n    //\n\n    const lastObject = contextData.lastOcclusionObject;\n    if (lastObject !== object && lastObject !== undefined) {\n      if (lastObject !== null && lastObject.occlusionTest === true) {\n        gl.endQuery(gl.ANY_SAMPLES_PASSED);\n        contextData.occlusionQueryIndex++;\n      }\n      if (object.occlusionTest === true) {\n        const query = gl.createQuery();\n        gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);\n        contextData.occlusionQueries[contextData.occlusionQueryIndex] = query;\n        contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] = object;\n      }\n      contextData.lastOcclusionObject = object;\n    }\n\n    //\n    const renderer = this.bufferRenderer;\n    if (object.isPoints) renderer.mode = gl.POINTS;else if (object.isLineSegments) renderer.mode = gl.LINES;else if (object.isLine) renderer.mode = gl.LINE_STRIP;else if (object.isLineLoop) renderer.mode = gl.LINE_LOOP;else {\n      if (material.wireframe === true) {\n        state.setLineWidth(material.wireframeLinewidth * this.renderer.getPixelRatio());\n        renderer.mode = gl.LINES;\n      } else {\n        renderer.mode = gl.TRIANGLES;\n      }\n    }\n\n    //\n\n    const {\n      vertexCount,\n      instanceCount\n    } = drawParams;\n    let {\n      firstVertex\n    } = drawParams;\n    renderer.object = object;\n    if (index !== null) {\n      firstVertex *= index.array.BYTES_PER_ELEMENT;\n      const indexData = this.get(index);\n      renderer.index = index.count;\n      renderer.type = indexData.type;\n    } else {\n      renderer.index = 0;\n    }\n    if (object.isBatchedMesh) {\n      if (object._multiDrawInstances !== null) {\n        renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);\n      } else if (!this.hasFeature('WEBGL_multi_draw')) {\n        warnOnce('THREE.WebGLRenderer: WEBGL_multi_draw not supported.');\n      } else {\n        renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);\n      }\n    } else if (instanceCount > 1) {\n      renderer.renderInstances(firstVertex, vertexCount, instanceCount);\n    } else {\n      renderer.render(firstVertex, vertexCount);\n    }\n    //\n\n    gl.bindVertexArray(null);\n  }\n  needsRenderUpdate(/*renderObject*/\n  ) {\n    return false;\n  }\n  getRenderCacheKey(/*renderObject*/\n  ) {\n    return '';\n  }\n\n  // textures\n\n  createDefaultTexture(texture) {\n    this.textureUtils.createDefaultTexture(texture);\n  }\n  createTexture(texture, options) {\n    this.textureUtils.createTexture(texture, options);\n  }\n  updateTexture(texture, options) {\n    this.textureUtils.updateTexture(texture, options);\n  }\n  generateMipmaps(texture) {\n    this.textureUtils.generateMipmaps(texture);\n  }\n  destroyTexture(texture) {\n    this.textureUtils.destroyTexture(texture);\n  }\n  copyTextureToBuffer(texture, x, y, width, height, faceIndex) {\n    return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);\n  }\n  createSampler(/*texture*/\n  ) {\n\n    //console.warn( 'Abstract class.' );\n  }\n  destroySampler() {}\n\n  // node builder\n\n  createNodeBuilder(object, renderer) {\n    return new GLSLNodeBuilder(object, renderer);\n  }\n\n  // program\n\n  createProgram(program) {\n    const gl = this.gl;\n    const {\n      stage,\n      code\n    } = program;\n    const shader = stage === 'fragment' ? gl.createShader(gl.FRAGMENT_SHADER) : gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(shader, code);\n    gl.compileShader(shader);\n    this.set(program, {\n      shaderGPU: shader\n    });\n  }\n  destroyProgram(/*program*/\n  ) {\n    console.warn('Abstract class.');\n  }\n  createRenderPipeline(renderObject, promises) {\n    const gl = this.gl;\n    const pipeline = renderObject.pipeline;\n\n    // Program\n\n    const {\n      fragmentProgram,\n      vertexProgram\n    } = pipeline;\n    const programGPU = gl.createProgram();\n    const fragmentShader = this.get(fragmentProgram).shaderGPU;\n    const vertexShader = this.get(vertexProgram).shaderGPU;\n    gl.attachShader(programGPU, fragmentShader);\n    gl.attachShader(programGPU, vertexShader);\n    gl.linkProgram(programGPU);\n    this.set(pipeline, {\n      programGPU,\n      fragmentShader,\n      vertexShader\n    });\n    if (promises !== null && this.parallel) {\n      const p = new Promise((resolve /*, reject*/) => {\n        const parallel = this.parallel;\n        const checkStatus = () => {\n          if (gl.getProgramParameter(programGPU, parallel.COMPLETION_STATUS_KHR)) {\n            this._completeCompile(renderObject, pipeline);\n            resolve();\n          } else {\n            requestAnimationFrame(checkStatus);\n          }\n        };\n        checkStatus();\n      });\n      promises.push(p);\n      return;\n    }\n    this._completeCompile(renderObject, pipeline);\n  }\n  _handleSource(string, errorLine) {\n    const lines = string.split('\\n');\n    const lines2 = [];\n    const from = Math.max(errorLine - 6, 0);\n    const to = Math.min(errorLine + 6, lines.length);\n    for (let i = from; i < to; i++) {\n      const line = i + 1;\n      lines2.push(`${line === errorLine ? '>' : ' '} ${line}: ${lines[i]}`);\n    }\n    return lines2.join('\\n');\n  }\n  _getShaderErrors(gl, shader, type) {\n    const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    const errors = gl.getShaderInfoLog(shader).trim();\n    if (status && errors === '') return '';\n    const errorMatches = /ERROR: 0:(\\d+)/.exec(errors);\n    if (errorMatches) {\n      const errorLine = parseInt(errorMatches[1]);\n      return type.toUpperCase() + '\\n\\n' + errors + '\\n\\n' + this._handleSource(gl.getShaderSource(shader), errorLine);\n    } else {\n      return errors;\n    }\n  }\n  _logProgramError(programGPU, glFragmentShader, glVertexShader) {\n    if (this.renderer.debug.checkShaderErrors) {\n      const gl = this.gl;\n      const programLog = gl.getProgramInfoLog(programGPU).trim();\n      if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {\n        if (typeof this.renderer.debug.onShaderError === 'function') {\n          this.renderer.debug.onShaderError(gl, programGPU, glVertexShader, glFragmentShader);\n        } else {\n          // default error reporting\n\n          const vertexErrors = this._getShaderErrors(gl, glVertexShader, 'vertex');\n          const fragmentErrors = this._getShaderErrors(gl, glFragmentShader, 'fragment');\n          console.error('THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' + 'VALIDATE_STATUS ' + gl.getProgramParameter(programGPU, gl.VALIDATE_STATUS) + '\\n\\n' + 'Program Info Log: ' + programLog + '\\n' + vertexErrors + '\\n' + fragmentErrors);\n        }\n      } else if (programLog !== '') {\n        console.warn('THREE.WebGLProgram: Program Info Log:', programLog);\n      }\n    }\n  }\n  _completeCompile(renderObject, pipeline) {\n    const {\n      state,\n      gl\n    } = this;\n    const pipelineData = this.get(pipeline);\n    const {\n      programGPU,\n      fragmentShader,\n      vertexShader\n    } = pipelineData;\n    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {\n      this._logProgramError(programGPU, fragmentShader, vertexShader);\n    }\n    state.useProgram(programGPU);\n\n    // Bindings\n\n    const bindings = renderObject.getBindings();\n    this._setupBindings(bindings, programGPU);\n\n    //\n\n    this.set(pipeline, {\n      programGPU\n    });\n  }\n  createComputePipeline(computePipeline, bindings) {\n    const {\n      state,\n      gl\n    } = this;\n\n    // Program\n\n    const fragmentProgram = {\n      stage: 'fragment',\n      code: '#version 300 es\\nprecision highp float;\\nvoid main() {}'\n    };\n    this.createProgram(fragmentProgram);\n    const {\n      computeProgram\n    } = computePipeline;\n    const programGPU = gl.createProgram();\n    const fragmentShader = this.get(fragmentProgram).shaderGPU;\n    const vertexShader = this.get(computeProgram).shaderGPU;\n    const transforms = computeProgram.transforms;\n    const transformVaryingNames = [];\n    const transformAttributeNodes = [];\n    for (let i = 0; i < transforms.length; i++) {\n      const transform = transforms[i];\n      transformVaryingNames.push(transform.varyingName);\n      transformAttributeNodes.push(transform.attributeNode);\n    }\n    gl.attachShader(programGPU, fragmentShader);\n    gl.attachShader(programGPU, vertexShader);\n    gl.transformFeedbackVaryings(programGPU, transformVaryingNames, gl.SEPARATE_ATTRIBS);\n    gl.linkProgram(programGPU);\n    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {\n      this._logProgramError(programGPU, fragmentShader, vertexShader);\n    }\n    state.useProgram(programGPU);\n\n    // Bindings\n\n    this._setupBindings(bindings, programGPU);\n    const attributeNodes = computeProgram.attributes;\n    const attributes = [];\n    const transformBuffers = [];\n    for (let i = 0; i < attributeNodes.length; i++) {\n      const attribute = attributeNodes[i].node.attribute;\n      attributes.push(attribute);\n      if (!this.has(attribute)) this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);\n    }\n    for (let i = 0; i < transformAttributeNodes.length; i++) {\n      const attribute = transformAttributeNodes[i].attribute;\n      if (!this.has(attribute)) this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);\n      const attributeData = this.get(attribute);\n      transformBuffers.push(attributeData);\n    }\n\n    //\n\n    this.set(computePipeline, {\n      programGPU,\n      transformBuffers,\n      attributes\n    });\n  }\n  createBindings(bindGroup, bindings) {\n    if (this._knownBindings.has(bindings) === false) {\n      this._knownBindings.add(bindings);\n      let uniformBuffers = 0;\n      let textures = 0;\n      for (const bindGroup of bindings) {\n        this.set(bindGroup, {\n          textures: textures,\n          uniformBuffers: uniformBuffers\n        });\n        for (const binding of bindGroup.bindings) {\n          if (binding.isUniformBuffer) uniformBuffers++;\n          if (binding.isSampledTexture) textures++;\n        }\n      }\n    }\n    this.updateBindings(bindGroup, bindings);\n  }\n  updateBindings(bindGroup /*, bindings*/) {\n    const {\n      gl\n    } = this;\n    const bindGroupData = this.get(bindGroup);\n    let i = bindGroupData.uniformBuffers;\n    let t = bindGroupData.textures;\n    for (const binding of bindGroup.bindings) {\n      if (binding.isUniformsGroup || binding.isUniformBuffer) {\n        const data = binding.buffer;\n        const bufferGPU = gl.createBuffer();\n        gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);\n        gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);\n        this.set(binding, {\n          index: i++,\n          bufferGPU\n        });\n      } else if (binding.isSampledTexture) {\n        const {\n          textureGPU,\n          glTextureType\n        } = this.get(binding.texture);\n        this.set(binding, {\n          index: t++,\n          textureGPU,\n          glTextureType\n        });\n      }\n    }\n  }\n  updateBinding(binding) {\n    const gl = this.gl;\n    if (binding.isUniformsGroup || binding.isUniformBuffer) {\n      const bindingData = this.get(binding);\n      const bufferGPU = bindingData.bufferGPU;\n      const data = binding.buffer;\n      gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);\n      gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);\n    }\n  }\n\n  // attributes\n\n  createIndexAttribute(attribute) {\n    const gl = this.gl;\n    this.attributeUtils.createAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);\n  }\n  createAttribute(attribute) {\n    if (this.has(attribute)) return;\n    const gl = this.gl;\n    this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);\n  }\n  createStorageAttribute(attribute) {\n    if (this.has(attribute)) return;\n    const gl = this.gl;\n    this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);\n  }\n  updateAttribute(attribute) {\n    this.attributeUtils.updateAttribute(attribute);\n  }\n  destroyAttribute(attribute) {\n    this.attributeUtils.destroyAttribute(attribute);\n  }\n  updateSize() {\n\n    //console.warn( 'Abstract class.' );\n  }\n  hasFeature(name) {\n    const keysMatching = Object.keys(GLFeatureName).filter(key => GLFeatureName[key] === name);\n    const extensions = this.extensions;\n    for (let i = 0; i < keysMatching.length; i++) {\n      if (extensions.has(keysMatching[i])) return true;\n    }\n    return false;\n  }\n  getMaxAnisotropy() {\n    return this.capabilities.getMaxAnisotropy();\n  }\n  copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level) {\n    this.textureUtils.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);\n  }\n  copyFramebufferToTexture(texture, renderContext, rectangle) {\n    this.textureUtils.copyFramebufferToTexture(texture, renderContext, rectangle);\n  }\n  _setFramebuffer(descriptor) {\n    const {\n      gl,\n      state\n    } = this;\n    let currentFrameBuffer = null;\n    if (descriptor.textures !== null) {\n      const renderTarget = descriptor.renderTarget;\n      const renderTargetContextData = this.get(renderTarget);\n      const {\n        samples,\n        depthBuffer,\n        stencilBuffer\n      } = renderTarget;\n      const isCube = renderTarget.isWebGLCubeRenderTarget === true;\n      let msaaFb = renderTargetContextData.msaaFrameBuffer;\n      let depthRenderbuffer = renderTargetContextData.depthRenderbuffer;\n      const cacheKey = getCacheKey(descriptor);\n      let fb;\n      if (isCube) {\n        renderTargetContextData.cubeFramebuffers || (renderTargetContextData.cubeFramebuffers = {});\n        fb = renderTargetContextData.cubeFramebuffers[cacheKey];\n      } else {\n        renderTargetContextData.framebuffers || (renderTargetContextData.framebuffers = {});\n        fb = renderTargetContextData.framebuffers[cacheKey];\n      }\n      if (fb === undefined) {\n        fb = gl.createFramebuffer();\n        state.bindFramebuffer(gl.FRAMEBUFFER, fb);\n        const textures = descriptor.textures;\n        if (isCube) {\n          renderTargetContextData.cubeFramebuffers[cacheKey] = fb;\n          const {\n            textureGPU\n          } = this.get(textures[0]);\n          const cubeFace = this.renderer._activeCubeFace;\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0);\n        } else {\n          renderTargetContextData.framebuffers[cacheKey] = fb;\n          for (let i = 0; i < textures.length; i++) {\n            const texture = textures[i];\n            const textureData = this.get(texture);\n            textureData.renderTarget = descriptor.renderTarget;\n            textureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n            const attachment = gl.COLOR_ATTACHMENT0 + i;\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0);\n          }\n          state.drawBuffers(descriptor, fb);\n        }\n        if (descriptor.depthTexture !== null) {\n          const textureData = this.get(descriptor.depthTexture);\n          const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n          textureData.renderTarget = descriptor.renderTarget;\n          textureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0);\n        }\n      }\n      if (samples > 0) {\n        if (msaaFb === undefined) {\n          const invalidationArray = [];\n          msaaFb = gl.createFramebuffer();\n          state.bindFramebuffer(gl.FRAMEBUFFER, msaaFb);\n          const msaaRenderbuffers = [];\n          const textures = descriptor.textures;\n          for (let i = 0; i < textures.length; i++) {\n            msaaRenderbuffers[i] = gl.createRenderbuffer();\n            gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderbuffers[i]);\n            invalidationArray.push(gl.COLOR_ATTACHMENT0 + i);\n            if (depthBuffer) {\n              const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n              invalidationArray.push(depthStyle);\n            }\n            const texture = descriptor.textures[i];\n            const textureData = this.get(texture);\n            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height);\n            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[i]);\n          }\n          renderTargetContextData.msaaFrameBuffer = msaaFb;\n          renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;\n          if (depthRenderbuffer === undefined) {\n            depthRenderbuffer = gl.createRenderbuffer();\n            this.textureUtils.setupRenderBufferStorage(depthRenderbuffer, descriptor);\n            renderTargetContextData.depthRenderbuffer = depthRenderbuffer;\n            const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n            invalidationArray.push(depthStyle);\n          }\n          renderTargetContextData.invalidationArray = invalidationArray;\n        }\n        currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n      } else {\n        currentFrameBuffer = fb;\n      }\n    }\n    state.bindFramebuffer(gl.FRAMEBUFFER, currentFrameBuffer);\n  }\n  _getVaoKey(index, attributes) {\n    let key = [];\n    if (index !== null) {\n      const indexData = this.get(index);\n      key += ':' + indexData.id;\n    }\n    for (let i = 0; i < attributes.length; i++) {\n      const attributeData = this.get(attributes[i]);\n      key += ':' + attributeData.id;\n    }\n    return key;\n  }\n  _createVao(index, attributes) {\n    const {\n      gl\n    } = this;\n    const vaoGPU = gl.createVertexArray();\n    let key = '';\n    let staticVao = true;\n    gl.bindVertexArray(vaoGPU);\n    if (index !== null) {\n      const indexData = this.get(index);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexData.bufferGPU);\n      key += ':' + indexData.id;\n    }\n    for (let i = 0; i < attributes.length; i++) {\n      const attribute = attributes[i];\n      const attributeData = this.get(attribute);\n      key += ':' + attributeData.id;\n      gl.bindBuffer(gl.ARRAY_BUFFER, attributeData.bufferGPU);\n      gl.enableVertexAttribArray(i);\n      if (attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute) staticVao = false;\n      let stride, offset;\n      if (attribute.isInterleavedBufferAttribute === true) {\n        stride = attribute.data.stride * attributeData.bytesPerElement;\n        offset = attribute.offset * attributeData.bytesPerElement;\n      } else {\n        stride = 0;\n        offset = 0;\n      }\n      if (attributeData.isInteger) {\n        gl.vertexAttribIPointer(i, attribute.itemSize, attributeData.type, stride, offset);\n      } else {\n        gl.vertexAttribPointer(i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset);\n      }\n      if (attribute.isInstancedBufferAttribute && !attribute.isInterleavedBufferAttribute) {\n        gl.vertexAttribDivisor(i, attribute.meshPerAttribute);\n      } else if (attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer) {\n        gl.vertexAttribDivisor(i, attribute.data.meshPerAttribute);\n      }\n    }\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    this.vaoCache[key] = vaoGPU;\n    return {\n      vaoGPU,\n      staticVao\n    };\n  }\n  _getTransformFeedback(transformBuffers) {\n    let key = '';\n    for (let i = 0; i < transformBuffers.length; i++) {\n      key += ':' + transformBuffers[i].id;\n    }\n    let transformFeedbackGPU = this.transformFeedbackCache[key];\n    if (transformFeedbackGPU !== undefined) {\n      return transformFeedbackGPU;\n    }\n    const {\n      gl\n    } = this;\n    transformFeedbackGPU = gl.createTransformFeedback();\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);\n    for (let i = 0; i < transformBuffers.length; i++) {\n      const attributeData = transformBuffers[i];\n      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer);\n    }\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n    this.transformFeedbackCache[key] = transformFeedbackGPU;\n    return transformFeedbackGPU;\n  }\n  _setupBindings(bindings, programGPU) {\n    const gl = this.gl;\n    for (const bindGroup of bindings) {\n      for (const binding of bindGroup.bindings) {\n        const bindingData = this.get(binding);\n        const index = bindingData.index;\n        if (binding.isUniformsGroup || binding.isUniformBuffer) {\n          const location = gl.getUniformBlockIndex(programGPU, binding.name);\n          gl.uniformBlockBinding(programGPU, location, index);\n        } else if (binding.isSampledTexture) {\n          const location = gl.getUniformLocation(programGPU, binding.name);\n          gl.uniform1i(location, index);\n        }\n      }\n    }\n  }\n  _bindUniforms(bindings) {\n    const {\n      gl,\n      state\n    } = this;\n    for (const bindGroup of bindings) {\n      for (const binding of bindGroup.bindings) {\n        const bindingData = this.get(binding);\n        const index = bindingData.index;\n        if (binding.isUniformsGroup || binding.isUniformBuffer) {\n          // TODO USE bindBufferRange to group multiple uniform buffers\n          state.bindBufferBase(gl.UNIFORM_BUFFER, index, bindingData.bufferGPU);\n        } else if (binding.isSampledTexture) {\n          state.bindTexture(bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index);\n        }\n      }\n    }\n  }\n  dispose() {\n    this.renderer.domElement.removeEventListener('webglcontextlost', this._onContextLost);\n  }\n}\nconst GPUPrimitiveTopology = {\n  PointList: 'point-list',\n  LineList: 'line-list',\n  LineStrip: 'line-strip',\n  TriangleList: 'triangle-list',\n  TriangleStrip: 'triangle-strip'\n};\nconst GPUCompareFunction = {\n  Never: 'never',\n  Less: 'less',\n  Equal: 'equal',\n  LessEqual: 'less-equal',\n  Greater: 'greater',\n  NotEqual: 'not-equal',\n  GreaterEqual: 'greater-equal',\n  Always: 'always'\n};\nconst GPUStoreOp = {\n  Store: 'store',\n  Discard: 'discard'\n};\nconst GPULoadOp = {\n  Load: 'load',\n  Clear: 'clear'\n};\nconst GPUFrontFace = {\n  CCW: 'ccw',\n  CW: 'cw'\n};\nconst GPUCullMode = {\n  None: 'none',\n  Front: 'front',\n  Back: 'back'\n};\nconst GPUIndexFormat = {\n  Uint16: 'uint16',\n  Uint32: 'uint32'\n};\nconst GPUTextureFormat = {\n  // 8-bit formats\n\n  R8Unorm: 'r8unorm',\n  R8Snorm: 'r8snorm',\n  R8Uint: 'r8uint',\n  R8Sint: 'r8sint',\n  // 16-bit formats\n\n  R16Uint: 'r16uint',\n  R16Sint: 'r16sint',\n  R16Float: 'r16float',\n  RG8Unorm: 'rg8unorm',\n  RG8Snorm: 'rg8snorm',\n  RG8Uint: 'rg8uint',\n  RG8Sint: 'rg8sint',\n  // 32-bit formats\n\n  R32Uint: 'r32uint',\n  R32Sint: 'r32sint',\n  R32Float: 'r32float',\n  RG16Uint: 'rg16uint',\n  RG16Sint: 'rg16sint',\n  RG16Float: 'rg16float',\n  RGBA8Unorm: 'rgba8unorm',\n  RGBA8UnormSRGB: 'rgba8unorm-srgb',\n  RGBA8Snorm: 'rgba8snorm',\n  RGBA8Uint: 'rgba8uint',\n  RGBA8Sint: 'rgba8sint',\n  BGRA8Unorm: 'bgra8unorm',\n  BGRA8UnormSRGB: 'bgra8unorm-srgb',\n  // Packed 32-bit formats\n  RGB9E5UFloat: 'rgb9e5ufloat',\n  RGB10A2Unorm: 'rgb10a2unorm',\n  RG11B10uFloat: 'rgb10a2unorm',\n  // 64-bit formats\n\n  RG32Uint: 'rg32uint',\n  RG32Sint: 'rg32sint',\n  RG32Float: 'rg32float',\n  RGBA16Uint: 'rgba16uint',\n  RGBA16Sint: 'rgba16sint',\n  RGBA16Float: 'rgba16float',\n  // 128-bit formats\n\n  RGBA32Uint: 'rgba32uint',\n  RGBA32Sint: 'rgba32sint',\n  RGBA32Float: 'rgba32float',\n  // Depth and stencil formats\n\n  Stencil8: 'stencil8',\n  Depth16Unorm: 'depth16unorm',\n  Depth24Plus: 'depth24plus',\n  Depth24PlusStencil8: 'depth24plus-stencil8',\n  Depth32Float: 'depth32float',\n  // 'depth32float-stencil8' extension\n\n  Depth32FloatStencil8: 'depth32float-stencil8',\n  // BC compressed formats usable if 'texture-compression-bc' is both\n  // supported by the device/user agent and enabled in requestDevice.\n\n  BC1RGBAUnorm: 'bc1-rgba-unorm',\n  BC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',\n  BC2RGBAUnorm: 'bc2-rgba-unorm',\n  BC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',\n  BC3RGBAUnorm: 'bc3-rgba-unorm',\n  BC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',\n  BC4RUnorm: 'bc4-r-unorm',\n  BC4RSnorm: 'bc4-r-snorm',\n  BC5RGUnorm: 'bc5-rg-unorm',\n  BC5RGSnorm: 'bc5-rg-snorm',\n  BC6HRGBUFloat: 'bc6h-rgb-ufloat',\n  BC6HRGBFloat: 'bc6h-rgb-float',\n  BC7RGBAUnorm: 'bc7-rgba-unorm',\n  BC7RGBAUnormSRGB: 'bc7-rgba-srgb',\n  // ETC2 compressed formats usable if 'texture-compression-etc2' is both\n  // supported by the device/user agent and enabled in requestDevice.\n\n  ETC2RGB8Unorm: 'etc2-rgb8unorm',\n  ETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',\n  ETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',\n  ETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',\n  ETC2RGBA8Unorm: 'etc2-rgba8unorm',\n  ETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',\n  EACR11Unorm: 'eac-r11unorm',\n  EACR11Snorm: 'eac-r11snorm',\n  EACRG11Unorm: 'eac-rg11unorm',\n  EACRG11Snorm: 'eac-rg11snorm',\n  // ASTC compressed formats usable if 'texture-compression-astc' is both\n  // supported by the device/user agent and enabled in requestDevice.\n\n  ASTC4x4Unorm: 'astc-4x4-unorm',\n  ASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',\n  ASTC5x4Unorm: 'astc-5x4-unorm',\n  ASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',\n  ASTC5x5Unorm: 'astc-5x5-unorm',\n  ASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',\n  ASTC6x5Unorm: 'astc-6x5-unorm',\n  ASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',\n  ASTC6x6Unorm: 'astc-6x6-unorm',\n  ASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',\n  ASTC8x5Unorm: 'astc-8x5-unorm',\n  ASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',\n  ASTC8x6Unorm: 'astc-8x6-unorm',\n  ASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',\n  ASTC8x8Unorm: 'astc-8x8-unorm',\n  ASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',\n  ASTC10x5Unorm: 'astc-10x5-unorm',\n  ASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',\n  ASTC10x6Unorm: 'astc-10x6-unorm',\n  ASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',\n  ASTC10x8Unorm: 'astc-10x8-unorm',\n  ASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',\n  ASTC10x10Unorm: 'astc-10x10-unorm',\n  ASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',\n  ASTC12x10Unorm: 'astc-12x10-unorm',\n  ASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',\n  ASTC12x12Unorm: 'astc-12x12-unorm',\n  ASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb'\n};\nconst GPUAddressMode = {\n  ClampToEdge: 'clamp-to-edge',\n  Repeat: 'repeat',\n  MirrorRepeat: 'mirror-repeat'\n};\nconst GPUFilterMode = {\n  Linear: 'linear',\n  Nearest: 'nearest'\n};\nconst GPUBlendFactor = {\n  Zero: 'zero',\n  One: 'one',\n  Src: 'src',\n  OneMinusSrc: 'one-minus-src',\n  SrcAlpha: 'src-alpha',\n  OneMinusSrcAlpha: 'one-minus-src-alpha',\n  Dst: 'dst',\n  OneMinusDstColor: 'one-minus-dst',\n  DstAlpha: 'dst-alpha',\n  OneMinusDstAlpha: 'one-minus-dst-alpha',\n  SrcAlphaSaturated: 'src-alpha-saturated',\n  Constant: 'constant',\n  OneMinusConstant: 'one-minus-constant'\n};\nconst GPUBlendOperation = {\n  Add: 'add',\n  Subtract: 'subtract',\n  ReverseSubtract: 'reverse-subtract',\n  Min: 'min',\n  Max: 'max'\n};\nconst GPUColorWriteFlags = {\n  None: 0,\n  Red: 0x1,\n  Green: 0x2,\n  Blue: 0x4,\n  Alpha: 0x8,\n  All: 0xF\n};\nconst GPUStencilOperation = {\n  Keep: 'keep',\n  Zero: 'zero',\n  Replace: 'replace',\n  Invert: 'invert',\n  IncrementClamp: 'increment-clamp',\n  DecrementClamp: 'decrement-clamp',\n  IncrementWrap: 'increment-wrap',\n  DecrementWrap: 'decrement-wrap'\n};\nconst GPUBufferBindingType = {\n  Uniform: 'uniform',\n  Storage: 'storage',\n  ReadOnlyStorage: 'read-only-storage'\n};\nconst GPUStorageTextureAccess = {\n  WriteOnly: 'write-only',\n  ReadOnly: 'read-only',\n  ReadWrite: 'read-write'\n};\nconst GPUTextureSampleType = {\n  Float: 'float',\n  UnfilterableFloat: 'unfilterable-float',\n  Depth: 'depth',\n  SInt: 'sint',\n  UInt: 'uint'\n};\nconst GPUTextureDimension = {\n  OneD: '1d',\n  TwoD: '2d',\n  ThreeD: '3d'\n};\nconst GPUTextureViewDimension = {\n  OneD: '1d',\n  TwoD: '2d',\n  TwoDArray: '2d-array',\n  Cube: 'cube',\n  CubeArray: 'cube-array',\n  ThreeD: '3d'\n};\nconst GPUTextureAspect = {\n  All: 'all',\n  StencilOnly: 'stencil-only',\n  DepthOnly: 'depth-only'\n};\nconst GPUInputStepMode = {\n  Vertex: 'vertex',\n  Instance: 'instance'\n};\nconst GPUFeatureName = {\n  DepthClipControl: 'depth-clip-control',\n  Depth32FloatStencil8: 'depth32float-stencil8',\n  TextureCompressionBC: 'texture-compression-bc',\n  TextureCompressionETC2: 'texture-compression-etc2',\n  TextureCompressionASTC: 'texture-compression-astc',\n  TimestampQuery: 'timestamp-query',\n  IndirectFirstInstance: 'indirect-first-instance',\n  ShaderF16: 'shader-f16',\n  RG11B10UFloat: 'rg11b10ufloat-renderable',\n  BGRA8UNormStorage: 'bgra8unorm-storage',\n  Float32Filterable: 'float32-filterable',\n  ClipDistances: 'clip-distances',\n  DualSourceBlending: 'dual-source-blending',\n  Subgroups: 'subgroups'\n};\nclass Sampler extends Binding {\n  constructor(name, texture) {\n    super(name);\n    this.texture = texture;\n    this.version = texture ? texture.version : 0;\n    this.isSampler = true;\n  }\n}\nclass NodeSampler extends Sampler {\n  constructor(name, textureNode, groupNode) {\n    super(name, textureNode ? textureNode.value : null);\n    this.textureNode = textureNode;\n    this.groupNode = groupNode;\n  }\n  update() {\n    this.texture = this.textureNode.value;\n  }\n}\nclass StorageBuffer extends Buffer {\n  constructor(name, attribute) {\n    super(name, attribute ? attribute.array : null);\n    this.attribute = attribute;\n    this.isStorageBuffer = true;\n  }\n}\nlet _id = 0;\nclass NodeStorageBuffer extends StorageBuffer {\n  constructor(nodeUniform, groupNode) {\n    super('StorageBuffer_' + _id++, nodeUniform ? nodeUniform.value : null);\n    this.nodeUniform = nodeUniform;\n    this.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;\n    this.groupNode = groupNode;\n  }\n  get buffer() {\n    return this.nodeUniform.value;\n  }\n}\nclass WebGPUTexturePassUtils extends DataMap {\n  constructor(device) {\n    super();\n    this.device = device;\n    const mipmapVertexSource = `\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n`;\n    const mipmapFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n`;\n    const flipYFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );\n\n}\n`;\n    this.mipmapSampler = device.createSampler({\n      minFilter: GPUFilterMode.Linear\n    });\n    this.flipYSampler = device.createSampler({\n      minFilter: GPUFilterMode.Nearest\n    }); //@TODO?: Consider using textureLoad()\n\n    // We'll need a new pipeline for every texture format used.\n    this.transferPipelines = {};\n    this.flipYPipelines = {};\n    this.mipmapVertexShaderModule = device.createShaderModule({\n      label: 'mipmapVertex',\n      code: mipmapVertexSource\n    });\n    this.mipmapFragmentShaderModule = device.createShaderModule({\n      label: 'mipmapFragment',\n      code: mipmapFragmentSource\n    });\n    this.flipYFragmentShaderModule = device.createShaderModule({\n      label: 'flipYFragment',\n      code: flipYFragmentSource\n    });\n  }\n  getTransferPipeline(format) {\n    let pipeline = this.transferPipelines[format];\n    if (pipeline === undefined) {\n      pipeline = this.device.createRenderPipeline({\n        label: `mipmap-${format}`,\n        vertex: {\n          module: this.mipmapVertexShaderModule,\n          entryPoint: 'main'\n        },\n        fragment: {\n          module: this.mipmapFragmentShaderModule,\n          entryPoint: 'main',\n          targets: [{\n            format\n          }]\n        },\n        primitive: {\n          topology: GPUPrimitiveTopology.TriangleStrip,\n          stripIndexFormat: GPUIndexFormat.Uint32\n        },\n        layout: 'auto'\n      });\n      this.transferPipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  getFlipYPipeline(format) {\n    let pipeline = this.flipYPipelines[format];\n    if (pipeline === undefined) {\n      pipeline = this.device.createRenderPipeline({\n        label: `flipY-${format}`,\n        vertex: {\n          module: this.mipmapVertexShaderModule,\n          entryPoint: 'main'\n        },\n        fragment: {\n          module: this.flipYFragmentShaderModule,\n          entryPoint: 'main',\n          targets: [{\n            format\n          }]\n        },\n        primitive: {\n          topology: GPUPrimitiveTopology.TriangleStrip,\n          stripIndexFormat: GPUIndexFormat.Uint32\n        },\n        layout: 'auto'\n      });\n      this.flipYPipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  flipY(textureGPU, textureGPUDescriptor) {\n    let baseArrayLayer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const format = textureGPUDescriptor.format;\n    const {\n      width,\n      height\n    } = textureGPUDescriptor.size;\n    const transferPipeline = this.getTransferPipeline(format);\n    const flipYPipeline = this.getFlipYPipeline(format);\n    const tempTexture = this.device.createTexture({\n      size: {\n        width,\n        height,\n        depthOrArrayLayers: 1\n      },\n      format,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n    });\n    const srcView = textureGPU.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n      dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer\n    });\n    const dstView = tempTexture.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n      dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer: 0\n    });\n    const commandEncoder = this.device.createCommandEncoder({});\n    const pass = (pipeline, sourceView, destinationView) => {\n      const bindGroupLayout = pipeline.getBindGroupLayout(0); // @TODO: Consider making this static.\n\n      const bindGroup = this.device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [{\n          binding: 0,\n          resource: this.flipYSampler\n        }, {\n          binding: 1,\n          resource: sourceView\n        }]\n      });\n      const passEncoder = commandEncoder.beginRenderPass({\n        colorAttachments: [{\n          view: destinationView,\n          loadOp: GPULoadOp.Clear,\n          storeOp: GPUStoreOp.Store,\n          clearValue: [0, 0, 0, 0]\n        }]\n      });\n      passEncoder.setPipeline(pipeline);\n      passEncoder.setBindGroup(0, bindGroup);\n      passEncoder.draw(4, 1, 0, 0);\n      passEncoder.end();\n    };\n    pass(transferPipeline, srcView, dstView);\n    pass(flipYPipeline, dstView, srcView);\n    this.device.queue.submit([commandEncoder.finish()]);\n    tempTexture.destroy();\n  }\n  generateMipmaps(textureGPU, textureGPUDescriptor) {\n    let baseArrayLayer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const textureData = this.get(textureGPU);\n    if (textureData.useCount === undefined) {\n      textureData.useCount = 0;\n      textureData.layers = [];\n    }\n    const passes = textureData.layers[baseArrayLayer] || this._mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer);\n    const commandEncoder = this.device.createCommandEncoder({});\n    this._mipmapRunBundles(commandEncoder, passes);\n    this.device.queue.submit([commandEncoder.finish()]);\n    if (textureData.useCount !== 0) textureData.layers[baseArrayLayer] = passes;\n    textureData.useCount++;\n  }\n  _mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer) {\n    const pipeline = this.getTransferPipeline(textureGPUDescriptor.format);\n    const bindGroupLayout = pipeline.getBindGroupLayout(0); // @TODO: Consider making this static.\n\n    let srcView = textureGPU.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n      dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer\n    });\n    const passes = [];\n    for (let i = 1; i < textureGPUDescriptor.mipLevelCount; i++) {\n      const bindGroup = this.device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [{\n          binding: 0,\n          resource: this.mipmapSampler\n        }, {\n          binding: 1,\n          resource: srcView\n        }]\n      });\n      const dstView = textureGPU.createView({\n        baseMipLevel: i,\n        mipLevelCount: 1,\n        dimension: GPUTextureViewDimension.TwoD,\n        baseArrayLayer\n      });\n      const passDescriptor = {\n        colorAttachments: [{\n          view: dstView,\n          loadOp: GPULoadOp.Clear,\n          storeOp: GPUStoreOp.Store,\n          clearValue: [0, 0, 0, 0]\n        }]\n      };\n      const passEncoder = this.device.createRenderBundleEncoder({\n        colorFormats: [textureGPUDescriptor.format]\n      });\n      passEncoder.setPipeline(pipeline);\n      passEncoder.setBindGroup(0, bindGroup);\n      passEncoder.draw(4, 1, 0, 0);\n      passes.push({\n        renderBundles: [passEncoder.finish()],\n        passDescriptor\n      });\n      srcView = dstView;\n    }\n    return passes;\n  }\n  _mipmapRunBundles(commandEncoder, passes) {\n    const levels = passes.length;\n    for (let i = 0; i < levels; i++) {\n      const pass = passes[i];\n      const passEncoder = commandEncoder.beginRenderPass(pass.passDescriptor);\n      passEncoder.executeBundles(pass.renderBundles);\n      passEncoder.end();\n    }\n  }\n}\nconst _compareToWebGPU = {\n  [NeverCompare]: 'never',\n  [LessCompare]: 'less',\n  [EqualCompare]: 'equal',\n  [LessEqualCompare]: 'less-equal',\n  [GreaterCompare]: 'greater',\n  [GreaterEqualCompare]: 'greater-equal',\n  [AlwaysCompare]: 'always',\n  [NotEqualCompare]: 'not-equal'\n};\nconst _flipMap = [0, 1, 3, 2, 4, 5];\nclass WebGPUTextureUtils {\n  constructor(backend) {\n    this.backend = backend;\n    this._passUtils = null;\n    this.defaultTexture = {};\n    this.defaultCubeTexture = {};\n    this.defaultVideoFrame = null;\n    this.colorBuffer = null;\n    this.depthTexture = new DepthTexture();\n    this.depthTexture.name = 'depthBuffer';\n  }\n  createSampler(texture) {\n    const backend = this.backend;\n    const device = backend.device;\n    const textureGPU = backend.get(texture);\n    const samplerDescriptorGPU = {\n      addressModeU: this._convertAddressMode(texture.wrapS),\n      addressModeV: this._convertAddressMode(texture.wrapT),\n      addressModeW: this._convertAddressMode(texture.wrapR),\n      magFilter: this._convertFilterMode(texture.magFilter),\n      minFilter: this._convertFilterMode(texture.minFilter),\n      mipmapFilter: this._convertFilterMode(texture.minFilter),\n      maxAnisotropy: 1\n    };\n\n    // anisotropy can only be used when all filter modes are set to linear.\n\n    if (samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear) {\n      samplerDescriptorGPU.maxAnisotropy = texture.anisotropy;\n    }\n    if (texture.isDepthTexture && texture.compareFunction !== null) {\n      samplerDescriptorGPU.compare = _compareToWebGPU[texture.compareFunction];\n    }\n    textureGPU.sampler = device.createSampler(samplerDescriptorGPU);\n  }\n  createDefaultTexture(texture) {\n    let textureGPU;\n    const format = getFormat(texture);\n    if (texture.isCubeTexture) {\n      textureGPU = this._getDefaultCubeTextureGPU(format);\n    } else if (texture.isVideoTexture) {\n      this.backend.get(texture).externalTexture = this._getDefaultVideoFrame();\n    } else {\n      textureGPU = this._getDefaultTextureGPU(format);\n    }\n    this.backend.get(texture).texture = textureGPU;\n  }\n  createTexture(texture) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const backend = this.backend;\n    const textureData = backend.get(texture);\n    if (textureData.initialized) {\n      throw new Error('WebGPUTextureUtils: Texture already initialized.');\n    }\n    if (options.needsMipmaps === undefined) options.needsMipmaps = false;\n    if (options.levels === undefined) options.levels = 1;\n    if (options.depth === undefined) options.depth = 1;\n    const {\n      width,\n      height,\n      depth,\n      levels\n    } = options;\n    if (texture.isFramebufferTexture) {\n      if (options.renderTarget) {\n        options.format = this.backend.utils.getCurrentColorFormat(options.renderTarget);\n      } else {\n        options.format = this.backend.utils.getPreferredCanvasFormat();\n      }\n    }\n    const dimension = this._getDimension(texture);\n    const format = texture.internalFormat || options.format || getFormat(texture, backend.device);\n    textureData.format = format;\n    let sampleCount = options.sampleCount !== undefined ? options.sampleCount : 1;\n    sampleCount = backend.utils.getSampleCount(sampleCount);\n    const primarySampleCount = texture.isRenderTargetTexture && !texture.isMultisampleRenderTargetTexture ? 1 : sampleCount;\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n    if (texture.isStorageTexture === true) {\n      usage |= GPUTextureUsage.STORAGE_BINDING;\n    }\n    if (texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true) {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    }\n    const textureDescriptorGPU = {\n      label: texture.name,\n      size: {\n        width: width,\n        height: height,\n        depthOrArrayLayers: depth\n      },\n      mipLevelCount: levels,\n      sampleCount: primarySampleCount,\n      dimension: dimension,\n      format: format,\n      usage: usage\n    };\n\n    // texture creation\n\n    if (texture.isVideoTexture) {\n      const video = texture.source.data;\n      const videoFrame = new VideoFrame(video);\n      textureDescriptorGPU.size.width = videoFrame.displayWidth;\n      textureDescriptorGPU.size.height = videoFrame.displayHeight;\n      videoFrame.close();\n      textureData.externalTexture = video;\n    } else {\n      if (format === undefined) {\n        console.warn('WebGPURenderer: Texture format not supported.');\n        return this.createDefaultTexture(texture);\n      }\n      textureData.texture = backend.device.createTexture(textureDescriptorGPU);\n    }\n    if (texture.isRenderTargetTexture && sampleCount > 1 && !texture.isMultisampleRenderTargetTexture) {\n      const msaaTextureDescriptorGPU = Object.assign({}, textureDescriptorGPU);\n      msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';\n      msaaTextureDescriptorGPU.sampleCount = sampleCount;\n      textureData.msaaTexture = backend.device.createTexture(msaaTextureDescriptorGPU);\n    }\n    textureData.initialized = true;\n    textureData.textureDescriptorGPU = textureDescriptorGPU;\n  }\n  destroyTexture(texture) {\n    const backend = this.backend;\n    const textureData = backend.get(texture);\n    if (textureData.texture !== undefined) textureData.texture.destroy();\n    if (textureData.msaaTexture !== undefined) textureData.msaaTexture.destroy();\n    backend.delete(texture);\n  }\n  destroySampler(texture) {\n    const backend = this.backend;\n    const textureData = backend.get(texture);\n    delete textureData.sampler;\n  }\n  generateMipmaps(texture) {\n    const textureData = this.backend.get(texture);\n    if (texture.isCubeTexture) {\n      for (let i = 0; i < 6; i++) {\n        this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i);\n      }\n    } else {\n      const depth = texture.image.depth || 1;\n      for (let i = 0; i < depth; i++) {\n        this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i);\n      }\n    }\n  }\n  getColorBuffer() {\n    if (this.colorBuffer) this.colorBuffer.destroy();\n    const backend = this.backend;\n    const {\n      width,\n      height\n    } = backend.getDrawingBufferSize();\n    this.colorBuffer = backend.device.createTexture({\n      label: 'colorBuffer',\n      size: {\n        width: width,\n        height: height,\n        depthOrArrayLayers: 1\n      },\n      sampleCount: backend.utils.getSampleCount(backend.renderer.samples),\n      format: backend.utils.getPreferredCanvasFormat(),\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n    });\n    return this.colorBuffer;\n  }\n  getDepthBuffer() {\n    let depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let stencil = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const backend = this.backend;\n    const {\n      width,\n      height\n    } = backend.getDrawingBufferSize();\n    const depthTexture = this.depthTexture;\n    const depthTextureGPU = backend.get(depthTexture).texture;\n    let format, type;\n    if (stencil) {\n      format = DepthStencilFormat;\n      type = UnsignedInt248Type;\n    } else if (depth) {\n      format = DepthFormat;\n      type = UnsignedIntType;\n    }\n    if (depthTextureGPU !== undefined) {\n      if (depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type) {\n        return depthTextureGPU;\n      }\n      this.destroyTexture(depthTexture);\n    }\n    depthTexture.name = 'depthBuffer';\n    depthTexture.format = format;\n    depthTexture.type = type;\n    depthTexture.image.width = width;\n    depthTexture.image.height = height;\n    this.createTexture(depthTexture, {\n      sampleCount: backend.utils.getSampleCount(backend.renderer.samples),\n      width,\n      height\n    });\n    return backend.get(depthTexture).texture;\n  }\n  updateTexture(texture, options) {\n    const textureData = this.backend.get(texture);\n    const {\n      textureDescriptorGPU\n    } = textureData;\n    if (texture.isRenderTargetTexture || textureDescriptorGPU === undefined /* unsupported texture format */) return;\n\n    // transfer texture data\n\n    if (texture.isDataTexture) {\n      this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY);\n    } else if (texture.isDataArrayTexture || texture.isData3DTexture) {\n      for (let i = 0; i < options.image.depth; i++) {\n        this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i);\n      }\n    } else if (texture.isCompressedTexture || texture.isCompressedArrayTexture) {\n      this._copyCompressedBufferToTexture(texture.mipmaps, textureData.texture, textureDescriptorGPU);\n    } else if (texture.isCubeTexture) {\n      this._copyCubeMapToTexture(options.images, textureData.texture, textureDescriptorGPU, texture.flipY);\n    } else if (texture.isVideoTexture) {\n      const video = texture.source.data;\n      textureData.externalTexture = video;\n    } else {\n      this._copyImageToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY);\n    }\n\n    //\n\n    textureData.version = texture.version;\n    if (texture.onUpdate) texture.onUpdate(texture);\n  }\n  async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {\n    const device = this.backend.device;\n    const textureData = this.backend.get(texture);\n    const textureGPU = textureData.texture;\n    const format = textureData.textureDescriptorGPU.format;\n    const bytesPerTexel = this._getBytesPerTexel(format);\n    let bytesPerRow = width * bytesPerTexel;\n    bytesPerRow = Math.ceil(bytesPerRow / 256) * 256; // Align to 256 bytes\n\n    const readBuffer = device.createBuffer({\n      size: width * height * bytesPerTexel,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n    });\n    const encoder = device.createCommandEncoder();\n    encoder.copyTextureToBuffer({\n      texture: textureGPU,\n      origin: {\n        x,\n        y,\n        z: faceIndex\n      }\n    }, {\n      buffer: readBuffer,\n      bytesPerRow: bytesPerRow\n    }, {\n      width: width,\n      height: height\n    });\n    const typedArrayType = this._getTypedArrayType(format);\n    device.queue.submit([encoder.finish()]);\n    await readBuffer.mapAsync(GPUMapMode.READ);\n    const buffer = readBuffer.getMappedRange();\n    return new typedArrayType(buffer);\n  }\n  _isEnvironmentTexture(texture) {\n    const mapping = texture.mapping;\n    return mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping || mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;\n  }\n  _getDefaultTextureGPU(format) {\n    let defaultTexture = this.defaultTexture[format];\n    if (defaultTexture === undefined) {\n      const texture = new Texture();\n      texture.minFilter = NearestFilter;\n      texture.magFilter = NearestFilter;\n      this.createTexture(texture, {\n        width: 1,\n        height: 1,\n        format\n      });\n      this.defaultTexture[format] = defaultTexture = texture;\n    }\n    return this.backend.get(defaultTexture).texture;\n  }\n  _getDefaultCubeTextureGPU(format) {\n    let defaultCubeTexture = this.defaultTexture[format];\n    if (defaultCubeTexture === undefined) {\n      const texture = new CubeTexture();\n      texture.minFilter = NearestFilter;\n      texture.magFilter = NearestFilter;\n      this.createTexture(texture, {\n        width: 1,\n        height: 1,\n        depth: 6\n      });\n      this.defaultCubeTexture[format] = defaultCubeTexture = texture;\n    }\n    return this.backend.get(defaultCubeTexture).texture;\n  }\n  _getDefaultVideoFrame() {\n    let defaultVideoFrame = this.defaultVideoFrame;\n    if (defaultVideoFrame === null) {\n      const init = {\n        timestamp: 0,\n        codedWidth: 1,\n        codedHeight: 1,\n        format: 'RGBA'\n      };\n      this.defaultVideoFrame = defaultVideoFrame = new VideoFrame(new Uint8Array([0, 0, 0, 0xff]), init);\n    }\n    return defaultVideoFrame;\n  }\n  _copyCubeMapToTexture(images, textureGPU, textureDescriptorGPU, flipY) {\n    for (let i = 0; i < 6; i++) {\n      const image = images[i];\n      const flipIndex = flipY === true ? _flipMap[i] : i;\n      if (image.isDataTexture) {\n        this._copyBufferToTexture(image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY);\n      } else {\n        this._copyImageToTexture(image, textureGPU, textureDescriptorGPU, flipIndex, flipY);\n      }\n    }\n  }\n  _copyImageToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY) {\n    const device = this.backend.device;\n    device.queue.copyExternalImageToTexture({\n      source: image\n    }, {\n      texture: textureGPU,\n      mipLevel: 0,\n      origin: {\n        x: 0,\n        y: 0,\n        z: originDepth\n      }\n    }, {\n      width: image.width,\n      height: image.height,\n      depthOrArrayLayers: 1\n    });\n    if (flipY === true) {\n      this._flipY(textureGPU, textureDescriptorGPU, originDepth);\n    }\n  }\n  _getPassUtils() {\n    let passUtils = this._passUtils;\n    if (passUtils === null) {\n      this._passUtils = passUtils = new WebGPUTexturePassUtils(this.backend.device);\n    }\n    return passUtils;\n  }\n  _generateMipmaps(textureGPU, textureDescriptorGPU) {\n    let baseArrayLayer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this._getPassUtils().generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer);\n  }\n  _flipY(textureGPU, textureDescriptorGPU) {\n    let originDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this._getPassUtils().flipY(textureGPU, textureDescriptorGPU, originDepth);\n  }\n  _copyBufferToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY) {\n    let depth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    // @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n    // @TODO: Consider to support valid buffer layouts with other formats like RGB\n\n    const device = this.backend.device;\n    const data = image.data;\n    const bytesPerTexel = this._getBytesPerTexel(textureDescriptorGPU.format);\n    const bytesPerRow = image.width * bytesPerTexel;\n    device.queue.writeTexture({\n      texture: textureGPU,\n      mipLevel: 0,\n      origin: {\n        x: 0,\n        y: 0,\n        z: originDepth\n      }\n    }, data, {\n      offset: image.width * image.height * bytesPerTexel * depth,\n      bytesPerRow\n    }, {\n      width: image.width,\n      height: image.height,\n      depthOrArrayLayers: 1\n    });\n    if (flipY === true) {\n      this._flipY(textureGPU, textureDescriptorGPU, originDepth);\n    }\n  }\n  _copyCompressedBufferToTexture(mipmaps, textureGPU, textureDescriptorGPU) {\n    // @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\n    const device = this.backend.device;\n    const blockData = this._getBlockData(textureDescriptorGPU.format);\n    const isTextureArray = textureDescriptorGPU.size.depthOrArrayLayers > 1;\n    for (let i = 0; i < mipmaps.length; i++) {\n      const mipmap = mipmaps[i];\n      const width = mipmap.width;\n      const height = mipmap.height;\n      const depth = isTextureArray ? textureDescriptorGPU.size.depthOrArrayLayers : 1;\n      const bytesPerRow = Math.ceil(width / blockData.width) * blockData.byteLength;\n      const bytesPerImage = bytesPerRow * Math.ceil(height / blockData.height);\n      for (let j = 0; j < depth; j++) {\n        device.queue.writeTexture({\n          texture: textureGPU,\n          mipLevel: i,\n          origin: {\n            x: 0,\n            y: 0,\n            z: j\n          }\n        }, mipmap.data, {\n          offset: j * bytesPerImage,\n          bytesPerRow,\n          rowsPerImage: Math.ceil(height / blockData.height)\n        }, {\n          width: Math.ceil(width / blockData.width) * blockData.width,\n          height: Math.ceil(height / blockData.height) * blockData.height,\n          depthOrArrayLayers: 1\n        });\n      }\n    }\n  }\n  _getBlockData(format) {\n    // this method is only relevant for compressed texture formats\n\n    if (format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    }; // DXT1\n    if (format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // DXT3\n    if (format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // DXT5\n    if (format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    }; // RGTC1\n    if (format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // RGTC2\n    if (format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // BPTC (float)\n    if (format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // BPTC (unorm)\n\n    if (format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACR11Unorm) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACR11Snorm) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACRG11Unorm) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACRG11Snorm) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB) return {\n      byteLength: 16,\n      width: 5,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB) return {\n      byteLength: 16,\n      width: 5,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB) return {\n      byteLength: 16,\n      width: 6,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB) return {\n      byteLength: 16,\n      width: 6,\n      height: 6\n    };\n    if (format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB) return {\n      byteLength: 16,\n      width: 8,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB) return {\n      byteLength: 16,\n      width: 8,\n      height: 6\n    };\n    if (format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB) return {\n      byteLength: 16,\n      width: 8,\n      height: 8\n    };\n    if (format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 6\n    };\n    if (format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 8\n    };\n    if (format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 10\n    };\n    if (format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB) return {\n      byteLength: 16,\n      width: 12,\n      height: 10\n    };\n    if (format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB) return {\n      byteLength: 16,\n      width: 12,\n      height: 12\n    };\n  }\n  _convertAddressMode(value) {\n    let addressMode = GPUAddressMode.ClampToEdge;\n    if (value === RepeatWrapping) {\n      addressMode = GPUAddressMode.Repeat;\n    } else if (value === MirroredRepeatWrapping) {\n      addressMode = GPUAddressMode.MirrorRepeat;\n    }\n    return addressMode;\n  }\n  _convertFilterMode(value) {\n    let filterMode = GPUFilterMode.Linear;\n    if (value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter) {\n      filterMode = GPUFilterMode.Nearest;\n    }\n    return filterMode;\n  }\n  _getBytesPerTexel(format) {\n    // 8-bit formats\n    if (format === GPUTextureFormat.R8Unorm || format === GPUTextureFormat.R8Snorm || format === GPUTextureFormat.R8Uint || format === GPUTextureFormat.R8Sint) return 1;\n\n    // 16-bit formats\n    if (format === GPUTextureFormat.R16Uint || format === GPUTextureFormat.R16Sint || format === GPUTextureFormat.R16Float || format === GPUTextureFormat.RG8Unorm || format === GPUTextureFormat.RG8Snorm || format === GPUTextureFormat.RG8Uint || format === GPUTextureFormat.RG8Sint) return 2;\n\n    // 32-bit formats\n    if (format === GPUTextureFormat.R32Uint || format === GPUTextureFormat.R32Sint || format === GPUTextureFormat.R32Float || format === GPUTextureFormat.RG16Uint || format === GPUTextureFormat.RG16Sint || format === GPUTextureFormat.RG16Float || format === GPUTextureFormat.RGBA8Unorm || format === GPUTextureFormat.RGBA8UnormSRGB || format === GPUTextureFormat.RGBA8Snorm || format === GPUTextureFormat.RGBA8Uint || format === GPUTextureFormat.RGBA8Sint || format === GPUTextureFormat.BGRA8Unorm || format === GPUTextureFormat.BGRA8UnormSRGB ||\n    // Packed 32-bit formats\n    format === GPUTextureFormat.RGB9E5UFloat || format === GPUTextureFormat.RGB10A2Unorm || format === GPUTextureFormat.RG11B10UFloat || format === GPUTextureFormat.Depth32Float || format === GPUTextureFormat.Depth24Plus || format === GPUTextureFormat.Depth24PlusStencil8 || format === GPUTextureFormat.Depth32FloatStencil8) return 4;\n\n    // 64-bit formats\n    if (format === GPUTextureFormat.RG32Uint || format === GPUTextureFormat.RG32Sint || format === GPUTextureFormat.RG32Float || format === GPUTextureFormat.RGBA16Uint || format === GPUTextureFormat.RGBA16Sint || format === GPUTextureFormat.RGBA16Float) return 8;\n\n    // 128-bit formats\n    if (format === GPUTextureFormat.RGBA32Uint || format === GPUTextureFormat.RGBA32Sint || format === GPUTextureFormat.RGBA32Float) return 16;\n  }\n  _getTypedArrayType(format) {\n    if (format === GPUTextureFormat.R8Uint) return Uint8Array;\n    if (format === GPUTextureFormat.R8Sint) return Int8Array;\n    if (format === GPUTextureFormat.R8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.R8Snorm) return Int8Array;\n    if (format === GPUTextureFormat.RG8Uint) return Uint8Array;\n    if (format === GPUTextureFormat.RG8Sint) return Int8Array;\n    if (format === GPUTextureFormat.RG8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.RG8Snorm) return Int8Array;\n    if (format === GPUTextureFormat.RGBA8Uint) return Uint8Array;\n    if (format === GPUTextureFormat.RGBA8Sint) return Int8Array;\n    if (format === GPUTextureFormat.RGBA8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.RGBA8Snorm) return Int8Array;\n    if (format === GPUTextureFormat.R16Uint) return Uint16Array;\n    if (format === GPUTextureFormat.R16Sint) return Int16Array;\n    if (format === GPUTextureFormat.RG16Uint) return Uint16Array;\n    if (format === GPUTextureFormat.RG16Sint) return Int16Array;\n    if (format === GPUTextureFormat.RGBA16Uint) return Uint16Array;\n    if (format === GPUTextureFormat.RGBA16Sint) return Int16Array;\n    if (format === GPUTextureFormat.R16Float) return Uint16Array;\n    if (format === GPUTextureFormat.RG16Float) return Uint16Array;\n    if (format === GPUTextureFormat.RGBA16Float) return Uint16Array;\n    if (format === GPUTextureFormat.R32Uint) return Uint32Array;\n    if (format === GPUTextureFormat.R32Sint) return Int32Array;\n    if (format === GPUTextureFormat.R32Float) return Float32Array;\n    if (format === GPUTextureFormat.RG32Uint) return Uint32Array;\n    if (format === GPUTextureFormat.RG32Sint) return Int32Array;\n    if (format === GPUTextureFormat.RG32Float) return Float32Array;\n    if (format === GPUTextureFormat.RGBA32Uint) return Uint32Array;\n    if (format === GPUTextureFormat.RGBA32Sint) return Int32Array;\n    if (format === GPUTextureFormat.RGBA32Float) return Float32Array;\n    if (format === GPUTextureFormat.BGRA8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.BGRA8UnormSRGB) return Uint8Array;\n    if (format === GPUTextureFormat.RGB10A2Unorm) return Uint32Array;\n    if (format === GPUTextureFormat.RGB9E5UFloat) return Uint32Array;\n    if (format === GPUTextureFormat.RG11B10UFloat) return Uint32Array;\n    if (format === GPUTextureFormat.Depth32Float) return Float32Array;\n    if (format === GPUTextureFormat.Depth24Plus) return Uint32Array;\n    if (format === GPUTextureFormat.Depth24PlusStencil8) return Uint32Array;\n    if (format === GPUTextureFormat.Depth32FloatStencil8) return Float32Array;\n  }\n  _getDimension(texture) {\n    let dimension;\n    if (texture.isData3DTexture) {\n      dimension = GPUTextureDimension.ThreeD;\n    } else {\n      dimension = GPUTextureDimension.TwoD;\n    }\n    return dimension;\n  }\n}\nfunction getFormat(texture) {\n  let device = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const format = texture.format;\n  const type = texture.type;\n  const colorSpace = texture.colorSpace;\n  let formatGPU;\n  if (texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true) {\n    switch (format) {\n      case RGBA_S3TC_DXT1_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;\n        break;\n      case RGBA_S3TC_DXT3_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;\n        break;\n      case RGBA_S3TC_DXT5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;\n        break;\n      case RGB_ETC2_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;\n        break;\n      case RGBA_ETC2_EAC_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;\n        break;\n      case RGBA_ASTC_4x4_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;\n        break;\n      case RGBA_ASTC_5x4_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;\n        break;\n      case RGBA_ASTC_5x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;\n        break;\n      case RGBA_ASTC_6x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;\n        break;\n      case RGBA_ASTC_6x6_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;\n        break;\n      case RGBA_ASTC_8x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;\n        break;\n      case RGBA_ASTC_8x6_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;\n        break;\n      case RGBA_ASTC_8x8_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;\n        break;\n      case RGBA_ASTC_10x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;\n        break;\n      case RGBA_ASTC_10x6_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;\n        break;\n      case RGBA_ASTC_10x8_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;\n        break;\n      case RGBA_ASTC_10x10_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;\n        break;\n      case RGBA_ASTC_12x10_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;\n        break;\n      case RGBA_ASTC_12x12_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;\n        break;\n      case RGBAFormat:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n        break;\n      default:\n        console.error('WebGPURenderer: Unsupported texture format.', format);\n    }\n  } else {\n    switch (format) {\n      case RGBAFormat:\n        switch (type) {\n          case ByteType:\n            formatGPU = GPUTextureFormat.RGBA8Snorm;\n            break;\n          case ShortType:\n            formatGPU = GPUTextureFormat.RGBA16Sint;\n            break;\n          case UnsignedShortType:\n            formatGPU = GPUTextureFormat.RGBA16Uint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.RGBA32Uint;\n            break;\n          case IntType:\n            formatGPU = GPUTextureFormat.RGBA32Sint;\n            break;\n          case UnsignedByteType:\n            formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n            break;\n          case HalfFloatType:\n            formatGPU = GPUTextureFormat.RGBA16Float;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.RGBA32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGBAFormat.', type);\n        }\n        break;\n      case RGBFormat:\n        switch (type) {\n          case UnsignedInt5999Type:\n            formatGPU = GPUTextureFormat.RGB9E5UFloat;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGBFormat.', type);\n        }\n        break;\n      case RedFormat:\n        switch (type) {\n          case ByteType:\n            formatGPU = GPUTextureFormat.R8Snorm;\n            break;\n          case ShortType:\n            formatGPU = GPUTextureFormat.R16Sint;\n            break;\n          case UnsignedShortType:\n            formatGPU = GPUTextureFormat.R16Uint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.R32Uint;\n            break;\n          case IntType:\n            formatGPU = GPUTextureFormat.R32Sint;\n            break;\n          case UnsignedByteType:\n            formatGPU = GPUTextureFormat.R8Unorm;\n            break;\n          case HalfFloatType:\n            formatGPU = GPUTextureFormat.R16Float;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.R32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RedFormat.', type);\n        }\n        break;\n      case RGFormat:\n        switch (type) {\n          case ByteType:\n            formatGPU = GPUTextureFormat.RG8Snorm;\n            break;\n          case ShortType:\n            formatGPU = GPUTextureFormat.RG16Sint;\n            break;\n          case UnsignedShortType:\n            formatGPU = GPUTextureFormat.RG16Uint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.RG32Uint;\n            break;\n          case IntType:\n            formatGPU = GPUTextureFormat.RG32Sint;\n            break;\n          case UnsignedByteType:\n            formatGPU = GPUTextureFormat.RG8Unorm;\n            break;\n          case HalfFloatType:\n            formatGPU = GPUTextureFormat.RG16Float;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.RG32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGFormat.', type);\n        }\n        break;\n      case DepthFormat:\n        switch (type) {\n          case UnsignedShortType:\n            formatGPU = GPUTextureFormat.Depth16Unorm;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.Depth24Plus;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.Depth32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with DepthFormat.', type);\n        }\n        break;\n      case DepthStencilFormat:\n        switch (type) {\n          case UnsignedInt248Type:\n            formatGPU = GPUTextureFormat.Depth24PlusStencil8;\n            break;\n          case FloatType:\n            if (device && device.features.has(GPUFeatureName.Depth32FloatStencil8) === false) {\n              console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the \"depth32float-stencil8\" GPU feature.');\n            }\n            formatGPU = GPUTextureFormat.Depth32FloatStencil8;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type);\n        }\n        break;\n      case RedIntegerFormat:\n        switch (type) {\n          case IntType:\n            formatGPU = GPUTextureFormat.R32Sint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.R32Uint;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type);\n        }\n        break;\n      case RGIntegerFormat:\n        switch (type) {\n          case IntType:\n            formatGPU = GPUTextureFormat.RG32Sint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.RG32Uint;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type);\n        }\n        break;\n      case RGBAIntegerFormat:\n        switch (type) {\n          case IntType:\n            formatGPU = GPUTextureFormat.RGBA32Sint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.RGBA32Uint;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type);\n        }\n        break;\n      default:\n        console.error('WebGPURenderer: Unsupported texture format.', format);\n    }\n  }\n  return formatGPU;\n}\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/i;\nconst propertiesRegexp = /([a-z_0-9]+)\\s*:\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/ig;\nconst wgslTypeLib$1 = {\n  'f32': 'float',\n  'i32': 'int',\n  'u32': 'uint',\n  'bool': 'bool',\n  'vec2<f32>': 'vec2',\n  'vec2<i32>': 'ivec2',\n  'vec2<u32>': 'uvec2',\n  'vec2<bool>': 'bvec2',\n  'vec2f': 'vec2',\n  'vec2i': 'ivec2',\n  'vec2u': 'uvec2',\n  'vec2b': 'bvec2',\n  'vec3<f32>': 'vec3',\n  'vec3<i32>': 'ivec3',\n  'vec3<u32>': 'uvec3',\n  'vec3<bool>': 'bvec3',\n  'vec3f': 'vec3',\n  'vec3i': 'ivec3',\n  'vec3u': 'uvec3',\n  'vec3b': 'bvec3',\n  'vec4<f32>': 'vec4',\n  'vec4<i32>': 'ivec4',\n  'vec4<u32>': 'uvec4',\n  'vec4<bool>': 'bvec4',\n  'vec4f': 'vec4',\n  'vec4i': 'ivec4',\n  'vec4u': 'uvec4',\n  'vec4b': 'bvec4',\n  'mat2x2<f32>': 'mat2',\n  'mat2x2f': 'mat2',\n  'mat3x3<f32>': 'mat3',\n  'mat3x3f': 'mat3',\n  'mat4x4<f32>': 'mat4',\n  'mat4x4f': 'mat4',\n  'sampler': 'sampler',\n  'texture_1d': 'texture',\n  'texture_2d': 'texture',\n  'texture_2d_array': 'texture',\n  'texture_multisampled_2d': 'cubeTexture',\n  'texture_depth_2d': 'depthTexture',\n  'texture_3d': 'texture3D',\n  'texture_cube': 'cubeTexture',\n  'texture_cube_array': 'cubeTexture',\n  'texture_storage_1d': 'storageTexture',\n  'texture_storage_2d': 'storageTexture',\n  'texture_storage_2d_array': 'storageTexture',\n  'texture_storage_3d': 'storageTexture'\n};\nconst parse = source => {\n  source = source.trim();\n  const declaration = source.match(declarationRegexp);\n  if (declaration !== null && declaration.length === 4) {\n    const inputsCode = declaration[2];\n    const propsMatches = [];\n    let match = null;\n    while ((match = propertiesRegexp.exec(inputsCode)) !== null) {\n      propsMatches.push({\n        name: match[1],\n        type: match[2]\n      });\n    }\n\n    // Process matches to correctly pair names and types\n    const inputs = [];\n    for (let i = 0; i < propsMatches.length; i++) {\n      const {\n        name,\n        type\n      } = propsMatches[i];\n      let resolvedType = type;\n      if (resolvedType.startsWith('ptr')) {\n        resolvedType = 'pointer';\n      } else {\n        if (resolvedType.startsWith('texture')) {\n          resolvedType = type.split('<')[0];\n        }\n        resolvedType = wgslTypeLib$1[resolvedType];\n      }\n      inputs.push(new NodeFunctionInput(resolvedType, name));\n    }\n    const blockCode = source.substring(declaration[0].length);\n    const outputType = declaration[3] || 'void';\n    const name = declaration[1] !== undefined ? declaration[1] : '';\n    const type = wgslTypeLib$1[outputType] || outputType;\n    return {\n      type,\n      inputs,\n      name,\n      inputsCode,\n      blockCode,\n      outputType\n    };\n  } else {\n    throw new Error('FunctionNode: Function is not a WGSL code.');\n  }\n};\nclass WGSLNodeFunction extends NodeFunction {\n  constructor(source) {\n    const {\n      type,\n      inputs,\n      name,\n      inputsCode,\n      blockCode,\n      outputType\n    } = parse(source);\n    super(type, inputs, name);\n    this.inputsCode = inputsCode;\n    this.blockCode = blockCode;\n    this.outputType = outputType;\n  }\n  getCode() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.name;\n    const outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';\n    return `fn ${name} ( ${this.inputsCode.trim()} ) ${outputType}` + this.blockCode;\n  }\n}\nclass WGSLNodeParser extends NodeParser {\n  parseFunction(source) {\n    return new WGSLNodeFunction(source);\n  }\n}\n\n// GPUShaderStage is not defined in browsers not supporting WebGPU\nconst GPUShaderStage = typeof self !== 'undefined' ? self.GPUShaderStage : {\n  VERTEX: 1,\n  FRAGMENT: 2,\n  COMPUTE: 4\n};\nconst accessNames = {\n  [NodeAccess.READ_ONLY]: 'read',\n  [NodeAccess.WRITE_ONLY]: 'write',\n  [NodeAccess.READ_WRITE]: 'read_write'\n};\nconst wrapNames = {\n  [RepeatWrapping]: 'repeat',\n  [ClampToEdgeWrapping]: 'clamp',\n  [MirroredRepeatWrapping]: 'mirror'\n};\nconst gpuShaderStageLib = {\n  'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,\n  'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,\n  'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4\n};\nconst supports = {\n  instance: true,\n  swizzleAssign: false,\n  storageBuffer: true\n};\nconst wgslFnOpLib = {\n  '^^': 'tsl_xor'\n};\nconst wgslTypeLib = {\n  float: 'f32',\n  int: 'i32',\n  uint: 'u32',\n  bool: 'bool',\n  color: 'vec3<f32>',\n  vec2: 'vec2<f32>',\n  ivec2: 'vec2<i32>',\n  uvec2: 'vec2<u32>',\n  bvec2: 'vec2<bool>',\n  vec3: 'vec3<f32>',\n  ivec3: 'vec3<i32>',\n  uvec3: 'vec3<u32>',\n  bvec3: 'vec3<bool>',\n  vec4: 'vec4<f32>',\n  ivec4: 'vec4<i32>',\n  uvec4: 'vec4<u32>',\n  bvec4: 'vec4<bool>',\n  mat2: 'mat2x2<f32>',\n  mat3: 'mat3x3<f32>',\n  mat4: 'mat4x4<f32>'\n};\nconst wgslCodeCache = {};\nconst wgslPolyfill = {\n  tsl_xor: new CodeNode('fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }'),\n  mod_float: new CodeNode('fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }'),\n  mod_vec2: new CodeNode('fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }'),\n  mod_vec3: new CodeNode('fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }'),\n  mod_vec4: new CodeNode('fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }'),\n  equals_bool: new CodeNode('fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }'),\n  equals_bvec2: new CodeNode('fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }'),\n  equals_bvec3: new CodeNode('fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }'),\n  equals_bvec4: new CodeNode('fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }'),\n  repeatWrapping_float: new CodeNode('fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }'),\n  mirrorWrapping_float: new CodeNode('fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }'),\n  clampWrapping_float: new CodeNode('fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }'),\n  biquadraticTexture: new CodeNode(/* wgsl */`\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {\n\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n`)\n};\nconst wgslMethods = {\n  dFdx: 'dpdx',\n  dFdy: '- dpdy',\n  mod_float: 'tsl_mod_float',\n  mod_vec2: 'tsl_mod_vec2',\n  mod_vec3: 'tsl_mod_vec3',\n  mod_vec4: 'tsl_mod_vec4',\n  equals_bool: 'tsl_equals_bool',\n  equals_bvec2: 'tsl_equals_bvec2',\n  equals_bvec3: 'tsl_equals_bvec3',\n  equals_bvec4: 'tsl_equals_bvec4',\n  inversesqrt: 'inverseSqrt',\n  bitcast: 'bitcast<f32>'\n};\n\n// WebGPU issue: does not support pow() with negative base on Windows\n\nif (typeof navigator !== 'undefined' && /Windows/g.test(navigator.userAgent)) {\n  wgslPolyfill.pow_float = new CodeNode('fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }');\n  wgslPolyfill.pow_vec2 = new CodeNode('fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [wgslPolyfill.pow_float]);\n  wgslPolyfill.pow_vec3 = new CodeNode('fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [wgslPolyfill.pow_float]);\n  wgslPolyfill.pow_vec4 = new CodeNode('fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [wgslPolyfill.pow_float]);\n  wgslMethods.pow_float = 'tsl_pow_float';\n  wgslMethods.pow_vec2 = 'tsl_pow_vec2';\n  wgslMethods.pow_vec3 = 'tsl_pow_vec3';\n  wgslMethods.pow_vec4 = 'tsl_pow_vec4';\n}\n\n//\n\nlet diagnostics = '';\nif ((typeof navigator !== 'undefined' && /Firefox|Deno/g.test(navigator.userAgent)) !== true) {\n  diagnostics += 'diagnostic( off, derivative_uniformity );\\n';\n}\n\n//\n\nclass WGSLNodeBuilder extends NodeBuilder {\n  constructor(object, renderer) {\n    super(object, renderer, new WGSLNodeParser());\n    this.uniformGroups = {};\n    this.builtins = {};\n    this.directives = {};\n    this.scopedArrays = new Map();\n  }\n  needsToWorkingColorSpace(texture) {\n    return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n  }\n  _generateTextureSample(texture, textureProperty, uvSnippet, depthSnippet) {\n    let shaderStage = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.shaderStage;\n    if (shaderStage === 'fragment') {\n      if (depthSnippet) {\n        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;\n      } else {\n        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;\n      }\n    } else if (this.isFilteredTexture(texture)) {\n      return this.generateFilteredTexture(texture, textureProperty, uvSnippet);\n    } else {\n      return this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, '0');\n    }\n  }\n  _generateVideoSample(textureProperty, uvSnippet) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    if (shaderStage === 'fragment') {\n      return `textureSampleBaseClampToEdge( ${textureProperty}, ${textureProperty}_sampler, vec2<f32>( ${uvSnippet}.x, 1.0 - ${uvSnippet}.y ) )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.VideoTexture does not support ${shaderStage} shader.`);\n    }\n  }\n  _generateTextureSampleLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet) {\n    let shaderStage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.shaderStage;\n    if (shaderStage === 'fragment' && this.isUnfilterable(texture) === false) {\n      return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;\n    } else if (this.isFilteredTexture(texture)) {\n      return this.generateFilteredTexture(texture, textureProperty, uvSnippet, levelSnippet);\n    } else {\n      return this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, levelSnippet);\n    }\n  }\n  generateWrapFunction(texture) {\n    const functionName = `tsl_coord_${wrapNames[texture.wrapS]}S_${wrapNames[texture.wrapT]}T`;\n    let nodeCode = wgslCodeCache[functionName];\n    if (nodeCode === undefined) {\n      const includes = [];\n      let code = `fn ${functionName}( coord : vec2f ) -> vec2f {\\n\\n\\treturn vec2f(\\n`;\n      const addWrapSnippet = (wrap, axis) => {\n        if (wrap === RepeatWrapping) {\n          includes.push(wgslPolyfill.repeatWrapping_float);\n          code += `\\t\\ttsl_repeatWrapping_float( coord.${axis} )`;\n        } else if (wrap === ClampToEdgeWrapping) {\n          includes.push(wgslPolyfill.clampWrapping_float);\n          code += `\\t\\ttsl_clampWrapping_float( coord.${axis} )`;\n        } else if (wrap === MirroredRepeatWrapping) {\n          includes.push(wgslPolyfill.mirrorWrapping_float);\n          code += `\\t\\ttsl_mirrorWrapping_float( coord.${axis} )`;\n        } else {\n          code += `\\t\\tcoord.${axis}`;\n          console.warn(`WebGPURenderer: Unsupported texture wrap type \"${wrap}\" for vertex shader.`);\n        }\n      };\n      addWrapSnippet(texture.wrapS, 'x');\n      code += ',\\n';\n      addWrapSnippet(texture.wrapT, 'y');\n      code += '\\n\\t);\\n\\n}\\n';\n      wgslCodeCache[functionName] = nodeCode = new CodeNode(code, includes);\n    }\n    nodeCode.build(this);\n    return functionName;\n  }\n  generateTextureDimension(texture, textureProperty, levelSnippet) {\n    const textureData = this.getDataFromNode(texture, this.shaderStage, this.globalCache);\n    if (textureData.dimensionsSnippet === undefined) textureData.dimensionsSnippet = {};\n    let textureDimensionNode = textureData.dimensionsSnippet[levelSnippet];\n    if (textureData.dimensionsSnippet[levelSnippet] === undefined) {\n      let textureDimensionsParams;\n      if (texture.isMultisampleRenderTargetTexture === true) {\n        textureDimensionsParams = textureProperty;\n      } else {\n        textureDimensionsParams = `${textureProperty}, u32( ${levelSnippet} )`;\n      }\n      textureDimensionNode = new VarNode(new ExpressionNode(`textureDimensions( ${textureDimensionsParams} )`, 'uvec2'));\n      textureData.dimensionsSnippet[levelSnippet] = textureDimensionNode;\n    }\n    return textureDimensionNode.build(this);\n  }\n  generateFilteredTexture(texture, textureProperty, uvSnippet) {\n    let levelSnippet = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '0u';\n    this._include('biquadraticTexture');\n    const wrapFunction = this.generateWrapFunction(texture);\n    const textureDimension = this.generateTextureDimension(texture, textureProperty, levelSnippet);\n    return `tsl_biquadraticTexture( ${textureProperty}, ${wrapFunction}( ${uvSnippet} ), ${textureDimension}, u32( ${levelSnippet} ) )`;\n  }\n  generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet) {\n    let levelSnippet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '0u';\n    const wrapFunction = this.generateWrapFunction(texture);\n    const textureDimension = this.generateTextureDimension(texture, textureProperty, levelSnippet);\n    const coordSnippet = `vec2u( ${wrapFunction}( ${uvSnippet} ) * vec2f( ${textureDimension} ) )`;\n    return this.generateTextureLoad(texture, textureProperty, coordSnippet, depthSnippet, levelSnippet);\n  }\n  generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet) {\n    let levelSnippet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '0u';\n    if (texture.isVideoTexture === true || texture.isStorageTexture === true) {\n      return `textureLoad( ${textureProperty}, ${uvIndexSnippet} )`;\n    } else if (depthSnippet) {\n      return `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, u32( ${levelSnippet} ) )`;\n    } else {\n      return `textureLoad( ${textureProperty}, ${uvIndexSnippet}, u32( ${levelSnippet} ) )`;\n    }\n  }\n  generateTextureStore(texture, textureProperty, uvIndexSnippet, valueSnippet) {\n    return `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${valueSnippet} )`;\n  }\n  isSampleCompare(texture) {\n    return texture.isDepthTexture === true && texture.compareFunction !== null;\n  }\n  isUnfilterable(texture) {\n    return this.getComponentTypeFromTexture(texture) !== 'float' || !this.isAvailable('float32Filterable') && texture.isDataTexture === true && texture.type === FloatType || this.isSampleCompare(texture) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter || texture.isMultisampleRenderTargetTexture === true;\n  }\n  generateTexture(texture, textureProperty, uvSnippet, depthSnippet) {\n    let shaderStage = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.shaderStage;\n    let snippet = null;\n    if (texture.isVideoTexture === true) {\n      snippet = this._generateVideoSample(textureProperty, uvSnippet, shaderStage);\n    } else if (this.isUnfilterable(texture)) {\n      snippet = this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage);\n    } else {\n      snippet = this._generateTextureSample(texture, textureProperty, uvSnippet, depthSnippet, shaderStage);\n    }\n    return snippet;\n  }\n  generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet) {\n    let shaderStage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.shaderStage;\n    if (shaderStage === 'fragment') {\n      // TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy\n      return `textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]} )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${shaderStage} shader.`);\n    }\n  }\n  generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet) {\n    let shaderStage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.shaderStage;\n    if (shaderStage === 'fragment') {\n      return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);\n    }\n  }\n  generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet) {\n    let shaderStage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.shaderStage;\n    let snippet = null;\n    if (texture.isVideoTexture === true) {\n      snippet = this._generateVideoSample(textureProperty, uvSnippet, shaderStage);\n    } else {\n      snippet = this._generateTextureSampleLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage);\n    }\n    return snippet;\n  }\n  generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, depthSnippet) {\n    let shaderStage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.shaderStage;\n    if (shaderStage === 'fragment') {\n      return `textureSampleBias( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${shaderStage} shader.`);\n    }\n  }\n  getPropertyName(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    if (node.isNodeVarying === true && node.needsInterpolation === true) {\n      if (shaderStage === 'vertex') {\n        return `varyings.${node.name}`;\n      }\n    } else if (node.isNodeUniform === true) {\n      const name = node.name;\n      const type = node.type;\n      if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') {\n        return name;\n      } else if (type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer') {\n        return `NodeBuffer_${node.id}.${name}`;\n      } else {\n        return node.groupNode.name + '.' + name;\n      }\n    }\n    return super.getPropertyName(node);\n  }\n  getOutputStructName() {\n    return 'output';\n  }\n  _getUniformGroupCount(shaderStage) {\n    return Object.keys(this.uniforms[shaderStage]).length;\n  }\n  getFunctionOperator(op) {\n    const fnOp = wgslFnOpLib[op];\n    if (fnOp !== undefined) {\n      this._include(fnOp);\n      return fnOp;\n    }\n    return null;\n  }\n  getNodeAccess(node, shaderStage) {\n    if (shaderStage !== 'compute') return NodeAccess.READ_ONLY;\n    return node.access;\n  }\n  getStorageAccess(node, shaderStage) {\n    return accessNames[this.getNodeAccess(node, shaderStage)];\n  }\n  getUniformFromNode(node, type, shaderStage) {\n    let name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);\n    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);\n    if (nodeData.uniformGPU === undefined) {\n      let uniformGPU;\n      const group = node.groupNode;\n      const groupName = group.name;\n      const bindings = this.getBindGroupArray(groupName, shaderStage);\n      if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') {\n        let texture = null;\n        const access = this.getNodeAccess(node, shaderStage);\n        if (type === 'texture' || type === 'storageTexture') {\n          texture = new NodeSampledTexture(uniformNode.name, uniformNode.node, group, access);\n        } else if (type === 'cubeTexture') {\n          texture = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group, access);\n        } else if (type === 'texture3D') {\n          texture = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group, access);\n        }\n        texture.store = node.isStorageTextureNode === true;\n        texture.setVisibility(gpuShaderStageLib[shaderStage]);\n        if (shaderStage === 'fragment' && this.isUnfilterable(node.value) === false && texture.store === false) {\n          const sampler = new NodeSampler(`${uniformNode.name}_sampler`, uniformNode.node, group);\n          sampler.setVisibility(gpuShaderStageLib[shaderStage]);\n          bindings.push(sampler, texture);\n          uniformGPU = [sampler, texture];\n        } else {\n          bindings.push(texture);\n          uniformGPU = [texture];\n        }\n      } else if (type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer') {\n        const bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;\n        const buffer = new bufferClass(node, group);\n        buffer.setVisibility(gpuShaderStageLib[shaderStage]);\n        bindings.push(buffer);\n        uniformGPU = buffer;\n      } else {\n        const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});\n        let uniformsGroup = uniformsStage[groupName];\n        if (uniformsGroup === undefined) {\n          uniformsGroup = new NodeUniformsGroup(groupName, group);\n          uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]);\n          uniformsStage[groupName] = uniformsGroup;\n          bindings.push(uniformsGroup);\n        }\n        uniformGPU = this.getNodeUniform(uniformNode, type);\n        uniformsGroup.addUniform(uniformGPU);\n      }\n      nodeData.uniformGPU = uniformGPU;\n    }\n    return uniformNode;\n  }\n  getBuiltin(name, property, type) {\n    let shaderStage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.shaderStage;\n    const map = this.builtins[shaderStage] || (this.builtins[shaderStage] = new Map());\n    if (map.has(name) === false) {\n      map.set(name, {\n        name,\n        property,\n        type\n      });\n    }\n    return property;\n  }\n  hasBuiltin(name) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    return this.builtins[shaderStage] !== undefined && this.builtins[shaderStage].has(name);\n  }\n  getVertexIndex() {\n    if (this.shaderStage === 'vertex') {\n      return this.getBuiltin('vertex_index', 'vertexIndex', 'u32', 'attribute');\n    }\n    return 'vertexIndex';\n  }\n  buildFunctionCode(shaderNode) {\n    const layout = shaderNode.layout;\n    const flowData = this.flowShaderNode(shaderNode);\n    const parameters = [];\n    for (const input of layout.inputs) {\n      parameters.push(input.name + ' : ' + this.getType(input.type));\n    }\n\n    //\n\n    let code = `fn ${layout.name}( ${parameters.join(', ')} ) -> ${this.getType(layout.type)} {\n${flowData.vars}\n${flowData.code}\n`;\n    if (flowData.result) {\n      code += `\\treturn ${flowData.result};\\n`;\n    }\n    code += '\\n}\\n';\n\n    //\n\n    return code;\n  }\n  getInstanceIndex() {\n    if (this.shaderStage === 'vertex') {\n      return this.getBuiltin('instance_index', 'instanceIndex', 'u32', 'attribute');\n    }\n    return 'instanceIndex';\n  }\n  getInvocationLocalIndex() {\n    return this.getBuiltin('local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute');\n  }\n  getSubgroupSize() {\n    this.enableSubGroups();\n    return this.getBuiltin('subgroup_size', 'subgroupSize', 'u32', 'attribute');\n  }\n  getInvocationSubgroupIndex() {\n    this.enableSubGroups();\n    return this.getBuiltin('subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute');\n  }\n  getSubgroupIndex() {\n    this.enableSubGroups();\n    return this.getBuiltin('subgroup_id', 'subgroupIndex', 'u32', 'attribute');\n  }\n  getDrawIndex() {\n    return null;\n  }\n  getFrontFacing() {\n    return this.getBuiltin('front_facing', 'isFront', 'bool');\n  }\n  getFragCoord() {\n    return this.getBuiltin('position', 'fragCoord', 'vec4<f32>') + '.xy';\n  }\n  getFragDepth() {\n    return 'output.' + this.getBuiltin('frag_depth', 'depth', 'f32', 'output');\n  }\n  getClipDistance() {\n    return 'varyings.hw_clip_distances';\n  }\n  isFlipY() {\n    return false;\n  }\n  enableDirective(name) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    const stage = this.directives[shaderStage] || (this.directives[shaderStage] = new Set());\n    stage.add(name);\n  }\n  getDirectives(shaderStage) {\n    const snippets = [];\n    const directives = this.directives[shaderStage];\n    if (directives !== undefined) {\n      for (const directive of directives) {\n        snippets.push(`enable ${directive};`);\n      }\n    }\n    return snippets.join('\\n');\n  }\n  enableSubGroups() {\n    this.enableDirective('subgroups');\n  }\n  enableSubgroupsF16() {\n    this.enableDirective('subgroups-f16');\n  }\n  enableClipDistances() {\n    this.enableDirective('clip_distances');\n  }\n  enableShaderF16() {\n    this.enableDirective('f16');\n  }\n  enableDualSourceBlending() {\n    this.enableDirective('dual_source_blending');\n  }\n  enableHardwareClipping(planeCount) {\n    this.enableClipDistances();\n    this.getBuiltin('clip_distances', 'hw_clip_distances', `array<f32, ${planeCount} >`, 'vertex');\n  }\n  getBuiltins(shaderStage) {\n    const snippets = [];\n    const builtins = this.builtins[shaderStage];\n    if (builtins !== undefined) {\n      for (const {\n        name,\n        property,\n        type\n      } of builtins.values()) {\n        snippets.push(`@builtin( ${name} ) ${property} : ${type}`);\n      }\n    }\n    return snippets.join(',\\n\\t');\n  }\n  getScopedArray(name, scope, bufferType, bufferCount) {\n    if (this.scopedArrays.has(name) === false) {\n      this.scopedArrays.set(name, {\n        name,\n        scope,\n        bufferType,\n        bufferCount\n      });\n    }\n    return name;\n  }\n  getScopedArrays(shaderStage) {\n    if (shaderStage !== 'compute') {\n      return;\n    }\n    const snippets = [];\n    for (const {\n      name,\n      scope,\n      bufferType,\n      bufferCount\n    } of this.scopedArrays.values()) {\n      const type = this.getType(bufferType);\n      snippets.push(`var<${scope}> ${name}: array< ${type}, ${bufferCount} >;`);\n    }\n    return snippets.join('\\n');\n  }\n  getAttributes(shaderStage) {\n    const snippets = [];\n    if (shaderStage === 'compute') {\n      this.getBuiltin('global_invocation_id', 'id', 'vec3<u32>', 'attribute');\n      this.getBuiltin('workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute');\n      this.getBuiltin('local_invocation_id', 'localId', 'vec3<u32>', 'attribute');\n      this.getBuiltin('num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute');\n      if (this.renderer.hasFeature('subgroups')) {\n        this.enableDirective('subgroups', shaderStage);\n        this.getBuiltin('subgroup_size', 'subgroupSize', 'u32', 'attribute');\n      }\n    }\n    if (shaderStage === 'vertex' || shaderStage === 'compute') {\n      const builtins = this.getBuiltins('attribute');\n      if (builtins) snippets.push(builtins);\n      const attributes = this.getAttributesArray();\n      for (let index = 0, length = attributes.length; index < length; index++) {\n        const attribute = attributes[index];\n        const name = attribute.name;\n        const type = this.getType(attribute.type);\n        snippets.push(`@location( ${index} ) ${name} : ${type}`);\n      }\n    }\n    return snippets.join(',\\n\\t');\n  }\n  getStructMembers(struct) {\n    const snippets = [];\n    const members = struct.getMemberTypes();\n    for (let i = 0; i < members.length; i++) {\n      const member = members[i];\n      snippets.push(`\\t@location( ${i} ) m${i} : ${member}<f32>`);\n    }\n    const builtins = this.getBuiltins('output');\n    if (builtins) snippets.push('\\t' + builtins);\n    return snippets.join(',\\n');\n  }\n  getStructs(shaderStage) {\n    const snippets = [];\n    const structs = this.structs[shaderStage];\n    for (let index = 0, length = structs.length; index < length; index++) {\n      const struct = structs[index];\n      const name = struct.name;\n      let snippet = `\\struct ${name} {\\n`;\n      snippet += this.getStructMembers(struct);\n      snippet += '\\n}';\n      snippets.push(snippet);\n      snippets.push(`\\nvar<private> output : ${name};\\n\\n`);\n    }\n    return snippets.join('\\n\\n');\n  }\n  getVar(type, name) {\n    return `var ${name} : ${this.getType(type)}`;\n  }\n  getVars(shaderStage) {\n    const snippets = [];\n    const vars = this.vars[shaderStage];\n    if (vars !== undefined) {\n      for (const variable of vars) {\n        snippets.push(`\\t${this.getVar(variable.type, variable.name)};`);\n      }\n    }\n    return `\\n${snippets.join('\\n')}\\n`;\n  }\n  getVaryings(shaderStage) {\n    const snippets = [];\n    if (shaderStage === 'vertex') {\n      this.getBuiltin('position', 'Vertex', 'vec4<f32>', 'vertex');\n    }\n    if (shaderStage === 'vertex' || shaderStage === 'fragment') {\n      const varyings = this.varyings;\n      const vars = this.vars[shaderStage];\n      for (let index = 0; index < varyings.length; index++) {\n        const varying = varyings[index];\n        if (varying.needsInterpolation) {\n          let attributesSnippet = `@location( ${index} )`;\n          if (/^(int|uint|ivec|uvec)/.test(varying.type)) {\n            attributesSnippet += ' @interpolate( flat )';\n          }\n          snippets.push(`${attributesSnippet} ${varying.name} : ${this.getType(varying.type)}`);\n        } else if (shaderStage === 'vertex' && vars.includes(varying) === false) {\n          vars.push(varying);\n        }\n      }\n    }\n    const builtins = this.getBuiltins(shaderStage);\n    if (builtins) snippets.push(builtins);\n    const code = snippets.join(',\\n\\t');\n    return shaderStage === 'vertex' ? this._getWGSLStruct('VaryingsStruct', '\\t' + code) : code;\n  }\n  getUniforms(shaderStage) {\n    const uniforms = this.uniforms[shaderStage];\n    const bindingSnippets = [];\n    const bufferSnippets = [];\n    const structSnippets = [];\n    const uniformGroups = {};\n    for (const uniform of uniforms) {\n      const groupName = uniform.groupNode.name;\n      const uniformIndexes = this.bindingsIndexes[groupName];\n      if (uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D') {\n        const texture = uniform.node.value;\n        if (shaderStage === 'fragment' && this.isUnfilterable(texture) === false && uniform.node.isStorageTextureNode !== true) {\n          if (this.isSampleCompare(texture)) {\n            bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name}_sampler : sampler_comparison;`);\n          } else {\n            bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name}_sampler : sampler;`);\n          }\n        }\n        let textureType;\n        let multisampled = '';\n        if (texture.isMultisampleRenderTargetTexture === true) {\n          multisampled = '_multisampled';\n        }\n        if (texture.isCubeTexture === true) {\n          textureType = 'texture_cube<f32>';\n        } else if (texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true) {\n          textureType = 'texture_2d_array<f32>';\n        } else if (texture.isDepthTexture === true) {\n          textureType = `texture_depth${multisampled}_2d`;\n        } else if (texture.isVideoTexture === true) {\n          textureType = 'texture_external';\n        } else if (texture.isData3DTexture === true) {\n          textureType = 'texture_3d<f32>';\n        } else if (uniform.node.isStorageTextureNode === true) {\n          const format = getFormat(texture);\n          const access = this.getStorageAccess(uniform.node, shaderStage);\n          textureType = `texture_storage_2d<${format}, ${access}>`;\n        } else {\n          const componentPrefix = this.getComponentTypeFromTexture(texture).charAt(0);\n          textureType = `texture${multisampled}_2d<${componentPrefix}32>`;\n        }\n        bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name} : ${textureType};`);\n      } else if (uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer') {\n        const bufferNode = uniform.node;\n        const bufferType = this.getType(bufferNode.bufferType);\n        const bufferCount = bufferNode.bufferCount;\n        const bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';\n        const bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`;\n        const bufferSnippet = `\\t${uniform.name} : array< ${bufferTypeSnippet}${bufferCountSnippet} >\\n`;\n        const bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${this.getStorageAccess(bufferNode, shaderStage)}` : 'uniform';\n        bufferSnippets.push(this._getWGSLStructBinding('NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, uniformIndexes.binding++, uniformIndexes.group));\n      } else {\n        const vectorType = this.getType(this.getVectorType(uniform.type));\n        const groupName = uniform.groupNode.name;\n        const group = uniformGroups[groupName] || (uniformGroups[groupName] = {\n          index: uniformIndexes.binding++,\n          id: uniformIndexes.group,\n          snippets: []\n        });\n        group.snippets.push(`\\t${uniform.name} : ${vectorType}`);\n      }\n    }\n    for (const name in uniformGroups) {\n      const group = uniformGroups[name];\n      structSnippets.push(this._getWGSLStructBinding(name, group.snippets.join(',\\n'), 'uniform', group.index, group.id));\n    }\n    let code = bindingSnippets.join('\\n');\n    code += bufferSnippets.join('\\n');\n    code += structSnippets.join('\\n');\n    return code;\n  }\n  buildCode() {\n    const shadersData = this.material !== null ? {\n      fragment: {},\n      vertex: {}\n    } : {\n      compute: {}\n    };\n    this.sortBindingGroups();\n    for (const shaderStage in shadersData) {\n      const stageData = shadersData[shaderStage];\n      stageData.uniforms = this.getUniforms(shaderStage);\n      stageData.attributes = this.getAttributes(shaderStage);\n      stageData.varyings = this.getVaryings(shaderStage);\n      stageData.structs = this.getStructs(shaderStage);\n      stageData.vars = this.getVars(shaderStage);\n      stageData.codes = this.getCodes(shaderStage);\n      stageData.directives = this.getDirectives(shaderStage);\n      stageData.scopedArrays = this.getScopedArrays(shaderStage);\n\n      //\n\n      let flow = '// code\\n\\n';\n      flow += this.flowCode[shaderStage];\n      const flowNodes = this.flowNodes[shaderStage];\n      const mainNode = flowNodes[flowNodes.length - 1];\n      const outputNode = mainNode.outputNode;\n      const isOutputStruct = outputNode !== undefined && outputNode.isOutputStructNode === true;\n      for (const node of flowNodes) {\n        const flowSlotData = this.getFlowData(node /*, shaderStage*/);\n        const slotName = node.name;\n        if (slotName) {\n          if (flow.length > 0) flow += '\\n';\n          flow += `\\t// flow -> ${slotName}\\n\\t`;\n        }\n        flow += `${flowSlotData.code}\\n\\t`;\n        if (node === mainNode && shaderStage !== 'compute') {\n          flow += '// result\\n\\n\\t';\n          if (shaderStage === 'vertex') {\n            flow += `varyings.Vertex = ${flowSlotData.result};`;\n          } else if (shaderStage === 'fragment') {\n            if (isOutputStruct) {\n              stageData.returnType = outputNode.nodeType;\n              flow += `return ${flowSlotData.result};`;\n            } else {\n              let structSnippet = '\\t@location(0) color: vec4<f32>';\n              const builtins = this.getBuiltins('output');\n              if (builtins) structSnippet += ',\\n\\t' + builtins;\n              stageData.returnType = 'OutputStruct';\n              stageData.structs += this._getWGSLStruct('OutputStruct', structSnippet);\n              stageData.structs += '\\nvar<private> output : OutputStruct;\\n\\n';\n              flow += `output.color = ${flowSlotData.result};\\n\\n\\treturn output;`;\n            }\n          }\n        }\n      }\n      stageData.flow = flow;\n    }\n    if (this.material !== null) {\n      this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);\n      this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);\n    } else {\n      this.computeShader = this._getWGSLComputeCode(shadersData.compute, (this.object.workgroupSize || [64]).join(', '));\n    }\n  }\n  getMethod(method) {\n    let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let wgslMethod;\n    if (output !== null) {\n      wgslMethod = this._getWGSLMethod(method + '_' + output);\n    }\n    if (wgslMethod === undefined) {\n      wgslMethod = this._getWGSLMethod(method);\n    }\n    return wgslMethod || method;\n  }\n  getType(type) {\n    return wgslTypeLib[type] || type;\n  }\n  isAvailable(name) {\n    let result = supports[name];\n    if (result === undefined) {\n      if (name === 'float32Filterable') {\n        result = this.renderer.hasFeature('float32-filterable');\n      } else if (name === 'clipDistance') {\n        result = this.renderer.hasFeature('clip-distances');\n      }\n      supports[name] = result;\n    }\n    return result;\n  }\n  _getWGSLMethod(method) {\n    if (wgslPolyfill[method] !== undefined) {\n      this._include(method);\n    }\n    return wgslMethods[method];\n  }\n  _include(name) {\n    const codeNode = wgslPolyfill[name];\n    codeNode.build(this);\n    if (this.currentFunctionNode !== null) {\n      this.currentFunctionNode.includes.push(codeNode);\n    }\n    return codeNode;\n  }\n  _getWGSLVertexCode(shaderData) {\n    return `${this.getSignature()}\n// directives\n${shaderData.directives}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( ${shaderData.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn varyings;\n\n}\n`;\n  }\n  _getWGSLFragmentCode(shaderData) {\n    return `${this.getSignature()}\n// global\n${diagnostics}\n\n// uniforms\n${shaderData.uniforms}\n\n// structs\n${shaderData.structs}\n\n// codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  _getWGSLComputeCode(shaderData, workgroupSize) {\n    return `${this.getSignature()}\n// directives\n${shaderData.directives}\n\n// system\nvar<private> instanceIndex : u32;\n\n// locals\n${shaderData.scopedArrays}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@compute @workgroup_size( ${workgroupSize} )\nfn main( ${shaderData.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x + id.y * numWorkgroups.x * u32(${workgroupSize}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${workgroupSize});\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  _getWGSLStruct(name, vars) {\n    return `\nstruct ${name} {\n${vars}\n};`;\n  }\n  _getWGSLStructBinding(name, vars, access) {\n    let binding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let group = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    const structName = name + 'Struct';\n    const structSnippet = this._getWGSLStruct(structName, vars);\n    return `${structSnippet}\n@binding( ${binding} ) @group( ${group} )\nvar<${access}> ${name} : ${structName};`;\n  }\n}\nclass WebGPUUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  getCurrentDepthStencilFormat(renderContext) {\n    let format;\n    if (renderContext.depthTexture !== null) {\n      format = this.getTextureFormatGPU(renderContext.depthTexture);\n    } else if (renderContext.depth && renderContext.stencil) {\n      format = GPUTextureFormat.Depth24PlusStencil8;\n    } else if (renderContext.depth) {\n      format = GPUTextureFormat.Depth24Plus;\n    }\n    return format;\n  }\n  getTextureFormatGPU(texture) {\n    return this.backend.get(texture).format;\n  }\n  getCurrentColorFormat(renderContext) {\n    let format;\n    if (renderContext.textures !== null) {\n      format = this.getTextureFormatGPU(renderContext.textures[0]);\n    } else {\n      format = this.getPreferredCanvasFormat(); // default context format\n    }\n    return format;\n  }\n  getCurrentColorSpace(renderContext) {\n    if (renderContext.textures !== null) {\n      return renderContext.textures[0].colorSpace;\n    }\n    return this.backend.renderer.outputColorSpace;\n  }\n  getPrimitiveTopology(object, material) {\n    if (object.isPoints) return GPUPrimitiveTopology.PointList;else if (object.isLineSegments || object.isMesh && material.wireframe === true) return GPUPrimitiveTopology.LineList;else if (object.isLine) return GPUPrimitiveTopology.LineStrip;else if (object.isMesh) return GPUPrimitiveTopology.TriangleList;\n  }\n  getSampleCount(sampleCount) {\n    let count = 1;\n    if (sampleCount > 1) {\n      // WebGPU only supports power-of-two sample counts and 2 is not a valid value\n      count = Math.pow(2, Math.floor(Math.log2(sampleCount)));\n      if (count === 2) {\n        count = 4;\n      }\n    }\n    return count;\n  }\n  getSampleCountRenderContext(renderContext) {\n    if (renderContext.textures !== null) {\n      return this.getSampleCount(renderContext.sampleCount);\n    }\n    return this.getSampleCount(this.backend.renderer.samples);\n  }\n  getPreferredCanvasFormat() {\n    // TODO: Remove this check when Quest 34.5 is out\n    // https://github.com/mrdoob/three.js/pull/29221/files#r1731833949\n\n    if (navigator.userAgent.includes('Quest')) {\n      return GPUTextureFormat.BGRA8Unorm;\n    } else {\n      return navigator.gpu.getPreferredCanvasFormat();\n    }\n  }\n}\nconst typedArraysToVertexFormatPrefix = new Map([[Int8Array, ['sint8', 'snorm8']], [Uint8Array, ['uint8', 'unorm8']], [Int16Array, ['sint16', 'snorm16']], [Uint16Array, ['uint16', 'unorm16']], [Int32Array, ['sint32', 'snorm32']], [Uint32Array, ['uint32', 'unorm32']], [Float32Array, ['float32']]]);\nconst typedAttributeToVertexFormatPrefix = new Map([[Float16BufferAttribute, ['float16']]]);\nconst typeArraysToVertexFormatPrefixForItemSize1 = new Map([[Int32Array, 'sint32'], [Int16Array, 'sint32'],\n// patch for INT16\n[Uint32Array, 'uint32'], [Uint16Array, 'uint32'],\n// patch for UINT16\n[Float32Array, 'float32']]);\nclass WebGPUAttributeUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  createAttribute(attribute, usage) {\n    const bufferAttribute = this._getBufferAttribute(attribute);\n    const backend = this.backend;\n    const bufferData = backend.get(bufferAttribute);\n    let buffer = bufferData.buffer;\n    if (buffer === undefined) {\n      const device = backend.device;\n      let array = bufferAttribute.array;\n\n      // patch for INT16 and UINT16\n      if (attribute.normalized === false && (array.constructor === Int16Array || array.constructor === Uint16Array)) {\n        const tempArray = new Uint32Array(array.length);\n        for (let i = 0; i < array.length; i++) {\n          tempArray[i] = array[i];\n        }\n        array = tempArray;\n      }\n      bufferAttribute.array = array;\n      if ((bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute) && bufferAttribute.itemSize === 3) {\n        array = new array.constructor(bufferAttribute.count * 4);\n        for (let i = 0; i < bufferAttribute.count; i++) {\n          array.set(bufferAttribute.array.subarray(i * 3, i * 3 + 3), i * 4);\n        }\n\n        // Update BufferAttribute\n        bufferAttribute.itemSize = 4;\n        bufferAttribute.array = array;\n      }\n      const size = array.byteLength + (4 - array.byteLength % 4) % 4; // ensure 4 byte alignment, see #20441\n\n      buffer = device.createBuffer({\n        label: bufferAttribute.name,\n        size: size,\n        usage: usage,\n        mappedAtCreation: true\n      });\n      new array.constructor(buffer.getMappedRange()).set(array);\n      buffer.unmap();\n      bufferData.buffer = buffer;\n    }\n  }\n  updateAttribute(attribute) {\n    const bufferAttribute = this._getBufferAttribute(attribute);\n    const backend = this.backend;\n    const device = backend.device;\n    const buffer = backend.get(bufferAttribute).buffer;\n    const array = bufferAttribute.array;\n    const isTypedArray = this._isTypedArray(array);\n    const updateRanges = bufferAttribute.updateRanges;\n    if (updateRanges.length === 0) {\n      // Not using update ranges\n\n      device.queue.writeBuffer(buffer, 0, array, 0);\n    } else {\n      const byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;\n      for (let i = 0, l = updateRanges.length; i < l; i++) {\n        const range = updateRanges[i];\n        const dataOffset = range.start * byteOffsetFactor;\n        const size = range.count * byteOffsetFactor;\n        device.queue.writeBuffer(buffer, 0, array, dataOffset, size);\n      }\n      bufferAttribute.clearUpdateRanges();\n    }\n  }\n  createShaderVertexBuffers(renderObject) {\n    const attributes = renderObject.getAttributes();\n    const vertexBuffers = new Map();\n    for (let slot = 0; slot < attributes.length; slot++) {\n      const geometryAttribute = attributes[slot];\n      const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;\n      const bufferAttribute = this._getBufferAttribute(geometryAttribute);\n      let vertexBufferLayout = vertexBuffers.get(bufferAttribute);\n      if (vertexBufferLayout === undefined) {\n        let arrayStride, stepMode;\n        if (geometryAttribute.isInterleavedBufferAttribute === true) {\n          arrayStride = geometryAttribute.data.stride * bytesPerElement;\n          stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n        } else {\n          arrayStride = geometryAttribute.itemSize * bytesPerElement;\n          stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n        }\n\n        // patch for INT16 and UINT16\n        if (geometryAttribute.normalized === false && (geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array)) {\n          arrayStride = 4;\n        }\n        vertexBufferLayout = {\n          arrayStride,\n          attributes: [],\n          stepMode\n        };\n        vertexBuffers.set(bufferAttribute, vertexBufferLayout);\n      }\n      const format = this._getVertexFormat(geometryAttribute);\n      const offset = geometryAttribute.isInterleavedBufferAttribute === true ? geometryAttribute.offset * bytesPerElement : 0;\n      vertexBufferLayout.attributes.push({\n        shaderLocation: slot,\n        offset,\n        format\n      });\n    }\n    return Array.from(vertexBuffers.values());\n  }\n  destroyAttribute(attribute) {\n    const backend = this.backend;\n    const data = backend.get(this._getBufferAttribute(attribute));\n    data.buffer.destroy();\n    backend.delete(attribute);\n  }\n  async getArrayBufferAsync(attribute) {\n    const backend = this.backend;\n    const device = backend.device;\n    const data = backend.get(this._getBufferAttribute(attribute));\n    const bufferGPU = data.buffer;\n    const size = bufferGPU.size;\n    const readBufferGPU = device.createBuffer({\n      label: attribute.name,\n      size,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n    });\n    const cmdEncoder = device.createCommandEncoder({});\n    cmdEncoder.copyBufferToBuffer(bufferGPU, 0, readBufferGPU, 0, size);\n    readBufferGPU.unmap();\n    const gpuCommands = cmdEncoder.finish();\n    device.queue.submit([gpuCommands]);\n    await readBufferGPU.mapAsync(GPUMapMode.READ);\n    const arrayBuffer = readBufferGPU.getMappedRange();\n    return arrayBuffer;\n  }\n  _getVertexFormat(geometryAttribute) {\n    const {\n      itemSize,\n      normalized\n    } = geometryAttribute;\n    const ArrayType = geometryAttribute.array.constructor;\n    const AttributeType = geometryAttribute.constructor;\n    let format;\n    if (itemSize == 1) {\n      format = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);\n    } else {\n      const prefixOptions = typedAttributeToVertexFormatPrefix.get(AttributeType) || typedArraysToVertexFormatPrefix.get(ArrayType);\n      const prefix = prefixOptions[normalized ? 1 : 0];\n      if (prefix) {\n        const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;\n        const paddedBytesPerUnit = Math.floor((bytesPerUnit + 3) / 4) * 4;\n        const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;\n        if (paddedItemSize % 1) {\n          throw new Error('THREE.WebGPUAttributeUtils: Bad vertex format item size.');\n        }\n        format = `${prefix}x${paddedItemSize}`;\n      }\n    }\n    if (!format) {\n      console.error('THREE.WebGPUAttributeUtils: Vertex format not supported yet.');\n    }\n    return format;\n  }\n  _isTypedArray(array) {\n    return ArrayBuffer.isView(array) && !(array instanceof DataView);\n  }\n  _getBufferAttribute(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    return attribute;\n  }\n}\nclass WebGPUBindingUtils {\n  constructor(backend) {\n    this.backend = backend;\n    this.bindGroupLayoutCache = new WeakMap();\n  }\n  createBindingsLayout(bindGroup) {\n    const backend = this.backend;\n    const device = backend.device;\n    const entries = [];\n    let index = 0;\n    for (const binding of bindGroup.bindings) {\n      const bindingGPU = {\n        binding: index++,\n        visibility: binding.visibility\n      };\n      if (binding.isUniformBuffer || binding.isStorageBuffer) {\n        const buffer = {}; // GPUBufferBindingLayout\n\n        if (binding.isStorageBuffer) {\n          if (binding.visibility & 4) {\n            // compute\n\n            if (binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY) {\n              buffer.type = GPUBufferBindingType.Storage;\n            } else {\n              buffer.type = GPUBufferBindingType.ReadOnlyStorage;\n            }\n          } else {\n            buffer.type = GPUBufferBindingType.ReadOnlyStorage;\n          }\n        }\n        bindingGPU.buffer = buffer;\n      } else if (binding.isSampler) {\n        const sampler = {}; // GPUSamplerBindingLayout\n\n        if (binding.texture.isDepthTexture) {\n          if (binding.texture.compareFunction !== null) {\n            sampler.type = 'comparison';\n          }\n        }\n        bindingGPU.sampler = sampler;\n      } else if (binding.isSampledTexture && binding.texture.isVideoTexture) {\n        bindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout\n      } else if (binding.isSampledTexture && binding.store) {\n        const storageTexture = {}; // GPUStorageTextureBindingLayout\n        storageTexture.format = this.backend.get(binding.texture).texture.format;\n        const access = binding.access;\n        if (access === NodeAccess.READ_WRITE) {\n          storageTexture.access = GPUStorageTextureAccess.ReadWrite;\n        } else if (access === NodeAccess.WRITE_ONLY) {\n          storageTexture.access = GPUStorageTextureAccess.WriteOnly;\n        } else {\n          storageTexture.access = GPUStorageTextureAccess.ReadOnly;\n        }\n        bindingGPU.storageTexture = storageTexture;\n      } else if (binding.isSampledTexture) {\n        const texture = {}; // GPUTextureBindingLayout\n\n        if (binding.texture.isMultisampleRenderTargetTexture === true) {\n          texture.multisampled = true;\n        }\n        if (binding.texture.isDepthTexture) {\n          texture.sampleType = GPUTextureSampleType.Depth;\n        } else if (binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture) {\n          const type = binding.texture.type;\n          if (type === IntType) {\n            texture.sampleType = GPUTextureSampleType.SInt;\n          } else if (type === UnsignedIntType) {\n            texture.sampleType = GPUTextureSampleType.UInt;\n          } else if (type === FloatType) {\n            if (this.backend.hasFeature('float32-filterable')) {\n              texture.sampleType = GPUTextureSampleType.Float;\n            } else {\n              texture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n            }\n          }\n        }\n        if (binding.isSampledCubeTexture) {\n          texture.viewDimension = GPUTextureViewDimension.Cube;\n        } else if (binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) {\n          texture.viewDimension = GPUTextureViewDimension.TwoDArray;\n        } else if (binding.isSampledTexture3D) {\n          texture.viewDimension = GPUTextureViewDimension.ThreeD;\n        }\n        bindingGPU.texture = texture;\n      } else {\n        console.error(`WebGPUBindingUtils: Unsupported binding \"${binding}\".`);\n      }\n      entries.push(bindingGPU);\n    }\n    return device.createBindGroupLayout({\n      entries\n    });\n  }\n  createBindings(bindGroup, bindings, cacheIndex) {\n    let version = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const {\n      backend,\n      bindGroupLayoutCache\n    } = this;\n    const bindingsData = backend.get(bindGroup);\n\n    // setup (static) binding layout and (dynamic) binding group\n\n    let bindLayoutGPU = bindGroupLayoutCache.get(bindGroup.bindingsReference);\n    if (bindLayoutGPU === undefined) {\n      bindLayoutGPU = this.createBindingsLayout(bindGroup);\n      bindGroupLayoutCache.set(bindGroup.bindingsReference, bindLayoutGPU);\n    }\n    let bindGroupGPU;\n    if (cacheIndex > 0) {\n      if (bindingsData.groups === undefined) {\n        bindingsData.groups = [];\n        bindingsData.versions = [];\n      }\n      if (bindingsData.versions[cacheIndex] === version) {\n        bindGroupGPU = bindingsData.groups[cacheIndex];\n      }\n    }\n    if (bindGroupGPU === undefined) {\n      bindGroupGPU = this.createBindGroup(bindGroup, bindLayoutGPU);\n      if (cacheIndex > 0) {\n        bindingsData.groups[cacheIndex] = bindGroupGPU;\n        bindingsData.versions[cacheIndex] = version;\n      }\n    }\n    bindingsData.group = bindGroupGPU;\n    bindingsData.layout = bindLayoutGPU;\n  }\n  updateBinding(binding) {\n    const backend = this.backend;\n    const device = backend.device;\n    const buffer = binding.buffer;\n    const bufferGPU = backend.get(binding).buffer;\n    device.queue.writeBuffer(bufferGPU, 0, buffer, 0);\n  }\n  createBindGroup(bindGroup, layoutGPU) {\n    const backend = this.backend;\n    const device = backend.device;\n    let bindingPoint = 0;\n    const entriesGPU = [];\n    for (const binding of bindGroup.bindings) {\n      if (binding.isUniformBuffer) {\n        const bindingData = backend.get(binding);\n        if (bindingData.buffer === undefined) {\n          const byteLength = binding.byteLength;\n          const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n          const bufferGPU = device.createBuffer({\n            label: 'bindingBuffer_' + binding.name,\n            size: byteLength,\n            usage: usage\n          });\n          bindingData.buffer = bufferGPU;\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: {\n            buffer: bindingData.buffer\n          }\n        });\n      } else if (binding.isStorageBuffer) {\n        const bindingData = backend.get(binding);\n        if (bindingData.buffer === undefined) {\n          const attribute = binding.attribute;\n          //const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;\n\n          //backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer\n\n          bindingData.buffer = backend.get(attribute).buffer;\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: {\n            buffer: bindingData.buffer\n          }\n        });\n      } else if (binding.isSampler) {\n        const textureGPU = backend.get(binding.texture);\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: textureGPU.sampler\n        });\n      } else if (binding.isSampledTexture) {\n        const textureData = backend.get(binding.texture);\n        let resourceGPU;\n        if (textureData.externalTexture !== undefined) {\n          resourceGPU = device.importExternalTexture({\n            source: textureData.externalTexture\n          });\n        } else {\n          const mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;\n          const propertyName = `view-${textureData.texture.width}-${textureData.texture.height}-${mipLevelCount}`;\n          resourceGPU = textureData[propertyName];\n          if (resourceGPU === undefined) {\n            const aspectGPU = GPUTextureAspect.All;\n            let dimensionViewGPU;\n            if (binding.isSampledCubeTexture) {\n              dimensionViewGPU = GPUTextureViewDimension.Cube;\n            } else if (binding.isSampledTexture3D) {\n              dimensionViewGPU = GPUTextureViewDimension.ThreeD;\n            } else if (binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) {\n              dimensionViewGPU = GPUTextureViewDimension.TwoDArray;\n            } else {\n              dimensionViewGPU = GPUTextureViewDimension.TwoD;\n            }\n            resourceGPU = textureData[propertyName] = textureData.texture.createView({\n              aspect: aspectGPU,\n              dimension: dimensionViewGPU,\n              mipLevelCount\n            });\n          }\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: resourceGPU\n        });\n      }\n      bindingPoint++;\n    }\n    return device.createBindGroup({\n      label: 'bindGroup_' + bindGroup.name,\n      layout: layoutGPU,\n      entries: entriesGPU\n    });\n  }\n}\nclass WebGPUPipelineUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  _getSampleCount(renderObjectContext) {\n    return this.backend.utils.getSampleCountRenderContext(renderObjectContext);\n  }\n  createRenderPipeline(renderObject, promises) {\n    const {\n      object,\n      material,\n      geometry,\n      pipeline\n    } = renderObject;\n    const {\n      vertexProgram,\n      fragmentProgram\n    } = pipeline;\n    const backend = this.backend;\n    const device = backend.device;\n    const utils = backend.utils;\n    const pipelineData = backend.get(pipeline);\n\n    // bind group layouts\n\n    const bindGroupLayouts = [];\n    for (const bindGroup of renderObject.getBindings()) {\n      const bindingsData = backend.get(bindGroup);\n      bindGroupLayouts.push(bindingsData.layout);\n    }\n\n    // vertex buffers\n\n    const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers(renderObject);\n\n    // blending\n\n    let blending;\n    if (material.transparent === true && material.blending !== NoBlending) {\n      blending = this._getBlending(material);\n    }\n\n    // stencil\n\n    let stencilFront = {};\n    if (material.stencilWrite === true) {\n      stencilFront = {\n        compare: this._getStencilCompare(material),\n        failOp: this._getStencilOperation(material.stencilFail),\n        depthFailOp: this._getStencilOperation(material.stencilZFail),\n        passOp: this._getStencilOperation(material.stencilZPass)\n      };\n    }\n    const colorWriteMask = this._getColorWriteMask(material);\n    const targets = [];\n    if (renderObject.context.textures !== null) {\n      const textures = renderObject.context.textures;\n      for (let i = 0; i < textures.length; i++) {\n        const colorFormat = utils.getTextureFormatGPU(textures[i]);\n        targets.push({\n          format: colorFormat,\n          blend: blending,\n          writeMask: colorWriteMask\n        });\n      }\n    } else {\n      const colorFormat = utils.getCurrentColorFormat(renderObject.context);\n      targets.push({\n        format: colorFormat,\n        blend: blending,\n        writeMask: colorWriteMask\n      });\n    }\n    const vertexModule = backend.get(vertexProgram).module;\n    const fragmentModule = backend.get(fragmentProgram).module;\n    const primitiveState = this._getPrimitiveState(object, geometry, material);\n    const depthCompare = this._getDepthCompare(material);\n    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);\n    const sampleCount = this._getSampleCount(renderObject.context);\n    const pipelineDescriptor = {\n      label: `renderPipeline_${material.name || material.type}_${material.id}`,\n      vertex: Object.assign({}, vertexModule, {\n        buffers: vertexBuffers\n      }),\n      fragment: Object.assign({}, fragmentModule, {\n        targets\n      }),\n      primitive: primitiveState,\n      multisample: {\n        count: sampleCount,\n        alphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1\n      },\n      layout: device.createPipelineLayout({\n        bindGroupLayouts\n      })\n    };\n    const depthStencil = {};\n    const renderDepth = renderObject.context.depth;\n    const renderStencil = renderObject.context.stencil;\n    if (renderDepth === true || renderStencil === true) {\n      if (renderDepth === true) {\n        depthStencil.format = depthStencilFormat;\n        depthStencil.depthWriteEnabled = material.depthWrite;\n        depthStencil.depthCompare = depthCompare;\n      }\n      if (renderStencil === true) {\n        depthStencil.stencilFront = stencilFront;\n        depthStencil.stencilBack = {}; // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)\n        depthStencil.stencilReadMask = material.stencilFuncMask;\n        depthStencil.stencilWriteMask = material.stencilWriteMask;\n      }\n      pipelineDescriptor.depthStencil = depthStencil;\n    }\n    if (promises === null) {\n      pipelineData.pipeline = device.createRenderPipeline(pipelineDescriptor);\n    } else {\n      const p = new Promise((resolve /*, reject*/) => {\n        device.createRenderPipelineAsync(pipelineDescriptor).then(pipeline => {\n          pipelineData.pipeline = pipeline;\n          resolve();\n        });\n      });\n      promises.push(p);\n    }\n  }\n  createBundleEncoder(renderContext) {\n    const backend = this.backend;\n    const {\n      utils,\n      device\n    } = backend;\n    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderContext);\n    const colorFormat = utils.getCurrentColorFormat(renderContext);\n    const sampleCount = this._getSampleCount(renderContext);\n    const descriptor = {\n      label: 'renderBundleEncoder',\n      colorFormats: [colorFormat],\n      depthStencilFormat,\n      sampleCount\n    };\n    return device.createRenderBundleEncoder(descriptor);\n  }\n  createComputePipeline(pipeline, bindings) {\n    const backend = this.backend;\n    const device = backend.device;\n    const computeProgram = backend.get(pipeline.computeProgram).module;\n    const pipelineGPU = backend.get(pipeline);\n\n    // bind group layouts\n\n    const bindGroupLayouts = [];\n    for (const bindingsGroup of bindings) {\n      const bindingsData = backend.get(bindingsGroup);\n      bindGroupLayouts.push(bindingsData.layout);\n    }\n    pipelineGPU.pipeline = device.createComputePipeline({\n      compute: computeProgram,\n      layout: device.createPipelineLayout({\n        bindGroupLayouts\n      })\n    });\n  }\n  _getBlending(material) {\n    let color, alpha;\n    const blending = material.blending;\n    const blendSrc = material.blendSrc;\n    const blendDst = material.blendDst;\n    const blendEquation = material.blendEquation;\n    if (blending === CustomBlending) {\n      const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;\n      const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;\n      const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;\n      color = {\n        srcFactor: this._getBlendFactor(blendSrc),\n        dstFactor: this._getBlendFactor(blendDst),\n        operation: this._getBlendOperation(blendEquation)\n      };\n      alpha = {\n        srcFactor: this._getBlendFactor(blendSrcAlpha),\n        dstFactor: this._getBlendFactor(blendDstAlpha),\n        operation: this._getBlendOperation(blendEquationAlpha)\n      };\n    } else {\n      const premultipliedAlpha = material.premultipliedAlpha;\n      const setBlend = (srcRGB, dstRGB, srcAlpha, dstAlpha) => {\n        color = {\n          srcFactor: srcRGB,\n          dstFactor: dstRGB,\n          operation: GPUBlendOperation.Add\n        };\n        alpha = {\n          srcFactor: srcAlpha,\n          dstFactor: dstAlpha,\n          operation: GPUBlendOperation.Add\n        };\n      };\n      if (premultipliedAlpha) {\n        switch (blending) {\n          case NormalBlending:\n            setBlend(GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);\n            break;\n          case AdditiveBlending:\n            setBlend(GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);\n            break;\n          case SubtractiveBlending:\n            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);\n            break;\n          case MultiplyBlending:\n            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha);\n            break;\n        }\n      } else {\n        switch (blending) {\n          case NormalBlending:\n            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);\n            break;\n          case AdditiveBlending:\n            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One);\n            break;\n          case SubtractiveBlending:\n            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);\n            break;\n          case MultiplyBlending:\n            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src);\n            break;\n        }\n      }\n    }\n    if (color !== undefined && alpha !== undefined) {\n      return {\n        color,\n        alpha\n      };\n    } else {\n      console.error('THREE.WebGPURenderer: Invalid blending: ', blending);\n    }\n  }\n  _getBlendFactor(blend) {\n    let blendFactor;\n    switch (blend) {\n      case ZeroFactor:\n        blendFactor = GPUBlendFactor.Zero;\n        break;\n      case OneFactor:\n        blendFactor = GPUBlendFactor.One;\n        break;\n      case SrcColorFactor:\n        blendFactor = GPUBlendFactor.Src;\n        break;\n      case OneMinusSrcColorFactor:\n        blendFactor = GPUBlendFactor.OneMinusSrc;\n        break;\n      case SrcAlphaFactor:\n        blendFactor = GPUBlendFactor.SrcAlpha;\n        break;\n      case OneMinusSrcAlphaFactor:\n        blendFactor = GPUBlendFactor.OneMinusSrcAlpha;\n        break;\n      case DstColorFactor:\n        blendFactor = GPUBlendFactor.Dst;\n        break;\n      case OneMinusDstColorFactor:\n        blendFactor = GPUBlendFactor.OneMinusDstColor;\n        break;\n      case DstAlphaFactor:\n        blendFactor = GPUBlendFactor.DstAlpha;\n        break;\n      case OneMinusDstAlphaFactor:\n        blendFactor = GPUBlendFactor.OneMinusDstAlpha;\n        break;\n      case SrcAlphaSaturateFactor:\n        blendFactor = GPUBlendFactor.SrcAlphaSaturated;\n        break;\n      case BlendColorFactor:\n        blendFactor = GPUBlendFactor.Constant;\n        break;\n      case OneMinusBlendColorFactor:\n        blendFactor = GPUBlendFactor.OneMinusConstant;\n        break;\n      default:\n        console.error('THREE.WebGPURenderer: Blend factor not supported.', blend);\n    }\n    return blendFactor;\n  }\n  _getStencilCompare(material) {\n    let stencilCompare;\n    const stencilFunc = material.stencilFunc;\n    switch (stencilFunc) {\n      case NeverStencilFunc:\n        stencilCompare = GPUCompareFunction.Never;\n        break;\n      case AlwaysStencilFunc:\n        stencilCompare = GPUCompareFunction.Always;\n        break;\n      case LessStencilFunc:\n        stencilCompare = GPUCompareFunction.Less;\n        break;\n      case LessEqualStencilFunc:\n        stencilCompare = GPUCompareFunction.LessEqual;\n        break;\n      case EqualStencilFunc:\n        stencilCompare = GPUCompareFunction.Equal;\n        break;\n      case GreaterEqualStencilFunc:\n        stencilCompare = GPUCompareFunction.GreaterEqual;\n        break;\n      case GreaterStencilFunc:\n        stencilCompare = GPUCompareFunction.Greater;\n        break;\n      case NotEqualStencilFunc:\n        stencilCompare = GPUCompareFunction.NotEqual;\n        break;\n      default:\n        console.error('THREE.WebGPURenderer: Invalid stencil function.', stencilFunc);\n    }\n    return stencilCompare;\n  }\n  _getStencilOperation(op) {\n    let stencilOperation;\n    switch (op) {\n      case KeepStencilOp:\n        stencilOperation = GPUStencilOperation.Keep;\n        break;\n      case ZeroStencilOp:\n        stencilOperation = GPUStencilOperation.Zero;\n        break;\n      case ReplaceStencilOp:\n        stencilOperation = GPUStencilOperation.Replace;\n        break;\n      case InvertStencilOp:\n        stencilOperation = GPUStencilOperation.Invert;\n        break;\n      case IncrementStencilOp:\n        stencilOperation = GPUStencilOperation.IncrementClamp;\n        break;\n      case DecrementStencilOp:\n        stencilOperation = GPUStencilOperation.DecrementClamp;\n        break;\n      case IncrementWrapStencilOp:\n        stencilOperation = GPUStencilOperation.IncrementWrap;\n        break;\n      case DecrementWrapStencilOp:\n        stencilOperation = GPUStencilOperation.DecrementWrap;\n        break;\n      default:\n        console.error('THREE.WebGPURenderer: Invalid stencil operation.', stencilOperation);\n    }\n    return stencilOperation;\n  }\n  _getBlendOperation(blendEquation) {\n    let blendOperation;\n    switch (blendEquation) {\n      case AddEquation:\n        blendOperation = GPUBlendOperation.Add;\n        break;\n      case SubtractEquation:\n        blendOperation = GPUBlendOperation.Subtract;\n        break;\n      case ReverseSubtractEquation:\n        blendOperation = GPUBlendOperation.ReverseSubtract;\n        break;\n      case MinEquation:\n        blendOperation = GPUBlendOperation.Min;\n        break;\n      case MaxEquation:\n        blendOperation = GPUBlendOperation.Max;\n        break;\n      default:\n        console.error('THREE.WebGPUPipelineUtils: Blend equation not supported.', blendEquation);\n    }\n    return blendOperation;\n  }\n  _getPrimitiveState(object, geometry, material) {\n    const descriptor = {};\n    const utils = this.backend.utils;\n    descriptor.topology = utils.getPrimitiveTopology(object, material);\n    if (geometry.index !== null && object.isLine === true && object.isLineSegments !== true) {\n      descriptor.stripIndexFormat = geometry.index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n    }\n    switch (material.side) {\n      case FrontSide:\n        descriptor.frontFace = GPUFrontFace.CCW;\n        descriptor.cullMode = GPUCullMode.Back;\n        break;\n      case BackSide:\n        descriptor.frontFace = GPUFrontFace.CCW;\n        descriptor.cullMode = GPUCullMode.Front;\n        break;\n      case DoubleSide:\n        descriptor.frontFace = GPUFrontFace.CCW;\n        descriptor.cullMode = GPUCullMode.None;\n        break;\n      default:\n        console.error('THREE.WebGPUPipelineUtils: Unknown material.side value.', material.side);\n        break;\n    }\n    return descriptor;\n  }\n  _getColorWriteMask(material) {\n    return material.colorWrite === true ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;\n  }\n  _getDepthCompare(material) {\n    let depthCompare;\n    if (material.depthTest === false) {\n      depthCompare = GPUCompareFunction.Always;\n    } else {\n      const depthFunc = material.depthFunc;\n      switch (depthFunc) {\n        case NeverDepth:\n          depthCompare = GPUCompareFunction.Never;\n          break;\n        case AlwaysDepth:\n          depthCompare = GPUCompareFunction.Always;\n          break;\n        case LessDepth:\n          depthCompare = GPUCompareFunction.Less;\n          break;\n        case LessEqualDepth:\n          depthCompare = GPUCompareFunction.LessEqual;\n          break;\n        case EqualDepth:\n          depthCompare = GPUCompareFunction.Equal;\n          break;\n        case GreaterEqualDepth:\n          depthCompare = GPUCompareFunction.GreaterEqual;\n          break;\n        case GreaterDepth:\n          depthCompare = GPUCompareFunction.Greater;\n          break;\n        case NotEqualDepth:\n          depthCompare = GPUCompareFunction.NotEqual;\n          break;\n        default:\n          console.error('THREE.WebGPUPipelineUtils: Invalid depth function.', depthFunc);\n      }\n    }\n    return depthCompare;\n  }\n}\n\n/*// debugger tools\nimport 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';\n//*/\n\n//\n\nclass WebGPUBackend extends Backend {\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.isWebGPUBackend = true;\n\n    // some parameters require default values other than \"undefined\"\n    this.parameters.alpha = parameters.alpha === undefined ? true : parameters.alpha;\n    this.parameters.requiredLimits = parameters.requiredLimits === undefined ? {} : parameters.requiredLimits;\n    this.trackTimestamp = parameters.trackTimestamp === true;\n    this.device = null;\n    this.context = null;\n    this.colorBuffer = null;\n    this.defaultRenderPassdescriptor = null;\n    this.utils = new WebGPUUtils(this);\n    this.attributeUtils = new WebGPUAttributeUtils(this);\n    this.bindingUtils = new WebGPUBindingUtils(this);\n    this.pipelineUtils = new WebGPUPipelineUtils(this);\n    this.textureUtils = new WebGPUTextureUtils(this);\n    this.occludedResolveCache = new Map();\n  }\n  async init(renderer) {\n    await super.init(renderer);\n\n    //\n\n    const parameters = this.parameters;\n\n    // create the device if it is not passed with parameters\n\n    let device;\n    if (parameters.device === undefined) {\n      const adapterOptions = {\n        powerPreference: parameters.powerPreference\n      };\n      const adapter = typeof navigator !== 'undefined' ? await navigator.gpu.requestAdapter(adapterOptions) : null;\n      if (adapter === null) {\n        throw new Error('WebGPUBackend: Unable to create WebGPU adapter.');\n      }\n\n      // feature support\n\n      const features = Object.values(GPUFeatureName);\n      const supportedFeatures = [];\n      for (const name of features) {\n        if (adapter.features.has(name)) {\n          supportedFeatures.push(name);\n        }\n      }\n      const deviceDescriptor = {\n        requiredFeatures: supportedFeatures,\n        requiredLimits: parameters.requiredLimits\n      };\n      device = await adapter.requestDevice(deviceDescriptor);\n    } else {\n      device = parameters.device;\n    }\n    device.lost.then(info => {\n      const deviceLossInfo = {\n        api: 'WebGPU',\n        message: info.message || 'Unknown reason',\n        reason: info.reason || null,\n        originalEvent: info\n      };\n      renderer.onDeviceLost(deviceLossInfo);\n    });\n    const context = parameters.context !== undefined ? parameters.context : renderer.domElement.getContext('webgpu');\n    this.device = device;\n    this.context = context;\n    const alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';\n    this.trackTimestamp = this.trackTimestamp && this.hasFeature(GPUFeatureName.TimestampQuery);\n    this.context.configure({\n      device: this.device,\n      format: this.utils.getPreferredCanvasFormat(),\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      alphaMode: alphaMode\n    });\n    this.updateSize();\n  }\n  get coordinateSystem() {\n    return WebGPUCoordinateSystem;\n  }\n  async getArrayBufferAsync(attribute) {\n    return await this.attributeUtils.getArrayBufferAsync(attribute);\n  }\n  getContext() {\n    return this.context;\n  }\n  _getDefaultRenderPassDescriptor() {\n    let descriptor = this.defaultRenderPassdescriptor;\n    if (descriptor === null) {\n      const renderer = this.renderer;\n      descriptor = {\n        colorAttachments: [{\n          view: null\n        }]\n      };\n      if (this.renderer.depth === true || this.renderer.stencil === true) {\n        descriptor.depthStencilAttachment = {\n          view: this.textureUtils.getDepthBuffer(renderer.depth, renderer.stencil).createView()\n        };\n      }\n      const colorAttachment = descriptor.colorAttachments[0];\n      if (this.renderer.samples > 0) {\n        colorAttachment.view = this.colorBuffer.createView();\n      } else {\n        colorAttachment.resolveTarget = undefined;\n      }\n      this.defaultRenderPassdescriptor = descriptor;\n    }\n    const colorAttachment = descriptor.colorAttachments[0];\n    if (this.renderer.samples > 0) {\n      colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n    } else {\n      colorAttachment.view = this.context.getCurrentTexture().createView();\n    }\n    return descriptor;\n  }\n  _getRenderPassDescriptor(renderContext) {\n    const renderTarget = renderContext.renderTarget;\n    const renderTargetData = this.get(renderTarget);\n    let descriptors = renderTargetData.descriptors;\n    if (descriptors === undefined || renderTargetData.width !== renderTarget.width || renderTargetData.height !== renderTarget.height || renderTargetData.activeMipmapLevel !== renderTarget.activeMipmapLevel || renderTargetData.samples !== renderTarget.samples) {\n      descriptors = {};\n      renderTargetData.descriptors = descriptors;\n\n      // dispose\n\n      const onDispose = () => {\n        renderTarget.removeEventListener('dispose', onDispose);\n        this.delete(renderTarget);\n      };\n      renderTarget.addEventListener('dispose', onDispose);\n    }\n    const cacheKey = renderContext.getCacheKey();\n    let descriptor = descriptors[cacheKey];\n    if (descriptor === undefined) {\n      const textures = renderContext.textures;\n      const colorAttachments = [];\n      for (let i = 0; i < textures.length; i++) {\n        const textureData = this.get(textures[i]);\n        const textureView = textureData.texture.createView({\n          baseMipLevel: renderContext.activeMipmapLevel,\n          mipLevelCount: 1,\n          baseArrayLayer: renderContext.activeCubeFace,\n          dimension: GPUTextureViewDimension.TwoD\n        });\n        let view, resolveTarget;\n        if (textureData.msaaTexture !== undefined) {\n          view = textureData.msaaTexture.createView();\n          resolveTarget = textureView;\n        } else {\n          view = textureView;\n          resolveTarget = undefined;\n        }\n        colorAttachments.push({\n          view,\n          resolveTarget,\n          loadOp: GPULoadOp.Load,\n          storeOp: GPUStoreOp.Store\n        });\n      }\n      descriptor = {\n        colorAttachments\n      };\n      if (renderContext.depth) {\n        const depthTextureData = this.get(renderContext.depthTexture);\n        const depthStencilAttachment = {\n          view: depthTextureData.texture.createView()\n        };\n        descriptor.depthStencilAttachment = depthStencilAttachment;\n      }\n      descriptors[cacheKey] = descriptor;\n      renderTargetData.width = renderTarget.width;\n      renderTargetData.height = renderTarget.height;\n      renderTargetData.samples = renderTarget.samples;\n      renderTargetData.activeMipmapLevel = renderTarget.activeMipmapLevel;\n    }\n    return descriptor;\n  }\n  beginRender(renderContext) {\n    const renderContextData = this.get(renderContext);\n    const device = this.device;\n    const occlusionQueryCount = renderContext.occlusionQueryCount;\n    let occlusionQuerySet;\n    if (occlusionQueryCount > 0) {\n      if (renderContextData.currentOcclusionQuerySet) renderContextData.currentOcclusionQuerySet.destroy();\n      if (renderContextData.currentOcclusionQueryBuffer) renderContextData.currentOcclusionQueryBuffer.destroy();\n\n      // Get a reference to the array of objects with queries. The renderContextData property\n      // can be changed by another render pass before the buffer.mapAsyc() completes.\n      renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;\n      renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;\n      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n      //\n\n      occlusionQuerySet = device.createQuerySet({\n        type: 'occlusion',\n        count: occlusionQueryCount,\n        label: `occlusionQuerySet_${renderContext.id}`\n      });\n      renderContextData.occlusionQuerySet = occlusionQuerySet;\n      renderContextData.occlusionQueryIndex = 0;\n      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);\n      renderContextData.lastOcclusionObject = null;\n    }\n    let descriptor;\n    if (renderContext.textures === null) {\n      descriptor = this._getDefaultRenderPassDescriptor();\n    } else {\n      descriptor = this._getRenderPassDescriptor(renderContext);\n    }\n    this.initTimestampQuery(renderContext, descriptor);\n    descriptor.occlusionQuerySet = occlusionQuerySet;\n    const depthStencilAttachment = descriptor.depthStencilAttachment;\n    if (renderContext.textures !== null) {\n      const colorAttachments = descriptor.colorAttachments;\n      for (let i = 0; i < colorAttachments.length; i++) {\n        const colorAttachment = colorAttachments[i];\n        if (renderContext.clearColor) {\n          colorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n          };\n          colorAttachment.loadOp = GPULoadOp.Clear;\n          colorAttachment.storeOp = GPUStoreOp.Store;\n        } else {\n          colorAttachment.loadOp = GPULoadOp.Load;\n          colorAttachment.storeOp = GPUStoreOp.Store;\n        }\n      }\n    } else {\n      const colorAttachment = descriptor.colorAttachments[0];\n      if (renderContext.clearColor) {\n        colorAttachment.clearValue = renderContext.clearColorValue;\n        colorAttachment.loadOp = GPULoadOp.Clear;\n        colorAttachment.storeOp = GPUStoreOp.Store;\n      } else {\n        colorAttachment.loadOp = GPULoadOp.Load;\n        colorAttachment.storeOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    if (renderContext.depth) {\n      if (renderContext.clearDepth) {\n        depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      }\n    }\n    if (renderContext.stencil) {\n      if (renderContext.clearStencil) {\n        depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    const encoder = device.createCommandEncoder({\n      label: 'renderContext_' + renderContext.id\n    });\n    const currentPass = encoder.beginRenderPass(descriptor);\n\n    //\n\n    renderContextData.descriptor = descriptor;\n    renderContextData.encoder = encoder;\n    renderContextData.currentPass = currentPass;\n    renderContextData.currentSets = {\n      attributes: {},\n      bindingGroups: [],\n      pipeline: null,\n      index: null\n    };\n    renderContextData.renderBundles = [];\n\n    //\n\n    if (renderContext.viewport) {\n      this.updateViewport(renderContext);\n    }\n    if (renderContext.scissor) {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = renderContext.scissorValue;\n      currentPass.setScissorRect(x, y, width, height);\n    }\n  }\n  finishRender(renderContext) {\n    const renderContextData = this.get(renderContext);\n    const occlusionQueryCount = renderContext.occlusionQueryCount;\n    if (renderContextData.renderBundles.length > 0) {\n      renderContextData.currentPass.executeBundles(renderContextData.renderBundles);\n    }\n    if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {\n      renderContextData.currentPass.endOcclusionQuery();\n    }\n    renderContextData.currentPass.end();\n    if (occlusionQueryCount > 0) {\n      const bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results\n\n      //\n\n      let queryResolveBuffer = this.occludedResolveCache.get(bufferSize);\n      if (queryResolveBuffer === undefined) {\n        queryResolveBuffer = this.device.createBuffer({\n          size: bufferSize,\n          usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n        });\n        this.occludedResolveCache.set(bufferSize, queryResolveBuffer);\n      }\n\n      //\n\n      const readBuffer = this.device.createBuffer({\n        size: bufferSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n      });\n\n      // two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined\n      renderContextData.encoder.resolveQuerySet(renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0);\n      renderContextData.encoder.copyBufferToBuffer(queryResolveBuffer, 0, readBuffer, 0, bufferSize);\n      renderContextData.occlusionQueryBuffer = readBuffer;\n\n      //\n\n      this.resolveOccludedAsync(renderContext);\n    }\n    this.prepareTimestampBuffer(renderContext, renderContextData.encoder);\n    this.device.queue.submit([renderContextData.encoder.finish()]);\n\n    //\n\n    if (renderContext.textures !== null) {\n      const textures = renderContext.textures;\n      for (let i = 0; i < textures.length; i++) {\n        const texture = textures[i];\n        if (texture.generateMipmaps === true) {\n          this.textureUtils.generateMipmaps(texture);\n        }\n      }\n    }\n  }\n  isOccluded(renderContext, object) {\n    const renderContextData = this.get(renderContext);\n    return renderContextData.occluded && renderContextData.occluded.has(object);\n  }\n  async resolveOccludedAsync(renderContext) {\n    const renderContextData = this.get(renderContext);\n\n    // handle occlusion query results\n\n    const {\n      currentOcclusionQueryBuffer,\n      currentOcclusionQueryObjects\n    } = renderContextData;\n    if (currentOcclusionQueryBuffer && currentOcclusionQueryObjects) {\n      const occluded = new WeakSet();\n      renderContextData.currentOcclusionQueryObjects = null;\n      renderContextData.currentOcclusionQueryBuffer = null;\n      await currentOcclusionQueryBuffer.mapAsync(GPUMapMode.READ);\n      const buffer = currentOcclusionQueryBuffer.getMappedRange();\n      const results = new BigUint64Array(buffer);\n      for (let i = 0; i < currentOcclusionQueryObjects.length; i++) {\n        if (results[i] !== BigInt(0)) {\n          occluded.add(currentOcclusionQueryObjects[i]);\n        }\n      }\n      currentOcclusionQueryBuffer.destroy();\n      renderContextData.occluded = occluded;\n    }\n  }\n  updateViewport(renderContext) {\n    const {\n      currentPass\n    } = this.get(renderContext);\n    const {\n      x,\n      y,\n      width,\n      height,\n      minDepth,\n      maxDepth\n    } = renderContext.viewportValue;\n    currentPass.setViewport(x, y, width, height, minDepth, maxDepth);\n  }\n  clear(color, depth, stencil) {\n    let renderTargetData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    const device = this.device;\n    const renderer = this.renderer;\n    let colorAttachments = [];\n    let depthStencilAttachment;\n    let clearValue;\n    let supportsDepth;\n    let supportsStencil;\n    if (color) {\n      const clearColor = this.getClearColor();\n      if (this.renderer.alpha === true) {\n        // premultiply alpha\n\n        const a = clearColor.a;\n        clearValue = {\n          r: clearColor.r * a,\n          g: clearColor.g * a,\n          b: clearColor.b * a,\n          a: a\n        };\n      } else {\n        clearValue = {\n          r: clearColor.r,\n          g: clearColor.g,\n          b: clearColor.b,\n          a: clearColor.a\n        };\n      }\n    }\n    if (renderTargetData === null) {\n      supportsDepth = renderer.depth;\n      supportsStencil = renderer.stencil;\n      const descriptor = this._getDefaultRenderPassDescriptor();\n      if (color) {\n        colorAttachments = descriptor.colorAttachments;\n        const colorAttachment = colorAttachments[0];\n        colorAttachment.clearValue = clearValue;\n        colorAttachment.loadOp = GPULoadOp.Clear;\n        colorAttachment.storeOp = GPUStoreOp.Store;\n      }\n      if (supportsDepth || supportsStencil) {\n        depthStencilAttachment = descriptor.depthStencilAttachment;\n      }\n    } else {\n      supportsDepth = renderTargetData.depth;\n      supportsStencil = renderTargetData.stencil;\n      if (color) {\n        for (const texture of renderTargetData.textures) {\n          const textureData = this.get(texture);\n          const textureView = textureData.texture.createView();\n          let view, resolveTarget;\n          if (textureData.msaaTexture !== undefined) {\n            view = textureData.msaaTexture.createView();\n            resolveTarget = textureView;\n          } else {\n            view = textureView;\n            resolveTarget = undefined;\n          }\n          colorAttachments.push({\n            view,\n            resolveTarget,\n            clearValue,\n            loadOp: GPULoadOp.Clear,\n            storeOp: GPUStoreOp.Store\n          });\n        }\n      }\n      if (supportsDepth || supportsStencil) {\n        const depthTextureData = this.get(renderTargetData.depthTexture);\n        depthStencilAttachment = {\n          view: depthTextureData.texture.createView()\n        };\n      }\n    }\n\n    //\n\n    if (supportsDepth) {\n      if (depth) {\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.depthClearValue = renderer.getClearDepth();\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    if (supportsStencil) {\n      if (stencil) {\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.stencilClearValue = renderer.getClearStencil();\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    const encoder = device.createCommandEncoder({});\n    const currentPass = encoder.beginRenderPass({\n      colorAttachments,\n      depthStencilAttachment\n    });\n    currentPass.end();\n    device.queue.submit([encoder.finish()]);\n  }\n\n  // compute\n\n  beginCompute(computeGroup) {\n    const groupGPU = this.get(computeGroup);\n    const descriptor = {};\n    this.initTimestampQuery(computeGroup, descriptor);\n    groupGPU.cmdEncoderGPU = this.device.createCommandEncoder();\n    groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass(descriptor);\n  }\n  compute(computeGroup, computeNode, bindings, pipeline) {\n    const {\n      passEncoderGPU\n    } = this.get(computeGroup);\n\n    // pipeline\n\n    const pipelineGPU = this.get(pipeline).pipeline;\n    passEncoderGPU.setPipeline(pipelineGPU);\n\n    // bind groups\n\n    for (let i = 0, l = bindings.length; i < l; i++) {\n      const bindGroup = bindings[i];\n      const bindingsData = this.get(bindGroup);\n      passEncoderGPU.setBindGroup(i, bindingsData.group);\n    }\n    const maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;\n    const computeNodeData = this.get(computeNode);\n    if (computeNodeData.dispatchSize === undefined) computeNodeData.dispatchSize = {\n      x: 0,\n      y: 1,\n      z: 1\n    };\n    const {\n      dispatchSize\n    } = computeNodeData;\n    if (computeNode.dispatchCount > maxComputeWorkgroupsPerDimension) {\n      dispatchSize.x = Math.min(computeNode.dispatchCount, maxComputeWorkgroupsPerDimension);\n      dispatchSize.y = Math.ceil(computeNode.dispatchCount / maxComputeWorkgroupsPerDimension);\n    } else {\n      dispatchSize.x = computeNode.dispatchCount;\n    }\n    passEncoderGPU.dispatchWorkgroups(dispatchSize.x, dispatchSize.y, dispatchSize.z);\n  }\n  finishCompute(computeGroup) {\n    const groupData = this.get(computeGroup);\n    groupData.passEncoderGPU.end();\n    this.prepareTimestampBuffer(computeGroup, groupData.cmdEncoderGPU);\n    this.device.queue.submit([groupData.cmdEncoderGPU.finish()]);\n  }\n  async waitForGPU() {\n    await this.device.queue.onSubmittedWorkDone();\n  }\n\n  // render object\n\n  draw(renderObject, info) {\n    const {\n      object,\n      context,\n      pipeline\n    } = renderObject;\n    const bindings = renderObject.getBindings();\n    const renderContextData = this.get(context);\n    const pipelineGPU = this.get(pipeline).pipeline;\n    const currentSets = renderContextData.currentSets;\n    const passEncoderGPU = renderContextData.currentPass;\n    const drawParams = renderObject.getDrawParameters();\n    if (drawParams === null) return;\n\n    // pipeline\n\n    if (currentSets.pipeline !== pipelineGPU) {\n      passEncoderGPU.setPipeline(pipelineGPU);\n      currentSets.pipeline = pipelineGPU;\n    }\n\n    // bind groups\n\n    const currentBindingGroups = currentSets.bindingGroups;\n    for (let i = 0, l = bindings.length; i < l; i++) {\n      const bindGroup = bindings[i];\n      const bindingsData = this.get(bindGroup);\n      if (currentBindingGroups[bindGroup.index] !== bindGroup.id) {\n        passEncoderGPU.setBindGroup(bindGroup.index, bindingsData.group);\n        currentBindingGroups[bindGroup.index] = bindGroup.id;\n      }\n    }\n\n    // attributes\n\n    const index = renderObject.getIndex();\n    const hasIndex = index !== null;\n\n    // index\n\n    if (hasIndex === true) {\n      if (currentSets.index !== index) {\n        const buffer = this.get(index).buffer;\n        const indexFormat = index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n        passEncoderGPU.setIndexBuffer(buffer, indexFormat);\n        currentSets.index = index;\n      }\n    }\n\n    // vertex buffers\n\n    const vertexBuffers = renderObject.getVertexBuffers();\n    for (let i = 0, l = vertexBuffers.length; i < l; i++) {\n      const vertexBuffer = vertexBuffers[i];\n      if (currentSets.attributes[i] !== vertexBuffer) {\n        const buffer = this.get(vertexBuffer).buffer;\n        passEncoderGPU.setVertexBuffer(i, buffer);\n        currentSets.attributes[i] = vertexBuffer;\n      }\n    }\n\n    // occlusion queries - handle multiple consecutive draw calls for an object\n\n    if (renderContextData.occlusionQuerySet !== undefined) {\n      const lastObject = renderContextData.lastOcclusionObject;\n      if (lastObject !== object) {\n        if (lastObject !== null && lastObject.occlusionTest === true) {\n          passEncoderGPU.endOcclusionQuery();\n          renderContextData.occlusionQueryIndex++;\n        }\n        if (object.occlusionTest === true) {\n          passEncoderGPU.beginOcclusionQuery(renderContextData.occlusionQueryIndex);\n          renderContextData.occlusionQueryObjects[renderContextData.occlusionQueryIndex] = object;\n        }\n        renderContextData.lastOcclusionObject = object;\n      }\n    }\n\n    // draw\n\n    if (object.isBatchedMesh === true) {\n      const starts = object._multiDrawStarts;\n      const counts = object._multiDrawCounts;\n      const drawCount = object._multiDrawCount;\n      const drawInstances = object._multiDrawInstances;\n      const bytesPerElement = hasIndex ? index.array.BYTES_PER_ELEMENT : 1;\n      for (let i = 0; i < drawCount; i++) {\n        const count = drawInstances ? drawInstances[i] : 1;\n        const firstInstance = count > 1 ? 0 : i;\n        passEncoderGPU.drawIndexed(counts[i], count, starts[i] / bytesPerElement, 0, firstInstance);\n      }\n    } else if (hasIndex === true) {\n      const {\n        vertexCount: indexCount,\n        instanceCount,\n        firstVertex: firstIndex\n      } = drawParams;\n      const indirect = renderObject.getIndirect();\n      if (indirect !== null) {\n        const buffer = this.get(indirect).buffer;\n        passEncoderGPU.drawIndexedIndirect(buffer, 0);\n      } else {\n        passEncoderGPU.drawIndexed(indexCount, instanceCount, firstIndex, 0, 0);\n      }\n      info.update(object, indexCount, instanceCount);\n    } else {\n      const {\n        vertexCount,\n        instanceCount,\n        firstVertex\n      } = drawParams;\n      const indirect = renderObject.getIndirect();\n      if (indirect !== null) {\n        const buffer = this.get(indirect).buffer;\n        passEncoderGPU.drawIndirect(buffer, 0);\n      } else {\n        passEncoderGPU.draw(vertexCount, instanceCount, firstVertex, 0);\n      }\n      info.update(object, vertexCount, instanceCount);\n    }\n  }\n\n  // cache key\n\n  needsRenderUpdate(renderObject) {\n    const data = this.get(renderObject);\n    const {\n      object,\n      material\n    } = renderObject;\n    const utils = this.utils;\n    const sampleCount = utils.getSampleCountRenderContext(renderObject.context);\n    const colorSpace = utils.getCurrentColorSpace(renderObject.context);\n    const colorFormat = utils.getCurrentColorFormat(renderObject.context);\n    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);\n    const primitiveTopology = utils.getPrimitiveTopology(object, material);\n    let needsUpdate = false;\n    if (data.material !== material || data.materialVersion !== material.version || data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha || data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation || data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha || data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc || data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc || data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass || data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask || data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage || data.sampleCount !== sampleCount || data.colorSpace !== colorSpace || data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat || data.primitiveTopology !== primitiveTopology || data.clippingContextCacheKey !== renderObject.clippingContextCacheKey) {\n      data.material = material;\n      data.materialVersion = material.version;\n      data.transparent = material.transparent;\n      data.blending = material.blending;\n      data.premultipliedAlpha = material.premultipliedAlpha;\n      data.blendSrc = material.blendSrc;\n      data.blendDst = material.blendDst;\n      data.blendEquation = material.blendEquation;\n      data.blendSrcAlpha = material.blendSrcAlpha;\n      data.blendDstAlpha = material.blendDstAlpha;\n      data.blendEquationAlpha = material.blendEquationAlpha;\n      data.colorWrite = material.colorWrite;\n      data.depthWrite = material.depthWrite;\n      data.depthTest = material.depthTest;\n      data.depthFunc = material.depthFunc;\n      data.stencilWrite = material.stencilWrite;\n      data.stencilFunc = material.stencilFunc;\n      data.stencilFail = material.stencilFail;\n      data.stencilZFail = material.stencilZFail;\n      data.stencilZPass = material.stencilZPass;\n      data.stencilFuncMask = material.stencilFuncMask;\n      data.stencilWriteMask = material.stencilWriteMask;\n      data.side = material.side;\n      data.alphaToCoverage = material.alphaToCoverage;\n      data.sampleCount = sampleCount;\n      data.colorSpace = colorSpace;\n      data.colorFormat = colorFormat;\n      data.depthStencilFormat = depthStencilFormat;\n      data.primitiveTopology = primitiveTopology;\n      data.clippingContextCacheKey = renderObject.clippingContextCacheKey;\n      needsUpdate = true;\n    }\n    return needsUpdate;\n  }\n  getRenderCacheKey(renderObject) {\n    const {\n      object,\n      material\n    } = renderObject;\n    const utils = this.utils;\n    const renderContext = renderObject.context;\n    return [material.transparent, material.blending, material.premultipliedAlpha, material.blendSrc, material.blendDst, material.blendEquation, material.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha, material.colorWrite, material.depthWrite, material.depthTest, material.depthFunc, material.stencilWrite, material.stencilFunc, material.stencilFail, material.stencilZFail, material.stencilZPass, material.stencilFuncMask, material.stencilWriteMask, material.side, utils.getSampleCountRenderContext(renderContext), utils.getCurrentColorSpace(renderContext), utils.getCurrentColorFormat(renderContext), utils.getCurrentDepthStencilFormat(renderContext), utils.getPrimitiveTopology(object, material), renderObject.getGeometryCacheKey(), renderObject.clippingContextCacheKey].join();\n  }\n\n  // textures\n\n  createSampler(texture) {\n    this.textureUtils.createSampler(texture);\n  }\n  destroySampler(texture) {\n    this.textureUtils.destroySampler(texture);\n  }\n  createDefaultTexture(texture) {\n    this.textureUtils.createDefaultTexture(texture);\n  }\n  createTexture(texture, options) {\n    this.textureUtils.createTexture(texture, options);\n  }\n  updateTexture(texture, options) {\n    this.textureUtils.updateTexture(texture, options);\n  }\n  generateMipmaps(texture) {\n    this.textureUtils.generateMipmaps(texture);\n  }\n  destroyTexture(texture) {\n    this.textureUtils.destroyTexture(texture);\n  }\n  copyTextureToBuffer(texture, x, y, width, height, faceIndex) {\n    return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);\n  }\n  initTimestampQuery(renderContext, descriptor) {\n    if (!this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (!renderContextData.timeStampQuerySet) {\n      const type = renderContext.isComputeNode ? 'compute' : 'render';\n      const timeStampQuerySet = this.device.createQuerySet({\n        type: 'timestamp',\n        count: 2,\n        label: `timestamp_${type}_${renderContext.id}`\n      });\n      const timestampWrites = {\n        querySet: timeStampQuerySet,\n        beginningOfPassWriteIndex: 0,\n        // Write timestamp in index 0 when pass begins.\n        endOfPassWriteIndex: 1 // Write timestamp in index 1 when pass ends.\n      };\n      Object.assign(descriptor, {\n        timestampWrites\n      });\n      renderContextData.timeStampQuerySet = timeStampQuerySet;\n    }\n  }\n\n  // timestamp utils\n\n  prepareTimestampBuffer(renderContext, encoder) {\n    if (!this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    const size = 2 * BigInt64Array.BYTES_PER_ELEMENT;\n    if (renderContextData.currentTimestampQueryBuffers === undefined) {\n      renderContextData.currentTimestampQueryBuffers = {\n        resolveBuffer: this.device.createBuffer({\n          label: 'timestamp resolve buffer',\n          size: size,\n          usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n        }),\n        resultBuffer: this.device.createBuffer({\n          label: 'timestamp result buffer',\n          size: size,\n          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n        })\n      };\n    }\n    const {\n      resolveBuffer,\n      resultBuffer\n    } = renderContextData.currentTimestampQueryBuffers;\n    encoder.resolveQuerySet(renderContextData.timeStampQuerySet, 0, 2, resolveBuffer, 0);\n    if (resultBuffer.mapState === 'unmapped') {\n      encoder.copyBufferToBuffer(resolveBuffer, 0, resultBuffer, 0, size);\n    }\n  }\n  async resolveTimestampAsync(renderContext) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'render';\n    if (!this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (renderContextData.currentTimestampQueryBuffers === undefined) return;\n    const {\n      resultBuffer\n    } = renderContextData.currentTimestampQueryBuffers;\n    await this.device.queue.onSubmittedWorkDone();\n    if (resultBuffer.mapState === 'unmapped') {\n      resultBuffer.mapAsync(GPUMapMode.READ).then(() => {\n        const times = new BigUint64Array(resultBuffer.getMappedRange());\n        const duration = Number(times[1] - times[0]) / 1000000;\n        this.renderer.info.updateTimestamp(type, duration);\n        resultBuffer.unmap();\n      });\n    }\n  }\n\n  // node builder\n\n  createNodeBuilder(object, renderer) {\n    return new WGSLNodeBuilder(object, renderer);\n  }\n\n  // program\n\n  createProgram(program) {\n    const programGPU = this.get(program);\n    programGPU.module = {\n      module: this.device.createShaderModule({\n        code: program.code,\n        label: program.stage\n      }),\n      entryPoint: 'main'\n    };\n  }\n  destroyProgram(program) {\n    this.delete(program);\n  }\n\n  // pipelines\n\n  createRenderPipeline(renderObject, promises) {\n    this.pipelineUtils.createRenderPipeline(renderObject, promises);\n  }\n  createComputePipeline(computePipeline, bindings) {\n    this.pipelineUtils.createComputePipeline(computePipeline, bindings);\n  }\n  beginBundle(renderContext) {\n    const renderContextData = this.get(renderContext);\n    renderContextData._currentPass = renderContextData.currentPass;\n    renderContextData._currentSets = renderContextData.currentSets;\n    renderContextData.currentSets = {\n      attributes: {},\n      bindingGroups: [],\n      pipeline: null,\n      index: null\n    };\n    renderContextData.currentPass = this.pipelineUtils.createBundleEncoder(renderContext);\n  }\n  finishBundle(renderContext, bundle) {\n    const renderContextData = this.get(renderContext);\n    const bundleEncoder = renderContextData.currentPass;\n    const bundleGPU = bundleEncoder.finish();\n    this.get(bundle).bundleGPU = bundleGPU;\n\n    // restore render pass state\n\n    renderContextData.currentSets = renderContextData._currentSets;\n    renderContextData.currentPass = renderContextData._currentPass;\n  }\n  addBundle(renderContext, bundle) {\n    const renderContextData = this.get(renderContext);\n    renderContextData.renderBundles.push(this.get(bundle).bundleGPU);\n  }\n\n  // bindings\n\n  createBindings(bindGroup, bindings, cacheIndex, version) {\n    this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);\n  }\n  updateBindings(bindGroup, bindings, cacheIndex, version) {\n    this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);\n  }\n  updateBinding(binding) {\n    this.bindingUtils.updateBinding(binding);\n  }\n\n  // attributes\n\n  createIndexAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  createAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  createStorageAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  createIndirectStorageAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  updateAttribute(attribute) {\n    this.attributeUtils.updateAttribute(attribute);\n  }\n  destroyAttribute(attribute) {\n    this.attributeUtils.destroyAttribute(attribute);\n  }\n\n  // canvas\n\n  updateSize() {\n    this.colorBuffer = this.textureUtils.getColorBuffer();\n    this.defaultRenderPassdescriptor = null;\n  }\n\n  // utils public\n\n  getMaxAnisotropy() {\n    return 16;\n  }\n  hasFeature(name) {\n    return this.device.features.has(name);\n  }\n  copyTextureToTexture(srcTexture, dstTexture) {\n    let srcRegion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let dstPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let dstX = 0;\n    let dstY = 0;\n    let dstLayer = 0;\n    let srcX = 0;\n    let srcY = 0;\n    let srcLayer = 0;\n    let srcWidth = srcTexture.image.width;\n    let srcHeight = srcTexture.image.height;\n    if (srcRegion !== null) {\n      srcX = srcRegion.x;\n      srcY = srcRegion.y;\n      srcLayer = srcRegion.z || 0;\n      srcWidth = srcRegion.width;\n      srcHeight = srcRegion.height;\n    }\n    if (dstPosition !== null) {\n      dstX = dstPosition.x;\n      dstY = dstPosition.y;\n      dstLayer = dstPosition.z || 0;\n    }\n    const encoder = this.device.createCommandEncoder({\n      label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id\n    });\n    const sourceGPU = this.get(srcTexture).texture;\n    const destinationGPU = this.get(dstTexture).texture;\n    encoder.copyTextureToTexture({\n      texture: sourceGPU,\n      mipLevel: level,\n      origin: {\n        x: srcX,\n        y: srcY,\n        z: srcLayer\n      }\n    }, {\n      texture: destinationGPU,\n      mipLevel: level,\n      origin: {\n        x: dstX,\n        y: dstY,\n        z: dstLayer\n      }\n    }, [srcWidth, srcHeight, 1]);\n    this.device.queue.submit([encoder.finish()]);\n  }\n  copyFramebufferToTexture(texture, renderContext, rectangle) {\n    const renderContextData = this.get(renderContext);\n    let sourceGPU = null;\n    if (renderContext.renderTarget) {\n      if (texture.isDepthTexture) {\n        sourceGPU = this.get(renderContext.depthTexture).texture;\n      } else {\n        sourceGPU = this.get(renderContext.textures[0]).texture;\n      }\n    } else {\n      if (texture.isDepthTexture) {\n        sourceGPU = this.textureUtils.getDepthBuffer(renderContext.depth, renderContext.stencil);\n      } else {\n        sourceGPU = this.context.getCurrentTexture();\n      }\n    }\n    const destinationGPU = this.get(texture).texture;\n    if (sourceGPU.format !== destinationGPU.format) {\n      console.error('WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format);\n      return;\n    }\n    let encoder;\n    if (renderContextData.currentPass) {\n      renderContextData.currentPass.end();\n      encoder = renderContextData.encoder;\n    } else {\n      encoder = this.device.createCommandEncoder({\n        label: 'copyFramebufferToTexture_' + texture.id\n      });\n    }\n    encoder.copyTextureToTexture({\n      texture: sourceGPU,\n      origin: [rectangle.x, rectangle.y, 0]\n    }, {\n      texture: destinationGPU\n    }, [rectangle.z, rectangle.w]);\n    if (texture.generateMipmaps) this.textureUtils.generateMipmaps(texture);\n    if (renderContextData.currentPass) {\n      const {\n        descriptor\n      } = renderContextData;\n      for (let i = 0; i < descriptor.colorAttachments.length; i++) {\n        descriptor.colorAttachments[i].loadOp = GPULoadOp.Load;\n      }\n      if (renderContext.depth) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n      if (renderContext.stencil) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n      renderContextData.currentPass = encoder.beginRenderPass(descriptor);\n      renderContextData.currentSets = {\n        attributes: {},\n        bindingGroups: [],\n        pipeline: null,\n        index: null\n      };\n      if (renderContext.viewport) {\n        this.updateViewport(renderContext);\n      }\n      if (renderContext.scissor) {\n        const {\n          x,\n          y,\n          width,\n          height\n        } = renderContext.scissorValue;\n        renderContextData.currentPass.setScissorRect(x, y, width, height);\n      }\n    } else {\n      this.device.queue.submit([encoder.finish()]);\n    }\n  }\n}\nclass IESSpotLight extends SpotLight {\n  constructor(color, intensity, distance, angle, penumbra, decay) {\n    super(color, intensity, distance, angle, penumbra, decay);\n    this.iesMap = null;\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.iesMap = source.iesMap;\n    return this;\n  }\n}\nclass StandardNodeLibrary extends NodeLibrary {\n  constructor() {\n    super();\n    this.addMaterial(MeshPhongNodeMaterial, 'MeshPhongMaterial');\n    this.addMaterial(MeshStandardNodeMaterial, 'MeshStandardMaterial');\n    this.addMaterial(MeshPhysicalNodeMaterial, 'MeshPhysicalMaterial');\n    this.addMaterial(MeshToonNodeMaterial, 'MeshToonMaterial');\n    this.addMaterial(MeshBasicNodeMaterial, 'MeshBasicMaterial');\n    this.addMaterial(MeshLambertNodeMaterial, 'MeshLambertMaterial');\n    this.addMaterial(MeshNormalNodeMaterial, 'MeshNormalMaterial');\n    this.addMaterial(MeshMatcapNodeMaterial, 'MeshMatcapMaterial');\n    this.addMaterial(LineBasicNodeMaterial, 'LineBasicMaterial');\n    this.addMaterial(LineDashedNodeMaterial, 'LineDashedMaterial');\n    this.addMaterial(PointsNodeMaterial, 'PointsMaterial');\n    this.addMaterial(SpriteNodeMaterial, 'SpriteMaterial');\n    this.addMaterial(ShadowNodeMaterial, 'ShadowMaterial');\n    this.addLight(PointLightNode, PointLight);\n    this.addLight(DirectionalLightNode, DirectionalLight);\n    this.addLight(RectAreaLightNode, RectAreaLight);\n    this.addLight(SpotLightNode, SpotLight);\n    this.addLight(AmbientLightNode, AmbientLight);\n    this.addLight(HemisphereLightNode, HemisphereLight);\n    this.addLight(LightProbeNode, LightProbe);\n    this.addLight(IESSpotLightNode, IESSpotLight);\n    this.addToneMapping(linearToneMapping, LinearToneMapping);\n    this.addToneMapping(reinhardToneMapping, ReinhardToneMapping);\n    this.addToneMapping(cineonToneMapping, CineonToneMapping);\n    this.addToneMapping(acesFilmicToneMapping, ACESFilmicToneMapping);\n    this.addToneMapping(agxToneMapping, AgXToneMapping);\n    this.addToneMapping(neutralToneMapping, NeutralToneMapping);\n  }\n}\n\n/*\nconst debugHandler = {\n\n\tget: function ( target, name ) {\n\n\t\t// Add |update\n\t\tif ( /^(create|destroy)/.test( name ) ) console.log( 'WebGPUBackend.' + name );\n\n\t\treturn target[ name ];\n\n\t}\n\n};\n*/\nclass WebGPURenderer extends Renderer {\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let BackendClass;\n    if (parameters.forceWebGL) {\n      BackendClass = WebGLBackend;\n    } else {\n      BackendClass = WebGPUBackend;\n      parameters.getFallback = () => {\n        console.warn('THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.');\n        return new WebGLBackend(parameters);\n      };\n    }\n    const backend = new BackendClass(parameters);\n\n    //super( new Proxy( backend, debugHandler ) );\n    super(backend, parameters);\n    this.library = new StandardNodeLibrary();\n    this.isWebGPURenderer = true;\n  }\n}\nclass BundleGroup extends Group {\n  constructor() {\n    super();\n    this.isBundleGroup = true;\n    this.type = 'BundleGroup';\n    this.static = true;\n    this.version = 0;\n  }\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n}\nconst _material = /*@__PURE__*/new NodeMaterial();\nconst _quadMesh = /*@__PURE__*/new QuadMesh(_material);\nclass PostProcessing {\n  constructor(renderer) {\n    let outputNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : vec4(0, 0, 1, 1);\n    this.renderer = renderer;\n    this.outputNode = outputNode;\n    this.outputColorTransform = true;\n    this.needsUpdate = true;\n    _material.name = 'PostProcessing';\n  }\n  render() {\n    this.update();\n    const renderer = this.renderer;\n    const toneMapping = renderer.toneMapping;\n    const outputColorSpace = renderer.outputColorSpace;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputColorSpace = LinearSRGBColorSpace;\n\n    //\n\n    _quadMesh.render(renderer);\n\n    //\n\n    renderer.toneMapping = toneMapping;\n    renderer.outputColorSpace = outputColorSpace;\n  }\n  update() {\n    if (this.needsUpdate === true) {\n      const renderer = this.renderer;\n      const toneMapping = renderer.toneMapping;\n      const outputColorSpace = renderer.outputColorSpace;\n      _quadMesh.material.fragmentNode = this.outputColorTransform === true ? renderOutput(this.outputNode, toneMapping, outputColorSpace) : this.outputNode.context({\n        toneMapping,\n        outputColorSpace\n      });\n      _quadMesh.material.needsUpdate = true;\n      this.needsUpdate = false;\n    }\n  }\n  async renderAsync() {\n    this.update();\n    const renderer = this.renderer;\n    const toneMapping = renderer.toneMapping;\n    const outputColorSpace = renderer.outputColorSpace;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputColorSpace = LinearSRGBColorSpace;\n\n    //\n\n    await _quadMesh.renderAsync(renderer);\n\n    //\n\n    renderer.toneMapping = toneMapping;\n    renderer.outputColorSpace = outputColorSpace;\n  }\n}\n\n// renderer state\n\nfunction saveRendererState(renderer) {\n  let state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  state.toneMapping = renderer.toneMapping;\n  state.toneMappingExposure = renderer.toneMappingExposure;\n  state.outputColorSpace = renderer.outputColorSpace;\n  state.renderTarget = renderer.getRenderTarget();\n  state.activeCubeFace = renderer.getActiveCubeFace();\n  state.activeMipmapLevel = renderer.getActiveMipmapLevel();\n  state.renderObjectFunction = renderer.getRenderObjectFunction();\n  state.pixelRatio = renderer.getPixelRatio();\n  state.mrt = renderer.getMRT();\n  state.clearColor = renderer.getClearColor(state.clearColor || new Color());\n  state.clearAlpha = renderer.getClearAlpha();\n  state.autoClear = renderer.autoClear;\n  state.scissorTest = renderer.getScissorTest();\n  return state;\n}\nfunction resetRendererState(renderer, state) {\n  state = saveRendererState(renderer, state);\n  renderer.setMRT(null);\n  renderer.setRenderObjectFunction(null);\n  renderer.setClearColor(0x000000, 1);\n  renderer.autoClear = true;\n  return state;\n}\nfunction restoreRendererState(renderer, state) {\n  renderer.toneMapping = state.toneMapping;\n  renderer.toneMappingExposure = state.toneMappingExposure;\n  renderer.outputColorSpace = state.outputColorSpace;\n  renderer.setRenderTarget(state.renderTarget, state.activeCubeFace, state.activeMipmapLevel);\n  renderer.setRenderObjectFunction(state.renderObjectFunction);\n  renderer.setPixelRatio(state.pixelRatio);\n  renderer.setMRT(state.mrt);\n  renderer.setClearColor(state.clearColor, state.clearAlpha);\n  renderer.autoClear = state.autoClear;\n  renderer.setScissorTest(state.scissorTest);\n}\n\n// renderer and scene state\n\nfunction saveRendererAndSceneState(renderer, scene) {\n  let state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  state = saveRendererState(renderer, state);\n  state.background = scene.background;\n  state.backgroundNode = scene.backgroundNode;\n  state.overrideMaterial = scene.overrideMaterial;\n  return state;\n}\nfunction resetRendererAndSceneState(renderer, scene, state) {\n  state = saveRendererAndSceneState(renderer, scene, state);\n  scene.background = null;\n  scene.backgroundNode = null;\n  scene.overrideMaterial = null;\n  return state;\n}\nfunction restoreRendererAndSceneState(renderer, scene, state) {\n  restoreRendererState(renderer, state);\n  scene.background = state.background;\n  scene.backgroundNode = state.backgroundNode;\n  scene.overrideMaterial = state.overrideMaterial;\n}\nvar PostProcessingUtils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  resetRendererAndSceneState: resetRendererAndSceneState,\n  resetRendererState: resetRendererState,\n  restoreRendererAndSceneState: restoreRendererAndSceneState,\n  restoreRendererState: restoreRendererState,\n  saveRendererAndSceneState: saveRendererAndSceneState,\n  saveRendererState: saveRendererState\n});\nclass StorageTexture extends Texture {\n  constructor() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    super();\n    this.image = {\n      width,\n      height\n    };\n    this.magFilter = LinearFilter;\n    this.minFilter = LinearFilter;\n    this.isStorageTexture = true;\n  }\n}\nclass IndirectStorageBufferAttribute extends StorageBufferAttribute {\n  constructor(array, itemSize) {\n    super(array, itemSize, Uint32Array);\n    this.isIndirectStorageBufferAttribute = true;\n  }\n}\nclass NodeLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.textures = {};\n    this.nodes = {};\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, text => {\n      try {\n        onLoad(this.parse(JSON.parse(text)));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        this.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parseNodes(json) {\n    const nodes = {};\n    if (json !== undefined) {\n      for (const nodeJSON of json) {\n        const {\n          uuid,\n          type\n        } = nodeJSON;\n        nodes[uuid] = this.createNodeFromType(type);\n        nodes[uuid].uuid = uuid;\n      }\n      const meta = {\n        nodes,\n        textures: this.textures\n      };\n      for (const nodeJSON of json) {\n        nodeJSON.meta = meta;\n        const node = nodes[nodeJSON.uuid];\n        node.deserialize(nodeJSON);\n        delete nodeJSON.meta;\n      }\n    }\n    return nodes;\n  }\n  parse(json) {\n    const node = this.createNodeFromType(json.type);\n    node.uuid = json.uuid;\n    const nodes = this.parseNodes(json.nodes);\n    const meta = {\n      nodes,\n      textures: this.textures\n    };\n    json.meta = meta;\n    node.deserialize(json);\n    delete json.meta;\n    return node;\n  }\n  setTextures(value) {\n    this.textures = value;\n    return this;\n  }\n  setNodes(value) {\n    this.nodes = value;\n    return this;\n  }\n  createNodeFromType(type) {\n    if (this.nodes[type] === undefined) {\n      console.error('THREE.NodeLoader: Node type not found:', type);\n      return float();\n    }\n    return nodeObject(new this.nodes[type]());\n  }\n}\nclass NodeMaterialLoader extends MaterialLoader {\n  constructor(manager) {\n    super(manager);\n    this.nodes = {};\n    this.nodeMaterials = {};\n  }\n  parse(json) {\n    const material = super.parse(json);\n    const nodes = this.nodes;\n    const inputNodes = json.inputNodes;\n    for (const property in inputNodes) {\n      const uuid = inputNodes[property];\n      material[property] = nodes[uuid];\n    }\n    return material;\n  }\n  setNodes(value) {\n    this.nodes = value;\n    return this;\n  }\n  setNodeMaterials(value) {\n    this.nodeMaterials = value;\n    return this;\n  }\n  createMaterialFromType(type) {\n    const materialClass = this.nodeMaterials[type];\n    if (materialClass !== undefined) {\n      return new materialClass();\n    }\n    return super.createMaterialFromType(type);\n  }\n}\nclass NodeObjectLoader extends ObjectLoader {\n  constructor(manager) {\n    super(manager);\n    this.nodes = {};\n    this.nodeMaterials = {};\n    this._nodesJSON = null;\n  }\n  setNodes(value) {\n    this.nodes = value;\n    return this;\n  }\n  setNodeMaterials(value) {\n    this.nodeMaterials = value;\n    return this;\n  }\n  parse(json, onLoad) {\n    this._nodesJSON = json.nodes;\n    const data = super.parse(json, onLoad);\n    this._nodesJSON = null; // dispose\n\n    return data;\n  }\n  parseNodes(json, textures) {\n    if (json !== undefined) {\n      const loader = new NodeLoader();\n      loader.setNodes(this.nodes);\n      loader.setTextures(textures);\n      return loader.parseNodes(json);\n    }\n    return {};\n  }\n  parseMaterials(json, textures) {\n    const materials = {};\n    if (json !== undefined) {\n      const nodes = this.parseNodes(this._nodesJSON, textures);\n      const loader = new NodeMaterialLoader();\n      loader.setTextures(textures);\n      loader.setNodes(nodes);\n      loader.setNodeMaterials(this.nodeMaterials);\n      for (let i = 0, l = json.length; i < l; i++) {\n        const data = json[i];\n        materials[data.uuid] = loader.parse(data);\n      }\n    }\n    return materials;\n  }\n}\nclass ClippingGroup extends Group {\n  constructor() {\n    super();\n    this.isClippingGroup = true;\n    this.clippingPlanes = [];\n    this.enabled = true;\n    this.clipIntersection = false;\n    this.clipShadows = false;\n  }\n}\nexport { ACESFilmicToneMapping, AONode, AddEquation, AddOperation, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightNode, AnalyticLightNode, ArrayElementNode, AssignNode, AttributeNode, BackSide, BasicEnvironmentNode, BasicShadowMap, BatchNode, BoxGeometry, BufferAttribute, BufferAttributeNode, BufferGeometry, BufferNode, BumpMapNode, BundleGroup, BypassNode, ByteType, CacheNode, CineonToneMapping, ClampToEdgeWrapping, ClippingGroup, CodeNode, Color, ColorManagement, ColorSpaceNode, ComputeNode, ConstNode, ContextNode, ConvertNode, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureNode, CubeUVReflectionMapping, CullFaceBack, CullFaceFront, CullFaceNone, CustomBlending, DataArrayTexture, DataTexture, DecrementStencilOp, DecrementWrapStencilOp, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightNode, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicDrawUsage, EnvironmentNode, EqualCompare, EqualDepth, EqualStencilFunc, EquirectUVNode, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExpressionNode, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, FogExp2Node, FogNode, FogRangeNode, FramebufferTexture, FrontFacingNode, FrontSide, Frustum, FunctionCallNode, FunctionNode, FunctionOverloadingNode, GLSLNodeParser, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, Group, HalfFloatType, HemisphereLight, HemisphereLightNode, IESSpotLight, IESSpotLightNode, IncrementStencilOp, IncrementWrapStencilOp, IndexNode, IndirectStorageBufferAttribute, InstanceNode, InstancedBufferAttribute, InstancedInterleavedBuffer, InstancedMeshNode, InstancedPointsNodeMaterial, IntType, InterleavedBuffer, InterleavedBufferAttribute, InvertStencilOp, IrradianceNode, JoinNode, KeepStencilOp, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, LightProbe, LightProbeNode, Lighting, LightingContextNode, LightingModel, LightingNode, LightsNode, Line2NodeMaterial, LineBasicMaterial, LineBasicNodeMaterial, LineDashedMaterial, LineDashedNodeMaterial, LinearFilter, LinearMipMapLinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, Loader, LoopNode, LuminanceAlphaFormat, LuminanceFormat, MRTNode, MatcapUVNode, Material, MaterialLoader, MaterialNode, MaterialReferenceNode, MathUtils, Matrix3, Matrix4, MaxEquation, MaxMipLevelNode, Mesh, MeshBasicMaterial, MeshBasicNodeMaterial, MeshLambertMaterial, MeshLambertNodeMaterial, MeshMatcapMaterial, MeshMatcapNodeMaterial, MeshNormalMaterial, MeshNormalNodeMaterial, MeshPhongMaterial, MeshPhongNodeMaterial, MeshPhysicalMaterial, MeshPhysicalNodeMaterial, MeshSSSNodeMaterial, MeshStandardMaterial, MeshStandardNodeMaterial, MeshToonMaterial, MeshToonNodeMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, ModelNode, ModelViewProjectionNode, MorphNode, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, Node, NodeAccess, NodeAttribute, NodeBuilder, NodeCache, NodeCode, NodeFrame, NodeFunctionInput, NodeLoader, NodeMaterial, NodeMaterialLoader, NodeMaterialObserver, NodeObjectLoader, NodeShaderStage, NodeType, NodeUniform, NodeUpdateType, NodeUtils, NodeVar, NodeVarying, NormalBlending, NormalMapNode, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, Object3D, Object3DNode, ObjectLoader, ObjectSpaceNormalMap, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, OutputStructNode, PCFShadowMap, PMREMGenerator, PMREMNode, ParameterNode, PassNode, PerspectiveCamera, PhongLightingModel, PhysicalLightingModel, Plane, PointLight, PointLightNode, PointUVNode, PointsMaterial, PointsNodeMaterial, PostProcessing, PostProcessingUtils, PosterizeNode, PropertyNode, QuadMesh, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBFormat, RGBIntegerFormat, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RTTNode, RangeNode, RectAreaLight, RectAreaLightNode, RedFormat, RedIntegerFormat, ReferenceNode, ReflectorNode, ReinhardToneMapping, RemapNode, RenderOutputNode, RenderTarget, RendererReferenceNode, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RotateNode, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, SceneNode, ScreenNode, ScriptableNode, ScriptableValueNode, SetNode, ShadowMaterial, ShadowNode, ShadowNodeMaterial, ShortType, SkinningNode, SphereGeometry, SplitNode, SpotLight, SpotLightNode, SpriteMaterial, SpriteNodeMaterial, SpriteSheetUVNode, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StackNode, StaticDrawUsage, StorageArrayElementNode, StorageBufferAttribute, StorageBufferNode, StorageInstancedBufferAttribute, StorageTexture, StorageTextureNode, SubtractEquation, SubtractiveBlending, TSL, TangentSpaceNormalMap, TempNode, Texture, Texture3DNode, TextureNode, TextureSizeNode, ToneMappingNode, ToonOutlinePassNode, TriplanarTexturesNode, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, UniformArrayNode, UniformGroupNode, UniformNode, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, UserDataNode, VSMShadowMap, VarNode, VaryingNode, Vector2, Vector3, Vector4, VertexColorNode, ViewportDepthNode, ViewportDepthTextureNode, ViewportSharedTextureNode, ViewportTextureNode, VolumeNodeMaterial, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGPUCoordinateSystem, WebGPURenderer, ZeroFactor, ZeroStencilOp, createCanvasElement, defaultBuildStages, defaultShaderStages, shaderStages, vectorComponents };","map":{"version":3,"names":["Color","Vector2","Vector3","Vector4","Matrix3","Matrix4","EventDispatcher","MathUtils","ColorManagement","SRGBTransfer","NoToneMapping","StaticDrawUsage","InterleavedBuffer","DynamicDrawUsage","InterleavedBufferAttribute","NoColorSpace","UnsignedIntType","IntType","WebGLCoordinateSystem","BackSide","CubeReflectionMapping","CubeRefractionMapping","WebGPUCoordinateSystem","TangentSpaceNormalMap","ObjectSpaceNormalMap","InstancedInterleavedBuffer","InstancedBufferAttribute","DataArrayTexture","FloatType","FramebufferTexture","LinearMipmapLinearFilter","DepthTexture","Material","NormalBlending","PointsMaterial","LineBasicMaterial","LineDashedMaterial","NoBlending","MeshNormalMaterial","WebGLCubeRenderTarget","BoxGeometry","Mesh","Scene","LinearFilter","CubeCamera","CubeTexture","EquirectangularReflectionMapping","EquirectangularRefractionMapping","AddOperation","MixOperation","MultiplyOperation","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","Texture","MeshStandardMaterial","MeshPhysicalMaterial","MeshToonMaterial","MeshMatcapMaterial","SpriteMaterial","ShadowMaterial","Uint32BufferAttribute","Uint16BufferAttribute","DoubleSide","DepthStencilFormat","DepthFormat","UnsignedInt248Type","UnsignedByteType","RenderTarget","Plane","Object3D","HalfFloatType","LinearMipMapLinearFilter","OrthographicCamera","BufferGeometry","Float32BufferAttribute","BufferAttribute","UVMapping","Euler","LinearSRGBColorSpace","LessCompare","VSMShadowMap","RGFormat","BasicShadowMap","SphereGeometry","CubeUVReflectionMapping","PerspectiveCamera","RGBAFormat","LinearMipmapNearestFilter","NearestMipmapLinearFilter","Float16BufferAttribute","REVISION","SRGBColorSpace","PCFShadowMap","FrontSide","Frustum","DataTexture","RedIntegerFormat","RedFormat","RGIntegerFormat","RGBIntegerFormat","RGBFormat","RGBAIntegerFormat","UnsignedShortType","ByteType","ShortType","createCanvasElement","AddEquation","SubtractEquation","ReverseSubtractEquation","ZeroFactor","OneFactor","SrcColorFactor","SrcAlphaFactor","SrcAlphaSaturateFactor","DstColorFactor","DstAlphaFactor","OneMinusSrcColorFactor","OneMinusSrcAlphaFactor","OneMinusDstColorFactor","OneMinusDstAlphaFactor","CullFaceNone","CullFaceBack","CullFaceFront","CustomBlending","MultiplyBlending","SubtractiveBlending","AdditiveBlending","NotEqualDepth","GreaterDepth","GreaterEqualDepth","EqualDepth","LessEqualDepth","LessDepth","AlwaysDepth","NeverDepth","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedInt5999Type","AlphaFormat","LuminanceFormat","LuminanceAlphaFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_ETC1_Format","RGB_ETC2_Format","RGBA_ETC2_EAC_Format","RGBA_ASTC_4x4_Format","RGBA_ASTC_5x4_Format","RGBA_ASTC_5x5_Format","RGBA_ASTC_6x5_Format","RGBA_ASTC_6x6_Format","RGBA_ASTC_8x5_Format","RGBA_ASTC_8x6_Format","RGBA_ASTC_8x8_Format","RGBA_ASTC_10x5_Format","RGBA_ASTC_10x6_Format","RGBA_ASTC_10x8_Format","RGBA_ASTC_10x10_Format","RGBA_ASTC_12x10_Format","RGBA_ASTC_12x12_Format","RGBA_BPTC_Format","RED_RGTC1_Format","SIGNED_RED_RGTC1_Format","RED_GREEN_RGTC2_Format","SIGNED_RED_GREEN_RGTC2_Format","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipmapNearestFilter","NeverCompare","AlwaysCompare","LessEqualCompare","EqualCompare","GreaterEqualCompare","GreaterCompare","NotEqualCompare","warnOnce","NotEqualStencilFunc","GreaterStencilFunc","GreaterEqualStencilFunc","EqualStencilFunc","LessEqualStencilFunc","LessStencilFunc","AlwaysStencilFunc","NeverStencilFunc","DecrementWrapStencilOp","IncrementWrapStencilOp","DecrementStencilOp","IncrementStencilOp","InvertStencilOp","ReplaceStencilOp","ZeroStencilOp","KeepStencilOp","MaxEquation","MinEquation","SpotLight","PointLight","DirectionalLight","RectAreaLight","AmbientLight","HemisphereLight","LightProbe","LinearToneMapping","ReinhardToneMapping","CineonToneMapping","ACESFilmicToneMapping","AgXToneMapping","NeutralToneMapping","Group","Loader","FileLoader","MaterialLoader","ObjectLoader","AdditiveAnimationBlendMode","AnimationAction","AnimationClip","AnimationLoader","AnimationMixer","AnimationObjectGroup","AnimationUtils","ArcCurve","ArrayCamera","ArrowHelper","AttachedBindMode","Audio","AudioAnalyser","AudioContext","AudioListener","AudioLoader","AxesHelper","BasicDepthPacking","BatchedMesh","Bone","BooleanKeyframeTrack","Box2","Box3","Box3Helper","BoxHelper","BufferGeometryLoader","Cache","Camera","CameraHelper","CanvasTexture","CapsuleGeometry","CatmullRomCurve3","CircleGeometry","Clock","ColorKeyframeTrack","CompressedArrayTexture","CompressedCubeTexture","CompressedTexture","CompressedTextureLoader","ConeGeometry","ConstantAlphaFactor","ConstantColorFactor","Controls","CubeTextureLoader","CubicBezierCurve","CubicBezierCurve3","CubicInterpolant","CullFaceFrontBack","Curve","CurvePath","CustomToneMapping","CylinderGeometry","Cylindrical","Data3DTexture","DataTextureLoader","DataUtils","DefaultLoadingManager","DetachedBindMode","DirectionalLightHelper","DiscreteInterpolant","DodecahedronGeometry","DynamicCopyUsage","DynamicReadUsage","EdgesGeometry","EllipseCurve","ExtrudeGeometry","Fog","FogExp2","GLBufferAttribute","GLSL1","GLSL3","GridHelper","HemisphereLightHelper","IcosahedronGeometry","ImageBitmapLoader","ImageLoader","ImageUtils","InstancedBufferGeometry","InstancedMesh","Int16BufferAttribute","Int32BufferAttribute","Int8BufferAttribute","Interpolant","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","KeyframeTrack","LOD","LatheGeometry","Layers","Light","Line","Line3","LineCurve","LineCurve3","LineLoop","LineSegments","LinearInterpolant","LinearMipMapNearestFilter","LinearTransfer","LoaderUtils","LoadingManager","LoopOnce","LoopPingPong","LoopRepeat","MOUSE","Matrix2","MeshDepthMaterial","MeshDistanceMaterial","NearestMipMapLinearFilter","NearestMipMapNearestFilter","NormalAnimationBlendMode","NumberKeyframeTrack","OctahedronGeometry","OneMinusConstantAlphaFactor","OneMinusConstantColorFactor","PCFSoftShadowMap","Path","PlaneGeometry","PlaneHelper","PointLightHelper","Points","PolarGridHelper","PolyhedronGeometry","PositionalAudio","PropertyBinding","PropertyMixer","QuadraticBezierCurve","QuadraticBezierCurve3","Quaternion","QuaternionKeyframeTrack","QuaternionLinearInterpolant","RGBADepthPacking","RGBDepthPacking","RGB_BPTC_SIGNED_Format","RGB_BPTC_UNSIGNED_Format","RGDepthPacking","RawShaderMaterial","Ray","Raycaster","RingGeometry","ShaderMaterial","Shape","ShapeGeometry","ShapePath","ShapeUtils","Skeleton","SkeletonHelper","SkinnedMesh","Source","Sphere","Spherical","SphericalHarmonics3","SplineCurve","SpotLightHelper","Sprite","StaticCopyUsage","StaticReadUsage","StereoCamera","StreamCopyUsage","StreamDrawUsage","StreamReadUsage","StringKeyframeTrack","TOUCH","TetrahedronGeometry","TextureLoader","TextureUtils","TorusGeometry","TorusKnotGeometry","Triangle","TriangleFanDrawMode","TriangleStripDrawMode","TrianglesDrawMode","TubeGeometry","Uint8BufferAttribute","Uint8ClampedBufferAttribute","Uniform","UniformsGroup","VectorKeyframeTrack","VideoTexture","WebGL3DRenderTarget","WebGLArrayRenderTarget","WebGLMultipleRenderTargets","WebGLRenderTarget","WireframeGeometry","WrapAroundEnding","ZeroCurvatureEnding","ZeroSlopeEnding","refreshUniforms","NodeMaterialObserver","constructor","builder","renderObjects","WeakMap","hasNode","containsNode","hasAnimation","object","isSkinnedMesh","renderId","firstInitialization","renderObject","hasInitialized","has","getRenderObjectData","data","get","undefined","geometry","material","getMaterialData","attributes","getAttributesData","indexVersion","index","version","drawRange","start","count","worldMatrix","matrixWorld","clone","center","morphTargetInfluences","slice","bundle","transmission","width","height","context","bufferWidth","bufferHeight","set","attributesData","name","attribute","property","isNode","renderer","nodes","modelViewMatrix","modelNormalViewMatrix","value","isTexture","id","equals","renderObjectData","copy","materialData","mtlValue","storedGeometryData","storedAttributes","storedAttributeNames","Object","keys","currentAttributeNames","length","storedAttributeData","storedIndexVersion","currentIndexVersion","morphChanged","i","needsRefresh","nodeFrame","isStatic","static","isBundle","notEqual","cyrb53","seed","arguments","h1","h2","Array","val","Math","imul","ch","charCodeAt","hashString","str","hashArray","array","hash$1","_len","params","_key","getCacheKey$1","force","values","push","getSelf","childNode","getNodeChildren","getCacheKey","node","toJSON","startsWith","isArray","child","subProperty","typeFromLength","Map","getTypeFromLength","getLengthFromType","type","test","console","error","getValueType","typeOf","isVector2","isVector3","isVector4","isMatrix3","isMatrix4","isColor","ArrayBuffer","getValueFromType","_len2","_key2","last4","base64ToArrayBuffer","arrayBufferToBase64","arrayBuffer","chars","Uint8Array","String","fromCharCode","btoa","base64","from","atob","c","buffer","NodeUtils","freeze","__proto__","hash","NodeShaderStage","VERTEX","FRAGMENT","NodeUpdateType","NONE","FRAME","RENDER","OBJECT","NodeType","BOOLEAN","INTEGER","FLOAT","VECTOR2","VECTOR3","VECTOR4","MATRIX2","MATRIX3","MATRIX4","NodeAccess","READ_ONLY","WRITE_ONLY","READ_WRITE","defaultShaderStages","defaultBuildStages","shaderStages","vectorComponents","_nodeId","Node","nodeType","updateType","updateBeforeType","updateAfterType","uuid","generateUUID","_cacheKey","_cacheKeyVersion","global","defineProperty","needsUpdate","onUpdate","callback","update","bind","onFrameUpdate","onRenderUpdate","onObjectUpdate","onReference","updateReference","self","isGlobal","getChildren","dispose","dispatchEvent","traverse","getScope","getHash","getUpdateType","getUpdateBeforeType","getUpdateAfterType","getElementType","getNodeType","elementType","nodeProperties","getNodeProperties","outputNode","getShared","nodeFromHash","getNodeFromHash","setup","analyze","usageCount","increaseUsage","build","generate","output","updateBefore","warn","updateAfter","refNode","addNode","addChain","result","buildStage","getBuildStage","properties","initialized","stackNodesBeforeSetup","stack","isGenerateOnce","nodeData","getDataFromNode","snippet","flowCodes","nodeBlock","addFlowCodeHierarchy","format","removeChain","addSequentialNode","getSerializeChildren","serialize","json","nodeChildren","inputNodes","Number","isInteger","meta","deserialize","inputArray","inputObject","isRoot","textures","images","metadata","generator","extractFromCache","cache","key","ArrayElementNode","indexNode","isArrayElementNode","nodeSnippet","indexSnippet","ConvertNode","convertTo","requestType","overloadingType","split","getTypeLength","TempNode","isTempNode","hasDependencies","getVectorType","propertyName","nodeVar","getVarFromNode","getPropertyName","addLineFlowCode","JoinNode","reduce","cur","primitiveType","getComponentType","snippetValues","input","inputSnippet","inputPrimitiveType","getType","join","stringVectorComponents","SplitNode","components","isSplitNode","getVectorLength","vectorLength","max","indexOf","nodeTypeLength","componentsLength","SetNode","sourceNode","targetNode","sourceType","targetType","targetSnippet","sourceSnippet","component","FlipNode","sourceCache","sourceProperty","componentIndex","InputNode","isInputNode","precision","getInputType","setPrecision","toArray","valueType","fromArray","ConstNode","isConstNode","generateConst","currentStack","NodeElements","addMethodChaining","nodeElement","Error","parseSwizzle","props","replace","parseSwizzleAndSort","sort","shaderNodeHandler","NodeClosure","inputs","shift","nodeObjects","prop","nodeObj","isStackNode","_len3","_key3","assign","add","_len4","_key4","endsWith","_len5","_key5","nodeObject","toLowerCase","Reflect","nodeObjectsCacheMap","nodeBuilderFunctionsCacheMap","ShaderNodeObject","obj","altType","Proxy","getConstNode","Fn","ShaderNodeObjects","objects","ShaderNodeArray","len","ShaderNodeProxy","NodeClass","scope","factor","settings","assignNode","_len6","_key6","nodeArray","_len7","_key7","_len8","_key8","ShaderNodeImmutable","_len9","_key9","ShaderCallNodeInternal","shaderNode","getOutputNode","call","onceOutput","layout","functionNodesCacheMap","functionNode","buildFunctionNode","currentFunctionNode","includes","jsFunc","once","setupOutput","addStack","removeStack","ShaderNodeInternal","setLayout","bools","uints","ints","floats","PI","boolsCacheMap","bool","uintsCacheMap","uint","intsCacheMap","map","el","int","floatsCacheMap","float","cacheMaps","constNodesCacheMap","safeGetNodeType","_","ConvertType","cacheMap","_len10","_key10","every","param","defined","v","getConstNodeType","ShaderNode","nodeProxy","_len11","_key11","nodeImmutable","_len12","_key12","fn","_len13","_key13","tslFn","setCurrentStack","getCurrentStack","If","append","color","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat2","mat3","mat4","string","element","convert","types","channels","UniformGroupNode","shared","order","isUniformGroup","uniformGroup","sharedUniformGroup","frameGroup","renderGroup","objectGroup","UniformNode","isUniformNode","groupNode","label","setGroup","group","getGroup","getUniformHash","frame","sharedNode","setHashNode","sharedNodeType","nodeUniform","getUniformFromNode","shaderStage","uniform","arg1","arg2","PropertyNode","varying","isPropertyNode","getVaryingFromNode","needsInterpolation","varyingProperty","diffuseColor","emissive","roughness","metalness","clearcoat","clearcoatRoughness","sheen","sheenRoughness","iridescence","iridescenceIOR","iridescenceThickness","alphaT","anisotropy","anisotropyT","anisotropyB","specularColor","specularF90","shininess","dashSize","gapSize","pointWidth","ior","thickness","attenuationDistance","attenuationColor","dispersion","AssignNode","needsSplitAssign","isAvailable","targetLength","assignDiferentVector","target","source","sourceVar","targetRoot","FunctionCallNode","parameters","setParameters","getParameters","getInputs","generateInput","inputNode","pointer","functionName","func","_len14","_key14","OperatorNode","op","aNode","bNode","_ref","finalOp","typeA","typeB","getIntegerType","typeLength","isMatrix","isVector","getVectorFromMatrix","changeComponentType","a","b","outputLength","fnOpSnippet","getFunctionOperator","useComparisonMethod","getMethod","sub","mul","div","modInt","equal","lessThan","greaterThan","lessThanEqual","greaterThanEqual","and","or","not","xor","bitAnd","bitNot","bitOr","bitXor","shiftLeft","shiftRight","remainder","MathNode","method","cNode","aType","bType","cType","aLen","bLen","cLen","LENGTH","DISTANCE","DOT","CROSS","ALL","EQUALS","MOD","inputType","isWebGL","isWebGLRenderer","TRANSFORM_DIRECTION","tA","tB","mulNode","xyz","normalize","NEGATE","ONE_MINUS","RECIPROCAL","DIFFERENCE","abs","STEP","MIN","MAX","REFRACT","MIX","ANY","RADIANS","DEGREES","EXP","EXP2","LOG","LOG2","SQRT","INVERSE_SQRT","FLOOR","CEIL","NORMALIZE","FRACT","SIN","COS","TAN","ASIN","ACOS","ATAN","ABS","SIGN","DFDX","DFDY","ROUND","TRUNC","FWIDTH","BITCAST","TRANSPOSE","ATAN2","REFLECT","POW","CLAMP","SMOOTHSTEP","FACEFORWARD","EPSILON","INFINITY","PI2","all","any","radians","degrees","exp","exp2","log","log2","sqrt","inverseSqrt","floor","ceil","fract","sin","cos","tan","asin","acos","atan","sign","negate","oneMinus","dFdx","dFdy","round","reciprocal","trunc","fwidth","bitcast","transpose","atan2","min$1","max$1","mod","step","reflect","distance","difference","dot","cross","pow","pow2","pow3","pow4","transformDirection","cbrt","lengthSq","mix","clamp","low","high","saturate","refract","smoothstep","faceForward","rand","_ref2","uv","dt","xy","sn","mixElement","t","e1","e2","smoothstepElement","x","ConditionalNode","condNode","ifNode","elseNode","ifType","elseType","currentNodeBlock","parentNodeBlock","nodeProperty","needsOutput","addFlowCode","tab","addFlowTab","ifSnippet","removeFlowTab","elseSnippet","select","cond","ContextNode","isContextNode","previousContext","getContext","setContext","VarNode","isVarNode","createVar","temp","VaryingNode","isVaryingNode","setupVarying","flowNodeFromShaderStage","sRGBTransferEOTF","_ref3","rgbResult","sRGBTransferOETF","_ref4","WORKING_COLOR_SPACE","OUTPUT_COLOR_SPACE","ColorSpaceNode","colorNode","resolveColorSpace","colorSpace","workingColorSpace","outputColorSpace","enabled","getTransfer","rgb","getPrimaries","_getMatrix","toOutputColorSpace","toWorkingColorSpace","workingToColorSpace","colorSpaceToWorking","convertColorSpace","sourceColorSpace","targetColorSpace","ReferenceElementNode$1","ReferenceElementNode","referenceNode","isReferenceElementNode","uniformType","arrayType","ReferenceBaseNode","reference","setNodeType","updateValue","getValueFromReference","state","reference$1","RendererReferenceNode","rendererReference","ToneMappingNode","toneMapping","exposureNode","toneMappingExposure","toneMappingFn","library","getToneMappingFunction","mapping","exposure","BufferAttributeNode","bufferType","bufferStride","bufferOffset","isBufferNode","usage","instanced","isBufferAttribute","isInstancedBufferAttribute","bufferData","globalCache","getData","setData","getTypeFromAttribute","itemSize","stride","offset","isInterleavedBuffer","bufferAttribute","setUsage","nodeAttribute","getBufferAttributeFromNode","nodeVarying","setInstanced","dynamicBufferAttribute","instancedBufferAttribute","instancedDynamicBufferAttribute","bufferNode","ComputeNode","computeNode","workgroupSize","isComputeNode","dispatchCount","onInitFunction","updateDispatchCount","size","onInit","_ref5","compute","CacheNode","parent","isCacheNode","previousCache","getCache","getCacheFromNode","setCache","_len15","_key15","_len16","_key16","BypassNode","returnNode","callNode","isBypassNode","bypass","RemapNode","inLowNode","inHighNode","outLowNode","outHighNode","doClamp","remap","remapClamp","ExpressionNode","expression","Discard","conditional","Return","RenderOutputNode","isRenderOutput","_ref6","renderOutput","addNodeElement","AttributeNode","attributeName","_attributeName","getAttributeName","hasGeometryAttribute","getAttribute","setAttributeName","geometryAttribute","attributeType","TextureSizeNode","textureNode","levelNode","isTextureSizeNode","textureProperty","level","textureSize","MaxMipLevelNode","_textureNode","texture","image","maxMipLevel","TextureNode","uvNode","biasNode","isTextureNode","compareNode","depthNode","gradNode","sampler","updateMatrix","_value","_matrixUniform","setUpdateMatrix","isDepthTexture","getDefaultUV","channel","getTransformedUV","matrix","setupUV","isFlipY","ImageBitmap","flipY","isRenderTargetTexture","isFramebufferTexture","setY","y","forceUVContext","getUV","getTextureLevel","generateUV","generateSnippet","uvSnippet","levelSnippet","biasSnippet","depthSnippet","compareSnippet","gradSnippet","generateTextureLevel","generateTextureBias","generateTextureGrad","generateTextureCompare","generateTextureLoad","generateTexture","isReference","needsToWorkingColorSpace","setSampler","getSampler","blur","amountNode","bias","compare","grad","gradNodeX","gradNodeY","depth","matrixUniform","matrixAutoUpdate","newNode","textureLoad","aTexture","cameraNear","_ref7","camera","near","cameraFar","_ref8","far","cameraProjectionMatrix","_ref9","projectionMatrix","cameraProjectionMatrixInverse","_ref10","projectionMatrixInverse","cameraViewMatrix","_ref11","matrixWorldInverse","cameraWorldMatrix","_ref12","cameraNormalMatrix","_ref13","normalMatrix","cameraPosition","_ref14","setFromMatrixPosition","Object3DNode","object3d","_uniformNode","WORLD_MATRIX","POSITION","VIEW_POSITION","DIRECTION","SCALE","uniformNode","setFromMatrixScale","getWorldDirection","applyMatrix4","objectDirection","objectWorldMatrix","objectPosition","objectScale","objectViewPosition","ModelNode","modelDirection","modelWorldMatrix","modelPosition","modelScale","modelViewPosition","modelNormalMatrix","_ref15","getNormalMatrix","modelWorldMatrixInverse","_ref16","invert","toVar","highPrecisionModelViewMatrix","isHighPrecisionModelViewMatrix","_ref17","multiplyMatrices","highPrecisionModelNormalViewMatrix","_ref18","positionGeometry","positionLocal","positionPrevious","positionWorld","positionWorldDirection","positionView","positionViewDirection","FrontFacingNode","isFrontFacingNode","coordinateSystem","side","getFrontFacing","frontFacing","faceDirection","normalGeometry","normalLocal","hasAttribute","normalFlat","normalView","flatShading","transformNormalToView","normalWorld","transformedNormalView","setupNormal","transformedNormalWorld","transformedClearcoatNormalView","setupClearcoatNormal","transformNormal","_ref19","normal","m","transformedNormal","_ref20","materialRefractionRatio","_ref21","_ref22","refractionRatio","reflectView","refractView","reflectVector","refractVector","CubeTextureNode","isCubeTextureNode","yz","cubeUV","cubeTexture","BufferNode","bufferCount","UniformArrayElementNode","isArrayBufferElementNode","UniformArrayNode","_elementType","_elementLength","isArrayBufferNode","getElementLength","elementLength","vector","r","g","z","w","Float32Array","charAt","Int32Array","Uint32Array","uniformArray","uniforms","ReferenceNode","referenceBuffer","MaterialReferenceNode","isMaterialReferenceNode","materialReference","tangentGeometry","computeTangents","tangentLocal","tangentView","tangentWorld","transformedTangentView","transformedTangentWorld","getBitangent","crossNormalTangent","bitangentGeometry","bitangentLocal","bitangentView","bitangentWorld","transformedBitangentView","transformedBitangentWorld","TBNViewMatrix","parallaxDirection","parallaxUV","scale","transformedBentNormalView","bentNormal","perturbNormal2Arb","eye_pos","surf_norm","mapN","q0","q1","st0","st1","N","q1perp","q0perp","T","B","det","NormalMapNode","scaleNode","normalMapType","normalMap","tangent","dHdxy_fwd","_ref23","bumpScale","sampleTexture","texNode","Hll","perturbNormalArb","surf_pos","dHdxy","vSigmaX","vSigmaY","vN","R1","R2","fDet","vGrad","BumpMapNode","bumpMap","_propertyCache","MaterialNode","getFloat","getColor","getTexture","COLOR","OPACITY","opacityNode","alphaMap","SPECULAR_STRENGTH","specularMap","SPECULAR_INTENSITY","specularIntensity","SPECULAR_COLOR","specularColorNode","specularColorMap","ROUGHNESS","roughnessNode","roughnessMap","METALNESS","metalnessNode","metalnessMap","EMISSIVE","emissiveIntensityNode","emissiveNode","emissiveMap","NORMAL","CLEARCOAT","clearcoatNode","clearcoatMap","CLEARCOAT_ROUGHNESS","clearcoatRoughnessNode","clearcoatRoughnessMap","CLEARCOAT_NORMAL","clearcoatNormalMap","SHEEN","sheenNode","sheenColorMap","SHEEN_ROUGHNESS","sheenRoughnessNode","sheenRoughnessMap","ANISOTROPY","anisotropyMap","anisotropyPolar","anisotropyMat","materialAnisotropyVector","rg","IRIDESCENCE_THICKNESS","iridescenceThicknessMaximum","iridescenceThicknessRange","iridescenceThicknessMap","iridescenceThicknessMinimum","TRANSMISSION","transmissionNode","transmissionMap","THICKNESS","thicknessNode","thicknessMap","IOR","LIGHT_MAP","AO_MAP","outputType","ALPHA_TEST","SHININESS","SPECULAR","REFLECTIVITY","ROTATION","IRIDESCENCE","IRIDESCENCE_IOR","ATTENUATION_DISTANCE","ATTENUATION_COLOR","LINE_SCALE","LINE_DASH_SIZE","LINE_GAP_SIZE","LINE_WIDTH","LINE_DASH_OFFSET","POINT_WIDTH","DISPERSION","materialAlphaTest","materialColor","materialShininess","materialEmissive","materialOpacity","materialSpecular","materialSpecularIntensity","materialSpecularColor","materialSpecularStrength","materialReflectivity","materialRoughness","materialMetalness","materialNormal","materialClearcoat","materialClearcoatRoughness","materialClearcoatNormal","materialRotation","materialSheen","materialSheenRoughness","materialAnisotropy","materialIridescence","materialIridescenceIOR","materialIridescenceThickness","materialTransmission","materialThickness","materialIOR","materialAttenuationDistance","materialAttenuationColor","materialLineScale","materialLineDashSize","materialLineGapSize","materialLineWidth","materialLineDashOffset","materialPointWidth","materialDispersion","materialLightMap","materialAOMap","_ref24","anisotropyRotation","ModelViewProjectionNode","positionNode","mvp","position","viewMatrix","modelViewProjection","IndexNode","isInstanceIndexNode","getVertexIndex","INSTANCE","getInstanceIndex","DRAW","getDrawIndex","INVOCATION_LOCAL","getInvocationLocalIndex","INVOCATION_SUBGROUP","getInvocationSubgroupIndex","SUBGROUP","getSubgroupIndex","vertexIndex","instanceIndex","subgroupIndex","invocationSubgroupIndex","invocationLocalIndex","drawIndex","InstanceNode","instanceMatrix","instanceColor","instanceMatrixNode","instanceColorNode","bufferColor","bufferFn","instanceBuffers","instancePosition","instanceNormal","instance","InstancedMeshNode","instanceMesh","instancedMesh","BatchNode","batchMesh","batchingIdNode","getIndirectIndex","_ref25","_indirectTexture","indirectId","matricesTexture","_matricesTexture","j","toInt","batchingMatrix","colorsTexture","_colorsTexture","getBatchingColor","_ref26","bm","batchingNormal","mulAssign","batch","_frameId","SkinningNode","skinnedMesh","useReference","skinIndexNode","skinWeightNode","bindMatrixNode","bindMatrixInverseNode","boneMatricesNode","skeleton","bones","bindMatrix","bindMatrixInverse","boneMatrices","previousBoneMatricesNode","getSkinnedPosition","boneMatX","boneMatY","boneMatZ","boneMatW","skinVertex","skinned","getSkinnedNormal","skinMatrix","getPreviousSkinnedPosition","previousBoneMatrices","needsPreviousBoneMatrices","mrt","getMRT","skinPosition","skinNormal","frameId","skinning","skinningReference","LoopNode","getVarName","getProperties","stackNode","l","returnsNode","end","condition","internalParam","startSnippet","endSnippet","declarationSnippet","conditionalSnippet","updateSnippet","getVar","forSnippet","stackSnippet","returnsSnippet","Loop","_len17","_key17","Continue","Break","loop","_morphTextures","_morphVec4","getMorph","_ref27","bufferMap","influence","texelIndex","bufferAttrib","getEntry","hasMorphPosition","morphAttributes","hasMorphNormals","hasMorphColors","morphAttribute","morphTargetsCount","entry","morphTargets","morphNormals","morphColors","vertexDataCount","maxTextureSize","bufferTexture","vertexDataStride","morphTarget","morphNormal","morphColor","fromBufferAttribute","disposeTexture","delete","removeEventListener","addEventListener","MorphNode","mesh","morphBaseInfluence","_ref28","morphTexture","addAssign","morphTargetsRelative","morphReference","LightingNode","isLightingNode","AONode","aoNode","ambientOcclusion","LightingContextNode","lightingModel","backdropNode","backdropAlphaNode","directDiffuse","directSpecular","indirectDiffuse","indirectSpecular","reflectedLight","radiance","irradiance","iblIrradiance","backdrop","backdropAlpha","lightingContext","IrradianceNode","screenSizeVec","viewportVec","ScreenNode","isViewportNode","VIEWPORT","SIZE","_ref29","renderTarget","getRenderTarget","viewport","getViewport","multiplyScalar","getPixelRatio","getDrawingBufferSize","screenCoordinate","screenSize","COORDINATE","coord","getFragCoord","UV","screenUV","viewportSize","zw","viewportCoordinate","viewportUV","viewportResolution","viewportTopLeft","viewportBottomLeft","_size$4","ViewportTextureNode","framebufferTexture","minFilter","generateMipmaps","isOutputTextureNode","currentGenerateMipmaps","copyFramebufferToTexture","viewportTextureNode","viewportTexture","viewportMipTexture","sharedDepthbuffer","ViewportDepthTextureNode","viewportDepthTexture","ViewportDepthNode","valueNode","isViewportDepthNode","DEPTH_BASE","getFragDepth","_ref30","depthBase","DEPTH","isPerspectiveCamera","viewZToPerspectiveDepth","viewZToOrthographicDepth","LINEAR_DEPTH","viewZ","perspectiveDepthToViewZ","orthographicDepthToViewZ","viewZToLogarithmicDepth","numerator","denominator","logarithmicDepthToViewZ","exponent","E","linearDepth","viewportLinearDepth","BuiltinNode","isBuiltinNode","builtin","ClippingNode","DEFAULT","clippingContext","intersectionPlanes","unionPlanes","hardwareClipping","ALPHA_TO_COVERAGE","setupAlphaToCoverage","HARDWARE","setupHardwareClipping","setupDefault","distanceToPlane","distanceGradient","clipOpacity","numUnionPlanes","clippingPlanes","_ref31","plane","numIntersectionPlanes","intersectionClipOpacity","_ref32","discard","_ref33","clipped","_ref34","enableHardwareClipping","hw_clip_distances","getClipDistance","_ref35","clipping","clippingAlpha","ALPHA_HASH_SCALE","hash2D","_ref36","hash3D","_ref37","getAlphaHashThreshold","_ref38","maxDeriv","pixScale","pixScales","alpha","lerpFactor","cases","threshold","NodeMaterial","isNodeMaterial","forceSinglePass","fog","lights","lightsNode","envNode","normalNode","alphaTestNode","geometryNode","shadowPositionNode","receivedShadowNode","castShadowNode","mrtNode","fragmentNode","vertexNode","customProgramCacheKey","setupObserver","setupPosition","addFlow","resultNode","clippingNode","setupClipping","depthWrite","depthBuffer","setupDepth","setupDiffuseColor","setupVariants","outgoingLightNode","setupLighting","basicOutput","materialMRT","merge","isOutputStructNode","monitor","samples","alphaToCoverage","candidateCount","logarithmicDepthBuffer","displacementMap","displacementScale","displacementBias","isBatchedMesh","isInstancedMesh","vertex","_ref39","vertexColors","batchColor","alphaTest","alphaHash","transparent","blending","setupOutgoingLight","setupEnvironment","envMap","isCubeTexture","setupLightMap","lightMap","setupLights","materialLightsNode","lightMapNode","aoMap","lightsN","lighting","createNode","getLights","setupLightingModel","hasLights","fogNode","setDefaultValues","descriptors","getOwnPropertyDescriptors","prototype","getOwnPropertyDescriptor","_defaultValues$e","InstancedPointsNodeMaterial","useAlphaToCoverage","useColor","pointColorNode","pointWidthNode","setValues","setupShaders","_ref40","mvPos","aspect","clipPos","len2","dlen","_defaultValues$d","LineBasicNodeMaterial","isLineBasicNodeMaterial","_defaultValues$c","LineDashedNodeMaterial","isLineDashedNodeMaterial","dashOffset","offsetNode","dashScaleNode","dashSizeNode","gapSizeNode","offsetNodeNode","dashGapNode","vLineDistance","vLineDistanceOffset","_sharedFramebuffer","ViewportSharedTextureNode","viewportSharedTexture","_defaultValues$b","Line2NodeMaterial","useDash","dashed","useWorldUnits","lineWidth","lineColorNode","_ref41","worldUnits","trimSegment","_ref42","nearEstimate","instanceStart","instanceEnd","instanceDistanceStart","instanceDistanceEnd","lineDistance","perspective","ElseIf","clipStart","clipEnd","ndcStart","ndcEnd","dir","clip","worldDir","tmpFwd","worldUp","worldFwd","worldPos","hw","subAssign","clipPose","closestLineToLine","_ref43","p1","p2","p3","p4","p13","p43","p21","d1343","d4321","d1321","d4343","d2121","denom","numer","mua","mub","vUv","worldStart","worldEnd","rayEnd","lineDir","delta","norm","dnorm","instanceColorStart","instanceColorEnd","directionToColor","colorToDirection","_defaultValues$a","MeshNormalNodeMaterial","isMeshNormalNodeMaterial","EquirectUVNode","dirNode","u","equirectUV","CubeRenderTarget","options","isCubeRenderTarget","fromEquirectangularTexture","texture$1","currentMinFilter","magFilter","scene","currentMRT","setMRT","_cache$1","CubeMapNode","_cubeTexture","_cubeTextureNode","defaultTexture","_defaultTexture","cubeMap","mapTextureMapping","isEquirectangularMapReady$1","onTextureDispose","event","cubeMapNode","BasicEnvironmentNode","environment","BasicLightMapNode","RECIPROCAL_PI","irradianceLightMap","LightingModel","finish","direct","directRectArea","indirect","BasicLightingModel","outgoingLight","combine","_defaultValues$9","MeshBasicNodeMaterial","isMeshBasicNodeMaterial","F_Schlick","_ref44","f0","f90","dotVH","fresnel","BRDF_Lambert","G_BlinnPhong_Implicit","D_BlinnPhong","_ref45","dotNH","BRDF_BlinnPhong","_ref46","lightDirection","halfDir","F","G","D","PhongLightingModel","specular","_ref47","lightColor","dotNL","_ref48","_defaultValues$8","MeshLambertNodeMaterial","isMeshLambertNodeMaterial","_defaultValues$7","MeshPhongNodeMaterial","isMeshPhongNodeMaterial","shininessNode","specularNode","getGeometryRoughness","dxy","geometryRoughness","getRoughness","roughnessFactor","min","V_GGX_SmithCorrelated","_ref49","dotNV","a2","gv","gl","V_GGX_SmithCorrelated_Anisotropic","_ref50","alphaB","dotTV","dotBV","dotTL","dotBL","qualifier","D_GGX","_ref51","D_GGX_Anisotropic","_ref52","dotTH","dotBH","v2","w2","BRDF_GGX","f","USE_IRIDESCENCE","USE_ANISOTROPY","V","DFGApprox","_ref53","c0","c1","a004","fab","EnvironmentBRDF","Schlick_to_F0","_ref54","x2","x5","D_Charlie","_ref55","invAlpha","cos2h","sin2h","V_Neubelt","_ref56","BRDF_Sheen","_ref57","LTC_Uv","_ref58","LUT_SIZE","LUT_SCALE","LUT_BIAS","LTC_ClippedSphereFormFactor","_ref59","LTC_EdgeVectorFormFactor","_ref60","v1","theta_sintheta","LTC_Evaluate","_ref61","P","mInv","p0","lightNormal","T1","T2","mat","coords0","coords1","coords2","coords3","vectorFormFactor","bC","w0","w1","w3","g0","g1","h0","bicubic","texelSize","lod","uvScaled","iuv","fuv","g0x","g1x","h0x","h1x","h0y","h1y","textureBicubic","_ref62","lodNode","fLodSize","cLodSize","fLodSizeInv","cLodSizeInv","fSample","cSample","getVolumeTransmissionRay","_ref63","n","modelMatrix","refractionVector","applyIorToRoughness","_ref64","viewportBackSideTexture","viewportFrontSideTexture","getTransmissionSample","_ref65","_ref66","fragCoord","vTexture","transmissionSample","volumeAttenuation","_ref67","transmissionDistance","attenuationCoefficient","transmittance","getIBLVolumeRefraction","_ref68","projMatrix","transmittedLight","halfSpread","iors","_ref69","transmissionRay","refractedRayExit","ndcPos","refractionCoords","divAssign","attenuatedColor","transmittanceFactor","XYZ_TO_REC709","Fresnel0ToIor","fresnel0","sqrtF0","IorToFresnel0","transmittedIor","incidentIor","evalSensitivity","OPD","phase","pos","VAR","evalIridescence","_ref70","outsideIOR","eta2","cosTheta1","thinFilmThickness","baseF0","sinTheta2Sq","cosTheta2Sq","cosTheta2","R0","R12","T121","phi12","phi21","baseIOR","toVec3","R23","phi23","phi","R123","r123","Rs","C0","I","Cm","_ref71","Sm","IBLSheenBRDF","_ref72","viewDir","r2","DG","clearcoatF0","clearcoatF90","PhysicalLightingModel","clearcoatRadiance","clearcoatSpecularDirect","clearcoatSpecularIndirect","sheenSpecularDirect","sheenSpecularIndirect","iridescenceFresnel","iridescenceF0","dotNVi","computeMultiscattering","singleScatter","multiScatter","Fr","FssEss","Ess","Ems","Favg","Fms","_ref73","dotNLcc","ccIrradiance","_ref74","lightPosition","halfWidth","halfHeight","ltc_1","ltc_2","t1","t2","_ref75","_ref76","dotNVcc","clearcoatEnv","singleScattering","multiScattering","cosineWeightedIrradiance","totalScattering","diffuse","_ref77","aoNV","aoExp","Fcc","clearcoatLight","sheenEnergyComp","sheenLight","cubeUV_r0","cubeUV_m0","cubeUV_r1","cubeUV_m1","cubeUV_r4","cubeUV_m4","cubeUV_r5","cubeUV_m5","cubeUV_r6","cubeUV_m6","cubeUV_minMipLevel","cubeUV_minTileSize","getFace","_ref78","direction","absDirection","face","Else","_ref79","roughnessToMip","_ref80","mip","getDirection","_ref81","uv_immutable","zyx","xzy","xz","textureCubeUV","_ref82","sampleDir_immutable","roughness_immutable","CUBEUV_TEXEL_WIDTH","CUBEUV_TEXEL_HEIGHT","CUBEUV_MAX_MIP","sampleDir","mipF","mipInt","color0","bilinearCubeUV","color1","_ref83","direction_immutable","mipInt_immutable","filterInt","faceSize","getSample","_ref84","outputDirection","theta","axis","cosTheta","sampleDirection","_ref85","latitudinal","poleAxis","weights","dTheta","gl_FragColor","_ref86","_generator","_cache","_generateCubeUVSize","imageHeight","maxMip","texelHeight","texelWidth","_getPMREMFromTexture","cacheTexture","pmremVersion","isCubeMapReady","fromCubemap","isEquirectangularMapReady","fromEquirectangular","PMREMNode","_pmrem","_texture","_width","_height","_maxMip","updateFromTexture","cubeUVSize","pmrem","isPMREMTexture","createPMREMGenerator","pmremTexture","_envNodeCache","EnvironmentNode","cacheEnvNode","intensity","useAnisotropy","radianceNormalView","createRadianceContext","createIrradianceContext","isolateRadiance","isolateIrradiance","clearcoatRadianceContext","isolateClearcoatRadiance","normalViewNode","reflectVec","normalWorldNode","_defaultValues$6","MeshStandardNodeMaterial","isMeshStandardNodeMaterial","environmentNode","setupSpecular","_defaultValues$5","MeshPhysicalNodeMaterial","isMeshPhysicalNodeMaterial","clearcoatNormalNode","iridescenceNode","iridescenceIORNode","iridescenceThicknessNode","specularIntensityNode","iorNode","attenuationDistanceNode","attenuationColorNode","dispersionNode","anisotropyNode","useClearcoat","useIridescence","useSheen","useTransmission","useDispersion","anisotropyV","SSSLightingModel","useSSS","_ref87","thicknessColorNode","thicknessDistortionNode","thicknessAmbientNode","thicknessAttenuationNode","thicknessPowerNode","thicknessScaleNode","scatteringHalf","scatteringDot","scatteringIllu","MeshSSSNodeMaterial","getGradientIrradiance","_ref88","gradientMap","fw","ToonLightingModel","_ref89","_ref90","_defaultValues$4","MeshToonNodeMaterial","isMeshToonNodeMaterial","MatcapUVNode","matcapUV","_defaultValues$3","MeshMatcapNodeMaterial","isMeshMatcapNodeMaterial","matcapColor","matcap","_defaultValues$2","PointsNodeMaterial","isPointsNodeMaterial","sizeNode","RotateNode","rotationNode","cosAngle","sinAngle","rotationMatrix","rotation","rotationXMatrix","rotationYMatrix","rotationZMatrix","rotate","_defaultValues$1","SpriteNodeMaterial","isSpriteNodeMaterial","_useSizeAttenuation","_ref91","sizeAttenuation","mvPosition","orthoScale","alignedPosition","rotatedPosition","ShadowMaskModel","shadowNode","_ref92","shadowMask","_defaultValues","ShadowNodeMaterial","isShadowNodeMaterial","_ref93","epsilon","ret","Texture3DNode","isTexture3DNode","texture3D","VolumeNodeMaterial","isVolumeNodeMaterial","testNode","hitBox","_ref94","orig","box_min","box_max","inv_dir","tmin_tmp","tmax_tmp","tmin","tmax","t0","vOrigin","vDirection","rayDir","bounds","p","inc","ac","d","mapValue","probe","finalColor","Animation","info","_context","_animationLoop","_requestId","time","requestAnimationFrame","autoReset","reset","stop","cancelAnimationFrame","setAnimationLoop","ChainMap","weakMap","_id$7","getKeys","proto","getPrototypeOf","descriptor","RenderObject","geometries","renderContext","_nodes","_geometries","pipeline","vertexBuffers","drawParams","clippingContextCacheKey","cacheKey","initialNodesCacheKey","getDynamicCacheKey","initialCacheKey","_nodeBuilderState","_bindings","_monitor","onDispose","isRenderObject","onMaterialDispose","updateClipping","clippingNeedsUpdate","hardwareClippingPlanes","unionClippingCount","getNodeBuilderState","getForRender","getMonitor","getBindings","createBindings","getIndex","getIndirect","getChainArray","setGeometry","getAttributes","nodeAttributes","Set","isInterleavedBufferAttribute","getVertexBuffers","getDrawParameters","vertexCount","firstVertex","instanceCount","firstInstance","hasIndex","isInstancedBufferGeometry","rangeFactor","wireframe","isPoints","isLineSegments","isLine","isLineLoop","lastVertex","itemCount","Infinity","getGeometryCacheKey","normalized","getMaterialCacheKey","valueKey","receiveShadow","needsGeometryUpdate","chainArray","RenderObjects","pipelines","bindings","chainMaps","passId","chainMap","getChainMap","createRenderObject","DataMap","AttributeType","INDEX","STORAGE","INDIRECT","GPU_CHUNK_BYTES","BlendColorFactor","OneMinusBlendColorFactor","Attributes","backend","attributeData","destroyAttribute","createAttribute","createIndexAttribute","createStorageAttribute","createIndirectStorageAttribute","_getBufferAttribute","updateAttribute","arrayNeedsUint32","getWireframeVersion","getWireframeIndex","indices","geometryIndex","geometryPosition","Geometries","wireframes","attributeCall","updateForRender","initGeometry","updateAttributes","geometryData","memory","geometryAttributes","wireframeAttribute","isStorageBufferAttribute","isStorageInstancedBufferAttribute","callId","render","calls","Info","frameCalls","drawCalls","triangles","points","lines","timestamp","previousFrameCalls","timestampCalls","isMesh","isSprite","updateTimestamp","previousRenderFrameCalls","previousComputeFrameCalls","Pipeline","usedTimes","RenderPipeline","vertexProgram","fragmentProgram","ComputePipeline","computeProgram","isComputePipeline","_id$6","ProgrammableStage","code","transforms","stage","Pipelines","caches","programs","fragment","getForCompute","_needsComputeUpdate","previousPipeline","nodeBuilderState","stageCompute","computeShader","_releaseProgram","createProgram","_getComputeCacheKey","_releasePipeline","_getComputePipeline","promises","_needsRenderUpdate","stageVertex","vertexShader","stageFragment","fragmentShader","_getRenderCacheKey","_getRenderPipeline","createComputePipeline","createRenderPipeline","getRenderCacheKey","program","needsRenderUpdate","Bindings","bindGroup","groupData","_init","updateForCompute","_updateBindings","_update","binding","isSampledTexture","updateTexture","isStorageBuffer","isIndirectStorageBufferAttribute","needsBindingsUpdate","cacheBindings","cacheIndex","isNodeUniformsGroup","updated","updateGroup","isUniformBuffer","updateBinding","isSampler","texturesTextureData","generation","textureData","externalTexture","isDefaultTexture","isWebGPUBackend","isStorageTexture","store","needsMipmap","needsMipmaps","updateBindings","painterSortStable","groupOrder","renderOrder","reversePainterSortStable","needsDoublePass","hasTransmission","RenderList","renderItems","renderItemsIndex","opaque","transparentDoublePass","bundles","getNode","lightsArray","occlusionQueryCount","begin","getNextRenderItem","renderItem","occlusionTest","unshift","pushBundle","pushLight","light","customOpaqueSort","customTransparentSort","setLights","il","RenderLists","lists","list","id$1","RenderContext","clearColor","clearColorValue","clearDepth","clearDepthValue","stencil","clearStencil","clearStencilValue","viewportValue","scissor","scissorValue","depthTexture","activeCubeFace","sampleCount","isRenderContext","RenderContexts","chainKey","attachmentState","stencilBuffer","renderState","_size$3","Textures","updateRenderTarget","activeMipmapLevel","renderTargetData","depthTextureMips","getSize","mipWidth","mipHeight","useDepthTexture","textureNeedsUpdate","_destroyTexture","isRenderTarget","destroySampler","destroyTexture","levels","getMipLevels","createSampler","createTexture","needsCreate","complete","dataReady","mipmaps","createDefaultTexture","mipLevelCount","isCompressedTexture","isEnvironmentTexture","Color4","ParameterNode","isParameterNode","parameter","StackNode","_currentCond","boolNode","methodNode","previousStack","_len18","_key18","else","elseif","StructTypeNode","isStructTypeNode","getMemberTypes","OutputStructNode","_len19","members","_key19","getStructTypeFromNode","getOutputStructName","structPrefix","outputStruct","getTextureIndex","MRTNode","outputNodes","isMRTNode","outputs","_ref95","toUint","word","toFloat","parabola","k","gain","pcurve","sinc","tri","_ref96","tri3","_ref97","triNoise3D","_ref98","p_immutable","spd","rz","bp","dg","FunctionOverloadingNode","functionNodes","_len20","parametersNodes","_key20","_candidateFnCall","candidateFnCall","candidateFn","candidateScore","score","overloadingBaseFn","overloadingFn","_len21","_key21","deltaTime","timerLocal","timeScale","timerGlobal","timerDelta","oscSine","oscSquare","oscTriangle","oscSawtooth","rotateUV","_ref99","spherizeUV","_ref100","strength","delta2","delta4","deltaOffset","billboarding","_ref101","horizontal","vertical","viewportSafeUV","_ref102","depthDiff","finalUV","SpriteSheetUVNode","countNode","frameNode","frameNum","column","row","uvFrameOffset","spritesheetUV","TriplanarTexturesNode","textureXNode","textureYNode","textureZNode","bf","tx","ty","zx","tz","textureX","textureY","textureZ","cx","cy","cz","triplanarTextures","triplanarTexture","_reflectorPlane","_normal","_reflectorWorldPosition","_cameraWorldPosition","_rotationMatrix","_lookAtPosition","clipPlane","_view","_target","_q","_size$2","_defaultRT","_defaultUV","flipX","_inReflector","ReflectorNode","_reflectorBaseNode","reflector","ReflectorBaseNode","_depthNode","getDepthNode","isQuadMesh","reflectorNode","resolution","bounces","virtualCameras","renderTargets","_updateResolution","setSize","getVirtualCamera","virtualCamera","extractRotation","subVectors","up","lookAt","updateMatrixWorld","setFromNormalAndCoplanarPoint","constant","elements","clipBias","visible","currentRenderTarget","setRenderTarget","_camera","QuadGeometry","setAttribute","_geometry","QuadMesh","renderAsync","_size$1","RTTNode","autoUpdate","updateMap","_rttNode","_quadMesh","autoSize","getSharedContext","effectiveWidth","pixelRatio","effectiveHeight","setPixelRatio","_ref103","rtt","_len22","_key22","convertToTexture","isPassNode","getTextureNode","_len23","_key23","getViewPosition","_ref104","screenPosition","clipSpacePosition","viewSpacePosition","getScreenPosition","_ref105","viewPosition","sampleClipPos","sampleUv","getNormalFromDepth","_ref106","l2","l1","r1","b2","b1","dl","dr","db","ce","dpdx","dpdy","StorageInstancedBufferAttribute","typeClass","isView","StorageBufferAttribute","StorageArrayElementNode","storageBufferNode","isStorageArrayElementNode","isPBO","setupPBO","isAssignContext","generatePBO","storageElement","StorageBufferNode","isStorageBufferNode","access","isAtomic","_attribute","_varying","setPBO","getPBO","setAccess","toReadOnly","setAtomic","toAtomic","getAttributeData","registerTransform","storage","storageObject","attributeArray","instancedArray","VertexColorNode","isVertexColorNode","vertexColor","_len24","_key24","PointUVNode","isPointUVNode","pointUV","_e1","_m1","SceneNode","BACKGROUND_BLURRINESS","BACKGROUND_INTENSITY","BACKGROUND_ROTATION","background","backgroundRotation","makeRotationFromEuler","identity","backgroundBlurriness","backgroundIntensity","StorageTextureNode","storeNode","isStorageTextureNode","generateStore","toReadWrite","toWriteOnly","storeSnippet","generateTextureStore","storageTexture","textureStore","UserDataNode","userData","_objectData","VelocityNode","previousModelWorldMatrix","previousProjectionMatrix","previousCameraViewMatrix","setProjectionMatrix","_ref107","previousModelMatrix","getPreviousMatrix","cameraData","currentProjectionMatrix","currentCameraViewMatrix","_ref108","previousModelViewMatrix","clipPositionCurrent","clipPositionPrevious","ndcPositionCurrent","ndcPositionPrevious","velocity","objectData","blendBurn","_ref109","base","blend","blendDodge","_ref110","blendScreen","_ref111","blendOverlay","_ref112","blendColor","_ref113","outAlpha","burn","_len25","_key25","dodge","_len26","_key26","screen","_len27","_key27","overlay","_len28","_key28","grayscale","_ref114","luminance","saturation","_ref115","adjustment","vibrance","_ref116","average","mx","amt","hue","_ref117","luminanceCoefficients","getLuminanceCoefficients","cdl","_ref118","slope","power","luma","pv","PosterizeNode","stepsNode","posterize","_size","PassTextureNode","passNode","PassMultipleTextureNode","textureName","previousTexture","getPreviousTexture","PassNode","_pixelRatio","_textures","_textureNodes","_linearDepthNodes","_viewZNodes","_previousTextures","_previousTextureNodes","_cameraNear","_cameraFar","_mrt","refTexture","toggleTexture","prevTexture","getPreviousTextureNode","getViewZNode","viewZNode","getLinearDepthNode","linearDepthNode","_ref119","isWebGLBackend","isMultisampleRenderTargetTexture","pass","passTexture","depthPass","ToonOutlinePassNode","alphaNode","_materialCache","currentRenderObjectFunction","getRenderObjectFunction","setRenderObjectFunction","isMeshToonMaterial","outlineMaterial","_getOutlineMaterial","_createMaterial","isMeshToonOutlineMaterial","outlineNormal","ratio","pos2","originalMaterial","toonOutlinePass","linearToneMapping","_ref120","reinhardToneMapping","_ref121","cineonToneMapping","_ref122","RRTAndODTFit","_ref123","acesFilmicToneMapping","_ref124","ACESInputMat","ACESOutputMat","LINEAR_REC2020_TO_LINEAR_SRGB","LINEAR_SRGB_TO_LINEAR_REC2020","agxDefaultContrastApprox","_ref125","x_immutable","x4","agxToneMapping","_ref126","colortone","AgXInsetMatrix","AgXOutsetMatrix","AgxMinEv","AgxMaxEv","neutralToneMapping","_ref127","StartCompression","Desaturation","peak","newPeak","CodeNode","language","isCodeNode","setIncludes","getIncludes","include","nodeCode","getCodeFromNode","js","src","wgsl","glsl","FunctionNode","getNodeFunction","nodeFunction","parser","parseFunction","getCode","nativeFn","glslFn","wgslFn","ScriptableValueNode","outpuType","events","isScriptableValueNode","isScriptableOutputNode","URL","revokeObjectURL","refresh","getValue","createObjectURL","Blob","scriptableValue","Resources","_len29","_key29","Parameters","scriptableNode","getLayout","getInputLayout","ScriptableNodeResources","ScriptableNode","codeNode","_local","_output","_outputs","_source","_method","_object","_needsOutputUpdate","onRefresh","isScriptableNode","setLocal","getLocal","_refresh","getOutputLayout","setOutput","getOutput","getParameter","setParameter","deleteParameter","getDefaultOutput","clearParameters","getObject","_len30","_key30","callAsync","_len31","_key31","getDefaultOutputNode","THREE","TSL","clear","_exec","parametersProps","interfaceProps","declarations","returns","Function","scriptable","FogNode","factorNode","isFogNode","getViewZ","FogRangeNode","nearNode","farNode","isFogRangeNode","rangeFog","FogExp2Node","densityNode","isFogExp2Node","density","densityFog","RangeNode","minNode","maxNode","minLength","maxLength","minValue","maxValue","setScalar","minElementValue","getComponent","maxElementValue","lerp","random","range","ComputeBuiltinNode","builtinName","_builtinName","getBuiltinName","setBuiltinName","hasBuiltin","computeBuiltin","numWorkgroups","workgroupId","localId","subgroupSize","BarrierNode","barrier","workgroupBarrier","storageBarrier","textureBarrier","WorkgroupInfoElementNode","workgroupInfoNode","isWorkgroupInfoElementNode","WorkgroupInfoNode","isWorkgroupInfoNode","setScope","getScopedArray","workgroupArray","AtomicFunctionNode","pointerNode","methodSnippet","varSnippet","ATOMIC_LOAD","ATOMIC_STORE","ATOMIC_ADD","ATOMIC_SUB","ATOMIC_MAX","ATOMIC_MIN","ATOMIC_AND","ATOMIC_OR","ATOMIC_XOR","atomicNode","atomicFunc","atomicStore","atomicAdd","atomicSub","atomicMax","atomicMin","atomicAnd","atomicOr","atomicXor","uniformsLib","getLightData","lightShadowMatrix","shadowMatrix","shadow","updateMatrices","lightProjectionUV","projectionUV","spotLightCoord","lightTargetPosition","targetPosition","lightViewPosition","_ref128","lightTargetDirection","sortLights","getLightNodeById","lightNodes","lightNode","isAnalyticLightNode","_lightsNodeRef","LightsNode","totalDiffuseNode","totalSpecularNode","_lights","_lightNodes","_lightNodesHash","setupLightsNode","previousLightNodes","nodeLibrary","lightNodeClass","getLightNodeClass","totalDiffuse","shadowMaterialLib","shadowWorldPosition","linearDistance","_ref129","dist","linearShadowDistance","nearDistance","farDistance","referencePosition","getShadowMaterial","isPointLight","BasicShadowFilter","_ref130","shadowCoord","PCFShadowFilter","_ref131","depthCompare","mapSize","radius","dx0","dy0","dx1","dy1","dx2","dy2","dx3","dy3","PCFSoftShadowFilter","_ref132","dx","dy","VSMShadowFilter","_ref133","occlusion","distribution","hardShadow","variance","softnessProbability","VSMPassVertical","_ref134","shadowPass","mean","squaredMean","uvStride","uvStart","_ref135","uvOffset","std_dev","VSMPassHorizontal","_ref136","_ref137","_shadowFilterLib","_quadMesh$1","ShadowNode","shadowMap","vsmShadowMapVertical","vsmShadowMapHorizontal","vsmMaterialVertical","vsmMaterialHorizontal","_node","isShadowNode","setupShadowFilter","_ref138","filterFn","frustumTest","setupShadowCoord","shadowPosition","coordZ","isOrthographicCamera","cameraNearLocal","cameraFarLocal","getShadowFilterFn","setupShadow","shadowMapType","compareFunction","createRenderTarget","updateProjectionMatrix","shadowPassVertical","shadowPassHorizontal","shadowIntensity","normalBias","filterNode","shadowDepthTexture","shadowTexture","shadowColor","shadowOutput","_ref139","renderShadow","updateShadow","shadowType","depthVersion","_depthVersionCached","currentOverrideMaterial","overrideMaterial","layers","mask","castShadow","_len32","_key32","vsmPass","AnalyticLightNode","baseColorNode","shadowColorNode","setupShadowNode","customShadowNode","getDistanceAttenuation","lightDistance","cutoffDistance","decayExponent","distanceFalloff","_clearColor$2","cubeToUV","_ref140","texelSizeY","absV","scaleToCube","planar","almostATexel","almostOne","signX","signY","BasicPointShadowFilter","_ref141","bd3D","dp","PointShadowFilter","_ref142","xyy","yyy","xyx","yyx","xxy","yxy","xxx","yxx","pointShadowFilter","_ref143","lightToPosition","lightToPositionLength","_viewport","_viewportSize","_shadowMapSize","PointShadowNode","_ref144","shadowFrameExtents","getFrameExtents","multiply","previousAutoClear","autoClear","previousClearColor","getClearColor","previousClearAlpha","getClearAlpha","setClearColor","clearAlpha","viewportCount","getViewportCount","vp","pointShadow","directPointLight","_ref145","lVector","lightAttenuation","PointLightNode","cutoffDistanceNode","decayExponentNode","decay","checker","_ref146","mx_select","_ref147","b_immutable","t_immutable","f_immutable","mx_negate_if","_ref148","val_immutable","mx_floor","_ref149","mx_floorfrac","_ref150","mx_bilerp_0","_ref151","v0_immutable","v1_immutable","v2_immutable","v3_immutable","s_immutable","s","v3","v0","s1","mx_bilerp_1","_ref152","mx_bilerp","mx_trilerp_0","_ref153","v4_immutable","v5_immutable","v6_immutable","v7_immutable","r_immutable","v7","v6","v5","v4","mx_trilerp_1","_ref154","mx_trilerp","mx_gradient_float_0","_ref155","hash_immutable","y_immutable","h","mx_gradient_float_1","_ref156","z_immutable","mx_gradient_float","mx_gradient_vec3_0","_ref157","mx_gradient_vec3_1","_ref158","mx_gradient_vec3","mx_gradient_scale2d_0","_ref159","v_immutable","mx_gradient_scale3d_0","_ref160","mx_gradient_scale2d_1","_ref161","mx_gradient_scale2d","mx_gradient_scale3d_1","_ref162","mx_gradient_scale3d","mx_rotl32","_ref163","k_immutable","mx_bjmix","_ref164","bitXorAssign","mx_bjfinal","_ref165","a_immutable","c_immutable","mx_bits_to_01","_ref166","bits_immutable","bits","mx_fade","_ref167","mx_hash_int_0","_ref168","mx_hash_int_1","_ref169","mx_hash_int_2","_ref170","mx_hash_int_3","_ref171","xx_immutable","xx","mx_hash_int_4","_ref172","yy_immutable","yy","mx_hash_int","mx_hash_vec3_0","_ref173","mx_hash_vec3_1","_ref174","mx_hash_vec3","mx_perlin_noise_float_0","_ref175","X","Y","fx","fy","mx_perlin_noise_float_1","_ref176","Z","fz","mx_perlin_noise_float","mx_perlin_noise_vec3_0","_ref177","mx_perlin_noise_vec3_1","_ref178","mx_perlin_noise_vec3","mx_cell_noise_float_0","_ref179","ix","mx_cell_noise_float_1","_ref180","iy","mx_cell_noise_float_2","_ref181","iz","mx_cell_noise_float_3","_ref182","iw","mx_cell_noise_float$1","mx_cell_noise_vec3_0","_ref183","mx_cell_noise_vec3_1","_ref184","mx_cell_noise_vec3_2","_ref185","mx_cell_noise_vec3_3","_ref186","mx_cell_noise_vec3","mx_fractal_noise_float$1","_ref187","octaves_immutable","lacunarity_immutable","diminish_immutable","diminish","lacunarity","octaves","amplitude","mx_fractal_noise_vec3$1","_ref188","mx_fractal_noise_vec2$1","_ref189","mx_fractal_noise_vec4$1","_ref190","mx_worley_distance_0","_ref191","xoff_immutable","yoff_immutable","jitter_immutable","metric_immutable","metric","jitter","yoff","xoff","tmp","off","cellpos","diff","mx_worley_distance_1","_ref192","zoff_immutable","zoff","mx_worley_distance","mx_worley_noise_float_0","_ref193","localpos","sqdist","_ref194","_ref195","mx_worley_noise_vec2_0","_ref196","_ref197","_ref198","mx_worley_noise_vec3_0","_ref199","_ref200","_ref201","mx_worley_noise_float_1","_ref202","_ref203","_ref204","_ref205","mx_worley_noise_float$1","mx_worley_noise_vec2_1","_ref206","_ref207","_ref208","_ref209","mx_worley_noise_vec2$1","mx_worley_noise_vec3_1","_ref210","_ref211","_ref212","_ref213","mx_worley_noise_vec3$1","mx_hsvtorgb","_ref214","hsv","hi","q","mx_rgbtohsv","_ref215","mincomp","maxcomp","mx_srgb_texture_to_lin_rec709","_ref216","color_immutable","isAbove","linSeg","powSeg","mx_aastep","afwidth","_ramp","mx_ramplr","valuel","valuer","texcoord","mx_ramptb","valuet","valueb","_split","mx_splitlr","mx_splittb","mx_transform_uv","uv_scale","uv_offset","uv_geo","mx_safepower","in1","in2","mx_contrast","amount","pivot","mx_noise_float","mx_noise_vec3","mx_noise_vec4","noise_vec4","mx_worley_noise_float","mx_worley_noise_vec2","mx_worley_noise_vec3","mx_cell_noise_float","mx_fractal_noise_float","mx_fractal_noise_vec2","mx_fractal_noise_vec3","mx_fractal_noise_vec4","getParallaxCorrectNormal","_ref217","cubeSize","cubePos","nDir","rbmax","rbmin","rbminmax","correction","boxIntersection","getShIrradianceAt","_ref218","shCoefficients","_clearColor$1","Background","renderList","getBackgroundNode","forceClear","_clearColor","getRGB","sceneData","backgroundNode","backgroundMesh","backgroundMeshNode","viewProj","setZ","nodeMaterial","depthTest","frustumCulled","onBeforeRender","copyPosition","backgroundCacheKey","depthClearValue","_clearDepth","stencilClearValue","_clearStencil","autoClearColor","autoClearDepth","autoClearStencil","_id$5","BindGroup","bindingsReference","NodeBuilderState","updateNodes","updateBeforeNodes","updateAfterNodes","instanceGroup","bindingsGroup","instanceBinding","NodeAttribute","isNodeAttribute","NodeUniform","isNodeUniform","NodeVar","isNodeVar","NodeVarying","isNodeVarying","NodeCode","NodeCache","nodesData","boundary","setValue","NumberUniform","isNumberUniform","Vector2Uniform","isVector2Uniform","Vector3Uniform","isVector3Uniform","Vector4Uniform","isVector4Uniform","ColorUniform","isColorUniform","Matrix3Uniform","isMatrix3Uniform","Matrix4Uniform","isMatrix4Uniform","NumberNodeUniform","Vector2NodeUniform","Vector3NodeUniform","Vector4NodeUniform","ColorNodeUniform","Matrix3NodeUniform","Matrix4NodeUniform","LOD_MIN","EXTRA_LOD_SIGMA","MAX_SAMPLES","_flatCamera","_cubeCamera","_oldTarget","_oldActiveCubeFace","_oldActiveMipmapLevel","PHI","INV_PHI","_axisDirections","_faceLib","PMREMGenerator","_renderer","_pingPongRenderTarget","_lodMax","_cubeSize","_lodPlanes","_sizeLods","_sigmas","_lodMeshes","_blurMaterial","_cubemapMaterial","_equirectMaterial","_backgroundBox","_hasInitialized","fromScene","sigma","_setSize","cubeUVRenderTarget","_allocateTargets","fromSceneAsync","getActiveCubeFace","getActiveMipmapLevel","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","init","equirectangular","_setSizeFromTexture","fromEquirectangularAsync","_fromTexture","cubemap","fromCubemapAsync","compileCubemapShader","_getCubemapMaterial","_compileMaterial","compileEquirectangularShader","_getEquirectMaterial","_dispose","outputTarget","scissorTest","_setViewport","_textureToCubeUV","_createRenderTarget","sizeLods","lodPlanes","sigmas","lodMeshes","_createPlanes","_getBlurShader","tmpMesh","compile","cubeCamera","upSign","forwardSign","originalAutoClear","backgroundBox","backgroundMaterial","useSolidColor","col","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","blurMaterial","STANDARD_DEVIATIONS","blurMesh","blurUniforms","pixels","radiansPerPixel","isFinite","sigmaPixels","sum","weight","outputSize","lodMax","totalLods","sizeLod","uv1","cubeFaces","vertices","positionSize","uvSize","faceIndexSize","faceIndex","coordinates","faceIdx","fill","planes","_getMaterial","materialUniforms","envTexture","rendererCache","typeFromArray","Int8Array","Int16Array","Uint16Array","NodeBuilder","sequentialNodes","hashNodes","flowNodes","flowCode","structs","bindingsIndexes","bindGroups","bufferAttributes","varyings","codes","vars","flow","chaining","stacks","flowsData","getBindGroupsCache","bindGroupsCache","createCubeRenderTarget","_getBindGroup","groupName","bindingsArray","sharedGroup","getBindGroupArray","bindingsGroups","groups","groupUniforms","sortBindingGroups","bindingGroup","buildUpdateNodes","currentNode","isFilteredTexture","lastChain","pop","generateTextureLod","componentType","getComponentTypeFromTexture","isDataTexture","exec","baseType","prefix","getTypeFromArray","dataAttribute","vecType","vecNum","newComponentType","lastStack","structType","variable","flowCodeBlock","needsFlowCode","nodeBlockHierarchy","addLineFlowCodeBlock","codeBlock","getFlowData","flowNode","flowData","flowChildNode","previous","buildFunctionCode","flowShaderNode","Symbol","iterator","next","done","flowStagesNode","previousFlow","previousVars","previousBuildStage","setBuildStage","getVars","previousShaderStage","setShaderStage","getAttributesArray","concat","getVaryings","getUniforms","getCodes","getShaderStage","buildCode","fromMaterial","getNodeUniform","createNodeMaterial","fromType","toType","fromTypeLength","toTypeLength","getSignature","NodeFrame","startTime","updateBeforeMap","updateAfterMap","_getMaps","referenceMap","nodeRef","maps","renderMap","frameMap","updateBeforeNode","updateAfterNode","updateNode","lastTime","performance","now","NodeFunctionInput","isConst","isNodeFunctionInput","DirectionalLightNode","_matrix41","_matrix42","ltcLib","RectAreaLightNode","premultiply","LTC_FLOAT_1","LTC_FLOAT_2","LTC_HALF_1","LTC_HALF_2","setLTC","ltc","SpotLightNode","coneCosNode","penumbraCosNode","angle","penumbra","getSpotAttenuation","angleCosine","angleCos","spotAttenuation","projectedTexture","inSpotLightMap","IESSpotLightNode","iesMap","AmbientLightNode","_ref219","HemisphereLightNode","lightPositionNode","lightDirectionNode","groundColorNode","groundColor","hemiDiffuseWeight","LightProbeNode","lightProbe","sh","coefficients","NodeParser","NodeFunction","isNodeFunction","declarationRegexp$1","propertiesRegexp$1","pragmaMain","parse$1","trim","pragmaMainIndex","mainCode","declaration","match","inputsCode","propsMatches","nameMatch","parseInt","isNaN","blockCode","substring","headerCode","GLSLNodeFunction","declarationCode","GLSLNodeParser","outputNodeMap","Nodes","nodeBuilderCache","callHashCache","groupsData","nodeUniformsGroup","uniformsGroupData","groupChain","getForRenderCacheKey","nodeBuilder","createNodeBuilder","getEnvironmentNode","getFogNode","_createNodeBuilderState","computeData","chain","cacheKeyData","updateScene","updateEnvironment","updateFog","updateBackground","isToneMappingState","forceUpdate","isFogExp2","isFog","getNodeFrame","getNodeFrameForRender","getOutputCacheKey","currentColorSpace","hasOutputChange","outputTexture","_plane","ClippingContext","parentContext","clipIntersection","viewNormalMatrix","clippingGroupContexts","parentVersion","projectPlanes","destination","updateGlobal","clippingGroup","srcClippingPlanes","dstClippingPlanes","getGroupContext","clipShadows","RenderBundle","RenderBundles","NodeLibrary","materialNodes","toneMappingNodes","nodeMaterialClass","getMaterialNodeClass","addToneMapping","toneMappingNode","addType","materialType","addMaterial","materialNodeClass","materialClassType","addLight","lightClass","addClass","nodeClass","baseClass","_defaultLights","Lighting","_scene","_drawingBufferSize","_screen","_frustum","_projScreenMatrix","_vector4","Renderer","isRenderer","antialias","getFallback","domElement","getDomElement","sortObjects","_getFallback","_scissor","_scissorTest","_attributes","_animation","_objects","_pipelines","_bundles","_renderLists","_renderContexts","_background","_quad","_currentRenderContext","_opaqueSort","_transparentSort","_frameBufferTarget","alphaClear","_renderTarget","_activeCubeFace","_activeMipmapLevel","_renderObjectFunction","_currentRenderObjectFunction","_currentRenderBundle","_handleObjectFunction","_renderObjectDirect","_isDeviceLost","onDeviceLost","_onDeviceLost","_initialized","_initPromise","_compilationPromises","xr","debug","checkShaderErrors","onShaderError","getShaderAsync","compileAsync","Promise","resolve","reject","targetScene","previousRenderId","previousRenderContext","previousRenderObjectFunction","previousCompilationPromises","sceneRef","isScene","compilationPromises","_createObjectPipeline","_projectObject","traverseVisible","isLight","opaqueObjects","transparentObjects","transparentDoublePassObjects","_renderObjects","_renderTransparents","_renderScene","resolveTimestampAsync","waitForGPU","errorMessage","api","message","reason","_renderBundle","bundleGroup","renderBundle","renderBundleData","renderContexts","renderBundleNeedsUpdate","beginBundle","finishBundle","addBundle","_getFrameBufferTarget","currentToneMapping","useToneMapping","useColorSpace","frameBufferTarget","isPostProcessingRenderTarget","useFrameBufferTarget","outputRenderTarget","matrixWorldAutoUpdate","minDepth","maxDepth","setFromProjectionMatrix","beginRender","_renderBundles","finishRender","quad","onAfterRender","getMaxAnisotropy","getArrayBufferAsync","setDrawingBufferSize","setViewport","updateSize","updateStyle","style","setOpaqueSort","setTransparentSort","getScissor","setScissor","getScissorTest","setScissorTest","boolean","setClearAlpha","getClearDepth","setClearDepth","getClearStencil","setClearStencil","isOccluded","clearAsync","clearColorAsync","clearDepthAsync","clearStencilAsync","renderObjectFunction","computeNodes","isDeviceLost","computeAsync","computeList","beginCompute","onInitFn","computeBindings","computePipeline","finishCompute","hasFeatureAsync","hasFeature","initTextureAsync","initTexture","rectangle","copyTextureToTexture","srcTexture","dstTexture","srcRegion","dstPosition","readRenderTargetPixelsAsync","copyTextureToBuffer","isGroup","isClippingGroup","isLOD","intersectsSprite","intersectsObject","boundingSphere","computeBoundingSphere","groupMaterial","materialIndex","isBundleGroup","baseRenderList","children","doublePassList","isArrayCamera","cameras","jl","camera2","updateViewport","overridePositionNode","overrideColorNode","overrideDepthNode","shadowSide","draw","Binding","visibility","setVisibility","getFloatLength","floatLength","Buffer","isBuffer","bytesPerElement","BYTES_PER_ELEMENT","_buffer","byteLength","UniformBuffer","_id$4","NodeUniformBuffer","isUniformsGroup","_values","addUniform","removeUniform","splice","chunkOffset","remainingSizeInChunk","updateByType","updateNumber","updateVector2","updateVector3","updateVector4","updateColor","updateMatrix3","updateMatrix4","_getBufferForType","e","arraysEqual","setArray","_id$3","NodeUniformsGroup","getNodes","_id$2","SampledTexture","isVideoTexture","NodeSampledTexture","NodeSampledCubeTexture","isSampledCubeTexture","NodeSampledTexture3D","isSampledTexture3D","glslMethods","textureDimensions","precisionLib","medium","supports$1","swizzleAssign","storageBuffer","defaultPrecisions","GLSLNodeBuilder","uniformGroups","extensions","builtins","pbo","originalArray","numElements","typeMap","Uint8ClampedArray","newSize","newArray","pboTexture","isPBOTexture","pboNode","storageArrayElementNode","elementNodeData","bufferNodeData","propertySizeName","uvIndexSnippet","snippets","bindingSnippets","typePrefix","isDataArrayTexture","isCompressedArrayTexture","bufferCountSnippet","vectorType","groupSnippets","_getGLSLUniformStruct","gpuType","location","getStructMembers","struct","member","getStructs","flat","acc","curr","enableExtension","behavior","getExtensions","ext","extensionName","planeCount","varyingName","attributeNode","getTransforms","transform","_getGLSLVertexCode","shaderData","_getGLSLFragmentCode","shadersData","mainNode","flowSlotData","slotName","stageData","uniformGPU","uniformsStage","uniformsGroup","vector2","vector4","color4","Backend","destroyProgram","destroyPipeline","getInstanceCount","canvas","_id$1","DualAttributeData","dualBuffer","buffers","bufferGPU","activeBufferIndex","baseId","transformBuffer","switchBuffers","WebGLAttributeUtils","STATIC_DRAW","_createBuffer","isFloat16BufferAttribute","HALF_FLOAT","UNSIGNED_SHORT","SHORT","UNSIGNED_INT","INT","BYTE","UNSIGNED_BYTE","bufferGPUDual","updateRanges","bindBuffer","bufferSubData","clearUpdateRanges","deleteBuffer","COPY_READ_BUFFER","writeBuffer","createBuffer","COPY_WRITE_BUFFER","STREAM_READ","copyBufferSubData","utils","_clientWaitAsync","dstBuffer","getBufferSubData","initialized$1","equationToGL","factorToGL","WebGLState","currentFlipSided","currentCullFace","currentProgram","currentBlendingEnabled","currentBlending","currentBlendSrc","currentBlendDst","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentPolygonOffsetFactor","currentPolygonOffsetUnits","currentColorMask","currentDepthFunc","currentDepthMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilMask","currentLineWidth","currentClippingPlanes","currentBoundFramebuffers","currentDrawbuffers","maxTextures","MAX_TEXTURE_IMAGE_UNITS","currentTextureSlot","currentBoundTextures","currentBoundBufferBases","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","ZERO","ONE","SRC_COLOR","SRC_ALPHA","SRC_ALPHA_SATURATE","DST_COLOR","DST_ALPHA","ONE_MINUS_SRC_COLOR","ONE_MINUS_SRC_ALPHA","ONE_MINUS_DST_COLOR","ONE_MINUS_DST_ALPHA","enable","disable","setFlipSided","flipSided","frontFace","CW","CCW","setCullFace","cullFace","CULL_FACE","BACK","FRONT","FRONT_AND_BACK","setLineWidth","setBlending","blendEquation","blendSrc","blendDst","blendEquationAlpha","blendSrcAlpha","blendDstAlpha","premultipliedAlpha","BLEND","currentBlendEquation","currentBlendEquationAlpha","blendFuncSeparate","blendFunc","blendEquationSeparate","setColorMask","colorMask","setDepthTest","DEPTH_TEST","setDepthMask","depthMask","setDepthFunc","depthFunc","NEVER","ALWAYS","LESS","LEQUAL","EQUAL","GEQUAL","GREATER","NOTEQUAL","setStencilTest","stencilTest","STENCIL_TEST","setStencilMask","stencilMask","setStencilFunc","stencilFunc","stencilRef","setStencilOp","stencilFail","stencilZFail","stencilZPass","stencilOp","setMaterial","frontFaceCW","colorWrite","stencilWrite","stencilWriteMask","stencilFuncMask","setPolygonOffset","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","SAMPLE_ALPHA_TO_COVERAGE","CLIP_DISTANCE0_WEBGL","units","POLYGON_OFFSET_FILL","useProgram","bindFramebuffer","framebuffer","DRAW_FRAMEBUFFER","FRAMEBUFFER","drawBuffers","COLOR_ATTACHMENT0","activeTexture","webglSlot","TEXTURE0","bindTexture","webglType","webglTexture","boundTexture","bindBufferBase","unbindTexture","WebGLUtils","extension","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_INT_5_9_9_9_REV","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","DEPTH_COMPONENT","DEPTH_STENCIL","RED","RED_INTEGER","RG","RG_INTEGER","RGBA_INTEGER","COMPRESSED_SRGB_S3TC_DXT1_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_SRGB8_ETC2","COMPRESSED_RGB8_ETC2","COMPRESSED_SRGB8_ALPHA8_ETC2_EAC","COMPRESSED_RGBA8_ETC2_EAC","COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR","COMPRESSED_RGBA_ASTC_4x4_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR","COMPRESSED_RGBA_ASTC_5x4_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR","COMPRESSED_RGBA_ASTC_5x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR","COMPRESSED_RGBA_ASTC_6x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR","COMPRESSED_RGBA_ASTC_6x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR","COMPRESSED_RGBA_ASTC_8x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR","COMPRESSED_RGBA_ASTC_8x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR","COMPRESSED_RGBA_ASTC_8x8_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR","COMPRESSED_RGBA_ASTC_10x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR","COMPRESSED_RGBA_ASTC_10x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR","COMPRESSED_RGBA_ASTC_10x8_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR","COMPRESSED_RGBA_ASTC_10x10_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR","COMPRESSED_RGBA_ASTC_12x10_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR","COMPRESSED_RGBA_ASTC_12x12_KHR","COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT","COMPRESSED_RGBA_BPTC_UNORM_EXT","COMPRESSED_RED_RGTC1_EXT","COMPRESSED_SIGNED_RED_RGTC1_EXT","COMPRESSED_RED_GREEN_RGTC2_EXT","COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT","UNSIGNED_INT_24_8","sync","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","res","clientWaitSync","SYNC_FLUSH_COMMANDS_BIT","WAIT_FAILED","deleteSync","TIMEOUT_EXPIRED","wrappingToGL","filterToGL","compareToGL","WebGLTextureUtils","defaultTextures","REPEAT","CLAMP_TO_EDGE","MIRRORED_REPEAT","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","filterFallback","getGLTextureType","glTextureType","TEXTURE_CUBE_MAP","TEXTURE_2D_ARRAY","isData3DTexture","TEXTURE_3D","TEXTURE_2D","getInternalFormat","internalFormatName","glFormat","glType","forceLinearTransfer","internalFormat","R32F","R16F","R8","R16","R32UI","R8I","R16I","R32I","R8UI","R16UI","RG32F","RG16F","RG8","RG16","RG32UI","RG8I","RG16I","RG32I","RG8UI","RG16UI","RGB32F","RGB16F","RGB8","RGB16","RGB32UI","RGB8I","RGB16I","RGB32I","SRGB8","UNSIGNED_SHORT_5_6_5","RGB565","RGB5_A1","RGB4","RGB9_E5","RGB_INTEGER","RGB8UI","RGB16UI","RGBA32F","RGBA16F","RGBA8","RGBA16","RGBA32UI","RGBA8I","RGBA16I","RGBA32I","SRGB8_ALPHA8","RGBA4","RGBA8UI","RGBA16UI","DEPTH24_STENCIL8","DEPTH_COMPONENT32F","setTextureParameters","textureType","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","premultiplyAlpha","UNPACK_ALIGNMENT","unpackAlignment","UNPACK_COLORSPACE_CONVERSION_WEBGL","texParameteri","TEXTURE_WRAP_S","wrapS","TEXTURE_WRAP_T","wrapT","TEXTURE_WRAP_R","wrapR","TEXTURE_MAG_FILTER","hasMipmaps","TEXTURE_MIN_FILTER","TEXTURE_COMPARE_MODE","COMPARE_REF_TO_TEXTURE","TEXTURE_COMPARE_FUNC","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","textureGPU","isDefault","glInternalFormat","texStorage3D","texStorage2D","copyBufferToTexture","PIXEL_UNPACK_BUFFER","texSubImage2D","getImage","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","mipmap","compressedTexSubImage3D","texSubImage3D","compressedTexSubImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","texImage2D","generateMipmap","deallocateRenderBuffers","renderContextData","renderBufferStorageSetup","framebuffers","deleteFramebuffer","depthRenderbuffer","deleteRenderbuffer","stencilRenderbuffer","msaaFrameBuffer","msaaRenderbuffers","deleteTexture","dstTextureGPU","minX","minY","dstX","dstY","currentUnpackRowLen","UNPACK_ROW_LENGTH","currentUnpackImageHeight","UNPACK_IMAGE_HEIGHT","currentUnpackSkipPixels","UNPACK_SKIP_PIXELS","currentUnpackSkipRows","UNPACK_SKIP_ROWS","currentUnpackSkipImages","UNPACK_SKIP_IMAGES","srcTextureData","dstTextureData","srcRenderContextData","dstRenderContextData","srcFramebuffer","dstFramebuffer","READ_FRAMEBUFFER","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","blitFramebuffer","requireDrawFrameBuffer","srcHeight","gerDrawingBufferSize","partial","attachment","DEPTH_ATTACHMENT","STENCIL_BUFFER_BIT","renderTargetContextData","fb","flippedY","copyTexSubImage2D","createFramebuffer","framebufferTexture2D","_setFramebuffer","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","DEPTH_COMPONENT24","renderbufferStorageMultisample","renderbufferStorage","framebufferRenderbuffer","DEPTH_STENCIL_ATTACHMENT","typedArrayType","_getTypedArrayType","bytesPerTexel","_getBytesPerTexel","elementCount","PIXEL_PACK_BUFFER","readPixels","bytesPerComponent","WebGLExtensions","availableExtensions","getSupportedExtensions","getExtension","WebGLCapabilities","maxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","GLFeatureName","WebGLBufferRenderer","mode","drawElements","drawArrays","renderInstances","primcount","drawElementsInstanced","drawArraysInstanced","renderMultiDraw","starts","counts","drawCount","multiDrawElementsWEBGL","multiDrawArraysWEBGL","renderMultiDrawInstances","multiDrawElementsInstancedWEBGL","multiDrawArraysInstancedWEBGL","WebGLBackend","glContext","onContextLost","preventDefault","contextLossInfo","statusMessage","originalEvent","_onContextLost","capabilities","attributeUtils","textureUtils","bufferRenderer","vaoCache","transformFeedbackCache","trackTimestamp","disjoint","parallel","_knownBindings","WeakSet","_currentContext","initTimestampQuery","queryRunning","queryQueue","activeQuery","endQuery","TIME_ELAPSED_EXT","createQuery","beginQuery","prepareTimestampBuffer","gpuQueries","query","nextRenderContext","queryInfo","available","getQueryParameter","QUERY_RESULT_AVAILABLE","GPU_DISJOINT_EXT","elapsed","QUERY_RESULT","duration","deleteQuery","drawingBufferWidth","drawingBufferHeight","currentOcclusionQueries","occlusionQueries","currentOcclusionQueryObjects","occlusionQueryObjects","lastOcclusionObject","occlusionQueryIndex","ANY_SAMPLES_PASSED","resolveOccludedAsync","viewY","invalidateSubFramebuffer","invalidationArray","invalidateFramebuffer","occluded","check","completed","SCISSOR_TEST","setFrameBuffer","clearBufferfv","clearBufferfi","clearBufferiv","STENCIL","computeGroup","RASTERIZER_DISCARD","programGPU","transformBuffers","vaoKey","_getVaoKey","vaoGPU","_createVao","bindVertexArray","_bindUniforms","transformFeedbackGPU","_getTransformFeedback","bindTransformFeedback","TRANSFORM_FEEDBACK","beginTransformFeedback","POINTS","endTransformFeedback","dualAttributeData","contextData","determinant","staticVao","geometryId","lastObject","LINES","LINE_STRIP","LINE_LOOP","wireframeLinewidth","TRIANGLES","indexData","_multiDrawInstances","_multiDrawStarts","_multiDrawCounts","_multiDrawCount","shader","createShader","FRAGMENT_SHADER","VERTEX_SHADER","shaderSource","compileShader","shaderGPU","attachShader","linkProgram","checkStatus","getProgramParameter","COMPLETION_STATUS_KHR","_completeCompile","_handleSource","errorLine","lines2","to","line","_getShaderErrors","status","getShaderParameter","COMPILE_STATUS","errors","getShaderInfoLog","errorMatches","toUpperCase","getShaderSource","_logProgramError","glFragmentShader","glVertexShader","programLog","getProgramInfoLog","LINK_STATUS","vertexErrors","fragmentErrors","getError","VALIDATE_STATUS","pipelineData","_setupBindings","transformVaryingNames","transformAttributeNodes","transformFeedbackVaryings","SEPARATE_ATTRIBS","attributeNodes","ARRAY_BUFFER","uniformBuffers","bindGroupData","UNIFORM_BUFFER","DYNAMIC_DRAW","bindingData","ELEMENT_ARRAY_BUFFER","keysMatching","filter","currentFrameBuffer","isCube","isWebGLCubeRenderTarget","msaaFb","cubeFramebuffers","cubeFace","depthStyle","createRenderbuffer","createVertexArray","enableVertexAttribArray","vertexAttribIPointer","vertexAttribPointer","vertexAttribDivisor","meshPerAttribute","isInstancedInterleavedBuffer","createTransformFeedback","TRANSFORM_FEEDBACK_BUFFER","getUniformBlockIndex","uniformBlockBinding","getUniformLocation","uniform1i","GPUPrimitiveTopology","PointList","LineList","LineStrip","TriangleList","TriangleStrip","GPUCompareFunction","Never","Less","Equal","LessEqual","Greater","NotEqual","GreaterEqual","Always","GPUStoreOp","Store","GPULoadOp","Load","Clear","GPUFrontFace","GPUCullMode","None","Front","Back","GPUIndexFormat","Uint16","Uint32","GPUTextureFormat","R8Unorm","R8Snorm","R8Uint","R8Sint","R16Uint","R16Sint","R16Float","RG8Unorm","RG8Snorm","RG8Uint","RG8Sint","R32Uint","R32Sint","R32Float","RG16Uint","RG16Sint","RG16Float","RGBA8Unorm","RGBA8UnormSRGB","RGBA8Snorm","RGBA8Uint","RGBA8Sint","BGRA8Unorm","BGRA8UnormSRGB","RGB9E5UFloat","RGB10A2Unorm","RG11B10uFloat","RG32Uint","RG32Sint","RG32Float","RGBA16Uint","RGBA16Sint","RGBA16Float","RGBA32Uint","RGBA32Sint","RGBA32Float","Stencil8","Depth16Unorm","Depth24Plus","Depth24PlusStencil8","Depth32Float","Depth32FloatStencil8","BC1RGBAUnorm","BC1RGBAUnormSRGB","BC2RGBAUnorm","BC2RGBAUnormSRGB","BC3RGBAUnorm","BC3RGBAUnormSRGB","BC4RUnorm","BC4RSnorm","BC5RGUnorm","BC5RGSnorm","BC6HRGBUFloat","BC6HRGBFloat","BC7RGBAUnorm","BC7RGBAUnormSRGB","ETC2RGB8Unorm","ETC2RGB8UnormSRGB","ETC2RGB8A1Unorm","ETC2RGB8A1UnormSRGB","ETC2RGBA8Unorm","ETC2RGBA8UnormSRGB","EACR11Unorm","EACR11Snorm","EACRG11Unorm","EACRG11Snorm","ASTC4x4Unorm","ASTC4x4UnormSRGB","ASTC5x4Unorm","ASTC5x4UnormSRGB","ASTC5x5Unorm","ASTC5x5UnormSRGB","ASTC6x5Unorm","ASTC6x5UnormSRGB","ASTC6x6Unorm","ASTC6x6UnormSRGB","ASTC8x5Unorm","ASTC8x5UnormSRGB","ASTC8x6Unorm","ASTC8x6UnormSRGB","ASTC8x8Unorm","ASTC8x8UnormSRGB","ASTC10x5Unorm","ASTC10x5UnormSRGB","ASTC10x6Unorm","ASTC10x6UnormSRGB","ASTC10x8Unorm","ASTC10x8UnormSRGB","ASTC10x10Unorm","ASTC10x10UnormSRGB","ASTC12x10Unorm","ASTC12x10UnormSRGB","ASTC12x12Unorm","ASTC12x12UnormSRGB","GPUAddressMode","ClampToEdge","Repeat","MirrorRepeat","GPUFilterMode","Linear","Nearest","GPUBlendFactor","Zero","One","Src","OneMinusSrc","SrcAlpha","OneMinusSrcAlpha","Dst","OneMinusDstColor","DstAlpha","OneMinusDstAlpha","SrcAlphaSaturated","Constant","OneMinusConstant","GPUBlendOperation","Add","Subtract","ReverseSubtract","Min","Max","GPUColorWriteFlags","Red","Green","Blue","Alpha","All","GPUStencilOperation","Keep","Replace","Invert","IncrementClamp","DecrementClamp","IncrementWrap","DecrementWrap","GPUBufferBindingType","Storage","ReadOnlyStorage","GPUStorageTextureAccess","WriteOnly","ReadOnly","ReadWrite","GPUTextureSampleType","Float","UnfilterableFloat","Depth","SInt","UInt","GPUTextureDimension","OneD","TwoD","ThreeD","GPUTextureViewDimension","TwoDArray","Cube","CubeArray","GPUTextureAspect","StencilOnly","DepthOnly","GPUInputStepMode","Vertex","Instance","GPUFeatureName","DepthClipControl","TextureCompressionBC","TextureCompressionETC2","TextureCompressionASTC","TimestampQuery","IndirectFirstInstance","ShaderF16","RG11B10UFloat","BGRA8UNormStorage","Float32Filterable","ClipDistances","DualSourceBlending","Subgroups","Sampler","NodeSampler","StorageBuffer","_id","NodeStorageBuffer","WebGPUTexturePassUtils","device","mipmapVertexSource","mipmapFragmentSource","flipYFragmentSource","mipmapSampler","flipYSampler","transferPipelines","flipYPipelines","mipmapVertexShaderModule","createShaderModule","mipmapFragmentShaderModule","flipYFragmentShaderModule","getTransferPipeline","module","entryPoint","targets","primitive","topology","stripIndexFormat","getFlipYPipeline","textureGPUDescriptor","baseArrayLayer","transferPipeline","flipYPipeline","tempTexture","depthOrArrayLayers","GPUTextureUsage","RENDER_ATTACHMENT","TEXTURE_BINDING","srcView","createView","baseMipLevel","dimension","dstView","commandEncoder","createCommandEncoder","sourceView","destinationView","bindGroupLayout","getBindGroupLayout","createBindGroup","entries","resource","passEncoder","beginRenderPass","colorAttachments","view","loadOp","storeOp","clearValue","setPipeline","setBindGroup","queue","submit","destroy","useCount","passes","_mipmapCreateBundles","_mipmapRunBundles","passDescriptor","createRenderBundleEncoder","colorFormats","renderBundles","executeBundles","_compareToWebGPU","_flipMap","WebGPUTextureUtils","_passUtils","defaultCubeTexture","defaultVideoFrame","colorBuffer","samplerDescriptorGPU","addressModeU","_convertAddressMode","addressModeV","addressModeW","_convertFilterMode","mipmapFilter","getFormat","_getDefaultCubeTextureGPU","_getDefaultVideoFrame","_getDefaultTextureGPU","getCurrentColorFormat","getPreferredCanvasFormat","_getDimension","getSampleCount","primarySampleCount","COPY_DST","COPY_SRC","STORAGE_BINDING","textureDescriptorGPU","video","videoFrame","VideoFrame","displayWidth","displayHeight","close","msaaTextureDescriptorGPU","msaaTexture","_generateMipmaps","getColorBuffer","getDepthBuffer","depthTextureGPU","_copyBufferToTexture","_copyCompressedBufferToTexture","_copyCubeMapToTexture","_copyImageToTexture","bytesPerRow","readBuffer","GPUBufferUsage","MAP_READ","encoder","origin","mapAsync","GPUMapMode","READ","getMappedRange","_isEnvironmentTexture","codedWidth","codedHeight","flipIndex","originDepth","copyExternalImageToTexture","mipLevel","_flipY","_getPassUtils","passUtils","writeTexture","blockData","_getBlockData","isTextureArray","bytesPerImage","rowsPerImage","BC4RSNorm","addressMode","filterMode","formatGPU","features","declarationRegexp","propertiesRegexp","wgslTypeLib$1","parse","resolvedType","WGSLNodeFunction","WGSLNodeParser","GPUShaderStage","COMPUTE","accessNames","wrapNames","gpuShaderStageLib","supports","wgslFnOpLib","wgslTypeLib","wgslCodeCache","wgslPolyfill","tsl_xor","mod_float","mod_vec2","mod_vec3","mod_vec4","equals_bool","equals_bvec2","equals_bvec3","equals_bvec4","repeatWrapping_float","mirrorWrapping_float","clampWrapping_float","biquadraticTexture","wgslMethods","inversesqrt","navigator","userAgent","pow_float","pow_vec2","pow_vec3","pow_vec4","diagnostics","WGSLNodeBuilder","directives","scopedArrays","_generateTextureSample","generateFilteredTexture","_generateVideoSample","_generateTextureSampleLevel","isUnfilterable","generateWrapFunction","addWrapSnippet","wrap","generateTextureDimension","dimensionsSnippet","textureDimensionNode","textureDimensionsParams","_include","wrapFunction","textureDimension","coordSnippet","valueSnippet","isSampleCompare","_getUniformGroupCount","fnOp","getNodeAccess","getStorageAccess","bufferClass","getBuiltin","getSubgroupSize","enableSubGroups","enableDirective","getDirectives","directive","enableSubgroupsF16","enableClipDistances","enableShaderF16","enableDualSourceBlending","getBuiltins","getScopedArrays","attributesSnippet","_getWGSLStruct","bufferSnippets","structSnippets","uniformIndexes","multisampled","componentPrefix","bufferTypeSnippet","bufferSnippet","bufferAccessMode","_getWGSLStructBinding","isOutputStruct","returnType","structSnippet","_getWGSLVertexCode","_getWGSLFragmentCode","_getWGSLComputeCode","wgslMethod","_getWGSLMethod","structName","WebGPUUtils","getCurrentDepthStencilFormat","getTextureFormatGPU","getCurrentColorSpace","getPrimitiveTopology","getSampleCountRenderContext","gpu","typedArraysToVertexFormatPrefix","typedAttributeToVertexFormatPrefix","typeArraysToVertexFormatPrefixForItemSize1","WebGPUAttributeUtils","tempArray","subarray","mappedAtCreation","unmap","isTypedArray","_isTypedArray","byteOffsetFactor","dataOffset","createShaderVertexBuffers","slot","vertexBufferLayout","arrayStride","stepMode","_getVertexFormat","shaderLocation","readBufferGPU","cmdEncoder","copyBufferToBuffer","gpuCommands","ArrayType","prefixOptions","bytesPerUnit","paddedBytesPerUnit","paddedItemSize","DataView","WebGPUBindingUtils","bindGroupLayoutCache","createBindingsLayout","bindingGPU","sampleType","viewDimension","createBindGroupLayout","bindingsData","bindLayoutGPU","bindGroupGPU","versions","layoutGPU","bindingPoint","entriesGPU","UNIFORM","resourceGPU","importExternalTexture","aspectGPU","dimensionViewGPU","WebGPUPipelineUtils","_getSampleCount","renderObjectContext","bindGroupLayouts","_getBlending","stencilFront","_getStencilCompare","failOp","_getStencilOperation","depthFailOp","passOp","colorWriteMask","_getColorWriteMask","colorFormat","writeMask","vertexModule","fragmentModule","primitiveState","_getPrimitiveState","_getDepthCompare","depthStencilFormat","pipelineDescriptor","multisample","alphaToCoverageEnabled","createPipelineLayout","depthStencil","renderDepth","renderStencil","depthWriteEnabled","stencilBack","stencilReadMask","createRenderPipelineAsync","then","createBundleEncoder","pipelineGPU","srcFactor","_getBlendFactor","dstFactor","operation","_getBlendOperation","setBlend","srcRGB","dstRGB","srcAlpha","dstAlpha","blendFactor","stencilCompare","stencilOperation","blendOperation","cullMode","WebGPUBackend","requiredLimits","defaultRenderPassdescriptor","bindingUtils","pipelineUtils","occludedResolveCache","adapterOptions","powerPreference","adapter","requestAdapter","supportedFeatures","deviceDescriptor","requiredFeatures","requestDevice","lost","deviceLossInfo","alphaMode","configure","_getDefaultRenderPassDescriptor","depthStencilAttachment","colorAttachment","resolveTarget","getCurrentTexture","_getRenderPassDescriptor","textureView","depthTextureData","occlusionQuerySet","currentOcclusionQuerySet","currentOcclusionQueryBuffer","occlusionQueryBuffer","createQuerySet","depthLoadOp","depthStoreOp","stencilLoadOp","stencilStoreOp","currentPass","currentSets","bindingGroups","setScissorRect","endOcclusionQuery","bufferSize","queryResolveBuffer","QUERY_RESOLVE","resolveQuerySet","results","BigUint64Array","BigInt","supportsDepth","supportsStencil","groupGPU","cmdEncoderGPU","passEncoderGPU","beginComputePass","maxComputeWorkgroupsPerDimension","limits","computeNodeData","dispatchSize","dispatchWorkgroups","onSubmittedWorkDone","currentBindingGroups","indexFormat","setIndexBuffer","vertexBuffer","setVertexBuffer","beginOcclusionQuery","drawInstances","drawIndexed","indexCount","firstIndex","drawIndexedIndirect","drawIndirect","primitiveTopology","materialVersion","timeStampQuerySet","timestampWrites","querySet","beginningOfPassWriteIndex","endOfPassWriteIndex","BigInt64Array","currentTimestampQueryBuffers","resolveBuffer","resultBuffer","mapState","times","_currentPass","_currentSets","bundleEncoder","bundleGPU","dstLayer","srcX","srcY","srcLayer","srcWidth","sourceGPU","destinationGPU","IESSpotLight","recursive","StandardNodeLibrary","WebGPURenderer","BackendClass","forceWebGL","isWebGPURenderer","BundleGroup","_material","PostProcessing","outputColorTransform","saveRendererState","resetRendererState","restoreRendererState","saveRendererAndSceneState","resetRendererAndSceneState","restoreRendererAndSceneState","PostProcessingUtils","StorageTexture","IndirectStorageBufferAttribute","NodeLoader","manager","load","url","onLoad","onProgress","onError","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","JSON","itemError","parseNodes","nodeJSON","createNodeFromType","setTextures","setNodes","NodeMaterialLoader","nodeMaterials","setNodeMaterials","createMaterialFromType","materialClass","NodeObjectLoader","_nodesJSON","parseMaterials","materials","ClippingGroup"],"sources":["/Users/BrooksCole/Documents/reading-community/frontend/node_modules/three/build/three.webgpu.js"],"sourcesContent":["/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nimport { Color, Vector2, Vector3, Vector4, Matrix3, Matrix4, EventDispatcher, MathUtils, ColorManagement, SRGBTransfer, NoToneMapping, StaticDrawUsage, InterleavedBuffer, DynamicDrawUsage, InterleavedBufferAttribute, NoColorSpace, UnsignedIntType, IntType, WebGLCoordinateSystem, BackSide, CubeReflectionMapping, CubeRefractionMapping, WebGPUCoordinateSystem, TangentSpaceNormalMap, ObjectSpaceNormalMap, InstancedInterleavedBuffer, InstancedBufferAttribute, DataArrayTexture, FloatType, FramebufferTexture, LinearMipmapLinearFilter, DepthTexture, Material, NormalBlending, PointsMaterial, LineBasicMaterial, LineDashedMaterial, NoBlending, MeshNormalMaterial, WebGLCubeRenderTarget, BoxGeometry, Mesh, Scene, LinearFilter, CubeCamera, CubeTexture, EquirectangularReflectionMapping, EquirectangularRefractionMapping, AddOperation, MixOperation, MultiplyOperation, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, Texture, MeshStandardMaterial, MeshPhysicalMaterial, MeshToonMaterial, MeshMatcapMaterial, SpriteMaterial, ShadowMaterial, Uint32BufferAttribute, Uint16BufferAttribute, DoubleSide, DepthStencilFormat, DepthFormat, UnsignedInt248Type, UnsignedByteType, RenderTarget, Plane, Object3D, HalfFloatType, LinearMipMapLinearFilter, OrthographicCamera, BufferGeometry, Float32BufferAttribute, BufferAttribute, UVMapping, Euler, LinearSRGBColorSpace, LessCompare, VSMShadowMap, RGFormat, BasicShadowMap, SphereGeometry, CubeUVReflectionMapping, PerspectiveCamera, RGBAFormat, LinearMipmapNearestFilter, NearestMipmapLinearFilter, Float16BufferAttribute, REVISION, SRGBColorSpace, PCFShadowMap, FrontSide, Frustum, DataTexture, RedIntegerFormat, RedFormat, RGIntegerFormat, RGBIntegerFormat, RGBFormat, RGBAIntegerFormat, UnsignedShortType, ByteType, ShortType, createCanvasElement, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, SrcAlphaFactor, SrcAlphaSaturateFactor, DstColorFactor, DstAlphaFactor, OneMinusSrcColorFactor, OneMinusSrcAlphaFactor, OneMinusDstColorFactor, OneMinusDstAlphaFactor, CullFaceNone, CullFaceBack, CullFaceFront, CustomBlending, MultiplyBlending, SubtractiveBlending, AdditiveBlending, NotEqualDepth, GreaterDepth, GreaterEqualDepth, EqualDepth, LessEqualDepth, LessDepth, AlwaysDepth, NeverDepth, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt5999Type, AlphaFormat, LuminanceFormat, LuminanceAlphaFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, RED_RGTC1_Format, SIGNED_RED_RGTC1_Format, RED_GREEN_RGTC2_Format, SIGNED_RED_GREEN_RGTC2_Format, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NeverCompare, AlwaysCompare, LessEqualCompare, EqualCompare, GreaterEqualCompare, GreaterCompare, NotEqualCompare, warnOnce, NotEqualStencilFunc, GreaterStencilFunc, GreaterEqualStencilFunc, EqualStencilFunc, LessEqualStencilFunc, LessStencilFunc, AlwaysStencilFunc, NeverStencilFunc, DecrementWrapStencilOp, IncrementWrapStencilOp, DecrementStencilOp, IncrementStencilOp, InvertStencilOp, ReplaceStencilOp, ZeroStencilOp, KeepStencilOp, MaxEquation, MinEquation, SpotLight, PointLight, DirectionalLight, RectAreaLight, AmbientLight, HemisphereLight, LightProbe, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, AgXToneMapping, NeutralToneMapping, Group, Loader, FileLoader, MaterialLoader, ObjectLoader } from './three.core.js';\nexport { AdditiveAnimationBlendMode, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BasicDepthPacking, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxHelper, BufferGeometryLoader, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CircleGeometry, Clock, ColorKeyframeTrack, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeTextureLoader, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceFrontBack, Curve, CurvePath, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataTextureLoader, DataUtils, DefaultLoadingManager, DetachedBindMode, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DynamicCopyUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, ExtrudeGeometry, Fog, FogExp2, GLBufferAttribute, GLSL1, GLSL3, GridHelper, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, InstancedBufferGeometry, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, KeyframeTrack, LOD, LatheGeometry, Layers, Light, Line, Line3, LineCurve, LineCurve3, LineLoop, LineSegments, LinearInterpolant, LinearMipMapNearestFilter, LinearTransfer, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, MOUSE, Matrix2, MeshDepthMaterial, MeshDistanceMaterial, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NormalAnimationBlendMode, NumberKeyframeTrack, OctahedronGeometry, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, PCFSoftShadowMap, Path, PlaneGeometry, PlaneHelper, PointLightHelper, Points, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RGBADepthPacking, RGBDepthPacking, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGDepthPacking, RawShaderMaterial, Ray, Raycaster, RingGeometry, ShaderMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, Spherical, SphericalHarmonics3, SplineCurve, SpotLightHelper, Sprite, StaticCopyUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, TOUCH, TetrahedronGeometry, TextureLoader, TextureUtils, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, VectorKeyframeTrack, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLMultipleRenderTargets, WebGLRenderTarget, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding } from './three.core.js';\n\nconst refreshUniforms = [\n\t'alphaMap',\n\t'alphaTest',\n\t'anisotropy',\n\t'anisotropyMap',\n\t'anisotropyRotation',\n\t'aoMap',\n\t'attenuationColor',\n\t'attenuationDistance',\n\t'bumpMap',\n\t'clearcoat',\n\t'clearcoatMap',\n\t'clearcoatNormalMap',\n\t'clearcoatNormalScale',\n\t'clearcoatRoughness',\n\t'color',\n\t'dispersion',\n\t'displacementMap',\n\t'emissive',\n\t'emissiveMap',\n\t'envMap',\n\t'gradientMap',\n\t'ior',\n\t'iridescence',\n\t'iridescenceIOR',\n\t'iridescenceMap',\n\t'iridescenceThicknessMap',\n\t'lightMap',\n\t'map',\n\t'matcap',\n\t'metalness',\n\t'metalnessMap',\n\t'normalMap',\n\t'normalScale',\n\t'opacity',\n\t'roughness',\n\t'roughnessMap',\n\t'sheen',\n\t'sheenColor',\n\t'sheenColorMap',\n\t'sheenRoughnessMap',\n\t'shininess',\n\t'specular',\n\t'specularColor',\n\t'specularColorMap',\n\t'specularIntensity',\n\t'specularIntensityMap',\n\t'specularMap',\n\t'thickness',\n\t'transmission',\n\t'transmissionMap'\n];\n\nclass NodeMaterialObserver {\n\n\tconstructor( builder ) {\n\n\t\tthis.renderObjects = new WeakMap();\n\t\tthis.hasNode = this.containsNode( builder );\n\t\tthis.hasAnimation = builder.object.isSkinnedMesh === true;\n\t\tthis.refreshUniforms = refreshUniforms;\n\t\tthis.renderId = 0;\n\n\t}\n\n\tfirstInitialization( renderObject ) {\n\n\t\tconst hasInitialized = this.renderObjects.has( renderObject );\n\n\t\tif ( hasInitialized === false ) {\n\n\t\t\tthis.getRenderObjectData( renderObject );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetRenderObjectData( renderObject ) {\n\n\t\tlet data = this.renderObjects.get( renderObject );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconst { geometry, material, object } = renderObject;\n\n\t\t\tdata = {\n\t\t\t\tmaterial: this.getMaterialData( material ),\n\t\t\t\tgeometry: {\n\t\t\t\t\tattributes: this.getAttributesData( geometry.attributes ),\n\t\t\t\t\tindexVersion: geometry.index ? geometry.index.version : null,\n\t\t\t\t\tdrawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }\n\t\t\t\t},\n\t\t\t\tworldMatrix: object.matrixWorld.clone()\n\t\t\t};\n\n\t\t\tif ( object.center ) {\n\n\t\t\t\tdata.center = object.center.clone();\n\n\t\t\t}\n\n\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\tdata.morphTargetInfluences = object.morphTargetInfluences.slice();\n\n\t\t\t}\n\n\t\t\tif ( renderObject.bundle !== null ) {\n\n\t\t\t\tdata.version = renderObject.bundle.version;\n\n\t\t\t}\n\n\t\t\tif ( data.material.transmission > 0 ) {\n\n\t\t\t\tconst { width, height } = renderObject.context;\n\n\t\t\t\tdata.bufferWidth = width;\n\t\t\t\tdata.bufferHeight = height;\n\n\t\t\t}\n\n\t\t\tthis.renderObjects.set( renderObject, data );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tgetAttributesData( attributes ) {\n\n\t\tconst attributesData = {};\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tattributesData[ name ] = {\n\t\t\t\tversion: attribute.version\n\t\t\t};\n\n\t\t}\n\n\t\treturn attributesData;\n\n\t}\n\n\tcontainsNode( builder ) {\n\n\t\tconst material = builder.material;\n\n\t\tfor ( const property in material ) {\n\n\t\t\tif ( material[ property ] && material[ property ].isNode )\n\t\t\t\treturn true;\n\n\t\t}\n\n\t\tif ( builder.renderer.nodes.modelViewMatrix !== null || builder.renderer.nodes.modelNormalViewMatrix !== null )\n\t\t\treturn true;\n\n\t\treturn false;\n\n\t}\n\n\tgetMaterialData( material ) {\n\n\t\tconst data = {};\n\n\t\tfor ( const property of this.refreshUniforms ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( value === null || value === undefined ) continue;\n\n\t\t\tif ( typeof value === 'object' && value.clone !== undefined ) {\n\n\t\t\t\tif ( value.isTexture === true ) {\n\n\t\t\t\t\tdata[ property ] = { id: value.id, version: value.version };\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdata[ property ] = value.clone();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdata[ property ] = value;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tequals( renderObject ) {\n\n\t\tconst { object, material, geometry } = renderObject;\n\n\t\tconst renderObjectData = this.getRenderObjectData( renderObject );\n\n\t\t// world matrix\n\n\t\tif ( renderObjectData.worldMatrix.equals( object.matrixWorld ) !== true ) {\n\n\t\t\trenderObjectData.worldMatrix.copy( object.matrixWorld );\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// material\n\n\t\tconst materialData = renderObjectData.material;\n\n\t\tfor ( const property in materialData ) {\n\n\t\t\tconst value = materialData[ property ];\n\t\t\tconst mtlValue = material[ property ];\n\n\t\t\tif ( value.equals !== undefined ) {\n\n\t\t\t\tif ( value.equals( mtlValue ) === false ) {\n\n\t\t\t\t\tvalue.copy( mtlValue );\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( mtlValue.isTexture === true ) {\n\n\t\t\t\tif ( value.id !== mtlValue.id || value.version !== mtlValue.version ) {\n\n\t\t\t\t\tvalue.id = mtlValue.id;\n\t\t\t\t\tvalue.version = mtlValue.version;\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( value !== mtlValue ) {\n\n\t\t\t\tmaterialData[ property ] = mtlValue;\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialData.transmission > 0 ) {\n\n\t\t\tconst { width, height } = renderObject.context;\n\n\t\t\tif ( renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height ) {\n\n\t\t\t\trenderObjectData.bufferWidth = width;\n\t\t\t\trenderObjectData.bufferHeight = height;\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// geometry\n\n\t\tconst storedGeometryData = renderObjectData.geometry;\n\t\tconst attributes = geometry.attributes;\n\t\tconst storedAttributes = storedGeometryData.attributes;\n\n\t\tconst storedAttributeNames = Object.keys( storedAttributes );\n\t\tconst currentAttributeNames = Object.keys( attributes );\n\n\t\tif ( storedAttributeNames.length !== currentAttributeNames.length ) {\n\n\t\t\trenderObjectData.geometry.attributes = this.getAttributesData( attributes );\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compare each attribute\n\n\t\tfor ( const name of storedAttributeNames ) {\n\n\t\t\tconst storedAttributeData = storedAttributes[ name ];\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tif ( attribute === undefined ) {\n\n\t\t\t\t// attribute was removed\n\t\t\t\tdelete storedAttributes[ name ];\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( storedAttributeData.version !== attribute.version ) {\n\n\t\t\t\tstoredAttributeData.version = attribute.version;\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check index\n\n\t\tconst index = geometry.index;\n\t\tconst storedIndexVersion = storedGeometryData.indexVersion;\n\t\tconst currentIndexVersion = index ? index.version : null;\n\n\t\tif ( storedIndexVersion !== currentIndexVersion ) {\n\n\t\t\tstoredGeometryData.indexVersion = currentIndexVersion;\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// check drawRange\n\n\t\tif ( storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count ) {\n\n\t\t\tstoredGeometryData.drawRange.start = geometry.drawRange.start;\n\t\t\tstoredGeometryData.drawRange.count = geometry.drawRange.count;\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tif ( renderObjectData.morphTargetInfluences ) {\n\n\t\t\tlet morphChanged = false;\n\n\t\t\tfor ( let i = 0; i < renderObjectData.morphTargetInfluences.length; i ++ ) {\n\n\t\t\t\tif ( renderObjectData.morphTargetInfluences[ i ] !== object.morphTargetInfluences[ i ] ) {\n\n\t\t\t\t\tmorphChanged = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( morphChanged ) return true;\n\n\t\t}\n\n\t\t// center\n\n\t\tif ( renderObjectData.center ) {\n\n\t\t\tif ( renderObjectData.center.equals( object.center ) === false ) {\n\n\t\t\t\trenderObjectData.center.copy( object.center );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// bundle\n\n\t\tif ( renderObject.bundle !== null ) {\n\n\t\t\trenderObjectData.version = renderObject.bundle.version;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tneedsRefresh( renderObject, nodeFrame ) {\n\n\t\tif ( this.hasNode || this.hasAnimation || this.firstInitialization( renderObject ) )\n\t\t\treturn true;\n\n\t\tconst { renderId } = nodeFrame;\n\n\t\tif ( this.renderId !== renderId ) {\n\n\t\t\tthis.renderId = renderId;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst isStatic = renderObject.object.static === true;\n\t\tconst isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData( renderObject ).version === renderObject.bundle.version;\n\n\t\tif ( isStatic || isBundle )\n\t\t\treturn false;\n\n\t\tconst notEqual = this.equals( renderObject ) !== true;\n\n\t\treturn notEqual;\n\n\t}\n\n}\n\n// cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.\n// A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.\n// Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.\n// See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480\n// https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\nfunction cyrb53( value, seed = 0 ) {\n\n\tlet h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n\n\tif ( value instanceof Array ) {\n\n\t\tfor ( let i = 0, val; i < value.length; i ++ ) {\n\n\t\t\tval = value[ i ];\n\t\t\th1 = Math.imul( h1 ^ val, 2654435761 );\n\t\t\th2 = Math.imul( h2 ^ val, 1597334677 );\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( let i = 0, ch; i < value.length; i ++ ) {\n\n\t\t\tch = value.charCodeAt( i );\n\t\t\th1 = Math.imul( h1 ^ ch, 2654435761 );\n\t\t\th2 = Math.imul( h2 ^ ch, 1597334677 );\n\n\t\t}\n\n\t}\n\n\th1 = Math.imul( h1 ^ ( h1 >>> 16 ), 2246822507 );\n\th1 ^= Math.imul( h2 ^ ( h2 >>> 13 ), 3266489909 );\n\th2 = Math.imul( h2 ^ ( h2 >>> 16 ), 2246822507 );\n\th2 ^= Math.imul( h1 ^ ( h1 >>> 13 ), 3266489909 );\n\n\treturn 4294967296 * ( 2097151 & h2 ) + ( h1 >>> 0 );\n\n}\n\nconst hashString = ( str ) => cyrb53( str );\nconst hashArray = ( array ) => cyrb53( array );\nconst hash$1 = ( ...params ) => cyrb53( params );\n\nfunction getCacheKey$1( object, force = false ) {\n\n\tconst values = [];\n\n\tif ( object.isNode === true ) {\n\n\t\tvalues.push( object.id );\n\t\tobject = object.getSelf();\n\n\t}\n\n\tfor ( const { property, childNode } of getNodeChildren( object ) ) {\n\n\t\tvalues.push( values, cyrb53( property.slice( 0, - 4 ) ), childNode.getCacheKey( force ) );\n\n\t}\n\n\treturn cyrb53( values );\n\n}\n\nfunction* getNodeChildren( node, toJSON = false ) {\n\n\tfor ( const property in node ) {\n\n\t\t// Ignore private properties.\n\t\tif ( property.startsWith( '_' ) === true ) continue;\n\n\t\tconst object = node[ property ];\n\n\t\tif ( Array.isArray( object ) === true ) {\n\n\t\t\tfor ( let i = 0; i < object.length; i ++ ) {\n\n\t\t\t\tconst child = object[ i ];\n\n\t\t\t\tif ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {\n\n\t\t\t\t\tyield { property, index: i, childNode: child };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( object && object.isNode === true ) {\n\n\t\t\tyield { property, childNode: object };\n\n\t\t} else if ( typeof object === 'object' ) {\n\n\t\t\tfor ( const subProperty in object ) {\n\n\t\t\t\tconst child = object[ subProperty ];\n\n\t\t\t\tif ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {\n\n\t\t\t\t\tyield { property, index: subProperty, childNode: child };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst typeFromLength = /*@__PURE__*/ new Map( [\n\t[ 1, 'float' ],\n\t[ 2, 'vec2' ],\n\t[ 3, 'vec3' ],\n\t[ 4, 'vec4' ],\n\t[ 9, 'mat3' ],\n\t[ 16, 'mat4' ]\n] );\n\nfunction getTypeFromLength( length ) {\n\n\treturn typeFromLength.get( length );\n\n}\n\nfunction getLengthFromType( type ) {\n\n\tif ( /float|int|uint/.test( type ) ) return 1;\n\tif ( /vec2/.test( type ) ) return 2;\n\tif ( /vec3/.test( type ) ) return 3;\n\tif ( /vec4/.test( type ) ) return 4;\n\tif ( /mat3/.test( type ) ) return 9;\n\tif ( /mat4/.test( type ) ) return 16;\n\n\tconsole.error( 'THREE.TSL: Unsupported type:', type );\n\n}\n\nfunction getValueType( value ) {\n\n\tif ( value === undefined || value === null ) return null;\n\n\tconst typeOf = typeof value;\n\n\tif ( value.isNode === true ) {\n\n\t\treturn 'node';\n\n\t} else if ( typeOf === 'number' ) {\n\n\t\treturn 'float';\n\n\t} else if ( typeOf === 'boolean' ) {\n\n\t\treturn 'bool';\n\n\t} else if ( typeOf === 'string' ) {\n\n\t\treturn 'string';\n\n\t} else if ( typeOf === 'function' ) {\n\n\t\treturn 'shader';\n\n\t} else if ( value.isVector2 === true ) {\n\n\t\treturn 'vec2';\n\n\t} else if ( value.isVector3 === true ) {\n\n\t\treturn 'vec3';\n\n\t} else if ( value.isVector4 === true ) {\n\n\t\treturn 'vec4';\n\n\t} else if ( value.isMatrix3 === true ) {\n\n\t\treturn 'mat3';\n\n\t} else if ( value.isMatrix4 === true ) {\n\n\t\treturn 'mat4';\n\n\t} else if ( value.isColor === true ) {\n\n\t\treturn 'color';\n\n\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\treturn 'ArrayBuffer';\n\n\t}\n\n\treturn null;\n\n}\n\nfunction getValueFromType( type, ...params ) {\n\n\tconst last4 = type ? type.slice( - 4 ) : undefined;\n\n\tif ( params.length === 1 ) { // ensure same behaviour as in NodeBuilder.format()\n\n\t\tif ( last4 === 'vec2' ) params = [ params[ 0 ], params[ 0 ] ];\n\t\telse if ( last4 === 'vec3' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ] ];\n\t\telse if ( last4 === 'vec4' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ], params[ 0 ] ];\n\n\t}\n\n\tif ( type === 'color' ) {\n\n\t\treturn new Color( ...params );\n\n\t} else if ( last4 === 'vec2' ) {\n\n\t\treturn new Vector2( ...params );\n\n\t} else if ( last4 === 'vec3' ) {\n\n\t\treturn new Vector3( ...params );\n\n\t} else if ( last4 === 'vec4' ) {\n\n\t\treturn new Vector4( ...params );\n\n\t} else if ( last4 === 'mat3' ) {\n\n\t\treturn new Matrix3( ...params );\n\n\t} else if ( last4 === 'mat4' ) {\n\n\t\treturn new Matrix4( ...params );\n\n\t} else if ( type === 'bool' ) {\n\n\t\treturn params[ 0 ] || false;\n\n\t} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {\n\n\t\treturn params[ 0 ] || 0;\n\n\t} else if ( type === 'string' ) {\n\n\t\treturn params[ 0 ] || '';\n\n\t} else if ( type === 'ArrayBuffer' ) {\n\n\t\treturn base64ToArrayBuffer( params[ 0 ] );\n\n\t}\n\n\treturn null;\n\n}\n\nfunction arrayBufferToBase64( arrayBuffer ) {\n\n\tlet chars = '';\n\n\tconst array = new Uint8Array( arrayBuffer );\n\n\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\tchars += String.fromCharCode( array[ i ] );\n\n\t}\n\n\treturn btoa( chars );\n\n}\n\nfunction base64ToArrayBuffer( base64 ) {\n\n\treturn Uint8Array.from( atob( base64 ), c => c.charCodeAt( 0 ) ).buffer;\n\n}\n\nvar NodeUtils = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tarrayBufferToBase64: arrayBufferToBase64,\n\tbase64ToArrayBuffer: base64ToArrayBuffer,\n\tgetCacheKey: getCacheKey$1,\n\tgetLengthFromType: getLengthFromType,\n\tgetNodeChildren: getNodeChildren,\n\tgetTypeFromLength: getTypeFromLength,\n\tgetValueFromType: getValueFromType,\n\tgetValueType: getValueType,\n\thash: hash$1,\n\thashArray: hashArray,\n\thashString: hashString\n});\n\nconst NodeShaderStage = {\n\tVERTEX: 'vertex',\n\tFRAGMENT: 'fragment'\n};\n\nconst NodeUpdateType = {\n\tNONE: 'none',\n\tFRAME: 'frame',\n\tRENDER: 'render',\n\tOBJECT: 'object'\n};\n\nconst NodeType = {\n\tBOOLEAN: 'bool',\n\tINTEGER: 'int',\n\tFLOAT: 'float',\n\tVECTOR2: 'vec2',\n\tVECTOR3: 'vec3',\n\tVECTOR4: 'vec4',\n\tMATRIX2: 'mat2',\n\tMATRIX3: 'mat3',\n\tMATRIX4: 'mat4'\n};\n\nconst NodeAccess = {\n\tREAD_ONLY: 'readOnly',\n\tWRITE_ONLY: 'writeOnly',\n\tREAD_WRITE: 'readWrite',\n};\n\nconst defaultShaderStages = [ 'fragment', 'vertex' ];\nconst defaultBuildStages = [ 'setup', 'analyze', 'generate' ];\nconst shaderStages = [ ...defaultShaderStages, 'compute' ];\nconst vectorComponents = [ 'x', 'y', 'z', 'w' ];\n\nlet _nodeId = 0;\n\nclass Node extends EventDispatcher {\n\n\tstatic get type() {\n\n\t\treturn 'Node';\n\n\t}\n\n\tconstructor( nodeType = null ) {\n\n\t\tsuper();\n\n\t\tthis.nodeType = nodeType;\n\n\t\tthis.updateType = NodeUpdateType.NONE;\n\t\tthis.updateBeforeType = NodeUpdateType.NONE;\n\t\tthis.updateAfterType = NodeUpdateType.NONE;\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tthis.version = 0;\n\n\t\tthis._cacheKey = null;\n\t\tthis._cacheKeyVersion = 0;\n\n\t\tthis.global = false;\n\n\t\tthis.isNode = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _nodeId ++ } );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t}\n\n\tget type() {\n\n\t\treturn this.constructor.type;\n\n\t}\n\n\tonUpdate( callback, updateType ) {\n\n\t\tthis.updateType = updateType;\n\t\tthis.update = callback.bind( this.getSelf() );\n\n\t\treturn this;\n\n\t}\n\n\tonFrameUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.FRAME );\n\n\t}\n\n\tonRenderUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.RENDER );\n\n\t}\n\n\tonObjectUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.OBJECT );\n\n\t}\n\n\tonReference( callback ) {\n\n\t\tthis.updateReference = callback.bind( this.getSelf() );\n\n\t\treturn this;\n\n\t}\n\n\tgetSelf() {\n\n\t\t// Returns non-node object.\n\n\t\treturn this.self || this;\n\n\t}\n\n\tupdateReference( /*state*/ ) {\n\n\t\treturn this;\n\n\t}\n\n\tisGlobal( /*builder*/ ) {\n\n\t\treturn this.global;\n\n\t}\n\n\t* getChildren() {\n\n\t\tfor ( const { childNode } of getNodeChildren( this ) ) {\n\n\t\t\tyield childNode;\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\ttraverse( callback ) {\n\n\t\tcallback( this );\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tchildNode.traverse( callback );\n\n\t\t}\n\n\t}\n\n\tgetCacheKey( force = false ) {\n\n\t\tforce = force || this.version !== this._cacheKeyVersion;\n\n\t\tif ( force === true || this._cacheKey === null ) {\n\n\t\t\tthis._cacheKey = getCacheKey$1( this, force );\n\t\t\tthis._cacheKeyVersion = this.version;\n\n\t\t}\n\n\t\treturn this._cacheKey;\n\n\t}\n\n\tgetScope() {\n\n\t\treturn this;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn this.uuid;\n\n\t}\n\n\tgetUpdateType() {\n\n\t\treturn this.updateType;\n\n\t}\n\n\tgetUpdateBeforeType() {\n\n\t\treturn this.updateBeforeType;\n\n\t}\n\n\tgetUpdateAfterType() {\n\n\t\treturn this.updateAfterType;\n\n\t}\n\n\tgetElementType( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst elementType = builder.getElementType( type );\n\n\t\treturn elementType;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tif ( nodeProperties.outputNode ) {\n\n\t\t\treturn nodeProperties.outputNode.getNodeType( builder );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\tgetShared( builder ) {\n\n\t\tconst hash = this.getHash( builder );\n\t\tconst nodeFromHash = builder.getNodeFromHash( hash );\n\n\t\treturn nodeFromHash || this;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tlet index = 0;\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tnodeProperties[ 'node' + index ++ ] = childNode;\n\n\t\t}\n\n\t\t// return a outputNode if exists\n\t\treturn null;\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tconst usageCount = builder.increaseUsage( this );\n\n\t\tif ( usageCount === 1 ) {\n\n\t\t\t// node flow children\n\n\t\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\t\tfor ( const childNode of Object.values( nodeProperties ) ) {\n\n\t\t\t\tif ( childNode && childNode.isNode === true ) {\n\n\t\t\t\t\tchildNode.build( builder );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { outputNode } = builder.getNodeProperties( this );\n\n\t\tif ( outputNode && outputNode.isNode === true ) {\n\n\t\t\treturn outputNode.build( builder, output );\n\n\t\t}\n\n\t}\n\n\tupdateBefore( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tupdateAfter( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tbuild( builder, output = null ) {\n\n\t\tconst refNode = this.getShared( builder );\n\n\t\tif ( this !== refNode ) {\n\n\t\t\treturn refNode.build( builder, output );\n\n\t\t}\n\n\t\tbuilder.addNode( this );\n\t\tbuilder.addChain( this );\n\n\t\t/* Build stages expected results:\n\t\t\t- \"setup\"\t\t-> Node\n\t\t\t- \"analyze\"\t\t-> null\n\t\t\t- \"generate\"\t-> String\n\t\t*/\n\t\tlet result = null;\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'setup' ) {\n\n\t\t\tthis.updateReference( builder );\n\n\t\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t\tif ( properties.initialized !== true ) {\n\n\t\t\t\tconst stackNodesBeforeSetup = builder.stack.nodes.length;\n\n\t\t\t\tproperties.initialized = true;\n\t\t\t\tproperties.outputNode = this.setup( builder );\n\n\t\t\t\tif ( properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeSetup ) ;\n\n\t\t\t\tfor ( const childNode of Object.values( properties ) ) {\n\n\t\t\t\t\tif ( childNode && childNode.isNode === true ) {\n\n\t\t\t\t\t\tchildNode.build( builder );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( buildStage === 'analyze' ) {\n\n\t\t\tthis.analyze( builder );\n\n\t\t} else if ( buildStage === 'generate' ) {\n\n\t\t\tconst isGenerateOnce = this.generate.length === 1;\n\n\t\t\tif ( isGenerateOnce ) {\n\n\t\t\t\tconst type = this.getNodeType( builder );\n\t\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\t\tresult = nodeData.snippet;\n\n\t\t\t\tif ( result === undefined ) {\n\n\t\t\t\t\tresult = this.generate( builder ) || '';\n\n\t\t\t\t\tnodeData.snippet = result;\n\n\t\t\t\t} else if ( nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined ) {\n\n\t\t\t\t\tbuilder.addFlowCodeHierarchy( this, builder.context.nodeBlock );\n\n\t\t\t\t}\n\n\t\t\t\tresult = builder.format( result, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tresult = this.generate( builder, output ) || '';\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeChain( this );\n\t\tbuilder.addSequentialNode( this );\n\n\t\treturn result;\n\n\t}\n\n\tgetSerializeChildren() {\n\n\t\treturn getNodeChildren( this );\n\n\t}\n\n\tserialize( json ) {\n\n\t\tconst nodeChildren = this.getSerializeChildren();\n\n\t\tconst inputNodes = {};\n\n\t\tfor ( const { property, index, childNode } of nodeChildren ) {\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tif ( inputNodes[ property ] === undefined ) {\n\n\t\t\t\t\tinputNodes[ property ] = Number.isInteger( index ) ? [] : {};\n\n\t\t\t\t}\n\n\t\t\t\tinputNodes[ property ][ index ] = childNode.toJSON( json.meta ).uuid;\n\n\t\t\t} else {\n\n\t\t\t\tinputNodes[ property ] = childNode.toJSON( json.meta ).uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( inputNodes ).length > 0 ) {\n\n\t\t\tjson.inputNodes = inputNodes;\n\n\t\t}\n\n\t}\n\n\tdeserialize( json ) {\n\n\t\tif ( json.inputNodes !== undefined ) {\n\n\t\t\tconst nodes = json.meta.nodes;\n\n\t\t\tfor ( const property in json.inputNodes ) {\n\n\t\t\t\tif ( Array.isArray( json.inputNodes[ property ] ) ) {\n\n\t\t\t\t\tconst inputArray = [];\n\n\t\t\t\t\tfor ( const uuid of json.inputNodes[ property ] ) {\n\n\t\t\t\t\t\tinputArray.push( nodes[ uuid ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis[ property ] = inputArray;\n\n\t\t\t\t} else if ( typeof json.inputNodes[ property ] === 'object' ) {\n\n\t\t\t\t\tconst inputObject = {};\n\n\t\t\t\t\tfor ( const subProperty in json.inputNodes[ property ] ) {\n\n\t\t\t\t\t\tconst uuid = json.inputNodes[ property ][ subProperty ];\n\n\t\t\t\t\t\tinputObject[ subProperty ] = nodes[ uuid ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis[ property ] = inputObject;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst uuid = json.inputNodes[ property ];\n\n\t\t\t\t\tthis[ property ] = nodes[ uuid ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst { uuid, type } = this;\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\t// serialize\n\n\t\tlet data = meta.nodes[ uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = {\n\t\t\t\tuuid,\n\t\t\t\ttype,\n\t\t\t\tmeta,\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.6,\n\t\t\t\t\ttype: 'Node',\n\t\t\t\t\tgenerator: 'Node.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif ( isRoot !== true ) meta.nodes[ data.uuid ] = data;\n\n\t\t\tthis.serialize( data );\n\n\t\t\tdelete data.meta;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass ArrayElementNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ArrayElementNode';\n\n\t} // @TODO: If extending from TempNode it breaks webgpu_compute\n\n\tconstructor( node, indexNode ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.indexNode = indexNode;\n\n\t\tthis.isArrayElementNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getElementType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeSnippet = this.node.build( builder );\n\t\tconst indexSnippet = this.indexNode.build( builder, 'uint' );\n\n\t\treturn `${nodeSnippet}[ ${indexSnippet} ]`;\n\n\t}\n\n}\n\nclass ConvertNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ConvertNode';\n\n\t}\n\n\tconstructor( node, convertTo ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.convertTo = convertTo;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst requestType = this.node.getNodeType( builder );\n\n\t\tlet convertTo = null;\n\n\t\tfor ( const overloadingType of this.convertTo.split( '|' ) ) {\n\n\t\t\tif ( convertTo === null || builder.getTypeLength( requestType ) === builder.getTypeLength( overloadingType ) ) {\n\n\t\t\t\tconvertTo = overloadingType;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn convertTo;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.convertTo = this.convertTo;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.convertTo = data.convertTo;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst snippet = node.build( builder, type );\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\nclass TempNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TempNode';\n\n\t}\n\n\tconstructor( type ) {\n\n\t\tsuper( type );\n\n\t\tthis.isTempNode = true;\n\n\t}\n\n\thasDependencies( builder ) {\n\n\t\treturn builder.getDataFromNode( this ).usageCount > 1;\n\n\t}\n\n\tbuild( builder, output ) {\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'generate' ) {\n\n\t\t\tconst type = builder.getVectorType( this.getNodeType( builder, output ) );\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tif ( nodeData.propertyName !== undefined ) {\n\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t\t} else if ( type !== 'void' && output !== 'void' && this.hasDependencies( builder ) ) {\n\n\t\t\t\tconst snippet = super.build( builder, type );\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, null, type );\n\t\t\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}`, this );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.build( builder, output );\n\n\t}\n\n}\n\nclass JoinNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'JoinNode';\n\n\t}\n\n\tconstructor( nodes = [], nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.nodes = nodes;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( this.nodeType !== null ) {\n\n\t\t\treturn builder.getVectorType( this.nodeType );\n\n\t\t}\n\n\t\treturn builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst nodes = this.nodes;\n\n\t\tconst primitiveType = builder.getComponentType( type );\n\n\t\tconst snippetValues = [];\n\n\t\tfor ( const input of nodes ) {\n\n\t\t\tlet inputSnippet = input.build( builder );\n\n\t\t\tconst inputPrimitiveType = builder.getComponentType( input.getNodeType( builder ) );\n\n\t\t\tif ( inputPrimitiveType !== primitiveType ) {\n\n\t\t\t\tinputSnippet = builder.format( inputSnippet, inputPrimitiveType, primitiveType );\n\n\t\t\t}\n\n\t\t\tsnippetValues.push( inputSnippet );\n\n\t\t}\n\n\t\tconst snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\nconst stringVectorComponents = vectorComponents.join( '' );\n\nclass SplitNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SplitNode';\n\n\t}\n\n\tconstructor( node, components = 'x' ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.components = components;\n\n\t\tthis.isSplitNode = true;\n\n\t}\n\n\tgetVectorLength() {\n\n\t\tlet vectorLength = this.components.length;\n\n\t\tfor ( const c of this.components ) {\n\n\t\t\tvectorLength = Math.max( vectorComponents.indexOf( c ) + 1, vectorLength );\n\n\t\t}\n\n\t\treturn vectorLength;\n\n\t}\n\n\tgetComponentType( builder ) {\n\n\t\treturn builder.getComponentType( this.node.getNodeType( builder ) );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn builder.getTypeFromLength( this.components.length, this.getComponentType( builder ) );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );\n\n\t\tlet snippet = null;\n\n\t\tif ( nodeTypeLength > 1 ) {\n\n\t\t\tlet type = null;\n\n\t\t\tconst componentsLength = this.getVectorLength();\n\n\t\t\tif ( componentsLength >= nodeTypeLength ) {\n\n\t\t\t\t// needed expand the input node\n\n\t\t\t\ttype = builder.getTypeFromLength( this.getVectorLength(), this.getComponentType( builder ) );\n\n\t\t\t}\n\n\t\t\tconst nodeSnippet = node.build( builder, type );\n\n\t\t\tif ( this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice( 0, this.components.length ) ) {\n\n\t\t\t\t// unnecessary swizzle\n\n\t\t\t\tsnippet = builder.format( nodeSnippet, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// ignore .components if .node returns float/integer\n\n\t\t\tsnippet = node.build( builder, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.components = this.components;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.components = data.components;\n\n\t}\n\n}\n\nclass SetNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'SetNode';\n\n\t}\n\n\tconstructor( sourceNode, components, targetNode ) {\n\n\t\tsuper();\n\n\t\tthis.sourceNode = sourceNode;\n\t\tthis.components = components;\n\t\tthis.targetNode = targetNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.sourceNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { sourceNode, components, targetNode } = this;\n\n\t\tconst sourceType = this.getNodeType( builder );\n\t\tconst targetType = builder.getTypeFromLength( components.length, targetNode.getNodeType( builder ) );\n\n\t\tconst targetSnippet = targetNode.build( builder, targetType );\n\t\tconst sourceSnippet = sourceNode.build( builder, sourceType );\n\n\t\tconst length = builder.getTypeLength( sourceType );\n\t\tconst snippetValues = [];\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst component = vectorComponents[ i ];\n\n\t\t\tif ( component === components[ 0 ] ) {\n\n\t\t\t\tsnippetValues.push( targetSnippet );\n\n\t\t\t\ti += components.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tsnippetValues.push( sourceSnippet + '.' + component );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\nclass FlipNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FlipNode';\n\n\t}\n\n\tconstructor( sourceNode, components ) {\n\n\t\tsuper();\n\n\t\tthis.sourceNode = sourceNode;\n\t\tthis.components = components;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.sourceNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { components, sourceNode } = this;\n\n\t\tconst sourceType = this.getNodeType( builder );\n\t\tconst sourceSnippet = sourceNode.build( builder );\n\n\t\tconst sourceCache = builder.getVarFromNode( this );\n\t\tconst sourceProperty = builder.getPropertyName( sourceCache );\n\n\t\tbuilder.addLineFlowCode( sourceProperty + ' = ' + sourceSnippet, this );\n\n\t\tconst length = builder.getTypeLength( sourceType );\n\t\tconst snippetValues = [];\n\n\t\tlet componentIndex = 0;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst component = vectorComponents[ i ];\n\n\t\t\tif ( component === components[ componentIndex ] ) {\n\n\t\t\t\tsnippetValues.push( '1.0 - ' + ( sourceProperty + '.' + component ) );\n\n\t\t\t\tcomponentIndex ++;\n\n\t\t\t} else {\n\n\t\t\t\tsnippetValues.push( sourceProperty + '.' + component );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\nclass InputNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'InputNode';\n\n\t}\n\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.isInputNode = true;\n\n\t\tthis.value = value;\n\t\tthis.precision = null;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.nodeType === null ) {\n\n\t\t\treturn getValueType( this.value );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\tsetPrecision( precision ) {\n\n\t\tthis.precision = precision;\n\n\t\treturn this;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value;\n\n\t\tif ( this.value && this.value.toArray ) data.value = this.value.toArray();\n\n\t\tdata.valueType = getValueType( this.value );\n\t\tdata.nodeType = this.nodeType;\n\n\t\tif ( data.valueType === 'ArrayBuffer' ) data.value = arrayBufferToBase64( data.value );\n\n\t\tdata.precision = this.precision;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.nodeType = data.nodeType;\n\t\tthis.value = Array.isArray( data.value ) ? getValueFromType( data.valueType, ...data.value ) : data.value;\n\n\t\tthis.precision = data.precision || null;\n\n\t\tif ( this.value && this.value.fromArray ) this.value = this.value.fromArray( data.value );\n\n\t}\n\n\tgenerate( /*builder, output*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nclass ConstNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'ConstNode';\n\n\t}\n\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\tthis.isConstNode = true;\n\n\t}\n\n\tgenerateConst( builder ) {\n\n\t\treturn builder.generateConst( this.getNodeType( builder ), this.value );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\treturn builder.format( this.generateConst( builder ), type, output );\n\n\t}\n\n}\n\n//\n\nlet currentStack = null;\n\nconst NodeElements = new Map();\n\nfunction addMethodChaining( name, nodeElement ) {\n\n\tif ( NodeElements.has( name ) ) {\n\n\t\tconsole.warn( `Redefinition of method chaining ${ name }` );\n\t\treturn;\n\n\t}\n\n\tif ( typeof nodeElement !== 'function' ) throw new Error( `Node element ${ name } is not a function` );\n\n\tNodeElements.set( name, nodeElement );\n\n}\n\nconst parseSwizzle = ( props ) => props.replace( /r|s/g, 'x' ).replace( /g|t/g, 'y' ).replace( /b|p/g, 'z' ).replace( /a|q/g, 'w' );\nconst parseSwizzleAndSort = ( props ) => parseSwizzle( props ).split( '' ).sort().join( '' );\n\nconst shaderNodeHandler = {\n\n\tsetup( NodeClosure, params ) {\n\n\t\tconst inputs = params.shift();\n\n\t\treturn NodeClosure( nodeObjects( inputs ), ...params );\n\n\t},\n\n\tget( node, prop, nodeObj ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\tif ( node.isStackNode !== true && prop === 'assign' ) {\n\n\t\t\t\treturn ( ...params ) => {\n\n\t\t\t\t\tcurrentStack.assign( nodeObj, ...params );\n\n\t\t\t\t\treturn nodeObj;\n\n\t\t\t\t};\n\n\t\t\t} else if ( NodeElements.has( prop ) ) {\n\n\t\t\t\tconst nodeElement = NodeElements.get( prop );\n\n\t\t\t\treturn node.isStackNode ? ( ...params ) => nodeObj.add( nodeElement( ...params ) ) : ( ...params ) => nodeElement( nodeObj, ...params );\n\n\t\t\t} else if ( prop === 'self' ) {\n\n\t\t\t\treturn node;\n\n\t\t\t} else if ( prop.endsWith( 'Assign' ) && NodeElements.has( prop.slice( 0, prop.length - 'Assign'.length ) ) ) {\n\n\t\t\t\tconst nodeElement = NodeElements.get( prop.slice( 0, prop.length - 'Assign'.length ) );\n\n\t\t\t\treturn node.isStackNode ? ( ...params ) => nodeObj.assign( params[ 0 ], nodeElement( ...params ) ) : ( ...params ) => nodeObj.assign( nodeElement( nodeObj, ...params ) );\n\n\t\t\t} else if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing properties ( swizzle )\n\n\t\t\t\tprop = parseSwizzle( prop );\n\n\t\t\t\treturn nodeObject( new SplitNode( nodeObj, prop ) );\n\n\t\t\t} else if ( /^set[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// set properties ( swizzle ) and sort to xyzw sequence\n\n\t\t\t\tprop = parseSwizzleAndSort( prop.slice( 3 ).toLowerCase() );\n\n\t\t\t\treturn ( value ) => nodeObject( new SetNode( node, prop, value ) );\n\n\t\t\t} else if ( /^flip[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// set properties ( swizzle ) and sort to xyzw sequence\n\n\t\t\t\tprop = parseSwizzleAndSort( prop.slice( 4 ).toLowerCase() );\n\n\t\t\t\treturn () => nodeObject( new FlipNode( nodeObject( node ), prop ) );\n\n\t\t\t} else if ( prop === 'width' || prop === 'height' || prop === 'depth' ) {\n\n\t\t\t\t// accessing property\n\n\t\t\t\tif ( prop === 'width' ) prop = 'x';\n\t\t\t\telse if ( prop === 'height' ) prop = 'y';\n\t\t\t\telse if ( prop === 'depth' ) prop = 'z';\n\n\t\t\t\treturn nodeObject( new SplitNode( node, prop ) );\n\n\t\t\t} else if ( /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing array\n\n\t\t\t\treturn nodeObject( new ArrayElementNode( nodeObj, new ConstNode( Number( prop ), 'uint' ) ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Reflect.get( node, prop, nodeObj );\n\n\t},\n\n\tset( node, prop, value, nodeObj ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\t// setting properties\n\n\t\t\tif ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\tnodeObj[ prop ].assign( value );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Reflect.set( node, prop, value, nodeObj );\n\n\t}\n\n};\n\nconst nodeObjectsCacheMap = new WeakMap();\nconst nodeBuilderFunctionsCacheMap = new WeakMap();\n\nconst ShaderNodeObject = function ( obj, altType = null ) {\n\n\tconst type = getValueType( obj );\n\n\tif ( type === 'node' ) {\n\n\t\tlet nodeObject = nodeObjectsCacheMap.get( obj );\n\n\t\tif ( nodeObject === undefined ) {\n\n\t\t\tnodeObject = new Proxy( obj, shaderNodeHandler );\n\n\t\t\tnodeObjectsCacheMap.set( obj, nodeObject );\n\t\t\tnodeObjectsCacheMap.set( nodeObject, nodeObject );\n\n\t\t}\n\n\t\treturn nodeObject;\n\n\t} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {\n\n\t\treturn nodeObject( getConstNode( obj, altType ) );\n\n\t} else if ( type === 'shader' ) {\n\n\t\treturn Fn( obj );\n\n\t}\n\n\treturn obj;\n\n};\n\nconst ShaderNodeObjects = function ( objects, altType = null ) {\n\n\tfor ( const name in objects ) {\n\n\t\tobjects[ name ] = nodeObject( objects[ name ], altType );\n\n\t}\n\n\treturn objects;\n\n};\n\nconst ShaderNodeArray = function ( array, altType = null ) {\n\n\tconst len = array.length;\n\n\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\tarray[ i ] = nodeObject( array[ i ], altType );\n\n\t}\n\n\treturn array;\n\n};\n\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {\n\n\tconst assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );\n\n\tif ( scope === null ) {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( ...nodeArray( params ) ) );\n\n\t\t};\n\n\t} else if ( factor !== null ) {\n\n\t\tfactor = nodeObject( factor );\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ), factor ) );\n\n\t\t};\n\n\t} else {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ) ) );\n\n\t\t};\n\n\t}\n\n};\n\nconst ShaderNodeImmutable = function ( NodeClass, ...params ) {\n\n\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\n\n};\n\nclass ShaderCallNodeInternal extends Node {\n\n\tconstructor( shaderNode, inputNodes ) {\n\n\t\tsuper();\n\n\t\tthis.shaderNode = shaderNode;\n\t\tthis.inputNodes = inputNodes;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.shaderNode.nodeType || this.getOutputNode( builder ).getNodeType( builder );\n\n\t}\n\n\tcall( builder ) {\n\n\t\tconst { shaderNode, inputNodes } = this;\n\n\t\tconst properties = builder.getNodeProperties( shaderNode );\n\t\tif ( properties.onceOutput ) return properties.onceOutput;\n\n\t\t//\n\n\t\tlet result = null;\n\n\t\tif ( shaderNode.layout ) {\n\n\t\t\tlet functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get( builder.constructor );\n\n\t\t\tif ( functionNodesCacheMap === undefined ) {\n\n\t\t\t\tfunctionNodesCacheMap = new WeakMap();\n\n\t\t\t\tnodeBuilderFunctionsCacheMap.set( builder.constructor, functionNodesCacheMap );\n\n\t\t\t}\n\n\t\t\tlet functionNode = functionNodesCacheMap.get( shaderNode );\n\n\t\t\tif ( functionNode === undefined ) {\n\n\t\t\t\tfunctionNode = nodeObject( builder.buildFunctionNode( shaderNode ) );\n\n\t\t\t\tfunctionNodesCacheMap.set( shaderNode, functionNode );\n\n\t\t\t}\n\n\t\t\tif ( builder.currentFunctionNode !== null ) {\n\n\t\t\t\tbuilder.currentFunctionNode.includes.push( functionNode );\n\n\t\t\t}\n\n\t\t\tresult = nodeObject( functionNode.call( inputNodes ) );\n\n\t\t} else {\n\n\t\t\tconst jsFunc = shaderNode.jsFunc;\n\t\t\tconst outputNode = inputNodes !== null ? jsFunc( inputNodes, builder ) : jsFunc( builder );\n\n\t\t\tresult = nodeObject( outputNode );\n\n\t\t}\n\n\t\tif ( shaderNode.once ) {\n\n\t\t\tproperties.onceOutput = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tgetOutputNode( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.outputNode === null ) {\n\n\t\t\tproperties.outputNode = this.setupOutput( builder );\n\n\t\t}\n\n\t\treturn properties.outputNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\treturn this.getOutputNode( builder );\n\n\t}\n\n\tsetupOutput( builder ) {\n\n\t\tbuilder.addStack();\n\n\t\tbuilder.stack.outputNode = this.call( builder );\n\n\t\treturn builder.removeStack();\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst outputNode = this.getOutputNode( builder );\n\n\t\treturn outputNode.build( builder, output );\n\n\t}\n\n}\n\nclass ShaderNodeInternal extends Node {\n\n\tconstructor( jsFunc, nodeType ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.jsFunc = jsFunc;\n\t\tthis.layout = null;\n\n\t\tthis.global = true;\n\n\t\tthis.once = false;\n\n\t}\n\n\tsetLayout( layout ) {\n\n\t\tthis.layout = layout;\n\n\t\treturn this;\n\n\t}\n\n\tcall( inputs = null ) {\n\n\t\tnodeObjects( inputs );\n\n\t\treturn nodeObject( new ShaderCallNodeInternal( this, inputs ) );\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.call();\n\n\t}\n\n}\n\nconst bools = [ false, true ];\nconst uints = [ 0, 1, 2, 3 ];\nconst ints = [ - 1, - 2 ];\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];\n\nconst boolsCacheMap = new Map();\nfor ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\n\nconst uintsCacheMap = new Map();\nfor ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\n\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\nfor ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\n\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\nfor ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\nfor ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\n\nconst cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\n\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\n\nconst getConstNode = ( value, type ) => {\n\n\tif ( constNodesCacheMap.has( value ) ) {\n\n\t\treturn constNodesCacheMap.get( value );\n\n\t} else if ( value.isNode === true ) {\n\n\t\treturn value;\n\n\t} else {\n\n\t\treturn new ConstNode( value, type );\n\n\t}\n\n};\n\nconst safeGetNodeType = ( node ) => {\n\n\ttry {\n\n\t\treturn node.getNodeType();\n\n\t} catch ( _ ) {\n\n\t\treturn undefined;\n\n\t}\n\n};\n\nconst ConvertType = function ( type, cacheMap = null ) {\n\n\treturn ( ...params ) => {\n\n\t\tif ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => typeof param !== 'object' ) ) ) {\n\n\t\t\tparams = [ getValueFromType( type, ...params ) ];\n\n\t\t}\n\n\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\n\n\t\t\treturn nodeObject( cacheMap.get( params[ 0 ] ) );\n\n\t\t}\n\n\t\tif ( params.length === 1 ) {\n\n\t\t\tconst node = getConstNode( params[ 0 ], type );\n\t\t\tif ( safeGetNodeType( node ) === type ) return nodeObject( node );\n\t\t\treturn nodeObject( new ConvertNode( node, type ) );\n\n\t\t}\n\n\t\tconst nodes = params.map( param => getConstNode( param ) );\n\t\treturn nodeObject( new JoinNode( nodes, type ) );\n\n\t};\n\n};\n\n// exports\n\nconst defined = ( v ) => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function\n\n// utils\n\nconst getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;\n\n// shader node base\n\nfunction ShaderNode( jsFunc, nodeType ) {\n\n\treturn new Proxy( new ShaderNodeInternal( jsFunc, nodeType ), shaderNodeHandler );\n\n}\n\nconst nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );\nconst nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );\nconst nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );\nconst nodeProxy = ( ...params ) => new ShaderNodeProxy( ...params );\nconst nodeImmutable = ( ...params ) => new ShaderNodeImmutable( ...params );\n\nconst Fn = ( jsFunc, nodeType ) => {\n\n\tconst shaderNode = new ShaderNode( jsFunc, nodeType );\n\n\tconst fn = ( ...params ) => {\n\n\t\tlet inputs;\n\n\t\tnodeObjects( params );\n\n\t\tif ( params[ 0 ] && params[ 0 ].isNode ) {\n\n\t\t\tinputs = [ ...params ];\n\n\t\t} else {\n\n\t\t\tinputs = params[ 0 ];\n\n\t\t}\n\n\t\treturn shaderNode.call( inputs );\n\n\t};\n\n\tfn.shaderNode = shaderNode;\n\n\tfn.setLayout = ( layout ) => {\n\n\t\tshaderNode.setLayout( layout );\n\n\t\treturn fn;\n\n\t};\n\n\tfn.once = () => {\n\n\t\tshaderNode.once = true;\n\n\t\treturn fn;\n\n\t};\n\n\treturn fn;\n\n};\n\nconst tslFn = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ShaderNode: tslFn() has been renamed to Fn().' );\n\treturn Fn( ...params );\n\n};\n\n//\n\naddMethodChaining( 'toGlobal', ( node ) => {\n\n\tnode.global = true;\n\n\treturn node;\n\n} );\n\n//\n\nconst setCurrentStack = ( stack ) => {\n\n\tcurrentStack = stack;\n\n};\n\nconst getCurrentStack = () => currentStack;\n\nconst If = ( ...params ) => currentStack.If( ...params );\n\nfunction append( node ) {\n\n\tif ( currentStack ) currentStack.add( node );\n\n\treturn node;\n\n}\n\naddMethodChaining( 'append', append );\n\n// types\n\nconst color = new ConvertType( 'color' );\n\nconst float = new ConvertType( 'float', cacheMaps.float );\nconst int = new ConvertType( 'int', cacheMaps.ints );\nconst uint = new ConvertType( 'uint', cacheMaps.uint );\nconst bool = new ConvertType( 'bool', cacheMaps.bool );\n\nconst vec2 = new ConvertType( 'vec2' );\nconst ivec2 = new ConvertType( 'ivec2' );\nconst uvec2 = new ConvertType( 'uvec2' );\nconst bvec2 = new ConvertType( 'bvec2' );\n\nconst vec3 = new ConvertType( 'vec3' );\nconst ivec3 = new ConvertType( 'ivec3' );\nconst uvec3 = new ConvertType( 'uvec3' );\nconst bvec3 = new ConvertType( 'bvec3' );\n\nconst vec4 = new ConvertType( 'vec4' );\nconst ivec4 = new ConvertType( 'ivec4' );\nconst uvec4 = new ConvertType( 'uvec4' );\nconst bvec4 = new ConvertType( 'bvec4' );\n\nconst mat2 = new ConvertType( 'mat2' );\nconst mat3 = new ConvertType( 'mat3' );\nconst mat4 = new ConvertType( 'mat4' );\n\nconst string = ( value = '' ) => nodeObject( new ConstNode( value, 'string' ) );\nconst arrayBuffer = ( value ) => nodeObject( new ConstNode( value, 'ArrayBuffer' ) );\n\naddMethodChaining( 'toColor', color );\naddMethodChaining( 'toFloat', float );\naddMethodChaining( 'toInt', int );\naddMethodChaining( 'toUint', uint );\naddMethodChaining( 'toBool', bool );\naddMethodChaining( 'toVec2', vec2 );\naddMethodChaining( 'toIVec2', ivec2 );\naddMethodChaining( 'toUVec2', uvec2 );\naddMethodChaining( 'toBVec2', bvec2 );\naddMethodChaining( 'toVec3', vec3 );\naddMethodChaining( 'toIVec3', ivec3 );\naddMethodChaining( 'toUVec3', uvec3 );\naddMethodChaining( 'toBVec3', bvec3 );\naddMethodChaining( 'toVec4', vec4 );\naddMethodChaining( 'toIVec4', ivec4 );\naddMethodChaining( 'toUVec4', uvec4 );\naddMethodChaining( 'toBVec4', bvec4 );\naddMethodChaining( 'toMat2', mat2 );\naddMethodChaining( 'toMat3', mat3 );\naddMethodChaining( 'toMat4', mat4 );\n\n// basic nodes\n\nconst element = /*@__PURE__*/ nodeProxy( ArrayElementNode );\nconst convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );\nconst split = ( node, channels ) => nodeObject( new SplitNode( nodeObject( node ), channels ) );\n\naddMethodChaining( 'element', element );\naddMethodChaining( 'convert', convert );\n\nclass UniformGroupNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'UniformGroupNode';\n\n\t}\n\n\tconstructor( name, shared = false, order = 1 ) {\n\n\t\tsuper( 'string' );\n\n\t\tthis.name = name;\n\t\tthis.version = 0;\n\n\t\tthis.shared = shared;\n\t\tthis.order = order;\n\t\tthis.isUniformGroup = true;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.name = this.name;\n\t\tdata.version = this.version;\n\t\tdata.shared = this.shared;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.name = data.name;\n\t\tthis.version = data.version;\n\t\tthis.shared = data.shared;\n\n\t}\n\n}\n\nconst uniformGroup = ( name ) => new UniformGroupNode( name );\nconst sharedUniformGroup = ( name, order = 0 ) => new UniformGroupNode( name, true, order );\n\nconst frameGroup = /*@__PURE__*/ sharedUniformGroup( 'frame' );\nconst renderGroup = /*@__PURE__*/ sharedUniformGroup( 'render' );\nconst objectGroup = /*@__PURE__*/ uniformGroup( 'object' );\n\nclass UniformNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformNode';\n\n\t}\n\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\tthis.isUniformNode = true;\n\n\t\tthis.name = '';\n\t\tthis.groupNode = objectGroup;\n\n\t}\n\n\tlabel( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\tsetGroup( group ) {\n\n\t\tthis.groupNode = group;\n\n\t\treturn this;\n\n\t}\n\n\tgetGroup() {\n\n\t\treturn this.groupNode;\n\n\t}\n\n\tgetUniformHash( builder ) {\n\n\t\treturn this.getHash( builder );\n\n\t}\n\n\tonUpdate( callback, updateType ) {\n\n\t\tconst self = this.getSelf();\n\n\t\tcallback = callback.bind( self );\n\n\t\treturn super.onUpdate( ( frame ) => {\n\n\t\t\tconst value = callback( frame, self );\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\tthis.value = value;\n\n\t\t\t}\n\n\t \t}, updateType );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst hash = this.getUniformHash( builder );\n\n\t\tlet sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode === undefined ) {\n\n\t\t\tbuilder.setHashNode( this, hash );\n\n\t\t\tsharedNode = this;\n\n\t\t}\n\n\t\tconst sharedNodeType = sharedNode.getInputType( builder );\n\n\t\tconst nodeUniform = builder.getUniformFromNode( sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label );\n\t\tconst propertyName = builder.getPropertyName( nodeUniform );\n\n\t\tif ( builder.context.label !== undefined ) delete builder.context.label;\n\n\t\treturn builder.format( propertyName, type, output );\n\n\t}\n\n}\n\nconst uniform = ( arg1, arg2 ) => {\n\n\tconst nodeType = getConstNodeType( arg2 || arg1 );\n\n\t// @TODO: get ConstNode from .traverse() in the future\n\tconst value = ( arg1 && arg1.isNode === true ) ? ( arg1.node && arg1.node.value ) || arg1.value : arg1;\n\n\treturn nodeObject( new UniformNode( value, nodeType ) );\n\n};\n\nclass PropertyNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'PropertyNode';\n\n\t}\n\n\tconstructor( nodeType, name = null, varying = false ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.name = name;\n\t\tthis.varying = varying;\n\n\t\tthis.isPropertyNode = true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tisGlobal( /*builder*/ ) {\n\n\t\treturn true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tlet nodeVar;\n\n\t\tif ( this.varying === true ) {\n\n\t\t\tnodeVar = builder.getVaryingFromNode( this, this.name );\n\t\t\tnodeVar.needsInterpolation = true;\n\n\t\t} else {\n\n\t\t\tnodeVar = builder.getVarFromNode( this, this.name );\n\n\t\t}\n\n\t\treturn builder.getPropertyName( nodeVar );\n\n\t}\n\n}\n\nconst property = ( type, name ) => nodeObject( new PropertyNode( type, name ) );\nconst varyingProperty = ( type, name ) => nodeObject( new PropertyNode( type, name, true ) );\n\nconst diffuseColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'DiffuseColor' );\nconst emissive = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'EmissiveColor' );\nconst roughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Roughness' );\nconst metalness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Metalness' );\nconst clearcoat = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Clearcoat' );\nconst clearcoatRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'ClearcoatRoughness' );\nconst sheen = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'Sheen' );\nconst sheenRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SheenRoughness' );\nconst iridescence = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Iridescence' );\nconst iridescenceIOR = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceIOR' );\nconst iridescenceThickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceThickness' );\nconst alphaT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AlphaT' );\nconst anisotropy = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Anisotropy' );\nconst anisotropyT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyT' );\nconst anisotropyB = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyB' );\nconst specularColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'SpecularColor' );\nconst specularF90 = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SpecularF90' );\nconst shininess = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Shininess' );\nconst output = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'Output' );\nconst dashSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'dashSize' );\nconst gapSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'gapSize' );\nconst pointWidth = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'pointWidth' );\nconst ior = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IOR' );\nconst transmission = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Transmission' );\nconst thickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Thickness' );\nconst attenuationDistance = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AttenuationDistance' );\nconst attenuationColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'AttenuationColor' );\nconst dispersion = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Dispersion' );\n\nclass AssignNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'AssignNode';\n\n\t}\n\n\tconstructor( targetNode, sourceNode ) {\n\n\t\tsuper();\n\n\t\tthis.targetNode = targetNode;\n\t\tthis.sourceNode = sourceNode;\n\n\t}\n\n\thasDependencies() {\n\n\t\treturn false;\n\n\t}\n\n\tgetNodeType( builder, output ) {\n\n\t\treturn output !== 'void' ? this.targetNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tneedsSplitAssign( builder ) {\n\n\t\tconst { targetNode } = this;\n\n\t\tif ( builder.isAvailable( 'swizzleAssign' ) === false && targetNode.isSplitNode && targetNode.components.length > 1 ) {\n\n\t\t\tconst targetLength = builder.getTypeLength( targetNode.node.getNodeType( builder ) );\n\t\t\tconst assignDiferentVector = vectorComponents.join( '' ).slice( 0, targetLength ) !== targetNode.components;\n\n\t\t\treturn assignDiferentVector;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { targetNode, sourceNode } = this;\n\n\t\tconst needsSplitAssign = this.needsSplitAssign( builder );\n\n\t\tconst targetType = targetNode.getNodeType( builder );\n\n\t\tconst target = targetNode.context( { assign: true } ).build( builder );\n\t\tconst source = sourceNode.build( builder, targetType );\n\n\t\tconst sourceType = sourceNode.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t//\n\n\t\tlet snippet;\n\n\t\tif ( nodeData.initialized === true ) {\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else if ( needsSplitAssign ) {\n\n\t\t\tconst sourceVar = builder.getVarFromNode( this, null, targetType );\n\t\t\tconst sourceProperty = builder.getPropertyName( sourceVar );\n\n\t\t\tbuilder.addLineFlowCode( `${ sourceProperty } = ${ source }`, this );\n\n\t\t\tconst targetRoot = targetNode.node.context( { assign: true } ).build( builder );\n\n\t\t\tfor ( let i = 0; i < targetNode.components.length; i ++ ) {\n\n\t\t\t\tconst component = targetNode.components[ i ];\n\n\t\t\t\tbuilder.addLineFlowCode( `${ targetRoot }.${ component } = ${ sourceProperty }[ ${ i } ]`, this );\n\n\t\t\t}\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsnippet = `${ target } = ${ source }`;\n\n\t\t\tif ( output === 'void' || sourceType === 'void' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\t\tsnippet = target;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tnodeData.initialized = true;\n\n\t\treturn builder.format( snippet, targetType, output );\n\n\t}\n\n}\n\nconst assign = /*@__PURE__*/ nodeProxy( AssignNode );\n\naddMethodChaining( 'assign', assign );\n\nclass FunctionCallNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionCallNode';\n\n\t}\n\n\tconstructor( functionNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\tthis.functionNode = functionNode;\n\t\tthis.parameters = parameters;\n\n\t}\n\n\tsetParameters( parameters ) {\n\n\t\tthis.parameters = parameters;\n\n\t\treturn this;\n\n\t}\n\n\tgetParameters() {\n\n\t\treturn this.parameters;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.functionNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst params = [];\n\n\t\tconst functionNode = this.functionNode;\n\n\t\tconst inputs = functionNode.getInputs( builder );\n\t\tconst parameters = this.parameters;\n\n\t\tconst generateInput = ( node, inputNode ) => {\n\n\t\t\tconst type = inputNode.type;\n\t\t\tconst pointer = type === 'pointer';\n\n\t\t\tlet output;\n\n\t\t\tif ( pointer ) output = '&' + node.build( builder );\n\t\t\telse output = node.build( builder, type );\n\n\t\t\treturn output;\n\n\t\t};\n\n\t\tif ( Array.isArray( parameters ) ) {\n\n\t\t\tfor ( let i = 0; i < parameters.length; i ++ ) {\n\n\t\t\t\tparams.push( generateInput( parameters[ i ], inputs[ i ] ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const inputNode of inputs ) {\n\n\t\t\t\tconst node = parameters[ inputNode.name ];\n\n\t\t\t\tif ( node !== undefined ) {\n\n\t\t\t\t\tparams.push( generateInput( node, inputNode ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.` );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst functionName = functionNode.build( builder, 'property' );\n\n\t\treturn `${functionName}( ${params.join( ', ' )} )`;\n\n\t}\n\n}\n\nconst call = ( func, ...params ) => {\n\n\tparams = params.length > 1 || ( params[ 0 ] && params[ 0 ].isNode === true ) ? nodeArray( params ) : nodeObjects( params[ 0 ] );\n\n\treturn nodeObject( new FunctionCallNode( nodeObject( func ), params ) );\n\n};\n\naddMethodChaining( 'call', call );\n\nclass OperatorNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'OperatorNode';\n\n\t}\n\n\tconstructor( op, aNode, bNode, ...params ) {\n\n\t\tsuper();\n\n\t\tif ( params.length > 0 ) {\n\n\t\t\tlet finalOp = new OperatorNode( op, aNode, bNode );\n\n\t\t\tfor ( let i = 0; i < params.length - 1; i ++ ) {\n\n\t\t\t\tfinalOp = new OperatorNode( op, finalOp, params[ i ] );\n\n\t\t\t}\n\n\t\t\taNode = finalOp;\n\t\t\tbNode = params[ params.length - 1 ];\n\n\t\t}\n\n\t\tthis.op = op;\n\t\tthis.aNode = aNode;\n\t\tthis.bNode = bNode;\n\n\t}\n\n\tgetNodeType( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst typeA = aNode.getNodeType( builder );\n\t\tconst typeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;\n\n\t\tif ( typeA === 'void' || typeB === 'void' ) {\n\n\t\t\treturn 'void';\n\n\t\t} else if ( op === '%' ) {\n\n\t\t\treturn typeA;\n\n\t\t} else if ( op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {\n\n\t\t\treturn builder.getIntegerType( typeA );\n\n\t\t} else if ( op === '!' || op === '==' || op === '&&' || op === '||' || op === '^^' ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\tconst typeLength = output ? builder.getTypeLength( output ) : Math.max( builder.getTypeLength( typeA ), builder.getTypeLength( typeB ) );\n\n\t\t\treturn typeLength > 1 ? `bvec${ typeLength }` : 'bool';\n\n\t\t} else {\n\n\t\t\tif ( typeA === 'float' && builder.isMatrix( typeB ) ) {\n\n\t\t\t\treturn typeB;\n\n\t\t\t} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t// matrix x vector\n\n\t\t\t\treturn builder.getVectorFromMatrix( typeA );\n\n\t\t\t} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t// vector x matrix\n\n\t\t\t\treturn builder.getVectorFromMatrix( typeB );\n\n\t\t\t} else if ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {\n\n\t\t\t\t// anytype x anytype: use the greater length vector\n\n\t\t\t\treturn typeB;\n\n\t\t\t}\n\n\t\t\treturn typeA;\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst type = this.getNodeType( builder, output );\n\n\t\tlet typeA = null;\n\t\tlet typeB = null;\n\n\t\tif ( type !== 'void' ) {\n\n\t\t\ttypeA = aNode.getNodeType( builder );\n\t\t\ttypeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;\n\n\t\t\tif ( op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==' ) {\n\n\t\t\t\tif ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\ttypeB = typeA;\n\n\t\t\t\t} else if ( typeA !== typeB ) {\n\n\t\t\t\t\ttypeA = typeB = 'float';\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>>' || op === '<<' ) {\n\n\t\t\t\ttypeA = type;\n\t\t\t\ttypeB = builder.changeComponentType( typeB, 'uint' );\n\n\t\t\t} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t// matrix x vector\n\n\t\t\t\ttypeB = builder.getVectorFromMatrix( typeA );\n\n\t\t\t} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t// vector x matrix\n\n\t\t\t\ttypeA = builder.getVectorFromMatrix( typeB );\n\n\t\t\t} else {\n\n\t\t\t\t// anytype x anytype\n\n\t\t\t\ttypeA = typeB = type;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttypeA = typeB = type;\n\n\t\t}\n\n\t\tconst a = aNode.build( builder, typeA );\n\t\tconst b = typeof bNode !== 'undefined' ? bNode.build( builder, typeB ) : null;\n\n\t\tconst outputLength = builder.getTypeLength( output );\n\t\tconst fnOpSnippet = builder.getFunctionOperator( op );\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\tif ( op === '<' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'lessThan', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } < ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '<=' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'lessThanEqual', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } <= ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'greaterThan', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } > ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>=' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'greaterThanEqual', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } >= ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '!' || op === '~' ) {\n\n\t\t\t\treturn builder.format( `(${op}${a})`, typeA, output );\n\n\t\t\t} else if ( fnOpSnippet ) {\n\n\t\t\t\treturn builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\treturn builder.format( `( ${ a } ${ op } ${ b } )`, type, output );\n\n\t\t\t}\n\n\t\t} else if ( typeA !== 'void' ) {\n\n\t\t\tif ( fnOpSnippet ) {\n\n\t\t\t\treturn builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\treturn builder.format( `${ a } ${ op } ${ b }`, type, output );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.op = this.op;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.op = data.op;\n\n\t}\n\n}\n\nconst add = /*@__PURE__*/ nodeProxy( OperatorNode, '+' );\nconst sub = /*@__PURE__*/ nodeProxy( OperatorNode, '-' );\nconst mul = /*@__PURE__*/ nodeProxy( OperatorNode, '*' );\nconst div = /*@__PURE__*/ nodeProxy( OperatorNode, '/' );\nconst modInt = /*@__PURE__*/ nodeProxy( OperatorNode, '%' );\nconst equal = /*@__PURE__*/ nodeProxy( OperatorNode, '==' );\nconst notEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '!=' );\nconst lessThan = /*@__PURE__*/ nodeProxy( OperatorNode, '<' );\nconst greaterThan = /*@__PURE__*/ nodeProxy( OperatorNode, '>' );\nconst lessThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '<=' );\nconst greaterThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '>=' );\nconst and = /*@__PURE__*/ nodeProxy( OperatorNode, '&&' );\nconst or = /*@__PURE__*/ nodeProxy( OperatorNode, '||' );\nconst not = /*@__PURE__*/ nodeProxy( OperatorNode, '!' );\nconst xor = /*@__PURE__*/ nodeProxy( OperatorNode, '^^' );\nconst bitAnd = /*@__PURE__*/ nodeProxy( OperatorNode, '&' );\nconst bitNot = /*@__PURE__*/ nodeProxy( OperatorNode, '~' );\nconst bitOr = /*@__PURE__*/ nodeProxy( OperatorNode, '|' );\nconst bitXor = /*@__PURE__*/ nodeProxy( OperatorNode, '^' );\nconst shiftLeft = /*@__PURE__*/ nodeProxy( OperatorNode, '<<' );\nconst shiftRight = /*@__PURE__*/ nodeProxy( OperatorNode, '>>' );\n\naddMethodChaining( 'add', add );\naddMethodChaining( 'sub', sub );\naddMethodChaining( 'mul', mul );\naddMethodChaining( 'div', div );\naddMethodChaining( 'modInt', modInt );\naddMethodChaining( 'equal', equal );\naddMethodChaining( 'notEqual', notEqual );\naddMethodChaining( 'lessThan', lessThan );\naddMethodChaining( 'greaterThan', greaterThan );\naddMethodChaining( 'lessThanEqual', lessThanEqual );\naddMethodChaining( 'greaterThanEqual', greaterThanEqual );\naddMethodChaining( 'and', and );\naddMethodChaining( 'or', or );\naddMethodChaining( 'not', not );\naddMethodChaining( 'xor', xor );\naddMethodChaining( 'bitAnd', bitAnd );\naddMethodChaining( 'bitNot', bitNot );\naddMethodChaining( 'bitOr', bitOr );\naddMethodChaining( 'bitXor', bitXor );\naddMethodChaining( 'shiftLeft', shiftLeft );\naddMethodChaining( 'shiftRight', shiftRight );\n\n\nconst remainder = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.OperatorNode: .remainder() has been renamed to .modInt().' );\n\treturn modInt( ...params );\n\n};\n\naddMethodChaining( 'remainder', remainder );\n\nclass MathNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'MathNode';\n\n\t}\n\n\tconstructor( method, aNode, bNode = null, cNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.method = method;\n\n\t\tthis.aNode = aNode;\n\t\tthis.bNode = bNode;\n\t\tthis.cNode = cNode;\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\tconst aType = this.aNode.getNodeType( builder );\n\t\tconst bType = this.bNode ? this.bNode.getNodeType( builder ) : null;\n\t\tconst cType = this.cNode ? this.cNode.getNodeType( builder ) : null;\n\n\t\tconst aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );\n\t\tconst bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );\n\t\tconst cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );\n\n\t\tif ( aLen > bLen && aLen > cLen ) {\n\n\t\t\treturn aType;\n\n\t\t} else if ( bLen > cLen ) {\n\n\t\t\treturn bType;\n\n\t\t} else if ( cLen > aLen ) {\n\n\t\t\treturn cType;\n\n\t\t}\n\n\t\treturn aType;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tif ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {\n\n\t\t\treturn 'float';\n\n\t\t} else if ( method === MathNode.CROSS ) {\n\n\t\t\treturn 'vec3';\n\n\t\t} else if ( method === MathNode.ALL ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( method === MathNode.EQUALS ) {\n\n\t\t\treturn builder.changeComponentType( this.aNode.getNodeType( builder ), 'bool' );\n\n\t\t} else if ( method === MathNode.MOD ) {\n\n\t\t\treturn this.aNode.getNodeType( builder );\n\n\t\t} else {\n\n\t\t\treturn this.getInputType( builder );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.aNode;\n\t\tconst b = this.bNode;\n\t\tconst c = this.cNode;\n\n\t\tconst isWebGL = builder.renderer.isWebGLRenderer === true;\n\n\t\tif ( method === MathNode.TRANSFORM_DIRECTION ) {\n\n\t\t\t// dir can be either a direction vector or a normal vector\n\t\t\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\t\t\tlet tA = a;\n\t\t\tlet tB = b;\n\n\t\t\tif ( builder.isMatrix( tA.getNodeType( builder ) ) ) {\n\n\t\t\t\ttB = vec4( vec3( tB ), 0.0 );\n\n\t\t\t} else {\n\n\t\t\t\ttA = vec4( vec3( tA ), 0.0 );\n\n\t\t\t}\n\n\t\t\tconst mulNode = mul( tA, tB ).xyz;\n\n\t\t\treturn normalize( mulNode ).build( builder, output );\n\n\t\t} else if ( method === MathNode.NEGATE ) {\n\n\t\t\treturn builder.format( '( - ' + a.build( builder, inputType ) + ' )', type, output );\n\n\t\t} else if ( method === MathNode.ONE_MINUS ) {\n\n\t\t\treturn sub( 1.0, a ).build( builder, output );\n\n\t\t} else if ( method === MathNode.RECIPROCAL ) {\n\n\t\t\treturn div( 1.0, a ).build( builder, output );\n\n\t\t} else if ( method === MathNode.DIFFERENCE ) {\n\n\t\t\treturn abs( sub( a, b ) ).build( builder, output );\n\n\t\t} else {\n\n\t\t\tconst params = [];\n\n\t\t\tif ( method === MathNode.CROSS || method === MathNode.MOD ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, type ),\n\t\t\t\t\tb.build( builder, type )\n\t\t\t\t);\n\n\t\t\t} else if ( isWebGL && method === MathNode.STEP ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),\n\t\t\t\t\tb.build( builder, inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( ( isWebGL && ( method === MathNode.MIN || method === MathNode.MAX ) ) || method === MathNode.MOD ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.REFRACT ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, 'float' )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.MIX ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tparams.push( a.build( builder, inputType ) );\n\t\t\t\tif ( b !== null ) params.push( b.build( builder, inputType ) );\n\t\t\t\tif ( c !== null ) params.push( c.build( builder, inputType ) );\n\n\t\t\t}\n\n\t\t\treturn builder.format( `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`, type, output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.method = this.method;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.method = data.method;\n\n\t}\n\n}\n\n// 1 input\n\nMathNode.ALL = 'all';\nMathNode.ANY = 'any';\nMathNode.EQUALS = 'equals';\n\nMathNode.RADIANS = 'radians';\nMathNode.DEGREES = 'degrees';\nMathNode.EXP = 'exp';\nMathNode.EXP2 = 'exp2';\nMathNode.LOG = 'log';\nMathNode.LOG2 = 'log2';\nMathNode.SQRT = 'sqrt';\nMathNode.INVERSE_SQRT = 'inversesqrt';\nMathNode.FLOOR = 'floor';\nMathNode.CEIL = 'ceil';\nMathNode.NORMALIZE = 'normalize';\nMathNode.FRACT = 'fract';\nMathNode.SIN = 'sin';\nMathNode.COS = 'cos';\nMathNode.TAN = 'tan';\nMathNode.ASIN = 'asin';\nMathNode.ACOS = 'acos';\nMathNode.ATAN = 'atan';\nMathNode.ABS = 'abs';\nMathNode.SIGN = 'sign';\nMathNode.LENGTH = 'length';\nMathNode.NEGATE = 'negate';\nMathNode.ONE_MINUS = 'oneMinus';\nMathNode.DFDX = 'dFdx';\nMathNode.DFDY = 'dFdy';\nMathNode.ROUND = 'round';\nMathNode.RECIPROCAL = 'reciprocal';\nMathNode.TRUNC = 'trunc';\nMathNode.FWIDTH = 'fwidth';\nMathNode.BITCAST = 'bitcast';\nMathNode.TRANSPOSE = 'transpose';\n\n// 2 inputs\n\nMathNode.ATAN2 = 'atan2';\nMathNode.MIN = 'min';\nMathNode.MAX = 'max';\nMathNode.MOD = 'mod';\nMathNode.STEP = 'step';\nMathNode.REFLECT = 'reflect';\nMathNode.DISTANCE = 'distance';\nMathNode.DIFFERENCE = 'difference';\nMathNode.DOT = 'dot';\nMathNode.CROSS = 'cross';\nMathNode.POW = 'pow';\nMathNode.TRANSFORM_DIRECTION = 'transformDirection';\n\n// 3 inputs\n\nMathNode.MIX = 'mix';\nMathNode.CLAMP = 'clamp';\nMathNode.REFRACT = 'refract';\nMathNode.SMOOTHSTEP = 'smoothstep';\nMathNode.FACEFORWARD = 'faceforward';\n\nconst EPSILON = /*@__PURE__*/ float( 1e-6 );\nconst INFINITY = /*@__PURE__*/ float( 1e6 );\nconst PI = /*@__PURE__*/ float( Math.PI );\nconst PI2 = /*@__PURE__*/ float( Math.PI * 2 );\n\nconst all = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ALL );\nconst any = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ANY );\nconst equals = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EQUALS );\n\nconst radians = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RADIANS );\nconst degrees = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DEGREES );\nconst exp = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP );\nconst exp2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP2 );\nconst log = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG );\nconst log2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG2 );\nconst sqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SQRT );\nconst inverseSqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.INVERSE_SQRT );\nconst floor = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FLOOR );\nconst ceil = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CEIL );\nconst normalize = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NORMALIZE );\nconst fract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FRACT );\nconst sin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIN );\nconst cos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.COS );\nconst tan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TAN );\nconst asin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ASIN );\nconst acos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ACOS );\nconst atan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN );\nconst abs = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ABS );\nconst sign = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIGN );\nconst length = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LENGTH );\nconst negate = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NEGATE );\nconst oneMinus = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ONE_MINUS );\nconst dFdx = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDX );\nconst dFdy = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDY );\nconst round = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ROUND );\nconst reciprocal = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RECIPROCAL );\nconst trunc = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRUNC );\nconst fwidth = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FWIDTH );\nconst bitcast = /*@__PURE__*/ nodeProxy( MathNode, MathNode.BITCAST );\nconst transpose = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSPOSE );\n\nconst atan2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN2 );\nconst min$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIN );\nconst max$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MAX );\nconst mod = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MOD );\nconst step = /*@__PURE__*/ nodeProxy( MathNode, MathNode.STEP );\nconst reflect = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFLECT );\nconst distance = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DISTANCE );\nconst difference = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DIFFERENCE );\nconst dot = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DOT );\nconst cross = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CROSS );\nconst pow = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW );\nconst pow2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 2 );\nconst pow3 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 3 );\nconst pow4 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 4 );\nconst transformDirection = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSFORM_DIRECTION );\n\nconst cbrt = ( a ) => mul( sign( a ), pow( abs( a ), 1.0 / 3.0 ) );\nconst lengthSq = ( a ) => dot( a, a );\nconst mix = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIX );\nconst clamp = ( value, low = 0, high = 1 ) => nodeObject( new MathNode( MathNode.CLAMP, nodeObject( value ), nodeObject( low ), nodeObject( high ) ) );\nconst saturate = ( value ) => clamp( value );\nconst refract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFRACT );\nconst smoothstep = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SMOOTHSTEP );\nconst faceForward = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FACEFORWARD );\n\nconst rand = /*@__PURE__*/ Fn( ( [ uv ] ) => {\n\n\tconst a = 12.9898, b = 78.233, c = 43758.5453;\n\tconst dt = dot( uv.xy, vec2( a, b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ).mul( c ) );\n\n} );\n\nconst mixElement = ( t, e1, e2 ) => mix( e1, e2, t );\nconst smoothstepElement = ( x, low, high ) => smoothstep( low, high, x );\n\naddMethodChaining( 'all', all );\naddMethodChaining( 'any', any );\naddMethodChaining( 'equals', equals );\n\naddMethodChaining( 'radians', radians );\naddMethodChaining( 'degrees', degrees );\naddMethodChaining( 'exp', exp );\naddMethodChaining( 'exp2', exp2 );\naddMethodChaining( 'log', log );\naddMethodChaining( 'log2', log2 );\naddMethodChaining( 'sqrt', sqrt );\naddMethodChaining( 'inverseSqrt', inverseSqrt );\naddMethodChaining( 'floor', floor );\naddMethodChaining( 'ceil', ceil );\naddMethodChaining( 'normalize', normalize );\naddMethodChaining( 'fract', fract );\naddMethodChaining( 'sin', sin );\naddMethodChaining( 'cos', cos );\naddMethodChaining( 'tan', tan );\naddMethodChaining( 'asin', asin );\naddMethodChaining( 'acos', acos );\naddMethodChaining( 'atan', atan );\naddMethodChaining( 'abs', abs );\naddMethodChaining( 'sign', sign );\naddMethodChaining( 'length', length );\naddMethodChaining( 'lengthSq', lengthSq );\naddMethodChaining( 'negate', negate );\naddMethodChaining( 'oneMinus', oneMinus );\naddMethodChaining( 'dFdx', dFdx );\naddMethodChaining( 'dFdy', dFdy );\naddMethodChaining( 'round', round );\naddMethodChaining( 'reciprocal', reciprocal );\naddMethodChaining( 'trunc', trunc );\naddMethodChaining( 'fwidth', fwidth );\naddMethodChaining( 'atan2', atan2 );\naddMethodChaining( 'min', min$1 );\naddMethodChaining( 'max', max$1 );\naddMethodChaining( 'mod', mod );\naddMethodChaining( 'step', step );\naddMethodChaining( 'reflect', reflect );\naddMethodChaining( 'distance', distance );\naddMethodChaining( 'dot', dot );\naddMethodChaining( 'cross', cross );\naddMethodChaining( 'pow', pow );\naddMethodChaining( 'pow2', pow2 );\naddMethodChaining( 'pow3', pow3 );\naddMethodChaining( 'pow4', pow4 );\naddMethodChaining( 'transformDirection', transformDirection );\naddMethodChaining( 'mix', mixElement );\naddMethodChaining( 'clamp', clamp );\naddMethodChaining( 'refract', refract );\naddMethodChaining( 'smoothstep', smoothstepElement );\naddMethodChaining( 'faceForward', faceForward );\naddMethodChaining( 'difference', difference );\naddMethodChaining( 'saturate', saturate );\naddMethodChaining( 'cbrt', cbrt );\naddMethodChaining( 'transpose', transpose );\naddMethodChaining( 'rand', rand );\n\nclass ConditionalNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ConditionalNode';\n\n\t}\n\n\tconstructor( condNode, ifNode, elseNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.condNode = condNode;\n\n\t\tthis.ifNode = ifNode;\n\t\tthis.elseNode = elseNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst ifType = this.ifNode.getNodeType( builder );\n\n\t\tif ( this.elseNode !== null ) {\n\n\t\t\tconst elseType = this.elseNode.getNodeType( builder );\n\n\t\t\tif ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {\n\n\t\t\t\treturn elseType;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ifType;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst condNode = this.condNode.cache();\n\t\tconst ifNode = this.ifNode.cache();\n\t\tconst elseNode = this.elseNode ? this.elseNode.cache() : null;\n\n\t\t//\n\n\t\tconst currentNodeBlock = builder.context.nodeBlock;\n\n\t\tbuilder.getDataFromNode( ifNode ).parentNodeBlock = currentNodeBlock;\n\t\tif ( elseNode !== null ) builder.getDataFromNode( elseNode ).parentNodeBlock = currentNodeBlock;\n\n\t\t//\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.condNode = condNode;\n\t\tproperties.ifNode = ifNode.context( { nodeBlock: ifNode } );\n\t\tproperties.elseNode = elseNode ? elseNode.context( { nodeBlock: elseNode } ) : null;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tif ( nodeData.nodeProperty !== undefined ) {\n\n\t\t\treturn nodeData.nodeProperty;\n\n\t\t}\n\n\t\tconst { condNode, ifNode, elseNode } = builder.getNodeProperties( this );\n\n\t\tconst needsOutput = output !== 'void';\n\t\tconst nodeProperty = needsOutput ? property( type ).build( builder ) : '';\n\n\t\tnodeData.nodeProperty = nodeProperty;\n\n\t\tconst nodeSnippet = condNode.build( builder, 'bool' );\n\n\t\tbuilder.addFlowCode( `\\n${ builder.tab }if ( ${ nodeSnippet } ) {\\n\\n` ).addFlowTab();\n\n\t\tlet ifSnippet = ifNode.build( builder, type );\n\n\t\tif ( ifSnippet ) {\n\n\t\t\tif ( needsOutput ) {\n\n\t\t\t\tifSnippet = nodeProperty + ' = ' + ifSnippet + ';';\n\n\t\t\t} else {\n\n\t\t\t\tifSnippet = 'return ' + ifSnippet + ';';\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeFlowTab().addFlowCode( builder.tab + '\\t' + ifSnippet + '\\n\\n' + builder.tab + '}' );\n\n\t\tif ( elseNode !== null ) {\n\n\t\t\tbuilder.addFlowCode( ' else {\\n\\n' ).addFlowTab();\n\n\t\t\tlet elseSnippet = elseNode.build( builder, type );\n\n\t\t\tif ( elseSnippet ) {\n\n\t\t\t\tif ( needsOutput ) {\n\n\t\t\t\t\telseSnippet = nodeProperty + ' = ' + elseSnippet + ';';\n\n\t\t\t\t} else {\n\n\t\t\t\t\telseSnippet = 'return ' + elseSnippet + ';';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbuilder.removeFlowTab().addFlowCode( builder.tab + '\\t' + elseSnippet + '\\n\\n' + builder.tab + '}\\n\\n' );\n\n\t\t} else {\n\n\t\t\tbuilder.addFlowCode( '\\n\\n' );\n\n\t\t}\n\n\t\treturn builder.format( nodeProperty, type, output );\n\n\t}\n\n}\n\nconst select = /*@__PURE__*/ nodeProxy( ConditionalNode );\n\naddMethodChaining( 'select', select );\n\n//\n\nconst cond = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ConditionalNode: cond() has been renamed to select().' );\n\treturn select( ...params );\n\n};\n\naddMethodChaining( 'cond', cond );\n\nclass ContextNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ContextNode';\n\n\t}\n\n\tconstructor( node, value = {} ) {\n\n\t\tsuper();\n\n\t\tthis.isContextNode = true;\n\n\t\tthis.node = node;\n\t\tthis.value = value;\n\n\t}\n\n\tgetScope() {\n\n\t\treturn this.node.getScope();\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tthis.node.build( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( { ...builder.context, ...this.value } );\n\n\t\tconst node = this.node.build( builder );\n\n\t\tbuilder.setContext( previousContext );\n\n\t\treturn node;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( { ...builder.context, ...this.value } );\n\n\t\tconst snippet = this.node.build( builder, output );\n\n\t\tbuilder.setContext( previousContext );\n\n\t\treturn snippet;\n\n\t}\n\n}\n\nconst context = /*@__PURE__*/ nodeProxy( ContextNode );\nconst label = ( node, name ) => context( node, { label: name } );\n\naddMethodChaining( 'context', context );\naddMethodChaining( 'label', label );\n\nclass VarNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'VarNode';\n\n\t}\n\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.name = name;\n\n\t\tthis.global = true;\n\n\t\tthis.isVarNode = true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { node, name } = this;\n\n\t\tconst nodeVar = builder.getVarFromNode( this, name, builder.getVectorType( this.getNodeType( builder ) ) );\n\n\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\tconst snippet = node.build( builder, nodeVar.type );\n\n\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}`, this );\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\nconst createVar = /*@__PURE__*/ nodeProxy( VarNode );\n\naddMethodChaining( 'toVar', ( ...params ) => createVar( ...params ).append() );\n\n// Deprecated\n\nconst temp = ( node ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: \"temp\" is deprecated. Use \".toVar()\" instead.' );\n\n\treturn createVar( node );\n\n};\n\naddMethodChaining( 'temp', temp );\n\nclass VaryingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'VaryingNode';\n\n\t}\n\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.name = name;\n\n\t\tthis.isVaryingNode = true;\n\n\t}\n\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\t// VaryingNode is auto type\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tsetupVarying( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tlet varying = properties.varying;\n\n\t\tif ( varying === undefined ) {\n\n\t\t\tconst name = this.name;\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tproperties.varying = varying = builder.getVaryingFromNode( this, name, type );\n\t\t\tproperties.node = this.node;\n\n\t\t}\n\n\t\t// this property can be used to check if the varying can be optimized for a variable\n\t\tvarying.needsInterpolation || ( varying.needsInterpolation = ( builder.shaderStage === 'fragment' ) );\n\n\t\treturn varying;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.setupVarying( builder );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tthis.setupVarying( builder );\n\n\t\treturn this.node.analyze( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst varying = this.setupVarying( builder );\n\n\t\tif ( properties.propertyName === undefined ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\t\t\tconst propertyName = builder.getPropertyName( varying, NodeShaderStage.VERTEX );\n\n\t\t\t// force node run in vertex stage\n\t\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node, type, propertyName );\n\n\t\t\tproperties.propertyName = propertyName;\n\n\t\t}\n\n\t\treturn builder.getPropertyName( varying );\n\n\t}\n\n}\n\nconst varying = /*@__PURE__*/ nodeProxy( VaryingNode );\n\naddMethodChaining( 'varying', varying );\n\nconst sRGBTransferEOTF = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.mul( 0.9478672986 ).add( 0.0521327014 ).pow( 2.4 );\n\tconst b = color.mul( 0.0773993808 );\n\tconst factor = color.lessThanEqual( 0.04045 );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn rgbResult;\n\n} ).setLayout( {\n\tname: 'sRGBTransferEOTF',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\nconst sRGBTransferOETF = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.pow( 0.41666 ).mul( 1.055 ).sub( 0.055 );\n\tconst b = color.mul( 12.92 );\n\tconst factor = color.lessThanEqual( 0.0031308 );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn rgbResult;\n\n} ).setLayout( {\n\tname: 'sRGBTransferOETF',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\nconst WORKING_COLOR_SPACE = 'WorkingColorSpace';\nconst OUTPUT_COLOR_SPACE = 'OutputColorSpace';\n\nclass ColorSpaceNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ColorSpaceNode';\n\n\t}\n\n\tconstructor( colorNode, source, target ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.colorNode = colorNode;\n\t\tthis.source = source;\n\t\tthis.target = target;\n\n\t}\n\n\tresolveColorSpace( builder, colorSpace ) {\n\n\t\tif ( colorSpace === WORKING_COLOR_SPACE ) {\n\n\t\t\treturn ColorManagement.workingColorSpace;\n\n\t\t} else if ( colorSpace === OUTPUT_COLOR_SPACE ) {\n\n\t\t\treturn builder.context.outputColorSpace || builder.renderer.outputColorSpace;\n\n\t\t}\n\n\t\treturn colorSpace;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { colorNode } = this;\n\n\t\tconst source = this.resolveColorSpace( builder, this.source );\n\t\tconst target = this.resolveColorSpace( builder, this.target );\n\n\t\tlet outputNode = colorNode;\n\n\t\tif ( ColorManagement.enabled === false || source === target || ! source || ! target ) {\n\n\t\t\treturn outputNode;\n\n\t\t}\n\n\t\tif ( ColorManagement.getTransfer( source ) === SRGBTransfer ) {\n\n\t\t\toutputNode = vec4( sRGBTransferEOTF( outputNode.rgb ), outputNode.a );\n\n\t\t}\n\n\t\tif ( ColorManagement.getPrimaries( source ) !== ColorManagement.getPrimaries( target ) ) {\n\n\t\t\toutputNode = vec4(\n\t\t\t\tmat3( ColorManagement._getMatrix( new Matrix3(), source, target ) ).mul( outputNode.rgb ),\n\t\t\t\toutputNode.a\n\t\t\t);\n\n\t\t}\n\n\t\tif ( ColorManagement.getTransfer( target ) === SRGBTransfer ) {\n\n\t\t\toutputNode = vec4( sRGBTransferOETF( outputNode.rgb ), outputNode.a );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nconst toOutputColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, OUTPUT_COLOR_SPACE ) );\nconst toWorkingColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), OUTPUT_COLOR_SPACE, WORKING_COLOR_SPACE ) );\n\nconst workingToColorSpace = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, colorSpace ) );\nconst colorSpaceToWorking = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), colorSpace, WORKING_COLOR_SPACE ) );\n\nconst convertColorSpace = ( node, sourceColorSpace, targetColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), sourceColorSpace, targetColorSpace ) );\n\naddMethodChaining( 'toOutputColorSpace', toOutputColorSpace );\naddMethodChaining( 'toWorkingColorSpace', toWorkingColorSpace );\n\naddMethodChaining( 'workingToColorSpace', workingToColorSpace );\naddMethodChaining( 'colorSpaceToWorking', colorSpaceToWorking );\n\nlet ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceElementNode';\n\n\t}\n\n\tconstructor( referenceNode, indexNode ) {\n\n\t\tsuper( referenceNode, indexNode );\n\n\t\tthis.referenceNode = referenceNode;\n\n\t\tthis.isReferenceElementNode = true;\n\n\t}\n\n\tgetNodeType() {\n\n\t\treturn this.referenceNode.uniformType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst arrayType = this.referenceNode.getNodeType();\n\t\tconst elementType = this.getNodeType();\n\n\t\treturn builder.format( snippet, arrayType, elementType );\n\n\t}\n\n};\n\nclass ReferenceBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceBaseNode';\n\n\t}\n\n\tconstructor( property, uniformType, object = null, count = null ) {\n\n\t\tsuper();\n\n\t\tthis.property = property;\n\t\tthis.uniformType = uniformType;\n\t\tthis.object = object;\n\t\tthis.count = count;\n\n\t\tthis.properties = property.split( '.' );\n\t\tthis.reference = object;\n\t\tthis.node = null;\n\t\tthis.group = null;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\tsetGroup( group ) {\n\n\t\tthis.group = group;\n\n\t\treturn this;\n\n\t}\n\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new ReferenceElementNode$1( this, nodeObject( indexNode ) ) );\n\n\t}\n\n\tsetNodeType( uniformType ) {\n\n\t\tconst node = uniform( null, uniformType ).getSelf();\n\n\t\tif ( this.group !== null ) {\n\n\t\t\tnode.setGroup( this.group );\n\n\t\t}\n\n\t\tthis.node = node;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( this.node === null ) {\n\n\t\t\tthis.updateReference( builder );\n\t\t\tthis.updateValue();\n\n\t\t}\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgetValueFromReference( object = this.reference ) {\n\n\t\tconst { properties } = this;\n\n\t\tlet value = object[ properties[ 0 ] ];\n\n\t\tfor ( let i = 1; i < properties.length; i ++ ) {\n\n\t\t\tvalue = value[ properties[ i ] ];\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.object !== null ? this.object : state.object;\n\n\t\treturn this.reference;\n\n\t}\n\n\tsetup() {\n\n\t\tthis.updateValue();\n\n\t\treturn this.node;\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tthis.updateValue();\n\n\t}\n\n\tupdateValue() {\n\n\t\tif ( this.node === null ) this.setNodeType( this.uniformType );\n\n\t\tconst value = this.getValueFromReference();\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tthis.node.array = value;\n\n\t\t} else {\n\n\t\t\tthis.node.value = value;\n\n\t\t}\n\n\t}\n\n}\n\nconst reference$1 = ( name, type, object ) => nodeObject( new ReferenceBaseNode( name, type, object ) );\n\nclass RendererReferenceNode extends ReferenceBaseNode {\n\n\tstatic get type() {\n\n\t\treturn 'RendererReferenceNode';\n\n\t}\n\n\tconstructor( property, inputType, renderer = null ) {\n\n\t\tsuper( property, inputType, renderer );\n\n\t\tthis.renderer = renderer;\n\n\t\tthis.setGroup( renderGroup );\n\n\t}\n\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.renderer !== null ? this.renderer : state.renderer;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\nconst rendererReference = ( name, type, renderer ) => nodeObject( new RendererReferenceNode( name, type, renderer ) );\n\nclass ToneMappingNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ToneMappingNode';\n\n\t}\n\n\tconstructor( toneMapping, exposureNode = toneMappingExposure, colorNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.toneMapping = toneMapping;\n\n\t\tthis.exposureNode = exposureNode;\n\t\tthis.colorNode = colorNode;\n\n\t}\n\n\tgetCacheKey() {\n\n\t\treturn hash$1( super.getCacheKey(), this.toneMapping );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst colorNode = this.colorNode || builder.context.color;\n\t\tconst toneMapping = this.toneMapping;\n\n\t\tif ( toneMapping === NoToneMapping ) return colorNode;\n\n\t\tlet outputNode = null;\n\n\t\tconst toneMappingFn = builder.renderer.library.getToneMappingFunction( toneMapping );\n\n\t\tif ( toneMappingFn !== null ) {\n\n\t\t\toutputNode = vec4( toneMappingFn( colorNode.rgb, this.exposureNode ), colorNode.a );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping );\n\n\t\t\toutputNode = colorNode;\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nconst toneMapping = ( mapping, exposure, color ) => nodeObject( new ToneMappingNode( mapping, nodeObject( exposure ), nodeObject( color ) ) );\nconst toneMappingExposure = /*@__PURE__*/ rendererReference( 'toneMappingExposure', 'float' );\n\naddMethodChaining( 'toneMapping', ( color, mapping, exposure ) => toneMapping( mapping, exposure, color ) );\n\nclass BufferAttributeNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'BufferAttributeNode';\n\n\t}\n\n\tconstructor( value, bufferType = null, bufferStride = 0, bufferOffset = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\tthis.isBufferNode = true;\n\n\t\tthis.bufferType = bufferType;\n\t\tthis.bufferStride = bufferStride;\n\t\tthis.bufferOffset = bufferOffset;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.instanced = false;\n\n\t\tthis.attribute = null;\n\n\t\tthis.global = true;\n\n\t\tif ( value && value.isBufferAttribute === true ) {\n\n\t\t\tthis.attribute = value;\n\t\t\tthis.usage = value.usage;\n\t\t\tthis.instanced = value.isInstancedBufferAttribute;\n\n\t\t}\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\tif ( this.bufferStride === 0 && this.bufferOffset === 0 ) {\n\n\t\t\tlet bufferData = builder.globalCache.getData( this.value );\n\n\t\t\tif ( bufferData === undefined ) {\n\n\t\t\t\tbufferData = {\n\t\t\t\t\tnode: this\n\t\t\t\t};\n\n\t\t\t\tbuilder.globalCache.setData( this.value, bufferData );\n\n\t\t\t}\n\n\t\t\treturn bufferData.node.uuid;\n\n\t\t}\n\n\t\treturn this.uuid;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( this.bufferType === null ) {\n\n\t\t\tthis.bufferType = builder.getTypeFromAttribute( this.attribute );\n\n\t\t}\n\n\t\treturn this.bufferType;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( this.attribute !== null ) return;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst array = this.value;\n\t\tconst itemSize = builder.getTypeLength( type );\n\t\tconst stride = this.bufferStride || itemSize;\n\t\tconst offset = this.bufferOffset;\n\n\t\tconst buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer( array, stride );\n\t\tconst bufferAttribute = new InterleavedBufferAttribute( buffer, itemSize, offset );\n\n\t\tbuffer.setUsage( this.usage );\n\n\t\tthis.attribute = bufferAttribute;\n\t\tthis.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tconst nodeAttribute = builder.getBufferAttributeFromNode( this, nodeType );\n\t\tconst propertyName = builder.getPropertyName( nodeAttribute );\n\n\t\tlet output = null;\n\n\t\tif ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {\n\n\t\t\tthis.name = propertyName;\n\n\t\t\toutput = propertyName;\n\n\t\t} else {\n\n\t\t\tconst nodeVarying = varying( this );\n\n\t\t\toutput = nodeVarying.build( builder, nodeType );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'bufferAttribute';\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\tif ( this.attribute && this.attribute.isBufferAttribute === true ) {\n\n\t\t\tthis.attribute.usage = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetInstanced( value ) {\n\n\t\tthis.instanced = value;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst bufferAttribute = ( array, type, stride, offset ) => nodeObject( new BufferAttributeNode( array, type, stride, offset ) );\nconst dynamicBufferAttribute = ( array, type, stride, offset ) => bufferAttribute( array, type, stride, offset ).setUsage( DynamicDrawUsage );\n\nconst instancedBufferAttribute = ( array, type, stride, offset ) => bufferAttribute( array, type, stride, offset ).setInstanced( true );\nconst instancedDynamicBufferAttribute = ( array, type, stride, offset ) => dynamicBufferAttribute( array, type, stride, offset ).setInstanced( true );\n\naddMethodChaining( 'toAttribute', ( bufferNode ) => bufferAttribute( bufferNode.value ) );\n\nclass ComputeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ComputeNode';\n\n\t}\n\n\tconstructor( computeNode, count, workgroupSize = [ 64 ] ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.isComputeNode = true;\n\n\t\tthis.computeNode = computeNode;\n\n\t\tthis.count = count;\n\t\tthis.workgroupSize = workgroupSize;\n\t\tthis.dispatchCount = 0;\n\n\t\tthis.version = 1;\n\t\tthis.updateBeforeType = NodeUpdateType.OBJECT;\n\n\t\tthis.onInitFunction = null;\n\n\t\tthis.updateDispatchCount();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tupdateDispatchCount() {\n\n\t\tconst { count, workgroupSize } = this;\n\n\t\tlet size = workgroupSize[ 0 ];\n\n\t\tfor ( let i = 1; i < workgroupSize.length; i ++ )\n\t\t\tsize *= workgroupSize[ i ];\n\n\t\tthis.dispatchCount = Math.ceil( count / size );\n\n\t}\n\n\tonInit( callback ) {\n\n\t\tthis.onInitFunction = callback;\n\n\t\treturn this;\n\n\t}\n\n\tupdateBefore( { renderer } ) {\n\n\t\trenderer.compute( this );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { shaderStage } = builder;\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tconst snippet = this.computeNode.build( builder, 'void' );\n\n\t\t\tif ( snippet !== '' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst compute = ( node, count, workgroupSize ) => nodeObject( new ComputeNode( nodeObject( node ), count, workgroupSize ) );\n\naddMethodChaining( 'compute', compute );\n\nclass CacheNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'CacheNode';\n\n\t}\n\n\tconstructor( node, parent = true ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.parent = parent;\n\n\t\tthis.isCacheNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tconst previousCache = builder.getCache();\n\t\tconst cache = builder.getCacheFromNode( this, this.parent );\n\n\t\tbuilder.setCache( cache );\n\n\t\tconst data = this.node.build( builder, ...params );\n\n\t\tbuilder.setCache( previousCache );\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst cache = ( node, ...params ) => nodeObject( new CacheNode( nodeObject( node ), ...params ) );\n\naddMethodChaining( 'cache', cache );\n\nclass BypassNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'BypassNode';\n\n\t}\n\n\tconstructor( returnNode, callNode ) {\n\n\t\tsuper();\n\n\t\tthis.isBypassNode = true;\n\n\t\tthis.outputNode = returnNode;\n\t\tthis.callNode = callNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = this.callNode.build( builder, 'void' );\n\n\t\tif ( snippet !== '' ) {\n\n\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t}\n\n\t\treturn this.outputNode.build( builder );\n\n\t}\n\n}\n\nconst bypass = /*@__PURE__*/ nodeProxy( BypassNode );\n\naddMethodChaining( 'bypass', bypass );\n\nclass RemapNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'RemapNode';\n\n\t}\n\n\tconstructor( node, inLowNode, inHighNode, outLowNode = float( 0 ), outHighNode = float( 1 ) ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.inLowNode = inLowNode;\n\t\tthis.inHighNode = inHighNode;\n\t\tthis.outLowNode = outLowNode;\n\t\tthis.outHighNode = outHighNode;\n\n\t\tthis.doClamp = true;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;\n\n\t\tlet t = node.sub( inLowNode ).div( inHighNode.sub( inLowNode ) );\n\n\t\tif ( doClamp === true ) t = t.clamp();\n\n\t\treturn t.mul( outHighNode.sub( outLowNode ) ).add( outLowNode );\n\n\t}\n\n}\n\nconst remap = /*@__PURE__*/ nodeProxy( RemapNode, null, null, { doClamp: false } );\nconst remapClamp = /*@__PURE__*/ nodeProxy( RemapNode );\n\naddMethodChaining( 'remap', remap );\naddMethodChaining( 'remapClamp', remapClamp );\n\nclass ExpressionNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ExpressionNode';\n\n\t}\n\n\tconstructor( snippet = '', nodeType = 'void' ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.snippet = snippet;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst snippet = this.snippet;\n\n\t\tif ( type === 'void' ) {\n\n\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t} else {\n\n\t\t\treturn builder.format( `( ${ snippet } )`, type, output );\n\n\t\t}\n\n\t}\n\n}\n\nconst expression = /*@__PURE__*/ nodeProxy( ExpressionNode );\n\nconst Discard = ( conditional ) => ( conditional ? select( conditional, expression( 'discard' ) ) : expression( 'discard' ) ).append();\nconst Return = () => expression( 'return' ).append();\n\naddMethodChaining( 'discard', Discard );\n\nclass RenderOutputNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'RenderOutputNode';\n\n\t}\n\n\tconstructor( colorNode, toneMapping, outputColorSpace ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.colorNode = colorNode;\n\t\tthis.toneMapping = toneMapping;\n\t\tthis.outputColorSpace = outputColorSpace;\n\n\t\tthis.isRenderOutput = true;\n\n\t}\n\n\tsetup( { context } ) {\n\n\t\tlet outputNode = this.colorNode || context.color;\n\n\t\t// tone mapping\n\n\t\tconst toneMapping = ( this.toneMapping !== null ? this.toneMapping : context.toneMapping ) || NoToneMapping;\n\t\tconst outputColorSpace = ( this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace ) || NoColorSpace;\n\n\t\tif ( toneMapping !== NoToneMapping ) {\n\n\t\t\toutputNode = outputNode.toneMapping( toneMapping );\n\n\t\t}\n\n\t\t// working to output color space\n\n\t\tif ( outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace ) {\n\n\t\t\toutputNode = outputNode.workingToColorSpace( outputColorSpace );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nconst renderOutput = ( color, toneMapping = null, outputColorSpace = null ) => nodeObject( new RenderOutputNode( nodeObject( color ), toneMapping, outputColorSpace ) );\n\naddMethodChaining( 'renderOutput', renderOutput );\n\n// Non-PURE exports list, side-effects are required here.\n// TSL Base Syntax\n\n\nfunction addNodeElement( name/*, nodeElement*/ ) {\n\n\tconsole.warn( 'THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add', name );\n\n}\n\nclass AttributeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'AttributeNode';\n\n\t}\n\n\tconstructor( attributeName, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.global = true;\n\n\t\tthis._attributeName = attributeName;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.getAttributeName( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tlet nodeType = this.nodeType;\n\n\t\tif ( nodeType === null ) {\n\n\t\t\tconst attributeName = this.getAttributeName( builder );\n\n\t\t\tif ( builder.hasGeometryAttribute( attributeName ) ) {\n\n\t\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\n\t\t\t\tnodeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\t} else {\n\n\t\t\t\tnodeType = 'float';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\tsetAttributeName( attributeName ) {\n\n\t\tthis._attributeName = attributeName;\n\n\t\treturn this;\n\n\t}\n\n\tgetAttributeName( /*builder*/ ) {\n\n\t\treturn this._attributeName;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\t\t\tconst attributeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\tconst nodeAttribute = builder.getAttribute( attributeName, attributeType );\n\n\t\t\tif ( builder.shaderStage === 'vertex' ) {\n\n\t\t\t\treturn builder.format( nodeAttribute.name, attributeType, nodeType );\n\n\t\t\t} else {\n\n\t\t\t\tconst nodeVarying = varying( this );\n\n\t\t\t\treturn nodeVarying.build( builder, nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( `AttributeNode: Vertex attribute \"${ attributeName }\" not found on geometry.` );\n\n\t\t\treturn builder.generateConst( nodeType );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.global = this.global;\n\t\tdata._attributeName = this._attributeName;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.global = data.global;\n\t\tthis._attributeName = data._attributeName;\n\n\t}\n\n}\n\nconst attribute = ( name, nodeType ) => nodeObject( new AttributeNode( name, nodeType ) );\n\nconst uv = ( index ) => attribute( 'uv' + ( index > 0 ? index : '' ), 'vec2' );\n\nclass TextureSizeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TextureSizeNode';\n\n\t}\n\n\tconstructor( textureNode, levelNode = null ) {\n\n\t\tsuper( 'uvec2' );\n\n\t\tthis.isTextureSizeNode = true;\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.levelNode = levelNode;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst textureProperty = this.textureNode.build( builder, 'property' );\n\t\tconst level = this.levelNode === null ? '0' : this.levelNode.build( builder, 'int' );\n\n\t\treturn builder.format( `${ builder.getMethod( 'textureDimensions' ) }( ${ textureProperty }, ${ level } )`, this.getNodeType( builder ), output );\n\n\t}\n\n}\n\nconst textureSize = /*@__PURE__*/ nodeProxy( TextureSizeNode );\n\nclass MaxMipLevelNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'MaxMipLevelNode';\n\n\t}\n\n\tconstructor( textureNode ) {\n\n\t\tsuper( 0 );\n\n\t\tthis._textureNode = textureNode;\n\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t}\n\n\tget textureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\tget texture() {\n\n\t\treturn this._textureNode.value;\n\n\t}\n\n\tupdate() {\n\n\t\tconst texture = this.texture;\n\t\tconst images = texture.images;\n\t\tconst image = ( images && images.length > 0 ) ? ( ( images[ 0 ] && images[ 0 ].image ) || images[ 0 ] ) : texture.image;\n\n\t\tif ( image && image.width !== undefined ) {\n\n\t\t\tconst { width, height } = image;\n\n\t\t\tthis.value = Math.log2( Math.max( width, height ) );\n\n\t\t}\n\n\t}\n\n}\n\nconst maxMipLevel = /*@__PURE__*/ nodeProxy( MaxMipLevelNode );\n\nclass TextureNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'TextureNode';\n\n\t}\n\n\tconstructor( value, uvNode = null, levelNode = null, biasNode = null ) {\n\n\t\tsuper( value );\n\n\t\tthis.isTextureNode = true;\n\n\t\tthis.uvNode = uvNode;\n\t\tthis.levelNode = levelNode;\n\t\tthis.biasNode = biasNode;\n\t\tthis.compareNode = null;\n\t\tthis.depthNode = null;\n\t\tthis.gradNode = null;\n\n\t\tthis.sampler = true;\n\t\tthis.updateMatrix = false;\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\tthis.referenceNode = null;\n\n\t\tthis._value = value;\n\t\tthis._matrixUniform = null;\n\n\t\tthis.setUpdateMatrix( uvNode === null );\n\n\t}\n\n\tset value( value ) {\n\n\t\tif ( this.referenceNode ) {\n\n\t\t\tthis.referenceNode.value = value;\n\n\t\t} else {\n\n\t\t\tthis._value = value;\n\n\t\t}\n\n\t}\n\n\tget value() {\n\n\t\treturn this.referenceNode ? this.referenceNode.value : this._value;\n\n\t}\n\n\tgetUniformHash( /*builder*/ ) {\n\n\t\treturn this.value.uuid;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.value.isDepthTexture === true ) return 'float';\n\n\t\tif ( this.value.type === UnsignedIntType ) {\n\n\t\t\treturn 'uvec4';\n\n\t\t} else if ( this.value.type === IntType ) {\n\n\t\t\treturn 'ivec4';\n\n\t\t}\n\n\t\treturn 'vec4';\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture';\n\n\t}\n\n\tgetDefaultUV() {\n\n\t\treturn uv( this.value.channel );\n\n\t}\n\n\tupdateReference( /*state*/ ) {\n\n\t\treturn this.value;\n\n\t}\n\n\tgetTransformedUV( uvNode ) {\n\n\t\tif ( this._matrixUniform === null ) this._matrixUniform = uniform( this.value.matrix );\n\n\t\treturn this._matrixUniform.mul( vec3( uvNode, 1 ) ).xy;\n\n\t}\n\n\tsetUpdateMatrix( value ) {\n\n\t\tthis.updateMatrix = value;\n\t\tthis.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;\n\n\t\treturn this;\n\n\t}\n\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.isFlipY() && ( ( texture.image instanceof ImageBitmap && texture.flipY === true ) || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true ) ) {\n\n\t\t\tif ( this.sampler ) {\n\n\t\t\t\tuvNode = uvNode.flipY();\n\n\t\t\t} else {\n\n\t\t\t\tuvNode = uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uvNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.referenceNode = this.referenceNode;\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( ( uvNode === null || builder.context.forceUVContext === true ) && builder.context.getUV ) {\n\n\t\t\tuvNode = builder.context.getUV( this );\n\n\t\t}\n\n\t\tif ( ! uvNode ) uvNode = this.getDefaultUV();\n\n\t\tif ( this.updateMatrix === true ) {\n\n\t\t\tuvNode = this.getTransformedUV( uvNode );\n\n\t\t}\n\n\t\tuvNode = this.setupUV( builder, uvNode );\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\t//\n\n\t\tproperties.uvNode = uvNode;\n\t\tproperties.levelNode = levelNode;\n\t\tproperties.biasNode = this.biasNode;\n\t\tproperties.compareNode = this.compareNode;\n\t\tproperties.gradNode = this.gradNode;\n\t\tproperties.depthNode = this.depthNode;\n\n\t}\n\n\tgenerateUV( builder, uvNode ) {\n\n\t\treturn uvNode.build( builder, this.sampler === true ? 'vec2' : 'ivec2' );\n\n\t}\n\n\tgenerateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet ) {\n\n\t\tconst texture = this.value;\n\n\t\tlet snippet;\n\n\t\tif ( levelSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet );\n\n\t\t} else if ( biasSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet );\n\n\t\t} else if ( gradSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet );\n\n\t\t} else if ( compareSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet );\n\n\t\t} else if ( this.sampler === false ) {\n\n\t\t\tsnippet = builder.generateTextureLoad( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t} else {\n\n\t\t\tsnippet = builder.generateTexture( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isTexture !== true ) {\n\n\t\t\tthrow new Error( 'TextureNode: Need a three.js texture.' );\n\n\t\t}\n\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\n\t\tif ( output === 'sampler' ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode } = properties;\n\n\t\t\t\tconst uvSnippet = this.generateUV( builder, uvNode );\n\t\t\t\tconst levelSnippet = levelNode ? levelNode.build( builder, 'float' ) : null;\n\t\t\t\tconst biasSnippet = biasNode ? biasNode.build( builder, 'float' ) : null;\n\t\t\t\tconst depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;\n\t\t\t\tconst compareSnippet = compareNode ? compareNode.build( builder, 'float' ) : null;\n\t\t\t\tconst gradSnippet = gradNode ? [ gradNode[ 0 ].build( builder, 'vec2' ), gradNode[ 1 ].build( builder, 'vec2' ) ] : null;\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this );\n\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tconst snippet = this.generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet );\n\n\t\t\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}`, this );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\tlet snippet = propertyName;\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( builder.needsToWorkingColorSpace( texture ) ) {\n\n\t\t\t\tsnippet = colorSpaceToWorking( expression( snippet, nodeType ), texture.colorSpace ).setup( builder ).build( builder, nodeType );\n\n\t\t\t}\n\n\t\t\treturn builder.format( snippet, nodeType, output );\n\n\t\t}\n\n\t}\n\n\tsetSampler( value ) {\n\n\t\tthis.sampler = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetSampler() {\n\n\t\treturn this.sampler;\n\n\t}\n\n\t// @TODO: Move to TSL\n\n\tuv( uvNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.uvNode = nodeObject( uvNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tblur( amountNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.biasNode = nodeObject( amountNode ).mul( maxMipLevel( textureNode ) );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tlevel( levelNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.levelNode = nodeObject( levelNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tsize( levelNode ) {\n\n\t\treturn textureSize( this, levelNode );\n\n\t}\n\n\tbias( biasNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.biasNode = nodeObject( biasNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tcompare( compareNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.compareNode = nodeObject( compareNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tgrad( gradNodeX, gradNodeY ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.gradNode = [ nodeObject( gradNodeX ), nodeObject( gradNodeY ) ];\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tdepth( depthNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.depthNode = nodeObject( depthNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t// --\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value.toJSON( data.meta ).uuid;\n\t\tdata.sampler = this.sampler;\n\t\tdata.updateMatrix = this.updateMatrix;\n\t\tdata.updateType = this.updateType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.value = data.meta.textures[ data.value ];\n\t\tthis.sampler = data.sampler;\n\t\tthis.updateMatrix = data.updateMatrix;\n\t\tthis.updateType = data.updateType;\n\n\t}\n\n\tupdate() {\n\n\t\tconst texture = this.value;\n\t\tconst matrixUniform = this._matrixUniform;\n\n\t\tif ( matrixUniform !== null ) matrixUniform.value = texture.matrix;\n\n\t\tif ( texture.matrixAutoUpdate === true ) {\n\n\t\t\ttexture.updateMatrix();\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new this.constructor( this.value, this.uvNode, this.levelNode, this.biasNode );\n\t\tnewNode.sampler = this.sampler;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\nconst texture = /*@__PURE__*/ nodeProxy( TextureNode );\nconst textureLoad = ( ...params ) => texture( ...params ).setSampler( false );\n\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\nconst sampler = ( aTexture ) => ( aTexture.isNode === true ? aTexture : texture( aTexture ) ).convert( 'sampler' );\n\nconst cameraNear = /*@__PURE__*/ uniform( 'float' ).label( 'cameraNear' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.near );\nconst cameraFar = /*@__PURE__*/ uniform( 'float' ).label( 'cameraFar' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.far );\nconst cameraProjectionMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraProjectionMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrix );\nconst cameraProjectionMatrixInverse = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraProjectionMatrixInverse' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrixInverse );\nconst cameraViewMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraViewMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorldInverse );\nconst cameraWorldMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraWorldMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorld );\nconst cameraNormalMatrix = /*@__PURE__*/ uniform( 'mat3' ).label( 'cameraNormalMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.normalMatrix );\nconst cameraPosition = /*@__PURE__*/ uniform( new Vector3() ).label( 'cameraPosition' ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => self.value.setFromMatrixPosition( camera.matrixWorld ) );\n\nclass Object3DNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'Object3DNode';\n\n\t}\n\n\tconstructor( scope, object3d = null ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\t\tthis.object3d = object3d;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\tthis._uniformNode = new UniformNode( null );\n\n\t}\n\n\tgetNodeType() {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\treturn 'mat4';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {\n\n\t\t\treturn 'vec3';\n\n\t\t}\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst object = this.object3d;\n\t\tconst uniformNode = this._uniformNode;\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tuniformNode.value = object.matrixWorld;\n\n\t\t} else if ( scope === Object3DNode.POSITION ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.SCALE ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tuniformNode.value.setFromMatrixScale( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.DIRECTION ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tobject.getWorldDirection( uniformNode.value );\n\n\t\t} else if ( scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\tconst camera = frame.camera;\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t\tuniformNode.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tthis._uniformNode.nodeType = 'mat4';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {\n\n\t\t\tthis._uniformNode.nodeType = 'vec3';\n\n\t\t}\n\n\t\treturn this._uniformNode.build( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nObject3DNode.WORLD_MATRIX = 'worldMatrix';\nObject3DNode.POSITION = 'position';\nObject3DNode.SCALE = 'scale';\nObject3DNode.VIEW_POSITION = 'viewPosition';\nObject3DNode.DIRECTION = 'direction';\n\nconst objectDirection = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.DIRECTION );\nconst objectWorldMatrix = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.WORLD_MATRIX );\nconst objectPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.POSITION );\nconst objectScale = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.SCALE );\nconst objectViewPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.VIEW_POSITION );\n\nclass ModelNode extends Object3DNode {\n\n\tstatic get type() {\n\n\t\treturn 'ModelNode';\n\n\t}\n\n\tconstructor( scope ) {\n\n\t\tsuper( scope );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tthis.object3d = frame.object;\n\n\t\tsuper.update( frame );\n\n\t}\n\n}\n\nconst modelDirection = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.DIRECTION );\nconst modelWorldMatrix = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );\nconst modelPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.POSITION );\nconst modelScale = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.SCALE );\nconst modelViewPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );\nconst modelNormalMatrix = /*@__PURE__*/ uniform( new Matrix3() ).onObjectUpdate( ( { object }, self ) => self.value.getNormalMatrix( object.matrixWorld ) );\nconst modelWorldMatrixInverse = /*@__PURE__*/ uniform( new Matrix4() ).onObjectUpdate( ( { object }, self ) => self.value.copy( object.matrixWorld ).invert() );\nconst modelViewMatrix = /*@__PURE__*/ cameraViewMatrix.mul( modelWorldMatrix ).toVar( 'modelViewMatrix' );\n\nconst highPrecisionModelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tbuilder.context.isHighPrecisionModelViewMatrix = true;\n\n\treturn uniform( 'mat4' ).onObjectUpdate( ( { object, camera } ) => {\n\n\t\treturn object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t} );\n\n} ).once() )().toVar( 'highPrecisionModelViewMatrix' );\n\nconst highPrecisionModelNormalViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tconst isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;\n\n\treturn uniform( 'mat3' ).onObjectUpdate( ( { object, camera } ) => {\n\n\t\tif ( isHighPrecisionModelViewMatrix !== true ) {\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\t}\n\n\t\treturn object.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t} );\n\n} ).once() )().toVar( 'highPrecisionModelNormalMatrix' );\n\nconst positionGeometry = /*@__PURE__*/ attribute( 'position', 'vec3' );\nconst positionLocal = /*@__PURE__*/ positionGeometry.varying( 'positionLocal' );\nconst positionPrevious = /*@__PURE__*/ positionGeometry.varying( 'positionPrevious' );\nconst positionWorld = /*@__PURE__*/ modelWorldMatrix.mul( positionLocal ).xyz.varying( 'v_positionWorld' );\nconst positionWorldDirection = /*@__PURE__*/ positionLocal.transformDirection( modelWorldMatrix ).varying( 'v_positionWorldDirection' ).normalize().toVar( 'positionWorldDirection' );\nconst positionView = /*@__PURE__*/ modelViewMatrix.mul( positionLocal ).xyz.varying( 'v_positionView' );\nconst positionViewDirection = /*@__PURE__*/ positionView.negate().varying( 'v_positionViewDirection' ).normalize().toVar( 'positionViewDirection' );\n\nclass FrontFacingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'FrontFacingNode';\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( 'bool' );\n\n\t\tthis.isFrontFacingNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { renderer, material } = builder;\n\n\t\tif ( renderer.coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\treturn 'false';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn builder.getFrontFacing();\n\n\t}\n\n}\n\nconst frontFacing = /*@__PURE__*/ nodeImmutable( FrontFacingNode );\nconst faceDirection = /*@__PURE__*/ float( frontFacing ).mul( 2.0 ).sub( 1.0 );\n\nconst normalGeometry = /*@__PURE__*/ attribute( 'normal', 'vec3' );\n\nconst normalLocal = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'normal' ) === false ) {\n\n\t\tconsole.warn( 'TSL.NormalNode: Vertex attribute \"normal\" not found on geometry.' );\n\n\t\treturn vec3( 0, 1, 0 );\n\n\t}\n\n\treturn normalGeometry;\n\n}, 'vec3' ).once() )().toVar( 'normalLocal' );\n\nconst normalFlat = /*@__PURE__*/ positionView.dFdx().cross( positionView.dFdy() ).normalize().toVar( 'normalFlat' );\n\nconst normalView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tlet node;\n\n\tif ( builder.material.flatShading === true ) {\n\n\t\tnode = normalFlat;\n\n\t} else {\n\n\t\tnode = varying( transformNormalToView( normalLocal ), 'v_normalView' ).normalize();\n\n\t}\n\n\treturn node;\n\n}, 'vec3' ).once() )().toVar( 'normalView' );\n\nconst normalWorld = /*@__PURE__*/ varying( normalView.transformDirection( cameraViewMatrix ), 'v_normalWorld' ).normalize().toVar( 'normalWorld' );\n\nconst transformedNormalView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.context.setupNormal();\n\n}, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedNormalView' );\n\n\nconst transformedNormalWorld = /*@__PURE__*/ transformedNormalView.transformDirection( cameraViewMatrix ).toVar( 'transformedNormalWorld' );\n\nconst transformedClearcoatNormalView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.context.setupClearcoatNormal();\n\n}, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedClearcoatNormalView' );\n\nconst transformNormal = /*@__PURE__*/ Fn( ( [ normal, matrix = modelWorldMatrix ] ) => {\n\n\tconst m = mat3( matrix );\n\n\tconst transformedNormal = normal.div( vec3( m[ 0 ].dot( m[ 0 ] ), m[ 1 ].dot( m[ 1 ] ), m[ 2 ].dot( m[ 2 ] ) ) );\n\n\treturn m.mul( transformedNormal ).xyz;\n\n} );\n\nconst transformNormalToView = /*@__PURE__*/ Fn( ( [ normal ], builder ) => {\n\n\tconst modelNormalViewMatrix = builder.renderer.nodes.modelNormalViewMatrix;\n\n\tif ( modelNormalViewMatrix !== null ) {\n\n\t\treturn modelNormalViewMatrix.transformDirection( normal );\n\n\t}\n\n\t//\n\n\tconst transformedNormal = modelNormalMatrix.mul( normal );\n\n\treturn cameraViewMatrix.transformDirection( transformedNormal );\n\n} );\n\nconst materialRefractionRatio = /*@__PURE__*/ uniform( 0 ).onReference( ( { material } ) => material ).onRenderUpdate( ( { material } ) => material.refractionRatio );\n\nconst reflectView = /*@__PURE__*/ positionViewDirection.negate().reflect( transformedNormalView );\nconst refractView = /*@__PURE__*/ positionViewDirection.negate().refract( transformedNormalView, materialRefractionRatio );\n\nconst reflectVector = /*@__PURE__*/ reflectView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );\nconst refractVector = /*@__PURE__*/ refractView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );\n\nclass CubeTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'CubeTextureNode';\n\n\t}\n\n\tconstructor( value, uvNode = null, levelNode = null, biasNode = null ) {\n\n\t\tsuper( value, uvNode, levelNode, biasNode );\n\n\t\tthis.isCubeTextureNode = true;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'cubeTexture';\n\n\t}\n\n\tgetDefaultUV() {\n\n\t\tconst texture = this.value;\n\n\t\tif ( texture.mapping === CubeReflectionMapping ) {\n\n\t\t\treturn reflectVector;\n\n\t\t} else if ( texture.mapping === CubeRefractionMapping ) {\n\n\t\t\treturn refractVector;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.CubeTextureNode: Mapping \"%s\" not supported.', texture.mapping );\n\n\t\t\treturn vec3( 0, 0, 0 );\n\n\t\t}\n\n\t}\n\n\tsetUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for CubeTextureNode\n\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem || ! texture.isRenderTargetTexture ) {\n\n\t\t\treturn vec3( uvNode.x.negate(), uvNode.yz );\n\n\t\t} else {\n\n\t\t\treturn uvNode;\n\n\t\t}\n\n\t}\n\n\tgenerateUV( builder, cubeUV ) {\n\n\t\treturn cubeUV.build( builder, 'vec3' );\n\n\t}\n\n}\n\nconst cubeTexture = /*@__PURE__*/ nodeProxy( CubeTextureNode );\n\nclass BufferNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'BufferNode';\n\n\t}\n\n\tconstructor( value, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\tthis.isBufferNode = true;\n\n\t\tthis.bufferType = bufferType;\n\t\tthis.bufferCount = bufferCount;\n\n\t}\n\n\tgetElementType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'buffer';\n\n\t}\n\n}\n\nconst buffer = ( value, type, count ) => nodeObject( new BufferNode( value, type, count ) );\n\nclass UniformArrayElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformArrayElementNode';\n\n\t}\n\n\tconstructor( arrayBuffer, indexNode ) {\n\n\t\tsuper( arrayBuffer, indexNode );\n\n\t\tthis.isArrayBufferElementNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst type = this.getNodeType();\n\n\t\treturn builder.format( snippet, 'vec4', type );\n\n\t}\n\n}\n\nclass UniformArrayNode extends BufferNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformArrayNode';\n\n\t}\n\n\tconstructor( value, elementType = null ) {\n\n\t\tsuper( null, 'vec4' );\n\n\t\tthis.array = value;\n\t\tthis.elementType = elementType;\n\n\t\tthis._elementType = null;\n\t\tthis._elementLength = 0;\n\n\t\tthis.updateType = NodeUpdateType.RENDER;\n\n\t\tthis.isArrayBufferNode = true;\n\n\t}\n\n\tgetElementType() {\n\n\t\treturn this.elementType || this._elementType;\n\n\t}\n\n\tgetElementLength() {\n\n\t\treturn this._elementLength;\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tconst { array, value } = this;\n\n\t\tconst elementLength = this.getElementLength();\n\t\tconst elementType = this.getElementType();\n\n\t\tif ( elementLength === 1 ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\n\t\t\t\tvalue[ index ] = array[ i ];\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'color' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst vector = array[ i ];\n\n\t\t\t\tvalue[ index ] = vector.r;\n\t\t\t\tvalue[ index + 1 ] = vector.g;\n\t\t\t\tvalue[ index + 2 ] = vector.b || 0;\n\t\t\t\t//value[ index + 3 ] = vector.a || 0;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst vector = array[ i ];\n\n\t\t\t\tvalue[ index ] = vector.x;\n\t\t\t\tvalue[ index + 1 ] = vector.y;\n\t\t\t\tvalue[ index + 2 ] = vector.z || 0;\n\t\t\t\tvalue[ index + 3 ] = vector.w || 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst length = this.array.length;\n\n\t\tthis._elementType = this.elementType === null ? getValueType( this.array[ 0 ] ) : this.elementType;\n\t\tthis._elementLength = builder.getTypeLength( this._elementType );\n\n\t\tlet arrayType = Float32Array;\n\n\t\tif ( this._elementType.charAt( 0 ) === 'i' ) arrayType = Int32Array;\n\t\telse if ( this._elementType.charAt( 0 ) === 'u' ) arrayType = Uint32Array;\n\n\t\tthis.value = new arrayType( length * 4 );\n\t\tthis.bufferCount = length;\n\t\tthis.bufferType = builder.changeComponentType( 'vec4', builder.getComponentType( this._elementType ) );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new UniformArrayElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n}\n\nconst uniformArray = ( values, nodeType ) => nodeObject( new UniformArrayNode( values, nodeType ) );\n\n//\n\nconst uniforms = ( values, nodeType ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.UniformArrayNode: uniforms() has been renamed to uniformArray().' );\n\treturn nodeObject( new UniformArrayNode( values, nodeType ) );\n\n};\n\nclass ReferenceElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceElementNode';\n\n\t}\n\n\tconstructor( referenceNode, indexNode ) {\n\n\t\tsuper( referenceNode, indexNode );\n\n\t\tthis.referenceNode = referenceNode;\n\n\t\tthis.isReferenceElementNode = true;\n\n\t}\n\n\tgetNodeType() {\n\n\t\treturn this.referenceNode.uniformType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst arrayType = this.referenceNode.getNodeType();\n\t\tconst elementType = this.getNodeType();\n\n\t\treturn builder.format( snippet, arrayType, elementType );\n\n\t}\n\n}\n\n// TODO: Extends this from ReferenceBaseNode\nclass ReferenceNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceNode';\n\n\t}\n\n\tconstructor( property, uniformType, object = null, count = null ) {\n\n\t\tsuper();\n\n\t\tthis.property = property;\n\t\tthis.uniformType = uniformType;\n\t\tthis.object = object;\n\t\tthis.count = count;\n\n\t\tthis.properties = property.split( '.' );\n\t\tthis.reference = object;\n\t\tthis.node = null;\n\t\tthis.group = null;\n\t\tthis.name = null;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new ReferenceElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n\tsetGroup( group ) {\n\n\t\tthis.group = group;\n\n\t\treturn this;\n\n\t}\n\n\tlabel( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\tsetNodeType( uniformType ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.count !== null ) {\n\n\t\t\tnode = buffer( null, uniformType, this.count );\n\n\t\t} else if ( Array.isArray( this.getValueFromReference() ) ) {\n\n\t\t\tnode = uniformArray( null, uniformType );\n\n\t\t} else if ( uniformType === 'texture' ) {\n\n\t\t\tnode = texture( null );\n\n\t\t} else if ( uniformType === 'cubeTexture' ) {\n\n\t\t\tnode = cubeTexture( null );\n\n\t\t} else {\n\n\t\t\tnode = uniform( null, uniformType );\n\n\t\t}\n\n\t\tif ( this.group !== null ) {\n\n\t\t\tnode.setGroup( this.group );\n\n\t\t}\n\n\t\tif ( this.name !== null ) node.label( this.name );\n\n\t\tthis.node = node.getSelf();\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( this.node === null ) {\n\n\t\t\tthis.updateReference( builder );\n\t\t\tthis.updateValue();\n\n\t\t}\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgetValueFromReference( object = this.reference ) {\n\n\t\tconst { properties } = this;\n\n\t\tlet value = object[ properties[ 0 ] ];\n\n\t\tfor ( let i = 1; i < properties.length; i ++ ) {\n\n\t\t\tvalue = value[ properties[ i ] ];\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.object !== null ? this.object : state.object;\n\n\t\treturn this.reference;\n\n\t}\n\n\tsetup() {\n\n\t\tthis.updateValue();\n\n\t\treturn this.node;\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tthis.updateValue();\n\n\t}\n\n\tupdateValue() {\n\n\t\tif ( this.node === null ) this.setNodeType( this.uniformType );\n\n\t\tconst value = this.getValueFromReference();\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tthis.node.array = value;\n\n\t\t} else {\n\n\t\t\tthis.node.value = value;\n\n\t\t}\n\n\t}\n\n}\n\nconst reference = ( name, type, object ) => nodeObject( new ReferenceNode( name, type, object ) );\nconst referenceBuffer = ( name, type, count, object ) => nodeObject( new ReferenceNode( name, type, object, count ) );\n\nclass MaterialReferenceNode extends ReferenceNode {\n\n\tstatic get type() {\n\n\t\treturn 'MaterialReferenceNode';\n\n\t}\n\n\tconstructor( property, inputType, material = null ) {\n\n\t\tsuper( property, inputType, material );\n\n\t\tthis.material = material;\n\n\t\t//this.updateType = NodeUpdateType.RENDER;\n\n\t\tthis.isMaterialReferenceNode = true;\n\n\t}\n\n\t/*setNodeType( node ) {\n\n\t\tsuper.setNodeType( node );\n\n\t\tthis.node.groupNode = renderGroup;\n\n\t}*/\n\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.material !== null ? this.material : state.material;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\nconst materialReference = ( name, type, material ) => nodeObject( new MaterialReferenceNode( name, type, material ) );\n\nconst tangentGeometry = /*@__PURE__*/ Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'tangent' ) === false ) {\n\n\t\tbuilder.geometry.computeTangents();\n\n\t}\n\n\treturn attribute( 'tangent', 'vec4' );\n\n} )();\n\nconst tangentLocal = /*@__PURE__*/ tangentGeometry.xyz.toVar( 'tangentLocal' );\nconst tangentView = /*@__PURE__*/ modelViewMatrix.mul( vec4( tangentLocal, 0 ) ).xyz.varying( 'v_tangentView' ).normalize().toVar( 'tangentView' );\nconst tangentWorld = /*@__PURE__*/ tangentView.transformDirection( cameraViewMatrix ).varying( 'v_tangentWorld' ).normalize().toVar( 'tangentWorld' );\nconst transformedTangentView = /*@__PURE__*/ tangentView.toVar( 'transformedTangentView' );\nconst transformedTangentWorld = /*@__PURE__*/ transformedTangentView.transformDirection( cameraViewMatrix ).normalize().toVar( 'transformedTangentWorld' );\n\nconst getBitangent = ( crossNormalTangent ) => crossNormalTangent.mul( tangentGeometry.w ).xyz;\n\nconst bitangentGeometry = /*@__PURE__*/ varying( getBitangent( normalGeometry.cross( tangentGeometry ) ), 'v_bitangentGeometry' ).normalize().toVar( 'bitangentGeometry' );\nconst bitangentLocal = /*@__PURE__*/ varying( getBitangent( normalLocal.cross( tangentLocal ) ), 'v_bitangentLocal' ).normalize().toVar( 'bitangentLocal' );\nconst bitangentView = /*@__PURE__*/ varying( getBitangent( normalView.cross( tangentView ) ), 'v_bitangentView' ).normalize().toVar( 'bitangentView' );\nconst bitangentWorld = /*@__PURE__*/ varying( getBitangent( normalWorld.cross( tangentWorld ) ), 'v_bitangentWorld' ).normalize().toVar( 'bitangentWorld' );\nconst transformedBitangentView = /*@__PURE__*/ getBitangent( transformedNormalView.cross( transformedTangentView ) ).normalize().toVar( 'transformedBitangentView' );\nconst transformedBitangentWorld = /*@__PURE__*/ transformedBitangentView.transformDirection( cameraViewMatrix ).normalize().toVar( 'transformedBitangentWorld' );\n\nconst TBNViewMatrix = /*@__PURE__*/ mat3( tangentView, bitangentView, normalView );\n\nconst parallaxDirection = /*@__PURE__*/ positionViewDirection.mul( TBNViewMatrix )/*.normalize()*/;\nconst parallaxUV = ( uv, scale ) => uv.sub( parallaxDirection.mul( scale ) );\n\nconst transformedBentNormalView = /*@__PURE__*/ ( () => {\n\n\t// https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy\n\n\tlet bentNormal = anisotropyB.cross( positionViewDirection );\n\tbentNormal = bentNormal.cross( anisotropyB ).normalize();\n\tbentNormal = mix( bentNormal, transformedNormalView, anisotropy.mul( roughness.oneMinus() ).oneMinus().pow2().pow2() ).normalize();\n\n\treturn bentNormal;\n\n\n} )();\n\n// Normal Mapping Without Precomputed Tangents\n// http://www.thetenthplanet.de/archives/1180\n\nconst perturbNormal2Arb = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { eye_pos, surf_norm, mapN, uv } = inputs;\n\n\tconst q0 = eye_pos.dFdx();\n\tconst q1 = eye_pos.dFdy();\n\tconst st0 = uv.dFdx();\n\tconst st1 = uv.dFdy();\n\n\tconst N = surf_norm; // normalized\n\n\tconst q1perp = q1.cross( N );\n\tconst q0perp = N.cross( q0 );\n\n\tconst T = q1perp.mul( st0.x ).add( q0perp.mul( st1.x ) );\n\tconst B = q1perp.mul( st0.y ).add( q0perp.mul( st1.y ) );\n\n\tconst det = T.dot( T ).max( B.dot( B ) );\n\tconst scale = faceDirection.mul( det.inverseSqrt() );\n\n\treturn add( T.mul( mapN.x, scale ), B.mul( mapN.y, scale ), N.mul( mapN.z ) ).normalize();\n\n} );\n\nclass NormalMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'NormalMapNode';\n\n\t}\n\n\tconstructor( node, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.node = node;\n\t\tthis.scaleNode = scaleNode;\n\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { normalMapType, scaleNode } = this;\n\n\t\tlet normalMap = this.node.mul( 2.0 ).sub( 1.0 );\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tnormalMap = vec3( normalMap.xy.mul( scaleNode ), normalMap.z );\n\n\t\t}\n\n\t\tlet outputNode = null;\n\n\t\tif ( normalMapType === ObjectSpaceNormalMap ) {\n\n\t\t\toutputNode = transformNormalToView( normalMap );\n\n\t\t} else if ( normalMapType === TangentSpaceNormalMap ) {\n\n\t\t\tconst tangent = builder.hasGeometryAttribute( 'tangent' );\n\n\t\t\tif ( tangent === true ) {\n\n\t\t\t\toutputNode = TBNViewMatrix.mul( normalMap ).normalize();\n\n\t\t\t} else {\n\n\t\t\t\toutputNode = perturbNormal2Arb( {\n\t\t\t\t\teye_pos: positionView,\n\t\t\t\t\tsurf_norm: normalView,\n\t\t\t\t\tmapN: normalMap,\n\t\t\t\t\tuv: uv()\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nconst normalMap = /*@__PURE__*/ nodeProxy( NormalMapNode );\n\n// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\nconst dHdxy_fwd = Fn( ( { textureNode, bumpScale } ) => {\n\n\t// It's used to preserve the same TextureNode instance\n\tconst sampleTexture = ( callback ) => textureNode.cache().context( { getUV: ( texNode ) => callback( texNode.uvNode || uv() ), forceUVContext: true } );\n\n\tconst Hll = float( sampleTexture( ( uvNode ) => uvNode ) );\n\n\treturn vec2(\n\t\tfloat( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdx() ) ) ).sub( Hll ),\n\t\tfloat( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdy() ) ) ).sub( Hll )\n\t).mul( bumpScale );\n\n} );\n\n// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\nconst perturbNormalArb = Fn( ( inputs ) => {\n\n\tconst { surf_pos, surf_norm, dHdxy } = inputs;\n\n\t// normalize is done to ensure that the bump map looks the same regardless of the texture's scale\n\tconst vSigmaX = surf_pos.dFdx().normalize();\n\tconst vSigmaY = surf_pos.dFdy().normalize();\n\tconst vN = surf_norm; // normalized\n\n\tconst R1 = vSigmaY.cross( vN );\n\tconst R2 = vN.cross( vSigmaX );\n\n\tconst fDet = vSigmaX.dot( R1 ).mul( faceDirection );\n\n\tconst vGrad = fDet.sign().mul( dHdxy.x.mul( R1 ).add( dHdxy.y.mul( R2 ) ) );\n\n\treturn fDet.abs().mul( surf_norm ).sub( vGrad ).normalize();\n\n} );\n\nclass BumpMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'BumpMapNode';\n\n\t}\n\n\tconstructor( textureNode, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.scaleNode = scaleNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst bumpScale = this.scaleNode !== null ? this.scaleNode : 1;\n\t\tconst dHdxy = dHdxy_fwd( { textureNode: this.textureNode, bumpScale } );\n\n\t\treturn perturbNormalArb( {\n\t\t\tsurf_pos: positionView,\n\t\t\tsurf_norm: normalView,\n\t\t\tdHdxy\n\t\t} );\n\n\t}\n\n}\n\nconst bumpMap = /*@__PURE__*/ nodeProxy( BumpMapNode );\n\nconst _propertyCache = new Map();\n\nclass MaterialNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MaterialNode';\n\n\t}\n\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgetCache( property, type ) {\n\n\t\tlet node = _propertyCache.get( property );\n\n\t\tif ( node === undefined ) {\n\n\t\t\tnode = materialReference( property, type );\n\n\t\t\t_propertyCache.set( property, node );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tgetFloat( property ) {\n\n\t\treturn this.getCache( property, 'float' );\n\n\t}\n\n\tgetColor( property ) {\n\n\t\treturn this.getCache( property, 'color' );\n\n\t}\n\n\tgetTexture( property ) {\n\n\t\treturn this.getCache( property === 'map' ? 'map' : property + 'Map', 'texture' );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst material = builder.context.material;\n\t\tconst scope = this.scope;\n\n\t\tlet node = null;\n\n\t\tif ( scope === MaterialNode.COLOR ) {\n\n\t\t\tconst colorNode = material.color !== undefined ? this.getColor( scope ) : vec3();\n\n\t\t\tif ( material.map && material.map.isTexture === true ) {\n\n\t\t\t\tnode = colorNode.mul( this.getTexture( 'map' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = colorNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.OPACITY ) {\n\n\t\t\tconst opacityNode = this.getFloat( scope );\n\n\t\t\tif ( material.alphaMap && material.alphaMap.isTexture === true ) {\n\n\t\t\t\tnode = opacityNode.mul( this.getTexture( 'alpha' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = opacityNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_STRENGTH ) {\n\n\t\t\tif ( material.specularMap && material.specularMap.isTexture === true ) {\n\n\t\t\t\tnode = this.getTexture( 'specular' ).r;\n\n\t\t\t} else {\n\n\t\t\t\tnode = float( 1 );\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_INTENSITY ) {\n\n\t\t\tconst specularIntensity = this.getFloat( scope );\n\n\t\t\tif ( material.specularMap ) {\n\n\t\t\t\tnode = specularIntensity.mul( this.getTexture( scope ).a );\n\n\t\t\t} else {\n\n\t\t\t\tnode = specularIntensity;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_COLOR ) {\n\n\t\t\tconst specularColorNode = this.getColor( scope );\n\n\t\t\tif ( material.specularColorMap && material.specularColorMap.isTexture === true ) {\n\n\t\t\t\tnode = specularColorNode.mul( this.getTexture( scope ).rgb );\n\n\t\t\t} else {\n\n\t\t\t\tnode = specularColorNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.ROUGHNESS ) { // TODO: cleanup similar branches\n\n\t\t\tconst roughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.roughnessMap && material.roughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = roughnessNode.mul( this.getTexture( scope ).g );\n\n\t\t\t} else {\n\n\t\t\t\tnode = roughnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.METALNESS ) {\n\n\t\t\tconst metalnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.metalnessMap && material.metalnessMap.isTexture === true ) {\n\n\t\t\t\tnode = metalnessNode.mul( this.getTexture( scope ).b );\n\n\t\t\t} else {\n\n\t\t\t\tnode = metalnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.EMISSIVE ) {\n\n\t\t\tconst emissiveIntensityNode = this.getFloat( 'emissiveIntensity' );\n\t\t\tconst emissiveNode = this.getColor( scope ).mul( emissiveIntensityNode );\n\n\t\t\tif ( material.emissiveMap && material.emissiveMap.isTexture === true ) {\n\n\t\t\t\tnode = emissiveNode.mul( this.getTexture( scope ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = emissiveNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.NORMAL ) {\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tnode = normalMap( this.getTexture( 'normal' ), this.getCache( 'normalScale', 'vec2' ) );\n\t\t\t\tnode.normalMapType = material.normalMapType;\n\n\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\tnode = bumpMap( this.getTexture( 'bump' ).r, this.getFloat( 'bumpScale' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = normalView;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT ) {\n\n\t\t\tconst clearcoatNode = this.getFloat( scope );\n\n\t\t\tif ( material.clearcoatMap && material.clearcoatMap.isTexture === true ) {\n\n\t\t\t\tnode = clearcoatNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = clearcoatNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT_ROUGHNESS ) {\n\n\t\t\tconst clearcoatRoughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = clearcoatRoughnessNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = clearcoatRoughnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT_NORMAL ) {\n\n\t\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\t\tnode = normalMap( this.getTexture( scope ), this.getCache( scope + 'Scale', 'vec2' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = normalView;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SHEEN ) {\n\n\t\t\tconst sheenNode = this.getColor( 'sheenColor' ).mul( this.getFloat( 'sheen' ) ); // Move this mul() to CPU\n\n\t\t\tif ( material.sheenColorMap && material.sheenColorMap.isTexture === true ) {\n\n\t\t\t\tnode = sheenNode.mul( this.getTexture( 'sheenColor' ).rgb );\n\n\t\t\t} else {\n\n\t\t\t\tnode = sheenNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SHEEN_ROUGHNESS ) {\n\n\t\t\tconst sheenRoughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = sheenRoughnessNode.mul( this.getTexture( scope ).a );\n\n\t\t\t} else {\n\n\t\t\t\tnode = sheenRoughnessNode;\n\n\t\t\t}\n\n\t\t\tnode = node.clamp( 0.07, 1.0 );\n\n\t\t} else if ( scope === MaterialNode.ANISOTROPY ) {\n\n\t\t\tif ( material.anisotropyMap && material.anisotropyMap.isTexture === true ) {\n\n\t\t\t\tconst anisotropyPolar = this.getTexture( scope );\n\t\t\t\tconst anisotropyMat = mat2( materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x );\n\n\t\t\t\tnode = anisotropyMat.mul( anisotropyPolar.rg.mul( 2.0 ).sub( vec2( 1.0 ) ).normalize().mul( anisotropyPolar.b ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = materialAnisotropyVector;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.IRIDESCENCE_THICKNESS ) {\n\n\t\t\tconst iridescenceThicknessMaximum = reference( '1', 'float', material.iridescenceThicknessRange );\n\n\t\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\t\tconst iridescenceThicknessMinimum = reference( '0', 'float', material.iridescenceThicknessRange );\n\n\t\t\t\tnode = iridescenceThicknessMaximum.sub( iridescenceThicknessMinimum ).mul( this.getTexture( scope ).g ).add( iridescenceThicknessMinimum );\n\n\t\t\t} else {\n\n\t\t\t\tnode = iridescenceThicknessMaximum;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.TRANSMISSION ) {\n\n\t\t\tconst transmissionNode = this.getFloat( scope );\n\n\t\t\tif ( material.transmissionMap ) {\n\n\t\t\t\tnode = transmissionNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = transmissionNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.THICKNESS ) {\n\n\t\t\tconst thicknessNode = this.getFloat( scope );\n\n\t\t\tif ( material.thicknessMap ) {\n\n\t\t\t\tnode = thicknessNode.mul( this.getTexture( scope ).g );\n\n\t\t\t} else {\n\n\t\t\t\tnode = thicknessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.IOR ) {\n\n\t\t\tnode = this.getFloat( scope );\n\n\t\t} else if ( scope === MaterialNode.LIGHT_MAP ) {\n\n\t\t\tnode = this.getTexture( scope ).rgb.mul( this.getFloat( 'lightMapIntensity' ) );\n\n\t\t} else if ( scope === MaterialNode.AO_MAP ) {\n\n\t\t\tnode = this.getTexture( scope ).r.sub( 1.0 ).mul( this.getFloat( 'aoMapIntensity' ) ).add( 1.0 );\n\n\t\t} else {\n\n\t\t\tconst outputType = this.getNodeType( builder );\n\n\t\t\tnode = this.getCache( scope, outputType );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nMaterialNode.ALPHA_TEST = 'alphaTest';\nMaterialNode.COLOR = 'color';\nMaterialNode.OPACITY = 'opacity';\nMaterialNode.SHININESS = 'shininess';\nMaterialNode.SPECULAR = 'specular';\nMaterialNode.SPECULAR_STRENGTH = 'specularStrength';\nMaterialNode.SPECULAR_INTENSITY = 'specularIntensity';\nMaterialNode.SPECULAR_COLOR = 'specularColor';\nMaterialNode.REFLECTIVITY = 'reflectivity';\nMaterialNode.ROUGHNESS = 'roughness';\nMaterialNode.METALNESS = 'metalness';\nMaterialNode.NORMAL = 'normal';\nMaterialNode.CLEARCOAT = 'clearcoat';\nMaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';\nMaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';\nMaterialNode.EMISSIVE = 'emissive';\nMaterialNode.ROTATION = 'rotation';\nMaterialNode.SHEEN = 'sheen';\nMaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';\nMaterialNode.ANISOTROPY = 'anisotropy';\nMaterialNode.IRIDESCENCE = 'iridescence';\nMaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';\nMaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';\nMaterialNode.IOR = 'ior';\nMaterialNode.TRANSMISSION = 'transmission';\nMaterialNode.THICKNESS = 'thickness';\nMaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';\nMaterialNode.ATTENUATION_COLOR = 'attenuationColor';\nMaterialNode.LINE_SCALE = 'scale';\nMaterialNode.LINE_DASH_SIZE = 'dashSize';\nMaterialNode.LINE_GAP_SIZE = 'gapSize';\nMaterialNode.LINE_WIDTH = 'linewidth';\nMaterialNode.LINE_DASH_OFFSET = 'dashOffset';\nMaterialNode.POINT_WIDTH = 'pointWidth';\nMaterialNode.DISPERSION = 'dispersion';\nMaterialNode.LIGHT_MAP = 'light';\nMaterialNode.AO_MAP = 'ao';\n\nconst materialAlphaTest = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );\nconst materialColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.COLOR );\nconst materialShininess = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHININESS );\nconst materialEmissive = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.EMISSIVE );\nconst materialOpacity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.OPACITY );\nconst materialSpecular = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR );\n\nconst materialSpecularIntensity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_INTENSITY );\nconst materialSpecularColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_COLOR );\n\nconst materialSpecularStrength = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_STRENGTH );\nconst materialReflectivity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.REFLECTIVITY );\nconst materialRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );\nconst materialMetalness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.METALNESS );\nconst materialNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.NORMAL ).context( { getUV: null } );\nconst materialClearcoat = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT );\nconst materialClearcoatRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS );\nconst materialClearcoatNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_NORMAL ).context( { getUV: null } );\nconst materialRotation = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROTATION );\nconst materialSheen = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN );\nconst materialSheenRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN_ROUGHNESS );\nconst materialAnisotropy = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ANISOTROPY );\nconst materialIridescence = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE );\nconst materialIridescenceIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_IOR );\nconst materialIridescenceThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS );\nconst materialTransmission = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.TRANSMISSION );\nconst materialThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.THICKNESS );\nconst materialIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IOR );\nconst materialAttenuationDistance = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_DISTANCE );\nconst materialAttenuationColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_COLOR );\nconst materialLineScale = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_SCALE );\nconst materialLineDashSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_SIZE );\nconst materialLineGapSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_GAP_SIZE );\nconst materialLineWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_WIDTH );\nconst materialLineDashOffset = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_OFFSET );\nconst materialPointWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.POINT_WIDTH );\nconst materialDispersion = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.DISPERSION );\nconst materialLightMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LIGHT_MAP );\nconst materialAOMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.AO_MAP );\nconst materialAnisotropyVector = /*@__PURE__*/ uniform( new Vector2() ).onReference( function ( frame ) {\n\n\treturn frame.material;\n\n} ).onRenderUpdate( function ( { material } ) {\n\n\tthis.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );\n\n} );\n\nclass ModelViewProjectionNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ModelViewProjectionNode';\n\n\t}\n\n\tconstructor( positionNode = null ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.positionNode = positionNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( builder.shaderStage === 'fragment' ) {\n\n\t\t\treturn varying( builder.context.mvp );\n\n\t\t}\n\n\t\tconst position = this.positionNode || positionLocal;\n\t\tconst viewMatrix = builder.renderer.nodes.modelViewMatrix || modelViewMatrix;\n\n\t\treturn cameraProjectionMatrix.mul( viewMatrix ).mul( position );\n\n\t}\n\n}\n\nconst modelViewProjection = /*@__PURE__*/ nodeProxy( ModelViewProjectionNode );\n\nclass IndexNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'IndexNode';\n\n\t}\n\n\tconstructor( scope ) {\n\n\t\tsuper( 'uint' );\n\n\t\tthis.scope = scope;\n\n\t\tthis.isInstanceIndexNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst scope = this.scope;\n\n\t\tlet propertyName;\n\n\t\tif ( scope === IndexNode.VERTEX ) {\n\n\t\t\t// The index of a vertex within a mesh.\n\t\t\tpropertyName = builder.getVertexIndex();\n\n\t\t} else if ( scope === IndexNode.INSTANCE ) {\n\n\t\t\t// The index of either a mesh instance or an invocation of a compute shader.\n\t\t\tpropertyName = builder.getInstanceIndex();\n\n\t\t} else if ( scope === IndexNode.DRAW ) {\n\n\t\t\t// The index of a draw call.\n\t\t\tpropertyName = builder.getDrawIndex();\n\n\t\t} else if ( scope === IndexNode.INVOCATION_LOCAL ) {\n\n\t\t\t// The index of a compute invocation within the scope of a workgroup load.\n\t\t\tpropertyName = builder.getInvocationLocalIndex();\n\n\t\t} else if ( scope === IndexNode.INVOCATION_SUBGROUP ) {\n\n\t\t\t// The index of a compute invocation within the scope of a subgroup.\n\t\t\tpropertyName = builder.getInvocationSubgroupIndex();\n\n\t\t} else if ( scope === IndexNode.SUBGROUP ) {\n\n\t\t\t// The index of the subgroup the current compute invocation belongs to.\n\t\t\tpropertyName = builder.getSubgroupIndex();\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.IndexNode: Unknown scope: ' + scope );\n\n\t\t}\n\n\t\tlet output;\n\n\t\tif ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {\n\n\t\t\toutput = propertyName;\n\n\t\t} else {\n\n\t\t\tconst nodeVarying = varying( this );\n\n\t\t\toutput = nodeVarying.build( builder, nodeType );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nIndexNode.VERTEX = 'vertex';\nIndexNode.INSTANCE = 'instance';\nIndexNode.SUBGROUP = 'subgroup';\nIndexNode.INVOCATION_LOCAL = 'invocationLocal';\nIndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';\nIndexNode.DRAW = 'draw';\n\nconst vertexIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.VERTEX );\nconst instanceIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INSTANCE );\nconst subgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.SUBGROUP );\nconst invocationSubgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_SUBGROUP );\nconst invocationLocalIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_LOCAL );\nconst drawIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.DRAW );\n\nclass InstanceNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'InstanceNode';\n\n\t}\n\n\tconstructor( count, instanceMatrix, instanceColor ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.count = count;\n\t\tthis.instanceMatrix = instanceMatrix;\n\t\tthis.instanceColor = instanceColor;\n\n\t\tthis.instanceMatrixNode = null;\n\n\t\tthis.instanceColorNode = null;\n\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t\tthis.buffer = null;\n\t\tthis.bufferColor = null;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { count, instanceMatrix, instanceColor } = this;\n\n\t\tlet { instanceMatrixNode, instanceColorNode } = this;\n\n\t\tif ( instanceMatrixNode === null ) {\n\n\t\t\t// Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.\n\n\t\t\tif ( count <= 1000 ) {\n\n\t\t\t\tinstanceMatrixNode = buffer( instanceMatrix.array, 'mat4', Math.max( count, 1 ) ).element( instanceIndex );\n\n\t\t\t} else {\n\n\t\t\t\tconst buffer = new InstancedInterleavedBuffer( instanceMatrix.array, 16, 1 );\n\n\t\t\t\tthis.buffer = buffer;\n\n\t\t\t\tconst bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n\n\t\t\t\tconst instanceBuffers = [\n\t\t\t\t\t// F.Signature -> bufferAttribute( array, type, stride, offset )\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 0 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 4 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 8 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 12 )\n\t\t\t\t];\n\n\t\t\t\tinstanceMatrixNode = mat4( ...instanceBuffers );\n\n\t\t\t}\n\n\t\t\tthis.instanceMatrixNode = instanceMatrixNode;\n\n\t\t}\n\n\t\tif ( instanceColor && instanceColorNode === null ) {\n\n\t\t\tconst buffer = new InstancedBufferAttribute( instanceColor.array, 3 );\n\n\t\t\tconst bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n\n\t\t\tthis.bufferColor = buffer;\n\n\t\t\tinstanceColorNode = vec3( bufferFn( buffer, 'vec3', 3, 0 ) );\n\n\t\t\tthis.instanceColorNode = instanceColorNode;\n\n\t\t}\n\n\t\t// POSITION\n\n\t\tconst instancePosition = instanceMatrixNode.mul( positionLocal ).xyz;\n\t\tpositionLocal.assign( instancePosition );\n\n\t\t// NORMAL\n\n\t\tif ( builder.hasGeometryAttribute( 'normal' ) ) {\n\n\t\t\tconst instanceNormal = transformNormal( normalLocal, instanceMatrixNode );\n\n\t\t\t// ASSIGNS\n\n\t\t\tnormalLocal.assign( instanceNormal );\n\n\t\t}\n\n\t\t// COLOR\n\n\t\tif ( this.instanceColorNode !== null ) {\n\n\t\t\tvaryingProperty( 'vec3', 'vInstanceColor' ).assign( this.instanceColorNode );\n\n\t\t}\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tif ( this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer != null && this.instanceMatrix.version !== this.buffer.version ) {\n\n\t\t\tthis.buffer.version = this.instanceMatrix.version;\n\n\t\t}\n\n\t\tif ( this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor != null && this.instanceColor.version !== this.bufferColor.version ) {\n\n\t\t\tthis.bufferColor.version = this.instanceColor.version;\n\n\t\t}\n\n\t}\n\n}\n\nconst instance = /*@__PURE__*/ nodeProxy( InstanceNode );\n\nclass InstancedMeshNode extends InstanceNode {\n\n\tstatic get type() {\n\n\t\treturn 'InstancedMeshNode';\n\n\t}\n\n\tconstructor( instanceMesh ) {\n\n\t\tconst { count, instanceMatrix, instanceColor } = instanceMesh;\n\n\t\tsuper( count, instanceMatrix, instanceColor );\n\n\t\tthis.instanceMesh = instanceMesh;\n\n\t}\n\n}\n\nconst instancedMesh = /*@__PURE__*/ nodeProxy( InstancedMeshNode );\n\nclass BatchNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'BatchNode';\n\n\t}\n\n\tconstructor( batchMesh ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.batchMesh = batchMesh;\n\n\n\t\tthis.batchingIdNode = null;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// POSITION\n\n\t\tif ( this.batchingIdNode === null ) {\n\n\t\t\tif ( builder.getDrawIndex() === null ) {\n\n\t\t\t\tthis.batchingIdNode = instanceIndex;\n\n\t\t\t} else {\n\n\t\t\t\tthis.batchingIdNode = drawIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst getIndirectIndex = Fn( ( [ id ] ) => {\n\n\t\t\tconst size = textureSize( textureLoad( this.batchMesh._indirectTexture ), 0 );\n\t\t\tconst x = int( id ).modInt( int( size ) );\n\t\t\tconst y = int( id ).div( int( size ) );\n\t\t\treturn textureLoad( this.batchMesh._indirectTexture, ivec2( x, y ) ).x;\n\n\t\t} ).setLayout( {\n\t\t\tname: 'getIndirectIndex',\n\t\t\ttype: 'uint',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'id', type: 'int' }\n\t\t\t]\n\t\t} );\n\n\t\tconst indirectId = getIndirectIndex( int( this.batchingIdNode ) );\n\n\t\tconst matricesTexture = this.batchMesh._matricesTexture;\n\n\t\tconst size = textureSize( textureLoad( matricesTexture ), 0 );\n\t\tconst j = float( indirectId ).mul( 4 ).toInt().toVar();\n\n\t\tconst x = j.modInt( size );\n\t\tconst y = j.div( int( size ) );\n\t\tconst batchingMatrix = mat4(\n\t\t\ttextureLoad( matricesTexture, ivec2( x, y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 1 ), y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 2 ), y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 3 ), y ) )\n\t\t);\n\n\n\t\tconst colorsTexture = this.batchMesh._colorsTexture;\n\n\t\tif ( colorsTexture !== null ) {\n\n\t\t\tconst getBatchingColor = Fn( ( [ id ] ) => {\n\n\t\t\t\tconst size = textureSize( textureLoad( colorsTexture ), 0 ).x;\n\t\t\t\tconst j = id;\n\t\t\t\tconst x = j.modInt( size );\n\t\t\t\tconst y = j.div( size );\n\t\t\t\treturn textureLoad( colorsTexture, ivec2( x, y ) ).rgb;\n\n\t\t\t} ).setLayout( {\n\t\t\t\tname: 'getBatchingColor',\n\t\t\t\ttype: 'vec3',\n\t\t\t\tinputs: [\n\t\t\t\t\t{ name: 'id', type: 'int' }\n\t\t\t\t]\n\t\t\t} );\n\n\t\t\tconst color = getBatchingColor( indirectId );\n\n\t\t\tvaryingProperty( 'vec3', 'vBatchColor' ).assign( color );\n\n\t\t}\n\n\t\tconst bm = mat3( batchingMatrix );\n\n\t\tpositionLocal.assign( batchingMatrix.mul( positionLocal ) );\n\n\t\tconst transformedNormal = normalLocal.div( vec3( bm[ 0 ].dot( bm[ 0 ] ), bm[ 1 ].dot( bm[ 1 ] ), bm[ 2 ].dot( bm[ 2 ] ) ) );\n\n\t\tconst batchingNormal = bm.mul( transformedNormal ).xyz;\n\n\t\tnormalLocal.assign( batchingNormal );\n\n\t\tif ( builder.hasGeometryAttribute( 'tangent' ) ) {\n\n\t\t\ttangentLocal.mulAssign( bm );\n\n\t\t}\n\n\t}\n\n}\n\nconst batch = /*@__PURE__*/ nodeProxy( BatchNode );\n\nconst _frameId = new WeakMap();\n\nclass SkinningNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SkinningNode';\n\n\t}\n\n\tconstructor( skinnedMesh, useReference = false ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.skinnedMesh = skinnedMesh;\n\t\tthis.useReference = useReference;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t//\n\n\t\tthis.skinIndexNode = attribute( 'skinIndex', 'uvec4' );\n\t\tthis.skinWeightNode = attribute( 'skinWeight', 'vec4' );\n\n\t\tlet bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;\n\n\t\tif ( useReference ) {\n\n\t\t\tbindMatrixNode = reference( 'bindMatrix', 'mat4' );\n\t\t\tbindMatrixInverseNode = reference( 'bindMatrixInverse', 'mat4' );\n\t\t\tboneMatricesNode = referenceBuffer( 'skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t} else {\n\n\t\t\tbindMatrixNode = uniform( skinnedMesh.bindMatrix, 'mat4' );\n\t\t\tbindMatrixInverseNode = uniform( skinnedMesh.bindMatrixInverse, 'mat4' );\n\t\t\tboneMatricesNode = buffer( skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t}\n\n\t\tthis.bindMatrixNode = bindMatrixNode;\n\t\tthis.bindMatrixInverseNode = bindMatrixInverseNode;\n\t\tthis.boneMatricesNode = boneMatricesNode;\n\t\tthis.previousBoneMatricesNode = null;\n\n\t}\n\n\tgetSkinnedPosition( boneMatrices = this.boneMatricesNode, position = positionLocal ) {\n\n\t\tconst { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;\n\n\t\tconst boneMatX = boneMatrices.element( skinIndexNode.x );\n\t\tconst boneMatY = boneMatrices.element( skinIndexNode.y );\n\t\tconst boneMatZ = boneMatrices.element( skinIndexNode.z );\n\t\tconst boneMatW = boneMatrices.element( skinIndexNode.w );\n\n\t\t// POSITION\n\n\t\tconst skinVertex = bindMatrixNode.mul( position );\n\n\t\tconst skinned = add(\n\t\t\tboneMatX.mul( skinWeightNode.x ).mul( skinVertex ),\n\t\t\tboneMatY.mul( skinWeightNode.y ).mul( skinVertex ),\n\t\t\tboneMatZ.mul( skinWeightNode.z ).mul( skinVertex ),\n\t\t\tboneMatW.mul( skinWeightNode.w ).mul( skinVertex )\n\t\t);\n\n\t\treturn bindMatrixInverseNode.mul( skinned ).xyz;\n\n\t}\n\n\tgetSkinnedNormal( boneMatrices = this.boneMatricesNode, normal = normalLocal ) {\n\n\t\tconst { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;\n\n\t\tconst boneMatX = boneMatrices.element( skinIndexNode.x );\n\t\tconst boneMatY = boneMatrices.element( skinIndexNode.y );\n\t\tconst boneMatZ = boneMatrices.element( skinIndexNode.z );\n\t\tconst boneMatW = boneMatrices.element( skinIndexNode.w );\n\n\t\t// NORMAL\n\n\t\tlet skinMatrix = add(\n\t\t\tskinWeightNode.x.mul( boneMatX ),\n\t\t\tskinWeightNode.y.mul( boneMatY ),\n\t\t\tskinWeightNode.z.mul( boneMatZ ),\n\t\t\tskinWeightNode.w.mul( boneMatW )\n\t\t);\n\n\t\tskinMatrix = bindMatrixInverseNode.mul( skinMatrix ).mul( bindMatrixNode );\n\n\t\treturn skinMatrix.transformDirection( normal ).xyz;\n\n\t}\n\n\tgetPreviousSkinnedPosition( builder ) {\n\n\t\tconst skinnedMesh = builder.object;\n\n\t\tif ( this.previousBoneMatricesNode === null ) {\n\n\t\t\tskinnedMesh.skeleton.previousBoneMatrices = new Float32Array( skinnedMesh.skeleton.boneMatrices );\n\n\t\t\tthis.previousBoneMatricesNode = referenceBuffer( 'skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t}\n\n\t\treturn this.getSkinnedPosition( this.previousBoneMatricesNode, positionPrevious );\n\n\t}\n\n\tneedsPreviousBoneMatrices( builder ) {\n\n\t\tconst mrt = builder.renderer.getMRT();\n\n\t\treturn mrt && mrt.has( 'velocity' );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( this.needsPreviousBoneMatrices( builder ) ) {\n\n\t\t\tpositionPrevious.assign( this.getPreviousSkinnedPosition( builder ) );\n\n\t\t}\n\n\t\tconst skinPosition = this.getSkinnedPosition();\n\n\n\t\tpositionLocal.assign( skinPosition );\n\n\t\tif ( builder.hasGeometryAttribute( 'normal' ) ) {\n\n\t\t\tconst skinNormal = this.getSkinnedNormal();\n\n\t\t\tnormalLocal.assign( skinNormal );\n\n\t\t\tif ( builder.hasGeometryAttribute( 'tangent' ) ) {\n\n\t\t\t\ttangentLocal.assign( skinNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\treturn positionLocal.build( builder, output );\n\n\t\t}\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst object = this.useReference ? frame.object : this.skinnedMesh;\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( _frameId.get( skeleton ) === frame.frameId ) return;\n\n\t\t_frameId.set( skeleton, frame.frameId );\n\n\t\tif ( this.previousBoneMatricesNode !== null ) skeleton.previousBoneMatrices.set( skeleton.boneMatrices );\n\n\t\tskeleton.update();\n\n\t}\n\n}\n\nconst skinning = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh ) );\nconst skinningReference = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh, true ) );\n\nclass LoopNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LoopNode';\n\n\t}\n\n\tconstructor( params = [] ) {\n\n\t\tsuper();\n\n\t\tthis.params = params;\n\n\t}\n\n\tgetVarName( index ) {\n\n\t\treturn String.fromCharCode( 'i'.charCodeAt() + index );\n\n\t}\n\n\tgetProperties( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.stackNode !== undefined ) return properties;\n\n\t\t//\n\n\t\tconst inputs = {};\n\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\n\n\t\t\tconst param = this.params[ i ];\n\n\t\t\tconst name = ( param.isNode !== true && param.name ) || this.getVarName( i );\n\t\t\tconst type = ( param.isNode !== true && param.type ) || 'int';\n\n\t\t\tinputs[ name ] = expression( name, type );\n\n\t\t}\n\n\t\tconst stack = builder.addStack(); // TODO: cache() it\n\n\t\tproperties.returnsNode = this.params[ this.params.length - 1 ]( inputs, stack, builder );\n\t\tproperties.stackNode = stack;\n\n\t\tbuilder.removeStack();\n\n\t\treturn properties;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst { returnsNode } = this.getProperties( builder );\n\n\t\treturn returnsNode ? returnsNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// setup properties\n\n\t\tthis.getProperties( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst properties = this.getProperties( builder );\n\n\t\tconst params = this.params;\n\t\tconst stackNode = properties.stackNode;\n\n\t\tfor ( let i = 0, l = params.length - 1; i < l; i ++ ) {\n\n\t\t\tconst param = params[ i ];\n\n\t\t\tlet start = null, end = null, name = null, type = null, condition = null, update = null;\n\n\t\t\tif ( param.isNode ) {\n\n\t\t\t\ttype = 'int';\n\t\t\t\tname = this.getVarName( i );\n\t\t\t\tstart = '0';\n\t\t\t\tend = param.build( builder, type );\n\t\t\t\tcondition = '<';\n\n\t\t\t} else {\n\n\t\t\t\ttype = param.type || 'int';\n\t\t\t\tname = param.name || this.getVarName( i );\n\t\t\t\tstart = param.start;\n\t\t\t\tend = param.end;\n\t\t\t\tcondition = param.condition;\n\t\t\t\tupdate = param.update;\n\n\t\t\t\tif ( typeof start === 'number' ) start = builder.generateConst( type, start );\n\t\t\t\telse if ( start && start.isNode ) start = start.build( builder, type );\n\n\t\t\t\tif ( typeof end === 'number' ) end = builder.generateConst( type, end );\n\t\t\t\telse if ( end && end.isNode ) end = end.build( builder, type );\n\n\t\t\t\tif ( start !== undefined && end === undefined ) {\n\n\t\t\t\t\tstart = start + ' - 1';\n\t\t\t\t\tend = '0';\n\t\t\t\t\tcondition = '>=';\n\n\t\t\t\t} else if ( end !== undefined && start === undefined ) {\n\n\t\t\t\t\tstart = '0';\n\t\t\t\t\tcondition = '<';\n\n\t\t\t\t}\n\n\t\t\t\tif ( condition === undefined ) {\n\n\t\t\t\t\tif ( Number( start ) > Number( end ) ) {\n\n\t\t\t\t\t\tcondition = '>=';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcondition = '<';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst internalParam = { start, end, condition };\n\n\t\t\t//\n\n\t\t\tconst startSnippet = internalParam.start;\n\t\t\tconst endSnippet = internalParam.end;\n\n\t\t\tlet declarationSnippet = '';\n\t\t\tlet conditionalSnippet = '';\n\t\t\tlet updateSnippet = '';\n\n\t\t\tif ( ! update ) {\n\n\t\t\t\tif ( type === 'int' || type === 'uint' ) {\n\n\t\t\t\t\tif ( condition.includes( '<' ) ) update = '++';\n\t\t\t\t\telse update = '--';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( condition.includes( '<' ) ) update = '+= 1.';\n\t\t\t\t\telse update = '-= 1.';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdeclarationSnippet += builder.getVar( type, name ) + ' = ' + startSnippet;\n\n\t\t\tconditionalSnippet += name + ' ' + condition + ' ' + endSnippet;\n\t\t\tupdateSnippet += name + ' ' + update;\n\n\t\t\tconst forSnippet = `for ( ${ declarationSnippet }; ${ conditionalSnippet }; ${ updateSnippet } )`;\n\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '\\n' : '' ) + builder.tab + forSnippet + ' {\\n\\n' ).addFlowTab();\n\n\t\t}\n\n\t\tconst stackSnippet = stackNode.build( builder, 'void' );\n\n\t\tconst returnsSnippet = properties.returnsNode ? properties.returnsNode.build( builder ) : '';\n\n\t\tbuilder.removeFlowTab().addFlowCode( '\\n' + builder.tab + stackSnippet );\n\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\n\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '' : builder.tab ) + '}\\n\\n' ).removeFlowTab();\n\n\t\t}\n\n\t\tbuilder.addFlowTab();\n\n\t\treturn returnsSnippet;\n\n\t}\n\n}\n\nconst Loop = ( ...params ) => nodeObject( new LoopNode( nodeArray( params, 'int' ) ) ).append();\nconst Continue = () => expression( 'continue' ).append();\nconst Break = () => expression( 'break' ).append();\n\n//\n\nconst loop = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.LoopNode: loop() has been renamed to Loop().' );\n\treturn Loop( ...params );\n\n};\n\nconst _morphTextures = /*@__PURE__*/ new WeakMap();\nconst _morphVec4 = /*@__PURE__*/ new Vector4();\n\nconst getMorph = /*@__PURE__*/ Fn( ( { bufferMap, influence, stride, width, depth, offset } ) => {\n\n\tconst texelIndex = int( vertexIndex ).mul( stride ).add( offset );\n\n\tconst y = texelIndex.div( width );\n\tconst x = texelIndex.sub( y.mul( width ) );\n\n\tconst bufferAttrib = textureLoad( bufferMap, ivec2( x, y ) ).depth( depth );\n\n\treturn bufferAttrib.mul( influence );\n\n} );\n\nfunction getEntry( geometry ) {\n\n\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\tconst hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n\t// instead of using attributes, the WebGL 2 code path encodes morph targets\n\t// into an array of data textures. Each layer represents a single morph target.\n\n\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\tlet entry = _morphTextures.get( geometry );\n\n\tif ( entry === undefined || entry.count !== morphTargetsCount ) {\n\n\t\tif ( entry !== undefined ) entry.texture.dispose();\n\n\t\tconst morphTargets = geometry.morphAttributes.position || [];\n\t\tconst morphNormals = geometry.morphAttributes.normal || [];\n\t\tconst morphColors = geometry.morphAttributes.color || [];\n\n\t\tlet vertexDataCount = 0;\n\n\t\tif ( hasMorphPosition === true ) vertexDataCount = 1;\n\t\tif ( hasMorphNormals === true ) vertexDataCount = 2;\n\t\tif ( hasMorphColors === true ) vertexDataCount = 3;\n\n\t\tlet width = geometry.attributes.position.count * vertexDataCount;\n\t\tlet height = 1;\n\n\t\tconst maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'\n\n\t\tif ( width > maxTextureSize ) {\n\n\t\t\theight = Math.ceil( width / maxTextureSize );\n\t\t\twidth = maxTextureSize;\n\n\t\t}\n\n\t\tconst buffer = new Float32Array( width * height * 4 * morphTargetsCount );\n\n\t\tconst bufferTexture = new DataArrayTexture( buffer, width, height, morphTargetsCount );\n\t\tbufferTexture.type = FloatType;\n\t\tbufferTexture.needsUpdate = true;\n\n\t\t// fill buffer\n\n\t\tconst vertexDataStride = vertexDataCount * 4;\n\n\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst morphNormal = morphNormals[ i ];\n\t\t\tconst morphColor = morphColors[ i ];\n\n\t\t\tconst offset = width * height * 4 * i;\n\n\t\t\tfor ( let j = 0; j < morphTarget.count; j ++ ) {\n\n\t\t\t\tconst stride = j * vertexDataStride;\n\n\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphTarget, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 0 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 1 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 2 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 3 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphNormal, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 4 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 5 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 6 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 7 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphColors === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphColor, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 8 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 9 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 10 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? _morphVec4.w : 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tentry = {\n\t\t\tcount: morphTargetsCount,\n\t\t\ttexture: bufferTexture,\n\t\t\tstride: vertexDataCount,\n\t\t\tsize: new Vector2( width, height )\n\t\t};\n\n\t\t_morphTextures.set( geometry, entry );\n\n\t\tfunction disposeTexture() {\n\n\t\t\tbufferTexture.dispose();\n\n\t\t\t_morphTextures.delete( geometry );\n\n\t\t\tgeometry.removeEventListener( 'dispose', disposeTexture );\n\n\t\t}\n\n\t\tgeometry.addEventListener( 'dispose', disposeTexture );\n\n\t}\n\n\treturn entry;\n\n}\n\n\nclass MorphNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MorphNode';\n\n\t}\n\n\tconstructor( mesh ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.mesh = mesh;\n\t\tthis.morphBaseInfluence = uniform( 1 );\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { geometry } = builder;\n\n\t\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\t\tconst hasMorphNormals = geometry.hasAttribute( 'normal' ) && geometry.morphAttributes.normal !== undefined;\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t// nodes\n\n\t\tconst { texture: bufferMap, stride, size } = getEntry( geometry );\n\n\t\tif ( hasMorphPosition === true ) positionLocal.mulAssign( this.morphBaseInfluence );\n\t\tif ( hasMorphNormals === true ) normalLocal.mulAssign( this.morphBaseInfluence );\n\n\t\tconst width = int( size.width );\n\n\t\tLoop( morphTargetsCount, ( { i } ) => {\n\n\t\t\tconst influence = float( 0 ).toVar();\n\n\t\t\tif ( this.mesh.count > 1 && ( this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined ) ) {\n\n\t\t\t\tinfluence.assign( textureLoad( this.mesh.morphTexture, ivec2( int( i ).add( 1 ), int( instanceIndex ) ) ).r );\n\n\t\t\t} else {\n\n\t\t\t\tinfluence.assign( reference( 'morphTargetInfluences', 'float' ).element( i ).toVar() );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\tpositionLocal.addAssign( getMorph( {\n\t\t\t\t\tbufferMap,\n\t\t\t\t\tinfluence,\n\t\t\t\t\tstride,\n\t\t\t\t\twidth,\n\t\t\t\t\tdepth: i,\n\t\t\t\t\toffset: int( 0 )\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\tnormalLocal.addAssign( getMorph( {\n\t\t\t\t\tbufferMap,\n\t\t\t\t\tinfluence,\n\t\t\t\t\tstride,\n\t\t\t\t\twidth,\n\t\t\t\t\tdepth: i,\n\t\t\t\t\toffset: int( 1 )\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tupdate() {\n\n\t\tconst morphBaseInfluence = this.morphBaseInfluence;\n\n\t\tif ( this.mesh.geometry.morphTargetsRelative ) {\n\n\t\t\tmorphBaseInfluence.value = 1;\n\n\t\t} else {\n\n\t\t\tmorphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce( ( a, b ) => a + b, 0 );\n\n\t\t}\n\n\t}\n\n}\n\nconst morphReference = /*@__PURE__*/ nodeProxy( MorphNode );\n\nclass LightingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LightingNode';\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.isLightingNode = true;\n\n\t}\n\n\tgenerate( /*builder*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nclass AONode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'AONode';\n\n\t}\n\n\tconstructor( aoNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.aoNode = aoNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.ambientOcclusion.mulAssign( this.aoNode );\n\n\t}\n\n}\n\nclass LightingContextNode extends ContextNode {\n\n\tstatic get type() {\n\n\t\treturn 'LightingContextNode';\n\n\t}\n\n\tconstructor( node, lightingModel = null, backdropNode = null, backdropAlphaNode = null ) {\n\n\t\tsuper( node );\n\n\t\tthis.lightingModel = lightingModel;\n\t\tthis.backdropNode = backdropNode;\n\t\tthis.backdropAlphaNode = backdropAlphaNode;\n\n\t\tthis._value = null;\n\n\t}\n\n\tgetContext() {\n\n\t\tconst { backdropNode, backdropAlphaNode } = this;\n\n\t\tconst directDiffuse = vec3().toVar( 'directDiffuse' ),\n\t\t\tdirectSpecular = vec3().toVar( 'directSpecular' ),\n\t\t\tindirectDiffuse = vec3().toVar( 'indirectDiffuse' ),\n\t\t\tindirectSpecular = vec3().toVar( 'indirectSpecular' );\n\n\t\tconst reflectedLight = {\n\t\t\tdirectDiffuse,\n\t\t\tdirectSpecular,\n\t\t\tindirectDiffuse,\n\t\t\tindirectSpecular\n\t\t};\n\n\t\tconst context = {\n\t\t\tradiance: vec3().toVar( 'radiance' ),\n\t\t\tirradiance: vec3().toVar( 'irradiance' ),\n\t\t\tiblIrradiance: vec3().toVar( 'iblIrradiance' ),\n\t\t\tambientOcclusion: float( 1 ).toVar( 'ambientOcclusion' ),\n\t\t\treflectedLight,\n\t\t\tbackdrop: backdropNode,\n\t\t\tbackdropAlpha: backdropAlphaNode\n\t\t};\n\n\t\treturn context;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.value = this._value || ( this._value = this.getContext() );\n\t\tthis.value.lightingModel = this.lightingModel || builder.context.lightingModel;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n}\n\nconst lightingContext = /*@__PURE__*/ nodeProxy( LightingContextNode );\n\nclass IrradianceNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'IrradianceNode';\n\n\t}\n\n\tconstructor( node ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.irradiance.addAssign( this.node );\n\n\t}\n\n}\n\nlet screenSizeVec, viewportVec;\n\nclass ScreenNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScreenNode';\n\n\t}\n\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t\tthis.isViewportNode = true;\n\n\t}\n\n\tgetNodeType() {\n\n\t\tif ( this.scope === ScreenNode.VIEWPORT ) return 'vec4';\n\t\telse return 'vec2';\n\n\t}\n\n\tgetUpdateType() {\n\n\t\tlet updateType = NodeUpdateType.NONE;\n\n\t\tif ( this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT ) {\n\n\t\t\tupdateType = NodeUpdateType.RENDER;\n\n\t\t}\n\n\t\tthis.updateType = updateType;\n\n\t\treturn updateType;\n\n\t}\n\n\tupdate( { renderer } ) {\n\n\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\tif ( this.scope === ScreenNode.VIEWPORT ) {\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tviewportVec.copy( renderTarget.viewport );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.getViewport( viewportVec );\n\n\t\t\t\tviewportVec.multiplyScalar( renderer.getPixelRatio() );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tscreenSizeVec.width = renderTarget.width;\n\t\t\t\tscreenSizeVec.height = renderTarget.height;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.getDrawingBufferSize( screenSizeVec );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( /*builder*/ ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet output = null;\n\n\t\tif ( scope === ScreenNode.SIZE ) {\n\n\t\t\toutput = uniform( screenSizeVec || ( screenSizeVec = new Vector2() ) );\n\n\t\t} else if ( scope === ScreenNode.VIEWPORT ) {\n\n\t\t\toutput = uniform( viewportVec || ( viewportVec = new Vector4() ) );\n\n\t\t} else {\n\n\t\t\toutput = vec2( screenCoordinate.div( screenSize ) );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tif ( this.scope === ScreenNode.COORDINATE ) {\n\n\t\t\tlet coord = builder.getFragCoord();\n\n\t\t\tif ( builder.isFlipY() ) {\n\n\t\t\t\t// follow webgpu standards\n\n\t\t\t\tconst size = builder.getNodeProperties( screenSize ).outputNode.build( builder );\n\n\t\t\t\tcoord = `${ builder.getType( 'vec2' ) }( ${ coord }.x, ${ size }.y - ${ coord }.y )`;\n\n\t\t\t}\n\n\t\t\treturn coord;\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n}\n\nScreenNode.COORDINATE = 'coordinate';\nScreenNode.VIEWPORT = 'viewport';\nScreenNode.SIZE = 'size';\nScreenNode.UV = 'uv';\n\n// Screen\n\nconst screenUV = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.UV );\nconst screenSize = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.SIZE );\nconst screenCoordinate = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.COORDINATE );\n\n// Viewport\n\nconst viewport = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.VIEWPORT );\nconst viewportSize = viewport.zw;\nconst viewportCoordinate = /*@__PURE__*/ screenCoordinate.sub( viewport.xy );\nconst viewportUV = /*@__PURE__*/ viewportCoordinate.div( viewportSize );\n\n// Deprecated\n\nconst viewportResolution = /*@__PURE__*/ ( Fn( () => { // @deprecated, r169\n\n\tconsole.warn( 'TSL.ViewportNode: \"viewportResolution\" is deprecated. Use \"screenSize\" instead.' );\n\n\treturn screenSize;\n\n}, 'vec2' ).once() )();\n\nconst viewportTopLeft = /*@__PURE__*/ ( Fn( () => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ViewportNode: \"viewportTopLeft\" is deprecated. Use \"screenUV\" instead.' );\n\n\treturn screenUV;\n\n}, 'vec2' ).once() )();\n\nconst viewportBottomLeft = /*@__PURE__*/ ( Fn( () => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ViewportNode: \"viewportBottomLeft\" is deprecated. Use \"screenUV.flipY()\" instead.' );\n\n\treturn screenUV.flipY();\n\n}, 'vec2' ).once() )();\n\nconst _size$4 = /*@__PURE__*/ new Vector2();\n\nclass ViewportTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportTextureNode';\n\n\t}\n\n\tconstructor( uvNode = screenUV, levelNode = null, framebufferTexture = null ) {\n\n\t\tif ( framebufferTexture === null ) {\n\n\t\t\tframebufferTexture = new FramebufferTexture();\n\t\t\tframebufferTexture.minFilter = LinearMipmapLinearFilter;\n\n\t\t}\n\n\t\tsuper( framebufferTexture, uvNode, levelNode );\n\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.isOutputTextureNode = true;\n\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst renderer = frame.renderer;\n\t\trenderer.getDrawingBufferSize( _size$4 );\n\n\t\t//\n\n\t\tconst framebufferTexture = this.value;\n\n\t\tif ( framebufferTexture.image.width !== _size$4.width || framebufferTexture.image.height !== _size$4.height ) {\n\n\t\t\tframebufferTexture.image.width = _size$4.width;\n\t\t\tframebufferTexture.image.height = _size$4.height;\n\t\t\tframebufferTexture.needsUpdate = true;\n\n\t\t}\n\n\t\t//\n\n\t\tconst currentGenerateMipmaps = framebufferTexture.generateMipmaps;\n\t\tframebufferTexture.generateMipmaps = this.generateMipmaps;\n\n\t\trenderer.copyFramebufferToTexture( framebufferTexture );\n\n\t\tframebufferTexture.generateMipmaps = currentGenerateMipmaps;\n\n\t}\n\n\tclone() {\n\n\t\tconst viewportTextureNode = new this.constructor( this.uvNode, this.levelNode, this.value );\n\t\tviewportTextureNode.generateMipmaps = this.generateMipmaps;\n\n\t\treturn viewportTextureNode;\n\n\t}\n\n}\n\nconst viewportTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode );\nconst viewportMipTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode, null, null, { generateMipmaps: true } );\n\nlet sharedDepthbuffer = null;\n\nclass ViewportDepthTextureNode extends ViewportTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportDepthTextureNode';\n\n\t}\n\n\tconstructor( uvNode = screenUV, levelNode = null ) {\n\n\t\tif ( sharedDepthbuffer === null ) {\n\n\t\t\tsharedDepthbuffer = new DepthTexture();\n\n\t\t}\n\n\t\tsuper( uvNode, levelNode, sharedDepthbuffer );\n\n\t}\n\n}\n\nconst viewportDepthTexture = /*@__PURE__*/ nodeProxy( ViewportDepthTextureNode );\n\nclass ViewportDepthNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportDepthNode';\n\n\t}\n\n\tconstructor( scope, valueNode = null ) {\n\n\t\tsuper( 'float' );\n\n\t\tthis.scope = scope;\n\t\tthis.valueNode = valueNode;\n\n\t\tthis.isViewportDepthNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { scope } = this;\n\n\t\tif ( scope === ViewportDepthNode.DEPTH_BASE ) {\n\n\t\t\treturn builder.getFragDepth();\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n\tsetup( { camera } ) {\n\n\t\tconst { scope } = this;\n\t\tconst value = this.valueNode;\n\n\t\tlet node = null;\n\n\t\tif ( scope === ViewportDepthNode.DEPTH_BASE ) {\n\n\t\t\tif ( value !== null ) {\n\n \t\t\t\tnode = depthBase().assign( value );\n\n\t\t\t}\n\n\t\t} else if ( scope === ViewportDepthNode.DEPTH ) {\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tnode = viewZToPerspectiveDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t} else {\n\n\t\t\t\tnode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t}\n\n\t\t} else if ( scope === ViewportDepthNode.LINEAR_DEPTH ) {\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tconst viewZ = perspectiveDepthToViewZ( value, cameraNear, cameraFar );\n\n\t\t\t\t\tnode = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode = value;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tnode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nViewportDepthNode.DEPTH_BASE = 'depthBase';\nViewportDepthNode.DEPTH = 'depth';\nViewportDepthNode.LINEAR_DEPTH = 'linearDepth';\n\n// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera\n\n// -near maps to 0; -far maps to 1\nconst viewZToOrthographicDepth = ( viewZ, near, far ) => viewZ.add( near ).div( near.sub( far ) );\n\n// maps orthographic depth in [ 0, 1 ] to viewZ\nconst orthographicDepthToViewZ = ( depth, near, far ) => near.sub( far ).mul( depth ).sub( near );\n\n// NOTE: https://twitter.com/gonnavis/status/1377183786949959682\n\n// -near maps to 0; -far maps to 1\nconst viewZToPerspectiveDepth = ( viewZ, near, far ) => near.add( viewZ ).mul( far ).div( far.sub( near ).mul( viewZ ) );\n\n// maps perspective depth in [ 0, 1 ] to viewZ\nconst perspectiveDepthToViewZ = ( depth, near, far ) => near.mul( far ).div( far.sub( near ).mul( depth ).sub( far ) );\n\n// -near maps to 0; -far maps to 1\nconst viewZToLogarithmicDepth = ( viewZ, near, far ) => {\n\n\t// NOTE: viewZ must be negative--see explanation at the end of this comment block.\n\t// The final logarithmic depth formula used here is adapted from one described in an\n\t// article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),\n\t// which was an improvement upon an earlier formula one described in an\n\t// Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).\n\t// Ulrich's formula is the following:\n\t//     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )\n\t//     where K = 2^k - 1, and k is the number of bits in the depth buffer.\n\t// The Outerra variant ignored the camera near plane (it assumed it was 0) and instead\n\t// opted for a \"C-constant\" for resolution adjustment of objects near the camera.\n\t// Outerra states: \"Notice that the 'C' variant doesnt use a near plane distance, it has it\n\t// set at 0\" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).\n\t// Ulrich's variant has the benefit of constant relative precision over the whole near-far range.\n\t// It was debated here whether Outerra's \"C-constant\" or Ulrich's \"near plane\" variant should\n\t// be used, and ultimately Ulrich's \"near plane\" version was chosen.\n\t// Outerra eventually made another improvement to their original \"C-constant\" variant,\n\t// but it still does not incorporate the camera near plane (for this version,\n\t// see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).\n\t// Here we make 4 changes to Ulrich's formula:\n\t// 1. Clamp the camera near plane so we don't divide by 0.\n\t// 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).\n\t// 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).\n\t// 4. To maintain consistency with the functions \"viewZToOrthographicDepth\" and \"viewZToPerspectiveDepth\",\n\t//    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,\n\t//    so we do the same here, hence the 'viewZ.negate()' call.\n\t// For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u\n\tnear = near.max( 1e-6 ).toVar();\n\tconst numerator = log2( viewZ.negate().div( near ) );\n\tconst denominator = log2( far.div( near ) );\n\treturn numerator.div( denominator );\n\n};\n\n// maps logarithmic depth in [ 0, 1 ] to viewZ\nconst logarithmicDepthToViewZ = ( depth, near, far ) => {\n\n\t// NOTE: we add a 'negate()' call to the return value here to maintain consistency with\n\t// the functions \"orthographicDepthToViewZ\" and \"perspectiveDepthToViewZ\" (they return\n\t// a negative viewZ).\n\tconst exponent = depth.mul( log( far.div( near ) ) );\n\treturn float( Math.E ).pow( exponent ).mul( near ).negate();\n\n};\n\nconst depthBase = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.DEPTH_BASE );\n\nconst depth = /*@__PURE__*/ nodeImmutable( ViewportDepthNode, ViewportDepthNode.DEPTH );\nconst linearDepth = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH );\nconst viewportLinearDepth = /*@__PURE__*/ linearDepth( viewportDepthTexture() );\n\ndepth.assign = ( value ) => depthBase( value );\n\nclass BuiltinNode extends Node {\n\n\tconstructor( name ) {\n\n\t\tsuper( 'float' );\n\n\t\tthis.name = name;\n\n\t\tthis.isBuiltinNode = true;\n\n\t}\n\n\tgenerate( /* builder */ ) {\n\n\t\treturn this.name;\n\n\t}\n\n}\n\nconst builtin = nodeProxy( BuiltinNode );\n\nclass ClippingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ClippingNode';\n\n\t}\n\n\tconstructor( scope = ClippingNode.DEFAULT ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst clippingContext = builder.clippingContext;\n\t\tconst { intersectionPlanes, unionPlanes } = clippingContext;\n\n\t\tthis.hardwareClipping = builder.material.hardwareClipping;\n\n\t\tif ( this.scope === ClippingNode.ALPHA_TO_COVERAGE ) {\n\n\t\t\treturn this.setupAlphaToCoverage( intersectionPlanes, unionPlanes );\n\n\t\t} else if ( this.scope === ClippingNode.HARDWARE ) {\n\n\t\t\treturn this.setupHardwareClipping( unionPlanes, builder );\n\n\t\t} else {\n\n\t\t\treturn this.setupDefault( intersectionPlanes, unionPlanes );\n\n\t\t}\n\n\t}\n\n\tsetupAlphaToCoverage( intersectionPlanes, unionPlanes ) {\n\n\t\treturn Fn( () => {\n\n\t\t\tconst distanceToPlane = float().toVar( 'distanceToPlane' );\n\t\t\tconst distanceGradient = float().toVar( 'distanceToGradient' );\n\n\t\t\tconst clipOpacity = float( 1 ).toVar( 'clipOpacity' );\n\n\t\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\t\tif ( ! this.hardwareClipping && numUnionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( unionPlanes );\n\n\t\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\t\tdistanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );\n\t\t\t\t\tdistanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );\n\n\t\t\t\t\tclipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ) );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst numIntersectionPlanes = intersectionPlanes.length;\n\n\t\t\tif ( numIntersectionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( intersectionPlanes );\n\t\t\t\tconst intersectionClipOpacity = float( 1 ).toVar( 'intersectionClipOpacity' );\n\n\t\t\t\tLoop( numIntersectionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\t\tdistanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );\n\t\t\t\t\tdistanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );\n\n\t\t\t\t\tintersectionClipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ).oneMinus() );\n\n\t\t\t\t} );\n\n\t\t\t\tclipOpacity.mulAssign( intersectionClipOpacity.oneMinus() );\n\n\t\t\t}\n\n\t\t\tdiffuseColor.a.mulAssign( clipOpacity );\n\n\t\t\tdiffuseColor.a.equal( 0.0 ).discard();\n\n\t\t} )();\n\n\t}\n\n\tsetupDefault( intersectionPlanes, unionPlanes ) {\n\n\t\treturn Fn( () => {\n\n\t\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\t\tif ( ! this.hardwareClipping && numUnionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( unionPlanes );\n\n\t\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\t\t\t\t\tpositionView.dot( plane.xyz ).greaterThan( plane.w ).discard();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst numIntersectionPlanes = intersectionPlanes.length;\n\n\t\t\tif ( numIntersectionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( intersectionPlanes );\n\t\t\t\tconst clipped = bool( true ).toVar( 'clipped' );\n\n\t\t\t\tLoop( numIntersectionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\t\t\t\t\tclipped.assign( positionView.dot( plane.xyz ).greaterThan( plane.w ).and( clipped ) );\n\n\t\t\t\t} );\n\n\t\t\t\tclipped.discard();\n\n\t\t\t}\n\n\t\t} )();\n\n\t}\n\n\tsetupHardwareClipping( unionPlanes, builder ) {\n\n\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\tbuilder.enableHardwareClipping( numUnionPlanes );\n\n\t\treturn Fn( () => {\n\n\t\t\tconst clippingPlanes = uniformArray( unionPlanes );\n\t\t\tconst hw_clip_distances = builtin( builder.getClipDistance() );\n\n\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\tconst distance = positionView.dot( plane.xyz ).sub( plane.w ).negate();\n\t\t\t\thw_clip_distances.element( i ).assign( distance );\n\n\t\t\t} );\n\n\t\t} )();\n\n\t}\n\n}\n\nClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';\nClippingNode.DEFAULT = 'default';\nClippingNode.HARDWARE = 'hardware';\n\nconst clipping = () => nodeObject( new ClippingNode() );\nconst clippingAlpha = () => nodeObject( new ClippingNode( ClippingNode.ALPHA_TO_COVERAGE ) );\nconst hardwareClipping = () => nodeObject( new ClippingNode( ClippingNode.HARDWARE ) );\n\n/**\n * See: https://casual-effects.com/research/Wyman2017Hashed/index.html\n */\n\nconst ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.\n\nconst hash2D = /*@__PURE__*/ Fn( ( [ value ] ) => {\n\n\treturn fract( mul( 1.0e4, sin( mul( 17.0, value.x ).add( mul( 0.1, value.y ) ) ) ).mul( add( 0.1, abs( sin( mul( 13.0, value.y ).add( value.x ) ) ) ) ) );\n\n} );\n\nconst hash3D = /*@__PURE__*/ Fn( ( [ value ] ) => {\n\n\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\n} );\n\nconst getAlphaHashThreshold = /*@__PURE__*/ Fn( ( [ position ] ) => {\n\n\t// Find the discretized derivatives of our coordinates\n\tconst maxDeriv = max$1(\n\t\tlength( dFdx( position.xyz ) ),\n\t\tlength( dFdy( position.xyz ) )\n\t);\n\n\tconst pixScale = float( 1 ).div( float( ALPHA_HASH_SCALE ).mul( maxDeriv ) ).toVar( 'pixScale' );\n\n\t// Find two nearest log-discretized noise scales\n\tconst pixScales = vec2(\n\t\texp2( floor( log2( pixScale ) ) ),\n\t\texp2( ceil( log2( pixScale ) ) )\n\t);\n\n\t// Compute alpha thresholds at our two noise scales\n\tconst alpha = vec2(\n\t\thash3D( floor( pixScales.x.mul( position.xyz ) ) ),\n\t\thash3D( floor( pixScales.y.mul( position.xyz ) ) ),\n\t);\n\n\t// Factor to interpolate lerp with\n\tconst lerpFactor = fract( log2( pixScale ) );\n\n\t// Interpolate alpha threshold from noise at two scales\n\tconst x = add( mul( lerpFactor.oneMinus(), alpha.x ), mul( lerpFactor, alpha.y ) );\n\n\t// Pass into CDF to compute uniformly distrib threshold\n\tconst a = min$1( lerpFactor, lerpFactor.oneMinus() );\n\tconst cases = vec3(\n\t\tx.mul( x ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ),\n\t\tx.sub( mul( 0.5, a ) ).div( sub( 1.0, a ) ),\n\t\tsub( 1.0, sub( 1.0, x ).mul( sub( 1.0, x ) ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ) ) );\n\n\t// Find our final, uniformly distributed alpha threshold ()\n\tconst threshold = x.lessThan( a.oneMinus() ).select( x.lessThan( a ).select( cases.x, cases.y ), cases.z );\n\n\t// Avoids  == 0. Could also do  =1-\n\treturn clamp( threshold, 1.0e-6, 1.0 );\n\n} ).setLayout( {\n\tname: 'getAlphaHashThreshold',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'position', type: 'vec3' }\n\t]\n} );\n\nclass NodeMaterial extends Material {\n\n\tstatic get type() {\n\n\t\treturn 'NodeMaterial';\n\n\t}\n\n\tget type() {\n\n\t\treturn this.constructor.type;\n\n\t}\n\n\tset type( _value ) { /* */ }\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isNodeMaterial = true;\n\n\t\tthis.forceSinglePass = false;\n\n\t\tthis.fog = true;\n\t\tthis.lights = false;\n\t\tthis.hardwareClipping = false;\n\n\t\tthis.lightsNode = null;\n\t\tthis.envNode = null;\n\t\tthis.aoNode = null;\n\n\t\tthis.colorNode = null;\n\t\tthis.normalNode = null;\n\t\tthis.opacityNode = null;\n\t\tthis.backdropNode = null;\n\t\tthis.backdropAlphaNode = null;\n\t\tthis.alphaTestNode = null;\n\n\t\tthis.positionNode = null;\n\t\tthis.geometryNode = null;\n\n\t\tthis.depthNode = null;\n\t\tthis.shadowPositionNode = null;\n\t\tthis.receivedShadowNode = null;\n\t\tthis.castShadowNode = null;\n\n\t\tthis.outputNode = null;\n\t\tthis.mrtNode = null;\n\n\t\tthis.fragmentNode = null;\n\t\tthis.vertexNode = null;\n\n\t}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this.type + getCacheKey$1( this );\n\n\t}\n\n\tbuild( builder ) {\n\n\t\tthis.setup( builder );\n\n\t}\n\n\tsetupObserver( builder ) {\n\n\t\treturn new NodeMaterialObserver( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.setupNormal = () => this.setupNormal( builder );\n\n\t\tconst renderer = builder.renderer;\n\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\t// < VERTEX STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tbuilder.stack.outputNode = this.vertexNode || this.setupPosition( builder );\n\n\t\tif ( this.geometryNode !== null ) {\n\n\t\t\tbuilder.stack.outputNode = builder.stack.outputNode.bypass( this.geometryNode );\n\n\t\t}\n\n\t\tbuilder.addFlow( 'vertex', builder.removeStack() );\n\n\t\t// < FRAGMENT STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tlet resultNode;\n\n\t\tconst clippingNode = this.setupClipping( builder );\n\n\t\tif ( this.depthWrite === true ) {\n\n\t\t\t// only write depth if depth buffer is configured\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tif ( renderTarget.depthBuffer === true ) this.setupDepth( builder );\n\n\t\t\t} else {\n\n\t\t\t\tif ( renderer.depth === true ) this.setupDepth( builder );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.fragmentNode === null ) {\n\n\t\t\tthis.setupDiffuseColor( builder );\n\t\t\tthis.setupVariants( builder );\n\n\t\t\tconst outgoingLightNode = this.setupLighting( builder );\n\n\t\t\tif ( clippingNode !== null ) builder.stack.add( clippingNode );\n\n\t\t\t// force unsigned floats - useful for RenderTargets\n\n\t\t\tconst basicOutput = vec4( outgoingLightNode, diffuseColor.a ).max( 0 );\n\n\t\t\tresultNode = this.setupOutput( builder, basicOutput );\n\n\t\t\t// OUTPUT NODE\n\n\t\t\toutput.assign( resultNode );\n\n\t\t\t//\n\n\t\t\tif ( this.outputNode !== null ) resultNode = this.outputNode;\n\n\t\t\t// MRT\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tconst mrt = renderer.getMRT();\n\t\t\t\tconst materialMRT = this.mrtNode;\n\n\t\t\t\tif ( mrt !== null ) {\n\n\t\t\t\t\tresultNode = mrt;\n\n\t\t\t\t\tif ( materialMRT !== null ) {\n\n\t\t\t\t\t\tresultNode = mrt.merge( materialMRT );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialMRT !== null ) {\n\n\t\t\t\t\tresultNode = materialMRT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tlet fragmentNode = this.fragmentNode;\n\n\t\t\tif ( fragmentNode.isOutputStructNode !== true ) {\n\n\t\t\t\tfragmentNode = vec4( fragmentNode );\n\n\t\t\t}\n\n\t\t\tresultNode = this.setupOutput( builder, fragmentNode );\n\n\t\t}\n\n\t\tbuilder.stack.outputNode = resultNode;\n\n\t\tbuilder.addFlow( 'fragment', builder.removeStack() );\n\n\t\t// < MONITOR >\n\n\t\tbuilder.monitor = this.setupObserver( builder );\n\n\t}\n\n\tsetupClipping( builder ) {\n\n\t\tif ( builder.clippingContext === null ) return null;\n\n\t\tconst { unionPlanes, intersectionPlanes } = builder.clippingContext;\n\n\t\tlet result = null;\n\n\t\tif ( unionPlanes.length > 0 || intersectionPlanes.length > 0 ) {\n\n\t\t\tconst samples = builder.renderer.samples;\n\n\t\t\tif ( this.alphaToCoverage && samples > 1 ) {\n\n\t\t\t\t// to be added to flow when the color/alpha value has been determined\n\t\t\t\tresult = clippingAlpha();\n\n\t\t\t} else {\n\n\t\t\t\tbuilder.stack.add( clipping() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tsetupHardwareClipping( builder ) {\n\n\t\tthis.hardwareClipping = false;\n\n\t\tif ( builder.clippingContext === null ) return;\n\n\t\tconst candidateCount = builder.clippingContext.unionPlanes.length;\n\n\t\t// 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances\n\n\t\tif ( candidateCount > 0 && candidateCount <= 8 && builder.isAvailable( 'clipDistance' ) ) {\n\n\t\t\tbuilder.stack.add( hardwareClipping() );\n\n\t\t\tthis.hardwareClipping = true;\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\tsetupDepth( builder ) {\n\n\t\tconst { renderer, camera } = builder;\n\n\t\t// Depth\n\n\t\tlet depthNode = this.depthNode;\n\n\t\tif ( depthNode === null ) {\n\n\t\t\tconst mrt = renderer.getMRT();\n\n\t\t\tif ( mrt && mrt.has( 'depth' ) ) {\n\n\t\t\t\tdepthNode = mrt.get( 'depth' );\n\n\t\t\t} else if ( renderer.logarithmicDepthBuffer === true ) {\n\n\t\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tdepthNode = viewZToLogarithmicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdepthNode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( depthNode !== null ) {\n\n\t\t\tdepth.assign( depthNode ).append();\n\n\t\t}\n\n\t}\n\n\tsetupPosition( builder ) {\n\n\t\tconst { object } = builder;\n\t\tconst geometry = object.geometry;\n\n\t\tbuilder.addStack();\n\n\t\t// Vertex\n\n\t\tif ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {\n\n\t\t\tmorphReference( object ).append();\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\tskinningReference( object ).append();\n\n\t\t}\n\n\t\tif ( this.displacementMap ) {\n\n\t\t\tconst displacementMap = materialReference( 'displacementMap', 'texture' );\n\t\t\tconst displacementScale = materialReference( 'displacementScale', 'float' );\n\t\t\tconst displacementBias = materialReference( 'displacementBias', 'float' );\n\n\t\t\tpositionLocal.addAssign( normalLocal.normalize().mul( ( displacementMap.x.mul( displacementScale ).add( displacementBias ) ) ) );\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tbatch( object ).append();\n\n\t\t}\n\n\t\tif ( ( object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) ) {\n\n\t\t\tinstancedMesh( object ).append();\n\n\t\t}\n\n\t\tif ( this.positionNode !== null ) {\n\n\t\t\tpositionLocal.assign( this.positionNode );\n\n\t\t}\n\n\t\tthis.setupHardwareClipping( builder );\n\n\t\tconst mvp = modelViewProjection();\n\n\t\tbuilder.context.vertex = builder.removeStack();\n\t\tbuilder.context.mvp = mvp;\n\n\t\treturn mvp;\n\n\t}\n\n\tsetupDiffuseColor( { object, geometry } ) {\n\n\t\tlet colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;\n\n\t\t// VERTEX COLORS\n\n\t\tif ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {\n\n\t\t\tcolorNode = vec4( colorNode.xyz.mul( attribute( 'color', 'vec3' ) ), colorNode.a );\n\n\t\t}\n\n\t\t// Instanced colors\n\n\t\tif ( object.instanceColor ) {\n\n\t\t\tconst instanceColor = varyingProperty( 'vec3', 'vInstanceColor' );\n\n\t\t\tcolorNode = instanceColor.mul( colorNode );\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh && object._colorsTexture ) {\n\n\t\t\tconst batchColor = varyingProperty( 'vec3', 'vBatchColor' );\n\n\t\t\tcolorNode = batchColor.mul( colorNode );\n\n\t\t}\n\n\n\t\t// COLOR\n\n\t\tdiffuseColor.assign( colorNode );\n\n\t\t// OPACITY\n\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\t\tdiffuseColor.a.assign( diffuseColor.a.mul( opacityNode ) );\n\n\t\t// ALPHA TEST\n\n\t\tif ( this.alphaTestNode !== null || this.alphaTest > 0 ) {\n\n\t\t\tconst alphaTestNode = this.alphaTestNode !== null ? float( this.alphaTestNode ) : materialAlphaTest;\n\n\t\t\tdiffuseColor.a.lessThanEqual( alphaTestNode ).discard();\n\n\t\t}\n\n\t\t// ALPHA HASH\n\n\t\tif ( this.alphaHash === true ) {\n\n\t\t\tdiffuseColor.a.lessThan( getAlphaHashThreshold( positionLocal ) ).discard();\n\n\t\t}\n\n\t\tif ( this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false ) {\n\n\t\t\tdiffuseColor.a.assign( 1.0 );\n\n\t\t}\n\n\t}\n\n\tsetupVariants( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\tsetupOutgoingLight() {\n\n\t\treturn ( this.lights === true ) ? vec3( 0 ) : diffuseColor.rgb;\n\n\t}\n\n\tsetupNormal() {\n\n\t\treturn this.normalNode ? vec3( this.normalNode ) : materialNormal;\n\n\t}\n\n\tsetupEnvironment( /*builder*/ ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.envNode ) {\n\n\t\t\tnode = this.envNode;\n\n\t\t} else if ( this.envMap ) {\n\n\t\t\tnode = this.envMap.isCubeTexture ? materialReference( 'envMap', 'cubeTexture' ) : materialReference( 'envMap', 'texture' );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tsetupLightMap( builder ) {\n\n\t\tlet node = null;\n\n\t\tif ( builder.material.lightMap ) {\n\n\t\t\tnode = new IrradianceNode( materialLightMap );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tsetupLights( builder ) {\n\n\t\tconst materialLightsNode = [];\n\n\t\t//\n\n\t\tconst envNode = this.setupEnvironment( builder );\n\n\t\tif ( envNode && envNode.isLightingNode ) {\n\n\t\t\tmaterialLightsNode.push( envNode );\n\n\t\t}\n\n\t\tconst lightMapNode = this.setupLightMap( builder );\n\n\t\tif ( lightMapNode && lightMapNode.isLightingNode ) {\n\n\t\t\tmaterialLightsNode.push( lightMapNode );\n\n\t\t}\n\n\t\tif ( this.aoNode !== null || builder.material.aoMap ) {\n\n\t\t\tconst aoNode = this.aoNode !== null ? this.aoNode : materialAOMap;\n\n\t\t\tmaterialLightsNode.push( new AONode( aoNode ) );\n\n\t\t}\n\n\t\tlet lightsN = this.lightsNode || builder.lightsNode;\n\n\t\tif ( materialLightsNode.length > 0 ) {\n\n\t\t\tlightsN = builder.renderer.lighting.createNode( [ ...lightsN.getLights(), ...materialLightsNode ] );\n\n\t\t}\n\n\t\treturn lightsN;\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\tsetupLighting( builder ) {\n\n\t\tconst { material } = builder;\n\t\tconst { backdropNode, backdropAlphaNode, emissiveNode } = this;\n\n\t\t// OUTGOING LIGHT\n\n\t\tconst lights = this.lights === true || this.lightsNode !== null;\n\n\t\tconst lightsNode = lights ? this.setupLights( builder ) : null;\n\n\t\tlet outgoingLightNode = this.setupOutgoingLight( builder );\n\n\t\tif ( lightsNode && lightsNode.getScope().hasLights ) {\n\n\t\t\tconst lightingModel = this.setupLightingModel( builder );\n\n\t\t\toutgoingLightNode = lightingContext( lightsNode, lightingModel, backdropNode, backdropAlphaNode );\n\n\t\t} else if ( backdropNode !== null ) {\n\n\t\t\toutgoingLightNode = vec3( backdropAlphaNode !== null ? mix( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );\n\n\t\t}\n\n\t\t// EMISSIVE\n\n\t\tif ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {\n\n\t\t\temissive.assign( vec3( emissiveNode ? emissiveNode : materialEmissive ) );\n\n\t\t\toutgoingLightNode = outgoingLightNode.add( emissive );\n\n\t\t}\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\tsetupOutput( builder, outputNode ) {\n\n\t\t// FOG\n\n\t\tif ( this.fog === true ) {\n\n\t\t\tconst fogNode = builder.fogNode;\n\n\t\t\tif ( fogNode ) outputNode = vec4( fogNode.mix( outputNode.rgb, fogNode.colorNode ), outputNode.a );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n\tsetDefaultValues( material ) {\n\n\t\t// This approach is to reuse the native refreshUniforms*\n\t\t// and turn available the use of features like transmission and environment in core\n\n\t\tfor ( const property in material ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( this[ property ] === undefined ) {\n\n\t\t\t\tthis[ property ] = value;\n\n\t\t\t\tif ( value && value.clone ) this[ property ] = value.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&\n\t\t\t     descriptors[ key ].get !== undefined ) {\n\n\t\t\t\tObject.defineProperty( this.constructor.prototype, key, descriptors[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = Material.prototype.toJSON.call( this, meta );\n\t\tconst nodeChildren = getNodeChildren( this );\n\n\t\tdata.inputNodes = {};\n\n\t\tfor ( const { property, childNode } of nodeChildren ) {\n\n\t\t\tdata.inputNodes[ property ] = childNode.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.lightsNode = source.lightsNode;\n\t\tthis.envNode = source.envNode;\n\n\t\tthis.colorNode = source.colorNode;\n\t\tthis.normalNode = source.normalNode;\n\t\tthis.opacityNode = source.opacityNode;\n\t\tthis.backdropNode = source.backdropNode;\n\t\tthis.backdropAlphaNode = source.backdropAlphaNode;\n\t\tthis.alphaTestNode = source.alphaTestNode;\n\n\t\tthis.positionNode = source.positionNode;\n\t\tthis.geometryNode = source.geometryNode;\n\n\t\tthis.depthNode = source.depthNode;\n\t\tthis.shadowPositionNode = source.shadowPositionNode;\n\t\tthis.receivedShadowNode = source.receivedShadowNode;\n\t\tthis.castShadowNode = source.castShadowNode;\n\n\t\tthis.outputNode = source.outputNode;\n\t\tthis.mrtNode = source.mrtNode;\n\n\t\tthis.fragmentNode = source.fragmentNode;\n\t\tthis.vertexNode = source.vertexNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst _defaultValues$e = /*@__PURE__*/ new PointsMaterial();\n\nclass InstancedPointsNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'InstancedPointsNodeMaterial';\n\n\t}\n\n\tconstructor( params = {} ) {\n\n\t\tsuper();\n\n\t\tthis.lights = false;\n\n\t\tthis.useAlphaToCoverage = true;\n\n\t\tthis.useColor = params.vertexColors;\n\n\t\tthis.pointWidth = 1;\n\n\t\tthis.pointColorNode = null;\n\n\t\tthis.pointWidthNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$e );\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.setupShaders( builder );\n\n\t\tsuper.setup( builder );\n\n\t}\n\n\tsetupShaders( { renderer } ) {\n\n\t\tconst useAlphaToCoverage = this.alphaToCoverage;\n\t\tconst useColor = this.useColor;\n\n\t\tthis.vertexNode = Fn( () => {\n\n\t\t\tconst instancePosition = attribute( 'instancePosition' ).xyz;\n\n\t\t\t// camera space\n\t\t\tconst mvPos = vec4( modelViewMatrix.mul( vec4( instancePosition, 1.0 ) ) );\n\n\t\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t\t// clip space\n\t\t\tconst clipPos = cameraProjectionMatrix.mul( mvPos );\n\n\t\t\t// offset in ndc space\n\t\t\tconst offset = positionGeometry.xy.toVar();\n\n\t\t\toffset.mulAssign( this.pointWidthNode ? this.pointWidthNode : materialPointWidth );\n\n\t\t\toffset.assign( offset.div( viewport.z ) );\n\t\t\toffset.y.assign( offset.y.mul( aspect ) );\n\n\t\t\t// back to clip space\n\t\t\toffset.assign( offset.mul( clipPos.w ) );\n\n\t\t\t//clipPos.xy += offset;\n\t\t\tclipPos.addAssign( vec4( offset, 0, 0 ) );\n\n\t\t\treturn clipPos;\n\n\t\t} )();\n\n\t\tthis.fragmentNode = Fn( () => {\n\n\t\t\tconst alpha = float( 1 ).toVar();\n\n\t\t\tconst len2 = lengthSq( uv().mul( 2 ).sub( 1 ) );\n\n\t\t\tif ( useAlphaToCoverage && renderer.samples > 1 ) {\n\n\t\t\t\tconst dlen = float( len2.fwidth() ).toVar();\n\n\t\t\t\talpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t\t\t} else {\n\n\t\t\t\tlen2.greaterThan( 1.0 ).discard();\n\n\t\t\t}\n\n\t\t\tlet pointColorNode;\n\n\t\t\tif ( this.pointColorNode ) {\n\n\t\t\t\tpointColorNode = this.pointColorNode;\n\n\t\t\t} else {\n\n\t\t\t\tif ( useColor ) {\n\n\t\t\t\t\tconst instanceColor = attribute( 'instanceColor' );\n\n\t\t\t\t\tpointColorNode = instanceColor.mul( materialColor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpointColorNode = materialColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\talpha.mulAssign( materialOpacity );\n\n\t\t\treturn vec4( pointColorNode, alpha );\n\n\t\t} )();\n\n\t}\n\n\tget alphaToCoverage() {\n\n\t\treturn this.useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this.useAlphaToCoverage !== value ) {\n\n\t\t\tthis.useAlphaToCoverage = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nconst _defaultValues$d = /*@__PURE__*/ new LineBasicMaterial();\n\nclass LineBasicNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'LineBasicNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineBasicNodeMaterial = true;\n\n\t\tthis.lights = false;\n\n\t\tthis.setDefaultValues( _defaultValues$d );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n\nconst _defaultValues$c = /*@__PURE__*/ new LineDashedMaterial();\n\nclass LineDashedNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'LineDashedNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineDashedNodeMaterial = true;\n\n\t\tthis.lights = false;\n\n\t\tthis.setDefaultValues( _defaultValues$c );\n\n\t\tthis.dashOffset = 0;\n\n\t\tthis.offsetNode = null;\n\t\tthis.dashScaleNode = null;\n\t\tthis.dashSizeNode = null;\n\t\tthis.gapSizeNode = null;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupVariants() {\n\n\t\tconst offsetNode = this.offsetNode ? float( this.offsetNodeNode ) : materialLineDashOffset;\n\t\tconst dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;\n\t\tconst dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;\n\t\tconst gapSizeNode = this.dashSizeNode ? float( this.dashGapNode ) : materialLineGapSize;\n\n\t\tdashSize.assign( dashSizeNode );\n\t\tgapSize.assign( gapSizeNode );\n\n\t\tconst vLineDistance = varying( attribute( 'lineDistance' ).mul( dashScaleNode ) );\n\t\tconst vLineDistanceOffset = offsetNode ? vLineDistance.add( offsetNode ) : vLineDistance;\n\n\t\tvLineDistanceOffset.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard();\n\n\t}\n\n}\n\nlet _sharedFramebuffer = null;\n\nclass ViewportSharedTextureNode extends ViewportTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportSharedTextureNode';\n\n\t}\n\n\tconstructor( uvNode = screenUV, levelNode = null ) {\n\n\t\tif ( _sharedFramebuffer === null ) {\n\n\t\t\t_sharedFramebuffer = new FramebufferTexture();\n\n\t\t}\n\n\t\tsuper( uvNode, levelNode, _sharedFramebuffer );\n\n\t}\n\n\tupdateReference() {\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst viewportSharedTexture = /*@__PURE__*/ nodeProxy( ViewportSharedTextureNode );\n\nconst _defaultValues$b = /*@__PURE__*/ new LineDashedMaterial();\n\nclass Line2NodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'Line2NodeMaterial';\n\n\t}\n\n\tconstructor( params = {} ) {\n\n\t\tsuper();\n\n\t\tthis.lights = false;\n\n\t\tthis.setDefaultValues( _defaultValues$b );\n\n\t\tthis.useAlphaToCoverage = true;\n\t\tthis.useColor = params.vertexColors;\n\t\tthis.useDash = params.dashed;\n\t\tthis.useWorldUnits = false;\n\n\t\tthis.dashOffset = 0;\n\t\tthis.lineWidth = 1;\n\n\t\tthis.lineColorNode = null;\n\n\t\tthis.offsetNode = null;\n\t\tthis.dashScaleNode = null;\n\t\tthis.dashSizeNode = null;\n\t\tthis.gapSizeNode = null;\n\n\t\tthis.blending = NoBlending;\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.setupShaders( builder );\n\n\t\tsuper.setup( builder );\n\n\t}\n\n\tsetupShaders( { renderer } ) {\n\n\t\tconst useAlphaToCoverage = this.alphaToCoverage;\n\t\tconst useColor = this.useColor;\n\t\tconst useDash = this.dashed;\n\t\tconst useWorldUnits = this.worldUnits;\n\n\t\tconst trimSegment = Fn( ( { start, end } ) => {\n\n\t\t\tconst a = cameraProjectionMatrix.element( 2 ).element( 2 ); // 3nd entry in 3th column\n\t\t\tconst b = cameraProjectionMatrix.element( 3 ).element( 2 ); // 3nd entry in 4th column\n\t\t\tconst nearEstimate = b.mul( - 0.5 ).div( a );\n\n\t\t\tconst alpha = nearEstimate.sub( start.z ).div( end.z.sub( start.z ) );\n\n\t\t\treturn vec4( mix( start.xyz, end.xyz, alpha ), end.w );\n\n\t\t} ).setLayout( {\n\t\t\tname: 'trimSegment',\n\t\t\ttype: 'vec4',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'start', type: 'vec4' },\n\t\t\t\t{ name: 'end', type: 'vec4' }\n\t\t\t]\n\t\t} );\n\n\t\tthis.vertexNode = Fn( () => {\n\n\t\t\tconst instanceStart = attribute( 'instanceStart' );\n\t\t\tconst instanceEnd = attribute( 'instanceEnd' );\n\n\t\t\t// camera space\n\n\t\t\tconst start = vec4( modelViewMatrix.mul( vec4( instanceStart, 1.0 ) ) ).toVar( 'start' );\n\t\t\tconst end = vec4( modelViewMatrix.mul( vec4( instanceEnd, 1.0 ) ) ).toVar( 'end' );\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;\n\t\t\t\tconst offsetNode = this.offsetNode ? float( this.offsetNodeNode ) : materialLineDashOffset;\n\n\t\t\t\tconst instanceDistanceStart = attribute( 'instanceDistanceStart' );\n\t\t\t\tconst instanceDistanceEnd = attribute( 'instanceDistanceEnd' );\n\n\t\t\t\tlet lineDistance = positionGeometry.y.lessThan( 0.5 ).select( dashScaleNode.mul( instanceDistanceStart ), dashScaleNode.mul( instanceDistanceEnd ) );\n\t\t\t\tlineDistance = lineDistance.add( offsetNode );\n\n\t\t\t\tvaryingProperty( 'float', 'lineDistance' ).assign( lineDistance );\n\n\t\t\t}\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tvaryingProperty( 'vec3', 'worldStart' ).assign( start.xyz );\n\t\t\t\tvaryingProperty( 'vec3', 'worldEnd' ).assign( end.xyz );\n\n\t\t\t}\n\n\t\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tconst perspective = cameraProjectionMatrix.element( 2 ).element( 3 ).equal( - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tIf( perspective, () => {\n\n\t\t\t\tIf( start.z.lessThan( 0.0 ).and( end.z.greaterThan( 0.0 ) ), () => {\n\n\t\t\t\t\tend.assign( trimSegment( { start: start, end: end } ) );\n\n\t\t\t\t} ).ElseIf( end.z.lessThan( 0.0 ).and( start.z.greaterThanEqual( 0.0 ) ), () => {\n\n\t\t\t\t\tstart.assign( trimSegment( { start: end, end: start } ) );\n\n\t\t\t \t} );\n\n\t\t\t} );\n\n\t\t\t// clip space\n\t\t\tconst clipStart = cameraProjectionMatrix.mul( start );\n\t\t\tconst clipEnd = cameraProjectionMatrix.mul( end );\n\n\t\t\t// ndc space\n\t\t\tconst ndcStart = clipStart.xyz.div( clipStart.w );\n\t\t\tconst ndcEnd = clipEnd.xyz.div( clipEnd.w );\n\n\t\t\t// direction\n\t\t\tconst dir = ndcEnd.xy.sub( ndcStart.xy ).toVar();\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x.assign( dir.x.mul( aspect ) );\n\t\t\tdir.assign( dir.normalize() );\n\n\t\t\tconst clip = vec4().toVar();\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\n\t\t\t\tconst worldDir = end.xyz.sub( start.xyz ).normalize();\n\t\t\t\tconst tmpFwd = mix( start.xyz, end.xyz, 0.5 ).normalize();\n\t\t\t\tconst worldUp = worldDir.cross( tmpFwd ).normalize();\n\t\t\t\tconst worldFwd = worldDir.cross( worldUp );\n\n\t\t\t\tconst worldPos = varyingProperty( 'vec4', 'worldPos' );\n\n\t\t\t\tworldPos.assign( positionGeometry.y.lessThan( 0.5 ).select( start, end ) );\n\n\t\t\t\t// height offset\n\t\t\t\tconst hw = materialLineWidth.mul( 0.5 );\n\t\t\t\tworldPos.addAssign( vec4( positionGeometry.x.lessThan( 0.0 ).select( worldUp.mul( hw ), worldUp.mul( hw ).negate() ), 0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.addAssign( vec4( positionGeometry.y.lessThan( 0.5 ).select( worldDir.mul( hw ).negate(), worldDir.mul( hw ) ), 0 ) );\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.addAssign( vec4( worldFwd.mul( hw ), 0 ) );\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tIf( positionGeometry.y.greaterThan( 1.0 ).or( positionGeometry.y.lessThan( 0.0 ) ), () => {\n\n\t\t\t\t\t\tworldPos.subAssign( vec4( worldFwd.mul( 2.0 ).mul( hw ), 0 ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t// project the worldpos\n\t\t\t\tclip.assign( cameraProjectionMatrix.mul( worldPos ) );\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tconst clipPose = vec3().toVar();\n\n\t\t\t\tclipPose.assign( positionGeometry.y.lessThan( 0.5 ).select( ndcStart, ndcEnd ) );\n\t\t\t\tclip.z.assign( clipPose.z.mul( clip.w ) );\n\n\t\t\t} else {\n\n\t\t\t\tconst offset = vec2( dir.y, dir.x.negate() ).toVar( 'offset' );\n\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x.assign( dir.x.div( aspect ) );\n\t\t\t\toffset.x.assign( offset.x.div( aspect ) );\n\n\t\t\t\t// sign flip\n\t\t\t\toffset.assign( positionGeometry.x.lessThan( 0.0 ).select( offset.negate(), offset ) );\n\n\t\t\t\t// endcaps\n\t\t\t\tIf( positionGeometry.y.lessThan( 0.0 ), () => {\n\n\t\t\t\t\toffset.assign( offset.sub( dir ) );\n\n\t\t\t\t} ).ElseIf( positionGeometry.y.greaterThan( 1.0 ), () => {\n\n\t\t\t\t\toffset.assign( offset.add( dir ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset.assign( offset.mul( materialLineWidth ) );\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset.assign( offset.div( viewport.w ) );\n\n\t\t\t\t// select end\n\t\t\t\tclip.assign( positionGeometry.y.lessThan( 0.5 ).select( clipStart, clipEnd ) );\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset.assign( offset.mul( clip.w ) );\n\n\t\t\t\tclip.assign( clip.add( vec4( offset, 0, 0 ) ) );\n\n\t\t\t}\n\n\t\t\treturn clip;\n\n\t\t} )();\n\n\t\tconst closestLineToLine = Fn( ( { p1, p2, p3, p4 } ) => {\n\n\t\t\tconst p13 = p1.sub( p3 );\n\t\t\tconst p43 = p4.sub( p3 );\n\n\t\t\tconst p21 = p2.sub( p1 );\n\n\t\t\tconst d1343 = p13.dot( p43 );\n\t\t\tconst d4321 = p43.dot( p21 );\n\t\t\tconst d1321 = p13.dot( p21 );\n\t\t\tconst d4343 = p43.dot( p43 );\n\t\t\tconst d2121 = p21.dot( p21 );\n\n\t\t\tconst denom = d2121.mul( d4343 ).sub( d4321.mul( d4321 ) );\n\t\t\tconst numer = d1343.mul( d4321 ).sub( d1321.mul( d4343 ) );\n\n\t\t\tconst mua = numer.div( denom ).clamp();\n\t\t\tconst mub = d1343.add( d4321.mul( mua ) ).div( d4343 ).clamp();\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t} );\n\n\t\tthis.colorNode = Fn( () => {\n\n\t\t\tconst vUv = uv();\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;\n\t\t\t\tconst gapSizeNode = this.dashSizeNode ? float( this.dashGapNode ) : materialLineGapSize;\n\n\t\t\t\tdashSize.assign( dashSizeNode );\n\t\t\t\tgapSize.assign( gapSizeNode );\n\n\t\t\t\tconst vLineDistance = varyingProperty( 'float', 'lineDistance' );\n\n\t\t\t\tvUv.y.lessThan( - 1.0 ).or( vUv.y.greaterThan( 1.0 ) ).discard(); // discard endcaps\n\t\t\t\tvLineDistance.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard(); // todo - FIX\n\n\t\t\t}\n\n\t\t\tconst alpha = float( 1 ).toVar( 'alpha' );\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tconst worldStart = varyingProperty( 'vec3', 'worldStart' );\n\t\t\t\tconst worldEnd = varyingProperty( 'vec3', 'worldEnd' );\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tconst rayEnd = varyingProperty( 'vec4', 'worldPos' ).xyz.normalize().mul( 1e5 );\n\t\t\t\tconst lineDir = worldEnd.sub( worldStart );\n\t\t\t\tconst params = closestLineToLine( { p1: worldStart, p2: worldEnd, p3: vec3( 0.0, 0.0, 0.0 ), p4: rayEnd } );\n\n\t\t\t\tconst p1 = worldStart.add( lineDir.mul( params.x ) );\n\t\t\t\tconst p2 = rayEnd.mul( params.y );\n\t\t\t\tconst delta = p1.sub( p2 );\n\t\t\t\tconst len = delta.length();\n\t\t\t\tconst norm = len.div( materialLineWidth );\n\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\tif ( useAlphaToCoverage && renderer.samples > 1 ) {\n\n\t\t\t\t\t\tconst dnorm = norm.fwidth();\n\t\t\t\t\t\talpha.assign( smoothstep( dnorm.negate().add( 0.5 ), dnorm.add( 0.5 ), norm ).oneMinus() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnorm.greaterThan( 0.5 ).discard();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// round endcaps\n\n\t\t\t\tif ( useAlphaToCoverage && renderer.samples > 1 ) {\n\n\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\n\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\tconst dlen = float( len2.fwidth() ).toVar( 'dlen' );\n\n\t\t\t\t\tIf( vUv.y.abs().greaterThan( 1.0 ), () => {\n\n\t\t\t\t\t\talpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tIf( vUv.y.abs().greaterThan( 1.0 ), () => {\n\n\t\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\t\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\t\tlen2.greaterThan( 1.0 ).discard();\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet lineColorNode;\n\n\t\t\tif ( this.lineColorNode ) {\n\n\t\t\t\tlineColorNode = this.lineColorNode;\n\n\t\t\t} else {\n\n\t\t\t\tif ( useColor ) {\n\n\t\t\t\t\tconst instanceColorStart = attribute( 'instanceColorStart' );\n\t\t\t\t\tconst instanceColorEnd = attribute( 'instanceColorEnd' );\n\n\t\t\t\t\tconst instanceColor = positionGeometry.y.lessThan( 0.5 ).select( instanceColorStart, instanceColorEnd );\n\n\t\t\t\t\tlineColorNode = instanceColor.mul( materialColor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlineColorNode = materialColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn vec4( lineColorNode, alpha );\n\n\t\t} )();\n\n\t\tif ( this.transparent ) {\n\n\t\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\n\t\t\tthis.outputNode = vec4( this.colorNode.rgb.mul( opacityNode ).add( viewportSharedTexture().rgb.mul( opacityNode.oneMinus() ) ), this.colorNode.a );\n\n\t\t}\n\n\t}\n\n\n\tget worldUnits() {\n\n\t\treturn this.useWorldUnits;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( this.useWorldUnits !== value ) {\n\n\t\t\tthis.useWorldUnits = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\n\tget dashed() {\n\n\t\treturn this.useDash;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( this.useDash !== value ) {\n\n\t\t\tthis.useDash = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\n\tget alphaToCoverage() {\n\n\t\treturn this.useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this.useAlphaToCoverage !== value ) {\n\n\t\t\tthis.useAlphaToCoverage = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nconst directionToColor = ( node ) => nodeObject( node ).mul( 0.5 ).add( 0.5 );\nconst colorToDirection = ( node ) => nodeObject( node ).mul( 2.0 ).sub( 1 );\n\nconst _defaultValues$a = /*@__PURE__*/ new MeshNormalMaterial();\n\nclass MeshNormalNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshNormalNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.lights = false;\n\n\t\tthis.isMeshNormalNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$a );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupDiffuseColor() {\n\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\n\t\tdiffuseColor.assign( vec4( directionToColor( transformedNormalView ), opacityNode ) );\n\n\t}\n\n}\n\nclass EquirectUVNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'EquirectUVNode';\n\n\t}\n\n\tconstructor( dirNode = positionWorldDirection ) {\n\n\t\tsuper( 'vec2' );\n\n\t\tthis.dirNode = dirNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst dir = this.dirNode;\n\n\t\tconst u = dir.z.atan2( dir.x ).mul( 1 / ( Math.PI * 2 ) ).add( 0.5 );\n\t\tconst v = dir.y.clamp( - 1.0, 1.0 ).asin().mul( 1 / Math.PI ).add( 0.5 );\n\n\t\treturn vec2( u, v );\n\n\t}\n\n}\n\nconst equirectUV = /*@__PURE__*/ nodeProxy( EquirectUVNode );\n\n// @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget\n\nclass CubeRenderTarget extends WebGLCubeRenderTarget {\n\n\tconstructor( size = 1, options = {} ) {\n\n\t\tsuper( size, options );\n\n\t\tthis.isCubeRenderTarget = true;\n\n\t}\n\n\tfromEquirectangularTexture( renderer, texture$1 ) {\n\n\t\tconst currentMinFilter = texture$1.minFilter;\n\t\tconst currentGenerateMipmaps = texture$1.generateMipmaps;\n\n\t\ttexture$1.generateMipmaps = true;\n\n\t\tthis.texture.type = texture$1.type;\n\t\tthis.texture.colorSpace = texture$1.colorSpace;\n\n\t\tthis.texture.generateMipmaps = texture$1.generateMipmaps;\n\t\tthis.texture.minFilter = texture$1.minFilter;\n\t\tthis.texture.magFilter = texture$1.magFilter;\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst uvNode = equirectUV( positionWorldDirection );\n\n\t\tconst material = new NodeMaterial();\n\t\tmaterial.colorNode = texture( texture$1, uvNode, 0 );\n\t\tmaterial.side = BackSide;\n\t\tmaterial.blending = NoBlending;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst scene = new Scene();\n\t\tscene.add( mesh );\n\n\t\t// Avoid blurred poles\n\t\tif ( texture$1.minFilter === LinearMipmapLinearFilter ) texture$1.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\n\t\tconst currentMRT = renderer.getMRT();\n\t\trenderer.setMRT( null );\n\n\t\tcamera.update( renderer, scene );\n\n\t\trenderer.setMRT( currentMRT );\n\n\t\ttexture$1.minFilter = currentMinFilter;\n\t\ttexture$1.currentGenerateMipmaps = currentGenerateMipmaps;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _cache$1 = new WeakMap();\n\nclass CubeMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'CubeMapNode';\n\n\t}\n\n\tconstructor( envNode ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.envNode = envNode;\n\n\t\tthis._cubeTexture = null;\n\t\tthis._cubeTextureNode = cubeTexture();\n\n\t\tconst defaultTexture = new CubeTexture();\n\t\tdefaultTexture.isRenderTargetTexture = true;\n\n\t\tthis._defaultTexture = defaultTexture;\n\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer, material } = frame;\n\n\t\tconst envNode = this.envNode;\n\n\t\tif ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {\n\n\t\t\tconst texture = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];\n\n\t\t\tif ( texture && texture.isTexture ) {\n\n\t\t\t\tconst mapping = texture.mapping;\n\n\t\t\t\tif ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {\n\n\t\t\t\t\t// check for converted cubemap map\n\n\t\t\t\t\tif ( _cache$1.has( texture ) ) {\n\n\t\t\t\t\t\tconst cubeMap = _cache$1.get( texture );\n\n\t\t\t\t\t\tmapTextureMapping( cubeMap, texture.mapping );\n\t\t\t\t\t\tthis._cubeTexture = cubeMap;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// create cube map from equirectangular map\n\n\t\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\t\tif ( isEquirectangularMapReady$1( image ) ) {\n\n\t\t\t\t\t\t\tconst renderTarget = new CubeRenderTarget( image.height );\n\t\t\t\t\t\t\trenderTarget.fromEquirectangularTexture( renderer, texture );\n\n\t\t\t\t\t\t\tmapTextureMapping( renderTarget.texture, texture.mapping );\n\t\t\t\t\t\t\tthis._cubeTexture = renderTarget.texture;\n\n\t\t\t\t\t\t\t_cache$1.set( texture, renderTarget.texture );\n\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// default cube texture as fallback when equirectangular texture is not yet loaded\n\n\t\t\t\t\t\t\tthis._cubeTexture = this._defaultTexture;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\tthis._cubeTextureNode.value = this._cubeTexture;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// envNode already refers to a cube map\n\n\t\t\t\t\tthis._cubeTextureNode = this.envNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.updateBefore( builder );\n\n\t\treturn this._cubeTextureNode;\n\n\t}\n\n}\n\nfunction isEquirectangularMapReady$1( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\treturn image.height > 0;\n\n}\n\nfunction onTextureDispose( event ) {\n\n\tconst texture = event.target;\n\n\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\tconst renderTarget = _cache$1.get( texture );\n\n\tif ( renderTarget !== undefined ) {\n\n\t\t_cache$1.delete( texture );\n\n\t\trenderTarget.dispose();\n\n\t}\n\n}\n\nfunction mapTextureMapping( texture, mapping ) {\n\n\tif ( mapping === EquirectangularReflectionMapping ) {\n\n\t\ttexture.mapping = CubeReflectionMapping;\n\n\t} else if ( mapping === EquirectangularRefractionMapping ) {\n\n\t\ttexture.mapping = CubeRefractionMapping;\n\n\t}\n\n}\n\nconst cubeMapNode = /*@__PURE__*/ nodeProxy( CubeMapNode );\n\nclass BasicEnvironmentNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'BasicEnvironmentNode';\n\n\t}\n\n\tconstructor( envNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.envNode = envNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// environment property is used in the finish() method of BasicLightingModel\n\n\t\tbuilder.context.environment = cubeMapNode( this.envNode );\n\n\t}\n\n}\n\nclass BasicLightMapNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'BasicLightMapNode';\n\n\t}\n\n\tconstructor( lightMapNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.lightMapNode = lightMapNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel\n\n\t\tconst RECIPROCAL_PI = float( 1 / Math.PI );\n\n\t\tbuilder.context.irradianceLightMap = this.lightMapNode.mul( RECIPROCAL_PI );\n\n\t}\n\n}\n\nclass LightingModel {\n\n\tstart( /*input, stack, builder*/ ) { }\n\n\tfinish( /*input, stack, builder*/ ) { }\n\n\tdirect( /*input, stack, builder*/ ) { }\n\n\tdirectRectArea( /*input, stack, builder*/ ) {}\n\n\tindirect( /*input, stack, builder*/ ) { }\n\n\tambientOcclusion( /*input, stack, builder*/ ) { }\n\n}\n\nclass BasicLightingModel extends LightingModel {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t}\n\n\tindirect( context, stack, builder ) {\n\n\t\tconst ambientOcclusion = context.ambientOcclusion;\n\t\tconst reflectedLight = context.reflectedLight;\n\t\tconst irradianceLightMap = builder.context.irradianceLightMap;\n\n\t\treflectedLight.indirectDiffuse.assign( vec4( 0.0 ) );\n\n\t\t// accumulation (baked indirect lighting only)\n\n\t\tif ( irradianceLightMap ) {\n\n\t\t\treflectedLight.indirectDiffuse.addAssign( irradianceLightMap );\n\n\t\t} else {\n\n\t\t\treflectedLight.indirectDiffuse.addAssign( vec4( 1.0, 1.0, 1.0, 0.0 ) );\n\n\t\t}\n\n\t\t// modulation\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( diffuseColor.rgb );\n\n\t}\n\n\tfinish( context, stack, builder ) {\n\n\t\tconst material = builder.material;\n\t\tconst outgoingLight = context.outgoingLight;\n\t\tconst envNode = builder.context.environment;\n\n\t\tif ( envNode ) {\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\toutgoingLight.rgb.assign( mix( outgoingLight.rgb, outgoingLight.rgb.mul( envNode.rgb ), materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MixOperation:\n\t\t\t\t\toutgoingLight.rgb.assign( mix( outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AddOperation:\n\t\t\t\t\toutgoingLight.rgb.addAssign( envNode.rgb.mul( materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.BasicLightingModel: Unsupported .combine value:', material.combine );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst _defaultValues$9 = /*@__PURE__*/ new MeshBasicMaterial();\n\nclass MeshBasicNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshBasicNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshBasicNodeMaterial = true;\n\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$9 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupNormal() {\n\n\t\treturn normalView; // see #28839\n\n\t}\n\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\tsetupLightMap( builder ) {\n\n\t\tlet node = null;\n\n\t\tif ( builder.material.lightMap ) {\n\n\t\t\tnode = new BasicLightMapNode( materialLightMap );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tsetupOutgoingLight() {\n\n\t\treturn diffuseColor.rgb;\n\n\t}\n\n\tsetupLightingModel() {\n\n\t\treturn new BasicLightingModel();\n\n\t}\n\n}\n\nconst F_Schlick = /*@__PURE__*/ Fn( ( { f0, f90, dotVH } ) => {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tconst fresnel = dotVH.mul( - 5.55473 ).sub( 6.98316 ).mul( dotVH ).exp2();\n\n\treturn f0.mul( fresnel.oneMinus() ).add( f90.mul( fresnel ) );\n\n} ); // validated\n\nconst BRDF_Lambert = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\treturn inputs.diffuseColor.mul( 1 / Math.PI ); // punctual light\n\n} ); // validated\n\nconst G_BlinnPhong_Implicit = () => float( 0.25 );\n\nconst D_BlinnPhong = /*@__PURE__*/ Fn( ( { dotNH } ) => {\n\n\treturn shininess.mul( float( 0.5 ) ).add( 1.0 ).mul( float( 1 / Math.PI ) ).mul( dotNH.pow( shininess ) );\n\n} );\n\nconst BRDF_BlinnPhong = /*@__PURE__*/ Fn( ( { lightDirection } ) => {\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNH = transformedNormalView.dot( halfDir ).clamp();\n\tconst dotVH = positionViewDirection.dot( halfDir ).clamp();\n\n\tconst F = F_Schlick( { f0: specularColor, f90: 1.0, dotVH } );\n\tconst G = G_BlinnPhong_Implicit();\n\tconst D = D_BlinnPhong( { dotNH } );\n\n\treturn F.mul( G ).mul( D );\n\n} );\n\nclass PhongLightingModel extends BasicLightingModel {\n\n\tconstructor( specular = true ) {\n\n\t\tsuper();\n\n\t\tthis.specular = specular;\n\n\t}\n\n\tdirect( { lightDirection, lightColor, reflectedLight } ) {\n\n\t\tconst dotNL = transformedNormalView.dot( lightDirection ).clamp();\n\t\tconst irradiance = dotNL.mul( lightColor );\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t\tif ( this.specular === true ) {\n\n\t\t\treflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_BlinnPhong( { lightDirection } ) ).mul( materialSpecularStrength ) );\n\n\t\t}\n\n\t}\n\n\tindirect( { ambientOcclusion, irradiance, reflectedLight } ) {\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t}\n\n}\n\nconst _defaultValues$8 = /*@__PURE__*/ new MeshLambertMaterial();\n\nclass MeshLambertNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshLambertNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshLambertNodeMaterial = true;\n\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$8 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhongLightingModel( false ); // ( specular ) -> force lambert\n\n\t}\n\n}\n\nconst _defaultValues$7 = /*@__PURE__*/ new MeshPhongMaterial();\n\nclass MeshPhongNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshPhongNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhongNodeMaterial = true;\n\n\t\tthis.lights = true;\n\n\t\tthis.shininessNode = null;\n\t\tthis.specularNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$7 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhongLightingModel();\n\n\t}\n\n\tsetupVariants() {\n\n\t\t// SHININESS\n\n\t\tconst shininessNode = ( this.shininessNode ? float( this.shininessNode ) : materialShininess ).max( 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tshininess.assign( shininessNode );\n\n\t\t// SPECULAR COLOR\n\n\t\tconst specularNode = this.specularNode || materialSpecular;\n\n\t\tspecularColor.assign( specularNode );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.shininessNode = source.shininessNode;\n\t\tthis.specularNode = source.specularNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst getGeometryRoughness = /*@__PURE__*/ Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'normal' ) === false ) {\n\n\t\treturn float( 0 );\n\n\t}\n\n\tconst dxy = normalView.dFdx().abs().max( normalView.dFdy().abs() );\n\tconst geometryRoughness = dxy.x.max( dxy.y ).max( dxy.z );\n\n\treturn geometryRoughness;\n\n} );\n\nconst getRoughness = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { roughness } = inputs;\n\n\tconst geometryRoughness = getGeometryRoughness();\n\n\tlet roughnessFactor = roughness.max( 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.\n\troughnessFactor = roughnessFactor.add( geometryRoughness );\n\troughnessFactor = roughnessFactor.min( 1.0 );\n\n\treturn roughnessFactor;\n\n} );\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nconst V_GGX_SmithCorrelated = /*@__PURE__*/ Fn( ( { alpha, dotNL, dotNV } ) => {\n\n\tconst a2 = alpha.pow2();\n\n\tconst gv = dotNL.mul( a2.add( a2.oneMinus().mul( dotNV.pow2() ) ).sqrt() );\n\tconst gl = dotNV.mul( a2.add( a2.oneMinus().mul( dotNL.pow2() ) ).sqrt() );\n\n\treturn div( 0.5, gv.add( gl ).max( EPSILON ) );\n\n} ).setLayout( {\n\tname: 'V_GGX_SmithCorrelated',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alpha', type: 'float' },\n\t\t{ name: 'dotNL', type: 'float' },\n\t\t{ name: 'dotNV', type: 'float' }\n\t]\n} ); // validated\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } ) => {\n\n\tconst gv = dotNL.mul( vec3( alphaT.mul( dotTV ), alphaB.mul( dotBV ), dotNV ).length() );\n\tconst gl = dotNV.mul( vec3( alphaT.mul( dotTL ), alphaB.mul( dotBL ), dotNL ).length() );\n\tconst v = div( 0.5, gv.add( gl ) );\n\n\treturn v.saturate();\n\n} ).setLayout( {\n\tname: 'V_GGX_SmithCorrelated_Anisotropic',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alphaT', type: 'float', qualifier: 'in' },\n\t\t{ name: 'alphaB', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTL', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBL', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNL', type: 'float', qualifier: 'in' }\n\t]\n} );\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneys reparameterization\nconst D_GGX = /*@__PURE__*/ Fn( ( { alpha, dotNH } ) => {\n\n\tconst a2 = alpha.pow2();\n\n\tconst denom = dotNH.pow2().mul( a2.oneMinus() ).oneMinus(); // avoid alpha = 0 with dotNH = 1\n\n\treturn a2.div( denom.pow2() ).mul( 1 / Math.PI );\n\n} ).setLayout( {\n\tname: 'D_GGX',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alpha', type: 'float' },\n\t\t{ name: 'dotNH', type: 'float' }\n\t]\n} ); // validated\n\nconst RECIPROCAL_PI = /*@__PURE__*/ float( 1 / Math.PI );\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst D_GGX_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotNH, dotTH, dotBH } ) => {\n\n\tconst a2 = alphaT.mul( alphaB );\n\tconst v = vec3( alphaB.mul( dotTH ), alphaT.mul( dotBH ), a2.mul( dotNH ) );\n\tconst v2 = v.dot( v );\n\tconst w2 = a2.div( v2 );\n\n\treturn RECIPROCAL_PI.mul( a2.mul( w2.pow2() ) );\n\n} ).setLayout( {\n\tname: 'D_GGX_Anisotropic',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alphaT', type: 'float', qualifier: 'in' },\n\t\t{ name: 'alphaB', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNH', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTH', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBH', type: 'float', qualifier: 'in' }\n\t]\n} );\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nconst BRDF_GGX = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { lightDirection, f0, f90, roughness, f, USE_IRIDESCENCE, USE_ANISOTROPY } = inputs;\n\n\tconst normalView = inputs.normalView || transformedNormalView;\n\n\tconst alpha = roughness.pow2(); // UE4's roughness\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNL = normalView.dot( lightDirection ).clamp();\n\tconst dotNV = normalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\tconst dotNH = normalView.dot( halfDir ).clamp();\n\tconst dotVH = positionViewDirection.dot( halfDir ).clamp();\n\n\tlet F = F_Schlick( { f0, f90, dotVH } );\n\tlet V, D;\n\n\tif ( defined( USE_IRIDESCENCE ) ) {\n\n\t\tF = iridescence.mix( F, f );\n\n\t}\n\n\tif ( defined( USE_ANISOTROPY ) ) {\n\n\t\tconst dotTL = anisotropyT.dot( lightDirection );\n\t\tconst dotTV = anisotropyT.dot( positionViewDirection );\n\t\tconst dotTH = anisotropyT.dot( halfDir );\n\t\tconst dotBL = anisotropyB.dot( lightDirection );\n\t\tconst dotBV = anisotropyB.dot( positionViewDirection );\n\t\tconst dotBH = anisotropyB.dot( halfDir );\n\n\t\tV = V_GGX_SmithCorrelated_Anisotropic( { alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } );\n\t\tD = D_GGX_Anisotropic( { alphaT, alphaB: alpha, dotNH, dotTH, dotBH } );\n\n\t} else {\n\n\t\tV = V_GGX_SmithCorrelated( { alpha, dotNL, dotNV } );\n\t\tD = D_GGX( { alpha, dotNH } );\n\n\t}\n\n\treturn F.mul( V ).mul( D );\n\n} ); // validated\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from \"Physically Based Shading on Mobile\"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nconst DFGApprox = /*@__PURE__*/ Fn( ( { roughness, dotNV } ) => {\n\n\tconst c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tconst r = roughness.mul( c0 ).add( c1 );\n\n\tconst a004 = r.x.mul( r.x ).min( dotNV.mul( - 9.28 ).exp2() ).mul( r.x ).add( r.y );\n\n\tconst fab = vec2( - 1.04, 1.04 ).mul( a004 ).add( r.zw );\n\n\treturn fab;\n\n} ).setLayout( {\n\tname: 'DFGApprox',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' },\n\t\t{ name: 'dotNV', type: 'vec3' }\n\t]\n} );\n\nconst EnvironmentBRDF = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { dotNV, specularColor, specularF90, roughness } = inputs;\n\n\tconst fab = DFGApprox( { dotNV, roughness } );\n\treturn specularColor.mul( fab.x ).add( specularF90.mul( fab.y ) );\n\n} );\n\nconst Schlick_to_F0 = /*@__PURE__*/ Fn( ( { f, f90, dotVH } ) => {\n\n\tconst x = dotVH.oneMinus().saturate();\n\tconst x2 = x.mul( x );\n\tconst x5 = x.mul( x2, x2 ).clamp( 0, .9999 );\n\n\treturn f.sub( vec3( f90 ).mul( x5 ) ).div( x5.oneMinus() );\n\n} ).setLayout( {\n\tname: 'Schlick_to_F0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'f', type: 'vec3' },\n\t\t{ name: 'f90', type: 'float' },\n\t\t{ name: 'dotVH', type: 'float' }\n\t]\n} );\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst D_Charlie = /*@__PURE__*/ Fn( ( { roughness, dotNH } ) => {\n\n\tconst alpha = roughness.pow2();\n\n\t// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n\tconst invAlpha = float( 1.0 ).div( alpha );\n\tconst cos2h = dotNH.pow2();\n\tconst sin2h = cos2h.oneMinus().max( 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\n\treturn float( 2.0 ).add( invAlpha ).mul( sin2h.pow( invAlpha.mul( 0.5 ) ) ).div( 2.0 * Math.PI );\n\n} ).setLayout( {\n\tname: 'D_Charlie',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' },\n\t\t{ name: 'dotNH', type: 'float' }\n\t]\n} );\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst V_Neubelt = /*@__PURE__*/ Fn( ( { dotNV, dotNL } ) => {\n\n\t// Neubelt and Pettineo 2013, \"Crafting a Next-gen Material Pipeline for The Order: 1886\"\n\treturn float( 1.0 ).div( float( 4.0 ).mul( dotNL.add( dotNV ).sub( dotNL.mul( dotNV ) ) ) );\n\n} ).setLayout( {\n\tname: 'V_Neubelt',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'dotNV', type: 'float' },\n\t\t{ name: 'dotNL', type: 'float' }\n\t]\n} );\n\nconst BRDF_Sheen = /*@__PURE__*/ Fn( ( { lightDirection } ) => {\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNL = transformedNormalView.dot( lightDirection ).clamp();\n\tconst dotNV = transformedNormalView.dot( positionViewDirection ).clamp();\n\tconst dotNH = transformedNormalView.dot( halfDir ).clamp();\n\n\tconst D = D_Charlie( { roughness: sheenRoughness, dotNH } );\n\tconst V = V_Neubelt( { dotNV, dotNL } );\n\n\treturn sheen.mul( D ).mul( V );\n\n} );\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nconst LTC_Uv = /*@__PURE__*/ Fn( ( { N, V, roughness } ) => {\n\n\tconst LUT_SIZE = 64.0;\n\tconst LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst LUT_BIAS = 0.5 / LUT_SIZE;\n\n\tconst dotNV = N.dot( V ).saturate();\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tconst uv = vec2( roughness, dotNV.oneMinus().sqrt() );\n\n\tuv.assign( uv.mul( LUT_SCALE ).add( LUT_BIAS ) );\n\n\treturn uv;\n\n} ).setLayout( {\n\tname: 'LTC_Uv',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'N', type: 'vec3' },\n\t\t{ name: 'V', type: 'vec3' },\n\t\t{ name: 'roughness', type: 'float' }\n\t]\n} );\n\nconst LTC_ClippedSphereFormFactor = /*@__PURE__*/ Fn( ( { f } ) => {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tconst l = f.length();\n\n\treturn max$1( l.mul( l ).add( f.z ).div( l.add( 1.0 ) ), 0 );\n\n} ).setLayout( {\n\tname: 'LTC_ClippedSphereFormFactor',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'f', type: 'vec3' }\n\t]\n} );\n\nconst LTC_EdgeVectorFormFactor = /*@__PURE__*/ Fn( ( { v1, v2 } ) => {\n\n\tconst x = v1.dot( v2 );\n\tconst y = x.abs().toVar();\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tconst a = y.mul( 0.0145206 ).add( 0.4965155 ).mul( y ).add( 0.8543985 ).toVar();\n\tconst b = y.add( 4.1616724 ).mul( y ).add( 3.4175940 ).toVar();\n\tconst v = a.div( b );\n\n\tconst theta_sintheta = x.greaterThan( 0.0 ).select( v, max$1( x.mul( x ).oneMinus(), 1e-7 ).inverseSqrt().mul( 0.5 ).sub( v ) );\n\n\treturn v1.cross( v2 ).mul( theta_sintheta );\n\n} ).setLayout( {\n\tname: 'LTC_EdgeVectorFormFactor',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' }\n\t]\n} );\n\nconst LTC_Evaluate = /*@__PURE__*/ Fn( ( { N, V, P, mInv, p0, p1, p2, p3 } ) => {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tconst v1 = p1.sub( p0 ).toVar();\n\tconst v2 = p3.sub( p0 ).toVar();\n\n\tconst lightNormal = v1.cross( v2 );\n\tconst result = vec3().toVar();\n\n\tIf( lightNormal.dot( P.sub( p0 ) ).greaterThanEqual( 0.0 ), () => {\n\n\t\t// construct orthonormal basis around N\n\t\tconst T1 = V.sub( N.mul( V.dot( N ) ) ).normalize();\n\t\tconst T2 = N.cross( T1 ).negate(); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t\t// compute transform\n\t\tconst mat = mInv.mul( mat3( T1, T2, N ).transpose() ).toVar();\n\n\t\t// transform rect\n\t\t// & project rect onto sphere\n\t\tconst coords0 = mat.mul( p0.sub( P ) ).normalize().toVar();\n\t\tconst coords1 = mat.mul( p1.sub( P ) ).normalize().toVar();\n\t\tconst coords2 = mat.mul( p2.sub( P ) ).normalize().toVar();\n\t\tconst coords3 = mat.mul( p3.sub( P ) ).normalize().toVar();\n\n\t\t// calculate vector form factor\n\t\tconst vectorFormFactor = vec3( 0 ).toVar();\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords0, v2: coords1 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords1, v2: coords2 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords2, v2: coords3 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords3, v2: coords0 } ) );\n\n\t\t// adjust for horizon clipping\n\t\tresult.assign( vec3( LTC_ClippedSphereFormFactor( { f: vectorFormFactor } ) ) );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'LTC_Evaluate',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'N', type: 'vec3' },\n\t\t{ name: 'V', type: 'vec3' },\n\t\t{ name: 'P', type: 'vec3' },\n\t\t{ name: 'mInv', type: 'mat3' },\n\t\t{ name: 'p0', type: 'vec3' },\n\t\t{ name: 'p1', type: 'vec3' },\n\t\t{ name: 'p2', type: 'vec3' },\n\t\t{ name: 'p3', type: 'vec3' }\n\t]\n} );\n\n// Mipped Bicubic Texture Filtering by N8\n// https://www.shadertoy.com/view/Dl2SDW\n\nconst bC = 1.0 / 6.0;\n\nconst w0 = ( a ) => mul( bC, mul( a, mul( a, a.negate().add( 3.0 ) ).sub( 3.0 ) ).add( 1.0 ) );\n\nconst w1 = ( a ) => mul( bC, mul( a, mul( a, mul( 3.0, a ).sub( 6.0 ) ) ).add( 4.0 ) );\n\nconst w2 = ( a ) => mul( bC, mul( a, mul( a, mul( - 3.0, a ).add( 3.0 ) ).add( 3.0 ) ).add( 1.0 ) );\n\nconst w3 = ( a ) => mul( bC, pow( a, 3 ) );\n\nconst g0 = ( a ) => w0( a ).add( w1( a ) );\n\nconst g1 = ( a ) => w2( a ).add( w3( a ) );\n\n// h0 and h1 are the two offset functions\nconst h0 = ( a ) => add( - 1.0, w1( a ).div( w0( a ).add( w1( a ) ) ) );\n\nconst h1 = ( a ) => add( 1.0, w3( a ).div( w2( a ).add( w3( a ) ) ) );\n\nconst bicubic = ( textureNode, texelSize, lod ) => {\n\n\tconst uv = textureNode.uvNode;\n\tconst uvScaled = mul( uv, texelSize.zw ).add( 0.5 );\n\n\tconst iuv = floor( uvScaled );\n\tconst fuv = fract( uvScaled );\n\n\tconst g0x = g0( fuv.x );\n\tconst g1x = g1( fuv.x );\n\tconst h0x = h0( fuv.x );\n\tconst h1x = h1( fuv.x );\n\tconst h0y = h0( fuv.y );\n\tconst h1y = h1( fuv.y );\n\n\tconst p0 = vec2( iuv.x.add( h0x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p1 = vec2( iuv.x.add( h1x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p2 = vec2( iuv.x.add( h0x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p3 = vec2( iuv.x.add( h1x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );\n\n\tconst a = g0( fuv.y ).mul( add( g0x.mul( textureNode.uv( p0 ).level( lod ) ), g1x.mul( textureNode.uv( p1 ).level( lod ) ) ) );\n\tconst b = g1( fuv.y ).mul( add( g0x.mul( textureNode.uv( p2 ).level( lod ) ), g1x.mul( textureNode.uv( p3 ).level( lod ) ) ) );\n\n\treturn a.add( b );\n\n};\n\nconst textureBicubic = /*@__PURE__*/ Fn( ( [ textureNode, lodNode = float( 3 ) ] ) => {\n\n\tconst fLodSize = vec2( textureNode.size( int( lodNode ) ) );\n\tconst cLodSize = vec2( textureNode.size( int( lodNode.add( 1.0 ) ) ) );\n\tconst fLodSizeInv = div( 1.0, fLodSize );\n\tconst cLodSizeInv = div( 1.0, cLodSize );\n\tconst fSample = bicubic( textureNode, vec4( fLodSizeInv, fLodSize ), floor( lodNode ) );\n\tconst cSample = bicubic( textureNode, vec4( cLodSizeInv, cLodSize ), ceil( lodNode ) );\n\n\treturn fract( lodNode ).mix( fSample, cSample );\n\n} );\n\n//\n// Transmission\n//\n\nconst getVolumeTransmissionRay = /*@__PURE__*/ Fn( ( [ n, v, thickness, ior, modelMatrix ] ) => {\n\n\t// Direction of refracted light.\n\tconst refractionVector = vec3( refract( v.negate(), normalize( n ), div( 1.0, ior ) ) );\n\n\t// Compute rotation-independant scaling of the model matrix.\n\tconst modelScale = vec3(\n\t\tlength( modelMatrix[ 0 ].xyz ),\n\t\tlength( modelMatrix[ 1 ].xyz ),\n\t\tlength( modelMatrix[ 2 ].xyz )\n\t);\n\n\t// The thickness is specified in local space.\n\treturn normalize( refractionVector ).mul( thickness.mul( modelScale ) );\n\n} ).setLayout( {\n\tname: 'getVolumeTransmissionRay',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'n', type: 'vec3' },\n\t\t{ name: 'v', type: 'vec3' },\n\t\t{ name: 'thickness', type: 'float' },\n\t\t{ name: 'ior', type: 'float' },\n\t\t{ name: 'modelMatrix', type: 'mat4' }\n\t]\n} );\n\nconst applyIorToRoughness = /*@__PURE__*/ Fn( ( [ roughness, ior ] ) => {\n\n\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\treturn roughness.mul( clamp( ior.mul( 2.0 ).sub( 2.0 ), 0.0, 1.0 ) );\n\n} ).setLayout( {\n\tname: 'applyIorToRoughness',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' },\n\t\t{ name: 'ior', type: 'float' }\n\t]\n} );\n\nconst viewportBackSideTexture = /*@__PURE__*/ viewportMipTexture();\nconst viewportFrontSideTexture = /*@__PURE__*/ viewportMipTexture();\n\nconst getTransmissionSample = /*@__PURE__*/ Fn( ( [ fragCoord, roughness, ior ], { material } ) => {\n\n\tconst vTexture = material.side == BackSide ? viewportBackSideTexture : viewportFrontSideTexture;\n\n\tconst transmissionSample = vTexture.uv( fragCoord );\n\t//const transmissionSample = viewportMipTexture( fragCoord );\n\n\tconst lod = log2( screenSize.x ).mul( applyIorToRoughness( roughness, ior ) );\n\n\treturn textureBicubic( transmissionSample, lod );\n\n} );\n\nconst volumeAttenuation = /*@__PURE__*/ Fn( ( [ transmissionDistance, attenuationColor, attenuationDistance ] ) => {\n\n\tIf( attenuationDistance.notEqual( 0 ), () => {\n\n\t\t// Compute light attenuation using Beer's law.\n\t\tconst attenuationCoefficient = log( attenuationColor ).negate().div( attenuationDistance );\n\t\tconst transmittance = exp( attenuationCoefficient.negate().mul( transmissionDistance ) );\n\n\t\treturn transmittance;\n\n\t} );\n\n\t// Attenuation distance is +, i.e. the transmitted color is not attenuated at all.\n\treturn vec3( 1.0 );\n\n} ).setLayout( {\n\tname: 'volumeAttenuation',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'transmissionDistance', type: 'float' },\n\t\t{ name: 'attenuationColor', type: 'vec3' },\n\t\t{ name: 'attenuationDistance', type: 'float' }\n\t]\n} );\n\nconst getIBLVolumeRefraction = /*@__PURE__*/ Fn( ( [ n, v, roughness, diffuseColor, specularColor, specularF90, position, modelMatrix, viewMatrix, projMatrix, ior, thickness, attenuationColor, attenuationDistance, dispersion ] ) => {\n\n\tlet transmittedLight, transmittance;\n\n\tif ( dispersion ) {\n\n\t\ttransmittedLight = vec4().toVar();\n\t\ttransmittance = vec3().toVar();\n\n\t\tconst halfSpread = ior.sub( 1.0 ).mul( dispersion.mul( 0.025 ) );\n\t\tconst iors = vec3( ior.sub( halfSpread ), ior, ior.add( halfSpread ) );\n\n\t\tLoop( { start: 0, end: 3 }, ( { i } ) => {\n\n\t\t\tconst ior = iors.element( i );\n\n\t\t\tconst transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tconst refractedRayExit = position.add( transmissionRay );\n\n\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\tconst ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );\n\t\t\tconst refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();\n\t\t\trefractionCoords.addAssign( 1.0 );\n\t\t\trefractionCoords.divAssign( 2.0 );\n\t\t\trefractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu\n\n\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\tconst transmissionSample = getTransmissionSample( refractionCoords, roughness, ior );\n\n\t\t\ttransmittedLight.element( i ).assign( transmissionSample.element( i ) );\n\t\t\ttransmittedLight.a.addAssign( transmissionSample.a );\n\n\t\t\ttransmittance.element( i ).assign( diffuseColor.element( i ).mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ).element( i ) ) );\n\n\t\t} );\n\n\t\ttransmittedLight.a.divAssign( 3.0 );\n\n\t} else {\n\n\t\tconst transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tconst refractedRayExit = position.add( transmissionRay );\n\n\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\tconst ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );\n\t\tconst refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();\n\t\trefractionCoords.addAssign( 1.0 );\n\t\trefractionCoords.divAssign( 2.0 );\n\t\trefractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu\n\n\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\ttransmittance = diffuseColor.mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ) );\n\n\t}\n\n\tconst attenuatedColor = transmittance.rgb.mul( transmittedLight.rgb );\n\tconst dotNV = n.dot( v ).clamp();\n\n\t// Get the specular component.\n\tconst F = vec3( EnvironmentBRDF( { // n, v, specularColor, specularF90, roughness\n\t\tdotNV,\n\t\tspecularColor,\n\t\tspecularF90,\n\t\troughness\n\t} ) );\n\n\t// As less light is transmitted, the opacity should be increased. This simple approximation does a decent job\n\t// of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.\n\tconst transmittanceFactor = transmittance.r.add( transmittance.g, transmittance.b ).div( 3.0 );\n\n\treturn vec4( F.oneMinus().mul( attenuatedColor ), transmittedLight.a.oneMinus().mul( transmittanceFactor ).oneMinus() );\n\n} );\n\n//\n// Iridescence\n//\n\n// XYZ to linear-sRGB color space\nconst XYZ_TO_REC709 = /*@__PURE__*/ mat3(\n\t3.2404542, - 0.9692660, 0.0556434,\n\t- 1.5371385, 1.8760108, - 0.2040259,\n\t- 0.4985314, 0.0415560, 1.0572252\n);\n\n// Assume air interface for top\n// Note: We don't handle the case fresnel0 == 1\nconst Fresnel0ToIor = ( fresnel0 ) => {\n\n\tconst sqrtF0 = fresnel0.sqrt();\n\treturn vec3( 1.0 ).add( sqrtF0 ).div( vec3( 1.0 ).sub( sqrtF0 ) );\n\n};\n\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nconst IorToFresnel0 = ( transmittedIor, incidentIor ) => {\n\n\treturn transmittedIor.sub( incidentIor ).div( transmittedIor.add( incidentIor ) ).pow2();\n\n};\n\n// Fresnel equations for dielectric/dielectric interfaces.\n// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n// Evaluation XYZ sensitivity curves in Fourier space\nconst evalSensitivity = ( OPD, shift ) => {\n\n\tconst phase = OPD.mul( 2.0 * Math.PI * 1.0e-9 );\n\tconst val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\tconst pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\tconst VAR = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\tconst x = float( 9.7470e-14 * Math.sqrt( 2.0 * Math.PI * 4.5282e+09 ) ).mul( phase.mul( 2.2399e+06 ).add( shift.x ).cos() ).mul( phase.pow2().mul( - 4.5282e+09 ).exp() );\n\n\tlet xyz = val.mul( VAR.mul( 2.0 * Math.PI ).sqrt() ).mul( pos.mul( phase ).add( shift ).cos() ).mul( phase.pow2().negate().mul( VAR ).exp() );\n\txyz = vec3( xyz.x.add( x ), xyz.y, xyz.z ).div( 1.0685e-7 );\n\n\tconst rgb = XYZ_TO_REC709.mul( xyz );\n\n\treturn rgb;\n\n};\n\nconst evalIridescence = /*@__PURE__*/ Fn( ( { outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 } ) => {\n\n\t// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\n\tconst iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t// Evaluate the cosTheta on the base layer (Snell law)\n\tconst sinTheta2Sq = outsideIOR.div( iridescenceIOR ).pow2().mul( cosTheta1.pow2().oneMinus() );\n\n\t// Handle TIR:\n\tconst cosTheta2Sq = sinTheta2Sq.oneMinus();\n\n\tIf( cosTheta2Sq.lessThan( 0 ), () => {\n\n\t\treturn vec3( 1.0 );\n\n\t} );\n\n\tconst cosTheta2 = cosTheta2Sq.sqrt();\n\n\t// First interface\n\tconst R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\tconst R12 = F_Schlick( { f0: R0, f90: 1.0, dotVH: cosTheta1 } );\n\t//const R21 = R12;\n\tconst T121 = R12.oneMinus();\n\tconst phi12 = iridescenceIOR.lessThan( outsideIOR ).select( Math.PI, 0.0 );\n\tconst phi21 = float( Math.PI ).sub( phi12 );\n\n\t// Second interface\n\tconst baseIOR = Fresnel0ToIor( baseF0.clamp( 0.0, 0.9999 ) ); // guard against 1.0\n\tconst R1 = IorToFresnel0( baseIOR, iridescenceIOR.toVec3() );\n\tconst R23 = F_Schlick( { f0: R1, f90: 1.0, dotVH: cosTheta2 } );\n\tconst phi23 = vec3(\n\t\tbaseIOR.x.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),\n\t\tbaseIOR.y.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),\n\t\tbaseIOR.z.lessThan( iridescenceIOR ).select( Math.PI, 0.0 )\n\t);\n\n\t// Phase shift\n\tconst OPD = iridescenceIOR.mul( thinFilmThickness, cosTheta2, 2.0 );\n\tconst phi = vec3( phi21 ).add( phi23 );\n\n\t// Compound terms\n\tconst R123 = R12.mul( R23 ).clamp( 1e-5, 0.9999 );\n\tconst r123 = R123.sqrt();\n\tconst Rs = T121.pow2().mul( R23 ).div( vec3( 1.0 ).sub( R123 ) );\n\n\t// Reflectance term for m = 0 (DC term amplitude)\n\tconst C0 = R12.add( Rs );\n\tconst I = C0.toVar();\n\n\t// Reflectance term for m > 0 (pairs of diracs)\n\tconst Cm = Rs.sub( T121 ).toVar();\n\n\tLoop( { start: 1, end: 2, condition: '<=', name: 'm' }, ( { m } ) => {\n\n\t\tCm.mulAssign( r123 );\n\t\tconst Sm = evalSensitivity( float( m ).mul( OPD ), float( m ).mul( phi ) ).mul( 2.0 );\n\t\tI.addAssign( Cm.mul( Sm ) );\n\n\t} );\n\n\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\treturn I.max( vec3( 0.0 ) );\n\n} ).setLayout( {\n\tname: 'evalIridescence',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'outsideIOR', type: 'float' },\n\t\t{ name: 'eta2', type: 'float' },\n\t\t{ name: 'cosTheta1', type: 'float' },\n\t\t{ name: 'thinFilmThickness', type: 'float' },\n\t\t{ name: 'baseF0', type: 'vec3' }\n\t]\n} );\n\n//\n//\tSheen\n//\n\n// This is a curve-fit approxmation to the \"Charlie sheen\" BRDF integrated over the hemisphere from\n// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\". The analysis can be found\n// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nconst IBLSheenBRDF = /*@__PURE__*/ Fn( ( { normal, viewDir, roughness } ) => {\n\n\tconst dotNV = normal.dot( viewDir ).saturate();\n\n\tconst r2 = roughness.pow2();\n\n\tconst a = select(\n\t\troughness.lessThan( 0.25 ),\n\t\tfloat( - 339.2 ).mul( r2 ).add( float( 161.4 ).mul( roughness ) ).sub( 25.9 ),\n\t\tfloat( - 8.48 ).mul( r2 ).add( float( 14.3 ).mul( roughness ) ).sub( 9.95 )\n\t);\n\n\tconst b = select(\n\t\troughness.lessThan( 0.25 ),\n\t\tfloat( 44.0 ).mul( r2 ).sub( float( 23.7 ).mul( roughness ) ).add( 3.26 ),\n\t\tfloat( 1.97 ).mul( r2 ).sub( float( 3.27 ).mul( roughness ) ).add( 0.72 )\n\t);\n\n\tconst DG = select( roughness.lessThan( 0.25 ), 0.0, float( 0.1 ).mul( roughness ).sub( 0.025 ) ).add( a.mul( dotNV ).add( b ).exp() );\n\n\treturn DG.mul( 1.0 / Math.PI ).saturate();\n\n} );\n\nconst clearcoatF0 = vec3( 0.04 );\nconst clearcoatF90 = float( 1 );\n\n//\n\nclass PhysicalLightingModel extends LightingModel {\n\n\tconstructor( clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false ) {\n\n\t\tsuper();\n\n\t\tthis.clearcoat = clearcoat;\n\t\tthis.sheen = sheen;\n\t\tthis.iridescence = iridescence;\n\t\tthis.anisotropy = anisotropy;\n\t\tthis.transmission = transmission;\n\t\tthis.dispersion = dispersion;\n\n\t\tthis.clearcoatRadiance = null;\n\t\tthis.clearcoatSpecularDirect = null;\n\t\tthis.clearcoatSpecularIndirect = null;\n\t\tthis.sheenSpecularDirect = null;\n\t\tthis.sheenSpecularIndirect = null;\n\t\tthis.iridescenceFresnel = null;\n\t\tthis.iridescenceF0 = null;\n\n\t}\n\n\tstart( context ) {\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tthis.clearcoatRadiance = vec3().toVar( 'clearcoatRadiance' );\n\t\t\tthis.clearcoatSpecularDirect = vec3().toVar( 'clearcoatSpecularDirect' );\n\t\t\tthis.clearcoatSpecularIndirect = vec3().toVar( 'clearcoatSpecularIndirect' );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularDirect = vec3().toVar( 'sheenSpecularDirect' );\n\t\t\tthis.sheenSpecularIndirect = vec3().toVar( 'sheenSpecularIndirect' );\n\n\t\t}\n\n\t\tif ( this.iridescence === true ) {\n\n\t\t\tconst dotNVi = transformedNormalView.dot( positionViewDirection ).clamp();\n\n\t\t\tthis.iridescenceFresnel = evalIridescence( {\n\t\t\t\toutsideIOR: float( 1.0 ),\n\t\t\t\teta2: iridescenceIOR,\n\t\t\t\tcosTheta1: dotNVi,\n\t\t\t\tthinFilmThickness: iridescenceThickness,\n\t\t\t\tbaseF0: specularColor\n\t\t\t} );\n\n\t\t\tthis.iridescenceF0 = Schlick_to_F0( { f: this.iridescenceFresnel, f90: 1.0, dotVH: dotNVi } );\n\n\t\t}\n\n\t\tif ( this.transmission === true ) {\n\n\t\t\tconst position = positionWorld;\n\t\t\tconst v = cameraPosition.sub( positionWorld ).normalize(); // TODO: Create Node for this, same issue in MaterialX\n\t\t\tconst n = transformedNormalWorld;\n\n\t\t\tcontext.backdrop = getIBLVolumeRefraction(\n\t\t\t\tn,\n\t\t\t\tv,\n\t\t\t\troughness,\n\t\t\t\tdiffuseColor,\n\t\t\t\tspecularColor,\n\t\t\t\tspecularF90, // specularF90\n\t\t\t\tposition, // positionWorld\n\t\t\t\tmodelWorldMatrix, // modelMatrix\n\t\t\t\tcameraViewMatrix, // viewMatrix\n\t\t\t\tcameraProjectionMatrix, // projMatrix\n\t\t\t\tior,\n\t\t\t\tthickness,\n\t\t\t\tattenuationColor,\n\t\t\t\tattenuationDistance,\n\t\t\t\tthis.dispersion ? dispersion : null\n\t\t\t);\n\n\t\t\tcontext.backdropAlpha = transmission;\n\n\t\t\tdiffuseColor.a.mulAssign( mix( 1, context.backdrop.a, transmission ) );\n\n\t\t}\n\n\t}\n\n\t// Fdez-Agera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n\t// Approximates multiscattering in order to preserve energy.\n\t// http://www.jcgt.org/published/0008/01/03/\n\n\tcomputeMultiscattering( singleScatter, multiScatter, specularF90 ) {\n\n\t\tconst dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\n\t\tconst fab = DFGApprox( { roughness, dotNV } );\n\n\t\tconst Fr = this.iridescenceF0 ? iridescence.mix( specularColor, this.iridescenceF0 ) : specularColor;\n\n\t\tconst FssEss = Fr.mul( fab.x ).add( specularF90.mul( fab.y ) );\n\n\t\tconst Ess = fab.x.add( fab.y );\n\t\tconst Ems = Ess.oneMinus();\n\n\t\tconst Favg = specularColor.add( specularColor.oneMinus().mul( 0.047619 ) ); // 1/21\n\t\tconst Fms = FssEss.mul( Favg ).div( Ems.mul( Favg ).oneMinus() );\n\n\t\tsingleScatter.addAssign( FssEss );\n\t\tmultiScatter.addAssign( Fms.mul( Ems ) );\n\n\t}\n\n\tdirect( { lightDirection, lightColor, reflectedLight } ) {\n\n\t\tconst dotNL = transformedNormalView.dot( lightDirection ).clamp();\n\t\tconst irradiance = dotNL.mul( lightColor );\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularDirect.addAssign( irradiance.mul( BRDF_Sheen( { lightDirection } ) ) );\n\n\t\t}\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNLcc = transformedClearcoatNormalView.dot( lightDirection ).clamp();\n\t\t\tconst ccIrradiance = dotNLcc.mul( lightColor );\n\n\t\t\tthis.clearcoatSpecularDirect.addAssign( ccIrradiance.mul( BRDF_GGX( { lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: transformedClearcoatNormalView } ) ) );\n\n\t\t}\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t\treflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_GGX( { lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy } ) ) );\n\n\t}\n\n\tdirectRectArea( { lightColor, lightPosition, halfWidth, halfHeight, reflectedLight, ltc_1, ltc_2 } ) {\n\n\t\tconst p0 = lightPosition.add( halfWidth ).sub( halfHeight ); // counterclockwise; light shines in local neg z direction\n\t\tconst p1 = lightPosition.sub( halfWidth ).sub( halfHeight );\n\t\tconst p2 = lightPosition.sub( halfWidth ).add( halfHeight );\n\t\tconst p3 = lightPosition.add( halfWidth ).add( halfHeight );\n\n\t\tconst N = transformedNormalView;\n\t\tconst V = positionViewDirection;\n\t\tconst P = positionView.toVar();\n\n\t\tconst uv = LTC_Uv( { N, V, roughness } );\n\n\t\tconst t1 = ltc_1.uv( uv ).toVar();\n\t\tconst t2 = ltc_2.uv( uv ).toVar();\n\n\t\tconst mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3( 0, 1, 0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t).toVar();\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tconst fresnel = specularColor.mul( t2.x ).add( specularColor.oneMinus().mul( t2.y ) ).toVar();\n\n\t\treflectedLight.directSpecular.addAssign( lightColor.mul( fresnel ).mul( LTC_Evaluate( { N, V, P, mInv, p0, p1, p2, p3 } ) ) );\n\n\t\treflectedLight.directDiffuse.addAssign( lightColor.mul( diffuseColor ).mul( LTC_Evaluate( { N, V, P, mInv: mat3( 1, 0, 0, 0, 1, 0, 0, 0, 1 ), p0, p1, p2, p3 } ) ) );\n\n\t}\n\n\tindirect( context, stack, builder ) {\n\n\t\tthis.indirectDiffuse( context, stack, builder );\n\t\tthis.indirectSpecular( context, stack, builder );\n\t\tthis.ambientOcclusion( context, stack, builder );\n\n\t}\n\n\tindirectDiffuse( { irradiance, reflectedLight } ) {\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t}\n\n\tindirectSpecular( { radiance, iblIrradiance, reflectedLight } ) {\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularIndirect.addAssign( iblIrradiance.mul(\n\t\t\t\tsheen,\n\t\t\t\tIBLSheenBRDF( {\n\t\t\t\t\tnormal: transformedNormalView,\n\t\t\t\t\tviewDir: positionViewDirection,\n\t\t\t\t\troughness: sheenRoughness\n\t\t\t\t} )\n\t\t\t) );\n\n\t\t}\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();\n\n\t\t\tconst clearcoatEnv = EnvironmentBRDF( {\n\t\t\t\tdotNV: dotNVcc,\n\t\t\t\tspecularColor: clearcoatF0,\n\t\t\t\tspecularF90: clearcoatF90,\n\t\t\t\troughness: clearcoatRoughness\n\t\t\t} );\n\n\t\t\tthis.clearcoatSpecularIndirect.addAssign( this.clearcoatRadiance.mul( clearcoatEnv ) );\n\n\t\t}\n\n\t\t// Both indirect specular and indirect diffuse light accumulate here\n\n\t\tconst singleScattering = vec3().toVar( 'singleScattering' );\n\t\tconst multiScattering = vec3().toVar( 'multiScattering' );\n\t\tconst cosineWeightedIrradiance = iblIrradiance.mul( 1 / Math.PI );\n\n\t\tthis.computeMultiscattering( singleScattering, multiScattering, specularF90 );\n\n\t\tconst totalScattering = singleScattering.add( multiScattering );\n\n\t\tconst diffuse = diffuseColor.mul( totalScattering.r.max( totalScattering.g ).max( totalScattering.b ).oneMinus() );\n\n\t\treflectedLight.indirectSpecular.addAssign( radiance.mul( singleScattering ) );\n\t\treflectedLight.indirectSpecular.addAssign( multiScattering.mul( cosineWeightedIrradiance ) );\n\n\t\treflectedLight.indirectDiffuse.addAssign( diffuse.mul( cosineWeightedIrradiance ) );\n\n\t}\n\n\tambientOcclusion( { ambientOcclusion, reflectedLight } ) {\n\n\t\tconst dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\n\t\tconst aoNV = dotNV.add( ambientOcclusion );\n\t\tconst aoExp = roughness.mul( - 16.0 ).oneMinus().negate().exp2();\n\n\t\tconst aoNode = ambientOcclusion.sub( aoNV.pow( aoExp ).oneMinus() ).clamp();\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tthis.clearcoatSpecularIndirect.mulAssign( ambientOcclusion );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularIndirect.mulAssign( ambientOcclusion );\n\n\t\t}\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\t\treflectedLight.indirectSpecular.mulAssign( aoNode );\n\n\t}\n\n\tfinish( context ) {\n\n\t\tconst { outgoingLight } = context;\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();\n\n\t\t\tconst Fcc = F_Schlick( {\n\t\t\t\tdotVH: dotNVcc,\n\t\t\t\tf0: clearcoatF0,\n\t\t\t\tf90: clearcoatF90\n\t\t\t} );\n\n\t\t\tconst clearcoatLight = outgoingLight.mul( clearcoat.mul( Fcc ).oneMinus() ).add( this.clearcoatSpecularDirect.add( this.clearcoatSpecularIndirect ).mul( clearcoat ) );\n\n\t\t\toutgoingLight.assign( clearcoatLight );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tconst sheenEnergyComp = sheen.r.max( sheen.g ).max( sheen.b ).mul( 0.157 ).oneMinus();\n\t\t\tconst sheenLight = outgoingLight.mul( sheenEnergyComp ).add( this.sheenSpecularDirect, this.sheenSpecularIndirect );\n\n\t\t\toutgoingLight.assign( sheenLight );\n\n\t\t}\n\n\t}\n\n}\n\n// These defines must match with PMREMGenerator\n\nconst cubeUV_r0 = /*@__PURE__*/ float( 1.0 );\nconst cubeUV_m0 = /*@__PURE__*/ float( - 2.0 );\nconst cubeUV_r1 = /*@__PURE__*/ float( 0.8 );\nconst cubeUV_m1 = /*@__PURE__*/ float( - 1.0 );\nconst cubeUV_r4 = /*@__PURE__*/ float( 0.4 );\nconst cubeUV_m4 = /*@__PURE__*/ float( 2.0 );\nconst cubeUV_r5 = /*@__PURE__*/ float( 0.305 );\nconst cubeUV_m5 = /*@__PURE__*/ float( 3.0 );\nconst cubeUV_r6 = /*@__PURE__*/ float( 0.21 );\nconst cubeUV_m6 = /*@__PURE__*/ float( 4.0 );\n\nconst cubeUV_minMipLevel = /*@__PURE__*/ float( 4.0 );\nconst cubeUV_minTileSize = /*@__PURE__*/ float( 16.0 );\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized ).\n\nconst getFace = /*@__PURE__*/ Fn( ( [ direction ] ) => {\n\n\tconst absDirection = vec3( abs( direction ) ).toVar();\n\tconst face = float( - 1.0 ).toVar();\n\n\tIf( absDirection.x.greaterThan( absDirection.z ), () => {\n\n\t\tIf( absDirection.x.greaterThan( absDirection.y ), () => {\n\n\t\t\tface.assign( select( direction.x.greaterThan( 0.0 ), 0.0, 3.0 ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tface.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );\n\n\t\t} );\n\n\t} ).Else( () => {\n\n\t\tIf( absDirection.z.greaterThan( absDirection.y ), () => {\n\n\t\t\tface.assign( select( direction.z.greaterThan( 0.0 ), 2.0, 5.0 ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tface.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );\n\n\t\t} );\n\n\t} );\n\n\treturn face;\n\n} ).setLayout( {\n\tname: 'getFace',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'direction', type: 'vec3' }\n\t]\n} );\n\n// RH coordinate system; PMREM face-indexing convention\nconst getUV = /*@__PURE__*/ Fn( ( [ direction, face ] ) => {\n\n\tconst uv = vec2().toVar();\n\n\tIf( face.equal( 0.0 ), () => {\n\n\t\tuv.assign( vec2( direction.z, direction.y ).div( abs( direction.x ) ) ); // pos x\n\n\t} ).ElseIf( face.equal( 1.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.z.negate() ).div( abs( direction.y ) ) ); // pos y\n\n\t} ).ElseIf( face.equal( 2.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.y ).div( abs( direction.z ) ) ); // pos z\n\n\t} ).ElseIf( face.equal( 3.0 ), () => {\n\n\t\tuv.assign( vec2( direction.z.negate(), direction.y ).div( abs( direction.x ) ) ); // neg x\n\n\t} ).ElseIf( face.equal( 4.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.z ).div( abs( direction.y ) ) ); // neg y\n\n\t} ).Else( () => {\n\n\t\tuv.assign( vec2( direction.x, direction.y ).div( abs( direction.z ) ) ); // neg z\n\n\t} );\n\n\treturn mul( 0.5, uv.add( 1.0 ) );\n\n} ).setLayout( {\n\tname: 'getUV',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'direction', type: 'vec3' },\n\t\t{ name: 'face', type: 'float' }\n\t]\n} );\n\nconst roughnessToMip = /*@__PURE__*/ Fn( ( [ roughness ] ) => {\n\n\tconst mip = float( 0.0 ).toVar();\n\n\tIf( roughness.greaterThanEqual( cubeUV_r1 ), () => {\n\n\t\tmip.assign( cubeUV_r0.sub( roughness ).mul( cubeUV_m1.sub( cubeUV_m0 ) ).div( cubeUV_r0.sub( cubeUV_r1 ) ).add( cubeUV_m0 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r4 ), () => {\n\n\t\tmip.assign( cubeUV_r1.sub( roughness ).mul( cubeUV_m4.sub( cubeUV_m1 ) ).div( cubeUV_r1.sub( cubeUV_r4 ) ).add( cubeUV_m1 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r5 ), () => {\n\n\t\tmip.assign( cubeUV_r4.sub( roughness ).mul( cubeUV_m5.sub( cubeUV_m4 ) ).div( cubeUV_r4.sub( cubeUV_r5 ) ).add( cubeUV_m4 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r6 ), () => {\n\n\t\tmip.assign( cubeUV_r5.sub( roughness ).mul( cubeUV_m6.sub( cubeUV_m5 ) ).div( cubeUV_r5.sub( cubeUV_r6 ) ).add( cubeUV_m5 ) );\n\n\t} ).Else( () => {\n\n\t\tmip.assign( float( - 2.0 ).mul( log2( mul( 1.16, roughness ) ) ) ); // 1.16 = 1.79^0.25\n\n\t} );\n\n\treturn mip;\n\n} ).setLayout( {\n\tname: 'roughnessToMip',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' }\n\t]\n} );\n\n// RH coordinate system; PMREM face-indexing convention\nconst getDirection = /*@__PURE__*/ Fn( ( [ uv_immutable, face ] ) => {\n\n\tconst uv = uv_immutable.toVar();\n\tuv.assign( mul( 2.0, uv ).sub( 1.0 ) );\n\tconst direction = vec3( uv, 1.0 ).toVar();\n\n\tIf( face.equal( 0.0 ), () => {\n\n\t\tdirection.assign( direction.zyx ); // ( 1, v, u ) pos x\n\n\t} ).ElseIf( face.equal( 1.0 ), () => {\n\n\t\tdirection.assign( direction.xzy );\n\t\tdirection.xz.mulAssign( - 1.0 ); // ( -u, 1, -v ) pos y\n\n\t} ).ElseIf( face.equal( 2.0 ), () => {\n\n\t\tdirection.x.mulAssign( - 1.0 ); // ( -u, v, 1 ) pos z\n\n\t} ).ElseIf( face.equal( 3.0 ), () => {\n\n\t\tdirection.assign( direction.zyx );\n\t\tdirection.xz.mulAssign( - 1.0 ); // ( -1, v, -u ) neg x\n\n\t} ).ElseIf( face.equal( 4.0 ), () => {\n\n\t\tdirection.assign( direction.xzy );\n\t\tdirection.xy.mulAssign( - 1.0 ); // ( -u, -1, v ) neg y\n\n\t} ).ElseIf( face.equal( 5.0 ), () => {\n\n\t\tdirection.z.mulAssign( - 1.0 ); // ( u, v, -1 ) neg zS\n\n\t} );\n\n\treturn direction;\n\n} ).setLayout( {\n\tname: 'getDirection',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'uv', type: 'vec2' },\n\t\t{ name: 'face', type: 'float' }\n\t]\n} );\n\n//\n\nconst textureCubeUV = /*@__PURE__*/ Fn( ( [ envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {\n\n\tconst roughness = float( roughness_immutable );\n\tconst sampleDir = vec3( sampleDir_immutable );\n\n\tconst mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\tconst mipF = fract( mip );\n\tconst mipInt = floor( mip );\n\tconst color0 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();\n\n\tIf( mipF.notEqual( 0.0 ), () => {\n\n\t\tconst color1 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt.add( 1.0 ), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();\n\n\t\tcolor0.assign( mix( color0, color1, mipF ) );\n\n\t} );\n\n\treturn color0;\n\n} );\n\nconst bilinearCubeUV = /*@__PURE__*/ Fn( ( [ envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {\n\n\tconst mipInt = float( mipInt_immutable ).toVar();\n\tconst direction = vec3( direction_immutable );\n\tconst face = float( getFace( direction ) ).toVar();\n\tconst filterInt = float( max$1( cubeUV_minMipLevel.sub( mipInt ), 0.0 ) ).toVar();\n\tmipInt.assign( max$1( mipInt, cubeUV_minMipLevel ) );\n\tconst faceSize = float( exp2( mipInt ) ).toVar();\n\tconst uv = vec2( getUV( direction, face ).mul( faceSize.sub( 2.0 ) ).add( 1.0 ) ).toVar();\n\n\tIf( face.greaterThan( 2.0 ), () => {\n\n\t\tuv.y.addAssign( faceSize );\n\t\tface.subAssign( 3.0 );\n\n\t} );\n\n\tuv.x.addAssign( face.mul( faceSize ) );\n\tuv.x.addAssign( filterInt.mul( mul( 3.0, cubeUV_minTileSize ) ) );\n\tuv.y.addAssign( mul( 4.0, exp2( CUBEUV_MAX_MIP ).sub( faceSize ) ) );\n\tuv.x.mulAssign( CUBEUV_TEXEL_WIDTH );\n\tuv.y.mulAssign( CUBEUV_TEXEL_HEIGHT );\n\n\treturn envMap.uv( uv ).grad( vec2(), vec2() ); // disable anisotropic filtering\n\n} );\n\nconst getSample = /*@__PURE__*/ Fn( ( { envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst cosTheta = cos( theta );\n\n\t// Rodrigues' axis-angle rotation\n\tconst sampleDirection = outputDirection.mul( cosTheta )\n\t\t.add( axis.cross( outputDirection ).mul( sin( theta ) ) )\n\t\t.add( axis.mul( axis.dot( outputDirection ).mul( cosTheta.oneMinus() ) ) );\n\n\treturn bilinearCubeUV( envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP );\n\n} );\n\nconst blur = /*@__PURE__*/ Fn( ( { n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst axis = vec3( select( latitudinal, poleAxis, cross( poleAxis, outputDirection ) ) ).toVar();\n\n\tIf( all( axis.equals( vec3( 0.0 ) ) ), () => {\n\n\t\taxis.assign( vec3( outputDirection.z, 0.0, outputDirection.x.negate() ) );\n\n\t} );\n\n\taxis.assign( normalize( axis ) );\n\n\tconst gl_FragColor = vec3().toVar();\n\tgl_FragColor.addAssign( weights.element( int( 0 ) ).mul( getSample( { theta: 0.0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\n\tLoop( { start: int( 1 ), end: n }, ( { i } ) => {\n\n\t\tIf( i.greaterThanEqual( samples ), () => {\n\n\t\t\tBreak();\n\n\t\t} );\n\n\t\tconst theta = float( dTheta.mul( float( i ) ) ).toVar();\n\t\tgl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta: theta.mul( - 1.0 ), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\t\tgl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\n\t} );\n\n\treturn vec4( gl_FragColor, 1 );\n\n} );\n\nlet _generator = null;\n\nconst _cache = new WeakMap();\n\nfunction _generateCubeUVSize( imageHeight ) {\n\n\tconst maxMip = Math.log2( imageHeight ) - 2;\n\n\tconst texelHeight = 1.0 / imageHeight;\n\n\tconst texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );\n\n\treturn { texelWidth, texelHeight, maxMip };\n\n}\n\nfunction _getPMREMFromTexture( texture ) {\n\n\tlet cacheTexture = _cache.get( texture );\n\n\tconst pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : - 1;\n\n\tif ( pmremVersion !== texture.pmremVersion ) {\n\n\t\tconst image = texture.image;\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tif ( isCubeMapReady( image ) ) {\n\n\t\t\t\tcacheTexture = _generator.fromCubemap( texture, cacheTexture );\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\tif ( isEquirectangularMapReady( image ) ) {\n\n\t\t\t\tcacheTexture = _generator.fromEquirectangular( texture, cacheTexture );\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcacheTexture.pmremVersion = texture.pmremVersion;\n\n\t\t_cache.set( texture, cacheTexture );\n\n\t}\n\n\treturn cacheTexture.texture;\n\n}\n\nclass PMREMNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PMREMNode';\n\n\t}\n\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis._value = value;\n\t\tthis._pmrem = null;\n\n\t\tthis.uvNode = uvNode;\n\t\tthis.levelNode = levelNode;\n\n\t\tthis._generator = null;\n\n\t\tconst defaultTexture = new Texture();\n\t\tdefaultTexture.isRenderTargetTexture = true;\n\n\t\tthis._texture = texture( defaultTexture );\n\n\t\tthis._width = uniform( 0 );\n\t\tthis._height = uniform( 0 );\n\t\tthis._maxMip = uniform( 0 );\n\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tset value( value ) {\n\n\t\tthis._value = value;\n\t\tthis._pmrem = null;\n\n\t}\n\n\tget value() {\n\n\t\treturn this._value;\n\n\t}\n\n\tupdateFromTexture( texture ) {\n\n\t\tconst cubeUVSize = _generateCubeUVSize( texture.image.height );\n\n\t\tthis._texture.value = texture;\n\t\tthis._width.value = cubeUVSize.texelWidth;\n\t\tthis._height.value = cubeUVSize.texelHeight;\n\t\tthis._maxMip.value = cubeUVSize.maxMip;\n\n\t}\n\n\tupdateBefore() {\n\n\t\tlet pmrem = this._pmrem;\n\n\t\tconst pmremVersion = pmrem ? pmrem.pmremVersion : - 1;\n\t\tconst texture = this._value;\n\n\t\tif ( pmremVersion !== texture.pmremVersion ) {\n\n\t\t\tif ( texture.isPMREMTexture === true ) {\n\n\t\t\t\tpmrem = texture;\n\n\t\t\t} else {\n\n\t\t\t\tpmrem = _getPMREMFromTexture( texture );\n\n\t\t\t}\n\n\t\t\tif ( pmrem !== null ) {\n\n\t\t\t\tthis._pmrem = pmrem;\n\n\t\t\t\tthis.updateFromTexture( pmrem );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( _generator === null ) {\n\n\t\t\t_generator = builder.createPMREMGenerator();\n\n\t\t}\n\n\t\t//\n\n\t\tthis.updateBefore( builder );\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( uvNode === null && builder.context.getUV ) {\n\n\t\t\tuvNode = builder.context.getUV( this );\n\n\t\t}\n\n\t\t//\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.renderer.coordinateSystem === WebGLCoordinateSystem && texture.isPMREMTexture !== true && texture.isRenderTargetTexture === true ) {\n\n\t\t\tuvNode = vec3( uvNode.x.negate(), uvNode.yz );\n\n\t\t}\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\t//\n\n\t\treturn textureCubeUV( this._texture, uvNode, levelNode, this._width, this._height, this._maxMip );\n\n\t}\n\n}\n\nfunction isCubeMapReady( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\tlet count = 0;\n\tconst length = 6;\n\n\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\tif ( image[ i ] !== undefined ) count ++;\n\n\t}\n\n\treturn count === length;\n\n\n}\n\nfunction isEquirectangularMapReady( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\treturn image.height > 0;\n\n}\n\nconst pmremTexture = /*@__PURE__*/ nodeProxy( PMREMNode );\n\nconst _envNodeCache = new WeakMap();\n\nclass EnvironmentNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'EnvironmentNode';\n\n\t}\n\n\tconstructor( envNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.envNode = envNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { material } = builder;\n\n\t\tlet envNode = this.envNode;\n\n\t\tif ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {\n\n\t\t\tconst value = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];\n\n\t\t\tlet cacheEnvNode = _envNodeCache.get( value );\n\n\t\t\tif ( cacheEnvNode === undefined ) {\n\n\t\t\t\tcacheEnvNode = pmremTexture( value );\n\n\t\t\t\t_envNodeCache.set( value, cacheEnvNode );\n\n\t\t\t}\n\n\t\t\tenvNode\t= cacheEnvNode;\n\n\t\t}\n\n\t\t//\n\n\t\tconst envMap = material.envMap;\n\t\tconst intensity = envMap ? reference( 'envMapIntensity', 'float', builder.material ) : reference( 'environmentIntensity', 'float', builder.scene ); // @TODO: Add materialEnvIntensity in MaterialNode\n\n\t\tconst useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;\n\t\tconst radianceNormalView = useAnisotropy ? transformedBentNormalView : transformedNormalView;\n\n\t\tconst radiance = envNode.context( createRadianceContext( roughness, radianceNormalView ) ).mul( intensity );\n\t\tconst irradiance = envNode.context( createIrradianceContext( transformedNormalWorld ) ).mul( Math.PI ).mul( intensity );\n\n\t\tconst isolateRadiance = cache( radiance );\n\t\tconst isolateIrradiance = cache( irradiance );\n\n\t\t//\n\n\t\tbuilder.context.radiance.addAssign( isolateRadiance );\n\n\t\tbuilder.context.iblIrradiance.addAssign( isolateIrradiance );\n\n\t\t//\n\n\t\tconst clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;\n\n\t\tif ( clearcoatRadiance ) {\n\n\t\t\tconst clearcoatRadianceContext = envNode.context( createRadianceContext( clearcoatRoughness, transformedClearcoatNormalView ) ).mul( intensity );\n\t\t\tconst isolateClearcoatRadiance = cache( clearcoatRadianceContext );\n\n\t\t\tclearcoatRadiance.addAssign( isolateClearcoatRadiance );\n\n\t\t}\n\n\t}\n\n}\n\nconst createRadianceContext = ( roughnessNode, normalViewNode ) => {\n\n\tlet reflectVec = null;\n\n\treturn {\n\t\tgetUV: () => {\n\n\t\t\tif ( reflectVec === null ) {\n\n\t\t\t\treflectVec = positionViewDirection.negate().reflect( normalViewNode );\n\n\t\t\t\t// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n\t\t\t\treflectVec = roughnessNode.mul( roughnessNode ).mix( reflectVec, normalViewNode ).normalize();\n\n\t\t\t\treflectVec = reflectVec.transformDirection( cameraViewMatrix );\n\n\t\t\t}\n\n\t\t\treturn reflectVec;\n\n\t\t},\n\t\tgetTextureLevel: () => {\n\n\t\t\treturn roughnessNode;\n\n\t\t}\n\t};\n\n};\n\nconst createIrradianceContext = ( normalWorldNode ) => {\n\n\treturn {\n\t\tgetUV: () => {\n\n\t\t\treturn normalWorldNode;\n\n\t\t},\n\t\tgetTextureLevel: () => {\n\n\t\t\treturn float( 1.0 );\n\n\t\t}\n\t};\n\n};\n\nconst _defaultValues$6 = /*@__PURE__*/ new MeshStandardMaterial();\n\nclass MeshStandardNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshStandardNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshStandardNodeMaterial = true;\n\n\t\tthis.lights = true;\n\n\t\tthis.emissiveNode = null;\n\n\t\tthis.metalnessNode = null;\n\t\tthis.roughnessNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$6 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupEnvironment( builder ) {\n\n\t\tlet envNode = super.setupEnvironment( builder );\n\n\t\tif ( envNode === null && builder.environmentNode ) {\n\n\t\t\tenvNode = builder.environmentNode;\n\n\t\t}\n\n\t\treturn envNode ? new EnvironmentNode( envNode ) : null;\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhysicalLightingModel();\n\n\t}\n\n\tsetupSpecular() {\n\n\t\tconst specularColorNode = mix( vec3( 0.04 ), diffuseColor.rgb, metalness );\n\n\t\tspecularColor.assign( specularColorNode );\n\t\tspecularF90.assign( 1.0 );\n\n\t}\n\n\tsetupVariants() {\n\n\t\t// METALNESS\n\n\t\tconst metalnessNode = this.metalnessNode ? float( this.metalnessNode ) : materialMetalness;\n\n\t\tmetalness.assign( metalnessNode );\n\n\t\t// ROUGHNESS\n\n\t\tlet roughnessNode = this.roughnessNode ? float( this.roughnessNode ) : materialRoughness;\n\t\troughnessNode = getRoughness( { roughness: roughnessNode } );\n\n\t\troughness.assign( roughnessNode );\n\n\t\t// SPECULAR COLOR\n\n\t\tthis.setupSpecular();\n\n\t\t// DIFFUSE COLOR\n\n\t\tdiffuseColor.assign( vec4( diffuseColor.rgb.mul( metalnessNode.oneMinus() ), diffuseColor.a ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.emissiveNode = source.emissiveNode;\n\n\t\tthis.metalnessNode = source.metalnessNode;\n\t\tthis.roughnessNode = source.roughnessNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst _defaultValues$5 = /*@__PURE__*/ new MeshPhysicalMaterial();\n\nclass MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshPhysicalNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhysicalNodeMaterial = true;\n\n\t\tthis.clearcoatNode = null;\n\t\tthis.clearcoatRoughnessNode = null;\n\t\tthis.clearcoatNormalNode = null;\n\n\t\tthis.sheenNode = null;\n\t\tthis.sheenRoughnessNode = null;\n\n\t\tthis.iridescenceNode = null;\n\t\tthis.iridescenceIORNode = null;\n\t\tthis.iridescenceThicknessNode = null;\n\n\t\tthis.specularIntensityNode = null;\n\t\tthis.specularColorNode = null;\n\n\t\tthis.iorNode = null;\n\t\tthis.transmissionNode = null;\n\t\tthis.thicknessNode = null;\n\t\tthis.attenuationDistanceNode = null;\n\t\tthis.attenuationColorNode = null;\n\t\tthis.dispersionNode = null;\n\n\t\tthis.anisotropyNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$5 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget useClearcoat() {\n\n\t\treturn this.clearcoat > 0 || this.clearcoatNode !== null;\n\n\t}\n\n\tget useIridescence() {\n\n\t\treturn this.iridescence > 0 || this.iridescenceNode !== null;\n\n\t}\n\n\tget useSheen() {\n\n\t\treturn this.sheen > 0 || this.sheenNode !== null;\n\n\t}\n\n\tget useAnisotropy() {\n\n\t\treturn this.anisotropy > 0 || this.anisotropyNode !== null;\n\n\t}\n\n\tget useTransmission() {\n\n\t\treturn this.transmission > 0 || this.transmissionNode !== null;\n\n\t}\n\n\tget useDispersion() {\n\n\t\treturn this.dispersion > 0 || this.dispersionNode !== null;\n\n\t}\n\n\tsetupSpecular() {\n\n\t\tconst iorNode = this.iorNode ? float( this.iorNode ) : materialIOR;\n\n\t\tior.assign( iorNode );\n\t\tspecularColor.assign( mix( min$1( pow2( ior.sub( 1.0 ).div( ior.add( 1.0 ) ) ).mul( materialSpecularColor ), vec3( 1.0 ) ).mul( materialSpecularIntensity ), diffuseColor.rgb, metalness ) );\n\t\tspecularF90.assign( mix( materialSpecularIntensity, 1.0, metalness ) );\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhysicalLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion );\n\n\t}\n\n\tsetupVariants( builder ) {\n\n\t\tsuper.setupVariants( builder );\n\n\t\t// CLEARCOAT\n\n\t\tif ( this.useClearcoat ) {\n\n\t\t\tconst clearcoatNode = this.clearcoatNode ? float( this.clearcoatNode ) : materialClearcoat;\n\t\t\tconst clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float( this.clearcoatRoughnessNode ) : materialClearcoatRoughness;\n\n\t\t\tclearcoat.assign( clearcoatNode );\n\t\t\tclearcoatRoughness.assign( getRoughness( { roughness: clearcoatRoughnessNode } ) );\n\n\t\t}\n\n\t\t// SHEEN\n\n\t\tif ( this.useSheen ) {\n\n\t\t\tconst sheenNode = this.sheenNode ? vec3( this.sheenNode ) : materialSheen;\n\t\t\tconst sheenRoughnessNode = this.sheenRoughnessNode ? float( this.sheenRoughnessNode ) : materialSheenRoughness;\n\n\t\t\tsheen.assign( sheenNode );\n\t\t\tsheenRoughness.assign( sheenRoughnessNode );\n\n\t\t}\n\n\t\t// IRIDESCENCE\n\n\t\tif ( this.useIridescence ) {\n\n\t\t\tconst iridescenceNode = this.iridescenceNode ? float( this.iridescenceNode ) : materialIridescence;\n\t\t\tconst iridescenceIORNode = this.iridescenceIORNode ? float( this.iridescenceIORNode ) : materialIridescenceIOR;\n\t\t\tconst iridescenceThicknessNode = this.iridescenceThicknessNode ? float( this.iridescenceThicknessNode ) : materialIridescenceThickness;\n\n\t\t\tiridescence.assign( iridescenceNode );\n\t\t\tiridescenceIOR.assign( iridescenceIORNode );\n\t\t\tiridescenceThickness.assign( iridescenceThicknessNode );\n\n\t\t}\n\n\t\t// ANISOTROPY\n\n\t\tif ( this.useAnisotropy ) {\n\n\t\t\tconst anisotropyV = ( this.anisotropyNode ? vec2( this.anisotropyNode ) : materialAnisotropy ).toVar();\n\n\t\t\tanisotropy.assign( anisotropyV.length() );\n\n\t\t\tIf( anisotropy.equal( 0.0 ), () => {\n\n\t\t\t\tanisotropyV.assign( vec2( 1.0, 0.0 ) );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tanisotropyV.divAssign( vec2( anisotropy ) );\n\t\t\t\tanisotropy.assign( anisotropy.saturate() );\n\n\t\t\t} );\n\n\t\t\t// Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.\n\t\t\talphaT.assign( anisotropy.pow2().mix( roughness.pow2(), 1.0 ) );\n\n\t\t\tanisotropyT.assign( TBNViewMatrix[ 0 ].mul( anisotropyV.x ).add( TBNViewMatrix[ 1 ].mul( anisotropyV.y ) ) );\n\t\t\tanisotropyB.assign( TBNViewMatrix[ 1 ].mul( anisotropyV.x ).sub( TBNViewMatrix[ 0 ].mul( anisotropyV.y ) ) );\n\n\t\t}\n\n\t\t// TRANSMISSION\n\n\t\tif ( this.useTransmission ) {\n\n\t\t\tconst transmissionNode = this.transmissionNode ? float( this.transmissionNode ) : materialTransmission;\n\t\t\tconst thicknessNode = this.thicknessNode ? float( this.thicknessNode ) : materialThickness;\n\t\t\tconst attenuationDistanceNode = this.attenuationDistanceNode ? float( this.attenuationDistanceNode ) : materialAttenuationDistance;\n\t\t\tconst attenuationColorNode = this.attenuationColorNode ? vec3( this.attenuationColorNode ) : materialAttenuationColor;\n\n\t\t\ttransmission.assign( transmissionNode );\n\t\t\tthickness.assign( thicknessNode );\n\t\t\tattenuationDistance.assign( attenuationDistanceNode );\n\t\t\tattenuationColor.assign( attenuationColorNode );\n\n\t\t\tif ( this.useDispersion ) {\n\n\t\t\t\tconst dispersionNode = this.dispersionNode ? float( this.dispersionNode ) : materialDispersion;\n\n\t\t\t\tdispersion.assign( dispersionNode );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetupClearcoatNormal() {\n\n\t\treturn this.clearcoatNormalNode ? vec3( this.clearcoatNormalNode ) : materialClearcoatNormal;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.setupClearcoatNormal = () => this.setupClearcoatNormal( builder );\n\n\t\tsuper.setup( builder );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.clearcoatNode = source.clearcoatNode;\n\t\tthis.clearcoatRoughnessNode = source.clearcoatRoughnessNode;\n\t\tthis.clearcoatNormalNode = source.clearcoatNormalNode;\n\n\t\tthis.sheenNode = source.sheenNode;\n\t\tthis.sheenRoughnessNode = source.sheenRoughnessNode;\n\n\t\tthis.iridescenceNode = source.iridescenceNode;\n\t\tthis.iridescenceIORNode = source.iridescenceIORNode;\n\t\tthis.iridescenceThicknessNode = source.iridescenceThicknessNode;\n\n\t\tthis.specularIntensityNode = source.specularIntensityNode;\n\t\tthis.specularColorNode = source.specularColorNode;\n\n\t\tthis.transmissionNode = source.transmissionNode;\n\t\tthis.thicknessNode = source.thicknessNode;\n\t\tthis.attenuationDistanceNode = source.attenuationDistanceNode;\n\t\tthis.attenuationColorNode = source.attenuationColorNode;\n\t\tthis.dispersionNode = source.dispersionNode;\n\n\t\tthis.anisotropyNode = source.anisotropyNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nclass SSSLightingModel extends PhysicalLightingModel {\n\n\tconstructor( useClearcoat, useSheen, useIridescence, useSSS ) {\n\n\t\tsuper( useClearcoat, useSheen, useIridescence );\n\n\t\tthis.useSSS = useSSS;\n\n\t}\n\n\tdirect( { lightDirection, lightColor, reflectedLight }, stack, builder ) {\n\n\t\tif ( this.useSSS === true ) {\n\n\t\t\tconst material = builder.material;\n\n\t\t\tconst { thicknessColorNode, thicknessDistortionNode, thicknessAmbientNode, thicknessAttenuationNode, thicknessPowerNode, thicknessScaleNode } = material;\n\n\t\t\tconst scatteringHalf = lightDirection.add( transformedNormalView.mul( thicknessDistortionNode ) ).normalize();\n\t\t\tconst scatteringDot = float( positionViewDirection.dot( scatteringHalf.negate() ).saturate().pow( thicknessPowerNode ).mul( thicknessScaleNode ) );\n\t\t\tconst scatteringIllu = vec3( scatteringDot.add( thicknessAmbientNode ).mul( thicknessColorNode ) );\n\n\t\t\treflectedLight.directDiffuse.addAssign( scatteringIllu.mul( thicknessAttenuationNode.mul( lightColor ) ) );\n\n\t\t}\n\n\t\tsuper.direct( { lightDirection, lightColor, reflectedLight }, stack, builder );\n\n\t}\n\n}\n\nclass MeshSSSNodeMaterial extends MeshPhysicalNodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshSSSNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper( parameters );\n\n\t\tthis.thicknessColorNode = null;\n\t\tthis.thicknessDistortionNode = float( 0.1 );\n\t\tthis.thicknessAmbientNode = float( 0.0 );\n\t\tthis.thicknessAttenuationNode = float( .1 );\n\t\tthis.thicknessPowerNode = float( 2.0 );\n\t\tthis.thicknessScaleNode = float( 10.0 );\n\n\t}\n\n\tget useSSS() {\n\n\t\treturn this.thicknessColorNode !== null;\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new SSSLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useSSS );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.thicknessColorNode = source.thicknessColorNode;\n\t\tthis.thicknessDistortionNode = source.thicknessDistortionNode;\n\t\tthis.thicknessAmbientNode = source.thicknessAmbientNode;\n\t\tthis.thicknessAttenuationNode = source.thicknessAttenuationNode;\n\t\tthis.thicknessPowerNode = source.thicknessPowerNode;\n\t\tthis.thicknessScaleNode = source.thicknessScaleNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst getGradientIrradiance = /*@__PURE__*/ Fn( ( { normal, lightDirection, builder } ) => {\n\n\t// dotNL will be from -1.0 to 1.0\n\tconst dotNL = normal.dot( lightDirection );\n\tconst coord = vec2( dotNL.mul( 0.5 ).add( 0.5 ), 0.0 );\n\n\tif ( builder.material.gradientMap ) {\n\n\t\tconst gradientMap = materialReference( 'gradientMap', 'texture' ).context( { getUV: () => coord } );\n\n\t\treturn vec3( gradientMap.r );\n\n\t} else {\n\n\t\tconst fw = coord.fwidth().mul( 0.5 );\n\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( float( 0.7 ).sub( fw.x ), float( 0.7 ).add( fw.x ), coord.x ) );\n\n\t}\n\n} );\n\nclass ToonLightingModel extends LightingModel {\n\n\tdirect( { lightDirection, lightColor, reflectedLight }, stack, builder ) {\n\n\t\tconst irradiance = getGradientIrradiance( { normal: normalGeometry, lightDirection, builder } ).mul( lightColor );\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t}\n\n\tindirect( { ambientOcclusion, irradiance, reflectedLight } ) {\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t}\n\n}\n\nconst _defaultValues$4 = /*@__PURE__*/ new MeshToonMaterial();\n\nclass MeshToonNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshToonNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshToonNodeMaterial = true;\n\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$4 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new ToonLightingModel();\n\n\t}\n\n}\n\nclass MatcapUVNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'MatcapUVNode';\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t}\n\n\tsetup() {\n\n\t\tconst x = vec3( positionViewDirection.z, 0, positionViewDirection.x.negate() ).normalize();\n\t\tconst y = positionViewDirection.cross( x );\n\n\t\treturn vec2( x.dot( transformedNormalView ), y.dot( transformedNormalView ) ).mul( 0.495 ).add( 0.5 ); // 0.495 to remove artifacts caused by undersized matcap disks\n\n\t}\n\n}\n\nconst matcapUV = /*@__PURE__*/ nodeImmutable( MatcapUVNode );\n\nconst _defaultValues$3 = /*@__PURE__*/ new MeshMatcapMaterial();\n\nclass MeshMatcapNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshMatcapNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.lights = false;\n\n\t\tthis.isMeshMatcapNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$3 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupVariants( builder ) {\n\n\t\tconst uv = matcapUV;\n\n\t\tlet matcapColor;\n\n\t\tif ( builder.material.matcap ) {\n\n\t\t\tmatcapColor = materialReference( 'matcap', 'texture' ).context( { getUV: () => uv } );\n\n\t\t} else {\n\n\t\t\tmatcapColor = vec3( mix( 0.2, 0.8, uv.y ) ); // default if matcap is missing\n\n\t\t}\n\n\t\tdiffuseColor.rgb.mulAssign( matcapColor.rgb );\n\n\t}\n\n}\n\nconst _defaultValues$2 = /*@__PURE__*/ new PointsMaterial();\n\nclass PointsNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'PointsNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isPointsNodeMaterial = true;\n\n\t\tthis.lights = false;\n\t\tthis.transparent = true;\n\n\t\tthis.sizeNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$2 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.sizeNode = source.sizeNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nclass RotateNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'RotateNode';\n\n\t}\n\n\tconstructor( positionNode, rotationNode ) {\n\n\t\tsuper();\n\n\t\tthis.positionNode = positionNode;\n\t\tthis.rotationNode = rotationNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.positionNode.getNodeType( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { rotationNode, positionNode } = this;\n\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tif ( nodeType === 'vec2' ) {\n\n\t\t\tconst cosAngle = rotationNode.cos();\n\t\t\tconst sinAngle = rotationNode.sin();\n\n\t\t\tconst rotationMatrix = mat2(\n\t\t\t\tcosAngle, sinAngle,\n\t\t\t\tsinAngle.negate(), cosAngle\n\t\t\t);\n\n\t\t\treturn rotationMatrix.mul( positionNode );\n\n\t\t} else {\n\n\t\t\tconst rotation = rotationNode;\n\t\t\tconst rotationXMatrix = mat4( vec4( 1.0, 0.0, 0.0, 0.0 ), vec4( 0.0, cos( rotation.x ), sin( rotation.x ).negate(), 0.0 ), vec4( 0.0, sin( rotation.x ), cos( rotation.x ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\t\t\tconst rotationYMatrix = mat4( vec4( cos( rotation.y ), 0.0, sin( rotation.y ), 0.0 ), vec4( 0.0, 1.0, 0.0, 0.0 ), vec4( sin( rotation.y ).negate(), 0.0, cos( rotation.y ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\t\t\tconst rotationZMatrix = mat4( vec4( cos( rotation.z ), sin( rotation.z ).negate(), 0.0, 0.0 ), vec4( sin( rotation.z ), cos( rotation.z ), 0.0, 0.0 ), vec4( 0.0, 0.0, 1.0, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\n\t\t\treturn rotationXMatrix.mul( rotationYMatrix ).mul( rotationZMatrix ).mul( vec4( positionNode, 1.0 ) ).xyz;\n\n\t\t}\n\n\t}\n\n}\n\nconst rotate = /*@__PURE__*/ nodeProxy( RotateNode );\n\nconst _defaultValues$1 = /*@__PURE__*/ new SpriteMaterial();\n\nclass SpriteNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'SpriteNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isSpriteNodeMaterial = true;\n\n\t\tthis.lights = false;\n\t\tthis._useSizeAttenuation = true;\n\n\t\tthis.positionNode = null;\n\t\tthis.rotationNode = null;\n\t\tthis.scaleNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$1 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupPosition( { object, camera, context } ) {\n\n\t\tconst sizeAttenuation = this.sizeAttenuation;\n\n\t\t// < VERTEX STAGE >\n\n\t\tconst { positionNode, rotationNode, scaleNode } = this;\n\n\t\tconst vertex = positionLocal;\n\n\t\tlet mvPosition = modelViewMatrix.mul( vec3( positionNode || 0 ) );\n\n\t\tlet scale = vec2( modelWorldMatrix[ 0 ].xyz.length(), modelWorldMatrix[ 1 ].xyz.length() );\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tscale = scale.mul( scaleNode );\n\n\t\t}\n\n\n\t\tif ( ! sizeAttenuation ) {\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tscale = scale.mul( mvPosition.z.negate() );\n\n\t\t\t} else {\n\n\t\t\t\tconst orthoScale = float( 2.0 ).div( cameraProjectionMatrix.element( 1 ).element( 1 ) );\n\t\t\t\tscale = scale.mul( orthoScale.mul( 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet alignedPosition = vertex.xy;\n\n\t\tif ( object.center && object.center.isVector2 === true ) {\n\n\t\t\tconst center = reference$1( 'center', 'vec2' );\n\n\t\t\talignedPosition = alignedPosition.sub( center.sub( 0.5 ) );\n\n\t\t}\n\n\t\talignedPosition = alignedPosition.mul( scale );\n\n\t\tconst rotation = float( rotationNode || materialRotation );\n\n\t\tconst rotatedPosition = rotate( alignedPosition, rotation );\n\n\t\tmvPosition = vec4( mvPosition.xy.add( rotatedPosition ), mvPosition.zw );\n\n\t\tconst modelViewProjection = cameraProjectionMatrix.mul( mvPosition );\n\n\t\tcontext.vertex = vertex;\n\n\t\treturn modelViewProjection;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.positionNode = source.positionNode;\n\t\tthis.rotationNode = source.rotationNode;\n\t\tthis.scaleNode = source.scaleNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n\tget sizeAttenuation() {\n\n\t\treturn this._useSizeAttenuation;\n\n\t}\n\n\tset sizeAttenuation( value ) {\n\n\t\tif ( this._useSizeAttenuation !== value ) {\n\n\t\t\tthis._useSizeAttenuation = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass ShadowMaskModel extends LightingModel {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.shadowNode = float( 1 ).toVar( 'shadowMask' );\n\n\t}\n\n\tdirect( { shadowMask } ) {\n\n\t\tthis.shadowNode.mulAssign( shadowMask );\n\n\t}\n\n\tfinish( context ) {\n\n\t\tdiffuseColor.a.mulAssign( this.shadowNode.oneMinus() );\n\n\t\tcontext.outgoingLight.rgb.assign( diffuseColor.rgb ); // TODO: Optimize LightsNode to avoid this assignment\n\n\t}\n\n}\n\nconst _defaultValues = /*@__PURE__*/ new ShadowMaterial();\n\nclass ShadowNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'ShadowNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isShadowNodeMaterial = true;\n\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new ShadowMaskModel();\n\n\t}\n\n}\n\nconst normal = Fn( ( { texture, uv } ) => {\n\n\tconst epsilon = 0.0001;\n\n\tconst ret = vec3().toVar();\n\n\tIf( uv.x.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 1, 0, 0 ) );\n\n\t} ).ElseIf( uv.y.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 1, 0 ) );\n\n\t} ).ElseIf( uv.z.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 0, 1 ) );\n\n\t} ).ElseIf( uv.x.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( - 1, 0, 0 ) );\n\n\t} ).ElseIf( uv.y.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( 0, - 1, 0 ) );\n\n\t} ).ElseIf( uv.z.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 0, - 1 ) );\n\n\t} ).Else( () => {\n\n\t\tconst step = 0.01;\n\n\t\tconst x = texture.uv( uv.add( vec3( - step, 0.0, 0.0 ) ) ).r.sub( texture.uv( uv.add( vec3( step, 0.0, 0.0 ) ) ).r );\n\t\tconst y = texture.uv( uv.add( vec3( 0.0, - step, 0.0 ) ) ).r.sub( texture.uv( uv.add( vec3( 0.0, step, 0.0 ) ) ).r );\n\t\tconst z = texture.uv( uv.add( vec3( 0.0, 0.0, - step ) ) ).r.sub( texture.uv( uv.add( vec3( 0.0, 0.0, step ) ) ).r );\n\n\t\tret.assign( vec3( x, y, z ) );\n\n\t} );\n\n\treturn ret.normalize();\n\n} );\n\n\nclass Texture3DNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'Texture3DNode';\n\n\t}\n\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( value, uvNode, levelNode );\n\n\t\tthis.isTexture3DNode = true;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture3D';\n\n\t}\n\n\tgetDefaultUV() {\n\n\t\treturn vec3( 0.5, 0.5, 0.5 );\n\n\t}\n\n\tsetUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for 3d TextureNode\n\n\tsetupUV( builder, uvNode ) {\n\n\t\treturn uvNode;\n\n\t}\n\n\tgenerateUV( builder, uvNode ) {\n\n\t\treturn uvNode.build( builder, 'vec3' );\n\n\t}\n\n\tnormal( uvNode ) {\n\n\t\treturn normal( { texture: this, uv: uvNode } );\n\n\t}\n\n}\n\nconst texture3D = /*@__PURE__*/ nodeProxy( Texture3DNode );\n\nclass VolumeNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'VolumeNodeMaterial';\n\n\t}\n\n\tconstructor( params = {} ) {\n\n\t\tsuper();\n\n\t\tthis.lights = false;\n\t\tthis.isVolumeNodeMaterial = true;\n\t\tthis.testNode = null;\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst map = texture3D( this.map, null, 0 );\n\n\t\tconst hitBox = Fn( ( { orig, dir } ) => {\n\n\t\t\tconst box_min = vec3( - 0.5 );\n\t\t\tconst box_max = vec3( 0.5 );\n\n\t\t\tconst inv_dir = dir.reciprocal();\n\n\t\t\tconst tmin_tmp = box_min.sub( orig ).mul( inv_dir );\n\t\t\tconst tmax_tmp = box_max.sub( orig ).mul( inv_dir );\n\n\t\t\tconst tmin = min$1( tmin_tmp, tmax_tmp );\n\t\t\tconst tmax = max$1( tmin_tmp, tmax_tmp );\n\n\t\t\tconst t0 = max$1( tmin.x, max$1( tmin.y, tmin.z ) );\n\t\t\tconst t1 = min$1( tmax.x, min$1( tmax.y, tmax.z ) );\n\n\t\t\treturn vec2( t0, t1 );\n\n\t\t} );\n\n\t\tthis.fragmentNode = Fn( () => {\n\n\t\t\tconst vOrigin = varying( vec3( modelWorldMatrixInverse.mul( vec4( cameraPosition, 1.0 ) ) ) );\n\t\t\tconst vDirection = varying( positionGeometry.sub( vOrigin ) );\n\n\t\t\tconst rayDir = vDirection.normalize();\n\t\t\tconst bounds = vec2( hitBox( { orig: vOrigin, dir: rayDir } ) ).toVar();\n\n\t\t\tbounds.x.greaterThan( bounds.y ).discard();\n\n\t\t\tbounds.assign( vec2( max$1( bounds.x, 0.0 ), bounds.y ) );\n\n\t\t\tconst p = vec3( vOrigin.add( bounds.x.mul( rayDir ) ) ).toVar();\n\t\t\tconst inc = vec3( rayDir.abs().reciprocal() ).toVar();\n\t\t\tconst delta = float( min$1( inc.x, min$1( inc.y, inc.z ) ) ).toVar( 'delta' ); // used 'delta' name in loop\n\n\t\t\tdelta.divAssign( materialReference( 'steps', 'float' ) );\n\n\t\t\tconst ac = vec4( materialReference( 'base', 'color' ), 0.0 ).toVar();\n\n\t\t\tLoop( { type: 'float', start: bounds.x, end: bounds.y, update: '+= delta' }, () => {\n\n\t\t\t\tconst d = property( 'float', 'd' ).assign( map.uv( p.add( 0.5 ) ).r );\n\n\t\t\t\tif ( this.testNode !== null ) {\n\n\t\t\t\t\tthis.testNode( { map: map, mapValue: d, probe: p, finalColor: ac } ).append();\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// default to show surface of mesh\n\t\t\t\t\tac.a.assign( 1 );\n\t\t\t\t\tBreak();\n\n\t\t\t\t}\n\n\t\t\t\tp.addAssign( rayDir.mul( delta ) );\n\n\t\t\t} );\n\n\t\t\tac.a.equal( 0 ).discard();\n\n\t\t\treturn vec4( ac );\n\n\t\t} )();\n\n\t\tsuper.setup( builder );\n\n\t}\n\n}\n\nclass Animation {\n\n\tconstructor( nodes, info ) {\n\n\t\tthis.nodes = nodes;\n\t\tthis.info = info;\n\n\t\tthis._context = self;\n\t\tthis._animationLoop = null;\n\t\tthis._requestId = null;\n\n\t}\n\n\tstart() {\n\n\t\tconst update = ( time, frame ) => {\n\n\t\t\tthis._requestId = this._context.requestAnimationFrame( update );\n\n\t\t\tif ( this.info.autoReset === true ) this.info.reset();\n\n\t\t\tthis.nodes.nodeFrame.update();\n\n\t\t\tthis.info.frame = this.nodes.nodeFrame.frameId;\n\n\t\t\tif ( this._animationLoop !== null ) this._animationLoop( time, frame );\n\n\t\t};\n\n\t\tupdate();\n\n\t}\n\n\tstop() {\n\n\t\tthis._context.cancelAnimationFrame( this._requestId );\n\n\t\tthis._requestId = null;\n\n\t}\n\n\tsetAnimationLoop( callback ) {\n\n\t\tthis._animationLoop = callback;\n\n\t}\n\n\tsetContext( context ) {\n\n\t\tthis._context = context;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.stop();\n\n\t}\n\n}\n\nclass ChainMap {\n\n\tconstructor() {\n\n\t\tthis.weakMap = new WeakMap();\n\n\t}\n\n\tget( keys ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length; i ++ ) {\n\n\t\t\tmap = map.get( keys[ i ] );\n\n\t\t\tif ( map === undefined ) return undefined;\n\n\t\t}\n\n\t\treturn map.get( keys[ keys.length - 1 ] );\n\n\t}\n\n\tset( keys, value ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length; i ++ ) {\n\n\t\t\tconst key = keys[ i ];\n\n\t\t\tif ( map.has( key ) === false ) map.set( key, new WeakMap() );\n\n\t\t\tmap = map.get( key );\n\n\t\t}\n\n\t\treturn map.set( keys[ keys.length - 1 ], value );\n\n\t}\n\n\tdelete( keys ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length; i ++ ) {\n\n\t\t\tmap = map.get( keys[ i ] );\n\n\t\t\tif ( map === undefined ) return false;\n\n\t\t}\n\n\t\treturn map.delete( keys[ keys.length - 1 ] );\n\n\t}\n\n}\n\nlet _id$7 = 0;\n\nfunction getKeys( obj ) {\n\n\tconst keys = Object.keys( obj );\n\n\tlet proto = Object.getPrototypeOf( obj );\n\n\twhile ( proto ) {\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( proto );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( descriptors[ key ] !== undefined ) {\n\n\t\t\t\tconst descriptor = descriptors[ key ];\n\n\t\t\t\tif ( descriptor && typeof descriptor.get === 'function' ) {\n\n\t\t\t\t\tkeys.push( key );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tproto = Object.getPrototypeOf( proto );\n\n\t}\n\n\treturn keys;\n\n}\n\nclass RenderObject {\n\n\tconstructor( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext ) {\n\n\t\tthis._nodes = nodes;\n\t\tthis._geometries = geometries;\n\n\t\tthis.id = _id$7 ++;\n\n\t\tthis.renderer = renderer;\n\t\tthis.object = object;\n\t\tthis.material = material;\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\t\tthis.lightsNode = lightsNode;\n\t\tthis.context = renderContext;\n\n\t\tthis.geometry = object.geometry;\n\t\tthis.version = material.version;\n\n\t\tthis.drawRange = null;\n\n\t\tthis.attributes = null;\n\t\tthis.pipeline = null;\n\t\tthis.vertexBuffers = null;\n\t\tthis.drawParams = null;\n\n\t\tthis.bundle = null;\n\n\t\tthis.clippingContext = clippingContext;\n\t\tthis.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';\n\n\t\tthis.initialNodesCacheKey = this.getDynamicCacheKey();\n\t\tthis.initialCacheKey = this.getCacheKey();\n\n\t\tthis._nodeBuilderState = null;\n\t\tthis._bindings = null;\n\t\tthis._monitor = null;\n\n\t\tthis.onDispose = null;\n\n\t\tthis.isRenderObject = true;\n\n\t\tthis.onMaterialDispose = () => {\n\n\t\t\tthis.dispose();\n\n\t\t};\n\n\t\tthis.material.addEventListener( 'dispose', this.onMaterialDispose );\n\n\t}\n\n\tupdateClipping( parent ) {\n\n\t\tthis.clippingContext = parent;\n\n\t}\n\n\tget clippingNeedsUpdate() {\n\n\t\tif ( this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey ) return false;\n\n\t\tthis.clippingContextCacheKey = this.clippingContext.cacheKey;\n\n\t\treturn true;\n\n\t}\n\n\tget hardwareClippingPlanes() {\n\n\t\treturn this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;\n\n\t}\n\n\tgetNodeBuilderState() {\n\n\t\treturn this._nodeBuilderState || ( this._nodeBuilderState = this._nodes.getForRender( this ) );\n\n\t}\n\n\tgetMonitor() {\n\n\t\treturn this._monitor || ( this._monitor = this.getNodeBuilderState().monitor );\n\n\t}\n\n\tgetBindings() {\n\n\t\treturn this._bindings || ( this._bindings = this.getNodeBuilderState().createBindings() );\n\n\t}\n\n\tgetIndex() {\n\n\t\treturn this._geometries.getIndex( this );\n\n\t}\n\n\tgetIndirect() {\n\n\t\treturn this._geometries.getIndirect( this );\n\n\t}\n\n\tgetChainArray() {\n\n\t\treturn [ this.object, this.material, this.context, this.lightsNode ];\n\n\t}\n\n\tsetGeometry( geometry ) {\n\n\t\tthis.geometry = geometry;\n\t\tthis.attributes = null;\n\n\t}\n\n\tgetAttributes() {\n\n\t\tif ( this.attributes !== null ) return this.attributes;\n\n\t\tconst nodeAttributes = this.getNodeBuilderState().nodeAttributes;\n\t\tconst geometry = this.geometry;\n\n\t\tconst attributes = [];\n\t\tconst vertexBuffers = new Set();\n\n\t\tfor ( const nodeAttribute of nodeAttributes ) {\n\n\t\t\tconst attribute = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute( nodeAttribute.name );\n\n\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\tattributes.push( attribute );\n\n\t\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\t\tvertexBuffers.add( bufferAttribute );\n\n\t\t}\n\n\t\tthis.attributes = attributes;\n\t\tthis.vertexBuffers = Array.from( vertexBuffers.values() );\n\n\t\treturn attributes;\n\n\t}\n\n\tgetVertexBuffers() {\n\n\t\tif ( this.vertexBuffers === null ) this.getAttributes();\n\n\t\treturn this.vertexBuffers;\n\n\t}\n\n\tgetDrawParameters() {\n\n\t\tconst { object, material, geometry, group, drawRange } = this;\n\n\t\tconst drawParams = this.drawParams || ( this.drawParams = {\n\t\t\tvertexCount: 0,\n\t\t\tfirstVertex: 0,\n\t\t\tinstanceCount: 0,\n\t\t\tfirstInstance: 0\n\t\t} );\n\n\t\tconst index = this.getIndex();\n\t\tconst hasIndex = ( index !== null );\n\t\tconst instanceCount = geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.count > 1 ? object.count : 1 );\n\n\t\tif ( instanceCount === 0 ) return null;\n\n\t\tdrawParams.instanceCount = instanceCount;\n\n\t\tif ( object.isBatchedMesh === true ) return drawParams;\n\n\t\tlet rangeFactor = 1;\n\n\t\tif ( material.wireframe === true && ! object.isPoints && ! object.isLineSegments && ! object.isLine && ! object.isLineLoop ) {\n\n\t\t\trangeFactor = 2;\n\n\t\t}\n\n\t\tlet firstVertex = drawRange.start * rangeFactor;\n\t\tlet lastVertex = ( drawRange.start + drawRange.count ) * rangeFactor;\n\n\t\tif ( group !== null ) {\n\n\t\t\tfirstVertex = Math.max( firstVertex, group.start * rangeFactor );\n\t\t\tlastVertex = Math.min( lastVertex, ( group.start + group.count ) * rangeFactor );\n\n\t\t}\n\n\t\tconst position = geometry.attributes.position;\n\t\tlet itemCount = Infinity;\n\n\t\tif ( hasIndex ) {\n\n\t\t\titemCount = index.count;\n\n\t\t} else if ( position !== undefined && position !== null ) {\n\n\t\t\titemCount = position.count;\n\n\t\t}\n\n\t\tfirstVertex = Math.max( firstVertex, 0 );\n\t\tlastVertex = Math.min( lastVertex, itemCount );\n\n\t\tconst count = lastVertex - firstVertex;\n\n\t\tif ( count < 0 || count === Infinity ) return null;\n\n\t\tdrawParams.vertexCount = count;\n\t\tdrawParams.firstVertex = firstVertex;\n\n\t\treturn drawParams;\n\n\t}\n\n\tgetGeometryCacheKey() {\n\n\t\tconst { geometry } = this;\n\n\t\tlet cacheKey = '';\n\n\t\tfor ( const name of Object.keys( geometry.attributes ).sort() ) {\n\n\t\t\tconst attribute = geometry.attributes[ name ];\n\n\t\t\tcacheKey += name + ',';\n\n\t\t\tif ( attribute.data ) cacheKey += attribute.data.stride + ',';\n\t\t\tif ( attribute.offset ) cacheKey += attribute.offset + ',';\n\t\t\tif ( attribute.itemSize ) cacheKey += attribute.itemSize + ',';\n\t\t\tif ( attribute.normalized ) cacheKey += 'n,';\n\n\t\t}\n\n\t\tif ( geometry.index ) {\n\n\t\t\tcacheKey += 'index,';\n\n\t\t}\n\n\t\treturn cacheKey;\n\n\t}\n\n\tgetMaterialCacheKey() {\n\n\t\tconst { object, material } = this;\n\n\t\tlet cacheKey = material.customProgramCacheKey();\n\n\t\tfor ( const property of getKeys( material ) ) {\n\n\t\t\tif ( /^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test( property ) ) continue;\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tlet valueKey;\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\t// some material values require a formatting\n\n\t\t\t\tconst type = typeof value;\n\n\t\t\t\tif ( type === 'number' ) {\n\n\t\t\t\t\tvalueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc\n\n\t\t\t\t} else if ( type === 'object' ) {\n\n\t\t\t\t\tvalueKey = '{';\n\n\t\t\t\t\tif ( value.isTexture ) {\n\n\t\t\t\t\t\tvalueKey += value.mapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvalueKey += '}';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvalueKey = String( value );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvalueKey = String( value );\n\n\t\t\t}\n\n\t\t\tcacheKey += /*property + ':' +*/ valueKey + ',';\n\n\t\t}\n\n\t\tcacheKey += this.clippingContextCacheKey + ',';\n\n\t\tif ( object.geometry ) {\n\n\t\t\tcacheKey += this.getGeometryCacheKey();\n\n\t\t}\n\n\t\tif ( object.skeleton ) {\n\n\t\t\tcacheKey += object.skeleton.bones.length + ',';\n\n\t\t}\n\n\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\tcacheKey += object.morphTargetInfluences.length + ',';\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tcacheKey += object._matricesTexture.uuid + ',';\n\n\t\t\tif ( object._colorsTexture !== null ) {\n\n\t\t\t\tcacheKey += object._colorsTexture.uuid + ',';\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.count > 1 ) {\n\n\t\t\t// TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850\n\n\t\t\tcacheKey += object.uuid + ',';\n\n\t\t}\n\n\t\tcacheKey += object.receiveShadow + ',';\n\n\t\treturn hashString( cacheKey );\n\n\t}\n\n\tget needsGeometryUpdate() {\n\n\t\treturn this.geometry.id !== this.object.geometry.id;\n\n\t}\n\n\tget needsUpdate() {\n\n\t\treturn /*this.object.static !== true &&*/ ( this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate );\n\n\t}\n\n\tgetDynamicCacheKey() {\n\n\t\t// Environment Nodes Cache Key\n\n\t\tlet cacheKey = this._nodes.getCacheKey( this.scene, this.lightsNode );\n\n\t\tif ( this.object.receiveShadow ) {\n\n\t\t\tcacheKey += 1;\n\n\t\t}\n\n\t\treturn cacheKey;\n\n\t}\n\n\tgetCacheKey() {\n\n\t\treturn this.getMaterialCacheKey() + this.getDynamicCacheKey();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.material.removeEventListener( 'dispose', this.onMaterialDispose );\n\n\t\tthis.onDispose();\n\n\t}\n\n}\n\nconst chainArray = [];\n\nclass RenderObjects {\n\n\tconstructor( renderer, nodes, geometries, pipelines, bindings, info ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.nodes = nodes;\n\t\tthis.geometries = geometries;\n\t\tthis.pipelines = pipelines;\n\t\tthis.bindings = bindings;\n\t\tthis.info = info;\n\n\t\tthis.chainMaps = {};\n\n\t}\n\n\tget( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {\n\n\t\tconst chainMap = this.getChainMap( passId );\n\n\t\t// reuse chainArray\n\t\tchainArray[ 0 ] = object;\n\t\tchainArray[ 1 ] = material;\n\t\tchainArray[ 2 ] = renderContext;\n\t\tchainArray[ 3 ] = lightsNode;\n\n\t\tlet renderObject = chainMap.get( chainArray );\n\n\t\tif ( renderObject === undefined ) {\n\n\t\t\trenderObject = this.createRenderObject( this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );\n\n\t\t\tchainMap.set( chainArray, renderObject );\n\n\t\t} else {\n\n\t\t\trenderObject.updateClipping( clippingContext );\n\n\t\t\tif ( renderObject.needsGeometryUpdate ) {\n\n\t\t\t\trenderObject.setGeometry( object.geometry );\n\n\t\t\t}\n\n\t\t\tif ( renderObject.version !== material.version || renderObject.needsUpdate ) {\n\n\t\t\t\tif ( renderObject.initialCacheKey !== renderObject.getCacheKey() ) {\n\n\t\t\t\t\trenderObject.dispose();\n\n\t\t\t\t\trenderObject = this.get( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderObject.version = material.version;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn renderObject;\n\n\t}\n\n\tgetChainMap( passId = 'default' ) {\n\n\t\treturn this.chainMaps[ passId ] || ( this.chainMaps[ passId ] = new ChainMap() );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.chainMaps = {};\n\n\t}\n\n\tcreateRenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {\n\n\t\tconst chainMap = this.getChainMap( passId );\n\n\t\tconst renderObject = new RenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext );\n\n\t\trenderObject.onDispose = () => {\n\n\t\t\tthis.pipelines.delete( renderObject );\n\t\t\tthis.bindings.delete( renderObject );\n\t\t\tthis.nodes.delete( renderObject );\n\n\t\t\tchainMap.delete( renderObject.getChainArray() );\n\n\t\t};\n\n\t\treturn renderObject;\n\n\t}\n\n\n}\n\nclass DataMap {\n\n\tconstructor() {\n\n\t\tthis.data = new WeakMap();\n\n\t}\n\n\tget( object ) {\n\n\t\tlet map = this.data.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tthis.data.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\tdelete( object ) {\n\n\t\tlet map;\n\n\t\tif ( this.data.has( object ) ) {\n\n\t\t\tmap = this.data.get( object );\n\n\t\t\tthis.data.delete( object );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\thas( object ) {\n\n\t\treturn this.data.has( object );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.data = new WeakMap();\n\n\t}\n\n}\n\nconst AttributeType = {\n\tVERTEX: 1,\n\tINDEX: 2,\n\tSTORAGE: 3,\n\tINDIRECT: 4\n};\n\n// size of a chunk in bytes (STD140 layout)\n\nconst GPU_CHUNK_BYTES = 16;\n\n// @TODO: Move to src/constants.js\n\nconst BlendColorFactor = 211;\nconst OneMinusBlendColorFactor = 212;\n\nclass Attributes extends DataMap {\n\n\tconstructor( backend ) {\n\n\t\tsuper();\n\n\t\tthis.backend = backend;\n\n\t}\n\n\tdelete( attribute ) {\n\n\t\tconst attributeData = super.delete( attribute );\n\n\t\tif ( attributeData !== undefined ) {\n\n\t\t\tthis.backend.destroyAttribute( attribute );\n\n\t\t}\n\n\t\treturn attributeData;\n\n\t}\n\n\tupdate( attribute, type ) {\n\n\t\tconst data = this.get( attribute );\n\n\t\tif ( data.version === undefined ) {\n\n\t\t\tif ( type === AttributeType.VERTEX ) {\n\n\t\t\t\tthis.backend.createAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.INDEX ) {\n\n\t\t\t\tthis.backend.createIndexAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.STORAGE ) {\n\n\t\t\t\tthis.backend.createStorageAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.INDIRECT ) {\n\n\t\t\t\tthis.backend.createIndirectStorageAttribute( attribute );\n\n\t\t\t}\n\n\t\t\tdata.version = this._getBufferAttribute( attribute ).version;\n\n\t\t} else {\n\n\t\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\t\tif ( data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage ) {\n\n\t\t\t\tthis.backend.updateAttribute( attribute );\n\n\t\t\t\tdata.version = bufferAttribute.version;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_getBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn attribute;\n\n\t}\n\n}\n\nfunction arrayNeedsUint32( array ) {\n\n\t// assumes larger values usually on last\n\n\tfor ( let i = array.length - 1; i >= 0; -- i ) {\n\n\t\tif ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n\n\t}\n\n\treturn false;\n\n}\n\nfunction getWireframeVersion( geometry ) {\n\n\treturn ( geometry.index !== null ) ? geometry.index.version : geometry.attributes.position.version;\n\n}\n\nfunction getWireframeIndex( geometry ) {\n\n\tconst indices = [];\n\n\tconst geometryIndex = geometry.index;\n\tconst geometryPosition = geometry.attributes.position;\n\n\tif ( geometryIndex !== null ) {\n\n\t\tconst array = geometryIndex.array;\n\n\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tconst a = array[ i + 0 ];\n\t\t\tconst b = array[ i + 1 ];\n\t\t\tconst c = array[ i + 2 ];\n\n\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = geometryPosition.array;\n\n\t\tfor ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\tconst a = i + 0;\n\t\t\tconst b = i + 1;\n\t\t\tconst c = i + 2;\n\n\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t}\n\n\t}\n\n\tconst attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\tattribute.version = getWireframeVersion( geometry );\n\n\treturn attribute;\n\n}\n\nclass Geometries extends DataMap {\n\n\tconstructor( attributes, info ) {\n\n\t\tsuper();\n\n\t\tthis.attributes = attributes;\n\t\tthis.info = info;\n\n\t\tthis.wireframes = new WeakMap();\n\n\t\tthis.attributeCall = new WeakMap();\n\n\t}\n\n\thas( renderObject ) {\n\n\t\tconst geometry = renderObject.geometry;\n\n\t\treturn super.has( geometry ) && this.get( geometry ).initialized === true;\n\n\t}\n\n\tupdateForRender( renderObject ) {\n\n\t\tif ( this.has( renderObject ) === false ) this.initGeometry( renderObject );\n\n\t\tthis.updateAttributes( renderObject );\n\n\t}\n\n\tinitGeometry( renderObject ) {\n\n\t\tconst geometry = renderObject.geometry;\n\t\tconst geometryData = this.get( geometry );\n\n\t\tgeometryData.initialized = true;\n\n\t\tthis.info.memory.geometries ++;\n\n\t\tconst onDispose = () => {\n\n\t\t\tthis.info.memory.geometries --;\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst geometryAttributes = renderObject.getAttributes();\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tthis.attributes.delete( index );\n\n\t\t\t}\n\n\t\t\tfor ( const geometryAttribute of geometryAttributes ) {\n\n\t\t\t\tthis.attributes.delete( geometryAttribute );\n\n\t\t\t}\n\n\t\t\tconst wireframeAttribute = this.wireframes.get( geometry );\n\n\t\t\tif ( wireframeAttribute !== undefined ) {\n\n\t\t\t\tthis.attributes.delete( wireframeAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry.removeEventListener( 'dispose', onDispose );\n\n\t\t};\n\n\t\tgeometry.addEventListener( 'dispose', onDispose );\n\n\t}\n\n\tupdateAttributes( renderObject ) {\n\n\t\t// attributes\n\n\t\tconst attributes = renderObject.getAttributes();\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {\n\n\t\t\t\tthis.updateAttribute( attribute, AttributeType.STORAGE );\n\n\t\t\t} else {\n\n\t\t\t\tthis.updateAttribute( attribute, AttributeType.VERTEX );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indexes\n\n\t\tconst index = this.getIndex( renderObject );\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.updateAttribute( index, AttributeType.INDEX );\n\n\t\t}\n\n\t\t// indirect\n\n\t\tconst indirect = renderObject.geometry.indirect;\n\n\t\tif ( indirect !== null ) {\n\n\t\t\tthis.updateAttribute( indirect, AttributeType.INDIRECT );\n\n\t\t}\n\n\t}\n\n\tupdateAttribute( attribute, type ) {\n\n\t\tconst callId = this.info.render.calls;\n\n\t\tif ( ! attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( this.attributeCall.get( attribute ) !== callId ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.attributeCall.get( attribute ) === undefined ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t} else if ( this.attributeCall.get( attribute.data ) !== callId ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute.data, callId );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetIndirect( renderObject ) {\n\n\t\treturn renderObject.geometry.indirect;\n\n\t}\n\n\tgetIndex( renderObject ) {\n\n\t\tconst { geometry, material } = renderObject;\n\n\t\tlet index = geometry.index;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tconst wireframes = this.wireframes;\n\n\t\t\tlet wireframeAttribute = wireframes.get( geometry );\n\n\t\t\tif ( wireframeAttribute === undefined ) {\n\n\t\t\t\twireframeAttribute = getWireframeIndex( geometry );\n\n\t\t\t\twireframes.set( geometry, wireframeAttribute );\n\n\t\t\t} else if ( wireframeAttribute.version !== getWireframeVersion( geometry ) ) {\n\n\t\t\t\tthis.attributes.delete( wireframeAttribute );\n\n\t\t\t\twireframeAttribute = getWireframeIndex( geometry );\n\n\t\t\t\twireframes.set( geometry, wireframeAttribute );\n\n\t\t\t}\n\n\t\t\tindex = wireframeAttribute;\n\n\t\t}\n\n\t\treturn index;\n\n\t}\n\n}\n\nclass Info {\n\n\tconstructor() {\n\n\t\tthis.autoReset = true;\n\n\t\tthis.frame = 0;\n\t\tthis.calls = 0;\n\n\t\tthis.render = {\n\t\t\tcalls: 0,\n\t\t\tframeCalls: 0,\n\t\t\tdrawCalls: 0,\n\t\t\ttriangles: 0,\n\t\t\tpoints: 0,\n\t\t\tlines: 0,\n\t\t\ttimestamp: 0,\n\t\t\tpreviousFrameCalls: 0,\n\t\t\ttimestampCalls: 0\n\t\t};\n\n\t\tthis.compute = {\n\t\t\tcalls: 0,\n\t\t\tframeCalls: 0,\n\t\t\ttimestamp: 0,\n\t\t\tpreviousFrameCalls: 0,\n\t\t\ttimestampCalls: 0\n\t\t};\n\n\t\tthis.memory = {\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\t\t};\n\n\t}\n\n\tupdate( object, count, instanceCount ) {\n\n\t\tthis.render.drawCalls ++;\n\n\t\tif ( object.isMesh || object.isSprite ) {\n\n\t\t\tthis.render.triangles += instanceCount * ( count / 3 );\n\n\t\t} else if ( object.isPoints ) {\n\n\t\t\tthis.render.points += instanceCount * count;\n\n\t\t} else if ( object.isLineSegments ) {\n\n\t\t\tthis.render.lines += instanceCount * ( count / 2 );\n\n\t\t} else if ( object.isLine ) {\n\n\t\t\tthis.render.lines += instanceCount * ( count - 1 );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.WebGPUInfo: Unknown object type.' );\n\n\t\t}\n\n\t}\n\n\tupdateTimestamp( type, time ) {\n\n\t\tif ( this[ type ].timestampCalls === 0 ) {\n\n\t\t\tthis[ type ].timestamp = 0;\n\n\t\t}\n\n\n\t\tthis[ type ].timestamp += time;\n\n\t\tthis[ type ].timestampCalls ++;\n\n\n\t\tif ( this[ type ].timestampCalls >= this[ type ].previousFrameCalls ) {\n\n\t\t\tthis[ type ].timestampCalls = 0;\n\n\t\t}\n\n\n\t}\n\n\treset() {\n\n\t\tconst previousRenderFrameCalls = this.render.frameCalls;\n\t\tthis.render.previousFrameCalls = previousRenderFrameCalls;\n\n\t\tconst previousComputeFrameCalls = this.compute.frameCalls;\n\t\tthis.compute.previousFrameCalls = previousComputeFrameCalls;\n\n\n\t\tthis.render.drawCalls = 0;\n\t\tthis.render.frameCalls = 0;\n\t\tthis.compute.frameCalls = 0;\n\n\t\tthis.render.triangles = 0;\n\t\tthis.render.points = 0;\n\t\tthis.render.lines = 0;\n\n\n\t}\n\n\tdispose() {\n\n\t\tthis.reset();\n\n\t\tthis.calls = 0;\n\n\t\tthis.render.calls = 0;\n\t\tthis.compute.calls = 0;\n\n\t\tthis.render.timestamp = 0;\n\t\tthis.compute.timestamp = 0;\n\t\tthis.memory.geometries = 0;\n\t\tthis.memory.textures = 0;\n\n\t}\n\n}\n\nclass Pipeline {\n\n\tconstructor( cacheKey ) {\n\n\t\tthis.cacheKey = cacheKey;\n\n\t\tthis.usedTimes = 0;\n\n\t}\n\n}\n\nclass RenderPipeline extends Pipeline {\n\n\tconstructor( cacheKey, vertexProgram, fragmentProgram ) {\n\n\t\tsuper( cacheKey );\n\n\t\tthis.vertexProgram = vertexProgram;\n\t\tthis.fragmentProgram = fragmentProgram;\n\n\t}\n\n}\n\nclass ComputePipeline extends Pipeline {\n\n\tconstructor( cacheKey, computeProgram ) {\n\n\t\tsuper( cacheKey );\n\n\t\tthis.computeProgram = computeProgram;\n\n\t\tthis.isComputePipeline = true;\n\n\t}\n\n}\n\nlet _id$6 = 0;\n\nclass ProgrammableStage {\n\n\tconstructor( code, type, transforms = null, attributes = null ) {\n\n\t\tthis.id = _id$6 ++;\n\n\t\tthis.code = code;\n\t\tthis.stage = type;\n\t\tthis.transforms = transforms;\n\t\tthis.attributes = attributes;\n\n\t\tthis.usedTimes = 0;\n\n\t}\n\n}\n\nclass Pipelines extends DataMap {\n\n\tconstructor( backend, nodes ) {\n\n\t\tsuper();\n\n\t\tthis.backend = backend;\n\t\tthis.nodes = nodes;\n\n\t\tthis.bindings = null; // set by the bindings\n\n\t\tthis.caches = new Map();\n\t\tthis.programs = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map()\n\t\t};\n\n\t}\n\n\tgetForCompute( computeNode, bindings ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst data = this.get( computeNode );\n\n\t\tif ( this._needsComputeUpdate( computeNode ) ) {\n\n\t\t\tconst previousPipeline = data.pipeline;\n\n\t\t\tif ( previousPipeline ) {\n\n\t\t\t\tpreviousPipeline.usedTimes --;\n\t\t\t\tpreviousPipeline.computeProgram.usedTimes --;\n\n\t\t\t}\n\n\t\t\t// get shader\n\n\t\t\tconst nodeBuilderState = this.nodes.getForCompute( computeNode );\n\n\t\t\t// programmable stage\n\n\t\t\tlet stageCompute = this.programs.compute.get( nodeBuilderState.computeShader );\n\n\t\t\tif ( stageCompute === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.computeProgram );\n\n\t\t\t\tstageCompute = new ProgrammableStage( nodeBuilderState.computeShader, 'compute', nodeBuilderState.transforms, nodeBuilderState.nodeAttributes );\n\t\t\t\tthis.programs.compute.set( nodeBuilderState.computeShader, stageCompute );\n\n\t\t\t\tbackend.createProgram( stageCompute );\n\n\t\t\t}\n\n\t\t\t// determine compute pipeline\n\n\t\t\tconst cacheKey = this._getComputeCacheKey( computeNode, stageCompute );\n\n\t\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\t\tif ( pipeline === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );\n\n\t\t\t\tpipeline = this._getComputePipeline( computeNode, stageCompute, cacheKey, bindings );\n\n\t\t\t}\n\n\t\t\t// keep track of all used times\n\n\t\t\tpipeline.usedTimes ++;\n\t\t\tstageCompute.usedTimes ++;\n\n\t\t\t//\n\n\t\t\tdata.version = computeNode.version;\n\t\t\tdata.pipeline = pipeline;\n\n\t\t}\n\n\t\treturn data.pipeline;\n\n\t}\n\n\tgetForRender( renderObject, promises = null ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst data = this.get( renderObject );\n\n\t\tif ( this._needsRenderUpdate( renderObject ) ) {\n\n\t\t\tconst previousPipeline = data.pipeline;\n\n\t\t\tif ( previousPipeline ) {\n\n\t\t\t\tpreviousPipeline.usedTimes --;\n\t\t\t\tpreviousPipeline.vertexProgram.usedTimes --;\n\t\t\t\tpreviousPipeline.fragmentProgram.usedTimes --;\n\n\t\t\t}\n\n\t\t\t// get shader\n\n\t\t\tconst nodeBuilderState = renderObject.getNodeBuilderState();\n\n\t\t\t// programmable stages\n\n\t\t\tlet stageVertex = this.programs.vertex.get( nodeBuilderState.vertexShader );\n\n\t\t\tif ( stageVertex === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.vertexProgram );\n\n\t\t\t\tstageVertex = new ProgrammableStage( nodeBuilderState.vertexShader, 'vertex' );\n\t\t\t\tthis.programs.vertex.set( nodeBuilderState.vertexShader, stageVertex );\n\n\t\t\t\tbackend.createProgram( stageVertex );\n\n\t\t\t}\n\n\t\t\tlet stageFragment = this.programs.fragment.get( nodeBuilderState.fragmentShader );\n\n\t\t\tif ( stageFragment === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.fragmentProgram );\n\n\t\t\t\tstageFragment = new ProgrammableStage( nodeBuilderState.fragmentShader, 'fragment' );\n\t\t\t\tthis.programs.fragment.set( nodeBuilderState.fragmentShader, stageFragment );\n\n\t\t\t\tbackend.createProgram( stageFragment );\n\n\t\t\t}\n\n\t\t\t// determine render pipeline\n\n\t\t\tconst cacheKey = this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\n\n\t\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\t\tif ( pipeline === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );\n\n\t\t\t\tpipeline = this._getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises );\n\n\t\t\t} else {\n\n\t\t\t\trenderObject.pipeline = pipeline;\n\n\t\t\t}\n\n\t\t\t// keep track of all used times\n\n\t\t\tpipeline.usedTimes ++;\n\t\t\tstageVertex.usedTimes ++;\n\t\t\tstageFragment.usedTimes ++;\n\n\t\t\t//\n\n\t\t\tdata.pipeline = pipeline;\n\n\t\t}\n\n\t\treturn data.pipeline;\n\n\t}\n\n\tdelete( object ) {\n\n\t\tconst pipeline = this.get( object ).pipeline;\n\n\t\tif ( pipeline ) {\n\n\t\t\t// pipeline\n\n\t\t\tpipeline.usedTimes --;\n\n\t\t\tif ( pipeline.usedTimes === 0 ) this._releasePipeline( pipeline );\n\n\t\t\t// programs\n\n\t\t\tif ( pipeline.isComputePipeline ) {\n\n\t\t\t\tpipeline.computeProgram.usedTimes --;\n\n\t\t\t\tif ( pipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( pipeline.computeProgram );\n\n\t\t\t} else {\n\n\t\t\t\tpipeline.fragmentProgram.usedTimes --;\n\t\t\t\tpipeline.vertexProgram.usedTimes --;\n\n\t\t\t\tif ( pipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( pipeline.vertexProgram );\n\t\t\t\tif ( pipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( pipeline.fragmentProgram );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.delete( object );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis.caches = new Map();\n\t\tthis.programs = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map()\n\t\t};\n\n\t}\n\n\tupdateForRender( renderObject ) {\n\n\t\tthis.getForRender( renderObject );\n\n\t}\n\n\t_getComputePipeline( computeNode, stageCompute, cacheKey, bindings ) {\n\n\t\t// check for existing pipeline\n\n\t\tcacheKey = cacheKey || this._getComputeCacheKey( computeNode, stageCompute );\n\n\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = new ComputePipeline( cacheKey, stageCompute );\n\n\t\t\tthis.caches.set( cacheKey, pipeline );\n\n\t\t\tthis.backend.createComputePipeline( pipeline, bindings );\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t_getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises ) {\n\n\t\t// check for existing pipeline\n\n\t\tcacheKey = cacheKey || this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\n\n\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = new RenderPipeline( cacheKey, stageVertex, stageFragment );\n\n\t\t\tthis.caches.set( cacheKey, pipeline );\n\n\t\t\trenderObject.pipeline = pipeline;\n\n\t\t\tthis.backend.createRenderPipeline( renderObject, promises );\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t_getComputeCacheKey( computeNode, stageCompute ) {\n\n\t\treturn computeNode.id + ',' + stageCompute.id;\n\n\t}\n\n\t_getRenderCacheKey( renderObject, stageVertex, stageFragment ) {\n\n\t\treturn stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey( renderObject );\n\n\t}\n\n\t_releasePipeline( pipeline ) {\n\n\t\tthis.caches.delete( pipeline.cacheKey );\n\n\t}\n\n\t_releaseProgram( program ) {\n\n\t\tconst code = program.code;\n\t\tconst stage = program.stage;\n\n\t\tthis.programs[ stage ].delete( code );\n\n\t}\n\n\t_needsComputeUpdate( computeNode ) {\n\n\t\tconst data = this.get( computeNode );\n\n\t\treturn data.pipeline === undefined || data.version !== computeNode.version;\n\n\t}\n\n\t_needsRenderUpdate( renderObject ) {\n\n\t\tconst data = this.get( renderObject );\n\n\t\treturn data.pipeline === undefined || this.backend.needsRenderUpdate( renderObject );\n\n\t}\n\n}\n\nclass Bindings extends DataMap {\n\n\tconstructor( backend, nodes, textures, attributes, pipelines, info ) {\n\n\t\tsuper();\n\n\t\tthis.backend = backend;\n\t\tthis.textures = textures;\n\t\tthis.pipelines = pipelines;\n\t\tthis.attributes = attributes;\n\t\tthis.nodes = nodes;\n\t\tthis.info = info;\n\n\t\tthis.pipelines.bindings = this; // assign bindings to pipelines\n\n\t}\n\n\tgetForRender( renderObject ) {\n\n\t\tconst bindings = renderObject.getBindings();\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tconst groupData = this.get( bindGroup );\n\n\t\t\tif ( groupData.bindGroup === undefined ) {\n\n\t\t\t\t// each object defines an array of bindings (ubos, textures, samplers etc.)\n\n\t\t\t\tthis._init( bindGroup );\n\n\t\t\t\tthis.backend.createBindings( bindGroup, bindings, 0 );\n\n\t\t\t\tgroupData.bindGroup = bindGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n\tgetForCompute( computeNode ) {\n\n\t\tconst bindings = this.nodes.getForCompute( computeNode ).bindings;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tconst groupData = this.get( bindGroup );\n\n\t\t\tif ( groupData.bindGroup === undefined ) {\n\n\t\t\t\tthis._init( bindGroup );\n\n\t\t\t\tthis.backend.createBindings( bindGroup, bindings, 0 );\n\n\t\t\t\tgroupData.bindGroup = bindGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n\tupdateForCompute( computeNode ) {\n\n\t\tthis._updateBindings( this.getForCompute( computeNode ) );\n\n\t}\n\n\tupdateForRender( renderObject ) {\n\n\t\tthis._updateBindings( this.getForRender( renderObject ) );\n\n\t}\n\n\t_updateBindings( bindings ) {\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tthis._update( bindGroup, bindings );\n\n\t\t}\n\n\t}\n\n\t_init( bindGroup ) {\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isSampledTexture ) {\n\n\t\t\t\tthis.textures.updateTexture( binding.texture );\n\n\t\t\t} else if ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\tconst attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;\n\n\t\t\t\tthis.attributes.update( attribute, attributeType );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_update( bindGroup, bindings ) {\n\n\t\tconst { backend } = this;\n\n\t\tlet needsBindingsUpdate = false;\n\t\tlet cacheBindings = true;\n\t\tlet cacheIndex = 0;\n\t\tlet version = 0;\n\n\t\t// iterate over all bindings and check if buffer updates or a new binding group is required\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isNodeUniformsGroup ) {\n\n\t\t\t\tconst updated = this.nodes.updateGroup( binding );\n\n\t\t\t\tif ( ! updated ) continue;\n\n\t\t\t}\n\n\t\t\tif ( binding.isUniformBuffer ) {\n\n\t\t\t\tconst updated = binding.update();\n\n\t\t\t\tif ( updated ) {\n\n\t\t\t\t\tbackend.updateBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tbinding.update();\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst texturesTextureData = this.textures.get( binding.texture );\n\n\t\t\t\tif ( binding.needsBindingsUpdate( texturesTextureData.generation ) ) needsBindingsUpdate = true;\n\n\t\t\t\tconst updated = binding.update();\n\n\t\t\t\tconst texture = binding.texture;\n\n\t\t\t\tif ( updated ) {\n\n\t\t\t\t\tthis.textures.updateTexture( texture );\n\n\t\t\t\t}\n\n\t\t\t\tconst textureData = backend.get( texture );\n\n\t\t\t\tif ( textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture ) {\n\n\t\t\t\t\tcacheBindings = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcacheIndex = cacheIndex * 10 + texture.id;\n\t\t\t\t\tversion += texture.version;\n\n\t\t\t\t}\n\n\t\t\t\tif ( backend.isWebGPUBackend === true && textureData.texture === undefined && textureData.externalTexture === undefined ) {\n\n\t\t\t\t\t// TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend\n\t\t\t\t\tconsole.error( 'Bindings._update: binding should be available:', binding, updated, texture, binding.textureNode.value, needsBindingsUpdate );\n\n\t\t\t\t\tthis.textures.updateTexture( texture );\n\t\t\t\t\tneedsBindingsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.isStorageTexture === true ) {\n\n\t\t\t\t\tconst textureData = this.get( texture );\n\n\t\t\t\t\tif ( binding.store === true ) {\n\n\t\t\t\t\t\ttextureData.needsMipmap = true;\n\n\t\t\t\t\t} else if ( this.textures.needsMipmaps( texture ) && textureData.needsMipmap === true ) {\n\n\t\t\t\t\t\tthis.backend.generateMipmaps( texture );\n\n\t\t\t\t\t\ttextureData.needsMipmap = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsBindingsUpdate === true ) {\n\n\t\t\tthis.backend.updateBindings( bindGroup, bindings, cacheBindings ? cacheIndex : 0, version );\n\n\t\t}\n\n\t}\n\n}\n\nfunction painterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.material.id !== b.material.id ) {\n\n\t\treturn a.material.id - b.material.id;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn a.z - b.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\nfunction reversePainterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn b.z - a.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\nfunction needsDoublePass( material ) {\n\n\tconst hasTransmission = material.transmission > 0 || material.transmissionNode;\n\n\treturn hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;\n\n}\n\nclass RenderList {\n\n\tconstructor( lighting, scene, camera ) {\n\n\t\tthis.renderItems = [];\n\t\tthis.renderItemsIndex = 0;\n\n\t\tthis.opaque = [];\n\t\tthis.transparentDoublePass = [];\n\t\tthis.transparent = [];\n\t\tthis.bundles = [];\n\n\t\tthis.lightsNode = lighting.getNode( scene, camera );\n\t\tthis.lightsArray = [];\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.occlusionQueryCount = 0;\n\n\t}\n\n\tbegin() {\n\n\t\tthis.renderItemsIndex = 0;\n\n\t\tthis.opaque.length = 0;\n\t\tthis.transparentDoublePass.length = 0;\n\t\tthis.transparent.length = 0;\n\t\tthis.bundles.length = 0;\n\n\t\tthis.lightsArray.length = 0;\n\n\t\tthis.occlusionQueryCount = 0;\n\n\t\treturn this;\n\n\t}\n\n\tgetNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tlet renderItem = this.renderItems[ this.renderItemsIndex ];\n\n\t\tif ( renderItem === undefined ) {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\tz: z,\n\t\t\t\tgroup: group,\n\t\t\t\tclippingContext: clippingContext\n\t\t\t};\n\n\t\t\tthis.renderItems[ this.renderItemsIndex ] = renderItem;\n\n\t\t} else {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\trenderItem.z = z;\n\t\t\trenderItem.group = group;\n\t\t\trenderItem.clippingContext = clippingContext;\n\n\t\t}\n\n\t\tthis.renderItemsIndex ++;\n\n\t\treturn renderItem;\n\n\t}\n\n\tpush( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tconst renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );\n\n\t\tif ( object.occlusionTest === true ) this.occlusionQueryCount ++;\n\n\t\tif ( material.transparent === true || material.transmission > 0 ) {\n\n\t\t\tif ( needsDoublePass( material ) ) this.transparentDoublePass.push( renderItem );\n\n\t\t\tthis.transparent.push( renderItem );\n\n\t\t} else {\n\n\t\t\tthis.opaque.push( renderItem );\n\n\t\t}\n\n\t}\n\n\tunshift( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tconst renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );\n\n\t\tif ( material.transparent === true || material.transmission > 0 ) {\n\n\t\t\tif ( needsDoublePass( material ) ) this.transparentDoublePass.unshift( renderItem );\n\n\t\t\tthis.transparent.unshift( renderItem );\n\n\t\t} else {\n\n\t\t\tthis.opaque.unshift( renderItem );\n\n\t\t}\n\n\t}\n\n\tpushBundle( group ) {\n\n\t\tthis.bundles.push( group );\n\n\t}\n\n\tpushLight( light ) {\n\n\t\tthis.lightsArray.push( light );\n\n\t}\n\n\tsort( customOpaqueSort, customTransparentSort ) {\n\n\t\tif ( this.opaque.length > 1 ) this.opaque.sort( customOpaqueSort || painterSortStable );\n\t\tif ( this.transparentDoublePass.length > 1 ) this.transparentDoublePass.sort( customTransparentSort || reversePainterSortStable );\n\t\tif ( this.transparent.length > 1 ) this.transparent.sort( customTransparentSort || reversePainterSortStable );\n\n\t}\n\n\tfinish() {\n\n\t\t// update lights\n\n\t\tthis.lightsNode.setLights( this.lightsArray );\n\n\t\t// Clear references from inactive renderItems in the list\n\n\t\tfor ( let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = this.renderItems[ i ];\n\n\t\t\tif ( renderItem.id === null ) break;\n\n\t\t\trenderItem.id = null;\n\t\t\trenderItem.object = null;\n\t\t\trenderItem.geometry = null;\n\t\t\trenderItem.material = null;\n\t\t\trenderItem.groupOrder = null;\n\t\t\trenderItem.renderOrder = null;\n\t\t\trenderItem.z = null;\n\t\t\trenderItem.group = null;\n\t\t\trenderItem.clippingContext = null;\n\n\t\t}\n\n\t}\n\n}\n\nclass RenderLists {\n\n\tconstructor( lighting ) {\n\n\t\tthis.lighting = lighting;\n\n\t\tthis.lists = new ChainMap();\n\n\t}\n\n\tget( scene, camera ) {\n\n\t\tconst lists = this.lists;\n\t\tconst keys = [ scene, camera ];\n\n\t\tlet list = lists.get( keys );\n\n\t\tif ( list === undefined ) {\n\n\t\t\tlist = new RenderList( this.lighting, scene, camera );\n\t\t\tlists.set( keys, list );\n\n\t\t}\n\n\t\treturn list;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.lists = new ChainMap();\n\n\t}\n\n}\n\nlet id$1 = 0;\n\nclass RenderContext {\n\n\tconstructor() {\n\n\t\tthis.id = id$1 ++;\n\n\t\tthis.color = true;\n\t\tthis.clearColor = true;\n\t\tthis.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };\n\n\t\tthis.depth = true;\n\t\tthis.clearDepth = true;\n\t\tthis.clearDepthValue = 1;\n\n\t\tthis.stencil = false;\n\t\tthis.clearStencil = true;\n\t\tthis.clearStencilValue = 1;\n\n\t\tthis.viewport = false;\n\t\tthis.viewportValue = new Vector4();\n\n\t\tthis.scissor = false;\n\t\tthis.scissorValue = new Vector4();\n\n\t\tthis.textures = null;\n\t\tthis.depthTexture = null;\n\t\tthis.activeCubeFace = 0;\n\t\tthis.sampleCount = 1;\n\n\t\tthis.width = 0;\n\t\tthis.height = 0;\n\n\t\tthis.isRenderContext = true;\n\n\t}\n\n\tgetCacheKey() {\n\n\t\treturn getCacheKey( this );\n\n\t}\n\n}\n\nfunction getCacheKey( renderContext ) {\n\n\tconst { textures, activeCubeFace } = renderContext;\n\n\tconst values = [ activeCubeFace ];\n\n\tfor ( const texture of textures ) {\n\n\t\tvalues.push( texture.id );\n\n\t}\n\n\treturn hashArray( values );\n\n}\n\nclass RenderContexts {\n\n\tconstructor() {\n\n\t\tthis.chainMaps = {};\n\n\t}\n\n\tget( scene, camera, renderTarget = null ) {\n\n\t\tconst chainKey = [ scene, camera ];\n\n\t\tlet attachmentState;\n\n\t\tif ( renderTarget === null ) {\n\n\t\t\tattachmentState = 'default';\n\n\t\t} else {\n\n\t\t\tconst format = renderTarget.texture.format;\n\t\t\tconst count = renderTarget.textures.length;\n\n\t\t\tattachmentState = `${ count }:${ format }:${ renderTarget.samples }:${ renderTarget.depthBuffer }:${ renderTarget.stencilBuffer }`;\n\n\t\t}\n\n\t\tconst chainMap = this.getChainMap( attachmentState );\n\n\t\tlet renderState = chainMap.get( chainKey );\n\n\t\tif ( renderState === undefined ) {\n\n\t\t\trenderState = new RenderContext();\n\n\t\t\tchainMap.set( chainKey, renderState );\n\n\t\t}\n\n\t\tif ( renderTarget !== null ) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n\n\t\treturn renderState;\n\n\t}\n\n\tgetChainMap( attachmentState ) {\n\n\t\treturn this.chainMaps[ attachmentState ] || ( this.chainMaps[ attachmentState ] = new ChainMap() );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.chainMaps = {};\n\n\t}\n\n}\n\nconst _size$3 = /*@__PURE__*/ new Vector3();\n\nclass Textures extends DataMap {\n\n\tconstructor( renderer, backend, info ) {\n\n\t\tsuper();\n\n\t\tthis.renderer = renderer;\n\t\tthis.backend = backend;\n\t\tthis.info = info;\n\n\t}\n\n\tupdateRenderTarget( renderTarget, activeMipmapLevel = 0 ) {\n\n\t\tconst renderTargetData = this.get( renderTarget );\n\n\t\tconst sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n\t\tconst depthTextureMips = renderTargetData.depthTextureMips || ( renderTargetData.depthTextureMips = {} );\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tconst size = this.getSize( textures[ 0 ] );\n\n\t\tconst mipWidth = size.width >> activeMipmapLevel;\n\t\tconst mipHeight = size.height >> activeMipmapLevel;\n\n\t\tlet depthTexture = renderTarget.depthTexture || depthTextureMips[ activeMipmapLevel ];\n\t\tconst useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;\n\n\t\tlet textureNeedsUpdate = false;\n\n\t\tif ( depthTexture === undefined && useDepthTexture ) {\n\n\t\t\tdepthTexture = new DepthTexture();\n\t\t\tdepthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;\n\t\t\tdepthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType\n\t\t\tdepthTexture.image.width = mipWidth;\n\t\t\tdepthTexture.image.height = mipHeight;\n\n\t\t\tdepthTextureMips[ activeMipmapLevel ] = depthTexture;\n\n\t\t}\n\n\t\tif ( renderTargetData.width !== size.width || size.height !== renderTargetData.height ) {\n\n\t\t\ttextureNeedsUpdate = true;\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tdepthTexture.needsUpdate = true;\n\t\t\t\tdepthTexture.image.width = mipWidth;\n\t\t\t\tdepthTexture.image.height = mipHeight;\n\n\t\t\t}\n\n\t\t}\n\n\t\trenderTargetData.width = size.width;\n\t\trenderTargetData.height = size.height;\n\t\trenderTargetData.textures = textures;\n\t\trenderTargetData.depthTexture = depthTexture || null;\n\t\trenderTargetData.depth = renderTarget.depthBuffer;\n\t\trenderTargetData.stencil = renderTarget.stencilBuffer;\n\t\trenderTargetData.renderTarget = renderTarget;\n\n\t\tif ( renderTargetData.sampleCount !== sampleCount ) {\n\n\t\t\ttextureNeedsUpdate = true;\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tdepthTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\trenderTargetData.sampleCount = sampleCount;\n\n\t\t}\n\n\t\t//\n\n\t\tconst options = { sampleCount };\n\n\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\tconst texture = textures[ i ];\n\n\t\t\tif ( textureNeedsUpdate ) texture.needsUpdate = true;\n\n\t\t\tthis.updateTexture( texture, options );\n\n\t\t}\n\n\t\tif ( depthTexture ) {\n\n\t\t\tthis.updateTexture( depthTexture, options );\n\n\t\t}\n\n\t\t// dispose handler\n\n\t\tif ( renderTargetData.initialized !== true ) {\n\n\t\t\trenderTargetData.initialized = true;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\trenderTarget.removeEventListener( 'dispose', onDispose );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tthis._destroyTexture( textures[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( depthTexture ) {\n\n\t\t\t\t\tthis._destroyTexture( depthTexture );\n\n\t\t\t\t}\n\n\t\t\t\tthis.delete( renderTarget );\n\n\t\t\t};\n\n\t\t\trenderTarget.addEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t}\n\n\tupdateTexture( texture, options = {} ) {\n\n\t\tconst textureData = this.get( texture );\n\t\tif ( textureData.initialized === true && textureData.version === texture.version ) return;\n\n\t\tconst isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;\n\t\tconst backend = this.backend;\n\n\t\tif ( isRenderTarget && textureData.initialized === true ) {\n\n\t\t\t// it's an update\n\n\t\t\tbackend.destroySampler( texture );\n\t\t\tbackend.destroyTexture( texture );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tconst renderTarget = this.renderer.getRenderTarget();\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\ttexture.type = renderTarget.texture.type;\n\n\t\t\t} else {\n\n\t\t\t\ttexture.type = UnsignedByteType;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst { width, height, depth } = this.getSize( texture );\n\n\t\toptions.width = width;\n\t\toptions.height = height;\n\t\toptions.depth = depth;\n\t\toptions.needsMipmaps = this.needsMipmaps( texture );\n\t\toptions.levels = options.needsMipmaps ? this.getMipLevels( texture, width, height ) : 1;\n\n\t\t//\n\n\t\tif ( isRenderTarget || texture.isStorageTexture === true ) {\n\n\t\t\tbackend.createSampler( texture );\n\t\t\tbackend.createTexture( texture, options );\n\n\t\t\ttextureData.generation = texture.version;\n\n\t\t} else {\n\n\t\t\tconst needsCreate = textureData.initialized !== true;\n\n\t\t\tif ( needsCreate ) backend.createSampler( texture );\n\n\t\t\tif ( texture.version > 0 ) {\n\n\t\t\t\tconst image = texture.image;\n\n\t\t\t\tif ( image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Renderer: Texture marked for update but image is undefined.' );\n\n\t\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Renderer: Texture marked for update but image is incomplete.' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( texture.images ) {\n\n\t\t\t\t\t\tconst images = [];\n\n\t\t\t\t\t\tfor ( const image of texture.images ) {\n\n\t\t\t\t\t\t\timages.push( image );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toptions.images = images;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toptions.image = image;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true ) {\n\n\t\t\t\t\t\tbackend.createTexture( texture, options );\n\n\t\t\t\t\t\ttextureData.isDefaultTexture = false;\n\t\t\t\t\t\ttextureData.generation = texture.version;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texture.source.dataReady === true ) backend.updateTexture( texture, options );\n\n\t\t\t\t\tif ( options.needsMipmaps && texture.mipmaps.length === 0 ) backend.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// async update\n\n\t\t\t\tbackend.createDefaultTexture( texture );\n\n\t\t\t\ttextureData.isDefaultTexture = true;\n\t\t\t\ttextureData.generation = texture.version;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// dispose handler\n\n\t\tif ( textureData.initialized !== true ) {\n\n\t\t\ttextureData.initialized = true;\n\t\t\ttextureData.generation = texture.version;\n\n\t\t\t//\n\n\t\t\tthis.info.memory.textures ++;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\ttexture.removeEventListener( 'dispose', onDispose );\n\n\t\t\t\tthis._destroyTexture( texture );\n\n\t\t\t\tthis.info.memory.textures --;\n\n\t\t\t};\n\n\t\t\ttexture.addEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t\t//\n\n\t\ttextureData.version = texture.version;\n\n\t}\n\n\tgetSize( texture, target = _size$3 ) {\n\n\t\tlet image = texture.images ? texture.images[ 0 ] : texture.image;\n\n\t\tif ( image ) {\n\n\t\t\tif ( image.image !== undefined ) image = image.image;\n\n\t\t\ttarget.width = image.width || 1;\n\t\t\ttarget.height = image.height || 1;\n\t\t\ttarget.depth = texture.isCubeTexture ? 6 : ( image.depth || 1 );\n\n\t\t} else {\n\n\t\t\ttarget.width = target.height = target.depth = 1;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetMipLevels( texture, width, height ) {\n\n\t\tlet mipLevelCount;\n\n\t\tif ( texture.isCompressedTexture ) {\n\n\t\t\tif ( texture.mipmaps ) {\n\n\t\t\t\tmipLevelCount = texture.mipmaps.length;\n\n\t\t\t} else {\n\n\t\t\t\tmipLevelCount = 1;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmipLevelCount = Math.floor( Math.log2( Math.max( width, height ) ) ) + 1;\n\n\t\t}\n\n\t\treturn mipLevelCount;\n\n\t}\n\n\tneedsMipmaps( texture ) {\n\n\t\treturn this.isEnvironmentTexture( texture ) || texture.isCompressedTexture === true || texture.generateMipmaps;\n\n\t}\n\n\tisEnvironmentTexture( texture ) {\n\n\t\tconst mapping = texture.mapping;\n\n\t\treturn ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\n\n\t}\n\n\t_destroyTexture( texture ) {\n\n\t\tthis.backend.destroySampler( texture );\n\t\tthis.backend.destroyTexture( texture );\n\n\t\tthis.delete( texture );\n\n\t}\n\n}\n\nclass Color4 extends Color {\n\n\tconstructor( r, g, b, a = 1 ) {\n\n\t\tsuper( r, g, b );\n\n\t\tthis.a = a;\n\n\t}\n\n\tset( r, g, b, a = 1 ) {\n\n\t\tthis.a = a;\n\n\t\treturn super.set( r, g, b );\n\n\t}\n\n\tcopy( color ) {\n\n\t\tif ( color.a !== undefined ) this.a = color.a;\n\n\t\treturn super.copy( color );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.r, this.g, this.b, this.a );\n\n\t}\n\n}\n\nclass ParameterNode extends PropertyNode {\n\n\tstatic get type() {\n\n\t\treturn 'ParameterNode';\n\n\t}\n\n\tconstructor( nodeType, name = null ) {\n\n\t\tsuper( nodeType, name );\n\n\t\tthis.isParameterNode = true;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.uuid;\n\n\t}\n\n\tgenerate() {\n\n\t\treturn this.name;\n\n\t}\n\n}\n\nconst parameter = ( type, name ) => nodeObject( new ParameterNode( type, name ) );\n\nclass StackNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'StackNode';\n\n\t}\n\n\tconstructor( parent = null ) {\n\n\t\tsuper();\n\n\t\tthis.nodes = [];\n\t\tthis.outputNode = null;\n\n\t\tthis.parent = parent;\n\n\t\tthis._currentCond = null;\n\n\t\tthis.isStackNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode ? this.outputNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tadd( node ) {\n\n\t\tthis.nodes.push( node );\n\n\t\treturn this;\n\n\t}\n\n\tIf( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tthis._currentCond = select( boolNode, methodNode );\n\n\t\treturn this.add( this._currentCond );\n\n\t}\n\n\tElseIf( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tconst ifNode = select( boolNode, methodNode );\n\n\t\tthis._currentCond.elseNode = ifNode;\n\t\tthis._currentCond = ifNode;\n\n\t\treturn this;\n\n\t}\n\n\tElse( method ) {\n\n\t\tthis._currentCond.elseNode = new ShaderNode( method );\n\n\t\treturn this;\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tconst previousStack = getCurrentStack();\n\n\t\tsetCurrentStack( this );\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tnode.build( builder, 'void' );\n\n\t\t}\n\n\t\tsetCurrentStack( previousStack );\n\n\t\treturn this.outputNode ? this.outputNode.build( builder, ...params ) : super.build( builder, ...params );\n\n\t}\n\n\t//\n\n\telse( ...params ) { // @deprecated, r168\n\n\t\tconsole.warn( 'TSL.StackNode: .else() has been renamed to .Else().' );\n\t\treturn this.Else( ...params );\n\n\t}\n\n\telseif( ...params ) { // @deprecated, r168\n\n\t\tconsole.warn( 'TSL.StackNode: .elseif() has been renamed to .ElseIf().' );\n\t\treturn this.ElseIf( ...params );\n\n\t}\n\n}\n\nconst stack = /*@__PURE__*/ nodeProxy( StackNode );\n\nclass StructTypeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'StructTypeNode';\n\n\t}\n\n\tconstructor( types ) {\n\n\t\tsuper();\n\n\t\tthis.types = types;\n\t\tthis.isStructTypeNode = true;\n\n\t}\n\n\tgetMemberTypes() {\n\n\t\treturn this.types;\n\n\t}\n\n}\n\nclass OutputStructNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'OutputStructNode';\n\n\t}\n\n\tconstructor( ...members ) {\n\n\t\tsuper();\n\n\t\tthis.members = members;\n\n\t\tthis.isOutputStructNode = true;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst members = this.members;\n\t\tconst types = [];\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\ttypes.push( members[ i ].getNodeType( builder ) );\n\n\t\t}\n\n\t\tthis.nodeType = builder.getStructTypeFromNode( new StructTypeNode( types ) ).name;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst propertyName = builder.getOutputStructName();\n\t\tconst members = this.members;\n\n\t\tconst structPrefix = propertyName !== '' ? propertyName + '.' : '';\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\tconst snippet = members[ i ].build( builder, output );\n\n\t\t\tbuilder.addLineFlowCode( `${ structPrefix }m${ i } = ${ snippet }`, this );\n\n\t\t}\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\nconst outputStruct = /*@__PURE__*/ nodeProxy( OutputStructNode );\n\nfunction getTextureIndex( textures, name ) {\n\n\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\tif ( textures[ i ].name === name ) {\n\n\t\t\treturn i;\n\n\t\t}\n\n\t}\n\n\treturn - 1;\n\n}\n\nclass MRTNode extends OutputStructNode {\n\n\tstatic get type() {\n\n\t\treturn 'MRTNode';\n\n\t}\n\n\tconstructor( outputNodes ) {\n\n\t\tsuper();\n\n\t\tthis.outputNodes = outputNodes;\n\n\t\tthis.isMRTNode = true;\n\n\t}\n\n\thas( name ) {\n\n\t\treturn this.outputNodes[ name ] !== undefined;\n\n\t}\n\n\tget( name ) {\n\n\t\treturn this.outputNodes[ name ];\n\n\t}\n\n\tmerge( mrtNode ) {\n\n\t\tconst outputs = { ...this.outputNodes, ...mrtNode.outputNodes };\n\n\t\treturn mrt( outputs );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst outputNodes = this.outputNodes;\n\t\tconst mrt = builder.renderer.getRenderTarget();\n\n\t\tconst members = [];\n\n\t\tconst textures = mrt.textures;\n\n\t\tfor ( const name in outputNodes ) {\n\n\t\t\tconst index = getTextureIndex( textures, name );\n\n\t\t\tmembers[ index ] = vec4( outputNodes[ name ] );\n\n\t\t}\n\n\t\tthis.members = members;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n}\n\nconst mrt = /*@__PURE__*/ nodeProxy( MRTNode );\n\nconst hash = /*@__PURE__*/ Fn( ( [ seed ] ) => {\n\n\t// Taken from https://www.shadertoy.com/view/XlGcRh, originally from pcg-random.org\n\n\tconst state = seed.toUint().mul( 747796405 ).add( 2891336453 );\n\tconst word = state.shiftRight( state.shiftRight( 28 ).add( 4 ) ).bitXor( state ).mul( 277803737 );\n\tconst result = word.shiftRight( 22 ).bitXor( word );\n\n\treturn result.toFloat().mul( 1 / 2 ** 32 ); // Convert to range [0, 1)\n\n} );\n\n// remapping functions https://iquilezles.org/articles/functions/\nconst parabola = ( x, k ) => pow( mul( 4.0, x.mul( sub( 1.0, x ) ) ), k );\nconst gain = ( x, k ) => x.lessThan( 0.5 ) ? parabola( x.mul( 2.0 ), k ).div( 2.0 ) : sub( 1.0, parabola( mul( sub( 1.0, x ), 2.0 ), k ).div( 2.0 ) );\nconst pcurve = ( x, a, b ) => pow( div( pow( x, a ), add( pow( x, a ), pow( sub( 1.0, x ), b ) ) ), 1.0 / a );\nconst sinc = ( x, k ) => sin( PI.mul( k.mul( x ).sub( 1.0 ) ) ).div( PI.mul( k.mul( x ).sub( 1.0 ) ) );\n\n// https://github.com/cabbibo/glsl-tri-noise-3d\n\n\nconst tri = /*@__PURE__*/ Fn( ( [ x ] ) => {\n\n\treturn x.fract().sub( .5 ).abs();\n\n} ).setLayout( {\n\tname: 'tri',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'x', type: 'float' }\n\t]\n} );\n\nconst tri3 = /*@__PURE__*/ Fn( ( [ p ] ) => {\n\n\treturn vec3( tri( p.z.add( tri( p.y.mul( 1. ) ) ) ), tri( p.z.add( tri( p.x.mul( 1. ) ) ) ), tri( p.y.add( tri( p.x.mul( 1. ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'tri3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst triNoise3D = /*@__PURE__*/ Fn( ( [ p_immutable, spd, time ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst z = float( 1.4 ).toVar();\n\tconst rz = float( 0.0 ).toVar();\n\tconst bp = vec3( p ).toVar();\n\n\tLoop( { start: float( 0.0 ), end: float( 3.0 ), type: 'float', condition: '<=' }, () => {\n\n\t\tconst dg = vec3( tri3( bp.mul( 2.0 ) ) ).toVar();\n\t\tp.addAssign( dg.add( time.mul( float( 0.1 ).mul( spd ) ) ) );\n\t\tbp.mulAssign( 1.8 );\n\t\tz.mulAssign( 1.5 );\n\t\tp.mulAssign( 1.2 );\n\n\t\tconst t = float( tri( p.z.add( tri( p.x.add( tri( p.y ) ) ) ) ) ).toVar();\n\t\trz.addAssign( t.div( z ) );\n\t\tbp.addAssign( 0.14 );\n\n\t} );\n\n\treturn rz;\n\n} ).setLayout( {\n\tname: 'triNoise3D',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'spd', type: 'float' },\n\t\t{ name: 'time', type: 'float' }\n\t]\n} );\n\nclass FunctionOverloadingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionOverloadingNode';\n\n\t}\n\n\tconstructor( functionNodes = [], ...parametersNodes ) {\n\n\t\tsuper();\n\n\t\tthis.functionNodes = functionNodes;\n\t\tthis.parametersNodes = parametersNodes;\n\n\t\tthis._candidateFnCall = null;\n\n\t\tthis.global = true;\n\n\t}\n\n\tgetNodeType() {\n\n\t\treturn this.functionNodes[ 0 ].shaderNode.layout.type;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst params = this.parametersNodes;\n\n\t\tlet candidateFnCall = this._candidateFnCall;\n\n\t\tif ( candidateFnCall === null ) {\n\n\t\t\tlet candidateFn = null;\n\t\t\tlet candidateScore = - 1;\n\n\t\t\tfor ( const functionNode of this.functionNodes ) {\n\n\t\t\t\tconst shaderNode = functionNode.shaderNode;\n\t\t\t\tconst layout = shaderNode.layout;\n\n\t\t\t\tif ( layout === null ) {\n\n\t\t\t\t\tthrow new Error( 'FunctionOverloadingNode: FunctionNode must be a layout.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst inputs = layout.inputs;\n\n\t\t\t\tif ( params.length === inputs.length ) {\n\n\t\t\t\t\tlet score = 0;\n\n\t\t\t\t\tfor ( let i = 0; i < params.length; i ++ ) {\n\n\t\t\t\t\t\tconst param = params[ i ];\n\t\t\t\t\t\tconst input = inputs[ i ];\n\n\t\t\t\t\t\tif ( param.getNodeType( builder ) === input.type ) {\n\n\t\t\t\t\t\t\tscore ++;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tscore = 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( score > candidateScore ) {\n\n\t\t\t\t\t\tcandidateFn = functionNode;\n\t\t\t\t\t\tcandidateScore = score;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._candidateFnCall = candidateFnCall = candidateFn( ...params );\n\n\t\t}\n\n\t\treturn candidateFnCall;\n\n\t}\n\n}\n\nconst overloadingBaseFn = /*@__PURE__*/ nodeProxy( FunctionOverloadingNode );\n\nconst overloadingFn = ( functionNodes ) => ( ...params ) => overloadingBaseFn( functionNodes, ...params );\n\nconst time = /*@__PURE__*/ uniform( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.time );\nconst deltaTime = /*@__PURE__*/ uniform( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.deltaTime );\nconst frameId = /*@__PURE__*/ uniform( 0, 'uint' ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.frameId );\n\n// Deprecated\n\nconst timerLocal = ( timeScale = 1 ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: timerLocal() is deprecated. Use \"time\" instead.' );\n\treturn time.mul( timeScale );\n\n};\n\nconst timerGlobal = ( timeScale = 1 ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: timerGlobal() is deprecated. Use \"time\" instead.' );\n\treturn time.mul( timeScale );\n\n};\n\nconst timerDelta = ( timeScale = 1 ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: timerDelta() is deprecated. Use \"deltaTime\" instead.' );\n\treturn deltaTime.mul( timeScale );\n\n};\n\nconst oscSine = ( t = time ) => t.add( 0.75 ).mul( Math.PI * 2 ).sin().mul( 0.5 ).add( 0.5 );\nconst oscSquare = ( t = time ) => t.fract().round();\nconst oscTriangle = ( t = time ) => t.add( 0.5 ).fract().mul( 2 ).sub( 1 ).abs();\nconst oscSawtooth = ( t = time ) => t.fract();\n\nconst rotateUV = /*@__PURE__*/ Fn( ( [ uv, rotation, center = vec2( 0.5 ) ] ) => {\n\n\treturn rotate( uv.sub( center ), rotation ).add( center );\n\n} );\n\nconst spherizeUV = /*@__PURE__*/ Fn( ( [ uv, strength, center = vec2( 0.5 ) ] ) => {\n\n\tconst delta = uv.sub( center );\n\tconst delta2 = delta.dot( delta );\n\tconst delta4 = delta2.mul( delta2 );\n\tconst deltaOffset = delta4.mul( strength );\n\n\treturn uv.add( delta.mul( deltaOffset ) );\n\n} );\n\nconst billboarding = /*@__PURE__*/ Fn( ( { position = null, horizontal = true, vertical = false } ) => {\n\n\tlet worldMatrix;\n\n\tif ( position !== null ) {\n\n\t\tworldMatrix = modelWorldMatrix.toVar();\n\t\tworldMatrix[ 3 ][ 0 ] = position.x;\n\t\tworldMatrix[ 3 ][ 1 ] = position.y;\n\t\tworldMatrix[ 3 ][ 2 ] = position.z;\n\n\t} else {\n\n\t\tworldMatrix = modelWorldMatrix;\n\n\t}\n\n\tconst modelViewMatrix = cameraViewMatrix.mul( worldMatrix );\n\n\tif ( defined( horizontal ) ) {\n\n\t\tmodelViewMatrix[ 0 ][ 0 ] = modelWorldMatrix[ 0 ].length();\n\t\tmodelViewMatrix[ 0 ][ 1 ] = 0;\n\t\tmodelViewMatrix[ 0 ][ 2 ] = 0;\n\n\t}\n\n\tif ( defined( vertical ) ) {\n\n\t\tmodelViewMatrix[ 1 ][ 0 ] = 0;\n\t\tmodelViewMatrix[ 1 ][ 1 ] = modelWorldMatrix[ 1 ].length();\n\t\tmodelViewMatrix[ 1 ][ 2 ] = 0;\n\n\t}\n\n\tmodelViewMatrix[ 2 ][ 0 ] = 0;\n\tmodelViewMatrix[ 2 ][ 1 ] = 0;\n\tmodelViewMatrix[ 2 ][ 2 ] = 1;\n\n\treturn cameraProjectionMatrix.mul( modelViewMatrix ).mul( positionLocal );\n\n} );\n\nconst viewportSafeUV = /*@__PURE__*/ Fn( ( [ uv = null ] ) => {\n\n\tconst depth = linearDepth();\n\tconst depthDiff = linearDepth( viewportDepthTexture( uv ) ).sub( depth );\n\tconst finalUV = depthDiff.lessThan( 0 ).select( screenUV, uv );\n\n\treturn finalUV;\n\n} );\n\nclass SpriteSheetUVNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SpriteSheetUVNode';\n\n\t}\n\n\tconstructor( countNode, uvNode = uv(), frameNode = float( 0 ) ) {\n\n\t\tsuper( 'vec2' );\n\n\t\tthis.countNode = countNode;\n\t\tthis.uvNode = uvNode;\n\t\tthis.frameNode = frameNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { frameNode, uvNode, countNode } = this;\n\n\t\tconst { width, height } = countNode;\n\n\t\tconst frameNum = frameNode.mod( width.mul( height ) ).floor();\n\n\t\tconst column = frameNum.mod( width );\n\t\tconst row = height.sub( frameNum.add( 1 ).div( width ).ceil() );\n\n\t\tconst scale = countNode.reciprocal();\n\t\tconst uvFrameOffset = vec2( column, row );\n\n\t\treturn uvNode.add( uvFrameOffset ).mul( scale );\n\n\t}\n\n}\n\nconst spritesheetUV = /*@__PURE__*/ nodeProxy( SpriteSheetUVNode );\n\nclass TriplanarTexturesNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TriplanarTexturesNode';\n\n\t}\n\n\tconstructor( textureXNode, textureYNode = null, textureZNode = null, scaleNode = float( 1 ), positionNode = positionLocal, normalNode = normalLocal ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.textureXNode = textureXNode;\n\t\tthis.textureYNode = textureYNode;\n\t\tthis.textureZNode = textureZNode;\n\n\t\tthis.scaleNode = scaleNode;\n\n\t\tthis.positionNode = positionNode;\n\t\tthis.normalNode = normalNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;\n\n\t\t// Ref: https://github.com/keijiro/StandardTriplanar\n\n\t\t// Blending factor of triplanar mapping\n\t\tlet bf = normalNode.abs().normalize();\n\t\tbf = bf.div( bf.dot( vec3( 1.0 ) ) );\n\n\t\t// Triplanar mapping\n\t\tconst tx = positionNode.yz.mul( scaleNode );\n\t\tconst ty = positionNode.zx.mul( scaleNode );\n\t\tconst tz = positionNode.xy.mul( scaleNode );\n\n\t\t// Base color\n\t\tconst textureX = textureXNode.value;\n\t\tconst textureY = textureYNode !== null ? textureYNode.value : textureX;\n\t\tconst textureZ = textureZNode !== null ? textureZNode.value : textureX;\n\n\t\tconst cx = texture( textureX, tx ).mul( bf.x );\n\t\tconst cy = texture( textureY, ty ).mul( bf.y );\n\t\tconst cz = texture( textureZ, tz ).mul( bf.z );\n\n\t\treturn add( cx, cy, cz );\n\n\t}\n\n}\n\nconst triplanarTextures = /*@__PURE__*/ nodeProxy( TriplanarTexturesNode );\nconst triplanarTexture = ( ...params ) => triplanarTextures( ...params );\n\nconst _reflectorPlane = new Plane();\nconst _normal = new Vector3();\nconst _reflectorWorldPosition = new Vector3();\nconst _cameraWorldPosition = new Vector3();\nconst _rotationMatrix = new Matrix4();\nconst _lookAtPosition = new Vector3( 0, 0, - 1 );\nconst clipPlane = new Vector4();\n\nconst _view = new Vector3();\nconst _target = new Vector3();\nconst _q = new Vector4();\n\nconst _size$2 = new Vector2();\n\nconst _defaultRT = new RenderTarget();\nconst _defaultUV = screenUV.flipX();\n\n_defaultRT.depthTexture = new DepthTexture( 1, 1 );\n\nlet _inReflector = false;\n\nclass ReflectorNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReflectorNode';\n\n\t}\n\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters.defaultTexture || _defaultRT.texture, _defaultUV );\n\n\t\tthis._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode( this, parameters );\n\t\tthis._depthNode = null;\n\n\t\tthis.setUpdateMatrix( false );\n\n\t}\n\n\tget reflector() {\n\n\t\treturn this._reflectorBaseNode;\n\n\t}\n\n\tget target() {\n\n\t\treturn this._reflectorBaseNode.target;\n\n\t}\n\n\tgetDepthNode() {\n\n\t\tif ( this._depthNode === null ) {\n\n\t\t\tif ( this._reflectorBaseNode.depth !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ' );\n\n\t\t\t}\n\n\t\t\tthis._depthNode = nodeObject( new ReflectorNode( {\n\t\t\t\tdefaultTexture: _defaultRT.depthTexture,\n\t\t\t\treflector: this._reflectorBaseNode\n\t\t\t} ) );\n\n\t\t}\n\n\t\treturn this._depthNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// ignore if used in post-processing\n\t\tif ( ! builder.object.isQuadMesh ) this._reflectorBaseNode.build( builder );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\tconst texture = new this.constructor( this.reflectorNode );\n\t\ttexture._reflectorBaseNode = this._reflectorBaseNode;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n\nclass ReflectorBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReflectorBaseNode';\n\n\t}\n\n\tconstructor( textureNode, parameters = {} ) {\n\n\t\tsuper();\n\n\t\tconst {\n\t\t\ttarget = new Object3D(),\n\t\t\tresolution = 1,\n\t\t\tgenerateMipmaps = false,\n\t\t\tbounces = true,\n\t\t\tdepth = false\n\t\t} = parameters;\n\n\t\t//\n\n\t\tthis.textureNode = textureNode;\n\n\t\tthis.target = target;\n\t\tthis.resolution = resolution;\n\t\tthis.generateMipmaps = generateMipmaps;\n\t\tthis.bounces = bounces;\n\t\tthis.depth = depth;\n\n\t\tthis.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n\n\t\tthis.virtualCameras = new WeakMap();\n\t\tthis.renderTargets = new WeakMap();\n\n\t}\n\n\t_updateResolution( renderTarget, renderer ) {\n\n\t\tconst resolution = this.resolution;\n\n\t\trenderer.getDrawingBufferSize( _size$2 );\n\n\t\trenderTarget.setSize( Math.round( _size$2.width * resolution ), Math.round( _size$2.height * resolution ) );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._updateResolution( _defaultRT, builder.renderer );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tgetVirtualCamera( camera ) {\n\n\t\tlet virtualCamera = this.virtualCameras.get( camera );\n\n\t\tif ( virtualCamera === undefined ) {\n\n\t\t\tvirtualCamera = camera.clone();\n\n\t\t\tthis.virtualCameras.set( camera, virtualCamera );\n\n\t\t}\n\n\t\treturn virtualCamera;\n\n\t}\n\n\tgetRenderTarget( camera ) {\n\n\t\tlet renderTarget = this.renderTargets.get( camera );\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = new RenderTarget( 0, 0, { type: HalfFloatType } );\n\n\t\t\tif ( this.generateMipmaps === true ) {\n\n\t\t\t\trenderTarget.texture.minFilter = LinearMipMapLinearFilter;\n\t\t\t\trenderTarget.texture.generateMipmaps = true;\n\n\t\t\t}\n\n\t\t\tif ( this.depth === true ) {\n\n\t\t\t\trenderTarget.depthTexture = new DepthTexture();\n\n\t\t\t}\n\n\t\t\tthis.renderTargets.set( camera, renderTarget );\n\n\t\t}\n\n\t\treturn renderTarget;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tif ( this.bounces === false && _inReflector ) return;\n\n\t\t_inReflector = true;\n\n\t\tconst { scene, camera, renderer, material } = frame;\n\t\tconst { target } = this;\n\n\t\tconst virtualCamera = this.getVirtualCamera( camera );\n\t\tconst renderTarget = this.getRenderTarget( virtualCamera );\n\n\t\trenderer.getDrawingBufferSize( _size$2 );\n\n\t\tthis._updateResolution( renderTarget, renderer );\n\n\t\t//\n\n\t\t_reflectorWorldPosition.setFromMatrixPosition( target.matrixWorld );\n\t\t_cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t_rotationMatrix.extractRotation( target.matrixWorld );\n\n\t\t_normal.set( 0, 0, 1 );\n\t\t_normal.applyMatrix4( _rotationMatrix );\n\n\t\t_view.subVectors( _reflectorWorldPosition, _cameraWorldPosition );\n\n\t\t// Avoid rendering when reflector is facing away\n\n\t\tif ( _view.dot( _normal ) > 0 ) return;\n\n\t\t_view.reflect( _normal ).negate();\n\t\t_view.add( _reflectorWorldPosition );\n\n\t\t_rotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t_lookAtPosition.set( 0, 0, - 1 );\n\t\t_lookAtPosition.applyMatrix4( _rotationMatrix );\n\t\t_lookAtPosition.add( _cameraWorldPosition );\n\n\t\t_target.subVectors( _reflectorWorldPosition, _lookAtPosition );\n\t\t_target.reflect( _normal ).negate();\n\t\t_target.add( _reflectorWorldPosition );\n\n\t\t//\n\n\t\tvirtualCamera.coordinateSystem = camera.coordinateSystem;\n\t\tvirtualCamera.position.copy( _view );\n\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\tvirtualCamera.up.applyMatrix4( _rotationMatrix );\n\t\tvirtualCamera.up.reflect( _normal );\n\t\tvirtualCamera.lookAt( _target );\n\n\t\tvirtualCamera.near = camera.near;\n\t\tvirtualCamera.far = camera.far;\n\n\t\tvirtualCamera.updateMatrixWorld();\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t_reflectorPlane.setFromNormalAndCoplanarPoint( _normal, _reflectorWorldPosition );\n\t\t_reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( _reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant );\n\n\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t_q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t_q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t_q.z = - 1.0;\n\t\t_q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 1.0 / clipPlane.dot( _q ) );\n\n\t\tconst clipBias = 0;\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = ( renderer.coordinateSystem === WebGPUCoordinateSystem ) ? ( clipPlane.z - clipBias ) : ( clipPlane.z + 1.0 - clipBias );\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t//\n\n\t\tthis.textureNode.value = renderTarget.texture;\n\n\t\tif ( this.depth === true ) {\n\n\t\t\tthis.textureNode.getDepthNode().value = renderTarget.depthTexture;\n\n\t\t}\n\n\t\tmaterial.visible = false;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentMRT = renderer.getMRT();\n\n\t\trenderer.setMRT( null );\n\t\trenderer.setRenderTarget( renderTarget );\n\n\t\trenderer.render( scene, virtualCamera );\n\n\t\trenderer.setMRT( currentMRT );\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\tmaterial.visible = true;\n\n\t\t_inReflector = false;\n\n\t}\n\n}\n\nconst reflector = ( parameters ) => nodeObject( new ReflectorNode( parameters ) );\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nclass QuadGeometry extends BufferGeometry {\n\n\tconstructor( flipY = false ) {\n\n\t\tsuper();\n\n\t\tconst uv = flipY === false ? [ 0, - 1, 0, 1, 2, 1 ] : [ 0, 2, 0, 0, 2, 0 ];\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );\n\n\t}\n\n}\n\nconst _geometry = /*@__PURE__*/ new QuadGeometry();\n\nclass QuadMesh extends Mesh {\n\n\tconstructor( material = null ) {\n\n\t\tsuper( _geometry, material );\n\n\t\tthis.camera = _camera;\n\n\t\tthis.isQuadMesh = true;\n\n\t}\n\n\trenderAsync( renderer ) {\n\n\t\treturn renderer.renderAsync( this, _camera );\n\n\t}\n\n\trender( renderer ) {\n\n\t\trenderer.render( this, _camera );\n\n\t}\n\n}\n\nconst _size$1 = /*@__PURE__*/ new Vector2();\n\nclass RTTNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'RTTNode';\n\n\t}\n\n\tconstructor( node, width = null, height = null, options = { type: HalfFloatType } ) {\n\n\t\tconst renderTarget = new RenderTarget( width, height, options );\n\n\t\tsuper( renderTarget.texture, uv() );\n\n\t\tthis.node = node;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tthis.renderTarget = renderTarget;\n\n\t\tthis.textureNeedsUpdate = true;\n\t\tthis.autoUpdate = true;\n\n\t\tthis.updateMap = new WeakMap();\n\n\t\tthis._rttNode = null;\n\t\tthis._quadMesh = new QuadMesh( new NodeMaterial() );\n\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tget autoSize() {\n\n\t\treturn this.width === null;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._rttNode = this.node.context( builder.getSharedContext() );\n\t\tthis._quadMesh.material.name = 'RTT';\n\t\tthis._quadMesh.material.needsUpdate = true;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tconst effectiveWidth = width * this.pixelRatio;\n\t\tconst effectiveHeight = height * this.pixelRatio;\n\n\t\tthis.renderTarget.setSize( effectiveWidth, effectiveHeight );\n\n\t\tthis.textureNeedsUpdate = true;\n\n\t}\n\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis.pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this.width, this.height );\n\n\t}\n\n\tupdateBefore( { renderer } ) {\n\n\t\tif ( this.textureNeedsUpdate === false && this.autoUpdate === false ) return;\n\n\t\tthis.textureNeedsUpdate = false;\n\n\t\t//\n\n\t\tif ( this.autoSize === true ) {\n\n\t\t\tthis.pixelRatio = renderer.getPixelRatio();\n\n\t\t\tconst size = renderer.getSize( _size$1 );\n\n\t\t\tthis.setSize( size.width, size.height );\n\n\t\t}\n\n\t\t//\n\n\t\tthis._quadMesh.material.fragmentNode = this._rttNode;\n\n\t\t//\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\trenderer.setRenderTarget( this.renderTarget );\n\n\t\tthis._quadMesh.render( renderer );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new TextureNode( this.value, this.uvNode, this.levelNode );\n\t\tnewNode.sampler = this.sampler;\n\t\tnewNode.referenceNode = this;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\nconst rtt = ( node, ...params ) => nodeObject( new RTTNode( nodeObject( node ), ...params ) );\n\nconst convertToTexture = ( node, ...params ) => {\n\n\tif ( node.isTextureNode ) return node;\n\tif ( node.isPassNode ) return node.getTextureNode();\n\n\treturn rtt( node, ...params );\n\n};\n\n/**\n* Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments\n* depth value and the camera's inverse projection matrix.\n*\n* @param {vec2} screenPosition - The fragment's screen position expressed as uv coordinates.\n* @param {float} depth - The fragment's depth value.\n* @param {mat4} projectionMatrixInverse - The camera's inverse projection matrix.\n* @return {vec3} The fragments position in view space.\n*/\nconst getViewPosition = /*@__PURE__*/ Fn( ( [ screenPosition, depth, projectionMatrixInverse ], builder ) => {\n\n\tlet clipSpacePosition;\n\n\tif ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\tscreenPosition = vec2( screenPosition.x, screenPosition.y.oneMinus() ).mul( 2.0 ).sub( 1.0 );\n\t\tclipSpacePosition = vec4( vec3( screenPosition, depth ), 1.0 );\n\n\t} else {\n\n\t\tclipSpacePosition = vec4( vec3( screenPosition.x, screenPosition.y.oneMinus(), depth ).mul( 2.0 ).sub( 1.0 ), 1.0 );\n\n\t}\n\n\tconst viewSpacePosition = vec4( projectionMatrixInverse.mul( clipSpacePosition ) );\n\n\treturn viewSpacePosition.xyz.div( viewSpacePosition.w );\n\n} );\n\n/**\n* Computes a screen position expressed as uv coordinates based on a fragment's position in view space\n* and the camera's projection matrix\n*\n* @param {vec3} viewPosition - The fragments position in view space.\n* @param {mat4} projectionMatrix - The camera's projection matrix.\n* @return {vec2} The fragment's screen position expressed as uv coordinates.\n*/\nconst getScreenPosition = /*@__PURE__*/ Fn( ( [ viewPosition, projectionMatrix ] ) => {\n\n\tconst sampleClipPos = projectionMatrix.mul( vec4( viewPosition, 1.0 ) );\n\tconst sampleUv = sampleClipPos.xy.div( sampleClipPos.w ).mul( 0.5 ).add( 0.5 ).toVar();\n\treturn vec2( sampleUv.x, sampleUv.y.oneMinus() );\n\n} );\n\n/**\n* Computes a normal vector based on depth data. Can be used as a fallback when no normal render\n* target is available or if flat surface normals are required.\n*\n* @param {vec2} uv - The texture coordinate.\n* @param {DepthTexture} depthTexture - The depth texture.\n* @param {mat4} projectionMatrixInverse - The camera's inverse projection matrix.\n* @return {vec3} The computed normal vector.\n*/\nconst getNormalFromDepth = /*@__PURE__*/ Fn( ( [ uv, depthTexture, projectionMatrixInverse ] ) => {\n\n\tconst size = textureSize( textureLoad( depthTexture ) );\n\tconst p = ivec2( uv.mul( size ) ).toVar();\n\n\tconst c0 = textureLoad( depthTexture, p ).toVar();\n\n\tconst l2 = textureLoad( depthTexture, p.sub( ivec2( 2, 0 ) ) ).toVar();\n\tconst l1 = textureLoad( depthTexture, p.sub( ivec2( 1, 0 ) ) ).toVar();\n\tconst r1 = textureLoad( depthTexture, p.add( ivec2( 1, 0 ) ) ).toVar();\n\tconst r2 = textureLoad( depthTexture, p.add( ivec2( 2, 0 ) ) ).toVar();\n\tconst b2 = textureLoad( depthTexture, p.add( ivec2( 0, 2 ) ) ).toVar();\n\tconst b1 = textureLoad( depthTexture, p.add( ivec2( 0, 1 ) ) ).toVar();\n\tconst t1 = textureLoad( depthTexture, p.sub( ivec2( 0, 1 ) ) ).toVar();\n\tconst t2 = textureLoad( depthTexture, p.sub( ivec2( 0, 2 ) ) ).toVar();\n\n\tconst dl = abs( sub( float( 2 ).mul( l1 ).sub( l2 ), c0 ) ).toVar();\n\tconst dr = abs( sub( float( 2 ).mul( r1 ).sub( r2 ), c0 ) ).toVar();\n\tconst db = abs( sub( float( 2 ).mul( b1 ).sub( b2 ), c0 ) ).toVar();\n\tconst dt = abs( sub( float( 2 ).mul( t1 ).sub( t2 ), c0 ) ).toVar();\n\n\tconst ce = getViewPosition( uv, c0, projectionMatrixInverse ).toVar();\n\n\tconst dpdx = dl.lessThan( dr ).select( ce.sub( getViewPosition( uv.sub( vec2( float( 1 ).div( size.x ), 0 ) ), l1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.add( vec2( float( 1 ).div( size.x ), 0 ) ), r1, projectionMatrixInverse ) ) );\n\tconst dpdy = db.lessThan( dt ).select( ce.sub( getViewPosition( uv.add( vec2( 0, float( 1 ).div( size.y ) ) ), b1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.sub( vec2( 0, float( 1 ).div( size.y ) ) ), t1, projectionMatrixInverse ) ) );\n\n\treturn normalize( cross( dpdx, dpdy ) );\n\n} );\n\nclass StorageInstancedBufferAttribute extends InstancedBufferAttribute {\n\n\tconstructor( array, itemSize, typeClass = Float32Array ) {\n\n\t\tif ( ArrayBuffer.isView( array ) === false ) array = new typeClass( array * itemSize );\n\n\t\tsuper( array, itemSize );\n\n\t\tthis.isStorageInstancedBufferAttribute = true;\n\n\t}\n\n}\n\nclass StorageBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, typeClass = Float32Array ) {\n\n\t\tif ( ArrayBuffer.isView( array ) === false ) array = new typeClass( array * itemSize );\n\n\t\tsuper( array, itemSize );\n\n\t\tthis.isStorageBufferAttribute = true;\n\n\t}\n\n}\n\nclass StorageArrayElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageArrayElementNode';\n\n\t}\n\n\tconstructor( storageBufferNode, indexNode ) {\n\n\t\tsuper( storageBufferNode, indexNode );\n\n\t\tthis.isStorageArrayElementNode = true;\n\n\t}\n\n\tset storageBufferNode( value ) {\n\n\t\tthis.node = value;\n\n\t}\n\n\tget storageBufferNode() {\n\n\t\treturn this.node;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) === false ) {\n\n\t\t\tif ( this.node.isPBO === true ) {\n\n\t\t\t\tbuilder.setupPBO( this.node );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tconst isAssignContext = builder.context.assign;\n\n\t\t//\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) === false ) {\n\n\t\t\tif ( this.node.isPBO === true && isAssignContext !== true && ( this.node.value.isInstancedBufferAttribute || builder.shaderStage !== 'compute' ) ) {\n\n\t\t\t\tsnippet = builder.generatePBO( this );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = this.node.build( builder );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsnippet = super.generate( builder );\n\n\t\t}\n\n\t\tif ( isAssignContext !== true ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tsnippet = builder.format( snippet, type, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n}\n\nconst storageElement = /*@__PURE__*/ nodeProxy( StorageArrayElementNode );\n\nclass StorageBufferNode extends BufferNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageBufferNode';\n\n\t}\n\n\tconstructor( value, bufferType = null, bufferCount = 0 ) {\n\n\t\tif ( bufferType === null && ( value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute ) ) {\n\n\t\t\tbufferType = getTypeFromLength( value.itemSize );\n\t\t\tbufferCount = value.count;\n\n\t\t}\n\n\t\tsuper( value, bufferType, bufferCount );\n\n\t\tthis.isStorageBufferNode = true;\n\n\t\tthis.access = NodeAccess.READ_WRITE;\n\t\tthis.isAtomic = false;\n\t\tthis.isPBO = false;\n\n\t\tthis.bufferCount = bufferCount;\n\n\t\tthis._attribute = null;\n\t\tthis._varying = null;\n\n\t\tthis.global = true;\n\n\t\tif ( value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true ) {\n\n\t\t\t// TOOD: Improve it, possibly adding a new property to the BufferAttribute to identify it as a storage buffer read-only attribute in Renderer\n\n\t\t\tif ( value.isInstancedBufferAttribute ) value.isStorageInstancedBufferAttribute = true;\n\t\t\telse value.isStorageBufferAttribute = true;\n\n\t\t}\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\tif ( this.bufferCount === 0 ) {\n\n\t\t\tlet bufferData = builder.globalCache.getData( this.value );\n\n\t\t\tif ( bufferData === undefined ) {\n\n\t\t\t\tbufferData = {\n\t\t\t\t\tnode: this\n\t\t\t\t};\n\n\t\t\t\tbuilder.globalCache.setData( this.value, bufferData );\n\n\t\t\t}\n\n\t\t\treturn bufferData.node.uuid;\n\n\t\t}\n\n\t\treturn this.uuid;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer';\n\n\t}\n\n\telement( indexNode ) {\n\n\t\treturn storageElement( this, indexNode );\n\n\t}\n\n\tsetPBO( value ) {\n\n\t\tthis.isPBO = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetPBO() {\n\n\t\treturn this.isPBO;\n\n\t}\n\n\tsetAccess( value ) {\n\n\t\tthis.access = value;\n\n\t\treturn this;\n\n\t}\n\n\ttoReadOnly() {\n\n\t\treturn this.setAccess( NodeAccess.READ_ONLY );\n\n\t}\n\n\tsetAtomic( value ) {\n\n\t\tthis.isAtomic = value;\n\n\t\treturn this;\n\n\t}\n\n\ttoAtomic() {\n\n\t\treturn this.setAtomic( true );\n\n\t}\n\n\tgetAttributeData() {\n\n\t\tif ( this._attribute === null ) {\n\n\t\t\tthis._attribute = bufferAttribute( this.value );\n\t\t\tthis._varying = varying( this._attribute );\n\n\t\t}\n\n\t\treturn {\n\t\t\tattribute: this._attribute,\n\t\t\tvarying: this._varying\n\t\t};\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {\n\n\t\t\treturn super.getNodeType( builder );\n\n\t\t}\n\n\t\tconst { attribute } = this.getAttributeData();\n\n\t\treturn attribute.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {\n\n\t\t\treturn super.generate( builder );\n\n\t\t}\n\n\t\tconst { attribute, varying } = this.getAttributeData();\n\n\t\tconst output = varying.build( builder );\n\n\t\tbuilder.registerTransform( output, attribute );\n\n\t\treturn output;\n\n\t}\n\n}\n\nconst storage = ( value, type, count ) => nodeObject( new StorageBufferNode( value, type, count ) );\n\nconst storageObject = ( value, type, count ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"storageObject()\" is deprecated. Use \"storage().setPBO( true )\" instead.' );\n\n\treturn storage( value, type, count ).setPBO( true );\n\n};\n\nconst attributeArray = ( count, type = 'float' ) => {\n\n\tconst itemSize = getLengthFromType( type );\n\n\tconst buffer = new StorageBufferAttribute( count, itemSize );\n\tconst node = storage( buffer, type, count );\n\n\treturn node;\n\n};\n\n\nconst instancedArray = ( count, type = 'float' ) => {\n\n\tconst itemSize = getLengthFromType( type );\n\n\tconst buffer = new StorageInstancedBufferAttribute( count, itemSize );\n\tconst node = storage( buffer, type, count );\n\n\treturn node;\n\n};\n\nclass VertexColorNode extends AttributeNode {\n\n\tstatic get type() {\n\n\t\treturn 'VertexColorNode';\n\n\t}\n\n\tconstructor( index = 0 ) {\n\n\t\tsuper( null, 'vec4' );\n\n\t\tthis.isVertexColorNode = true;\n\n\t\tthis.index = index;\n\n\t}\n\n\tgetAttributeName( /*builder*/ ) {\n\n\t\tconst index = this.index;\n\n\t\treturn 'color' + ( index > 0 ? index : '' );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tlet result;\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tresult = super.generate( builder );\n\n\t\t} else {\n\n\t\t\t// Vertex color fallback should be white\n\t\t\tresult = builder.generateConst( this.nodeType, new Vector4( 1, 1, 1, 1 ) );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.index = this.index;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.index = data.index;\n\n\t}\n\n}\n\nconst vertexColor = ( ...params ) => nodeObject( new VertexColorNode( ...params ) );\n\nclass PointUVNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'PointUVNode';\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t\tthis.isPointUVNode = true;\n\n\t}\n\n\tgenerate( /*builder*/ ) {\n\n\t\treturn 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';\n\n\t}\n\n}\n\nconst pointUV = /*@__PURE__*/ nodeImmutable( PointUVNode );\n\nconst _e1 = /*@__PURE__*/ new Euler();\nconst _m1 = /*@__PURE__*/ new Matrix4();\n\nclass SceneNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SceneNode';\n\n\t}\n\n\tconstructor( scope = SceneNode.BACKGROUND_BLURRINESS, scene = null ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\t\tthis.scene = scene;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst scope = this.scope;\n\t\tconst scene = this.scene !== null ? this.scene : builder.scene;\n\n\t\tlet output;\n\n\t\tif ( scope === SceneNode.BACKGROUND_BLURRINESS ) {\n\n\t\t\toutput = reference( 'backgroundBlurriness', 'float', scene );\n\n\t\t} else if ( scope === SceneNode.BACKGROUND_INTENSITY ) {\n\n\t\t\toutput = reference( 'backgroundIntensity', 'float', scene );\n\n\t\t} else if ( scope === SceneNode.BACKGROUND_ROTATION ) {\n\n\t\t\toutput = uniform( 'mat4' ).label( 'backgroundRotation' ).setGroup( renderGroup ).onRenderUpdate( () => {\n\n\t\t\t\tconst background = scene.background;\n\n\t\t\t\tif ( background !== null && background.isTexture && background.mapping !== UVMapping ) {\n\n\t\t\t\t\t_e1.copy( scene.backgroundRotation );\n\n\t\t\t\t\t// accommodate left-handed frame\n\t\t\t\t\t_e1.x *= - 1; _e1.y *= - 1; _e1.z *= - 1;\n\n\t\t\t\t\t_m1.makeRotationFromEuler( _e1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_m1.identity();\n\n\t\t\t\t}\n\n\t\t\t\treturn _m1;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.SceneNode: Unknown scope:', scope );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nSceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';\nSceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';\nSceneNode.BACKGROUND_ROTATION = 'backgroundRotation';\n\nconst backgroundBlurriness = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_BLURRINESS );\nconst backgroundIntensity = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_INTENSITY );\nconst backgroundRotation = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_ROTATION );\n\nclass StorageTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageTextureNode';\n\n\t}\n\n\tconstructor( value, uvNode, storeNode = null ) {\n\n\t\tsuper( value, uvNode );\n\n\t\tthis.storeNode = storeNode;\n\n\t\tthis.isStorageTextureNode = true;\n\n\t\tthis.access = NodeAccess.WRITE_ONLY;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'storageTexture';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.storeNode = this.storeNode;\n\n\t}\n\n\tsetAccess( value ) {\n\n\t\tthis.access = value;\n\t\treturn this;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tif ( this.storeNode !== null ) {\n\n\t\t\tsnippet = this.generateStore( builder );\n\n\t\t} else {\n\n\t\t\tsnippet = super.generate( builder, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\ttoReadWrite() {\n\n\t\treturn this.setAccess( NodeAccess.READ_WRITE );\n\n\t}\n\n\ttoReadOnly() {\n\n\t\treturn this.setAccess( NodeAccess.READ_ONLY );\n\n\t}\n\n\ttoWriteOnly() {\n\n\t\treturn this.setAccess( NodeAccess.WRITE_ONLY );\n\n\t}\n\n\tgenerateStore( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst { uvNode, storeNode } = properties;\n\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\t\tconst uvSnippet = uvNode.build( builder, 'uvec2' );\n\t\tconst storeSnippet = storeNode.build( builder, 'vec4' );\n\n\t\tconst snippet = builder.generateTextureStore( builder, textureProperty, uvSnippet, storeSnippet );\n\n\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t}\n\n}\n\nconst storageTexture = /*@__PURE__*/ nodeProxy( StorageTextureNode );\n\nconst textureStore = ( value, uvNode, storeNode ) => {\n\n\tconst node = storageTexture( value, uvNode, storeNode );\n\n\tif ( storeNode !== null ) node.append();\n\n\treturn node;\n\n};\n\nclass UserDataNode extends ReferenceNode {\n\n\tstatic get type() {\n\n\t\treturn 'UserDataNode';\n\n\t}\n\n\tconstructor( property, inputType, userData = null ) {\n\n\t\tsuper( property, inputType, userData );\n\n\t\tthis.userData = userData;\n\n\t}\n\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.userData !== null ? this.userData : state.object.userData;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\nconst userData = ( name, inputType, userData ) => nodeObject( new UserDataNode( name, inputType, userData ) );\n\nconst _objectData = new WeakMap();\n\nclass VelocityNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'VelocityNode';\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t\tthis.projectionMatrix = null;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\t\tthis.updateAfterType = NodeUpdateType.OBJECT;\n\n\t\tthis.previousModelWorldMatrix = uniform( new Matrix4() );\n\t\tthis.previousProjectionMatrix = uniform( new Matrix4() ).setGroup( renderGroup );\n\t\tthis.previousCameraViewMatrix = uniform( new Matrix4() );\n\n\t}\n\n\tsetProjectionMatrix( projectionMatrix ) {\n\n\t\tthis.projectionMatrix = projectionMatrix;\n\n\t}\n\n\tupdate( { frameId, camera, object } ) {\n\n\t\tconst previousModelMatrix = getPreviousMatrix( object );\n\n\t\tthis.previousModelWorldMatrix.value.copy( previousModelMatrix );\n\n\t\t//\n\n\t\tconst cameraData = getData( camera );\n\n\t\tif ( cameraData.frameId !== frameId ) {\n\n\t\t\tcameraData.frameId = frameId;\n\n\t\t\tif ( cameraData.previousProjectionMatrix === undefined ) {\n\n\t\t\t\tcameraData.previousProjectionMatrix = new Matrix4();\n\t\t\t\tcameraData.previousCameraViewMatrix = new Matrix4();\n\n\t\t\t\tcameraData.currentProjectionMatrix = new Matrix4();\n\t\t\t\tcameraData.currentCameraViewMatrix = new Matrix4();\n\n\t\t\t\tcameraData.previousProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );\n\t\t\t\tcameraData.previousCameraViewMatrix.copy( camera.matrixWorldInverse );\n\n\t\t\t} else {\n\n\t\t\t\tcameraData.previousProjectionMatrix.copy( cameraData.currentProjectionMatrix );\n\t\t\t\tcameraData.previousCameraViewMatrix.copy( cameraData.currentCameraViewMatrix );\n\n\t\t\t}\n\n\t\t\tcameraData.currentProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );\n\t\t\tcameraData.currentCameraViewMatrix.copy( camera.matrixWorldInverse );\n\n\t\t\tthis.previousProjectionMatrix.value.copy( cameraData.previousProjectionMatrix );\n\t\t\tthis.previousCameraViewMatrix.value.copy( cameraData.previousCameraViewMatrix );\n\n\t\t}\n\n\t}\n\n\tupdateAfter( { object } ) {\n\n\t\tgetPreviousMatrix( object ).copy( object.matrixWorld );\n\n\t}\n\n\tsetup( /*builder*/ ) {\n\n\t\tconst projectionMatrix = ( this.projectionMatrix === null ) ? cameraProjectionMatrix : uniform( this.projectionMatrix );\n\n\t\tconst previousModelViewMatrix = this.previousCameraViewMatrix.mul( this.previousModelWorldMatrix );\n\n\t\tconst clipPositionCurrent = projectionMatrix.mul( modelViewMatrix ).mul( positionLocal );\n\t\tconst clipPositionPrevious = this.previousProjectionMatrix.mul( previousModelViewMatrix ).mul( positionPrevious );\n\n\t\tconst ndcPositionCurrent = clipPositionCurrent.xy.div( clipPositionCurrent.w );\n\t\tconst ndcPositionPrevious = clipPositionPrevious.xy.div( clipPositionPrevious.w );\n\n\t\tconst velocity = sub( ndcPositionCurrent, ndcPositionPrevious );\n\n\t\treturn velocity;\n\n\t}\n\n}\n\nfunction getData( object ) {\n\n\tlet objectData = _objectData.get( object );\n\n\tif ( objectData === undefined ) {\n\n\t\tobjectData = {};\n\t\t_objectData.set( object, objectData );\n\n\t}\n\n\treturn objectData;\n\n}\n\nfunction getPreviousMatrix( object, index = 0 ) {\n\n\tconst objectData = getData( object );\n\n\tlet matrix = objectData[ index ];\n\n\tif ( matrix === undefined ) {\n\n\t\tobjectData[ index ] = matrix = new Matrix4();\n\n\t}\n\n\treturn matrix;\n\n}\n\nconst velocity = /*@__PURE__*/ nodeImmutable( VelocityNode );\n\nconst blendBurn = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn min$1( 1.0, base.oneMinus().div( blend ) ).oneMinus();\n\n} ).setLayout( {\n\tname: 'blendBurn',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\nconst blendDodge = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn min$1( base.div( blend.oneMinus() ), 1.0 );\n\n} ).setLayout( {\n\tname: 'blendDodge',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\nconst blendScreen = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn base.oneMinus().mul( blend.oneMinus() ).oneMinus();\n\n} ).setLayout( {\n\tname: 'blendScreen',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\nconst blendOverlay = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn mix( base.mul( 2.0 ).mul( blend ), base.oneMinus().mul( 2.0 ).mul( blend.oneMinus() ).oneMinus(), step( 0.5, base ) );\n\n} ).setLayout( {\n\tname: 'blendOverlay',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\nconst blendColor = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\tconst outAlpha = blend.a.add( base.a.mul( blend.a.oneMinus() ) );\n\n\treturn vec4( blend.rgb.mul( blend.a ).add( base.rgb.mul( base.a ).mul( blend.a.oneMinus() ) ).div( outAlpha ), outAlpha );\n\n} ).setLayout( {\n\tname: 'blendColor',\n\ttype: 'vec4',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec4' },\n\t\t{ name: 'blend', type: 'vec4' }\n\t]\n} );\n\n// deprecated\n\nconst burn = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"burn\" has been renamed. Use \"blendBurn\" instead.' );\n\treturn blendBurn( params );\n\n};\n\nconst dodge = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"dodge\" has been renamed. Use \"blendDodge\" instead.' );\n\treturn blendDodge( params );\n\n};\n\nconst screen = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"screen\" has been renamed. Use \"blendScreen\" instead.' );\n\treturn blendScreen( params );\n\n};\n\nconst overlay = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"overlay\" has been renamed. Use \"blendOverlay\" instead.' );\n\treturn blendOverlay( params );\n\n};\n\nconst grayscale = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\treturn luminance( color.rgb );\n\n} );\n\nconst saturation = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\treturn adjustment.mix( luminance( color.rgb ), color.rgb );\n\n} );\n\nconst vibrance = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\tconst average = add( color.r, color.g, color.b ).div( 3.0 );\n\n\tconst mx = color.r.max( color.g.max( color.b ) );\n\tconst amt = mx.sub( average ).mul( adjustment ).mul( - 3.0 );\n\n\treturn mix( color.rgb, mx, amt );\n\n} );\n\nconst hue = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\tconst k = vec3( 0.57735, 0.57735, 0.57735 );\n\n\tconst cosAngle = adjustment.cos();\n\n\treturn vec3( color.rgb.mul( cosAngle ).add( k.cross( color.rgb ).mul( adjustment.sin() ).add( k.mul( dot( k, color.rgb ).mul( cosAngle.oneMinus() ) ) ) ) );\n\n} );\n\nconst luminance = (\n\tcolor,\n\tluminanceCoefficients = vec3( ColorManagement.getLuminanceCoefficients( new Vector3() ) )\n) => dot( color, luminanceCoefficients );\n\nconst threshold = ( color, threshold ) => mix( vec3( 0.0 ), color, luminance( color ).sub( threshold ).max( 0 ) );\n\n/**\n * Color Decision List (CDL) v1.2\n *\n * Compact representation of color grading information, defined by slope, offset, power, and\n * saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,\n * or AgX Log), and will return output in the same space. Output may require clamping >=0.\n *\n * @param {vec4} color Input (-Infinity < input < +Infinity)\n * @param {number | vec3} slope Slope (0  slope < +Infinity)\n * @param {number | vec3} offset Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1)\n * @param {number | vec3} power Power (0 < power < +Infinity)\n * @param {number} saturation Saturation (0  saturation < +Infinity; typically 0  saturation < 4)\n * @param {vec3} luminanceCoefficients Luminance coefficients for saturation term, typically Rec. 709\n * @return Output, -Infinity < output < +Infinity\n *\n * References:\n * - ASC CDL v1.2\n * - https://blender.stackexchange.com/a/55239/43930\n * - https://docs.acescentral.com/specifications/acescc/\n */\nconst cdl = /*@__PURE__*/ Fn( ( [\n\tcolor,\n\tslope = vec3( 1 ),\n\toffset = vec3( 0 ),\n\tpower = vec3( 1 ),\n\tsaturation = float( 1 ),\n\t// ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.\n\tluminanceCoefficients = vec3( ColorManagement.getLuminanceCoefficients( new Vector3(), LinearSRGBColorSpace ) )\n] ) => {\n\n\t// NOTE: The ASC CDL v1.2 defines a [0, 1] clamp on the slope+offset term, and another on the\n\t// saturation term. Per the ACEScc specification and Filament, limits may be omitted to support\n\t// values outside [0, 1], requiring a workaround for negative values in the power expression.\n\n\tconst luma = color.rgb.dot( vec3( luminanceCoefficients ) );\n\n\tconst v = max$1( color.rgb.mul( slope ).add( offset ), 0.0 ).toVar();\n\tconst pv = v.pow( power ).toVar();\n\n\tIf( v.r.greaterThan( 0.0 ), () => { v.r.assign( pv.r ); } ); // eslint-disable-line\n\tIf( v.g.greaterThan( 0.0 ), () => { v.g.assign( pv.g ); } ); // eslint-disable-line\n\tIf( v.b.greaterThan( 0.0 ), () => { v.b.assign( pv.b ); } ); // eslint-disable-line\n\n\tv.assign( luma.add( v.sub( luma ).mul( saturation ) ) );\n\n\treturn vec4( v.rgb, color.a );\n\n} );\n\nclass PosterizeNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PosterizeNode';\n\n\t}\n\n\tconstructor( sourceNode, stepsNode ) {\n\n\t\tsuper();\n\n\t\tthis.sourceNode = sourceNode;\n\t\tthis.stepsNode = stepsNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { sourceNode, stepsNode } = this;\n\n\t\treturn sourceNode.mul( stepsNode ).floor().div( stepsNode );\n\n\t}\n\n}\n\nconst posterize = /*@__PURE__*/ nodeProxy( PosterizeNode );\n\nconst _size = /*@__PURE__*/ new Vector2();\n\nclass PassTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassTextureNode';\n\n\t}\n\n\tconstructor( passNode, texture ) {\n\n\t\tsuper( texture );\n\n\t\tthis.passNode = passNode;\n\n\t\tthis.setUpdateMatrix( false );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( builder.object.isQuadMesh ) this.passNode.build( builder );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.passNode, this.value );\n\n\t}\n\n}\n\nclass PassMultipleTextureNode extends PassTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassMultipleTextureNode';\n\n\t}\n\n\tconstructor( passNode, textureName, previousTexture = false ) {\n\n\t\tsuper( passNode, null );\n\n\t\tthis.textureName = textureName;\n\t\tthis.previousTexture = previousTexture;\n\n\t}\n\n\tupdateTexture() {\n\n\t\tthis.value = this.previousTexture ? this.passNode.getPreviousTexture( this.textureName ) : this.passNode.getTexture( this.textureName );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.updateTexture();\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.passNode, this.textureName, this.previousTexture );\n\n\t}\n\n}\n\nclass PassNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassNode';\n\n\t}\n\n\tconstructor( scope, scene, camera, options = {} ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.scope = scope;\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\t\tthis.options = options;\n\n\t\tthis._pixelRatio = 1;\n\t\tthis._width = 1;\n\t\tthis._height = 1;\n\n\t\tconst depthTexture = new DepthTexture();\n\t\tdepthTexture.isRenderTargetTexture = true;\n\t\t//depthTexture.type = FloatType;\n\t\tdepthTexture.name = 'depth';\n\n\t\tconst renderTarget = new RenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options, } );\n\t\trenderTarget.texture.name = 'output';\n\t\trenderTarget.depthTexture = depthTexture;\n\n\t\tthis.renderTarget = renderTarget;\n\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\tthis._textures = {\n\t\t\toutput: renderTarget.texture,\n\t\t\tdepth: depthTexture\n\t\t};\n\n\t\tthis._textureNodes = {};\n\t\tthis._linearDepthNodes = {};\n\t\tthis._viewZNodes = {};\n\n\t\tthis._previousTextures = {};\n\t\tthis._previousTextureNodes = {};\n\n\t\tthis._cameraNear = uniform( 0 );\n\t\tthis._cameraFar = uniform( 0 );\n\n\t\tthis._mrt = null;\n\n\t\tthis.isPassNode = true;\n\n\t}\n\n\tsetMRT( mrt ) {\n\n\t\tthis._mrt = mrt;\n\n\t\treturn this;\n\n\t}\n\n\tgetMRT() {\n\n\t\treturn this._mrt;\n\n\t}\n\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\tgetTexture( name ) {\n\n\t\tlet texture = this._textures[ name ];\n\n\t\tif ( texture === undefined ) {\n\n\t\t\tconst refTexture = this.renderTarget.texture;\n\n\t\t\ttexture = refTexture.clone();\n\t\t\ttexture.isRenderTargetTexture = true;\n\t\t\ttexture.name = name;\n\n\t\t\tthis._textures[ name ] = texture;\n\n\t\t\tthis.renderTarget.textures.push( texture );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tgetPreviousTexture( name ) {\n\n\t\tlet texture = this._previousTextures[ name ];\n\n\t\tif ( texture === undefined ) {\n\n\t\t\ttexture = this.getTexture( name ).clone();\n\t\t\ttexture.isRenderTargetTexture = true;\n\n\t\t\tthis._previousTextures[ name ] = texture;\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\ttoggleTexture( name ) {\n\n\t\tconst prevTexture = this._previousTextures[ name ];\n\n\t\tif ( prevTexture !== undefined ) {\n\n\t\t\tconst texture = this._textures[ name ];\n\n\t\t\tconst index = this.renderTarget.textures.indexOf( texture );\n\t\t\tthis.renderTarget.textures[ index ] = prevTexture;\n\n\t\t\tthis._textures[ name ] = prevTexture;\n\t\t\tthis._previousTextures[ name ] = texture;\n\n\t\t\tthis._textureNodes[ name ].updateTexture();\n\t\t\tthis._previousTextureNodes[ name ].updateTexture();\n\n\t\t}\n\n\t}\n\n\tgetTextureNode( name = 'output' ) {\n\n\t\tlet textureNode = this._textureNodes[ name ];\n\n\t\tif ( textureNode === undefined ) {\n\n\t\t\ttextureNode = nodeObject( new PassMultipleTextureNode( this, name ) );\n\t\t\ttextureNode.updateTexture();\n\t\t\tthis._textureNodes[ name ] = textureNode;\n\n\t\t}\n\n\t\treturn textureNode;\n\n\t}\n\n\tgetPreviousTextureNode( name = 'output' ) {\n\n\t\tlet textureNode = this._previousTextureNodes[ name ];\n\n\t\tif ( textureNode === undefined ) {\n\n\t\t\tif ( this._textureNodes[ name ] === undefined ) this.getTextureNode( name );\n\n\t\t\ttextureNode = nodeObject( new PassMultipleTextureNode( this, name, true ) );\n\t\t\ttextureNode.updateTexture();\n\t\t\tthis._previousTextureNodes[ name ] = textureNode;\n\n\t\t}\n\n\t\treturn textureNode;\n\n\t}\n\n\tgetViewZNode( name = 'depth' ) {\n\n\t\tlet viewZNode = this._viewZNodes[ name ];\n\n\t\tif ( viewZNode === undefined ) {\n\n\t\t\tconst cameraNear = this._cameraNear;\n\t\t\tconst cameraFar = this._cameraFar;\n\n\t\t\tthis._viewZNodes[ name ] = viewZNode = perspectiveDepthToViewZ( this.getTextureNode( name ), cameraNear, cameraFar );\n\n\t\t}\n\n\t\treturn viewZNode;\n\n\t}\n\n\tgetLinearDepthNode( name = 'depth' ) {\n\n\t\tlet linearDepthNode = this._linearDepthNodes[ name ];\n\n\t\tif ( linearDepthNode === undefined ) {\n\n\t\t\tconst cameraNear = this._cameraNear;\n\t\t\tconst cameraFar = this._cameraFar;\n\t\t\tconst viewZNode = this.getViewZNode( name );\n\n\t\t\t// TODO: just if ( builder.camera.isPerspectiveCamera )\n\n\t\t\tthis._linearDepthNodes[ name ] = linearDepthNode = viewZToOrthographicDepth( viewZNode, cameraNear, cameraFar );\n\n\t\t}\n\n\t\treturn linearDepthNode;\n\n\t}\n\n\tsetup( { renderer } ) {\n\n\t\tthis.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;\n\n\t\t// Disable MSAA for WebGL backend for now\n\t\tif ( renderer.backend.isWebGLBackend === true ) {\n\n\t\t\tthis.renderTarget.samples = 0;\n\n\t\t}\n\n\t\tthis.renderTarget.depthTexture.isMultisampleRenderTargetTexture = this.renderTarget.samples > 1;\n\n\t\treturn this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\t\tconst { scene, camera } = this;\n\n\t\tthis._pixelRatio = renderer.getPixelRatio();\n\n\t\tconst size = renderer.getSize( _size );\n\n\t\tthis.setSize( size.width, size.height );\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentMRT = renderer.getMRT();\n\n\t\tthis._cameraNear.value = camera.near;\n\t\tthis._cameraFar.value = camera.far;\n\n\t\tfor ( const name in this._previousTextures ) {\n\n\t\t\tthis.toggleTexture( name );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( this.renderTarget );\n\t\trenderer.setMRT( this._mrt );\n\n\t\trenderer.render( scene, camera );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.setMRT( currentMRT );\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tconst effectiveWidth = this._width * this._pixelRatio;\n\t\tconst effectiveHeight = this._height * this._pixelRatio;\n\n\t\tthis.renderTarget.setSize( effectiveWidth, effectiveHeight );\n\n\t}\n\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this._width, this._height );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.renderTarget.dispose();\n\n\t}\n\n\n}\n\nPassNode.COLOR = 'color';\nPassNode.DEPTH = 'depth';\n\nconst pass = ( scene, camera, options ) => nodeObject( new PassNode( PassNode.COLOR, scene, camera, options ) );\nconst passTexture = ( pass, texture ) => nodeObject( new PassTextureNode( pass, texture ) );\nconst depthPass = ( scene, camera ) => nodeObject( new PassNode( PassNode.DEPTH, scene, camera ) );\n\nclass ToonOutlinePassNode extends PassNode {\n\n\tstatic get type() {\n\n\t\treturn 'ToonOutlinePassNode';\n\n\t}\n\n\tconstructor( scene, camera, colorNode, thicknessNode, alphaNode ) {\n\n\t\tsuper( PassNode.COLOR, scene, camera );\n\n\t\tthis.colorNode = colorNode;\n\t\tthis.thicknessNode = thicknessNode;\n\t\tthis.alphaNode = alphaNode;\n\n\t\tthis._materialCache = new WeakMap();\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\tconst currentRenderObjectFunction = renderer.getRenderObjectFunction();\n\n\t\trenderer.setRenderObjectFunction( ( object, scene, camera, geometry, material, group, lightsNode, clippingContext ) => {\n\n\t\t\t// only render outline for supported materials\n\n\t\t\tif ( material.isMeshToonMaterial || material.isMeshToonNodeMaterial ) {\n\n\t\t\t\tif ( material.wireframe === false ) {\n\n\t\t\t\t\tconst outlineMaterial = this._getOutlineMaterial( material );\n\t\t\t\t\trenderer.renderObject( object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// default\n\n\t\t\trenderer.renderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext );\n\n\t\t} );\n\n\t\tsuper.updateBefore( frame );\n\n\t\trenderer.setRenderObjectFunction( currentRenderObjectFunction );\n\n\t}\n\n\t_createMaterial() {\n\n\t\tconst material = new NodeMaterial();\n\t\tmaterial.isMeshToonOutlineMaterial = true;\n\t\tmaterial.name = 'Toon_Outline';\n\t\tmaterial.side = BackSide;\n\n\t\t// vertex node\n\n\t\tconst outlineNormal = normalLocal.negate();\n\t\tconst mvp = cameraProjectionMatrix.mul( modelViewMatrix );\n\n\t\tconst ratio = float( 1.0 ); // TODO: support outline thickness ratio for each vertex\n\t\tconst pos = mvp.mul( vec4( positionLocal, 1.0 ) );\n\t\tconst pos2 = mvp.mul( vec4( positionLocal.add( outlineNormal ), 1.0 ) );\n\t\tconst norm = normalize( pos.sub( pos2 ) ); // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\n\t\tmaterial.vertexNode = pos.add( norm.mul( this.thicknessNode ).mul( pos.w ).mul( ratio ) );\n\n\t\t// color node\n\n\t\tmaterial.colorNode = vec4( this.colorNode, this.alphaNode );\n\n\t\treturn material;\n\n\t}\n\n\t_getOutlineMaterial( originalMaterial ) {\n\n\t\tlet outlineMaterial = this._materialCache.get( originalMaterial );\n\n\t\tif ( outlineMaterial === undefined ) {\n\n\t\t\toutlineMaterial = this._createMaterial();\n\n\t\t\tthis._materialCache.set( originalMaterial, outlineMaterial );\n\n\t\t}\n\n\t\treturn outlineMaterial;\n\n\t}\n\n}\n\nconst toonOutlinePass = ( scene, camera, color = new Color( 0, 0, 0 ), thickness = 0.003, alpha = 1 ) => nodeObject( new ToonOutlinePassNode( scene, camera, nodeObject( color ), nodeObject( thickness ), nodeObject( alpha ) ) );\n\n// exposure only\n\nconst linearToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\treturn color.mul( exposure ).clamp();\n\n} ).setLayout( {\n\tname: 'linearToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf\n\nconst reinhardToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tcolor = color.mul( exposure );\n\n\treturn color.div( color.add( 1.0 ) ).clamp();\n\n} ).setLayout( {\n\tname: 'reinhardToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n\nconst cineonToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\t// filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor = color.mul( exposure );\n\tcolor = color.sub( 0.004 ).max( 0.0 );\n\n\tconst a = color.mul( color.mul( 6.2 ).add( 0.5 ) );\n\tconst b = color.mul( color.mul( 6.2 ).add( 1.7 ) ).add( 0.06 );\n\n\treturn a.div( b ).pow( 2.2 );\n\n} ).setLayout( {\n\tname: 'cineonToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n\nconst RRTAndODTFit = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.mul( color.add( 0.0245786 ) ).sub( 0.000090537 );\n\tconst b = color.mul( color.add( 0.4329510 ).mul( 0.983729 ) ).add( 0.238081 );\n\n\treturn a.div( b );\n\n} );\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n\nconst acesFilmicToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\t// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n\tconst ACESInputMat = mat3(\n\t\t0.59719, 0.35458, 0.04823,\n\t\t0.07600, 0.90834, 0.01566,\n\t\t0.02840, 0.13383, 0.83777\n\t);\n\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n\tconst ACESOutputMat = mat3(\n\t\t1.60475, - 0.53108, - 0.07367,\n\t\t- 0.10208, 1.10813, - 0.00605,\n\t\t- 0.00327, - 0.07276, 1.07602\n\t);\n\n\tcolor = color.mul( exposure ).div( 0.6 );\n\n\tcolor = ACESInputMat.mul( color );\n\n\t// Apply RRT and ODT\n\tcolor = RRTAndODTFit( color );\n\n\tcolor = ACESOutputMat.mul( color );\n\n\t// Clamp to [0, 1]\n\treturn color.clamp();\n\n} ).setLayout( {\n\tname: 'acesFilmicToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\nconst LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/ mat3( vec3( 1.6605, - 0.1246, - 0.0182 ), vec3( - 0.5876, 1.1329, - 0.1006 ), vec3( - 0.0728, - 0.0083, 1.1187 ) );\nconst LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/ mat3( vec3( 0.6274, 0.0691, 0.0164 ), vec3( 0.3293, 0.9195, 0.0880 ), vec3( 0.0433, 0.0113, 0.8956 ) );\n\nconst agxDefaultContrastApprox = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = vec3( x_immutable ).toVar();\n\tconst x2 = vec3( x.mul( x ) ).toVar();\n\tconst x4 = vec3( x2.mul( x2 ) ).toVar();\n\n\treturn float( 15.5 ).mul( x4.mul( x2 ) ).sub( mul( 40.14, x4.mul( x ) ) ).add( mul( 31.96, x4 ).sub( mul( 6.868, x2.mul( x ) ) ).add( mul( 0.4298, x2 ).add( mul( 0.1191, x ).sub( 0.00232 ) ) ) );\n\n} );\n\nconst agxToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tconst colortone = vec3( color ).toVar();\n\tconst AgXInsetMatrix = mat3( vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ), vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ), vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 ) );\n\tconst AgXOutsetMatrix = mat3( vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ), vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ), vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 ) );\n\tconst AgxMinEv = float( - 12.47393 );\n\tconst AgxMaxEv = float( 4.026069 );\n\tcolortone.mulAssign( exposure );\n\tcolortone.assign( LINEAR_SRGB_TO_LINEAR_REC2020.mul( colortone ) );\n\tcolortone.assign( AgXInsetMatrix.mul( colortone ) );\n\tcolortone.assign( max$1( colortone, 1e-10 ) );\n\tcolortone.assign( log2( colortone ) );\n\tcolortone.assign( colortone.sub( AgxMinEv ).div( AgxMaxEv.sub( AgxMinEv ) ) );\n\tcolortone.assign( clamp( colortone, 0.0, 1.0 ) );\n\tcolortone.assign( agxDefaultContrastApprox( colortone ) );\n\tcolortone.assign( AgXOutsetMatrix.mul( colortone ) );\n\tcolortone.assign( pow( max$1( vec3( 0.0 ), colortone ), vec3( 2.2 ) ) );\n\tcolortone.assign( LINEAR_REC2020_TO_LINEAR_SRGB.mul( colortone ) );\n\tcolortone.assign( clamp( colortone, 0.0, 1.0 ) );\n\n\treturn colortone;\n\n} ).setLayout( {\n\tname: 'agxToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n// https://modelviewer.dev/examples/tone-mapping\n\nconst neutralToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tconst StartCompression = float( 0.8 - 0.04 );\n\tconst Desaturation = float( 0.15 );\n\n\tcolor = color.mul( exposure );\n\n\tconst x = min$1( color.r, min$1( color.g, color.b ) );\n\tconst offset = select( x.lessThan( 0.08 ), x.sub( mul( 6.25, x.mul( x ) ) ), 0.04 );\n\n\tcolor.subAssign( offset );\n\n\tconst peak = max$1( color.r, max$1( color.g, color.b ) );\n\n\tIf( peak.lessThan( StartCompression ), () => {\n\n\t\treturn color;\n\n\t} );\n\n\tconst d = sub( 1, StartCompression );\n\tconst newPeak = sub( 1, d.mul( d ).div( peak.add( d.sub( StartCompression ) ) ) );\n\tcolor.mulAssign( newPeak.div( peak ) );\n\tconst g = sub( 1, div( 1, Desaturation.mul( peak.sub( newPeak ) ).add( 1 ) ) );\n\n\treturn mix( color, vec3( newPeak ), g );\n\n} ).setLayout( {\n\tname: 'neutralToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\nclass CodeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'CodeNode';\n\n\t}\n\n\tconstructor( code = '', includes = [], language = '' ) {\n\n\t\tsuper( 'code' );\n\n\t\tthis.isCodeNode = true;\n\n\t\tthis.code = code;\n\t\tthis.language = language;\n\n\t\tthis.includes = includes;\n\n\t}\n\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\tsetIncludes( includes ) {\n\n\t\tthis.includes = includes;\n\n\t\treturn this;\n\n\t}\n\n\tgetIncludes( /*builder*/ ) {\n\n\t\treturn this.includes;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst includes = this.getIncludes( builder );\n\n\t\tfor ( const include of includes ) {\n\n\t\t\tinclude.build( builder );\n\n\t\t}\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, this.getNodeType( builder ) );\n\t\tnodeCode.code = this.code;\n\n\t\treturn nodeCode.code;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.code = this.code;\n\t\tdata.language = this.language;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.code = data.code;\n\t\tthis.language = data.language;\n\n\t}\n\n}\n\nconst code = /*@__PURE__*/ nodeProxy( CodeNode );\n\nconst js = ( src, includes ) => code( src, includes, 'js' );\nconst wgsl = ( src, includes ) => code( src, includes, 'wgsl' );\nconst glsl = ( src, includes ) => code( src, includes, 'glsl' );\n\nclass FunctionNode extends CodeNode {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionNode';\n\n\t}\n\n\tconstructor( code = '', includes = [], language = '' ) {\n\n\t\tsuper( code, includes, language );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).type;\n\n\t}\n\n\tgetInputs( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).inputs;\n\n\t}\n\n\tgetNodeFunction( builder ) {\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tlet nodeFunction = nodeData.nodeFunction;\n\n\t\tif ( nodeFunction === undefined ) {\n\n\t\t\tnodeFunction = builder.parser.parseFunction( this.code );\n\n\t\t\tnodeData.nodeFunction = nodeFunction;\n\n\t\t}\n\n\t\treturn nodeFunction;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tsuper.generate( builder );\n\n\t\tconst nodeFunction = this.getNodeFunction( builder );\n\n\t\tconst name = nodeFunction.name;\n\t\tconst type = nodeFunction.type;\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, type );\n\n\t\tif ( name !== '' ) {\n\n\t\t\t// use a custom property name\n\n\t\t\tnodeCode.name = name;\n\n\t\t}\n\n\t\tconst propertyName = builder.getPropertyName( nodeCode );\n\n\t\tconst code = this.getNodeFunction( builder ).getCode( propertyName );\n\n\t\tnodeCode.code = code + '\\n';\n\n\t\tif ( output === 'property' ) {\n\n\t\t\treturn propertyName;\n\n\t\t} else {\n\n\t\t\treturn builder.format( `${ propertyName }()`, type, output );\n\n\t\t}\n\n\t}\n\n}\n\nconst nativeFn = ( code, includes = [], language = '' ) => {\n\n\tfor ( let i = 0; i < includes.length; i ++ ) {\n\n\t\tconst include = includes[ i ];\n\n\t\t// TSL Function: glslFn, wgslFn\n\n\t\tif ( typeof include === 'function' ) {\n\n\t\t\tincludes[ i ] = include.functionNode;\n\n\t\t}\n\n\t}\n\n\tconst functionNode = nodeObject( new FunctionNode( code, includes, language ) );\n\n\tconst fn = ( ...params ) => functionNode.call( ...params );\n\tfn.functionNode = functionNode;\n\n\treturn fn;\n\n};\n\nconst glslFn = ( code, includes ) => nativeFn( code, includes, 'glsl' );\nconst wgslFn = ( code, includes ) => nativeFn( code, includes, 'wgsl' );\n\nclass ScriptableValueNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScriptableValueNode';\n\n\t}\n\n\tconstructor( value = null ) {\n\n\t\tsuper();\n\n\t\tthis._value = value;\n\t\tthis._cache = null;\n\n\t\tthis.inputType = null;\n\t\tthis.outpuType = null;\n\n\t\tthis.events = new EventDispatcher();\n\n\t\tthis.isScriptableValueNode = true;\n\n\t}\n\n\tget isScriptableOutputNode() {\n\n\t\treturn this.outputType !== null;\n\n\t}\n\n\tset value( val ) {\n\n\t\tif ( this._value === val ) return;\n\n\t\tif ( this._cache && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer ) {\n\n\t\t\tURL.revokeObjectURL( this._cache );\n\n\t\t\tthis._cache = null;\n\n\t\t}\n\n\t\tthis._value = val;\n\n\t\tthis.events.dispatchEvent( { type: 'change' } );\n\n\t\tthis.refresh();\n\n\t}\n\n\tget value() {\n\n\t\treturn this._value;\n\n\t}\n\n\trefresh() {\n\n\t\tthis.events.dispatchEvent( { type: 'refresh' } );\n\n\t}\n\n\tgetValue() {\n\n\t\tconst value = this.value;\n\n\t\tif ( value && this._cache === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer ) {\n\n\t\t\tthis._cache = URL.createObjectURL( new Blob( [ value.value ] ) );\n\n\t\t} else if ( value && value.value !== null && value.value !== undefined && (\n\t\t\t( ( this.inputType === 'URL' || this.inputType === 'String' ) && typeof value.value === 'string' ) ||\n\t\t\t( this.inputType === 'Number' && typeof value.value === 'number' ) ||\n\t\t\t( this.inputType === 'Vector2' && value.value.isVector2 ) ||\n\t\t\t( this.inputType === 'Vector3' && value.value.isVector3 ) ||\n\t\t\t( this.inputType === 'Vector4' && value.value.isVector4 ) ||\n\t\t\t( this.inputType === 'Color' && value.value.isColor ) ||\n\t\t\t( this.inputType === 'Matrix3' && value.value.isMatrix3 ) ||\n\t\t\t( this.inputType === 'Matrix4' && value.value.isMatrix4 )\n\t\t) ) {\n\n\t\t\treturn value.value;\n\n\t\t}\n\n\t\treturn this._cache || value;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.value && this.value.isNode ? this.value.getNodeType( builder ) : 'float';\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.value && this.value.isNode ? this.value : float();\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tif ( this.value !== null ) {\n\n\t\t\tif ( this.inputType === 'ArrayBuffer' ) {\n\n\t\t\t\tdata.value = arrayBufferToBase64( this.value );\n\n\t\t\t} else {\n\n\t\t\t\tdata.value = this.value ? this.value.toJSON( data.meta ).uuid : null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdata.value = null;\n\n\t\t}\n\n\t\tdata.inputType = this.inputType;\n\t\tdata.outputType = this.outputType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tlet value = null;\n\n\t\tif ( data.value !== null ) {\n\n\t\t\tif ( data.inputType === 'ArrayBuffer' ) {\n\n\t\t\t\tvalue = base64ToArrayBuffer( data.value );\n\n\t\t\t} else if ( data.inputType === 'Texture' ) {\n\n\t\t\t\tvalue = data.meta.textures[ data.value ];\n\n\t\t\t} else {\n\n\t\t\t\tvalue = data.meta.nodes[ data.value ] || null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tthis.inputType = data.inputType;\n\t\tthis.outputType = data.outputType;\n\n\t}\n\n}\n\nconst scriptableValue = /*@__PURE__*/ nodeProxy( ScriptableValueNode );\n\nclass Resources extends Map {\n\n\tget( key, callback = null, ...params ) {\n\n\t\tif ( this.has( key ) ) return super.get( key );\n\n\t\tif ( callback !== null ) {\n\n\t\t\tconst value = callback( ...params );\n\t\t\tthis.set( key, value );\n\t\t\treturn value;\n\n\t\t}\n\n\t}\n\n}\n\nclass Parameters {\n\n\tconstructor( scriptableNode ) {\n\n\t\tthis.scriptableNode = scriptableNode;\n\n\t}\n\n\tget parameters() {\n\n\t\treturn this.scriptableNode.parameters;\n\n\t}\n\n\tget layout() {\n\n\t\treturn this.scriptableNode.getLayout();\n\n\t}\n\n\tgetInputLayout( id ) {\n\n\t\treturn this.scriptableNode.getInputLayout( id );\n\n\t}\n\n\tget( name ) {\n\n\t\tconst param = this.parameters[ name ];\n\t\tconst value = param ? param.getValue() : null;\n\n\t\treturn value;\n\n\t}\n\n}\n\nconst ScriptableNodeResources = new Resources();\n\nclass ScriptableNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScriptableNode';\n\n\t}\n\n\tconstructor( codeNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\tthis.codeNode = codeNode;\n\t\tthis.parameters = parameters;\n\n\t\tthis._local = new Resources();\n\t\tthis._output = scriptableValue();\n\t\tthis._outputs = {};\n\t\tthis._source = this.source;\n\t\tthis._method = null;\n\t\tthis._object = null;\n\t\tthis._value = null;\n\t\tthis._needsOutputUpdate = true;\n\n\t\tthis.onRefresh = this.onRefresh.bind( this );\n\n\t\tthis.isScriptableNode = true;\n\n\t}\n\n\tget source() {\n\n\t\treturn this.codeNode ? this.codeNode.code : '';\n\n\t}\n\n\tsetLocal( name, value ) {\n\n\t\treturn this._local.set( name, value );\n\n\t}\n\n\tgetLocal( name ) {\n\n\t\treturn this._local.get( name );\n\n\t}\n\n\tonRefresh() {\n\n\t\tthis._refresh();\n\n\t}\n\n\tgetInputLayout( id ) {\n\n\t\tfor ( const element of this.getLayout() ) {\n\n\t\t\tif ( element.inputType && ( element.id === id || element.name === id ) ) {\n\n\t\t\t\treturn element;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetOutputLayout( id ) {\n\n\t\tfor ( const element of this.getLayout() ) {\n\n\t\t\tif ( element.outputType && ( element.id === id || element.name === id ) ) {\n\n\t\t\t\treturn element;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetOutput( name, value ) {\n\n\t\tconst outputs = this._outputs;\n\n\t\tif ( outputs[ name ] === undefined ) {\n\n\t\t\toutputs[ name ] = scriptableValue( value );\n\n\t\t} else {\n\n\t\t\toutputs[ name ].value = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetOutput( name ) {\n\n\t\treturn this._outputs[ name ];\n\n\t}\n\n\tgetParameter( name ) {\n\n\t\treturn this.parameters[ name ];\n\n\t}\n\n\tsetParameter( name, value ) {\n\n\t\tconst parameters = this.parameters;\n\n\t\tif ( value && value.isScriptableNode ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t\tparameters[ name ] = value;\n\t\t\tparameters[ name ].getDefaultOutput().events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else if ( value && value.isScriptableValueNode ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t\tparameters[ name ] = value;\n\t\t\tparameters[ name ].events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else if ( parameters[ name ] === undefined ) {\n\n\t\t\tparameters[ name ] = scriptableValue( value );\n\t\t\tparameters[ name ].events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else {\n\n\t\t\tparameters[ name ].value = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.getDefaultOutput().getValue();\n\n\t}\n\n\tdeleteParameter( name ) {\n\n\t\tlet valueNode = this.parameters[ name ];\n\n\t\tif ( valueNode ) {\n\n\t\t\tif ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();\n\n\t\t\tvalueNode.events.removeEventListener( 'refresh', this.onRefresh );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclearParameters() {\n\n\t\tfor ( const name of Object.keys( this.parameters ) ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tcall( name, ...params ) {\n\n\t\tconst object = this.getObject();\n\t\tconst method = object[ name ];\n\n\t\tif ( typeof method === 'function' ) {\n\n\t\t\treturn method( ...params );\n\n\t\t}\n\n\t}\n\n\tasync callAsync( name, ...params ) {\n\n\t\tconst object = this.getObject();\n\t\tconst method = object[ name ];\n\n\t\tif ( typeof method === 'function' ) {\n\n\t\t\treturn method.constructor.name === 'AsyncFunction' ? await method( ...params ) : method( ...params );\n\n\t\t}\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.getDefaultOutputNode().getNodeType( builder );\n\n\t}\n\n\trefresh( output = null ) {\n\n\t\tif ( output !== null ) {\n\n\t\t\tthis.getOutput( output ).refresh();\n\n\t\t} else {\n\n\t\t\tthis._refresh();\n\n\t\t}\n\n\t}\n\n\tgetObject() {\n\n\t\tif ( this.needsUpdate ) this.dispose();\n\t\tif ( this._object !== null ) return this._object;\n\n\t\t//\n\n\t\tconst refresh = () => this.refresh();\n\t\tconst setOutput = ( id, value ) => this.setOutput( id, value );\n\n\t\tconst parameters = new Parameters( this );\n\n\t\tconst THREE = ScriptableNodeResources.get( 'THREE' );\n\t\tconst TSL = ScriptableNodeResources.get( 'TSL' );\n\n\t\tconst method = this.getMethod( this.codeNode );\n\t\tconst params = [ parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE, TSL ];\n\n\t\tthis._object = method( ...params );\n\n\t\tconst layout = this._object.layout;\n\n\t\tif ( layout ) {\n\n\t\t\tif ( layout.cache === false ) {\n\n\t\t\t\tthis._local.clear();\n\n\t\t\t}\n\n\t\t\t// default output\n\t\t\tthis._output.outputType = layout.outputType || null;\n\n\t\t\tif ( Array.isArray( layout.elements ) ) {\n\n\t\t\t\tfor ( const element of layout.elements ) {\n\n\t\t\t\t\tconst id = element.id || element.name;\n\n\t\t\t\t\tif ( element.inputType ) {\n\n\t\t\t\t\t\tif ( this.getParameter( id ) === undefined ) this.setParameter( id, null );\n\n\t\t\t\t\t\tthis.getParameter( id ).inputType = element.inputType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( element.outputType ) {\n\n\t\t\t\t\t\tif ( this.getOutput( id ) === undefined ) this.setOutput( id, null );\n\n\t\t\t\t\t\tthis.getOutput( id ).outputType = element.outputType;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this._object;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tfor ( const name in this.parameters ) {\n\n\t\t\tlet valueNode = this.parameters[ name ];\n\n\t\t\tif ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();\n\n\t\t\tvalueNode.events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t}\n\n\t}\n\n\tgetLayout() {\n\n\t\treturn this.getObject().layout;\n\n\t}\n\n\tgetDefaultOutputNode() {\n\n\t\tconst output = this.getDefaultOutput().value;\n\n\t\tif ( output && output.isNode ) {\n\n\t\t\treturn output;\n\n\t\t}\n\n\t\treturn float();\n\n\t}\n\n\tgetDefaultOutput()\t{\n\n\t\treturn this._exec()._output;\n\n\t}\n\n\tgetMethod() {\n\n\t\tif ( this.needsUpdate ) this.dispose();\n\t\tif ( this._method !== null ) return this._method;\n\n\t\t//\n\n\t\tconst parametersProps = [ 'parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL' ];\n\t\tconst interfaceProps = [ 'layout', 'init', 'main', 'dispose' ];\n\n\t\tconst properties = interfaceProps.join( ', ' );\n\t\tconst declarations = 'var ' + properties + '; var output = {};\\n';\n\t\tconst returns = '\\nreturn { ...output, ' + properties + ' };';\n\n\t\tconst code = declarations + this.codeNode.code + returns;\n\n\t\t//\n\n\t\tthis._method = new Function( ...parametersProps, code );\n\n\t\treturn this._method;\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this._method === null ) return;\n\n\t\tif ( this._object && typeof this._object.dispose === 'function' ) {\n\n\t\t\tthis._object.dispose();\n\n\t\t}\n\n\t\tthis._method = null;\n\t\tthis._object = null;\n\t\tthis._source = null;\n\t\tthis._value = null;\n\t\tthis._needsOutputUpdate = true;\n\t\tthis._output.value = null;\n\t\tthis._outputs = {};\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.getDefaultOutputNode();\n\n\t}\n\n\tgetCacheKey( force ) {\n\n\t\tconst values = [ hashString( this.source ), this.getDefaultOutputNode().getCacheKey( force ) ];\n\n\t\tfor ( const param in this.parameters ) {\n\n\t\t\tvalues.push( this.parameters[ param ].getCacheKey( force ) );\n\n\t\t}\n\n\t\treturn hashArray( values );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.dispose();\n\n\t}\n\n\tget needsUpdate() {\n\n\t\treturn this.source !== this._source;\n\n\t}\n\n\t_exec()\t{\n\n\t\tif ( this.codeNode === null ) return this;\n\n\t\tif ( this._needsOutputUpdate === true ) {\n\n\t\t\tthis._value = this.call( 'main' );\n\n\t\t\tthis._needsOutputUpdate = false;\n\n\t\t}\n\n\t\tthis._output.value = this._value;\n\n\t\treturn this;\n\n\t}\n\n\t_refresh() {\n\n\t\tthis.needsUpdate = true;\n\n\t\tthis._exec();\n\n\t\tthis._output.refresh();\n\n\t}\n\n}\n\nconst scriptable = /*@__PURE__*/ nodeProxy( ScriptableNode );\n\nclass FogNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'FogNode';\n\n\t}\n\n\tconstructor( colorNode, factorNode ) {\n\n\t\tsuper( 'float' );\n\n\t\tthis.isFogNode = true;\n\n\t\tthis.colorNode = colorNode;\n\t\tthis.factorNode = factorNode;\n\n\t}\n\n\tgetViewZNode( builder ) {\n\n\t\tlet viewZ;\n\n\t\tconst getViewZ = builder.context.getViewZ;\n\n\t\tif ( getViewZ !== undefined ) {\n\n\t\t\tviewZ = getViewZ( this );\n\n\t\t}\n\n\t\treturn ( viewZ || positionView.z ).negate();\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.factorNode;\n\n\t}\n\n}\n\nconst fog = /*@__PURE__*/ nodeProxy( FogNode );\n\nclass FogRangeNode extends FogNode {\n\n\tstatic get type() {\n\n\t\treturn 'FogRangeNode';\n\n\t}\n\n\tconstructor( colorNode, nearNode, farNode ) {\n\n\t\tsuper( colorNode );\n\n\t\tthis.isFogRangeNode = true;\n\n\t\tthis.nearNode = nearNode;\n\t\tthis.farNode = farNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst viewZ = this.getViewZNode( builder );\n\n\t\treturn smoothstep( this.nearNode, this.farNode, viewZ );\n\n\t}\n\n}\n\nconst rangeFog = /*@__PURE__*/ nodeProxy( FogRangeNode );\n\nclass FogExp2Node extends FogNode {\n\n\tstatic get type() {\n\n\t\treturn 'FogExp2Node';\n\n\t}\n\n\tconstructor( colorNode, densityNode ) {\n\n\t\tsuper( colorNode );\n\n\t\tthis.isFogExp2Node = true;\n\n\t\tthis.densityNode = densityNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst viewZ = this.getViewZNode( builder );\n\t\tconst density = this.densityNode;\n\n\t\treturn density.mul( density, viewZ, viewZ ).negate().exp().oneMinus();\n\n\t}\n\n}\n\nconst densityFog = /*@__PURE__*/ nodeProxy( FogExp2Node );\n\nlet min = null;\nlet max = null;\n\nclass RangeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'RangeNode';\n\n\t}\n\n\tconstructor( minNode = float(), maxNode = float() ) {\n\n\t\tsuper();\n\n\t\tthis.minNode = minNode;\n\t\tthis.maxNode = maxNode;\n\n\t}\n\n\tgetVectorLength( builder ) {\n\n\t\tconst minLength = builder.getTypeLength( getValueType( this.minNode.value ) );\n\t\tconst maxLength = builder.getTypeLength( getValueType( this.maxNode.value ) );\n\n\t\treturn minLength > maxLength ? minLength : maxLength;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn builder.object.count > 1 ? builder.getTypeFromLength( this.getVectorLength( builder ) ) : 'float';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst object = builder.object;\n\n\t\tlet output = null;\n\n\t\tif ( object.count > 1 ) {\n\n\t\t\tconst minValue = this.minNode.value;\n\t\t\tconst maxValue = this.maxNode.value;\n\n\t\t\tconst minLength = builder.getTypeLength( getValueType( minValue ) );\n\t\t\tconst maxLength = builder.getTypeLength( getValueType( maxValue ) );\n\n\t\t\tmin = min || new Vector4();\n\t\t\tmax = max || new Vector4();\n\n\t\t\tmin.setScalar( 0 );\n\t\t\tmax.setScalar( 0 );\n\n\t\t\tif ( minLength === 1 ) min.setScalar( minValue );\n\t\t\telse if ( minValue.isColor ) min.set( minValue.r, minValue.g, minValue.b );\n\t\t\telse min.set( minValue.x, minValue.y, minValue.z || 0, minValue.w || 0 );\n\n\t\t\tif ( maxLength === 1 ) max.setScalar( maxValue );\n\t\t\telse if ( maxValue.isColor ) max.set( maxValue.r, maxValue.g, maxValue.b );\n\t\t\telse max.set( maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0 );\n\n\t\t\tconst stride = 4;\n\n\t\t\tconst length = stride * object.count;\n\t\t\tconst array = new Float32Array( length );\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tconst index = i % stride;\n\n\t\t\t\tconst minElementValue = min.getComponent( index );\n\t\t\t\tconst maxElementValue = max.getComponent( index );\n\n\t\t\t\tarray[ i ] = MathUtils.lerp( minElementValue, maxElementValue, Math.random() );\n\n\t\t\t}\n\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( object.count <= 4096 ) {\n\n\t\t\t\toutput = buffer( array, 'vec4', object.count ).element( instanceIndex ).convert( nodeType );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: Improve anonymous buffer attribute creation removing this part\n\t\t\t\tconst bufferAttribute = new InstancedBufferAttribute( array, 4 );\n\t\t\t\tbuilder.geometry.setAttribute( '__range' + this.id, bufferAttribute );\n\n\t\t\t\toutput = instancedBufferAttribute( bufferAttribute ).convert( nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\toutput = float( 0 );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nconst range = /*@__PURE__*/ nodeProxy( RangeNode );\n\nclass ComputeBuiltinNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ComputeBuiltinNode';\n\n\t}\n\n\tconstructor( builtinName, nodeType ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis._builtinName = builtinName;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.getBuiltinName( builder );\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.nodeType;\n\n\t}\n\n\tsetBuiltinName( builtinName ) {\n\n\t\tthis._builtinName = builtinName;\n\n\t\treturn this;\n\n\t}\n\n\tgetBuiltinName( /*builder*/ ) {\n\n\t\treturn this._builtinName;\n\n\t}\n\n\thasBuiltin( builder ) {\n\n\t\tbuilder.hasBuiltin( this._builtinName );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst builtinName = this.getBuiltinName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tif ( builder.shaderStage === 'compute' ) {\n\n\t\t\treturn builder.format( builtinName, nodeType, output );\n\n\t\t} else {\n\n\t\t\tconsole.warn( `ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage` );\n\t\t\treturn builder.generateConst( nodeType );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.global = this.global;\n\t\tdata._builtinName = this._builtinName;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.global = data.global;\n\t\tthis._builtinName = data._builtinName;\n\n\t}\n\n}\n\nconst computeBuiltin = ( name, nodeType ) => nodeObject( new ComputeBuiltinNode( name, nodeType ) );\n\nconst numWorkgroups = /*@__PURE__*/ computeBuiltin( 'numWorkgroups', 'uvec3' );\nconst workgroupId = /*@__PURE__*/ computeBuiltin( 'workgroupId', 'uvec3' );\nconst localId = /*@__PURE__*/ computeBuiltin( 'localId', 'uvec3' );\nconst subgroupSize = /*@__PURE__*/ computeBuiltin( 'subgroupSize', 'uint' );\n\nclass BarrierNode extends Node {\n\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { scope } = this;\n\t\tconst { renderer } = builder;\n\n\t\tif ( renderer.backend.isWebGLBackend === true ) {\n\n\t\t\tbuilder.addFlowCode( `\\t// ${scope}Barrier \\n` );\n\n\t\t} else {\n\n\t\t\tbuilder.addLineFlowCode( `${scope}Barrier()`, this );\n\n\t\t}\n\n\t}\n\n}\n\nconst barrier = nodeProxy( BarrierNode );\n\nconst workgroupBarrier = () => barrier( 'workgroup' ).append();\nconst storageBarrier = () => barrier( 'storage' ).append();\nconst textureBarrier = () => barrier( 'texture' ).append();\n\nclass WorkgroupInfoElementNode extends ArrayElementNode {\n\n\tconstructor( workgroupInfoNode, indexNode ) {\n\n\t\tsuper( workgroupInfoNode, indexNode );\n\n\t\tthis.isWorkgroupInfoElementNode = true;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tconst isAssignContext = builder.context.assign;\n\t\tsnippet = super.generate( builder );\n\n\t\tif ( isAssignContext !== true ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tsnippet = builder.format( snippet, type, output );\n\n\t\t}\n\n\t\t// TODO: Possibly activate clip distance index on index access rather than from clipping context\n\n\t\treturn snippet;\n\n\t}\n\n}\n\n\nclass WorkgroupInfoNode extends Node {\n\n\tconstructor( scope, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( bufferType );\n\n\t\tthis.bufferType = bufferType;\n\t\tthis.bufferCount = bufferCount;\n\n\t\tthis.isWorkgroupInfoNode = true;\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tlabel( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.uuid;\n\n\t}\n\n\tsetScope( scope ) {\n\n\t\tthis.scope = scope;\n\n\t\treturn this;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn `${this.scope}Array`;\n\n\t}\n\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new WorkgroupInfoElementNode( this, indexNode ) );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn builder.getScopedArray( this.name || `${this.scope}Array_${this.id}`, this.scope.toLowerCase(), this.bufferType, this.bufferCount );\n\n\t}\n\n}\n\nconst workgroupArray = ( type, count ) => nodeObject( new WorkgroupInfoNode( 'Workgroup', type, count ) );\n\nclass AtomicFunctionNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'AtomicFunctionNode';\n\n\t}\n\n\tconstructor( method, pointerNode, valueNode, storeNode = null ) {\n\n\t\tsuper( 'uint' );\n\n\t\tthis.method = method;\n\n\t\tthis.pointerNode = pointerNode;\n\t\tthis.valueNode = valueNode;\n\t\tthis.storeNode = storeNode;\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\treturn this.pointerNode.getNodeType( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.getInputType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.pointerNode;\n\t\tconst b = this.valueNode;\n\n\t\tconst params = [];\n\n\t\tparams.push( `&${ a.build( builder, inputType ) }` );\n\t\tparams.push( b.build( builder, inputType ) );\n\n\t\tconst methodSnippet = `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`;\n\n\t\tif ( this.storeNode !== null ) {\n\n\t\t\tconst varSnippet = this.storeNode.build( builder, inputType );\n\n\t\t\tbuilder.addLineFlowCode( `${varSnippet} = ${methodSnippet}`, this );\n\n\t\t} else {\n\n\t\t\tbuilder.addLineFlowCode( methodSnippet, this );\n\n\t\t}\n\n\t}\n\n}\n\nAtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';\nAtomicFunctionNode.ATOMIC_STORE = 'atomicStore';\nAtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';\nAtomicFunctionNode.ATOMIC_SUB = 'atomicSub';\nAtomicFunctionNode.ATOMIC_MAX = 'atomicMax';\nAtomicFunctionNode.ATOMIC_MIN = 'atomicMin';\nAtomicFunctionNode.ATOMIC_AND = 'atomicAnd';\nAtomicFunctionNode.ATOMIC_OR = 'atomicOr';\nAtomicFunctionNode.ATOMIC_XOR = 'atomicXor';\n\nconst atomicNode = nodeProxy( AtomicFunctionNode );\n\nconst atomicFunc = ( method, pointerNode, valueNode, storeNode ) => {\n\n\tconst node = atomicNode( method, pointerNode, valueNode, storeNode );\n\tnode.append();\n\n\treturn node;\n\n};\n\nconst atomicStore = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode, storeNode );\nconst atomicAdd = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode, storeNode );\nconst atomicSub = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode, storeNode );\nconst atomicMax = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode, storeNode );\nconst atomicMin = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode, storeNode );\nconst atomicAnd = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode, storeNode );\nconst atomicOr = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode, storeNode );\nconst atomicXor = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode, storeNode );\n\nlet uniformsLib;\n\nfunction getLightData( light ) {\n\n\tuniformsLib = uniformsLib || new WeakMap();\n\n\tlet uniforms = uniformsLib.get( light );\n\n\tif ( uniforms === undefined ) uniformsLib.set( light, uniforms = {} );\n\n\treturn uniforms;\n\n}\n\nfunction lightShadowMatrix( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.shadowMatrix || ( data.shadowMatrix = uniform( 'mat4' ).setGroup( renderGroup ).onRenderUpdate( () => {\n\n\t\tlight.shadow.updateMatrices( light );\n\n\t\treturn light.shadow.matrix;\n\n\t} ) );\n\n}\n\nfunction lightProjectionUV( light ) {\n\n\tconst data = getLightData( light );\n\n\tif ( data.projectionUV === undefined ) {\n\n\t\tconst spotLightCoord = lightShadowMatrix( light ).mul( positionWorld );\n\n\t\tdata.projectionUV = spotLightCoord.xyz.div( spotLightCoord.w );\n\n\n\t}\n\n\treturn data.projectionUV;\n\n}\n\nfunction lightPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.position || ( data.position = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.matrixWorld ) ) );\n\n}\n\nfunction lightTargetPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.targetPosition || ( data.targetPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.target.matrixWorld ) ) );\n\n}\n\nfunction lightViewPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.viewPosition || ( data.viewPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => {\n\n\t\tself.value = self.value || new Vector3();\n\t\tself.value.setFromMatrixPosition( light.matrixWorld );\n\n\t\tself.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t} ) );\n\n}\n\nconst lightTargetDirection = ( light ) => cameraViewMatrix.transformDirection( lightPosition( light ).sub( lightTargetPosition( light ) ) );\n\nconst sortLights = ( lights ) => {\n\n\treturn lights.sort( ( a, b ) => a.id - b.id );\n\n};\n\nconst getLightNodeById = ( id, lightNodes ) => {\n\n\tfor ( const lightNode of lightNodes ) {\n\n\t\tif ( lightNode.isAnalyticLightNode && lightNode.light.id === id ) {\n\n\t\t\treturn lightNode;\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n};\n\nconst _lightsNodeRef = /*@__PURE__*/ new WeakMap();\n\nclass LightsNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LightsNode';\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.totalDiffuseNode = vec3().toVar( 'totalDiffuse' );\n\t\tthis.totalSpecularNode = vec3().toVar( 'totalSpecular' );\n\n\t\tthis.outgoingLightNode = vec3().toVar( 'outgoingLight' );\n\n\t\tthis._lights = [];\n\n\t\tthis._lightNodes = null;\n\t\tthis._lightNodesHash = null;\n\n\t\tthis.global = true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\tif ( this._lightNodesHash === null ) {\n\n\t\t\tif ( this._lightNodes === null ) this.setupLightsNode( builder );\n\n\t\t\tconst hash = [];\n\n\t\t\tfor ( const lightNode of this._lightNodes ) {\n\n\t\t\t\thash.push( lightNode.getSelf().getHash() );\n\n\t\t\t}\n\n\t\t\tthis._lightNodesHash = 'lights-' + hash.join( ',' );\n\n\t\t}\n\n\t\treturn this._lightNodesHash;\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tconst properties = builder.getDataFromNode( this );\n\n\t\tfor ( const node of properties.nodes ) {\n\n\t\t\tnode.build( builder );\n\n\t\t}\n\n\t}\n\n\tsetupLightsNode( builder ) {\n\n\t\tconst lightNodes = [];\n\n\t\tconst previousLightNodes = this._lightNodes;\n\n\t\tconst lights = sortLights( this._lights );\n\t\tconst nodeLibrary = builder.renderer.library;\n\n\t\tfor ( const light of lights ) {\n\n\t\t\tif ( light.isNode ) {\n\n\t\t\t\tlightNodes.push( nodeObject( light ) );\n\n\t\t\t} else {\n\n\t\t\t\tlet lightNode = null;\n\n\t\t\t\tif ( previousLightNodes !== null ) {\n\n\t\t\t\t\tlightNode = getLightNodeById( light.id, previousLightNodes ); // resuse existing light node\n\n\t\t\t\t}\n\n\t\t\t\tif ( lightNode === null ) {\n\n\t\t\t\t\tconst lightNodeClass = nodeLibrary.getLightNodeClass( light.constructor );\n\n\t\t\t\t\tif ( lightNodeClass === null ) {\n\n\t\t\t\t\t\tconsole.warn( `LightsNode.setupNodeLights: Light node not found for ${ light.constructor.name }` );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet lightNode = null;\n\n\t\t\t\t\tif ( ! _lightsNodeRef.has( light ) ) {\n\n\t\t\t\t\t\tlightNode = nodeObject( new lightNodeClass( light ) );\n\t\t\t\t\t\t_lightsNodeRef.set( light, lightNode );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlightNode = _lightsNodeRef.get( light );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlightNodes.push( lightNode );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._lightNodes = lightNodes;\n\n\t}\n\n\tsetupLights( builder, lightNodes ) {\n\n\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\tlightNode.build( builder );\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( this._lightNodes === null ) this.setupLightsNode( builder );\n\n\t\tconst context = builder.context;\n\t\tconst lightingModel = context.lightingModel;\n\n\t\tlet outgoingLightNode = this.outgoingLightNode;\n\n\t\tif ( lightingModel ) {\n\n\t\t\tconst { _lightNodes, totalDiffuseNode, totalSpecularNode } = this;\n\n\t\t\tcontext.outgoingLight = outgoingLightNode;\n\n\t\t\tconst stack = builder.addStack();\n\n\t\t\t//\n\n\t\t\tconst properties = builder.getDataFromNode( this );\n\t\t\tproperties.nodes = stack.nodes;\n\n\t\t\t//\n\n\t\t\tlightingModel.start( context, stack, builder );\n\n\t\t\t// lights\n\n\t\t\tthis.setupLights( builder, _lightNodes );\n\n\t\t\t//\n\n\t\t\tlightingModel.indirect( context, stack, builder );\n\n\t\t\t//\n\n\t\t\tconst { backdrop, backdropAlpha } = context;\n\t\t\tconst { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context.reflectedLight;\n\n\t\t\tlet totalDiffuse = directDiffuse.add( indirectDiffuse );\n\n\t\t\tif ( backdrop !== null ) {\n\n\t\t\t\tif ( backdropAlpha !== null ) {\n\n\t\t\t\t\ttotalDiffuse = vec3( backdropAlpha.mix( totalDiffuse, backdrop ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttotalDiffuse = vec3( backdrop );\n\n\t\t\t\t}\n\n\t\t\t\tcontext.material.transparent = true;\n\n\t\t\t}\n\n\t\t\ttotalDiffuseNode.assign( totalDiffuse );\n\t\t\ttotalSpecularNode.assign( directSpecular.add( indirectSpecular ) );\n\n\t\t\toutgoingLightNode.assign( totalDiffuseNode.add( totalSpecularNode ) );\n\n\t\t\t//\n\n\t\t\tlightingModel.finish( context, stack, builder );\n\n\t\t\t//\n\n\t\t\toutgoingLightNode = outgoingLightNode.bypass( builder.removeStack() );\n\n\t\t}\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\tsetLights( lights ) {\n\n\t\tthis._lights = lights;\n\n\t\tthis._lightNodes = null;\n\t\tthis._lightNodesHash = null;\n\n\t\treturn this;\n\n\t}\n\n\tgetLights() {\n\n\t\treturn this._lights;\n\n\t}\n\n\tget hasLights() {\n\n\t\treturn this._lights.length > 0;\n\n\t}\n\n}\n\nconst lights = ( lights = [] ) => nodeObject( new LightsNode() ).setLights( lights );\n\nconst shadowMaterialLib = /*@__PURE__*/ new WeakMap();\nconst shadowWorldPosition = /*@__PURE__*/ vec3().toVar( 'shadowWorldPosition' );\n\nconst linearDistance = /*@__PURE__*/ Fn( ( [ position, cameraNear, cameraFar ] ) => {\n\n\tlet dist = positionWorld.sub( position ).length();\n\tdist = dist.sub( cameraNear ).div( cameraFar.sub( cameraNear ) );\n\tdist = dist.saturate(); // clamp to [ 0, 1 ]\n\n\treturn dist;\n\n} );\n\nconst linearShadowDistance = ( light ) => {\n\n\tconst camera = light.shadow.camera;\n\n\tconst nearDistance = reference( 'near', 'float', camera ).setGroup( renderGroup );\n\tconst farDistance = reference( 'far', 'float', camera ).setGroup( renderGroup );\n\n\tconst referencePosition = objectPosition( light );\n\n\treturn linearDistance( referencePosition, nearDistance, farDistance );\n\n};\n\nconst getShadowMaterial = ( light ) => {\n\n\tlet material = shadowMaterialLib.get( light );\n\n\tif ( material === undefined ) {\n\n\t\tconst depthNode = light.isPointLight ? linearShadowDistance( light ) : null;\n\n\t\tmaterial = new NodeMaterial();\n\t\tmaterial.colorNode = vec4( 0, 0, 0, 1 );\n\t\tmaterial.depthNode = depthNode;\n\t\tmaterial.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode\n\t\tmaterial.blending = NoBlending;\n\t\tmaterial.name = 'ShadowMaterial';\n\n\t\tshadowMaterialLib.set( light, material );\n\n\t}\n\n\treturn material;\n\n};\n\nconst BasicShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord } ) => {\n\n\treturn texture( depthTexture, shadowCoord.xy ).compare( shadowCoord.z );\n\n} );\n\nconst PCFShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow } ) => {\n\n\tconst depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );\n\n\tconst mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\n\tconst texelSize = vec2( 1 ).div( mapSize );\n\tconst dx0 = texelSize.x.negate().mul( radius );\n\tconst dy0 = texelSize.y.negate().mul( radius );\n\tconst dx1 = texelSize.x.mul( radius );\n\tconst dy1 = texelSize.y.mul( radius );\n\tconst dx2 = dx0.div( 2 );\n\tconst dy2 = dy0.div( 2 );\n\tconst dx3 = dx1.div( 2 );\n\tconst dy3 = dy1.div( 2 );\n\n\treturn add(\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy, shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n\t).mul( 1 / 17 );\n\n} );\n\nconst PCFSoftShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow } ) => {\n\n\tconst depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );\n\n\tconst mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\n\tconst texelSize = vec2( 1 ).div( mapSize );\n\tconst dx = texelSize.x;\n\tconst dy = texelSize.y;\n\n\tconst uv = shadowCoord.xy;\n\tconst f = fract( uv.mul( mapSize ).add( 0.5 ) );\n\tuv.subAssign( f.mul( texelSize ) );\n\n\treturn add(\n\t\tdepthCompare( uv, shadowCoord.z ),\n\t\tdepthCompare( uv.add( vec2( dx, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( uv.add( vec2( 0, dy ) ), shadowCoord.z ),\n\t\tdepthCompare( uv.add( texelSize ), shadowCoord.z ),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx.negate(), 0 ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), 0 ) ), shadowCoord.z ),\n\t\t\tf.x\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy ) ), shadowCoord.z ),\n\t\t\tf.x\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( 0, dy.negate() ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( 0, dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\tf.y\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx, dy.negate() ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx, dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\tf.y\n\t\t),\n\t\tmix(\n\t\t\tmix(\n\t\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy.negate() ) ), shadowCoord.z ),\n\t\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy.negate() ) ), shadowCoord.z ),\n\t\t\t\tf.x\n\t\t\t),\n\t\t\tmix(\n\t\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\t\tf.x\n\t\t\t),\n\t\t\tf.y\n\t\t)\n\t).mul( 1 / 9 );\n\n} );\n\n// VSM\n\nconst VSMShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord } ) => {\n\n\tconst occlusion = float( 1 ).toVar();\n\n\tconst distribution = texture( depthTexture ).uv( shadowCoord.xy ).rg;\n\n\tconst hardShadow = step( shadowCoord.z, distribution.x );\n\n\tIf( hardShadow.notEqual( float( 1.0 ) ), () => {\n\n\t\tconst distance = shadowCoord.z.sub( distribution.x );\n\t\tconst variance = max$1( 0, distribution.y.mul( distribution.y ) );\n\t\tlet softnessProbability = variance.div( variance.add( distance.mul( distance ) ) ); // Chebeyshevs inequality\n\t\tsoftnessProbability = clamp( sub( softnessProbability, 0.3 ).div( 0.95 - 0.3 ) );\n\t\tocclusion.assign( clamp( max$1( hardShadow, softnessProbability ) ) );\n\n\t} );\n\n\treturn occlusion;\n\n} );\n\nconst VSMPassVertical = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass } ) => {\n\n\tconst mean = float( 0 ).toVar();\n\tconst squaredMean = float( 0 ).toVar();\n\n\tconst uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );\n\tconst uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );\n\n\tLoop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\tconst uvOffset = uvStart.add( float( i ).mul( uvStride ) );\n\n\t\tconst depth = shadowPass.uv( add( screenCoordinate.xy, vec2( 0, uvOffset ).mul( radius ) ).div( size ) ).x;\n\t\tmean.addAssign( depth );\n\t\tsquaredMean.addAssign( depth.mul( depth ) );\n\n\t} );\n\n\tmean.divAssign( samples );\n\tsquaredMean.divAssign( samples );\n\n\tconst std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );\n\treturn vec2( mean, std_dev );\n\n} );\n\nconst VSMPassHorizontal = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass } ) => {\n\n\tconst mean = float( 0 ).toVar();\n\tconst squaredMean = float( 0 ).toVar();\n\n\tconst uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );\n\tconst uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );\n\n\tLoop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\tconst uvOffset = uvStart.add( float( i ).mul( uvStride ) );\n\n\t\tconst distribution = shadowPass.uv( add( screenCoordinate.xy, vec2( uvOffset, 0 ).mul( radius ) ).div( size ) );\n\t\tmean.addAssign( distribution.x );\n\t\tsquaredMean.addAssign( add( distribution.y.mul( distribution.y ), distribution.x.mul( distribution.x ) ) );\n\n\t} );\n\n\tmean.divAssign( samples );\n\tsquaredMean.divAssign( samples );\n\n\tconst std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );\n\treturn vec2( mean, std_dev );\n\n} );\n\nconst _shadowFilterLib = [ BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter ];\n\n//\n\nconst _quadMesh$1 = /*@__PURE__*/ new QuadMesh();\n\nclass ShadowNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ShadowNode';\n\n\t}\n\n\tconstructor( light, shadow = null ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\t\tthis.shadow = shadow || light.shadow;\n\n\t\tthis.shadowMap = null;\n\n\t\tthis.vsmShadowMapVertical = null;\n\t\tthis.vsmShadowMapHorizontal = null;\n\n\t\tthis.vsmMaterialVertical = null;\n\t\tthis.vsmMaterialHorizontal = null;\n\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\t\tthis._node = null;\n\n\t\tthis.isShadowNode = true;\n\n\t}\n\n\tsetupShadowFilter( builder, { filterFn, depthTexture, shadowCoord, shadow } ) {\n\n\t\tconst frustumTest = shadowCoord.x.greaterThanEqual( 0 )\n\t\t\t.and( shadowCoord.x.lessThanEqual( 1 ) )\n\t\t\t.and( shadowCoord.y.greaterThanEqual( 0 ) )\n\t\t\t.and( shadowCoord.y.lessThanEqual( 1 ) )\n\t\t\t.and( shadowCoord.z.lessThanEqual( 1 ) );\n\n\t\tconst shadowNode = filterFn( { depthTexture, shadowCoord, shadow } );\n\n\t\treturn frustumTest.select( shadowNode, float( 1 ) );\n\n\t}\n\n\tsetupShadowCoord( builder, shadowPosition ) {\n\n\t\tconst { shadow } = this;\n\t\tconst { renderer } = builder;\n\n\t\tconst bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );\n\n\t\tlet shadowCoord = shadowPosition;\n\t\tlet coordZ;\n\n\t\tif ( shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true ) {\n\n\t\t\tshadowCoord = shadowCoord.xyz.div( shadowCoord.w );\n\n\t\t\tcoordZ = shadowCoord.z;\n\n\t\t\tif ( renderer.coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\t\tcoordZ = coordZ.mul( 2 ).sub( 1 ); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst w = shadowCoord.w;\n\t\t\tshadowCoord = shadowCoord.xy.div( w ); // <-- Only divide X/Y coords since we don't need Z\n\n\t\t\t// The normally available \"cameraNear\" and \"cameraFar\" nodes cannot be used here because they do not get\n\t\t\t// updated to use the shadow camera. So, we have to declare our own \"local\" ones here.\n\t\t\t// TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?\n\t\t\tconst cameraNearLocal = reference( 'near', 'float', shadow.camera ).setGroup( renderGroup );\n\t\t\tconst cameraFarLocal = reference( 'far', 'float', shadow.camera ).setGroup( renderGroup );\n\n\t\t\tcoordZ = viewZToLogarithmicDepth( w.negate(), cameraNearLocal, cameraFarLocal );\n\n\t\t}\n\n\t\tshadowCoord = vec3(\n\t\t\tshadowCoord.x,\n\t\t\tshadowCoord.y.oneMinus(), // follow webgpu standards\n\t\t\tcoordZ.add( bias )\n\t\t);\n\n\t\treturn shadowCoord;\n\n\t}\n\n\tgetShadowFilterFn( type ) {\n\n\t\treturn _shadowFilterLib[ type ];\n\n\t}\n\n\tsetupShadow( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tconst { light, shadow } = this;\n\n\t\tconst shadowMapType = renderer.shadowMap.type;\n\n\t\tconst depthTexture = new DepthTexture( shadow.mapSize.width, shadow.mapSize.height );\n\t\tdepthTexture.compareFunction = LessCompare;\n\n\t\tconst shadowMap = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height );\n\t\tshadowMap.depthTexture = depthTexture;\n\n\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t// VSM\n\n\t\tif ( shadowMapType === VSMShadowMap ) {\n\n\t\t\tdepthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()\n\n\t\t\tthis.vsmShadowMapVertical = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );\n\t\t\tthis.vsmShadowMapHorizontal = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );\n\n\t\t\tconst shadowPassVertical = texture( depthTexture );\n\t\t\tconst shadowPassHorizontal = texture( this.vsmShadowMapVertical.texture );\n\n\t\t\tconst samples = reference( 'blurSamples', 'float', shadow ).setGroup( renderGroup );\n\t\t\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\t\t\tconst size = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\n\t\t\tlet material = this.vsmMaterialVertical || ( this.vsmMaterialVertical = new NodeMaterial() );\n\t\t\tmaterial.fragmentNode = VSMPassVertical( { samples, radius, size, shadowPass: shadowPassVertical } ).context( builder.getSharedContext() );\n\t\t\tmaterial.name = 'VSMVertical';\n\n\t\t\tmaterial = this.vsmMaterialHorizontal || ( this.vsmMaterialHorizontal = new NodeMaterial() );\n\t\t\tmaterial.fragmentNode = VSMPassHorizontal( { samples, radius, size, shadowPass: shadowPassHorizontal } ).context( builder.getSharedContext() );\n\t\t\tmaterial.name = 'VSMHorizontal';\n\n\t\t}\n\n\t\t//\n\n\t\tconst shadowIntensity = reference( 'intensity', 'float', shadow ).setGroup( renderGroup );\n\t\tconst normalBias = reference( 'normalBias', 'float', shadow ).setGroup( renderGroup );\n\n\t\tconst shadowPosition = lightShadowMatrix( light ).mul( shadowWorldPosition.add( transformedNormalWorld.mul( normalBias ) ) );\n\t\tconst shadowCoord = this.setupShadowCoord( builder, shadowPosition );\n\n\t\t//\n\n\t\tconst filterFn = shadow.filterNode || this.getShadowFilterFn( renderer.shadowMap.type ) || null;\n\n\t\tif ( filterFn === null ) {\n\n\t\t\tthrow new Error( 'THREE.WebGPURenderer: Shadow map type not supported yet.' );\n\n\t\t}\n\n\t\tconst shadowDepthTexture = ( shadowMapType === VSMShadowMap ) ? this.vsmShadowMapHorizontal.texture : depthTexture;\n\n\t\tconst shadowNode = this.setupShadowFilter( builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow } );\n\n\t\tconst shadowColor = texture( shadowMap.texture, shadowCoord );\n\t\tconst shadowOutput = mix( 1, shadowNode.rgb.mix( shadowColor, 1 ), shadowIntensity.mul( shadowColor.a ) ).toVar();\n\n\t\tthis.shadowMap = shadowMap;\n\t\tthis.shadow.map = shadowMap;\n\n\t\treturn shadowOutput;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( builder.renderer.shadowMap.enabled === false ) return;\n\n\t\treturn Fn( ( { material } ) => {\n\n\t\t\tshadowWorldPosition.assign( material.shadowPositionNode || positionWorld );\n\n\t\t\tlet node = this._node;\n\n\t\t\tif ( node === null ) {\n\n\t\t\t\tthis._node = node = this.setupShadow( builder );\n\n\t\t\t}\n\n\t\t\tif ( builder.material.shadowNode ) { // @deprecated, r171\n\n\t\t\t\tconsole.warn( 'THREE.NodeMaterial: \".shadowNode\" is deprecated. Use \".castShadowNode\" instead.' );\n\n\t\t\t}\n\n\t\t\tif ( builder.material.receivedShadowNode ) {\n\n\t\t\t\tnode = builder.material.receivedShadowNode( node );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} )();\n\n\t}\n\n\trenderShadow( frame ) {\n\n\t\tconst { shadow, shadowMap } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tshadowMap.setSize( shadow.mapSize.width, shadow.mapSize.height );\n\n\t\trenderer.render( scene, shadow.camera );\n\n\t}\n\n\tupdateShadow( frame ) {\n\n\t\tconst { shadowMap, light, shadow } = this;\n\t\tconst { renderer, scene, camera } = frame;\n\n\t\tconst shadowType = renderer.shadowMap.type;\n\n\t\tconst depthVersion = shadowMap.depthTexture.version;\n\t\tthis._depthVersionCached = depthVersion;\n\n\t\tconst currentOverrideMaterial = scene.overrideMaterial;\n\n\t\tscene.overrideMaterial = getShadowMaterial( light );\n\n\t\tshadow.camera.layers.mask = camera.layers.mask;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentRenderObjectFunction = renderer.getRenderObjectFunction();\n\t\tconst currentMRT = renderer.getMRT();\n\n\t\trenderer.setMRT( null );\n\n\t\trenderer.setRenderObjectFunction( ( object, ...params ) => {\n\n\t\t\tif ( object.castShadow === true || ( object.receiveShadow && shadowType === VSMShadowMap ) ) {\n\n\t\t\t\trenderer.renderObject( object, ...params );\n\n\t\t\t}\n\n\t\t} );\n\n\t\trenderer.setRenderTarget( shadowMap );\n\n\t\tthis.renderShadow( frame );\n\n\t\trenderer.setRenderObjectFunction( currentRenderObjectFunction );\n\n\t\t// vsm blur pass\n\n\t\tif ( light.isPointLight !== true && shadowType === VSMShadowMap ) {\n\n\t\t\tthis.vsmPass( renderer );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\trenderer.setMRT( currentMRT );\n\n\t\tscene.overrideMaterial = currentOverrideMaterial;\n\n\t}\n\n\tvsmPass( renderer ) {\n\n\t\tconst { shadow } = this;\n\n\t\tthis.vsmShadowMapVertical.setSize( shadow.mapSize.width, shadow.mapSize.height );\n\t\tthis.vsmShadowMapHorizontal.setSize( shadow.mapSize.width, shadow.mapSize.height );\n\n\t\trenderer.setRenderTarget( this.vsmShadowMapVertical );\n\t\t_quadMesh$1.material = this.vsmMaterialVertical;\n\t\t_quadMesh$1.render( renderer );\n\n\t\trenderer.setRenderTarget( this.vsmShadowMapHorizontal );\n\t\t_quadMesh$1.material = this.vsmMaterialHorizontal;\n\t\t_quadMesh$1.render( renderer );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadowMap.dispose();\n\t\tthis.shadowMap = null;\n\n\t\tif ( this.vsmShadowMapVertical !== null ) {\n\n\t\t\tthis.vsmShadowMapVertical.dispose();\n\t\t\tthis.vsmShadowMapVertical = null;\n\n\t\t\tthis.vsmMaterialVertical.dispose();\n\t\t\tthis.vsmMaterialVertical = null;\n\n\t\t}\n\n\t\tif ( this.vsmShadowMapHorizontal !== null ) {\n\n\t\t\tthis.vsmShadowMapHorizontal.dispose();\n\t\t\tthis.vsmShadowMapHorizontal = null;\n\n\t\t\tthis.vsmMaterialHorizontal.dispose();\n\t\t\tthis.vsmMaterialHorizontal = null;\n\n\t\t}\n\n\t\tthis.updateBeforeType = NodeUpdateType.NONE;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { shadow } = this;\n\n\t\tconst needsUpdate = shadow.needsUpdate || shadow.autoUpdate;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tthis.updateShadow( frame );\n\n\t\t\tif ( this.shadowMap.depthTexture.version === this._depthVersionCached ) {\n\n\t\t\t\tshadow.needsUpdate = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst shadow = ( light, shadow ) => nodeObject( new ShadowNode( light, shadow ) );\n\nclass AnalyticLightNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'AnalyticLightNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.color = new Color();\n\t\tthis.colorNode = ( light && light.colorNode ) || uniform( this.color ).setGroup( renderGroup );\n\n\t\tthis.baseColorNode = null;\n\n\t\tthis.shadowNode = null;\n\t\tthis.shadowColorNode = null;\n\n\t\tthis.isAnalyticLightNode = true;\n\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t}\n\n\tgetCacheKey() {\n\n\t\treturn hash$1( super.getCacheKey(), this.light.id, this.light.castShadow ? 1 : 0 );\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.light.uuid;\n\n\t}\n\n\tsetupShadowNode() {\n\n\t\treturn shadow( this.light );\n\n\t}\n\n\tsetupShadow( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tif ( renderer.shadowMap.enabled === false ) return;\n\n\t\tlet shadowColorNode = this.shadowColorNode;\n\n\t\tif ( shadowColorNode === null ) {\n\n\t\t\tconst customShadowNode = this.light.shadow.shadowNode;\n\n\t\t\tlet shadowNode;\n\n\t\t\tif ( customShadowNode !== undefined ) {\n\n\t\t\t\tshadowNode = nodeObject( customShadowNode );\n\n\t\t\t} else {\n\n\t\t\t\tshadowNode = this.setupShadowNode( builder );\n\n\t\t\t}\n\n\t\t\tthis.shadowNode = shadowNode;\n\n\t\t\tthis.shadowColorNode = shadowColorNode = this.colorNode.mul( shadowNode );\n\n\t\t\tthis.baseColorNode = this.colorNode;\n\n\t\t}\n\n\t\t//\n\n\t\tthis.colorNode = shadowColorNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.colorNode = this.baseColorNode || this.colorNode;\n\n\t\tif ( this.light.castShadow ) {\n\n\t\t\tif ( builder.object.receiveShadow ) {\n\n\t\t\t\tthis.setupShadow( builder );\n\n\t\t\t}\n\n\t\t} else if ( this.shadowNode !== null ) {\n\n\t\t\tthis.shadowNode.dispose();\n\t\t\tthis.shadowNode = null;\n\t\t\tthis.shadowColorNode = null;\n\n\t\t}\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tconst { light } = this;\n\n\t\tthis.color.copy( light.color ).multiplyScalar( light.intensity );\n\n\t}\n\n}\n\nconst getDistanceAttenuation = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { lightDistance, cutoffDistance, decayExponent } = inputs;\n\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t// page 32, equation 26: E[window1]\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\tconst distanceFalloff = lightDistance.pow( decayExponent ).max( 0.01 ).reciprocal();\n\n\treturn cutoffDistance.greaterThan( 0 ).select(\n\t\tdistanceFalloff.mul( lightDistance.div( cutoffDistance ).pow4().oneMinus().clamp().pow2() ),\n\t\tdistanceFalloff\n\t);\n\n} ); // validated\n\nconst _clearColor$2 = /*@__PURE__*/ new Color();\n\n// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n// vector suitable for 2D texture mapping. This code uses the following layout for the\n// 2D texture:\n//\n// xzXZ\n//  y Y\n//\n// Y - Positive y direction\n// y - Negative y direction\n// X - Positive x direction\n// x - Negative x direction\n// Z - Positive z direction\n// z - Negative z direction\n//\n// Source and test bed:\n// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\nconst cubeToUV = /*@__PURE__*/ Fn( ( [ pos, texelSizeY ] ) => {\n\n\tconst v = pos.toVar();\n\n\t// Number of texels to avoid at the edge of each square\n\n\tconst absV = abs( v );\n\n\t// Intersect unit cube\n\n\tconst scaleToCube = div( 1.0, max$1( absV.x, max$1( absV.y, absV.z ) ) );\n\tabsV.mulAssign( scaleToCube );\n\n\t// Apply scale to avoid seams\n\n\t// two texels less per square (one texel will do for NEAREST)\n\tv.mulAssign( scaleToCube.mul( texelSizeY.mul( 2 ).oneMinus() ) );\n\n\t// Unwrap\n\n\t// space: -1 ... 1 range for each square\n\t//\n\t// #X##\t\tdim    := ( 4 , 2 )\n\t//  # #\t\tcenter := ( 1 , 1 )\n\n\tconst planar = vec2( v.xy ).toVar();\n\n\tconst almostATexel = texelSizeY.mul( 1.5 );\n\tconst almostOne = almostATexel.oneMinus();\n\n\tIf( absV.z.greaterThanEqual( almostOne ), () => {\n\n\t\tIf( v.z.greaterThan( 0.0 ), () => {\n\n\t\t\tplanar.x.assign( sub( 4.0, v.x ) );\n\n\t\t} );\n\n\t} ).ElseIf( absV.x.greaterThanEqual( almostOne ), () => {\n\n\t\tconst signX = sign( v.x );\n\t\tplanar.x.assign( v.z.mul( signX ).add( signX.mul( 2.0 ) ) );\n\n\t} ).ElseIf( absV.y.greaterThanEqual( almostOne ), () => {\n\n\t\tconst signY = sign( v.y );\n\t\tplanar.x.assign( v.x.add( signY.mul( 2.0 ) ).add( 2.0 ) );\n\t\tplanar.y.assign( v.z.mul( signY ).sub( 2.0 ) );\n\n\t} );\n\n\t// Transform to UV space\n\n\t// scale := 0.5 / dim\n\t// translate := ( center + 0.5 ) / dim\n\treturn vec2( 0.125, 0.25 ).mul( planar ).add( vec2( 0.375, 0.75 ) ).flipY();\n\n} ).setLayout( {\n\tname: 'cubeToUV',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'pos', type: 'vec3' },\n\t\t{ name: 'texelSizeY', type: 'float' }\n\t]\n} );\n\nconst BasicPointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize } ) => {\n\n\treturn texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp );\n\n} );\n\nconst PointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize, shadow } ) => {\n\n\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\tconst offset = vec2( - 1.0, 1.0 ).mul( radius ).mul( texelSize.y );\n\n\treturn texture( depthTexture, cubeToUV( bd3D.add( offset.xyy ), texelSize.y ) ).compare( dp )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xyx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxx ), texelSize.y ) ).compare( dp ) )\n\t\t.mul( 1.0 / 9.0 );\n\n} );\n\nconst pointShadowFilter = /*@__PURE__*/ Fn( ( { filterFn, depthTexture, shadowCoord, shadow } ) => {\n\n\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t// the vector from the light to the world-space position of the fragment.\n\tconst lightToPosition = shadowCoord.xyz.toVar();\n\tconst lightToPositionLength = lightToPosition.length();\n\n\tconst cameraNearLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.near );\n\tconst cameraFarLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.far );\n\tconst bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );\n\tconst mapSize = uniform( shadow.mapSize ).setGroup( renderGroup );\n\n\tconst result = float( 1.0 ).toVar();\n\n\tIf( lightToPositionLength.sub( cameraFarLocal ).lessThanEqual( 0.0 ).and( lightToPositionLength.sub( cameraNearLocal ).greaterThanEqual( 0.0 ) ), () => {\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tconst dp = lightToPositionLength.sub( cameraNearLocal ).div( cameraFarLocal.sub( cameraNearLocal ) ).toVar(); // need to clamp?\n\t\tdp.addAssign( bias );\n\n\t\t// bd3D = base direction 3D\n\t\tconst bd3D = lightToPosition.normalize();\n\t\tconst texelSize = vec2( 1.0 ).div( mapSize.mul( vec2( 4.0, 2.0 ) ) );\n\n\t\t// percentage-closer filtering\n\t\tresult.assign( filterFn( { depthTexture, bd3D, dp, texelSize, shadow } ) );\n\n\t} );\n\n\treturn result;\n\n} );\n\nconst _viewport = /*@__PURE__*/ new Vector4();\nconst _viewportSize = /*@__PURE__*/ new Vector2();\nconst _shadowMapSize = /*@__PURE__*/ new Vector2();\n\n//\n\nclass PointShadowNode extends ShadowNode {\n\n\tstatic get type() {\n\n\t\treturn 'PointShadowNode';\n\n\t}\n\n\tconstructor( light, shadow = null ) {\n\n\t\tsuper( light, shadow );\n\n\t}\n\n\tgetShadowFilterFn( type ) {\n\n\t\treturn type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;\n\n\t}\n\n\tsetupShadowCoord( builder, shadowPosition ) {\n\n\t\treturn shadowPosition;\n\n\t}\n\n\tsetupShadowFilter( builder, { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } ) {\n\n\t\treturn pointShadowFilter( { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } );\n\n\t}\n\n\trenderShadow( frame ) {\n\n\t\tconst { shadow, shadowMap, light } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\tshadowMap.setSize( _shadowMapSize.width, _shadowMapSize.height );\n\n\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t//\n\n\t\tconst previousAutoClear = renderer.autoClear;\n\n\t\tconst previousClearColor = renderer.getClearColor( _clearColor$2 );\n\t\tconst previousClearAlpha = renderer.getClearAlpha();\n\n\t\trenderer.autoClear = false;\n\t\trenderer.setClearColor( shadow.clearColor, shadow.clearAlpha );\n\t\trenderer.clear();\n\n\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\tconst x = _viewportSize.x * viewport.x;\n\t\t\tconst y = _shadowMapSize.y - _viewportSize.y - ( _viewportSize.y * viewport.y );\n\n\t\t\t_viewport.set(\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t);\n\n\t\t\tshadowMap.viewport.copy( _viewport );\n\n\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\trenderer.render( scene, shadow.camera );\n\n\t\t}\n\n\t\t//\n\n\t\trenderer.autoClear = previousAutoClear;\n\t\trenderer.setClearColor( previousClearColor, previousClearAlpha );\n\n\t}\n\n}\n\nconst pointShadow = ( light, shadow ) => nodeObject( new PointShadowNode( light, shadow ) );\n\nconst directPointLight = Fn( ( { color, lightViewPosition, cutoffDistance, decayExponent }, builder ) => {\n\n\tconst lightingModel = builder.context.lightingModel;\n\n\tconst lVector = lightViewPosition.sub( positionView ); // @TODO: Add it into LightNode\n\n\tconst lightDirection = lVector.normalize();\n\tconst lightDistance = lVector.length();\n\n\tconst lightAttenuation = getDistanceAttenuation( {\n\t\tlightDistance,\n\t\tcutoffDistance,\n\t\tdecayExponent\n\t} );\n\n\tconst lightColor = color.mul( lightAttenuation );\n\n\tconst reflectedLight = builder.context.reflectedLight;\n\n\tlightingModel.direct( {\n\t\tlightDirection,\n\t\tlightColor,\n\t\treflectedLight\n\t}, builder.stack, builder );\n\n} );\n\nclass PointLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'PointLightNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tthis.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );\n\t\tthis.decayExponentNode = uniform( 0 ).setGroup( renderGroup );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\tthis.cutoffDistanceNode.value = light.distance;\n\t\tthis.decayExponentNode.value = light.decay;\n\n\t}\n\n\tsetupShadowNode() {\n\n\t\treturn pointShadow( this.light );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tdirectPointLight( {\n\t\t\tcolor: this.colorNode,\n\t\t\tlightViewPosition: lightViewPosition( this.light ),\n\t\t\tcutoffDistance: this.cutoffDistanceNode,\n\t\t\tdecayExponent: this.decayExponentNode\n\t\t} ).append();\n\n\t}\n\n}\n\nconst checker = /*@__PURE__*/ Fn( ( [ coord = uv() ] ) => {\n\n\tconst uv = coord.mul( 2.0 );\n\n\tconst cx = uv.x.floor();\n\tconst cy = uv.y.floor();\n\tconst result = cx.add( cy ).mod( 2.0 );\n\n\treturn result.sign();\n\n} );\n\n// Three.js Transpiler\n// https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/libraries/stdlib/genglsl/lib/mx_noise.glsl\n\n\n\nconst mx_select = /*@__PURE__*/ Fn( ( [ b_immutable, t_immutable, f_immutable ] ) => {\n\n\tconst f = float( f_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst b = bool( b_immutable ).toVar();\n\n\treturn select( b, t, f );\n\n} ).setLayout( {\n\tname: 'mx_select',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'b', type: 'bool' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'f', type: 'float' }\n\t]\n} );\n\nconst mx_negate_if = /*@__PURE__*/ Fn( ( [ val_immutable, b_immutable ] ) => {\n\n\tconst b = bool( b_immutable ).toVar();\n\tconst val = float( val_immutable ).toVar();\n\n\treturn select( b, val.negate(), val );\n\n} ).setLayout( {\n\tname: 'mx_negate_if',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'val', type: 'float' },\n\t\t{ name: 'b', type: 'bool' }\n\t]\n} );\n\nconst mx_floor = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = float( x_immutable ).toVar();\n\n\treturn int( floor( x ) );\n\n} ).setLayout( {\n\tname: 'mx_floor',\n\ttype: 'int',\n\tinputs: [\n\t\t{ name: 'x', type: 'float' }\n\t]\n} );\n\nconst mx_floorfrac = /*@__PURE__*/ Fn( ( [ x_immutable, i ] ) => {\n\n\tconst x = float( x_immutable ).toVar();\n\ti.assign( mx_floor( x ) );\n\n\treturn x.sub( float( i ) );\n\n} );\n\nconst mx_bilerp_0 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v3 = float( v3_immutable ).toVar();\n\tconst v2 = float( v2_immutable ).toVar();\n\tconst v1 = float( v1_immutable ).toVar();\n\tconst v0 = float( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\n\treturn sub( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bilerp_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v0', type: 'float' },\n\t\t{ name: 'v1', type: 'float' },\n\t\t{ name: 'v2', type: 'float' },\n\t\t{ name: 'v3', type: 'float' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_bilerp_1 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v3 = vec3( v3_immutable ).toVar();\n\tconst v2 = vec3( v2_immutable ).toVar();\n\tconst v1 = vec3( v1_immutable ).toVar();\n\tconst v0 = vec3( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\n\treturn sub( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bilerp_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v0', type: 'vec3' },\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' },\n\t\t{ name: 'v3', type: 'vec3' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_bilerp = /*@__PURE__*/ overloadingFn( [ mx_bilerp_0, mx_bilerp_1 ] );\n\nconst mx_trilerp_0 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {\n\n\tconst r = float( r_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v7 = float( v7_immutable ).toVar();\n\tconst v6 = float( v6_immutable ).toVar();\n\tconst v5 = float( v5_immutable ).toVar();\n\tconst v4 = float( v4_immutable ).toVar();\n\tconst v3 = float( v3_immutable ).toVar();\n\tconst v2 = float( v2_immutable ).toVar();\n\tconst v1 = float( v1_immutable ).toVar();\n\tconst v0 = float( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\tconst t1 = float( sub( 1.0, t ) ).toVar();\n\tconst r1 = float( sub( 1.0, r ) ).toVar();\n\n\treturn r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_trilerp_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v0', type: 'float' },\n\t\t{ name: 'v1', type: 'float' },\n\t\t{ name: 'v2', type: 'float' },\n\t\t{ name: 'v3', type: 'float' },\n\t\t{ name: 'v4', type: 'float' },\n\t\t{ name: 'v5', type: 'float' },\n\t\t{ name: 'v6', type: 'float' },\n\t\t{ name: 'v7', type: 'float' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'r', type: 'float' }\n\t]\n} );\n\nconst mx_trilerp_1 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {\n\n\tconst r = float( r_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v7 = vec3( v7_immutable ).toVar();\n\tconst v6 = vec3( v6_immutable ).toVar();\n\tconst v5 = vec3( v5_immutable ).toVar();\n\tconst v4 = vec3( v4_immutable ).toVar();\n\tconst v3 = vec3( v3_immutable ).toVar();\n\tconst v2 = vec3( v2_immutable ).toVar();\n\tconst v1 = vec3( v1_immutable ).toVar();\n\tconst v0 = vec3( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\tconst t1 = float( sub( 1.0, t ) ).toVar();\n\tconst r1 = float( sub( 1.0, r ) ).toVar();\n\n\treturn r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_trilerp_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v0', type: 'vec3' },\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' },\n\t\t{ name: 'v3', type: 'vec3' },\n\t\t{ name: 'v4', type: 'vec3' },\n\t\t{ name: 'v5', type: 'vec3' },\n\t\t{ name: 'v6', type: 'vec3' },\n\t\t{ name: 'v7', type: 'vec3' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'r', type: 'float' }\n\t]\n} );\n\nconst mx_trilerp = /*@__PURE__*/ overloadingFn( [ mx_trilerp_0, mx_trilerp_1 ] );\n\nconst mx_gradient_float_0 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable ] ) => {\n\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uint( hash_immutable ).toVar();\n\tconst h = uint( hash.bitAnd( uint( 7 ) ) ).toVar();\n\tconst u = float( mx_select( h.lessThan( uint( 4 ) ), x, y ) ).toVar();\n\tconst v = float( mul( 2.0, mx_select( h.lessThan( uint( 4 ) ), y, x ) ) ).toVar();\n\n\treturn mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uint' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_float_1 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = float( z_immutable ).toVar();\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uint( hash_immutable ).toVar();\n\tconst h = uint( hash.bitAnd( uint( 15 ) ) ).toVar();\n\tconst u = float( mx_select( h.lessThan( uint( 8 ) ), x, y ) ).toVar();\n\tconst v = float( mx_select( h.lessThan( uint( 4 ) ), y, mx_select( h.equal( uint( 12 ) ).or( h.equal( uint( 14 ) ) ), x, z ) ) ).toVar();\n\n\treturn mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uint' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' },\n\t\t{ name: 'z', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_float = /*@__PURE__*/ overloadingFn( [ mx_gradient_float_0, mx_gradient_float_1 ] );\n\nconst mx_gradient_vec3_0 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable ] ) => {\n\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uvec3( hash_immutable ).toVar();\n\n\treturn vec3( mx_gradient_float( hash.x, x, y ), mx_gradient_float( hash.y, x, y ), mx_gradient_float( hash.z, x, y ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uvec3' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_vec3_1 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = float( z_immutable ).toVar();\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uvec3( hash_immutable ).toVar();\n\n\treturn vec3( mx_gradient_float( hash.x, x, y, z ), mx_gradient_float( hash.y, x, y, z ), mx_gradient_float( hash.z, x, y, z ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uvec3' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' },\n\t\t{ name: 'z', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_vec3 = /*@__PURE__*/ overloadingFn( [ mx_gradient_vec3_0, mx_gradient_vec3_1 ] );\n\nconst mx_gradient_scale2d_0 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = float( v_immutable ).toVar();\n\n\treturn mul( 0.6616, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale2d_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_scale3d_0 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = float( v_immutable ).toVar();\n\n\treturn mul( 0.9820, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale3d_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_scale2d_1 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = vec3( v_immutable ).toVar();\n\n\treturn mul( 0.6616, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale2d_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v', type: 'vec3' }\n\t]\n} );\n\nconst mx_gradient_scale2d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale2d_0, mx_gradient_scale2d_1 ] );\n\nconst mx_gradient_scale3d_1 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = vec3( v_immutable ).toVar();\n\n\treturn mul( 0.9820, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale3d_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v', type: 'vec3' }\n\t]\n} );\n\nconst mx_gradient_scale3d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale3d_0, mx_gradient_scale3d_1 ] );\n\nconst mx_rotl32 = /*@__PURE__*/ Fn( ( [ x_immutable, k_immutable ] ) => {\n\n\tconst k = int( k_immutable ).toVar();\n\tconst x = uint( x_immutable ).toVar();\n\n\treturn x.shiftLeft( k ).bitOr( x.shiftRight( int( 32 ).sub( k ) ) );\n\n} ).setLayout( {\n\tname: 'mx_rotl32',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'uint' },\n\t\t{ name: 'k', type: 'int' }\n\t]\n} );\n\nconst mx_bjmix = /*@__PURE__*/ Fn( ( [ a, b, c ] ) => {\n\n\ta.subAssign( c );\n\ta.bitXorAssign( mx_rotl32( c, int( 4 ) ) );\n\tc.addAssign( b );\n\tb.subAssign( a );\n\tb.bitXorAssign( mx_rotl32( a, int( 6 ) ) );\n\ta.addAssign( c );\n\tc.subAssign( b );\n\tc.bitXorAssign( mx_rotl32( b, int( 8 ) ) );\n\tb.addAssign( a );\n\ta.subAssign( c );\n\ta.bitXorAssign( mx_rotl32( c, int( 16 ) ) );\n\tc.addAssign( b );\n\tb.subAssign( a );\n\tb.bitXorAssign( mx_rotl32( a, int( 19 ) ) );\n\ta.addAssign( c );\n\tc.subAssign( b );\n\tc.bitXorAssign( mx_rotl32( b, int( 4 ) ) );\n\tb.addAssign( a );\n\n} );\n\nconst mx_bjfinal = /*@__PURE__*/ Fn( ( [ a_immutable, b_immutable, c_immutable ] ) => {\n\n\tconst c = uint( c_immutable ).toVar();\n\tconst b = uint( b_immutable ).toVar();\n\tconst a = uint( a_immutable ).toVar();\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 14 ) ) );\n\ta.bitXorAssign( c );\n\ta.subAssign( mx_rotl32( c, int( 11 ) ) );\n\tb.bitXorAssign( a );\n\tb.subAssign( mx_rotl32( a, int( 25 ) ) );\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 16 ) ) );\n\ta.bitXorAssign( c );\n\ta.subAssign( mx_rotl32( c, int( 4 ) ) );\n\tb.bitXorAssign( a );\n\tb.subAssign( mx_rotl32( a, int( 14 ) ) );\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 24 ) ) );\n\n\treturn c;\n\n} ).setLayout( {\n\tname: 'mx_bjfinal',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'a', type: 'uint' },\n\t\t{ name: 'b', type: 'uint' },\n\t\t{ name: 'c', type: 'uint' }\n\t]\n} );\n\nconst mx_bits_to_01 = /*@__PURE__*/ Fn( ( [ bits_immutable ] ) => {\n\n\tconst bits = uint( bits_immutable ).toVar();\n\n\treturn float( bits ).div( float( uint( int( 0xffffffff ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bits_to_01',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'bits', type: 'uint' }\n\t]\n} );\n\nconst mx_fade = /*@__PURE__*/ Fn( ( [ t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\n\treturn t.mul( t ).mul( t ).mul( t.mul( t.mul( 6.0 ).sub( 15.0 ) ).add( 10.0 ) );\n\n} ).setLayout( {\n\tname: 'mx_fade',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_hash_int_0 = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 1 ) ).toVar();\n\tconst seed = uint( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ).toVar();\n\n\treturn mx_bjfinal( seed.add( uint( x ) ), seed, seed );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_0',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_1 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable ] ) => {\n\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 2 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_1',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_2 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 3 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_2',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_3 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable, xx_immutable ] ) => {\n\n\tconst xx = int( xx_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 4 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\tmx_bjmix( a, b, c );\n\ta.addAssign( uint( xx ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_3',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xx', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_4 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable ] ) => {\n\n\tconst yy = int( yy_immutable ).toVar();\n\tconst xx = int( xx_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 5 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\tmx_bjmix( a, b, c );\n\ta.addAssign( uint( xx ) );\n\tb.addAssign( uint( yy ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_4',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xx', type: 'int' },\n\t\t{ name: 'yy', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int = /*@__PURE__*/ overloadingFn( [ mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4 ] );\n\nconst mx_hash_vec3_0 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable ] ) => {\n\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst h = uint( mx_hash_int( x, y ) ).toVar();\n\tconst result = uvec3().toVar();\n\tresult.x.assign( h.bitAnd( int( 0xFF ) ) );\n\tresult.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );\n\tresult.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hash_vec3_0',\n\ttype: 'uvec3',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' }\n\t]\n} );\n\nconst mx_hash_vec3_1 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst h = uint( mx_hash_int( x, y, z ) ).toVar();\n\tconst result = uvec3().toVar();\n\tresult.x.assign( h.bitAnd( int( 0xFF ) ) );\n\tresult.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );\n\tresult.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hash_vec3_1',\n\ttype: 'uvec3',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' }\n\t]\n} );\n\nconst mx_hash_vec3 = /*@__PURE__*/ overloadingFn( [ mx_hash_vec3_0, mx_hash_vec3_1 ] );\n\nconst mx_perlin_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst result = float( mx_bilerp( mx_gradient_float( mx_hash_int( X, Y ), fx, fy ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();\n\n\treturn mx_gradient_scale2d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_perlin_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst fz = float( mx_floorfrac( p.z, Z ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst w = float( mx_fade( fz ) ).toVar();\n\tconst result = float( mx_trilerp( mx_gradient_float( mx_hash_int( X, Y, Z ), fx, fy, fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();\n\n\treturn mx_gradient_scale3d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_perlin_noise_float = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_float_0, mx_perlin_noise_float_1 ] );\n\nconst mx_perlin_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst result = vec3( mx_bilerp( mx_gradient_vec3( mx_hash_vec3( X, Y ), fx, fy ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();\n\n\treturn mx_gradient_scale2d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_perlin_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst fz = float( mx_floorfrac( p.z, Z ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst w = float( mx_fade( fz ) ).toVar();\n\tconst result = vec3( mx_trilerp( mx_gradient_vec3( mx_hash_vec3( X, Y, Z ), fx, fy, fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();\n\n\treturn mx_gradient_scale3d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_perlin_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1 ] );\n\nconst mx_cell_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = float( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'float' }\n\t]\n} );\n\nconst mx_cell_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_cell_noise_float_2 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy, iz ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_2',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_cell_noise_float_3 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec4( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\tconst iw = int( mx_floor( p.w ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy, iz, iw ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_3',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec4' }\n\t]\n} );\n\nconst mx_cell_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3 ] );\n\nconst mx_cell_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = float( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'float' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_2 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_2',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_3 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec4( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\tconst iw = int( mx_floor( p.w ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec4' }\n\t]\n} );\n\nconst mx_cell_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3 ] );\n\nconst mx_fractal_noise_float$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst result = float( 0.0 ).toVar();\n\tconst amplitude = float( 1.0 ).toVar();\n\n\tLoop( octaves, () => {\n\n\t\tresult.addAssign( amplitude.mul( mx_perlin_noise_float( p ) ) );\n\t\tamplitude.mulAssign( diminish );\n\t\tp.mulAssign( lacunarity );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_float',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec3$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst result = vec3( 0.0 ).toVar();\n\tconst amplitude = float( 1.0 ).toVar();\n\n\tLoop( octaves, () => {\n\n\t\tresult.addAssign( amplitude.mul( mx_perlin_noise_vec3( p ) ) );\n\t\tamplitude.mulAssign( diminish );\n\t\tp.mulAssign( lacunarity );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec2$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\n\treturn vec2( mx_fractal_noise_float$1( p, octaves, lacunarity, diminish ), mx_fractal_noise_float$1( p.add( vec3( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) );\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec2',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec4$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst c = vec3( mx_fractal_noise_vec3$1( p, octaves, lacunarity, diminish ) ).toVar();\n\tconst f = float( mx_fractal_noise_float$1( p.add( vec3( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) ).toVar();\n\n\treturn vec4( c, f );\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec4',\n\ttype: 'vec4',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_worley_distance_0 = /*@__PURE__*/ Fn( ( [ p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst yoff = int( yoff_immutable ).toVar();\n\tconst xoff = int( xoff_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst tmp = vec3( mx_cell_noise_vec3( vec2( x.add( xoff ), y.add( yoff ) ) ) ).toVar();\n\tconst off = vec2( tmp.x, tmp.y ).toVar();\n\toff.subAssign( 0.5 );\n\toff.mulAssign( jitter );\n\toff.addAssign( 0.5 );\n\tconst cellpos = vec2( vec2( float( x ), float( y ) ).add( off ) ).toVar();\n\tconst diff = vec2( cellpos.sub( p ) ).toVar();\n\n\tIf( metric.equal( int( 2 ) ), () => {\n\n\t\treturn abs( diff.x ).add( abs( diff.y ) );\n\n\t} );\n\n\tIf( metric.equal( int( 3 ) ), () => {\n\n\t\treturn max$1( abs( diff.x ), abs( diff.y ) );\n\n\t} );\n\n\treturn dot( diff, diff );\n\n} ).setLayout( {\n\tname: 'mx_worley_distance_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'xoff', type: 'int' },\n\t\t{ name: 'yoff', type: 'int' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_distance_1 = /*@__PURE__*/ Fn( ( [ p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst zoff = int( zoff_immutable ).toVar();\n\tconst yoff = int( yoff_immutable ).toVar();\n\tconst xoff = int( xoff_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst off = vec3( mx_cell_noise_vec3( vec3( x.add( xoff ), y.add( yoff ), z.add( zoff ) ) ) ).toVar();\n\toff.subAssign( 0.5 );\n\toff.mulAssign( jitter );\n\toff.addAssign( 0.5 );\n\tconst cellpos = vec3( vec3( float( x ), float( y ), float( z ) ).add( off ) ).toVar();\n\tconst diff = vec3( cellpos.sub( p ) ).toVar();\n\n\tIf( metric.equal( int( 2 ) ), () => {\n\n\t\treturn abs( diff.x ).add( abs( diff.y ) ).add( abs( diff.z ) );\n\n\t} );\n\n\tIf( metric.equal( int( 3 ) ), () => {\n\n\t\treturn max$1( max$1( abs( diff.x ), abs( diff.y ) ), abs( diff.z ) );\n\n\t} );\n\n\treturn dot( diff, diff );\n\n} ).setLayout( {\n\tname: 'mx_worley_distance_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xoff', type: 'int' },\n\t\t{ name: 'yoff', type: 'int' },\n\t\t{ name: 'zoff', type: 'int' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_distance = /*@__PURE__*/ overloadingFn( [ mx_worley_distance_0, mx_worley_distance_1 ] );\n\nconst mx_worley_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = float( 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\t\t\tsqdist.assign( min$1( sqdist, dist ) );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec2_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = vec2( 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\n\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec2_0',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = vec3( 1e6, 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\n\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.z ), () => {\n\n\t\t\t\tsqdist.z.assign( dist );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = float( 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\t\t\t\tsqdist.assign( min$1( sqdist, dist ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_float_0, mx_worley_noise_float_1 ] );\n\nconst mx_worley_noise_vec2_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = vec2( 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\n\t\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec2_1',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec2$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec2_0, mx_worley_noise_vec2_1 ] );\n\nconst mx_worley_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = vec3( 1e6, 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\n\t\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.z ), () => {\n\n\t\t\t\t\tsqdist.z.assign( dist );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec3$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec3_0, mx_worley_noise_vec3_1 ] );\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl\n\n\nconst mx_hsvtorgb = /*@__PURE__*/ Fn( ( [ hsv ] ) => {\n\n\tconst s = hsv.y;\n\tconst v = hsv.z;\n\n\tconst result = vec3().toVar();\n\n\tIf( s.lessThan( 0.0001 ), () => {\n\n\t\tresult.assign( vec3( v, v, v ) );\n\n\t} ).Else( () => {\n\n\t\tlet h = hsv.x;\n\t\th = h.sub( floor( h ) ).mul( 6.0 ).toVar(); // TODO: check what .toVar() is needed in node system cache\n\t\tconst hi = int( trunc( h ) );\n\t\tconst f = h.sub( float( hi ) );\n\t\tconst p = v.mul( s.oneMinus() );\n\t\tconst q = v.mul( s.mul( f ).oneMinus() );\n\t\tconst t = v.mul( s.mul( f.oneMinus() ).oneMinus() );\n\n\t\tIf( hi.equal( int( 0 ) ), () => {\n\n\t\t\tresult.assign( vec3( v, t, p ) );\n\n\t\t} ).ElseIf( hi.equal( int( 1 ) ), () => {\n\n\t\t\tresult.assign( vec3( q, v, p ) );\n\n\t\t} ).ElseIf( hi.equal( int( 2 ) ), () => {\n\n\t\t\tresult.assign( vec3( p, v, t ) );\n\n\t\t} ).ElseIf( hi.equal( int( 3 ) ), () => {\n\n\t\t\tresult.assign( vec3( p, q, v ) );\n\n\t\t} ).ElseIf( hi.equal( int( 4 ) ), () => {\n\n\t\t\tresult.assign( vec3( t, p, v ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tresult.assign( vec3( v, p, q ) );\n\n\t\t} );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hsvtorgb',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hsv', type: 'vec3' }\n\t]\n} );\n\nconst mx_rgbtohsv = /*@__PURE__*/ Fn( ( [ c_immutable ] ) => {\n\n\tconst c = vec3( c_immutable ).toVar();\n\tconst r = float( c.x ).toVar();\n\tconst g = float( c.y ).toVar();\n\tconst b = float( c.z ).toVar();\n\tconst mincomp = float( min$1( r, min$1( g, b ) ) ).toVar();\n\tconst maxcomp = float( max$1( r, max$1( g, b ) ) ).toVar();\n\tconst delta = float( maxcomp.sub( mincomp ) ).toVar();\n\tconst h = float().toVar(), s = float().toVar(), v = float().toVar();\n\tv.assign( maxcomp );\n\n\tIf( maxcomp.greaterThan( 0.0 ), () => {\n\n\t\ts.assign( delta.div( maxcomp ) );\n\n\t} ).Else( () => {\n\n\t\ts.assign( 0.0 );\n\n\t} );\n\n\tIf( s.lessThanEqual( 0.0 ), () => {\n\n\t\th.assign( 0.0 );\n\n\t} ).Else( () => {\n\n\t\tIf( r.greaterThanEqual( maxcomp ), () => {\n\n\t\t\th.assign( g.sub( b ).div( delta ) );\n\n\t\t} ).ElseIf( g.greaterThanEqual( maxcomp ), () => {\n\n\t\t\th.assign( add( 2.0, b.sub( r ).div( delta ) ) );\n\n\t\t} ).Else( () => {\n\n\t\t\th.assign( add( 4.0, r.sub( g ).div( delta ) ) );\n\n\t\t} );\n\n\t\th.mulAssign( 1.0 / 6.0 );\n\n\t\tIf( h.lessThan( 0.0 ), () => {\n\n\t\t\th.addAssign( 1.0 );\n\n\t\t} );\n\n\t} );\n\n\treturn vec3( h, s, v );\n\n} ).setLayout( {\n\tname: 'mx_rgbtohsv',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'c', type: 'vec3' }\n\t]\n} );\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl\n\n\nconst mx_srgb_texture_to_lin_rec709 = /*@__PURE__*/ Fn( ( [ color_immutable ] ) => {\n\n\tconst color = vec3( color_immutable ).toVar();\n\tconst isAbove = bvec3( greaterThan( color, vec3( 0.04045 ) ) ).toVar();\n\tconst linSeg = vec3( color.div( 12.92 ) ).toVar();\n\tconst powSeg = vec3( pow( max$1( color.add( vec3( 0.055 ) ), vec3( 0.0 ) ).div( 1.055 ), vec3( 2.4 ) ) ).toVar();\n\n\treturn mix( linSeg, powSeg, isAbove );\n\n} ).setLayout( {\n\tname: 'mx_srgb_texture_to_lin_rec709',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\nconst mx_aastep = ( threshold, value ) => {\n\n\tthreshold = float( threshold );\n\tvalue = float( value );\n\n\tconst afwidth = vec2( value.dFdx(), value.dFdy() ).length().mul( 0.70710678118654757 );\n\n\treturn smoothstep( threshold.sub( afwidth ), threshold.add( afwidth ), value );\n\n};\n\nconst _ramp = ( a, b, uv, p ) => mix( a, b, uv[ p ].clamp() );\nconst mx_ramplr = ( valuel, valuer, texcoord = uv() ) => _ramp( valuel, valuer, texcoord, 'x' );\nconst mx_ramptb = ( valuet, valueb, texcoord = uv() ) => _ramp( valuet, valueb, texcoord, 'y' );\n\nconst _split = ( a, b, center, uv, p ) => mix( a, b, mx_aastep( center, uv[ p ] ) );\nconst mx_splitlr = ( valuel, valuer, center, texcoord = uv() ) => _split( valuel, valuer, center, texcoord, 'x' );\nconst mx_splittb = ( valuet, valueb, center, texcoord = uv() ) => _split( valuet, valueb, center, texcoord, 'y' );\n\nconst mx_transform_uv = ( uv_scale = 1, uv_offset = 0, uv_geo = uv() ) => uv_geo.mul( uv_scale ).add( uv_offset );\n\nconst mx_safepower = ( in1, in2 = 1 ) => {\n\n\tin1 = float( in1 );\n\n\treturn in1.abs().pow( in2 ).mul( in1.sign() );\n\n};\n\nconst mx_contrast = ( input, amount = 1, pivot = .5 ) => float( input ).sub( pivot ).mul( amount ).add( pivot );\n\nconst mx_noise_float = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_float( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\n//export const mx_noise_vec2 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\nconst mx_noise_vec3 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\nconst mx_noise_vec4 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => {\n\n\ttexcoord = texcoord.convert( 'vec2|vec3' ); // overloading type\n\n\tconst noise_vec4 = vec4( mx_perlin_noise_vec3( texcoord ), mx_perlin_noise_float( texcoord.add( vec2( 19, 73 ) ) ) );\n\n\treturn noise_vec4.mul( amplitude ).add( pivot );\n\n};\n\nconst mx_worley_noise_float = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_float$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\nconst mx_worley_noise_vec2 = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_vec2$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\nconst mx_worley_noise_vec3 = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_vec3$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\n\nconst mx_cell_noise_float = ( texcoord = uv() ) => mx_cell_noise_float$1( texcoord.convert( 'vec2|vec3' ) );\n\nconst mx_fractal_noise_float = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_float$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec2 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec2$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec3 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec3$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec4 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec4$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\n\n// https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html\n\nconst getParallaxCorrectNormal = /*@__PURE__*/ Fn( ( [ normal, cubeSize, cubePos ] ) => {\n\n\tconst nDir = normalize( normal ).toVar( 'nDir' );\n\tconst rbmax = sub( float( 0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld ).div( nDir ).toVar( 'rbmax' );\n\tconst rbmin = sub( float( - 0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld ).div( nDir ).toVar( 'rbmin' );\n\tconst rbminmax = vec3().toVar( 'rbminmax' );\n\trbminmax.x = nDir.x.greaterThan( float( 0 ) ).select( rbmax.x, rbmin.x );\n\trbminmax.y = nDir.y.greaterThan( float( 0 ) ).select( rbmax.y, rbmin.y );\n\trbminmax.z = nDir.z.greaterThan( float( 0 ) ).select( rbmax.z, rbmin.z );\n\n\tconst correction = min$1( min$1( rbminmax.x, rbminmax.y ), rbminmax.z ).toVar( 'correction' );\n\tconst boxIntersection = positionWorld.add( nDir.mul( correction ) ).toVar( 'boxIntersection' );\n\treturn boxIntersection.sub( cubePos );\n\n} );\n\nconst getShIrradianceAt = /*@__PURE__*/ Fn( ( [ normal, shCoefficients ] ) => {\n\n\t// normal is assumed to have unit length\n\n\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t// band 0\n\tlet result = shCoefficients.element( 0 ).mul( 0.886227 );\n\n\t// band 1\n\tresult = result.add( shCoefficients.element( 1 ).mul( 2.0 * 0.511664 ).mul( y ) );\n\tresult = result.add( shCoefficients.element( 2 ).mul( 2.0 * 0.511664 ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 3 ).mul( 2.0 * 0.511664 ).mul( x ) );\n\n\t// band 2\n\tresult = result.add( shCoefficients.element( 4 ).mul( 2.0 * 0.429043 ).mul( x ).mul( y ) );\n\tresult = result.add( shCoefficients.element( 5 ).mul( 2.0 * 0.429043 ).mul( y ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 6 ).mul( z.mul( z ).mul( 0.743125 ).sub( 0.247708 ) ) );\n\tresult = result.add( shCoefficients.element( 7 ).mul( 2.0 * 0.429043 ).mul( x ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 8 ).mul( 0.429043 ).mul( mul( x, x ).sub( mul( y, y ) ) ) );\n\n\treturn result;\n\n} );\n\n// constants\n\nvar TSL = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBRDF_GGX: BRDF_GGX,\n\tBRDF_Lambert: BRDF_Lambert,\n\tBasicShadowFilter: BasicShadowFilter,\n\tBreak: Break,\n\tContinue: Continue,\n\tDFGApprox: DFGApprox,\n\tD_GGX: D_GGX,\n\tDiscard: Discard,\n\tEPSILON: EPSILON,\n\tF_Schlick: F_Schlick,\n\tFn: Fn,\n\tINFINITY: INFINITY,\n\tIf: If,\n\tLoop: Loop,\n\tNodeAccess: NodeAccess,\n\tNodeShaderStage: NodeShaderStage,\n\tNodeType: NodeType,\n\tNodeUpdateType: NodeUpdateType,\n\tPCFShadowFilter: PCFShadowFilter,\n\tPCFSoftShadowFilter: PCFSoftShadowFilter,\n\tPI: PI,\n\tPI2: PI2,\n\tReturn: Return,\n\tSchlick_to_F0: Schlick_to_F0,\n\tScriptableNodeResources: ScriptableNodeResources,\n\tShaderNode: ShaderNode,\n\tTBNViewMatrix: TBNViewMatrix,\n\tVSMShadowFilter: VSMShadowFilter,\n\tV_GGX_SmithCorrelated: V_GGX_SmithCorrelated,\n\tabs: abs,\n\tacesFilmicToneMapping: acesFilmicToneMapping,\n\tacos: acos,\n\tadd: add,\n\taddMethodChaining: addMethodChaining,\n\taddNodeElement: addNodeElement,\n\tagxToneMapping: agxToneMapping,\n\tall: all,\n\talphaT: alphaT,\n\tand: and,\n\tanisotropy: anisotropy,\n\tanisotropyB: anisotropyB,\n\tanisotropyT: anisotropyT,\n\tany: any,\n\tappend: append,\n\tarrayBuffer: arrayBuffer,\n\tasin: asin,\n\tassign: assign,\n\tatan: atan,\n\tatan2: atan2,\n\tatomicAdd: atomicAdd,\n\tatomicAnd: atomicAnd,\n\tatomicFunc: atomicFunc,\n\tatomicMax: atomicMax,\n\tatomicMin: atomicMin,\n\tatomicOr: atomicOr,\n\tatomicStore: atomicStore,\n\tatomicSub: atomicSub,\n\tatomicXor: atomicXor,\n\tattenuationColor: attenuationColor,\n\tattenuationDistance: attenuationDistance,\n\tattribute: attribute,\n\tattributeArray: attributeArray,\n\tbackgroundBlurriness: backgroundBlurriness,\n\tbackgroundIntensity: backgroundIntensity,\n\tbackgroundRotation: backgroundRotation,\n\tbatch: batch,\n\tbillboarding: billboarding,\n\tbitAnd: bitAnd,\n\tbitNot: bitNot,\n\tbitOr: bitOr,\n\tbitXor: bitXor,\n\tbitangentGeometry: bitangentGeometry,\n\tbitangentLocal: bitangentLocal,\n\tbitangentView: bitangentView,\n\tbitangentWorld: bitangentWorld,\n\tbitcast: bitcast,\n\tblendBurn: blendBurn,\n\tblendColor: blendColor,\n\tblendDodge: blendDodge,\n\tblendOverlay: blendOverlay,\n\tblendScreen: blendScreen,\n\tblur: blur,\n\tbool: bool,\n\tbuffer: buffer,\n\tbufferAttribute: bufferAttribute,\n\tbumpMap: bumpMap,\n\tburn: burn,\n\tbvec2: bvec2,\n\tbvec3: bvec3,\n\tbvec4: bvec4,\n\tbypass: bypass,\n\tcache: cache,\n\tcall: call,\n\tcameraFar: cameraFar,\n\tcameraNear: cameraNear,\n\tcameraNormalMatrix: cameraNormalMatrix,\n\tcameraPosition: cameraPosition,\n\tcameraProjectionMatrix: cameraProjectionMatrix,\n\tcameraProjectionMatrixInverse: cameraProjectionMatrixInverse,\n\tcameraViewMatrix: cameraViewMatrix,\n\tcameraWorldMatrix: cameraWorldMatrix,\n\tcbrt: cbrt,\n\tcdl: cdl,\n\tceil: ceil,\n\tchecker: checker,\n\tcineonToneMapping: cineonToneMapping,\n\tclamp: clamp,\n\tclearcoat: clearcoat,\n\tclearcoatRoughness: clearcoatRoughness,\n\tcode: code,\n\tcolor: color,\n\tcolorSpaceToWorking: colorSpaceToWorking,\n\tcolorToDirection: colorToDirection,\n\tcompute: compute,\n\tcond: cond,\n\tcontext: context,\n\tconvert: convert,\n\tconvertColorSpace: convertColorSpace,\n\tconvertToTexture: convertToTexture,\n\tcos: cos,\n\tcross: cross,\n\tcubeTexture: cubeTexture,\n\tdFdx: dFdx,\n\tdFdy: dFdy,\n\tdashSize: dashSize,\n\tdefaultBuildStages: defaultBuildStages,\n\tdefaultShaderStages: defaultShaderStages,\n\tdefined: defined,\n\tdegrees: degrees,\n\tdeltaTime: deltaTime,\n\tdensityFog: densityFog,\n\tdepth: depth,\n\tdepthPass: depthPass,\n\tdifference: difference,\n\tdiffuseColor: diffuseColor,\n\tdirectPointLight: directPointLight,\n\tdirectionToColor: directionToColor,\n\tdispersion: dispersion,\n\tdistance: distance,\n\tdiv: div,\n\tdodge: dodge,\n\tdot: dot,\n\tdrawIndex: drawIndex,\n\tdynamicBufferAttribute: dynamicBufferAttribute,\n\telement: element,\n\temissive: emissive,\n\tequal: equal,\n\tequals: equals,\n\tequirectUV: equirectUV,\n\texp: exp,\n\texp2: exp2,\n\texpression: expression,\n\tfaceDirection: faceDirection,\n\tfaceForward: faceForward,\n\tfloat: float,\n\tfloor: floor,\n\tfog: fog,\n\tfract: fract,\n\tframeGroup: frameGroup,\n\tframeId: frameId,\n\tfrontFacing: frontFacing,\n\tfwidth: fwidth,\n\tgain: gain,\n\tgapSize: gapSize,\n\tgetConstNodeType: getConstNodeType,\n\tgetCurrentStack: getCurrentStack,\n\tgetDirection: getDirection,\n\tgetDistanceAttenuation: getDistanceAttenuation,\n\tgetGeometryRoughness: getGeometryRoughness,\n\tgetNormalFromDepth: getNormalFromDepth,\n\tgetParallaxCorrectNormal: getParallaxCorrectNormal,\n\tgetRoughness: getRoughness,\n\tgetScreenPosition: getScreenPosition,\n\tgetShIrradianceAt: getShIrradianceAt,\n\tgetTextureIndex: getTextureIndex,\n\tgetViewPosition: getViewPosition,\n\tglsl: glsl,\n\tglslFn: glslFn,\n\tgrayscale: grayscale,\n\tgreaterThan: greaterThan,\n\tgreaterThanEqual: greaterThanEqual,\n\thash: hash,\n\thighPrecisionModelNormalViewMatrix: highPrecisionModelNormalViewMatrix,\n\thighPrecisionModelViewMatrix: highPrecisionModelViewMatrix,\n\thue: hue,\n\tinstance: instance,\n\tinstanceIndex: instanceIndex,\n\tinstancedArray: instancedArray,\n\tinstancedBufferAttribute: instancedBufferAttribute,\n\tinstancedDynamicBufferAttribute: instancedDynamicBufferAttribute,\n\tinstancedMesh: instancedMesh,\n\tint: int,\n\tinverseSqrt: inverseSqrt,\n\tinvocationLocalIndex: invocationLocalIndex,\n\tinvocationSubgroupIndex: invocationSubgroupIndex,\n\tior: ior,\n\tiridescence: iridescence,\n\tiridescenceIOR: iridescenceIOR,\n\tiridescenceThickness: iridescenceThickness,\n\tivec2: ivec2,\n\tivec3: ivec3,\n\tivec4: ivec4,\n\tjs: js,\n\tlabel: label,\n\tlength: length,\n\tlengthSq: lengthSq,\n\tlessThan: lessThan,\n\tlessThanEqual: lessThanEqual,\n\tlightPosition: lightPosition,\n\tlightProjectionUV: lightProjectionUV,\n\tlightShadowMatrix: lightShadowMatrix,\n\tlightTargetDirection: lightTargetDirection,\n\tlightTargetPosition: lightTargetPosition,\n\tlightViewPosition: lightViewPosition,\n\tlightingContext: lightingContext,\n\tlights: lights,\n\tlinearDepth: linearDepth,\n\tlinearToneMapping: linearToneMapping,\n\tlocalId: localId,\n\tlog: log,\n\tlog2: log2,\n\tlogarithmicDepthToViewZ: logarithmicDepthToViewZ,\n\tloop: loop,\n\tluminance: luminance,\n\tmat2: mat2,\n\tmat3: mat3,\n\tmat4: mat4,\n\tmatcapUV: matcapUV,\n\tmaterialAOMap: materialAOMap,\n\tmaterialAlphaTest: materialAlphaTest,\n\tmaterialAnisotropy: materialAnisotropy,\n\tmaterialAnisotropyVector: materialAnisotropyVector,\n\tmaterialAttenuationColor: materialAttenuationColor,\n\tmaterialAttenuationDistance: materialAttenuationDistance,\n\tmaterialClearcoat: materialClearcoat,\n\tmaterialClearcoatNormal: materialClearcoatNormal,\n\tmaterialClearcoatRoughness: materialClearcoatRoughness,\n\tmaterialColor: materialColor,\n\tmaterialDispersion: materialDispersion,\n\tmaterialEmissive: materialEmissive,\n\tmaterialIOR: materialIOR,\n\tmaterialIridescence: materialIridescence,\n\tmaterialIridescenceIOR: materialIridescenceIOR,\n\tmaterialIridescenceThickness: materialIridescenceThickness,\n\tmaterialLightMap: materialLightMap,\n\tmaterialLineDashOffset: materialLineDashOffset,\n\tmaterialLineDashSize: materialLineDashSize,\n\tmaterialLineGapSize: materialLineGapSize,\n\tmaterialLineScale: materialLineScale,\n\tmaterialLineWidth: materialLineWidth,\n\tmaterialMetalness: materialMetalness,\n\tmaterialNormal: materialNormal,\n\tmaterialOpacity: materialOpacity,\n\tmaterialPointWidth: materialPointWidth,\n\tmaterialReference: materialReference,\n\tmaterialReflectivity: materialReflectivity,\n\tmaterialRefractionRatio: materialRefractionRatio,\n\tmaterialRotation: materialRotation,\n\tmaterialRoughness: materialRoughness,\n\tmaterialSheen: materialSheen,\n\tmaterialSheenRoughness: materialSheenRoughness,\n\tmaterialShininess: materialShininess,\n\tmaterialSpecular: materialSpecular,\n\tmaterialSpecularColor: materialSpecularColor,\n\tmaterialSpecularIntensity: materialSpecularIntensity,\n\tmaterialSpecularStrength: materialSpecularStrength,\n\tmaterialThickness: materialThickness,\n\tmaterialTransmission: materialTransmission,\n\tmax: max$1,\n\tmaxMipLevel: maxMipLevel,\n\tmetalness: metalness,\n\tmin: min$1,\n\tmix: mix,\n\tmixElement: mixElement,\n\tmod: mod,\n\tmodInt: modInt,\n\tmodelDirection: modelDirection,\n\tmodelNormalMatrix: modelNormalMatrix,\n\tmodelPosition: modelPosition,\n\tmodelScale: modelScale,\n\tmodelViewMatrix: modelViewMatrix,\n\tmodelViewPosition: modelViewPosition,\n\tmodelViewProjection: modelViewProjection,\n\tmodelWorldMatrix: modelWorldMatrix,\n\tmodelWorldMatrixInverse: modelWorldMatrixInverse,\n\tmorphReference: morphReference,\n\tmrt: mrt,\n\tmul: mul,\n\tmx_aastep: mx_aastep,\n\tmx_cell_noise_float: mx_cell_noise_float,\n\tmx_contrast: mx_contrast,\n\tmx_fractal_noise_float: mx_fractal_noise_float,\n\tmx_fractal_noise_vec2: mx_fractal_noise_vec2,\n\tmx_fractal_noise_vec3: mx_fractal_noise_vec3,\n\tmx_fractal_noise_vec4: mx_fractal_noise_vec4,\n\tmx_hsvtorgb: mx_hsvtorgb,\n\tmx_noise_float: mx_noise_float,\n\tmx_noise_vec3: mx_noise_vec3,\n\tmx_noise_vec4: mx_noise_vec4,\n\tmx_ramplr: mx_ramplr,\n\tmx_ramptb: mx_ramptb,\n\tmx_rgbtohsv: mx_rgbtohsv,\n\tmx_safepower: mx_safepower,\n\tmx_splitlr: mx_splitlr,\n\tmx_splittb: mx_splittb,\n\tmx_srgb_texture_to_lin_rec709: mx_srgb_texture_to_lin_rec709,\n\tmx_transform_uv: mx_transform_uv,\n\tmx_worley_noise_float: mx_worley_noise_float,\n\tmx_worley_noise_vec2: mx_worley_noise_vec2,\n\tmx_worley_noise_vec3: mx_worley_noise_vec3,\n\tnegate: negate,\n\tneutralToneMapping: neutralToneMapping,\n\tnodeArray: nodeArray,\n\tnodeImmutable: nodeImmutable,\n\tnodeObject: nodeObject,\n\tnodeObjects: nodeObjects,\n\tnodeProxy: nodeProxy,\n\tnormalFlat: normalFlat,\n\tnormalGeometry: normalGeometry,\n\tnormalLocal: normalLocal,\n\tnormalMap: normalMap,\n\tnormalView: normalView,\n\tnormalWorld: normalWorld,\n\tnormalize: normalize,\n\tnot: not,\n\tnotEqual: notEqual,\n\tnumWorkgroups: numWorkgroups,\n\tobjectDirection: objectDirection,\n\tobjectGroup: objectGroup,\n\tobjectPosition: objectPosition,\n\tobjectScale: objectScale,\n\tobjectViewPosition: objectViewPosition,\n\tobjectWorldMatrix: objectWorldMatrix,\n\toneMinus: oneMinus,\n\tor: or,\n\torthographicDepthToViewZ: orthographicDepthToViewZ,\n\toscSawtooth: oscSawtooth,\n\toscSine: oscSine,\n\toscSquare: oscSquare,\n\toscTriangle: oscTriangle,\n\toutput: output,\n\toutputStruct: outputStruct,\n\toverlay: overlay,\n\toverloadingFn: overloadingFn,\n\tparabola: parabola,\n\tparallaxDirection: parallaxDirection,\n\tparallaxUV: parallaxUV,\n\tparameter: parameter,\n\tpass: pass,\n\tpassTexture: passTexture,\n\tpcurve: pcurve,\n\tperspectiveDepthToViewZ: perspectiveDepthToViewZ,\n\tpmremTexture: pmremTexture,\n\tpointUV: pointUV,\n\tpointWidth: pointWidth,\n\tpositionGeometry: positionGeometry,\n\tpositionLocal: positionLocal,\n\tpositionPrevious: positionPrevious,\n\tpositionView: positionView,\n\tpositionViewDirection: positionViewDirection,\n\tpositionWorld: positionWorld,\n\tpositionWorldDirection: positionWorldDirection,\n\tposterize: posterize,\n\tpow: pow,\n\tpow2: pow2,\n\tpow3: pow3,\n\tpow4: pow4,\n\tproperty: property,\n\tradians: radians,\n\trand: rand,\n\trange: range,\n\trangeFog: rangeFog,\n\treciprocal: reciprocal,\n\treference: reference,\n\treferenceBuffer: referenceBuffer,\n\treflect: reflect,\n\treflectVector: reflectVector,\n\treflectView: reflectView,\n\treflector: reflector,\n\trefract: refract,\n\trefractVector: refractVector,\n\trefractView: refractView,\n\treinhardToneMapping: reinhardToneMapping,\n\tremainder: remainder,\n\tremap: remap,\n\tremapClamp: remapClamp,\n\trenderGroup: renderGroup,\n\trenderOutput: renderOutput,\n\trendererReference: rendererReference,\n\trotate: rotate,\n\trotateUV: rotateUV,\n\troughness: roughness,\n\tround: round,\n\trtt: rtt,\n\tsRGBTransferEOTF: sRGBTransferEOTF,\n\tsRGBTransferOETF: sRGBTransferOETF,\n\tsampler: sampler,\n\tsaturate: saturate,\n\tsaturation: saturation,\n\tscreen: screen,\n\tscreenCoordinate: screenCoordinate,\n\tscreenSize: screenSize,\n\tscreenUV: screenUV,\n\tscriptable: scriptable,\n\tscriptableValue: scriptableValue,\n\tselect: select,\n\tsetCurrentStack: setCurrentStack,\n\tshaderStages: shaderStages,\n\tshadow: shadow,\n\tsharedUniformGroup: sharedUniformGroup,\n\tsheen: sheen,\n\tsheenRoughness: sheenRoughness,\n\tshiftLeft: shiftLeft,\n\tshiftRight: shiftRight,\n\tshininess: shininess,\n\tsign: sign,\n\tsin: sin,\n\tsinc: sinc,\n\tskinning: skinning,\n\tskinningReference: skinningReference,\n\tsmoothstep: smoothstep,\n\tsmoothstepElement: smoothstepElement,\n\tspecularColor: specularColor,\n\tspecularF90: specularF90,\n\tspherizeUV: spherizeUV,\n\tsplit: split,\n\tspritesheetUV: spritesheetUV,\n\tsqrt: sqrt,\n\tstack: stack,\n\tstep: step,\n\tstorage: storage,\n\tstorageBarrier: storageBarrier,\n\tstorageObject: storageObject,\n\tstorageTexture: storageTexture,\n\tstring: string,\n\tsub: sub,\n\tsubgroupIndex: subgroupIndex,\n\tsubgroupSize: subgroupSize,\n\ttan: tan,\n\ttangentGeometry: tangentGeometry,\n\ttangentLocal: tangentLocal,\n\ttangentView: tangentView,\n\ttangentWorld: tangentWorld,\n\ttemp: temp,\n\ttexture: texture,\n\ttexture3D: texture3D,\n\ttextureBarrier: textureBarrier,\n\ttextureBicubic: textureBicubic,\n\ttextureCubeUV: textureCubeUV,\n\ttextureLoad: textureLoad,\n\ttextureSize: textureSize,\n\ttextureStore: textureStore,\n\tthickness: thickness,\n\tthreshold: threshold,\n\ttime: time,\n\ttimerDelta: timerDelta,\n\ttimerGlobal: timerGlobal,\n\ttimerLocal: timerLocal,\n\ttoOutputColorSpace: toOutputColorSpace,\n\ttoWorkingColorSpace: toWorkingColorSpace,\n\ttoneMapping: toneMapping,\n\ttoneMappingExposure: toneMappingExposure,\n\ttoonOutlinePass: toonOutlinePass,\n\ttransformDirection: transformDirection,\n\ttransformNormal: transformNormal,\n\ttransformNormalToView: transformNormalToView,\n\ttransformedBentNormalView: transformedBentNormalView,\n\ttransformedBitangentView: transformedBitangentView,\n\ttransformedBitangentWorld: transformedBitangentWorld,\n\ttransformedClearcoatNormalView: transformedClearcoatNormalView,\n\ttransformedNormalView: transformedNormalView,\n\ttransformedNormalWorld: transformedNormalWorld,\n\ttransformedTangentView: transformedTangentView,\n\ttransformedTangentWorld: transformedTangentWorld,\n\ttransmission: transmission,\n\ttranspose: transpose,\n\ttri: tri,\n\ttri3: tri3,\n\ttriNoise3D: triNoise3D,\n\ttriplanarTexture: triplanarTexture,\n\ttriplanarTextures: triplanarTextures,\n\ttrunc: trunc,\n\ttslFn: tslFn,\n\tuint: uint,\n\tuniform: uniform,\n\tuniformArray: uniformArray,\n\tuniformGroup: uniformGroup,\n\tuniforms: uniforms,\n\tuserData: userData,\n\tuv: uv,\n\tuvec2: uvec2,\n\tuvec3: uvec3,\n\tuvec4: uvec4,\n\tvarying: varying,\n\tvaryingProperty: varyingProperty,\n\tvec2: vec2,\n\tvec3: vec3,\n\tvec4: vec4,\n\tvectorComponents: vectorComponents,\n\tvelocity: velocity,\n\tvertexColor: vertexColor,\n\tvertexIndex: vertexIndex,\n\tvibrance: vibrance,\n\tviewZToLogarithmicDepth: viewZToLogarithmicDepth,\n\tviewZToOrthographicDepth: viewZToOrthographicDepth,\n\tviewZToPerspectiveDepth: viewZToPerspectiveDepth,\n\tviewport: viewport,\n\tviewportBottomLeft: viewportBottomLeft,\n\tviewportCoordinate: viewportCoordinate,\n\tviewportDepthTexture: viewportDepthTexture,\n\tviewportLinearDepth: viewportLinearDepth,\n\tviewportMipTexture: viewportMipTexture,\n\tviewportResolution: viewportResolution,\n\tviewportSafeUV: viewportSafeUV,\n\tviewportSharedTexture: viewportSharedTexture,\n\tviewportSize: viewportSize,\n\tviewportTexture: viewportTexture,\n\tviewportTopLeft: viewportTopLeft,\n\tviewportUV: viewportUV,\n\twgsl: wgsl,\n\twgslFn: wgslFn,\n\tworkgroupArray: workgroupArray,\n\tworkgroupBarrier: workgroupBarrier,\n\tworkgroupId: workgroupId,\n\tworkingToColorSpace: workingToColorSpace,\n\txor: xor\n});\n\nconst _clearColor$1 = /*@__PURE__*/ new Color4();\n\nclass Background extends DataMap {\n\n\tconstructor( renderer, nodes ) {\n\n\t\tsuper();\n\n\t\tthis.renderer = renderer;\n\t\tthis.nodes = nodes;\n\n\t}\n\n\tupdate( scene, renderList, renderContext ) {\n\n\t\tconst renderer = this.renderer;\n\t\tconst background = this.nodes.getBackgroundNode( scene ) || scene.background;\n\n\t\tlet forceClear = false;\n\n\t\tif ( background === null ) {\n\n\t\t\t// no background settings, use clear color configuration from the renderer\n\n\t\t\trenderer._clearColor.getRGB( _clearColor$1, LinearSRGBColorSpace );\n\t\t\t_clearColor$1.a = renderer._clearColor.a;\n\n\t\t} else if ( background.isColor === true ) {\n\n\t\t\t// background is an opaque color\n\n\t\t\tbackground.getRGB( _clearColor$1, LinearSRGBColorSpace );\n\t\t\t_clearColor$1.a = 1;\n\n\t\t\tforceClear = true;\n\n\t\t} else if ( background.isNode === true ) {\n\n\t\t\tconst sceneData = this.get( scene );\n\t\t\tconst backgroundNode = background;\n\n\t\t\t_clearColor$1.copy( renderer._clearColor );\n\n\t\t\tlet backgroundMesh = sceneData.backgroundMesh;\n\n\t\t\tif ( backgroundMesh === undefined ) {\n\n\t\t\t\tconst backgroundMeshNode = context( vec4( backgroundNode ).mul( backgroundIntensity ), {\n\t\t\t\t\t// @TODO: Add Texture2D support using node context\n\t\t\t\t\tgetUV: () => backgroundRotation.mul( normalWorld ),\n\t\t\t\t\tgetTextureLevel: () => backgroundBlurriness\n\t\t\t\t} );\n\n\t\t\t\tlet viewProj = modelViewProjection();\n\t\t\t\tviewProj = viewProj.setZ( viewProj.w );\n\n\t\t\t\tconst nodeMaterial = new NodeMaterial();\n\t\t\t\tnodeMaterial.name = 'Background.material';\n\t\t\t\tnodeMaterial.side = BackSide;\n\t\t\t\tnodeMaterial.depthTest = false;\n\t\t\t\tnodeMaterial.depthWrite = false;\n\t\t\t\tnodeMaterial.fog = false;\n\t\t\t\tnodeMaterial.lights = false;\n\t\t\t\tnodeMaterial.vertexNode = viewProj;\n\t\t\t\tnodeMaterial.colorNode = backgroundMeshNode;\n\n\t\t\t\tsceneData.backgroundMeshNode = backgroundMeshNode;\n\t\t\t\tsceneData.backgroundMesh = backgroundMesh = new Mesh( new SphereGeometry( 1, 32, 32 ), nodeMaterial );\n\t\t\t\tbackgroundMesh.frustumCulled = false;\n\t\t\t\tbackgroundMesh.name = 'Background.mesh';\n\n\t\t\t\tbackgroundMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tconst backgroundCacheKey = backgroundNode.getCacheKey();\n\n\t\t\tif ( sceneData.backgroundCacheKey !== backgroundCacheKey ) {\n\n\t\t\t\tsceneData.backgroundMeshNode.node = vec4( backgroundNode ).mul( backgroundIntensity );\n\t\t\t\tsceneData.backgroundMeshNode.needsUpdate = true;\n\n\t\t\t\tbackgroundMesh.material.needsUpdate = true;\n\n\t\t\t\tsceneData.backgroundCacheKey = backgroundCacheKey;\n\n\t\t\t}\n\n\t\t\trenderList.unshift( backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Renderer: Unsupported background configuration.', background );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderer.autoClear === true || forceClear === true ) {\n\n\t\t\tconst clearColorValue = renderContext.clearColorValue;\n\n\t\t\tclearColorValue.r = _clearColor$1.r;\n\t\t\tclearColorValue.g = _clearColor$1.g;\n\t\t\tclearColorValue.b = _clearColor$1.b;\n\t\t\tclearColorValue.a = _clearColor$1.a;\n\n\t\t\t// premultiply alpha\n\n\t\t\tif ( renderer.backend.isWebGLBackend === true || renderer.alpha === true ) {\n\n\t\t\t\tclearColorValue.r *= clearColorValue.a;\n\t\t\t\tclearColorValue.g *= clearColorValue.a;\n\t\t\t\tclearColorValue.b *= clearColorValue.a;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\trenderContext.depthClearValue = renderer._clearDepth;\n\t\t\trenderContext.stencilClearValue = renderer._clearStencil;\n\n\t\t\trenderContext.clearColor = renderer.autoClearColor === true;\n\t\t\trenderContext.clearDepth = renderer.autoClearDepth === true;\n\t\t\trenderContext.clearStencil = renderer.autoClearStencil === true;\n\n\t\t} else {\n\n\t\t\trenderContext.clearColor = false;\n\t\t\trenderContext.clearDepth = false;\n\t\t\trenderContext.clearStencil = false;\n\n\t\t}\n\n\t}\n\n}\n\nlet _id$5 = 0;\n\nclass BindGroup {\n\n\tconstructor( name = '', bindings = [], index = 0, bindingsReference = [] ) {\n\n\t\tthis.name = name;\n\t\tthis.bindings = bindings;\n\t\tthis.index = index;\n\t\tthis.bindingsReference = bindingsReference;\n\n\t\tthis.id = _id$5 ++;\n\n\t}\n\n}\n\nclass NodeBuilderState {\n\n\tconstructor( vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, monitor, transforms = [] ) {\n\n\t\tthis.vertexShader = vertexShader;\n\t\tthis.fragmentShader = fragmentShader;\n\t\tthis.computeShader = computeShader;\n\t\tthis.transforms = transforms;\n\n\t\tthis.nodeAttributes = nodeAttributes;\n\t\tthis.bindings = bindings;\n\n\t\tthis.updateNodes = updateNodes;\n\t\tthis.updateBeforeNodes = updateBeforeNodes;\n\t\tthis.updateAfterNodes = updateAfterNodes;\n\n\t\tthis.monitor = monitor;\n\n\t\tthis.usedTimes = 0;\n\n\t}\n\n\tcreateBindings() {\n\n\t\tconst bindings = [];\n\n\t\tfor ( const instanceGroup of this.bindings ) {\n\n\t\t\tconst shared = instanceGroup.bindings[ 0 ].groupNode.shared;\n\n\t\t\tif ( shared !== true ) {\n\n\t\t\t\tconst bindingsGroup = new BindGroup( instanceGroup.name, [], instanceGroup.index, instanceGroup );\n\t\t\t\tbindings.push( bindingsGroup );\n\n\t\t\t\tfor ( const instanceBinding of instanceGroup.bindings ) {\n\n\t\t\t\t\tbindingsGroup.bindings.push( instanceBinding.clone() );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbindings.push( instanceGroup );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n}\n\nclass NodeAttribute {\n\n\tconstructor( name, type, node = null ) {\n\n\t\tthis.isNodeAttribute = true;\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.node = node;\n\n\t}\n\n}\n\nclass NodeUniform {\n\n\tconstructor( name, type, node ) {\n\n\t\tthis.isNodeUniform = true;\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.node = node.getSelf();\n\n\t}\n\n\tget value() {\n\n\t\treturn this.node.value;\n\n\t}\n\n\tset value( val ) {\n\n\t\tthis.node.value = val;\n\n\t}\n\n\tget id() {\n\n\t\treturn this.node.id;\n\n\t}\n\n\tget groupNode() {\n\n\t\treturn this.node.groupNode;\n\n\t}\n\n}\n\nclass NodeVar {\n\n\tconstructor( name, type ) {\n\n\t\tthis.isNodeVar = true;\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\n\t}\n\n}\n\nclass NodeVarying extends NodeVar {\n\n\tconstructor( name, type ) {\n\n\t\tsuper( name, type );\n\n\t\tthis.needsInterpolation = false;\n\n\t\tthis.isNodeVarying = true;\n\n\t}\n\n}\n\nclass NodeCode {\n\n\tconstructor( name, type, code = '' ) {\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.code = code;\n\n\t\tObject.defineProperty( this, 'isNodeCode', { value: true } );\n\n\t}\n\n}\n\nlet id = 0;\n\nclass NodeCache {\n\n\tconstructor( parent = null ) {\n\n\t\tthis.id = id ++;\n\t\tthis.nodesData = new WeakMap();\n\n\t\tthis.parent = parent;\n\n\t}\n\n\tgetData( node ) {\n\n\t\tlet data = this.nodesData.get( node );\n\n\t\tif ( data === undefined && this.parent !== null ) {\n\n\t\t\tdata = this.parent.getData( node );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tsetData( node, data ) {\n\n\t\tthis.nodesData.set( node, data );\n\n\t}\n\n}\n\nclass Uniform {\n\n\tconstructor( name, value ) {\n\n\t\tthis.name = name;\n\t\tthis.value = value;\n\n\t\tthis.boundary = 0; // used to build the uniform buffer according to the STD140 layout\n\t\tthis.itemSize = 0;\n\n\t\tthis.offset = 0; // this property is set by WebGPUUniformsGroup and marks the start position in the uniform buffer\n\n\t}\n\n\tsetValue( value ) {\n\n\t\tthis.value = value;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.value;\n\n\t}\n\n}\n\nclass NumberUniform extends Uniform {\n\n\tconstructor( name, value = 0 ) {\n\n\t\tsuper( name, value );\n\n\t\tthis.isNumberUniform = true;\n\n\t\tthis.boundary = 4;\n\t\tthis.itemSize = 1;\n\n\t}\n\n}\n\nclass Vector2Uniform extends Uniform {\n\n\tconstructor( name, value = new Vector2() ) {\n\n\t\tsuper( name, value );\n\n\t\tthis.isVector2Uniform = true;\n\n\t\tthis.boundary = 8;\n\t\tthis.itemSize = 2;\n\n\t}\n\n}\n\nclass Vector3Uniform extends Uniform {\n\n\tconstructor( name, value = new Vector3() ) {\n\n\t\tsuper( name, value );\n\n\t\tthis.isVector3Uniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 3;\n\n\t}\n\n}\n\nclass Vector4Uniform extends Uniform {\n\n\tconstructor( name, value = new Vector4() ) {\n\n\t\tsuper( name, value );\n\n\t\tthis.isVector4Uniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 4;\n\n\t}\n\n}\n\nclass ColorUniform extends Uniform {\n\n\tconstructor( name, value = new Color() ) {\n\n\t\tsuper( name, value );\n\n\t\tthis.isColorUniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 3;\n\n\t}\n\n}\n\nclass Matrix3Uniform extends Uniform {\n\n\tconstructor( name, value = new Matrix3() ) {\n\n\t\tsuper( name, value );\n\n\t\tthis.isMatrix3Uniform = true;\n\n\t\tthis.boundary = 48;\n\t\tthis.itemSize = 12;\n\n\t}\n\n}\n\nclass Matrix4Uniform extends Uniform {\n\n\tconstructor( name, value = new Matrix4() ) {\n\n\t\tsuper( name, value );\n\n\t\tthis.isMatrix4Uniform = true;\n\n\t\tthis.boundary = 64;\n\t\tthis.itemSize = 16;\n\n\t}\n\n}\n\nclass NumberNodeUniform extends NumberUniform {\n\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nclass Vector2NodeUniform extends Vector2Uniform {\n\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nclass Vector3NodeUniform extends Vector3Uniform {\n\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nclass Vector4NodeUniform extends Vector4Uniform {\n\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nclass ColorNodeUniform extends ColorUniform {\n\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nclass Matrix3NodeUniform extends Matrix3Uniform {\n\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nclass Matrix4NodeUniform extends Matrix4Uniform {\n\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\nconst _cubeCamera = /*@__PURE__*/ new PerspectiveCamera( 90, 1 );\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 )\n];\n\n//\n\n// WebGPU Face indices\nconst _faceLib = [\n\t3, 1, 5,\n\t0, 4, 2\n];\n\nconst direction = getDirection( uv(), attribute( 'faceIndex' ) ).normalize();\nconst outputDirection = vec3( direction.x, direction.y.negate(), direction.z );\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._lodMax = 0;\n\t\tthis._cubeSize = 0;\n\t\tthis._lodPlanes = [];\n\t\tthis._sizeLods = [];\n\t\tthis._sigmas = [];\n\t\tthis._lodMeshes = [];\n\n\t\tthis._blurMaterial = null;\n\t\tthis._cubemapMaterial = null;\n\t\tthis._equirectMaterial = null;\n\t\tthis._backgroundBox = null;\n\n\t}\n\n\tget _hasInitialized() {\n\n\t\treturn this._renderer.hasInitialized();\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100, renderTarget = null ) {\n\n\t\tthis._setSize( 256 );\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.' );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n\t\t\tthis.fromSceneAsync( scene, sigma, near, far, cubeUVRenderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tcubeUVRenderTarget.depthBuffer = true;\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\tasync fromSceneAsync( scene, sigma = 0, near = 0.1, far = 100, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this.fromScene( scene, sigma, near, far, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromEquirectangular( equirectangular, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.' );\n\n\t\t\tthis._setSizeFromTexture( equirectangular );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n\t\t\tthis.fromEquirectangularAsync( equirectangular, cubeUVRenderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\tasync fromEquirectangularAsync( equirectangular, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromCubemap( cubemap, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.' );\n\n\t\t\tthis._setSizeFromTexture( cubemap );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n\t\t\tthis.fromCubemapAsync( cubemap, renderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\tasync fromCubemapAsync( cubemap, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tasync compileCubemapShader() {\n\n\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\t\t\tawait this._compileMaterial( this._cubemapMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tasync compileEquirectangularShader() {\n\n\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\t\t\tawait this._compileMaterial( this._equirectMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._dispose();\n\n\t\tif ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();\n\t\tif ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();\n\t\tif ( this._backgroundBox !== null ) {\n\n\t\t\tthis._backgroundBox.geometry.dispose();\n\t\t\tthis._backgroundBox.material.dispose();\n\n\t\t}\n\n\t}\n\n\t// private interface\n\n\t_setSizeFromTexture( texture ) {\n\n\t\tif ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {\n\n\t\t\tthis._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );\n\n\t\t} else { // Equirectangular\n\n\t\t\tthis._setSize( texture.image.width / 4 );\n\n\t\t}\n\n\t}\n\n\t_setSize( cubeSize ) {\n\n\t\tthis._lodMax = Math.floor( Math.log2( cubeSize ) );\n\t\tthis._cubeSize = Math.pow( 2, this._lodMax );\n\n\t}\n\n\t_dispose() {\n\n\t\tif ( this._blurMaterial !== null ) this._blurMaterial.dispose();\n\n\t\tif ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();\n\n\t\tfor ( let i = 0; i < this._lodPlanes.length; i ++ ) {\n\n\t\t\tthis._lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture, renderTarget ) {\n\n\t\tthis._setSizeFromTexture( texture );\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets() {\n\n\t\tconst width = 3 * Math.max( this._cubeSize, 16 * 7 );\n\t\tconst height = 4 * this._cubeSize;\n\n\t\tconst params = {\n\t\t\tmagFilter: LinearFilter,\n\t\t\tminFilter: LinearFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: HalfFloatType,\n\t\t\tformat: RGBAFormat,\n\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\t//depthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( width, height, params );\n\n\t\tif ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {\n\n\t\t\tif ( this._pingPongRenderTarget !== null ) {\n\n\t\t\t\tthis._dispose();\n\n\t\t\t}\n\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget( width, height, params );\n\n\t\t\tconst { _lodMax } = this;\n\t\t\t( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes( _lodMax ) );\n\n\t\t\tthis._blurMaterial = _getBlurShader( _lodMax, width, height );\n\n\t\t}\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\tasync _compileMaterial( material ) {\n\n\t\tconst tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );\n\t\tawait this._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\t\tconst cubeCamera = _cubeCamera;\n\t\tcubeCamera.near = near;\n\t\tcubeCamera.far = far;\n\n\t\t// px, py, pz, nx, ny, nz\n\t\tconst upSign = [ - 1, 1, - 1, - 1, - 1, - 1 ];\n\t\tconst forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.autoClear = false;\n\n\t\tlet backgroundBox = this._backgroundBox;\n\n\t\tif ( backgroundBox === null ) {\n\n\t\t\tconst backgroundMaterial = new MeshBasicMaterial( {\n\t\t\t\tname: 'PMREM.Background',\n\t\t\t\tside: BackSide,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tdepthTest: false\n\t\t\t} );\n\n\t\t\tbackgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );\n\n\t\t}\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundBox.material.color.copy( background );\n\t\t\t\tscene.background = null;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundBox.material.color.copy( _clearColor );\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\trenderer.clear();\n\n\t\tif ( useSolidColor ) {\n\n\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\n\t\t\tif ( col === 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t\t} else if ( col === 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\tconst size = this._cubeSize;\n\n\t\t\t_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\trenderer.autoClear = originalAutoClear;\n\t\tscene.background = background;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );\n\n\t\tif ( isCubeTexture ) {\n\n\t\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\t\tthis._cubemapMaterial = _getCubemapMaterial( texture );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\t\tthis._equirectMaterial = _getEquirectMaterial( texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n\t\tmaterial.fragmentNode.value = texture;\n\n\t\tconst mesh = this._lodMeshes[ 0 ];\n\t\tmesh.material = material;\n\n\t\tconst size = this._cubeSize;\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\t\tconst n = this._lodPlanes.length;\n\n\t\tfor ( let i = 1; i < n; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error( 'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = this._lodMeshes[ lodOut ];\n\t\tblurMesh.material = blurMaterial;\n\n\t\tconst blurUniforms = blurMaterial.uniforms;\n\n\t\tconst pixels = this._sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\ttargetIn.texture.frame = ( targetIn.texture.frame || 0 ) + 1;\n\n\t\tblurUniforms.envMap.value = targetIn.texture;\n\t\tblurUniforms.samples.value = samples;\n\t\tblurUniforms.weights.array = weights;\n\t\tblurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms.poleAxis.value = poleAxis;\n\n\t\t}\n\n\t\tconst { _lodMax } = this;\n\t\tblurUniforms.dTheta.value = radiansPerPixel;\n\t\tblurUniforms.mipInt.value = _lodMax - lodIn;\n\n\t\tconst outputSize = this._sizeLods[ lodOut ];\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\nfunction _createPlanes( lodMax ) {\n\n\tconst lodPlanes = [];\n\tconst sizeLods = [];\n\tconst sigmas = [];\n\tconst lodMeshes = [];\n\n\tlet lod = lodMax;\n\n\tconst totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n\tfor ( let i = 0; i < totalLods; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\tsizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > lodMax - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];\n\n\t\t} else if ( i === 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\tsigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 2 );\n\t\tconst min = - texelSize;\n\t\tconst max = 1 + texelSize;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\n\t\t\tconst faceIdx = _faceLib[ face ];\n\t\t\tposition.set( coordinates, positionSize * vertices * faceIdx );\n\t\t\tuv.set( uv1, uvSize * vertices * faceIdx );\n\t\t\tconst fill = [ faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * faceIdx );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\tlodPlanes.push( planes );\n\t\tlodMeshes.push( new Mesh( planes, null ) );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { lodPlanes, sizeLods, sigmas, lodMeshes };\n\n}\n\nfunction _createRenderTarget( width, height, params ) {\n\n\tconst cubeUVRenderTarget = new RenderTarget( width, height, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.texture.isPMREMTexture = true;\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getMaterial( type ) {\n\n\tconst material = new NodeMaterial();\n\tmaterial.depthTest = false;\n\tmaterial.depthWrite = false;\n\tmaterial.blending = NoBlending;\n\tmaterial.name = `PMREM_${ type }`;\n\n\treturn material;\n\n}\n\nfunction _getBlurShader( lodMax, width, height ) {\n\n\tconst weights = uniformArray( new Array( MAX_SAMPLES ).fill( 0 ) );\n\tconst poleAxis = uniform( new Vector3( 0, 1, 0 ) );\n\tconst dTheta = uniform( 0 );\n\tconst n = float( MAX_SAMPLES );\n\tconst latitudinal = uniform( 0 ); // false, bool\n\tconst samples = uniform( 1 ); // int\n\tconst envMap = texture( null );\n\tconst mipInt = uniform( 0 ); // int\n\tconst CUBEUV_TEXEL_WIDTH = float( 1 / width );\n\tconst CUBEUV_TEXEL_HEIGHT = float( 1 / height );\n\tconst CUBEUV_MAX_MIP = float( lodMax );\n\n\tconst materialUniforms = {\n\t\tn,\n\t\tlatitudinal,\n\t\tweights,\n\t\tpoleAxis,\n\t\toutputDirection,\n\t\tdTheta,\n\t\tsamples,\n\t\tenvMap,\n\t\tmipInt,\n\t\tCUBEUV_TEXEL_WIDTH,\n\t\tCUBEUV_TEXEL_HEIGHT,\n\t\tCUBEUV_MAX_MIP\n\t};\n\n\tconst material = _getMaterial( 'blur' );\n\tmaterial.uniforms = materialUniforms; // TODO: Move to outside of the material\n\tmaterial.fragmentNode = blur( { ...materialUniforms, latitudinal: latitudinal.equal( 1 ) } );\n\n\treturn material;\n\n}\n\nfunction _getCubemapMaterial( envTexture ) {\n\n\tconst material = _getMaterial( 'cubemap' );\n\tmaterial.fragmentNode = cubeTexture( envTexture, outputDirection );\n\n\treturn material;\n\n}\n\nfunction _getEquirectMaterial( envTexture ) {\n\n\tconst material = _getMaterial( 'equirect' );\n\tmaterial.fragmentNode = texture( envTexture, equirectUV( outputDirection ), 0 );\n\n\treturn material;\n\n}\n\nconst rendererCache = new WeakMap();\n\nconst typeFromArray = new Map( [\n\t[ Int8Array, 'int' ],\n\t[ Int16Array, 'int' ],\n\t[ Int32Array, 'int' ],\n\t[ Uint8Array, 'uint' ],\n\t[ Uint16Array, 'uint' ],\n\t[ Uint32Array, 'uint' ],\n\t[ Float32Array, 'float' ]\n] );\n\nconst toFloat = ( value ) => {\n\n\tif ( /e/g.test( value ) ) {\n\n\t\treturn String( value ).replace( /\\+/g, '' );\n\n\t} else {\n\n\t\tvalue = Number( value );\n\n\t\treturn value + ( value % 1 ? '' : '.0' );\n\n\t}\n\n};\n\nclass NodeBuilder {\n\n\tconstructor( object, renderer, parser ) {\n\n\t\tthis.object = object;\n\t\tthis.material = ( object && object.material ) || null;\n\t\tthis.geometry = ( object && object.geometry ) || null;\n\t\tthis.renderer = renderer;\n\t\tthis.parser = parser;\n\t\tthis.scene = null;\n\t\tthis.camera = null;\n\n\t\tthis.nodes = [];\n\t\tthis.sequentialNodes = [];\n\t\tthis.updateNodes = [];\n\t\tthis.updateBeforeNodes = [];\n\t\tthis.updateAfterNodes = [];\n\t\tthis.hashNodes = {};\n\n\t\tthis.monitor = null;\n\n\t\tthis.lightsNode = null;\n\t\tthis.environmentNode = null;\n\t\tthis.fogNode = null;\n\n\t\tthis.clippingContext = null;\n\n\t\tthis.vertexShader = null;\n\t\tthis.fragmentShader = null;\n\t\tthis.computeShader = null;\n\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: '' };\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.structs = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.bindings = { vertex: {}, fragment: {}, compute: {} };\n\t\tthis.bindingsIndexes = {};\n\t\tthis.bindGroups = null;\n\t\tthis.attributes = [];\n\t\tthis.bufferAttributes = [];\n\t\tthis.varyings = [];\n\t\tthis.codes = {};\n\t\tthis.vars = {};\n\t\tthis.flow = { code: '' };\n\t\tthis.chaining = [];\n\t\tthis.stack = stack();\n\t\tthis.stacks = [];\n\t\tthis.tab = '\\t';\n\n\t\tthis.currentFunctionNode = null;\n\n\t\tthis.context = {\n\t\t\tmaterial: this.material\n\t\t};\n\n\t\tthis.cache = new NodeCache();\n\t\tthis.globalCache = this.cache;\n\n\t\tthis.flowsData = new WeakMap();\n\n\t\tthis.shaderStage = null;\n\t\tthis.buildStage = null;\n\n\t\tthis.useComparisonMethod = false;\n\n\t}\n\n\tgetBindGroupsCache() {\n\n\t\tlet bindGroupsCache = rendererCache.get( this.renderer );\n\n\t\tif ( bindGroupsCache === undefined ) {\n\n\t\t\tbindGroupsCache = new ChainMap();\n\n\t\t\trendererCache.set( this.renderer, bindGroupsCache );\n\n\t\t}\n\n\t\treturn bindGroupsCache;\n\n\t}\n\n\tcreateRenderTarget( width, height, options ) {\n\n\t\treturn new RenderTarget( width, height, options );\n\n\t}\n\n\tcreateCubeRenderTarget( size, options ) {\n\n\t\treturn new CubeRenderTarget( size, options );\n\n\t}\n\n\tcreatePMREMGenerator() {\n\n\t\t// TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support\n\n\t\treturn new PMREMGenerator( this.renderer );\n\n\t}\n\n\tincludes( node ) {\n\n\t\treturn this.nodes.includes( node );\n\n\t}\n\n\t_getBindGroup( groupName, bindings ) {\n\n\t\tconst bindGroupsCache = this.getBindGroupsCache();\n\n\t\t//\n\n\t\tconst bindingsArray = [];\n\n\t\tlet sharedGroup = true;\n\n\t\tfor ( const binding of bindings ) {\n\n\t\t\tbindingsArray.push( binding );\n\n\t\t\tsharedGroup = sharedGroup && binding.groupNode.shared !== true;\n\n\t\t}\n\n\t\t//\n\n\t\tlet bindGroup;\n\n\t\tif ( sharedGroup ) {\n\n\t\t\tbindGroup = bindGroupsCache.get( bindingsArray );\n\n\t\t\tif ( bindGroup === undefined ) {\n\n\t\t\t\tbindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );\n\n\t\t\t\tbindGroupsCache.set( bindingsArray, bindGroup );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );\n\n\t\t}\n\n\t\treturn bindGroup;\n\n\t}\n\n\tgetBindGroupArray( groupName, shaderStage ) {\n\n\t\tconst bindings = this.bindings[ shaderStage ];\n\n\t\tlet bindGroup = bindings[ groupName ];\n\n\t\tif ( bindGroup === undefined ) {\n\n\t\t\tif ( this.bindingsIndexes[ groupName ] === undefined ) {\n\n\t\t\t\tthis.bindingsIndexes[ groupName ] = { binding: 0, group: Object.keys( this.bindingsIndexes ).length };\n\n\t\t\t}\n\n\t\t\tbindings[ groupName ] = bindGroup = [];\n\n\t\t}\n\n\t\treturn bindGroup;\n\n\t}\n\n\tgetBindings() {\n\n\t\tlet bindingsGroups = this.bindGroups;\n\n\t\tif ( bindingsGroups === null ) {\n\n\t\t\tconst groups = {};\n\t\t\tconst bindings = this.bindings;\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tfor ( const groupName in bindings[ shaderStage ] ) {\n\n\t\t\t\t\tconst uniforms = bindings[ shaderStage ][ groupName ];\n\n\t\t\t\t\tconst groupUniforms = groups[ groupName ] || ( groups[ groupName ] = [] );\n\t\t\t\t\tgroupUniforms.push( ...uniforms );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingsGroups = [];\n\n\t\t\tfor ( const groupName in groups ) {\n\n\t\t\t\tconst group = groups[ groupName ];\n\n\t\t\t\tconst bindingsGroup = this._getBindGroup( groupName, group );\n\n\t\t\t\tbindingsGroups.push( bindingsGroup );\n\n\t\t\t}\n\n\t\t\tthis.bindGroups = bindingsGroups;\n\n\t\t}\n\n\t\treturn bindingsGroups;\n\n\t}\n\n\tsortBindingGroups() {\n\n\t\tconst bindingsGroups = this.getBindings();\n\n\t\tbindingsGroups.sort( ( a, b ) => ( a.bindings[ 0 ].groupNode.order - b.bindings[ 0 ].groupNode.order ) );\n\n\t\tfor ( let i = 0; i < bindingsGroups.length; i ++ ) {\n\n\t\t\tconst bindingGroup = bindingsGroups[ i ];\n\t\t\tthis.bindingsIndexes[ bindingGroup.name ].group = i;\n\n\t\t\tbindingGroup.index = i;\n\n\t\t}\n\n\t}\n\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\taddNode( node ) {\n\n\t\tif ( this.nodes.includes( node ) === false ) {\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\taddSequentialNode( node ) {\n\n\t\tif ( this.sequentialNodes.includes( node ) === false ) {\n\n\t\t\tthis.sequentialNodes.push( node );\n\n\t\t}\n\n\t}\n\n\tbuildUpdateNodes() {\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tconst updateType = node.getUpdateType();\n\n\t\t\tif ( updateType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const node of this.sequentialNodes ) {\n\n\t\t\tconst updateBeforeType = node.getUpdateBeforeType();\n\t\t\tconst updateAfterType = node.getUpdateAfterType();\n\n\t\t\tif ( updateBeforeType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateBeforeNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t\tif ( updateAfterType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateAfterNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tget currentNode() {\n\n\t\treturn this.chaining[ this.chaining.length - 1 ];\n\n\t}\n\n\tisFilteredTexture( texture ) {\n\n\t\treturn ( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||\n\t\t\ttexture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter );\n\n\t}\n\n\taddChain( node ) {\n\n\t\t/*\n\t\tif ( this.chaining.indexOf( node ) !== - 1 ) {\n\n\t\t\tconsole.warn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.chaining.push( node );\n\n\t}\n\n\tremoveChain( node ) {\n\n\t\tconst lastChain = this.chaining.pop();\n\n\t\tif ( lastChain !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node chaining!' );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\tgetSharedContext() {\n\n\t\t({ ...this.context });\n\n\t\treturn this.context;\n\n\t}\n\n\tsetCache( cache ) {\n\n\t\tthis.cache = cache;\n\n\t}\n\n\tgetCache() {\n\n\t\treturn this.cache;\n\n\t}\n\n\tgetCacheFromNode( node, parent = true ) {\n\n\t\tconst data = this.getDataFromNode( node );\n\t\tif ( data.cache === undefined ) data.cache = new NodeCache( parent ? this.getCache() : null );\n\n\t\treturn data.cache;\n\n\t}\n\n\tisAvailable( /*name*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetDrawIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFragCoord() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\tincreaseUsage( node ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\t\tnodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;\n\n\t\treturn nodeData.usageCount;\n\n\t}\n\n\tgenerateTexture( /* texture, textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgenerateTextureLod( /* texture, textureProperty, uvSnippet, levelSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgenerateConst( type, value = null ) {\n\n\t\tif ( value === null ) {\n\n\t\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;\n\t\t\telse if ( type === 'bool' ) value = false;\n\t\t\telse if ( type === 'color' ) value = new Color();\n\t\t\telse if ( type === 'vec2' ) value = new Vector2();\n\t\t\telse if ( type === 'vec3' ) value = new Vector3();\n\t\t\telse if ( type === 'vec4' ) value = new Vector4();\n\n\t\t}\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst generateConst = value => this.generateConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) }, ${ generateConst( value.w ) } )`;\n\n\t\t} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ value.elements.map( generateConst ).join( ', ' ) } )`;\n\n\t\t} else if ( typeLength > 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }()`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\tgetType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\n\t\treturn type;\n\n\t}\n\n\thasGeometryAttribute( name ) {\n\n\t\treturn this.geometry && this.geometry.getAttribute( name ) !== undefined;\n\n\t}\n\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';\n\n\t}\n\n\tneedsToWorkingColorSpace( /*texture*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetComponentTypeFromTexture( texture ) {\n\n\t\tconst type = texture.type;\n\n\t\tif ( texture.isDataTexture ) {\n\n\t\t\tif ( type === IntType ) return 'int';\n\t\t\tif ( type === UnsignedIntType ) return 'uint';\n\n\t\t}\n\n\t\treturn 'float';\n\n\t}\n\n\tgetElementType( type ) {\n\n\t\tif ( type === 'mat2' ) return 'vec2';\n\t\tif ( type === 'mat3' ) return 'vec3';\n\t\tif ( type === 'mat4' ) return 'vec4';\n\n\t\treturn this.getComponentType( type );\n\n\t}\n\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tif ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\tgetTypeFromLength( length, componentType = 'float' ) {\n\n\t\tif ( length === 1 ) return componentType;\n\n\t\tconst baseType = getTypeFromLength( length );\n\t\tconst prefix = componentType === 'float' ? '' : componentType[ 0 ];\n\n\t\treturn prefix + baseType;\n\n\t}\n\n\tgetTypeFromArray( array ) {\n\n\t\treturn typeFromArray.get( array.constructor );\n\n\t}\n\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet dataAttribute = attribute;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\tconst array = dataAttribute.array;\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst normalized = attribute.normalized;\n\n\t\tlet arrayType;\n\n\t\tif ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {\n\n\t\t\tarrayType = this.getTypeFromArray( array );\n\n\t\t}\n\n\t\treturn this.getTypeFromLength( itemSize, arrayType );\n\n\t}\n\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\t\tif ( /mat2/.test( type ) === true ) return 4;\n\t\tif ( /mat3/.test( type ) === true ) return 9;\n\t\tif ( /mat4/.test( type ) === true ) return 16;\n\n\t\treturn 0;\n\n\t}\n\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\tchangeComponentType( type, newComponentType ) {\n\n\t\treturn this.getTypeFromLength( this.getTypeLength( type ), newComponentType );\n\n\t}\n\n\tgetIntegerType( type ) {\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tif ( componentType === 'int' || componentType === 'uint' ) return type;\n\n\t\treturn this.changeComponentType( type, 'int' );\n\n\t}\n\n\taddStack() {\n\n\t\tthis.stack = stack( this.stack );\n\n\t\tthis.stacks.push( getCurrentStack() || this.stack );\n\t\tsetCurrentStack( this.stack );\n\n\t\treturn this.stack;\n\n\t}\n\n\tremoveStack() {\n\n\t\tconst lastStack = this.stack;\n\t\tthis.stack = lastStack.parent;\n\n\t\tsetCurrentStack( this.stacks.pop() );\n\n\t\treturn lastStack;\n\n\t}\n\n\tgetDataFromNode( node, shaderStage = this.shaderStage, cache = null ) {\n\n\t\tcache = cache === null ? ( node.isGlobal( this ) ? this.globalCache : this.cache ) : cache;\n\n\t\tlet nodeData = cache.getData( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = {};\n\n\t\t\tcache.setData( node, nodeData );\n\n\t\t}\n\n\t\tif ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};\n\n\t\treturn nodeData[ shaderStage ];\n\n\t}\n\n\tgetNodeProperties( node, shaderStage = 'any' ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\treturn nodeData.properties || ( nodeData.properties = { outputNode: null } );\n\n\t}\n\n\tgetBufferAttributeFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet bufferAttribute = nodeData.bufferAttribute;\n\n\t\tif ( bufferAttribute === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tbufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );\n\n\t\t\tthis.bufferAttributes.push( bufferAttribute );\n\n\t\t\tnodeData.bufferAttribute = bufferAttribute;\n\n\t\t}\n\n\t\treturn bufferAttribute;\n\n\t}\n\n\tgetStructTypeFromNode( node, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tif ( nodeData.structType === undefined ) {\n\n\t\t\tconst index = this.structs.index ++;\n\n\t\t\tnode.name = `StructType${ index }`;\n\t\t\tthis.structs[ shaderStage ].push( node );\n\n\t\t\tnodeData.structType = node;\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\tgetVarFromNode( node, name = null, type = node.getNodeType( this ), shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeVar = nodeData.variable;\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst vars = this.vars[ shaderStage ] || ( this.vars[ shaderStage ] = [] );\n\n\t\t\tif ( name === null ) name = 'nodeVar' + vars.length;\n\n\t\t\tnodeVar = new NodeVar( name, type );\n\n\t\t\tvars.push( nodeVar );\n\n\t\t\tnodeData.variable = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\tgetVaryingFromNode( node, name = null, type = node.getNodeType( this ) ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, 'any' );\n\n\t\tlet nodeVarying = nodeData.varying;\n\n\t\tif ( nodeVarying === undefined ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst index = varyings.length;\n\n\t\t\tif ( name === null ) name = 'nodeVarying' + index;\n\n\t\t\tnodeVarying = new NodeVarying( name, type );\n\n\t\t\tvaryings.push( nodeVarying );\n\n\t\t\tnodeData.varying = nodeVarying;\n\n\t\t}\n\n\t\treturn nodeVarying;\n\n\t}\n\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ] || ( this.codes[ shaderStage ] = [] );\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\taddFlowCodeHierarchy( node, nodeBlock ) {\n\n\t\tconst { flowCodes, flowCodeBlock } = this.getDataFromNode( node );\n\n\t\tlet needsFlowCode = true;\n\t\tlet nodeBlockHierarchy = nodeBlock;\n\n\t\twhile ( nodeBlockHierarchy ) {\n\n\t\t\tif ( flowCodeBlock.get( nodeBlockHierarchy ) === true ) {\n\n\t\t\t\tneedsFlowCode = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tnodeBlockHierarchy = this.getDataFromNode( nodeBlockHierarchy ).parentNodeBlock;\n\n\t\t}\n\n\t\tif ( needsFlowCode ) {\n\n\t\t\tfor ( const flowCode of flowCodes ) {\n\n\t\t\t\tthis.addLineFlowCode( flowCode );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\taddLineFlowCodeBlock( node, code, nodeBlock ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\t\tconst flowCodes = nodeData.flowCodes || ( nodeData.flowCodes = [] );\n\t\tconst codeBlock = nodeData.flowCodeBlock || ( nodeData.flowCodeBlock = new WeakMap() );\n\n\t\tflowCodes.push( code );\n\t\tcodeBlock.set( nodeBlock, true );\n\n\t}\n\n\taddLineFlowCode( code, node = null ) {\n\n\t\tif ( code === '' ) return this;\n\n\t\tif ( node !== null && this.context.nodeBlock ) {\n\n\t\t\tthis.addLineFlowCodeBlock( node, code, this.context.nodeBlock );\n\n\t\t}\n\n\t\tcode = this.tab + code;\n\n\t\tif ( ! /;\\s*$/.test( code ) ) {\n\n\t\t\tcode = code + ';\\n';\n\n\t\t}\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\taddFlowTab() {\n\n\t\tthis.tab += '\\t';\n\n\t\treturn this;\n\n\t}\n\n\tremoveFlowTab() {\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\n\t\treturn this;\n\n\t}\n\n\tgetFlowData( node/*, shaderStage*/ ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\tflowNode( node ) {\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\treturn flowData;\n\n\t}\n\n\tbuildFunctionNode( shaderNode ) {\n\n\t\tconst fn = new FunctionNode();\n\n\t\tconst previous = this.currentFunctionNode;\n\n\t\tthis.currentFunctionNode = fn;\n\n\t\tfn.code = this.buildFunctionCode( shaderNode );\n\n\t\tthis.currentFunctionNode = previous;\n\n\t\treturn fn;\n\n\t}\n\n\tflowShaderNode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\n\t\tconst inputs = {\n\t\t\t[ Symbol.iterator ]() {\n\n\t\t\t\tlet index = 0;\n\t\t\t\tconst values = Object.values( this );\n\t\t\t\treturn {\n\t\t\t\t\tnext: () => ( {\n\t\t\t\t\t\tvalue: values[ index ],\n\t\t\t\t\t\tdone: index ++ >= values.length\n\t\t\t\t\t} )\n\t\t\t\t};\n\n\t\t\t}\n\t\t};\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tinputs[ input.name ] = new ParameterNode( input.type, input.name );\n\n\t\t}\n\n\t\t//\n\n\t\tshaderNode.layout = null;\n\n\t\tconst callNode = shaderNode.call( inputs );\n\t\tconst flowData = this.flowStagesNode( callNode, layout.type );\n\n\t\tshaderNode.layout = layout;\n\n\t\treturn flowData;\n\n\t}\n\n\tflowStagesNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\t\tconst previousVars = this.vars;\n\t\tconst previousCache = this.cache;\n\t\tconst previousBuildStage = this.buildStage;\n\t\tconst previousStack = this.stack;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\t\tthis.vars = {};\n\t\tthis.cache = new NodeCache();\n\t\tthis.stack = stack();\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tflow.result = node.build( this, output );\n\n\t\t}\n\n\t\tflow.vars = this.getVars( this.shaderStage );\n\n\t\tthis.flow = previousFlow;\n\t\tthis.vars = previousVars;\n\t\tthis.cache = previousCache;\n\t\tthis.stack = previousStack;\n\n\t\tthis.setBuildStage( previousBuildStage );\n\n\t\treturn flow;\n\n\t}\n\n\tgetFunctionOperator() {\n\n\t\treturn null;\n\n\t}\n\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousShaderStage = this.shaderStage;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tif ( propertyName !== null ) {\n\n\t\t\tflowData.code += `${ this.tab + propertyName } = ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\treturn flowData;\n\n\t}\n\n\tgetAttributesArray() {\n\n\t\treturn this.attributes.concat( this.bufferAttributes );\n\n\t}\n\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVaryings( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVar( type, name ) {\n\n\t\treturn `${ this.getType( type ) } ${ name }`;\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippet += `${ this.getVar( variable.type, variable.name ) }; `;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tif ( codes !== undefined ) {\n\n\t\t\tfor ( const nodeCode of codes ) {\n\n\t\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\n\n\t}\n\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\tsetBuildStage( buildStage ) {\n\n\t\tthis.buildStage = buildStage;\n\n\t}\n\n\tgetBuildStage() {\n\n\t\treturn this.buildStage;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tbuild() {\n\n\t\tconst { object, material, renderer } = this;\n\n\t\tif ( material !== null ) {\n\n\t\t\tlet nodeMaterial = renderer.library.fromMaterial( material );\n\n\t\t\tif ( nodeMaterial === null ) {\n\n\t\t\t\tconsole.error( `NodeMaterial: Material \"${ material.type }\" is not compatible.` );\n\n\t\t\t\tnodeMaterial = new NodeMaterial();\n\n\t\t\t}\n\n\t\t\tnodeMaterial.build( this );\n\n\t\t} else {\n\n\t\t\tthis.addFlow( 'compute', object );\n\n\t\t}\n\n\t\t// setup() -> stage 1: create possible new nodes and returns an output reference node\n\t\t// analyze()   -> stage 2: analyze nodes to possible optimization and validation\n\t\t// generate()  -> stage 3: generate shader\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t\t}\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\t\tif ( buildStage === 'generate' ) {\n\n\t\t\t\t\t\tthis.flowNode( node );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode.build( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setBuildStage( null );\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 4: build code for a specific output\n\n\t\tthis.buildCode();\n\t\tthis.buildUpdateNodes();\n\n\t\treturn this;\n\n\t}\n\n\tgetNodeUniform( uniformNode, type ) {\n\n\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) return new NumberNodeUniform( uniformNode );\n\t\tif ( type === 'vec2' || type === 'ivec2' || type === 'uvec2' ) return new Vector2NodeUniform( uniformNode );\n\t\tif ( type === 'vec3' || type === 'ivec3' || type === 'uvec3' ) return new Vector3NodeUniform( uniformNode );\n\t\tif ( type === 'vec4' || type === 'ivec4' || type === 'uvec4' ) return new Vector4NodeUniform( uniformNode );\n\t\tif ( type === 'color' ) return new ColorNodeUniform( uniformNode );\n\t\tif ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );\n\t\tif ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );\n\n\t\tthrow new Error( `Uniform \"${type}\" not declared.` );\n\n\t}\n\n\tcreateNodeMaterial( type = 'NodeMaterial' ) { // @deprecated, r168\n\n\t\tthrow new Error( `THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${ type }() instead.` );\n\n\t}\n\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength === 16 && toTypeLength === 9 ) {\n\n\t\t\treturn `${ this.getType( toType ) }(${ snippet }[0].xyz, ${ snippet }[1].xyz, ${ snippet }[2].xyz)`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 9 && toTypeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( toType ) }(${ snippet }[0].xy, ${ snippet }[1].xy)`;\n\n\t\t}\n\n\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 && fromTypeLength > 1 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType( toType ) ) { // fromType is float-like\n\n\t\t\t// convert a number value to vector type, e.g:\n\t\t\t// vec3( 1u ) -> vec3( float( 1u ) )\n\n\t\t\tsnippet = `${ this.getType( this.getComponentType( toType ) ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - Node System\\n`;\n\n\t}\n\n}\n\nclass NodeFrame {\n\n\tconstructor() {\n\n\t\tthis.time = 0;\n\t\tthis.deltaTime = 0;\n\n\t\tthis.frameId = 0;\n\t\tthis.renderId = 0;\n\n\t\tthis.startTime = null;\n\n\t\tthis.updateMap = new WeakMap();\n\t\tthis.updateBeforeMap = new WeakMap();\n\t\tthis.updateAfterMap = new WeakMap();\n\n\t\tthis.renderer = null;\n\t\tthis.material = null;\n\t\tthis.camera = null;\n\t\tthis.object = null;\n\t\tthis.scene = null;\n\n\t}\n\n\t_getMaps( referenceMap, nodeRef ) {\n\n\t\tlet maps = referenceMap.get( nodeRef );\n\n\t\tif ( maps === undefined ) {\n\n\t\t\tmaps = {\n\t\t\t\trenderMap: new WeakMap(),\n\t\t\t\tframeMap: new WeakMap()\n\t\t\t};\n\n\t\t\treferenceMap.set( nodeRef, maps );\n\n\t\t}\n\n\t\treturn maps;\n\n\t}\n\n\tupdateBeforeNode( node ) {\n\n\t\tconst updateType = node.getUpdateBeforeType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateBeforeMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.updateBefore( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateBeforeMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.updateBefore( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.updateBefore( this );\n\n\t\t}\n\n\t}\n\n\tupdateAfterNode( node ) {\n\n\t\tconst updateType = node.getUpdateAfterType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateAfterMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.updateAfter( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateAfterMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.updateAfter( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.updateAfter( this );\n\n\t\t}\n\n\t}\n\n\tupdateNode( node ) {\n\n\t\tconst updateType = node.getUpdateType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.update( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.update( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.update( this );\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tthis.frameId ++;\n\n\t\tif ( this.lastTime === undefined ) this.lastTime = performance.now();\n\n\t\tthis.deltaTime = ( performance.now() - this.lastTime ) / 1000;\n\n\t\tthis.lastTime = performance.now();\n\n\t\tthis.time += this.deltaTime;\n\n\t}\n\n}\n\nclass NodeFunctionInput {\n\n\tconstructor( type, name, count = null, qualifier = '', isConst = false ) {\n\n\t\tthis.type = type;\n\t\tthis.name = name;\n\t\tthis.count = count;\n\t\tthis.qualifier = qualifier;\n\t\tthis.isConst = isConst;\n\n\t}\n\n}\n\nNodeFunctionInput.isNodeFunctionInput = true;\n\nclass DirectionalLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'DirectionalLightNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst lightingModel = builder.context.lightingModel;\n\n\t\tconst lightColor = this.colorNode;\n\t\tconst lightDirection = lightTargetDirection( this.light );\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tlightingModel.direct( {\n\t\t\tlightDirection,\n\t\t\tlightColor,\n\t\t\treflectedLight\n\t\t}, builder.stack, builder );\n\n\t}\n\n}\n\nconst _matrix41 = /*@__PURE__*/ new Matrix4();\nconst _matrix42 = /*@__PURE__*/ new Matrix4();\n\nlet ltcLib = null;\n\nclass RectAreaLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'RectAreaLightNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tthis.halfHeight = uniform( new Vector3() ).setGroup( renderGroup );\n\t\tthis.halfWidth = uniform( new Vector3() ).setGroup( renderGroup );\n\n\t\tthis.updateType = NodeUpdateType.RENDER;\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tsuper.update( frame );\n\n\t\tconst { light } = this;\n\n\t\tconst viewMatrix = frame.camera.matrixWorldInverse;\n\n\t\t_matrix42.identity();\n\t\t_matrix41.copy( light.matrixWorld );\n\t\t_matrix41.premultiply( viewMatrix );\n\t\t_matrix42.extractRotation( _matrix41 );\n\n\t\tthis.halfWidth.value.set( light.width * 0.5, 0.0, 0.0 );\n\t\tthis.halfHeight.value.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\tthis.halfWidth.value.applyMatrix4( _matrix42 );\n\t\tthis.halfHeight.value.applyMatrix4( _matrix42 );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tlet ltc_1, ltc_2;\n\n\t\tif ( builder.isAvailable( 'float32Filterable' ) ) {\n\n\t\t\tltc_1 = texture( ltcLib.LTC_FLOAT_1 );\n\t\t\tltc_2 = texture( ltcLib.LTC_FLOAT_2 );\n\n\t\t} else {\n\n\t\t\tltc_1 = texture( ltcLib.LTC_HALF_1 );\n\t\t\tltc_2 = texture( ltcLib.LTC_HALF_2 );\n\n\t\t}\n\n\t\tconst { colorNode, light } = this;\n\t\tconst lightingModel = builder.context.lightingModel;\n\n\t\tconst lightPosition = lightViewPosition( light );\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tlightingModel.directRectArea( {\n\t\t\tlightColor: colorNode,\n\t\t\tlightPosition,\n\t\t\thalfWidth: this.halfWidth,\n\t\t\thalfHeight: this.halfHeight,\n\t\t\treflectedLight,\n\t\t\tltc_1,\n\t\t\tltc_2\n\t\t}, builder.stack, builder );\n\n\t}\n\n\tstatic setLTC( ltc ) {\n\n\t\tltcLib = ltc;\n\n\t}\n\n}\n\nclass SpotLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'SpotLightNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tthis.coneCosNode = uniform( 0 ).setGroup( renderGroup );\n\t\tthis.penumbraCosNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\tthis.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );\n\t\tthis.decayExponentNode = uniform( 0 ).setGroup( renderGroup );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tsuper.update( frame );\n\n\t\tconst { light } = this;\n\n\t\tthis.coneCosNode.value = Math.cos( light.angle );\n\t\tthis.penumbraCosNode.value = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\n\t\tthis.cutoffDistanceNode.value = light.distance;\n\t\tthis.decayExponentNode.value = light.decay;\n\n\t}\n\n\tgetSpotAttenuation( angleCosine ) {\n\n\t\tconst { coneCosNode, penumbraCosNode } = this;\n\n\t\treturn smoothstep( coneCosNode, penumbraCosNode, angleCosine );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst lightingModel = builder.context.lightingModel;\n\n\t\tconst { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;\n\n\t\tconst lVector = lightViewPosition( light ).sub( positionView ); // @TODO: Add it into LightNode\n\n\t\tconst lightDirection = lVector.normalize();\n\t\tconst angleCos = lightDirection.dot( lightTargetDirection( light ) );\n\t\tconst spotAttenuation = this.getSpotAttenuation( angleCos );\n\n\t\tconst lightDistance = lVector.length();\n\n\t\tconst lightAttenuation = getDistanceAttenuation( {\n\t\t\tlightDistance,\n\t\t\tcutoffDistance: cutoffDistanceNode,\n\t\t\tdecayExponent: decayExponentNode\n\t\t} );\n\n\t\tlet lightColor = colorNode.mul( spotAttenuation ).mul( lightAttenuation );\n\n\t\tif ( light.map ) {\n\n\t\t\tconst spotLightCoord = lightProjectionUV( light );\n\t\t\tconst projectedTexture = texture( light.map, spotLightCoord.xy ).onRenderUpdate( () => light.map );\n\n\t\t\tconst inSpotLightMap = spotLightCoord.mul( 2. ).sub( 1. ).abs().lessThan( 1. ).all();\n\n\t\t\tlightColor = inSpotLightMap.select( lightColor.mul( projectedTexture ), lightColor );\n\n\t\t}\n\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tlightingModel.direct( {\n\t\t\tlightDirection,\n\t\t\tlightColor,\n\t\t\treflectedLight\n\t\t}, builder.stack, builder );\n\n\t}\n\n}\n\nclass IESSpotLightNode extends SpotLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'IESSpotLightNode';\n\n\t}\n\n\tgetSpotAttenuation( angleCosine ) {\n\n\t\tconst iesMap = this.light.iesMap;\n\n\t\tlet spotAttenuation = null;\n\n\t\tif ( iesMap && iesMap.isTexture === true ) {\n\n\t\t\tconst angle = angleCosine.acos().mul( 1.0 / Math.PI );\n\n\t\t\tspotAttenuation = texture( iesMap, vec2( angle, 0 ), 0 ).r;\n\n\t\t} else {\n\n\t\t\tspotAttenuation = super.getSpotAttenuation( angleCosine );\n\n\t\t}\n\n\t\treturn spotAttenuation;\n\n\t}\n\n}\n\nclass AmbientLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'AmbientLightNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t}\n\n\tsetup( { context } ) {\n\n\t\tcontext.irradiance.addAssign( this.colorNode );\n\n\t}\n\n}\n\nclass HemisphereLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'HemisphereLightNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tthis.lightPositionNode = lightPosition( light );\n\t\tthis.lightDirectionNode = this.lightPositionNode.normalize();\n\n\t\tthis.groundColorNode = uniform( new Color() ).setGroup( renderGroup );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\tthis.lightPositionNode.object3d = light;\n\n\t\tthis.groundColorNode.value.copy( light.groundColor ).multiplyScalar( light.intensity );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { colorNode, groundColorNode, lightDirectionNode } = this;\n\n\t\tconst dotNL = normalView.dot( lightDirectionNode );\n\t\tconst hemiDiffuseWeight = dotNL.mul( 0.5 ).add( 0.5 );\n\n\t\tconst irradiance = mix( groundColorNode, colorNode, hemiDiffuseWeight );\n\n\t\tbuilder.context.irradiance.addAssign( irradiance );\n\n\t}\n\n}\n\nclass LightProbeNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'LightProbeNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tconst array = [];\n\n\t\tfor ( let i = 0; i < 9; i ++ ) array.push( new Vector3() );\n\n\t\tthis.lightProbe = uniformArray( array );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\t//\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.lightProbe.array[ i ].copy( light.sh.coefficients[ i ] ).multiplyScalar( light.intensity );\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst irradiance = getShIrradianceAt( normalWorld, this.lightProbe );\n\n\t\tbuilder.context.irradiance.addAssign( irradiance );\n\n\t}\n\n}\n\nclass NodeParser {\n\n\tparseFunction( /*source*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nclass NodeFunction {\n\n\tconstructor( type, inputs, name = '', precision = '' ) {\n\n\t\tthis.type = type;\n\t\tthis.inputs = inputs;\n\t\tthis.name = name;\n\t\tthis.precision = precision;\n\n\t}\n\n\tgetCode( /*name = this.name*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nNodeFunction.isNodeFunction = true;\n\nconst declarationRegexp$1 = /^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)/i;\nconst propertiesRegexp$1 = /[a-z_0-9]+/ig;\n\nconst pragmaMain = '#pragma main';\n\nconst parse$1 = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst pragmaMainIndex = source.indexOf( pragmaMain );\n\n\tconst mainCode = pragmaMainIndex !== - 1 ? source.slice( pragmaMainIndex + pragmaMain.length ) : source;\n\n\tconst declaration = mainCode.match( declarationRegexp$1 );\n\n\tif ( declaration !== null && declaration.length === 5 ) {\n\n\t\t// tokenizer\n\n\t\tconst inputsCode = declaration[ 4 ];\n\t\tconst propsMatches = [];\n\n\t\tlet nameMatch = null;\n\n\t\twhile ( ( nameMatch = propertiesRegexp$1.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( nameMatch );\n\n\t\t}\n\n\t\t// parser\n\n\t\tconst inputs = [];\n\n\t\tlet i = 0;\n\n\t\twhile ( i < propsMatches.length ) {\n\n\t\t\tconst isConst = propsMatches[ i ][ 0 ] === 'const';\n\n\t\t\tif ( isConst === true ) {\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tlet qualifier = propsMatches[ i ][ 0 ];\n\n\t\t\tif ( qualifier === 'in' || qualifier === 'out' || qualifier === 'inout' ) {\n\n\t\t\t\ti ++;\n\n\t\t\t} else {\n\n\t\t\t\tqualifier = '';\n\n\t\t\t}\n\n\t\t\tconst type = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tlet count = Number.parseInt( propsMatches[ i ][ 0 ] );\n\n\t\t\tif ( Number.isNaN( count ) === false ) i ++;\n\t\t\telse count = null;\n\n\t\t\tconst name = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tinputs.push( new NodeFunctionInput( type, name, count, qualifier, isConst ) );\n\n\t\t}\n\n\t\t//\n\n\t\tconst blockCode = mainCode.substring( declaration[ 0 ].length );\n\n\t\tconst name = declaration[ 3 ] !== undefined ? declaration[ 3 ] : '';\n\t\tconst type = declaration[ 2 ];\n\n\t\tconst precision = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\n\t\tconst headerCode = pragmaMainIndex !== - 1 ? source.slice( 0, pragmaMainIndex ) : '';\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tprecision,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\theaderCode\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a GLSL code.' );\n\n\t}\n\n};\n\nclass GLSLNodeFunction extends NodeFunction {\n\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, precision, inputsCode, blockCode, headerCode } = parse$1( source );\n\n\t\tsuper( type, inputs, name, precision );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.headerCode = headerCode;\n\n\t}\n\n\tgetCode( name = this.name ) {\n\n\t\tlet code;\n\n\t\tconst blockCode = this.blockCode;\n\n\t\tif ( blockCode !== '' ) {\n\n\t\t\tconst { type, inputsCode, headerCode, precision } = this;\n\n\t\t\tlet declarationCode = `${ type } ${ name } ( ${ inputsCode.trim() } )`;\n\n\t\t\tif ( precision !== '' ) {\n\n\t\t\t\tdeclarationCode = `${ precision } ${ declarationCode }`;\n\n\t\t\t}\n\n\t\t\tcode = headerCode + declarationCode + blockCode;\n\n\t\t} else {\n\n\t\t\t// interface function\n\n\t\t\tcode = '';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n}\n\nclass GLSLNodeParser extends NodeParser {\n\n\tparseFunction( source ) {\n\n\t\treturn new GLSLNodeFunction( source );\n\n\t}\n\n}\n\nconst outputNodeMap = new WeakMap();\n\nclass Nodes extends DataMap {\n\n\tconstructor( renderer, backend ) {\n\n\t\tsuper();\n\n\t\tthis.renderer = renderer;\n\t\tthis.backend = backend;\n\t\tthis.nodeFrame = new NodeFrame();\n\t\tthis.nodeBuilderCache = new Map();\n\t\tthis.callHashCache = new ChainMap();\n\t\tthis.groupsData = new ChainMap();\n\n\t}\n\n\tupdateGroup( nodeUniformsGroup ) {\n\n\t\tconst groupNode = nodeUniformsGroup.groupNode;\n\t\tconst name = groupNode.name;\n\n\t\t// objectGroup is every updated\n\n\t\tif ( name === objectGroup.name ) return true;\n\n\t\t// renderGroup is updated once per render/compute call\n\n\t\tif ( name === renderGroup.name ) {\n\n\t\t\tconst uniformsGroupData = this.get( nodeUniformsGroup );\n\t\t\tconst renderId = this.nodeFrame.renderId;\n\n\t\t\tif ( uniformsGroupData.renderId !== renderId ) {\n\n\t\t\t\tuniformsGroupData.renderId = renderId;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// frameGroup is updated once per frame\n\n\t\tif ( name === frameGroup.name ) {\n\n\t\t\tconst uniformsGroupData = this.get( nodeUniformsGroup );\n\t\t\tconst frameId = this.nodeFrame.frameId;\n\n\t\t\tif ( uniformsGroupData.frameId !== frameId ) {\n\n\t\t\t\tuniformsGroupData.frameId = frameId;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// other groups are updated just when groupNode.needsUpdate is true\n\n\t\tconst groupChain = [ groupNode, nodeUniformsGroup ];\n\n\t\tlet groupData = this.groupsData.get( groupChain );\n\t\tif ( groupData === undefined ) this.groupsData.set( groupChain, groupData = {} );\n\n\t\tif ( groupData.version !== groupNode.version ) {\n\n\t\t\tgroupData.version = groupNode.version;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetForRenderCacheKey( renderObject ) {\n\n\t\treturn renderObject.initialCacheKey;\n\n\t}\n\n\tgetForRender( renderObject ) {\n\n\t\tconst renderObjectData = this.get( renderObject );\n\n\t\tlet nodeBuilderState = renderObjectData.nodeBuilderState;\n\n\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\tconst { nodeBuilderCache } = this;\n\n\t\t\tconst cacheKey = this.getForRenderCacheKey( renderObject );\n\n\t\t\tnodeBuilderState = nodeBuilderCache.get( cacheKey );\n\n\t\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\t\tconst nodeBuilder = this.backend.createNodeBuilder( renderObject.object, this.renderer );\n\t\t\t\tnodeBuilder.scene = renderObject.scene;\n\t\t\t\tnodeBuilder.material = renderObject.material;\n\t\t\t\tnodeBuilder.camera = renderObject.camera;\n\t\t\t\tnodeBuilder.context.material = renderObject.material;\n\t\t\t\tnodeBuilder.lightsNode = renderObject.lightsNode;\n\t\t\t\tnodeBuilder.environmentNode = this.getEnvironmentNode( renderObject.scene );\n\t\t\t\tnodeBuilder.fogNode = this.getFogNode( renderObject.scene );\n\t\t\t\tnodeBuilder.clippingContext = renderObject.clippingContext;\n\t\t\t\tnodeBuilder.build();\n\n\t\t\t\tnodeBuilderState = this._createNodeBuilderState( nodeBuilder );\n\n\t\t\t\tnodeBuilderCache.set( cacheKey, nodeBuilderState );\n\n\t\t\t}\n\n\t\t\tnodeBuilderState.usedTimes ++;\n\n\t\t\trenderObjectData.nodeBuilderState = nodeBuilderState;\n\n\t\t}\n\n\t\treturn nodeBuilderState;\n\n\t}\n\n\tdelete( object ) {\n\n\t\tif ( object.isRenderObject ) {\n\n\t\t\tconst nodeBuilderState = this.get( object ).nodeBuilderState;\n\t\t\tnodeBuilderState.usedTimes --;\n\n\t\t\tif ( nodeBuilderState.usedTimes === 0 ) {\n\n\t\t\t\tthis.nodeBuilderCache.delete( this.getForRenderCacheKey( object ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.delete( object );\n\n\t}\n\n\tgetForCompute( computeNode ) {\n\n\t\tconst computeData = this.get( computeNode );\n\n\t\tlet nodeBuilderState = computeData.nodeBuilderState;\n\n\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\tconst nodeBuilder = this.backend.createNodeBuilder( computeNode, this.renderer );\n\t\t\tnodeBuilder.build();\n\n\t\t\tnodeBuilderState = this._createNodeBuilderState( nodeBuilder );\n\n\t\t\tcomputeData.nodeBuilderState = nodeBuilderState;\n\n\t\t}\n\n\t\treturn nodeBuilderState;\n\n\t}\n\n\t_createNodeBuilderState( nodeBuilder ) {\n\n\t\treturn new NodeBuilderState(\n\t\t\tnodeBuilder.vertexShader,\n\t\t\tnodeBuilder.fragmentShader,\n\t\t\tnodeBuilder.computeShader,\n\t\t\tnodeBuilder.getAttributesArray(),\n\t\t\tnodeBuilder.getBindings(),\n\t\t\tnodeBuilder.updateNodes,\n\t\t\tnodeBuilder.updateBeforeNodes,\n\t\t\tnodeBuilder.updateAfterNodes,\n\t\t\tnodeBuilder.monitor,\n\t\t\tnodeBuilder.transforms\n\t\t);\n\n\t}\n\n\tgetEnvironmentNode( scene ) {\n\n\t\treturn scene.environmentNode || this.get( scene ).environmentNode || null;\n\n\t}\n\n\tgetBackgroundNode( scene ) {\n\n\t\treturn scene.backgroundNode || this.get( scene ).backgroundNode || null;\n\n\t}\n\n\tgetFogNode( scene ) {\n\n\t\treturn scene.fogNode || this.get( scene ).fogNode || null;\n\n\t}\n\n\tgetCacheKey( scene, lightsNode ) {\n\n\t\tconst chain = [ scene, lightsNode ];\n\t\tconst callId = this.renderer.info.calls;\n\n\t\tlet cacheKeyData = this.callHashCache.get( chain );\n\n\t\tif ( cacheKeyData === undefined || cacheKeyData.callId !== callId ) {\n\n\t\t\tconst environmentNode = this.getEnvironmentNode( scene );\n\t\t\tconst fogNode = this.getFogNode( scene );\n\n\t\t\tconst values = [];\n\n\t\t\tif ( lightsNode ) values.push( lightsNode.getCacheKey( true ) );\n\t\t\tif ( environmentNode ) values.push( environmentNode.getCacheKey() );\n\t\t\tif ( fogNode ) values.push( fogNode.getCacheKey() );\n\n\t\t\tvalues.push( this.renderer.shadowMap.enabled ? 1 : 0 );\n\n\t\t\tcacheKeyData = {\n\t\t\t\tcallId,\n\t\t\t\tcacheKey: hashArray( values )\n\t\t\t};\n\n\t\t\tthis.callHashCache.set( chain, cacheKeyData );\n\n\t\t}\n\n\t\treturn cacheKeyData.cacheKey;\n\n\t}\n\n\tupdateScene( scene ) {\n\n\t\tthis.updateEnvironment( scene );\n\t\tthis.updateFog( scene );\n\t\tthis.updateBackground( scene );\n\n\t}\n\n\tget isToneMappingState() {\n\n\t\treturn this.renderer.getRenderTarget() ? false : true;\n\n\t}\n\n\tupdateBackground( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tconst forceUpdate = ( scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 ) || ( scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0 );\n\n\t\t\tif ( sceneData.background !== background || forceUpdate ) {\n\n\t\t\t\tlet backgroundNode = null;\n\n\t\t\t\tif ( background.isCubeTexture === true || ( background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping ) ) {\n\n\t\t\t\t\tif ( scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping ) {\n\n\t\t\t\t\t\tbackgroundNode = pmremTexture( background );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlet envMap;\n\n\t\t\t\t\t\tif ( background.isCubeTexture === true ) {\n\n\t\t\t\t\t\t\tenvMap = cubeTexture( background );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tenvMap = texture( background );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbackgroundNode = cubeMapNode( envMap );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( background.isTexture === true ) {\n\n\t\t\t\t\tbackgroundNode = texture( background, screenUV.flipY() ).setUpdateMatrix( true );\n\n\t\t\t\t} else if ( background.isColor !== true ) {\n\n\t\t\t\t\tconsole.error( 'WebGPUNodes: Unsupported background configuration.', background );\n\n\t\t\t\t}\n\n\t\t\t\tsceneData.backgroundNode = backgroundNode;\n\t\t\t\tsceneData.background = background;\n\t\t\t\tsceneData.backgroundBlurriness = scene.backgroundBlurriness;\n\n\t\t\t}\n\n\t\t} else if ( sceneData.backgroundNode ) {\n\n\t\t\tdelete sceneData.backgroundNode;\n\t\t\tdelete sceneData.background;\n\n\t\t}\n\n\t}\n\n\tupdateFog( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst fog = scene.fog;\n\n\t\tif ( fog ) {\n\n\t\t\tif ( sceneData.fog !== fog ) {\n\n\t\t\t\tlet fogNode = null;\n\n\t\t\t\tif ( fog.isFogExp2 ) {\n\n\t\t\t\t\tconst color = reference( 'color', 'color', fog ).setGroup( renderGroup );\n\t\t\t\t\tconst density = reference( 'density', 'float', fog ).setGroup( renderGroup );\n\n\t\t\t\t\tfogNode = densityFog( color, density );\n\n\t\t\t\t} else if ( fog.isFog ) {\n\n\t\t\t\t\tconst color = reference( 'color', 'color', fog ).setGroup( renderGroup );\n\t\t\t\t\tconst near = reference( 'near', 'float', fog ).setGroup( renderGroup );\n\t\t\t\t\tconst far = reference( 'far', 'float', fog ).setGroup( renderGroup );\n\n\t\t\t\t\tfogNode = rangeFog( color, near, far );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'WebGPUNodes: Unsupported fog configuration.', fog );\n\n\t\t\t\t}\n\n\t\t\t\tsceneData.fogNode = fogNode;\n\t\t\t\tsceneData.fog = fog;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdelete sceneData.fogNode;\n\t\t\tdelete sceneData.fog;\n\n\t\t}\n\n\t}\n\n\tupdateEnvironment( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst environment = scene.environment;\n\n\t\tif ( environment ) {\n\n\t\t\tif ( sceneData.environment !== environment ) {\n\n\t\t\t\tlet environmentNode = null;\n\n\t\t\t\tif ( environment.isCubeTexture === true ) {\n\n\t\t\t\t\tenvironmentNode = cubeTexture( environment );\n\n\t\t\t\t} else if ( environment.isTexture === true ) {\n\n\t\t\t\t\tenvironmentNode = texture( environment );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'Nodes: Unsupported environment configuration.', environment );\n\n\t\t\t\t}\n\n\t\t\t\tsceneData.environmentNode = environmentNode;\n\t\t\t\tsceneData.environment = environment;\n\n\t\t\t}\n\n\t\t} else if ( sceneData.environmentNode ) {\n\n\t\t\tdelete sceneData.environmentNode;\n\t\t\tdelete sceneData.environment;\n\n\t\t}\n\n\t}\n\n\tgetNodeFrame( renderer = this.renderer, scene = null, object = null, camera = null, material = null ) {\n\n\t\tconst nodeFrame = this.nodeFrame;\n\t\tnodeFrame.renderer = renderer;\n\t\tnodeFrame.scene = scene;\n\t\tnodeFrame.object = object;\n\t\tnodeFrame.camera = camera;\n\t\tnodeFrame.material = material;\n\n\t\treturn nodeFrame;\n\n\t}\n\n\tgetNodeFrameForRender( renderObject ) {\n\n\t\treturn this.getNodeFrame( renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material );\n\n\t}\n\n\tgetOutputCacheKey() {\n\n\t\tconst renderer = this.renderer;\n\n\t\treturn renderer.toneMapping + ',' + renderer.currentColorSpace;\n\n\t}\n\n\thasOutputChange( outputTarget ) {\n\n\t\tconst cacheKey = outputNodeMap.get( outputTarget );\n\n\t\treturn cacheKey !== this.getOutputCacheKey();\n\n\t}\n\n\tgetOutputNode( outputTexture ) {\n\n\t\tconst renderer = this.renderer;\n\t\tconst cacheKey = this.getOutputCacheKey();\n\n\t\tconst output = texture( outputTexture, screenUV ).renderOutput( renderer.toneMapping, renderer.currentColorSpace );\n\n\t\toutputNodeMap.set( outputTexture, cacheKey );\n\n\t\treturn output;\n\n\t}\n\n\tupdateBefore( renderObject ) {\n\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateBeforeNodes ) {\n\n\t\t\t// update frame state for each node\n\n\t\t\tthis.getNodeFrameForRender( renderObject ).updateBeforeNode( node );\n\n\t\t}\n\n\t}\n\n\tupdateAfter( renderObject ) {\n\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateAfterNodes ) {\n\n\t\t\t// update frame state for each node\n\n\t\t\tthis.getNodeFrameForRender( renderObject ).updateAfterNode( node );\n\n\t\t}\n\n\t}\n\n\tupdateForCompute( computeNode ) {\n\n\t\tconst nodeFrame = this.getNodeFrame();\n\t\tconst nodeBuilder = this.getForCompute( computeNode );\n\n\t\tfor ( const node of nodeBuilder.updateNodes ) {\n\n\t\t\tnodeFrame.updateNode( node );\n\n\t\t}\n\n\t}\n\n\tupdateForRender( renderObject ) {\n\n\t\tconst nodeFrame = this.getNodeFrameForRender( renderObject );\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateNodes ) {\n\n\t\t\tnodeFrame.updateNode( node );\n\n\t\t}\n\n\t}\n\n\tneedsRefresh( renderObject ) {\n\n\t\tconst nodeFrame = this.getNodeFrameForRender( renderObject );\n\t\tconst monitor = renderObject.getMonitor();\n\n\t\treturn monitor.needsRefresh( renderObject, nodeFrame );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis.nodeFrame = new NodeFrame();\n\t\tthis.nodeBuilderCache = new Map();\n\n\t}\n\n}\n\nconst _plane = /*@__PURE__*/ new Plane();\n\nclass ClippingContext {\n\n\tconstructor( parentContext = null ) {\n\n\t\tthis.version = 0;\n\n\t\tthis.clipIntersection = null;\n\t\tthis.cacheKey = '';\n\n\n\t\tif ( parentContext === null ) {\n\n\t\t\tthis.intersectionPlanes = [];\n\t\t\tthis.unionPlanes = [];\n\n\t\t\tthis.viewNormalMatrix = new Matrix3();\n\t\t\tthis.clippingGroupContexts = new WeakMap();\n\n\t\t\tthis.shadowPass = false;\n\n\t\t} else {\n\n\t\t\tthis.viewNormalMatrix = parentContext.viewNormalMatrix;\n\t\t\tthis.clippingGroupContexts = parentContext.clippingGroupContexts;\n\n\t\t\tthis.shadowPass = parentContext.shadowPass;\n\n\t\t\tthis.viewMatrix = parentContext.viewMatrix;\n\n\t\t}\n\n\t\tthis.parentVersion = null;\n\n\t}\n\n\tprojectPlanes( source, destination, offset ) {\n\n\t\tconst l = source.length;\n\n\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t_plane.copy( source[ i ] ).applyMatrix4( this.viewMatrix, this.viewNormalMatrix );\n\n\t\t\tconst v = destination[ offset + i ];\n\t\t\tconst normal = _plane.normal;\n\n\t\t\tv.x = - normal.x;\n\t\t\tv.y = - normal.y;\n\t\t\tv.z = - normal.z;\n\t\t\tv.w = _plane.constant;\n\n\t\t}\n\n\t}\n\n\tupdateGlobal( scene, camera ) {\n\n\t\tthis.shadowPass = ( scene.overrideMaterial !== null && scene.overrideMaterial.isShadowNodeMaterial );\n\t\tthis.viewMatrix = camera.matrixWorldInverse;\n\n\t\tthis.viewNormalMatrix.getNormalMatrix( this.viewMatrix );\n\n\t}\n\n\tupdate( parentContext, clippingGroup ) {\n\n\t\tlet update = false;\n\n\t\tif ( parentContext.version !== this.parentVersion ) {\n\n\t\t\tthis.intersectionPlanes = Array.from( parentContext.intersectionPlanes );\n\t\t\tthis.unionPlanes = Array.from( parentContext.unionPlanes );\n\t\t\tthis.parentVersion = parentContext.version;\n\n\t\t}\n\n\t\tif ( this.clipIntersection !== clippingGroup.clipIntersection ) {\n\n\t\t\tthis.clipIntersection = clippingGroup.clipIntersection;\n\n\t\t\tif ( this.clipIntersection ) {\n\n\t\t\t\tthis.unionPlanes.length = parentContext.unionPlanes.length;\n\n\t\t\t} else {\n\n\t\t\t\tthis.intersectionPlanes.length = parentContext.intersectionPlanes.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst srcClippingPlanes = clippingGroup.clippingPlanes;\n\t\tconst l = srcClippingPlanes.length;\n\n\t\tlet dstClippingPlanes;\n\t\tlet offset;\n\n\t\tif ( this.clipIntersection ) {\n\n\t\t\tdstClippingPlanes = this.intersectionPlanes;\n\t\t\toffset = parentContext.intersectionPlanes.length;\n\n\t\t} else {\n\n\t\t\tdstClippingPlanes = this.unionPlanes;\n\t\t\toffset = parentContext.unionPlanes.length;\n\n\t\t}\n\n\t\tif ( dstClippingPlanes.length !== offset + l ) {\n\n\t\t\tdstClippingPlanes.length = offset + l;\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tdstClippingPlanes[ offset + i ] = new Vector4();\n\n\t\t\t}\n\n\t\t\tupdate = true;\n\n\t\t}\n\n\t\tthis.projectPlanes( srcClippingPlanes, dstClippingPlanes, offset );\n\n\t\tif ( update ) {\n\n\t\t\tthis.version ++;\n\t\t\tthis.cacheKey = `${ this.intersectionPlanes.length }:${ this.unionPlanes.length }`;\n\n\t\t}\n\n\t}\n\n\tgetGroupContext( clippingGroup ) {\n\n\t\tif ( this.shadowPass && ! clippingGroup.clipShadows ) return this;\n\n\t\tlet context = this.clippingGroupContexts.get( clippingGroup );\n\n\t\tif ( context === undefined ) {\n\n\t\t\tcontext = new ClippingContext( this );\n\t\t\tthis.clippingGroupContexts.set( clippingGroup, context );\n\n\t\t}\n\n\t\tcontext.update( this, clippingGroup );\n\n\t\treturn context;\n\n\t}\n\n\tget unionClippingCount() {\n\n\t\treturn this.unionPlanes.length;\n\n\t}\n\n}\n\nclass RenderBundle {\n\n\tconstructor( scene, camera ) {\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t}\n\n\tclone() {\n\n\t\treturn Object.assign( new this.constructor(), this );\n\n\t}\n\n}\n\nclass RenderBundles {\n\n\tconstructor() {\n\n\t\tthis.lists = new ChainMap();\n\n\t}\n\n\tget( scene, camera ) {\n\n\t\tconst lists = this.lists;\n\t\tconst keys = [ scene, camera ];\n\n\t\tlet list = lists.get( keys );\n\n\t\tif ( list === undefined ) {\n\n\t\t\tlist = new RenderBundle( scene, camera );\n\t\t\tlists.set( keys, list );\n\n\t\t}\n\n\t\treturn list;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.lists = new ChainMap();\n\n\t}\n\n}\n\nclass NodeLibrary {\n\n\tconstructor() {\n\n\t\tthis.lightNodes = new WeakMap();\n\t\tthis.materialNodes = new Map();\n\t\tthis.toneMappingNodes = new Map();\n\n\t}\n\n\tfromMaterial( material ) {\n\n\t\tif ( material.isNodeMaterial ) return material;\n\n\t\tlet nodeMaterial = null;\n\n\t\tconst nodeMaterialClass = this.getMaterialNodeClass( material.type );\n\n\t\tif ( nodeMaterialClass !== null ) {\n\n\t\t\tnodeMaterial = new nodeMaterialClass();\n\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tnodeMaterial[ key ] = material[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeMaterial;\n\n\t}\n\n\taddToneMapping( toneMappingNode, toneMapping ) {\n\n\t\tthis.addType( toneMappingNode, toneMapping, this.toneMappingNodes );\n\n\t}\n\n\tgetToneMappingFunction( toneMapping ) {\n\n\t\treturn this.toneMappingNodes.get( toneMapping ) || null;\n\n\t}\n\n\tgetMaterialNodeClass( materialType ) {\n\n\t\treturn this.materialNodes.get( materialType ) || null;\n\n\t}\n\n\taddMaterial( materialNodeClass, materialClassType ) {\n\n\t\tthis.addType( materialNodeClass, materialClassType, this.materialNodes );\n\n\t}\n\n\tgetLightNodeClass( light ) {\n\n\t\treturn this.lightNodes.get( light ) || null;\n\n\t}\n\n\taddLight( lightNodeClass, lightClass ) {\n\n\t\tthis.addClass( lightNodeClass, lightClass, this.lightNodes );\n\n\t}\n\n\taddType( nodeClass, type, library ) {\n\n\t\tif ( library.has( type ) ) {\n\n\t\t\tconsole.warn( `Redefinition of node ${ type }` );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );\n\t\tif ( typeof type === 'function' || typeof type === 'object' ) throw new Error( `Base class ${ type } is not a class.` );\n\n\t\tlibrary.set( type, nodeClass );\n\n\t}\n\n\taddClass( nodeClass, baseClass, library ) {\n\n\t\tif ( library.has( baseClass ) ) {\n\n\t\t\tconsole.warn( `Redefinition of node ${ baseClass.name }` );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );\n\t\tif ( typeof baseClass !== 'function' ) throw new Error( `Base class ${ baseClass.name } is not a class.` );\n\n\t\tlibrary.set( baseClass, nodeClass );\n\n\t}\n\n}\n\nconst _defaultLights = /*@__PURE__*/ new LightsNode();\n\nclass Lighting extends ChainMap {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t}\n\n\tcreateNode( lights = [] ) {\n\n\t\treturn new LightsNode().setLights( lights );\n\n\t}\n\n\tgetNode( scene, camera ) {\n\n\t\t// ignore post-processing\n\n\t\tif ( scene.isQuadMesh ) return _defaultLights;\n\n\t\t// tiled lighting\n\n\t\tconst keys = [ scene, camera ];\n\n\t\tlet node = this.get( keys );\n\n\t\tif ( node === undefined ) {\n\n\t\t\tnode = this.createNode();\n\t\t\tthis.set( keys, node );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nconst _scene = /*@__PURE__*/ new Scene();\nconst _drawingBufferSize = /*@__PURE__*/ new Vector2();\nconst _screen = /*@__PURE__*/ new Vector4();\nconst _frustum = /*@__PURE__*/ new Frustum();\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _vector4 = /*@__PURE__*/ new Vector4();\n\nclass Renderer {\n\n\tconstructor( backend, parameters = {} ) {\n\n\t\tthis.isRenderer = true;\n\n\t\t//\n\n\t\tconst {\n\t\t\tlogarithmicDepthBuffer = false,\n\t\t\talpha = true,\n\t\t\tdepth = true,\n\t\t\tstencil = false,\n\t\t\tantialias = false,\n\t\t\tsamples = 0,\n\t\t\tgetFallback = null\n\t\t} = parameters;\n\n\t\t// public\n\t\tthis.domElement = backend.getDomElement();\n\n\t\tthis.backend = backend;\n\n\t\tthis.samples = samples || ( antialias === true ) ? 4 : 0;\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\n\t\tthis.alpha = alpha;\n\n\t\tthis.logarithmicDepthBuffer = logarithmicDepthBuffer;\n\n\t\tthis.outputColorSpace = SRGBColorSpace;\n\n\t\tthis.toneMapping = NoToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\n\t\tthis.sortObjects = true;\n\n\t\tthis.depth = depth;\n\t\tthis.stencil = stencil;\n\n\t\tthis.info = new Info();\n\n\t\tthis.nodes = {\n\t\t\tmodelViewMatrix: null,\n\t\t\tmodelNormalViewMatrix: null\n\t\t};\n\n\t\tthis.library = new NodeLibrary();\n\t\tthis.lighting = new Lighting();\n\n\t\t// internals\n\n\t\tthis._getFallback = getFallback;\n\n\t\tthis._pixelRatio = 1;\n\t\tthis._width = this.domElement.width;\n\t\tthis._height = this.domElement.height;\n\n\t\tthis._viewport = new Vector4( 0, 0, this._width, this._height );\n\t\tthis._scissor = new Vector4( 0, 0, this._width, this._height );\n\t\tthis._scissorTest = false;\n\n\t\tthis._attributes = null;\n\t\tthis._geometries = null;\n\t\tthis._nodes = null;\n\t\tthis._animation = null;\n\t\tthis._bindings = null;\n\t\tthis._objects = null;\n\t\tthis._pipelines = null;\n\t\tthis._bundles = null;\n\t\tthis._renderLists = null;\n\t\tthis._renderContexts = null;\n\t\tthis._textures = null;\n\t\tthis._background = null;\n\n\t\tthis._quad = new QuadMesh( new NodeMaterial() );\n\t\tthis._quad.material.type = 'Renderer_output';\n\n\t\tthis._currentRenderContext = null;\n\n\t\tthis._opaqueSort = null;\n\t\tthis._transparentSort = null;\n\n\t\tthis._frameBufferTarget = null;\n\n\t\tconst alphaClear = this.alpha === true ? 0 : 1;\n\n\t\tthis._clearColor = new Color4( 0, 0, 0, alphaClear );\n\t\tthis._clearDepth = 1;\n\t\tthis._clearStencil = 0;\n\n\t\tthis._renderTarget = null;\n\t\tthis._activeCubeFace = 0;\n\t\tthis._activeMipmapLevel = 0;\n\n\t\tthis._mrt = null;\n\n\t\tthis._renderObjectFunction = null;\n\t\tthis._currentRenderObjectFunction = null;\n\t\tthis._currentRenderBundle = null;\n\n\t\tthis._handleObjectFunction = this._renderObjectDirect;\n\n\t\tthis._isDeviceLost = false;\n\t\tthis.onDeviceLost = this._onDeviceLost;\n\n\t\tthis._initialized = false;\n\t\tthis._initPromise = null;\n\n\t\tthis._compilationPromises = null;\n\n\t\tthis.transparent = true;\n\t\tthis.opaque = true;\n\n\t\tthis.shadowMap = {\n\t\t\tenabled: false,\n\t\t\ttype: PCFShadowMap\n\t\t};\n\n\t\tthis.xr = {\n\t\t\tenabled: false\n\t\t};\n\n\t\tthis.debug = {\n\t\t\tcheckShaderErrors: true,\n\t\t\tonShaderError: null,\n\t\t\tgetShaderAsync: async ( scene, camera, object ) => {\n\n\t\t\t\tawait this.compileAsync( scene, camera );\n\n\t\t\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\t\t\tconst renderContext = this._renderContexts.get( scene, camera, this._renderTarget );\n\n\t\t\t\tconst material = scene.overrideMaterial || object.material;\n\n\t\t\t\tconst renderObject = this._objects.get( object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext );\n\n\t\t\t\tconst { fragmentShader, vertexShader } = renderObject.getNodeBuilderState();\n\n\t\t\t\treturn { fragmentShader, vertexShader };\n\n\t\t\t}\n\t\t};\n\n\t}\n\n\tasync init() {\n\n\t\tif ( this._initialized ) {\n\n\t\t\tthrow new Error( 'Renderer: Backend has already been initialized.' );\n\n\t\t}\n\n\t\tif ( this._initPromise !== null ) {\n\n\t\t\treturn this._initPromise;\n\n\t\t}\n\n\t\tthis._initPromise = new Promise( async ( resolve, reject ) => {\n\n\t\t\tlet backend = this.backend;\n\n\t\t\ttry {\n\n\t\t\t\tawait backend.init( this );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( this._getFallback !== null ) {\n\n\t\t\t\t\t// try the fallback\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tthis.backend = backend = this._getFallback( error );\n\t\t\t\t\t\tawait backend.init( this );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\treject( error );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\treject( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._nodes = new Nodes( this, backend );\n\t\t\tthis._animation = new Animation( this._nodes, this.info );\n\t\t\tthis._attributes = new Attributes( backend );\n\t\t\tthis._background = new Background( this, this._nodes );\n\t\t\tthis._geometries = new Geometries( this._attributes, this.info );\n\t\t\tthis._textures = new Textures( this, backend, this.info );\n\t\t\tthis._pipelines = new Pipelines( backend, this._nodes );\n\t\t\tthis._bindings = new Bindings( backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info );\n\t\t\tthis._objects = new RenderObjects( this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info );\n\t\t\tthis._renderLists = new RenderLists( this.lighting );\n\t\t\tthis._bundles = new RenderBundles();\n\t\t\tthis._renderContexts = new RenderContexts();\n\n\t\t\t//\n\n\t\t\tthis._animation.start();\n\t\t\tthis._initialized = true;\n\n\t\t\tresolve();\n\n\t\t} );\n\n\t\treturn this._initPromise;\n\n\t}\n\n\tget coordinateSystem() {\n\n\t\treturn this.backend.coordinateSystem;\n\n\t}\n\n\tasync compileAsync( scene, camera, targetScene = null ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\t// preserve render tree\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\t\tconst previousRenderContext = this._currentRenderContext;\n\t\tconst previousRenderObjectFunction = this._currentRenderObjectFunction;\n\t\tconst previousCompilationPromises = this._compilationPromises;\n\n\t\t//\n\n\t\tconst sceneRef = ( scene.isScene === true ) ? scene : _scene;\n\n\t\tif ( targetScene === null ) targetScene = scene;\n\n\t\tconst renderTarget = this._renderTarget;\n\t\tconst renderContext = this._renderContexts.get( targetScene, camera, renderTarget );\n\t\tconst activeMipmapLevel = this._activeMipmapLevel;\n\n\t\tconst compilationPromises = [];\n\n\t\tthis._currentRenderContext = renderContext;\n\t\tthis._currentRenderObjectFunction = this.renderObject;\n\n\t\tthis._handleObjectFunction = this._createObjectPipeline;\n\n\t\tthis._compilationPromises = compilationPromises;\n\n\t\tnodeFrame.renderId ++;\n\n\t\t//\n\n\t\tnodeFrame.update();\n\n\t\t//\n\n\t\trenderContext.depth = this.depth;\n\t\trenderContext.stencil = this.stencil;\n\n\t\tif ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();\n\t\trenderContext.clippingContext.updateGlobal( sceneRef, camera );\n\n\t\t//\n\n\t\tsceneRef.onBeforeRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\trenderList.begin();\n\n\t\tthis._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );\n\n\t\t// include lights from target scene\n\t\tif ( targetScene !== scene ) {\n\n\t\t\ttargetScene.traverseVisible( function ( object ) {\n\n\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\trenderList.pushLight( object );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\trenderList.finish();\n\n\t\t//\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget, activeMipmapLevel );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\n\t\t} else {\n\n\t\t\trenderContext.textures = null;\n\t\t\trenderContext.depthTexture = null;\n\n\t\t}\n\n\t\t//\n\n\t\tthis._nodes.updateScene( sceneRef );\n\n\t\t//\n\n\t\tthis._background.update( sceneRef, renderList, renderContext );\n\n\t\t// process render lists\n\n\t\tconst opaqueObjects = renderList.opaque;\n\t\tconst transparentObjects = renderList.transparent;\n\t\tconst transparentDoublePassObjects = renderList.transparentDoublePass;\n\t\tconst lightsNode = renderList.lightsNode;\n\n\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\tif ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );\n\n\t\t// restore render tree\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t\tthis._currentRenderContext = previousRenderContext;\n\t\tthis._currentRenderObjectFunction = previousRenderObjectFunction;\n\t\tthis._compilationPromises = previousCompilationPromises;\n\n\t\tthis._handleObjectFunction = this._renderObjectDirect;\n\n\t\t// wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete\n\n\t\tawait Promise.all( compilationPromises );\n\n\t}\n\n\tasync renderAsync( scene, camera ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tconst renderContext = this._renderScene( scene, camera );\n\n\t\tawait this.backend.resolveTimestampAsync( renderContext, 'render' );\n\n\t}\n\n\tasync waitForGPU() {\n\n\t\tawait this.backend.waitForGPU();\n\n\t}\n\n\tsetMRT( mrt ) {\n\n\t\tthis._mrt = mrt;\n\n\t\treturn this;\n\n\t}\n\n\tgetMRT() {\n\n\t\treturn this._mrt;\n\n\t}\n\n\t_onDeviceLost( info ) {\n\n\t\tlet errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\\n\\nMessage: ${info.message}`;\n\n\t\tif ( info.reason ) {\n\n\t\t\terrorMessage += `\\nReason: ${info.reason}`;\n\n\t\t}\n\n\t\tconsole.error( errorMessage );\n\n\t\tthis._isDeviceLost = true;\n\n\t}\n\n\n\t_renderBundle( bundle, sceneRef, lightsNode ) {\n\n\t\tconst { bundleGroup, camera, renderList } = bundle;\n\n\t\tconst renderContext = this._currentRenderContext;\n\n\t\t//\n\n\t\tconst renderBundle = this._bundles.get( bundleGroup, camera );\n\t\tconst renderBundleData = this.backend.get( renderBundle );\n\n\t\tif ( renderBundleData.renderContexts === undefined ) renderBundleData.renderContexts = new Set();\n\n\t\t//\n\n\t\tconst needsUpdate = bundleGroup.version !== renderBundleData.version;\n\t\tconst renderBundleNeedsUpdate = renderBundleData.renderContexts.has( renderContext ) === false || needsUpdate;\n\n\t\trenderBundleData.renderContexts.add( renderContext );\n\n\t\tif ( renderBundleNeedsUpdate ) {\n\n\t\t\tthis.backend.beginBundle( renderContext );\n\n\t\t\tif ( renderBundleData.renderObjects === undefined || needsUpdate ) {\n\n\t\t\t\trenderBundleData.renderObjects = [];\n\n\t\t\t}\n\n\t\t\tthis._currentRenderBundle = renderBundle;\n\n\t\t\tconst opaqueObjects = renderList.opaque;\n\n\t\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\n\t\t\tthis._currentRenderBundle = null;\n\n\t\t\t//\n\n\t\t\tthis.backend.finishBundle( renderContext, renderBundle );\n\n\t\t\trenderBundleData.version = bundleGroup.version;\n\n\t\t} else {\n\n\t\t\tconst { renderObjects } = renderBundleData;\n\n\t\t\tfor ( let i = 0, l = renderObjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst renderObject = renderObjects[ i ];\n\n\t\t\t\tif ( this._nodes.needsRefresh( renderObject ) ) {\n\n\t\t\t\t\tthis._nodes.updateBefore( renderObject );\n\n\t\t\t\t\tthis._nodes.updateForRender( renderObject );\n\t\t\t\t\tthis._bindings.updateForRender( renderObject );\n\n\t\t\t\t\tthis._nodes.updateAfter( renderObject );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.backend.addBundle( renderContext, renderBundle );\n\n\t}\n\n\trender( scene, camera ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.' );\n\n\t\t\treturn this.renderAsync( scene, camera );\n\n\t\t}\n\n\t\tthis._renderScene( scene, camera );\n\n\t}\n\n\t_getFrameBufferTarget() {\n\n\t\tconst { currentToneMapping, currentColorSpace } = this;\n\n\t\tconst useToneMapping = currentToneMapping !== NoToneMapping;\n\t\tconst useColorSpace = currentColorSpace !== LinearSRGBColorSpace;\n\n\t\tif ( useToneMapping === false && useColorSpace === false ) return null;\n\n\t\tconst { width, height } = this.getDrawingBufferSize( _drawingBufferSize );\n\t\tconst { depth, stencil } = this;\n\n\t\tlet frameBufferTarget = this._frameBufferTarget;\n\n\t\tif ( frameBufferTarget === null ) {\n\n\t\t\tframeBufferTarget = new RenderTarget( width, height, {\n\t\t\t\tdepthBuffer: depth,\n\t\t\t\tstencilBuffer: stencil,\n\t\t\t\ttype: HalfFloatType, // FloatType\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\t\tgenerateMipmaps: false,\n\t\t\t\tminFilter: LinearFilter,\n\t\t\t\tmagFilter: LinearFilter,\n\t\t\t\tsamples: this.samples\n\t\t\t} );\n\n\t\t\tframeBufferTarget.isPostProcessingRenderTarget = true;\n\n\t\t\tthis._frameBufferTarget = frameBufferTarget;\n\n\t\t}\n\n\t\tframeBufferTarget.depthBuffer = depth;\n\t\tframeBufferTarget.stencilBuffer = stencil;\n\t\tframeBufferTarget.setSize( width, height );\n\t\tframeBufferTarget.viewport.copy( this._viewport );\n\t\tframeBufferTarget.scissor.copy( this._scissor );\n\t\tframeBufferTarget.viewport.multiplyScalar( this._pixelRatio );\n\t\tframeBufferTarget.scissor.multiplyScalar( this._pixelRatio );\n\t\tframeBufferTarget.scissorTest = this._scissorTest;\n\n\t\treturn frameBufferTarget;\n\n\t}\n\n\t_renderScene( scene, camera, useFrameBufferTarget = true ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\tconst frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;\n\n\t\t// preserve render tree\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\t\tconst previousRenderContext = this._currentRenderContext;\n\t\tconst previousRenderObjectFunction = this._currentRenderObjectFunction;\n\n\t\t//\n\n\t\tconst sceneRef = ( scene.isScene === true ) ? scene : _scene;\n\n\t\tconst outputRenderTarget = this._renderTarget;\n\n\t\tconst activeCubeFace = this._activeCubeFace;\n\t\tconst activeMipmapLevel = this._activeMipmapLevel;\n\n\t\t//\n\n\t\tlet renderTarget;\n\n\t\tif ( frameBufferTarget !== null ) {\n\n\t\t\trenderTarget = frameBufferTarget;\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\n\t\t} else {\n\n\t\t\trenderTarget = outputRenderTarget;\n\n\t\t}\n\n\t\t//\n\n\t\tconst renderContext = this._renderContexts.get( scene, camera, renderTarget );\n\n\t\tthis._currentRenderContext = renderContext;\n\t\tthis._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;\n\n\t\t//\n\n\t\tthis.info.calls ++;\n\t\tthis.info.render.calls ++;\n\t\tthis.info.render.frameCalls ++;\n\n\t\tnodeFrame.renderId = this.info.calls;\n\n\t\t//\n\n\t\tconst coordinateSystem = this.coordinateSystem;\n\n\t\tif ( camera.coordinateSystem !== coordinateSystem ) {\n\n\t\t\tcamera.coordinateSystem = coordinateSystem;\n\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\n\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\t//\n\n\t\tlet viewport = this._viewport;\n\t\tlet scissor = this._scissor;\n\t\tlet pixelRatio = this._pixelRatio;\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tviewport = renderTarget.viewport;\n\t\t\tscissor = renderTarget.scissor;\n\t\t\tpixelRatio = 1;\n\n\t\t}\n\n\t\tthis.getDrawingBufferSize( _drawingBufferSize );\n\n\t\t_screen.set( 0, 0, _drawingBufferSize.width, _drawingBufferSize.height );\n\n\t\tconst minDepth = ( viewport.minDepth === undefined ) ? 0 : viewport.minDepth;\n\t\tconst maxDepth = ( viewport.maxDepth === undefined ) ? 1 : viewport.maxDepth;\n\n\t\trenderContext.viewportValue.copy( viewport ).multiplyScalar( pixelRatio ).floor();\n\t\trenderContext.viewportValue.width >>= activeMipmapLevel;\n\t\trenderContext.viewportValue.height >>= activeMipmapLevel;\n\t\trenderContext.viewportValue.minDepth = minDepth;\n\t\trenderContext.viewportValue.maxDepth = maxDepth;\n\t\trenderContext.viewport = renderContext.viewportValue.equals( _screen ) === false;\n\n\t\trenderContext.scissorValue.copy( scissor ).multiplyScalar( pixelRatio ).floor();\n\t\trenderContext.scissor = this._scissorTest && renderContext.scissorValue.equals( _screen ) === false;\n\t\trenderContext.scissorValue.width >>= activeMipmapLevel;\n\t\trenderContext.scissorValue.height >>= activeMipmapLevel;\n\n\t\tif ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();\n\t\trenderContext.clippingContext.updateGlobal( sceneRef, camera );\n\n\t\t//\n\n\t\tsceneRef.onBeforeRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromProjectionMatrix( _projScreenMatrix, coordinateSystem );\n\n\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\trenderList.begin();\n\n\t\tthis._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );\n\n\t\trenderList.finish();\n\n\t\tif ( this.sortObjects === true ) {\n\n\t\t\trenderList.sort( this._opaqueSort, this._transparentSort );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget, activeMipmapLevel );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\t\t\trenderContext.width = renderTargetData.width;\n\t\t\trenderContext.height = renderTargetData.height;\n\t\t\trenderContext.renderTarget = renderTarget;\n\t\t\trenderContext.depth = renderTarget.depthBuffer;\n\t\t\trenderContext.stencil = renderTarget.stencilBuffer;\n\n\t\t} else {\n\n\t\t\trenderContext.textures = null;\n\t\t\trenderContext.depthTexture = null;\n\t\t\trenderContext.width = this.domElement.width;\n\t\t\trenderContext.height = this.domElement.height;\n\t\t\trenderContext.depth = this.depth;\n\t\t\trenderContext.stencil = this.stencil;\n\n\t\t}\n\n\t\trenderContext.width >>= activeMipmapLevel;\n\t\trenderContext.height >>= activeMipmapLevel;\n\t\trenderContext.activeCubeFace = activeCubeFace;\n\t\trenderContext.activeMipmapLevel = activeMipmapLevel;\n\t\trenderContext.occlusionQueryCount = renderList.occlusionQueryCount;\n\n\t\t//\n\n\t\tthis._nodes.updateScene( sceneRef );\n\n\t\t//\n\n\t\tthis._background.update( sceneRef, renderList, renderContext );\n\n\t\t//\n\n\t\tthis.backend.beginRender( renderContext );\n\n\t\t// process render lists\n\n\t\tconst {\n\t\t\tbundles,\n\t\t\tlightsNode,\n\t\t\ttransparentDoublePass: transparentDoublePassObjects,\n\t\t\ttransparent: transparentObjects,\n\t\t\topaque: opaqueObjects\n\t\t} = renderList;\n\n\t\tif ( bundles.length > 0 ) this._renderBundles( bundles, sceneRef, lightsNode );\n\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\tif ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );\n\n\t\t// finish render pass\n\n\t\tthis.backend.finishRender( renderContext );\n\n\t\t// restore render tree\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t\tthis._currentRenderContext = previousRenderContext;\n\t\tthis._currentRenderObjectFunction = previousRenderObjectFunction;\n\n\t\t//\n\n\t\tif ( frameBufferTarget !== null ) {\n\n\t\t\tthis.setRenderTarget( outputRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t\t\tconst quad = this._quad;\n\n\t\t\tif ( this._nodes.hasOutputChange( renderTarget.texture ) ) {\n\n\t\t\t\tquad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );\n\t\t\t\tquad.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tthis._renderScene( quad, quad.camera, false );\n\n\t\t}\n\n\t\t//\n\n\t\tsceneRef.onAfterRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\treturn renderContext;\n\n\t}\n\n\tgetMaxAnisotropy() {\n\n\t\treturn this.backend.getMaxAnisotropy();\n\n\t}\n\n\tgetActiveCubeFace() {\n\n\t\treturn this._activeCubeFace;\n\n\t}\n\n\tgetActiveMipmapLevel() {\n\n\t\treturn this._activeMipmapLevel;\n\n\t}\n\n\tasync setAnimationLoop( callback ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis._animation.setAnimationLoop( callback );\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.backend.getArrayBufferAsync( attribute );\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.backend.getContext();\n\n\t}\n\n\tgetPixelRatio() {\n\n\t\treturn this._pixelRatio;\n\n\t}\n\n\tgetDrawingBufferSize( target ) {\n\n\t\treturn target.set( this._width * this._pixelRatio, this._height * this._pixelRatio ).floor();\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn target.set( this._width, this._height );\n\n\t}\n\n\tsetPixelRatio( value = 1 ) {\n\n\t\tif ( this._pixelRatio === value ) return;\n\n\t\tthis._pixelRatio = value;\n\n\t\tthis.setSize( this._width, this._height, false );\n\n\t}\n\n\tsetDrawingBufferSize( width, height, pixelRatio ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.domElement.width = Math.floor( width * pixelRatio );\n\t\tthis.domElement.height = Math.floor( height * pixelRatio );\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t\tif ( this._initialized ) this.backend.updateSize();\n\n\t}\n\n\tsetSize( width, height, updateStyle = true ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis.domElement.width = Math.floor( width * this._pixelRatio );\n\t\tthis.domElement.height = Math.floor( height * this._pixelRatio );\n\n\t\tif ( updateStyle === true ) {\n\n\t\t\tthis.domElement.style.width = width + 'px';\n\t\t\tthis.domElement.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t\tif ( this._initialized ) this.backend.updateSize();\n\n\t}\n\n\tsetOpaqueSort( method ) {\n\n\t\tthis._opaqueSort = method;\n\n\t}\n\n\tsetTransparentSort( method ) {\n\n\t\tthis._transparentSort = method;\n\n\t}\n\n\tgetScissor( target ) {\n\n\t\tconst scissor = this._scissor;\n\n\t\ttarget.x = scissor.x;\n\t\ttarget.y = scissor.y;\n\t\ttarget.width = scissor.width;\n\t\ttarget.height = scissor.height;\n\n\t\treturn target;\n\n\t}\n\n\tsetScissor( x, y, width, height ) {\n\n\t\tconst scissor = this._scissor;\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\tscissor.copy( x );\n\n\t\t} else {\n\n\t\t\tscissor.set( x, y, width, height );\n\n\t\t}\n\n\t}\n\n\tgetScissorTest() {\n\n\t\treturn this._scissorTest;\n\n\t}\n\n\tsetScissorTest( boolean ) {\n\n\t\tthis._scissorTest = boolean;\n\n\t\tthis.backend.setScissorTest( boolean );\n\n\t}\n\n\tgetViewport( target ) {\n\n\t\treturn target.copy( this._viewport );\n\n\t}\n\n\tsetViewport( x, y, width, height, minDepth = 0, maxDepth = 1 ) {\n\n\t\tconst viewport = this._viewport;\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\tviewport.copy( x );\n\n\t\t} else {\n\n\t\t\tviewport.set( x, y, width, height );\n\n\t\t}\n\n\t\tviewport.minDepth = minDepth;\n\t\tviewport.maxDepth = maxDepth;\n\n\t}\n\n\tgetClearColor( target ) {\n\n\t\treturn target.copy( this._clearColor );\n\n\t}\n\n\tsetClearColor( color, alpha = 1 ) {\n\n\t\tthis._clearColor.set( color );\n\t\tthis._clearColor.a = alpha;\n\n\t}\n\n\tgetClearAlpha() {\n\n\t\treturn this._clearColor.a;\n\n\t}\n\n\tsetClearAlpha( alpha ) {\n\n\t\tthis._clearColor.a = alpha;\n\n\t}\n\n\tgetClearDepth() {\n\n\t\treturn this._clearDepth;\n\n\t}\n\n\tsetClearDepth( depth ) {\n\n\t\tthis._clearDepth = depth;\n\n\t}\n\n\tgetClearStencil() {\n\n\t\treturn this._clearStencil;\n\n\t}\n\n\tsetClearStencil( stencil ) {\n\n\t\tthis._clearStencil = stencil;\n\n\t}\n\n\tisOccluded( object ) {\n\n\t\tconst renderContext = this._currentRenderContext;\n\n\t\treturn renderContext && this.backend.isOccluded( renderContext, object );\n\n\t}\n\n\tclear( color = true, depth = true, stencil = true ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.' );\n\n\t\t\treturn this.clearAsync( color, depth, stencil );\n\n\t\t}\n\n\t\tconst renderTarget = this._renderTarget || this._getFrameBufferTarget();\n\n\t\tlet renderTargetData = null;\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget );\n\n\t\t\trenderTargetData = this._textures.get( renderTarget );\n\n\t\t}\n\n\t\tthis.backend.clear( color, depth, stencil, renderTargetData );\n\n\t\tif ( renderTarget !== null && this._renderTarget === null ) {\n\n\t\t\t// If a color space transform or tone mapping is required,\n\t\t\t// the clear operation clears the intermediate renderTarget texture, but does not update the screen canvas.\n\n\t\t\tconst quad = this._quad;\n\n\t\t\tif ( this._nodes.hasOutputChange( renderTarget.texture ) ) {\n\n\t\t\t\tquad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );\n\t\t\t\tquad.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tthis._renderScene( quad, quad.camera, false );\n\n\t\t}\n\n\t}\n\n\tclearColor() {\n\n\t\treturn this.clear( true, false, false );\n\n\t}\n\n\tclearDepth() {\n\n\t\treturn this.clear( false, true, false );\n\n\t}\n\n\tclearStencil() {\n\n\t\treturn this.clear( false, false, true );\n\n\t}\n\n\tasync clearAsync( color = true, depth = true, stencil = true ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis.clear( color, depth, stencil );\n\n\t}\n\n\tclearColorAsync() {\n\n\t\treturn this.clearAsync( true, false, false );\n\n\t}\n\n\tclearDepthAsync() {\n\n\t\treturn this.clearAsync( false, true, false );\n\n\t}\n\n\tclearStencilAsync() {\n\n\t\treturn this.clearAsync( false, false, true );\n\n\t}\n\n\tget currentToneMapping() {\n\n\t\treturn this._renderTarget !== null ? NoToneMapping : this.toneMapping;\n\n\t}\n\n\tget currentColorSpace() {\n\n\t\treturn this._renderTarget !== null ? LinearSRGBColorSpace : this.outputColorSpace;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.info.dispose();\n\t\tthis.backend.dispose();\n\n\t\tthis._animation.dispose();\n\t\tthis._objects.dispose();\n\t\tthis._pipelines.dispose();\n\t\tthis._nodes.dispose();\n\t\tthis._bindings.dispose();\n\t\tthis._renderLists.dispose();\n\t\tthis._renderContexts.dispose();\n\t\tthis._textures.dispose();\n\n\t\tthis.setRenderTarget( null );\n\t\tthis.setAnimationLoop( null );\n\n\t}\n\n\tsetRenderTarget( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\tthis._renderTarget = renderTarget;\n\t\tthis._activeCubeFace = activeCubeFace;\n\t\tthis._activeMipmapLevel = activeMipmapLevel;\n\n\t}\n\n\tgetRenderTarget() {\n\n\t\treturn this._renderTarget;\n\n\t}\n\n\tsetRenderObjectFunction( renderObjectFunction ) {\n\n\t\tthis._renderObjectFunction = renderObjectFunction;\n\n\t}\n\n\tgetRenderObjectFunction() {\n\n\t\treturn this._renderObjectFunction;\n\n\t}\n\n\tcompute( computeNodes ) {\n\n\t\tif ( this.isDeviceLost === true ) return;\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.' );\n\n\t\t\treturn this.computeAsync( computeNodes );\n\n\t\t}\n\n\t\t//\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\n\t\t//\n\n\t\tthis.info.calls ++;\n\t\tthis.info.compute.calls ++;\n\t\tthis.info.compute.frameCalls ++;\n\n\t\tnodeFrame.renderId = this.info.calls;\n\n\t\t//\n\n\t\tconst backend = this.backend;\n\t\tconst pipelines = this._pipelines;\n\t\tconst bindings = this._bindings;\n\t\tconst nodes = this._nodes;\n\n\t\tconst computeList = Array.isArray( computeNodes ) ? computeNodes : [ computeNodes ];\n\n\t\tif ( computeList[ 0 ] === undefined || computeList[ 0 ].isComputeNode !== true ) {\n\n\t\t\tthrow new Error( 'THREE.Renderer: .compute() expects a ComputeNode.' );\n\n\t\t}\n\n\t\tbackend.beginCompute( computeNodes );\n\n\t\tfor ( const computeNode of computeList ) {\n\n\t\t\t// onInit\n\n\t\t\tif ( pipelines.has( computeNode ) === false ) {\n\n\t\t\t\tconst dispose = () => {\n\n\t\t\t\t\tcomputeNode.removeEventListener( 'dispose', dispose );\n\n\t\t\t\t\tpipelines.delete( computeNode );\n\t\t\t\t\tbindings.delete( computeNode );\n\t\t\t\t\tnodes.delete( computeNode );\n\n\t\t\t\t};\n\n\t\t\t\tcomputeNode.addEventListener( 'dispose', dispose );\n\n\t\t\t\t//\n\n\t\t\t\tconst onInitFn = computeNode.onInitFunction;\n\n\t\t\t\tif ( onInitFn !== null ) {\n\n\t\t\t\t\tonInitFn.call( computeNode, { renderer: this } );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnodes.updateForCompute( computeNode );\n\t\t\tbindings.updateForCompute( computeNode );\n\n\t\t\tconst computeBindings = bindings.getForCompute( computeNode );\n\t\t\tconst computePipeline = pipelines.getForCompute( computeNode, computeBindings );\n\n\t\t\tbackend.compute( computeNodes, computeNode, computeBindings, computePipeline );\n\n\t\t}\n\n\t\tbackend.finishCompute( computeNodes );\n\n\t\t//\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t}\n\n\tasync computeAsync( computeNodes ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis.compute( computeNodes );\n\n\t\tawait this.backend.resolveTimestampAsync( computeNodes, 'compute' );\n\n\t}\n\n\tasync hasFeatureAsync( name ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\treturn this.backend.hasFeature( name );\n\n\t}\n\n\thasFeature( name ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.' );\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.backend.hasFeature( name );\n\n\t}\n\n\thasInitialized() {\n\n\t\treturn this._initialized;\n\n\t}\n\n\tasync initTextureAsync( texture ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis._textures.updateTexture( texture );\n\n\t}\n\n\tinitTexture( texture ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.' );\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tthis._textures.updateTexture( texture );\n\n\t}\n\n\tcopyFramebufferToTexture( framebufferTexture, rectangle = null ) {\n\n\t\tif ( rectangle !== null ) {\n\n\t\t\tif ( rectangle.isVector2 ) {\n\n\t\t\t\trectangle = _vector4.set( rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height ).floor();\n\n\t\t\t} else if ( rectangle.isVector4 ) {\n\n\t\t\t\trectangle = _vector4.copy( rectangle ).floor();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.' );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trectangle = _vector4.set( 0, 0, framebufferTexture.image.width, framebufferTexture.image.height );\n\n\t\t}\n\n\t\t//\n\n\t\tlet renderContext = this._currentRenderContext;\n\t\tlet renderTarget;\n\n\t\tif ( renderContext !== null ) {\n\n\t\t\trenderTarget = renderContext.renderTarget;\n\n\t\t} else {\n\n\t\t\trenderTarget = this._renderTarget || this._getFrameBufferTarget();\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tthis._textures.updateRenderTarget( renderTarget );\n\n\t\t\t\trenderContext = this._textures.get( renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tthis._textures.updateTexture( framebufferTexture, { renderTarget } );\n\n\t\tthis.backend.copyFramebufferToTexture( framebufferTexture, renderContext, rectangle );\n\n\t}\n\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\tthis._textures.updateTexture( srcTexture );\n\t\tthis._textures.updateTexture( dstTexture );\n\n\t\tthis.backend.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );\n\n\t}\n\n\treadRenderTargetPixelsAsync( renderTarget, x, y, width, height, index = 0, faceIndex = 0 ) {\n\n\t\treturn this.backend.copyTextureToBuffer( renderTarget.textures[ index ], x, y, width, height, faceIndex );\n\n\t}\n\n\t_projectObject( object, camera, groupOrder, renderList, clippingContext ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible ) {\n\n\t\t\tif ( object.isGroup ) {\n\n\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t\tif ( object.isClippingGroup && object.enabled ) clippingContext = clippingContext.getGroupContext( object );\n\n\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\trenderList.pushLight( object );\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\t_vector4.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { geometry, material } = object;\n\n\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\trenderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\tconsole.error( 'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.' );\n\n\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tconst { geometry, material } = object;\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\t\t\t_vector4\n\t\t\t\t\t\t\t.copy( geometry.boundingSphere.center )\n\t\t\t\t\t\t\t.applyMatrix4( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\trenderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\trenderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.isBundleGroup === true && this.backend.beginBundle !== undefined ) {\n\n\t\t\tconst baseRenderList = renderList;\n\n\t\t\t// replace render list\n\t\t\trenderList = this._renderLists.get( object, camera );\n\n\t\t\trenderList.begin();\n\n\t\t\tbaseRenderList.pushBundle( {\n\t\t\t\tbundleGroup: object,\n\t\t\t\tcamera,\n\t\t\t\trenderList,\n\t\t\t} );\n\n\t\t\trenderList.finish();\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis._projectObject( children[ i ], camera, groupOrder, renderList, clippingContext );\n\n\t\t}\n\n\t}\n\n\t_renderBundles( bundles, sceneRef, lightsNode ) {\n\n\t\tfor ( const bundle of bundles ) {\n\n\t\t\tthis._renderBundle( bundle, sceneRef, lightsNode );\n\n\t\t}\n\n\t}\n\n\t_renderTransparents( renderList, doublePassList, camera, scene, lightsNode ) {\n\n\t\tif ( doublePassList.length > 0 ) {\n\n\t\t\t// render back side\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\n\t\t\t}\n\n\t\t\tthis._renderObjects( doublePassList, camera, scene, lightsNode, 'backSide' );\n\n\t\t\t// render front side\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = FrontSide;\n\n\t\t\t}\n\n\t\t\tthis._renderObjects( renderList, camera, scene, lightsNode );\n\n\t\t\t// restore\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis._renderObjects( renderList, camera, scene, lightsNode );\n\n\t\t}\n\n\t}\n\n\t_renderObjects( renderList, camera, scene, lightsNode, passId = null ) {\n\n\t\t// process renderable objects\n\n\t\tfor ( let i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = renderList[ i ];\n\n\t\t\t// @TODO: Add support for multiple materials per object. This will require to extract\n\t\t\t// the material from the renderItem object and pass it with its group data to renderObject().\n\n\t\t\tconst { object, geometry, material, group, clippingContext } = renderItem;\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\tconst cameras = camera.cameras;\n\n\t\t\t\tfor ( let j = 0, jl = cameras.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst camera2 = cameras[ j ];\n\n\t\t\t\t\tif ( object.layers.test( camera2.layers ) ) {\n\n\t\t\t\t\t\tconst vp = camera2.viewport;\n\t\t\t\t\t\tconst minDepth = ( vp.minDepth === undefined ) ? 0 : vp.minDepth;\n\t\t\t\t\t\tconst maxDepth = ( vp.maxDepth === undefined ) ? 1 : vp.maxDepth;\n\n\t\t\t\t\t\tconst viewportValue = this._currentRenderContext.viewportValue;\n\t\t\t\t\t\tviewportValue.copy( vp ).multiplyScalar( this._pixelRatio ).floor();\n\t\t\t\t\t\tviewportValue.minDepth = minDepth;\n\t\t\t\t\t\tviewportValue.maxDepth = maxDepth;\n\n\t\t\t\t\t\tthis.backend.updateViewport( this._currentRenderContext );\n\n\t\t\t\t\t\tthis._currentRenderObjectFunction( object, scene, camera2, geometry, material, group, lightsNode, clippingContext, passId );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis._currentRenderObjectFunction( object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\trenderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null ) {\n\n\t\tlet overridePositionNode;\n\t\tlet overrideColorNode;\n\t\tlet overrideDepthNode;\n\n\t\t//\n\n\t\tobject.onBeforeRender( this, scene, camera, geometry, material, group );\n\n\t\t//\n\n\t\tif ( scene.overrideMaterial !== null ) {\n\n\t\t\tconst overrideMaterial = scene.overrideMaterial;\n\n\t\t\tif ( material.positionNode && material.positionNode.isNode ) {\n\n\t\t\t\toverridePositionNode = overrideMaterial.positionNode;\n\t\t\t\toverrideMaterial.positionNode = material.positionNode;\n\n\t\t\t}\n\n\t\t\toverrideMaterial.alphaTest = material.alphaTest;\n\t\t\toverrideMaterial.alphaMap = material.alphaMap;\n\n\t\t\tif ( overrideMaterial.isShadowNodeMaterial ) {\n\n\t\t\t\toverrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;\n\n\t\t\t\tif ( material.depthNode && material.depthNode.isNode ) {\n\n\t\t\t\t\toverrideDepthNode = overrideMaterial.depthNode;\n\t\t\t\t\toverrideMaterial.depthNode = material.depthNode;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.castShadowNode && material.castShadowNode.isNode ) {\n\n\t\t\t\t\toverrideColorNode = overrideMaterial.colorNode;\n\t\t\t\t\toverrideMaterial.colorNode = material.castShadowNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterial = overrideMaterial;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\tmaterial.side = BackSide;\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, 'backSide' ); // create backSide pass id\n\n\t\t\tmaterial.side = FrontSide;\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId ); // use default pass id\n\n\t\t\tmaterial.side = DoubleSide;\n\n\t\t} else {\n\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( overridePositionNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.positionNode = overridePositionNode;\n\n\t\t}\n\n\t\tif ( overrideDepthNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.depthNode = overrideDepthNode;\n\n\t\t}\n\n\t\tif ( overrideColorNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.colorNode = overrideColorNode;\n\n\t\t}\n\n\t\t//\n\n\t\tobject.onAfterRender( this, scene, camera, geometry, material, group );\n\n\t}\n\n\t_renderObjectDirect( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {\n\n\t\tconst renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );\n\t\trenderObject.drawRange = object.geometry.drawRange;\n\t\trenderObject.group = group;\n\n\t\t//\n\n\t\tconst needsRefresh = this._nodes.needsRefresh( renderObject );\n\n\t\tif ( needsRefresh ) {\n\n\t\t\tthis._nodes.updateBefore( renderObject );\n\n\t\t\tthis._geometries.updateForRender( renderObject );\n\n\t\t\tthis._nodes.updateForRender( renderObject );\n\t\t\tthis._bindings.updateForRender( renderObject );\n\n\t\t}\n\n\t\tthis._pipelines.updateForRender( renderObject );\n\n\t\t//\n\n\t\tif ( this._currentRenderBundle !== null ) {\n\n\t\t\tconst renderBundleData = this.backend.get( this._currentRenderBundle );\n\n\t\t\trenderBundleData.renderObjects.push( renderObject );\n\n\t\t\trenderObject.bundle = this._currentRenderBundle.scene;\n\n\t\t}\n\n\t\tthis.backend.draw( renderObject, this.info );\n\n\t\tif ( needsRefresh ) this._nodes.updateAfter( renderObject );\n\n\t}\n\n\t_createObjectPipeline( object, material, scene, camera, lightsNode, clippingContext, passId ) {\n\n\t\tconst renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );\n\n\t\t//\n\n\t\tthis._nodes.updateBefore( renderObject );\n\n\t\tthis._geometries.updateForRender( renderObject );\n\n\t\tthis._nodes.updateForRender( renderObject );\n\t\tthis._bindings.updateForRender( renderObject );\n\n\t\tthis._pipelines.getForRender( renderObject, this._compilationPromises );\n\n\t\tthis._nodes.updateAfter( renderObject );\n\n\t}\n\n\tget compile() {\n\n\t\treturn this.compileAsync;\n\n\t}\n\n}\n\nclass Binding {\n\n\tconstructor( name = '' ) {\n\n\t\tthis.name = name;\n\n\t\tthis.visibility = 0;\n\n\t}\n\n\tsetVisibility( visibility ) {\n\n\t\tthis.visibility |= visibility;\n\n\t}\n\n\tclone() {\n\n\t\treturn Object.assign( new this.constructor(), this );\n\n\t}\n\n}\n\nfunction getFloatLength( floatLength ) {\n\n\t// ensure chunk size alignment (STD140 layout)\n\n\treturn floatLength + ( ( GPU_CHUNK_BYTES - ( floatLength % GPU_CHUNK_BYTES ) ) % GPU_CHUNK_BYTES );\n\n}\n\nclass Buffer extends Binding {\n\n\tconstructor( name, buffer = null ) {\n\n\t\tsuper( name );\n\n\t\tthis.isBuffer = true;\n\n\t\tthis.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;\n\n\t\tthis._buffer = buffer;\n\n\t}\n\n\tget byteLength() {\n\n\t\treturn getFloatLength( this._buffer.byteLength );\n\n\t}\n\n\tget buffer() {\n\n\t\treturn this._buffer;\n\n\t}\n\n\tupdate() {\n\n\t\treturn true;\n\n\t}\n\n}\n\nclass UniformBuffer extends Buffer {\n\n\tconstructor( name, buffer = null ) {\n\n\t\tsuper( name, buffer );\n\n\t\tthis.isUniformBuffer = true;\n\n\t}\n\n}\n\nlet _id$4 = 0;\n\nclass NodeUniformBuffer extends UniformBuffer {\n\n\tconstructor( nodeUniform, groupNode ) {\n\n\t\tsuper( 'UniformBuffer_' + _id$4 ++, nodeUniform ? nodeUniform.value : null );\n\n\t\tthis.nodeUniform = nodeUniform;\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\tget buffer() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n}\n\nclass UniformsGroup extends UniformBuffer {\n\n\tconstructor( name ) {\n\n\t\tsuper( name );\n\n\t\tthis.isUniformsGroup = true;\n\n\t\tthis._values = null;\n\n\t\t// the order of uniforms in this array must match the order of uniforms in the shader\n\n\t\tthis.uniforms = [];\n\n\t}\n\n\taddUniform( uniform ) {\n\n\t\tthis.uniforms.push( uniform );\n\n\t\treturn this;\n\n\t}\n\n\tremoveUniform( uniform ) {\n\n\t\tconst index = this.uniforms.indexOf( uniform );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.uniforms.splice( index, 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tget values() {\n\n\t\tif ( this._values === null ) {\n\n\t\t\tthis._values = Array.from( this.buffer );\n\n\t\t}\n\n\t\treturn this._values;\n\n\t}\n\n\tget buffer() {\n\n\t\tlet buffer = this._buffer;\n\n\t\tif ( buffer === null ) {\n\n\t\t\tconst byteLength = this.byteLength;\n\n\t\t\tbuffer = new Float32Array( new ArrayBuffer( byteLength ) );\n\n\t\t\tthis._buffer = buffer;\n\n\t\t}\n\n\t\treturn buffer;\n\n\t}\n\n\tget byteLength() {\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\n\t\tfor ( let i = 0, l = this.uniforms.length; i < l; i ++ ) {\n\n\t\t\tconst uniform = this.uniforms[ i ];\n\n\t\t\tconst { boundary, itemSize } = uniform;\n\n\t\t\t// offset within a single chunk in bytes\n\n\t\t\tconst chunkOffset = offset % GPU_CHUNK_BYTES;\n\t\t\tconst remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;\n\n\t\t\t// conformance tests\n\n\t\t\tif ( chunkOffset !== 0 && ( remainingSizeInChunk - boundary ) < 0 ) {\n\n\t\t\t\t// check for chunk overflow\n\n\t\t\t\toffset += ( GPU_CHUNK_BYTES - chunkOffset );\n\n\t\t\t} else if ( chunkOffset % boundary !== 0 ) {\n\n\t\t\t\t// check for correct alignment\n\n\t\t\t\toffset += ( chunkOffset % boundary );\n\n\t\t\t}\n\n\t\t\tuniform.offset = ( offset / this.bytesPerElement );\n\n\t\t\toffset += ( itemSize * this.bytesPerElement );\n\n\t\t}\n\n\t\treturn Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES;\n\n\t}\n\n\tupdate() {\n\n\t\tlet updated = false;\n\n\t\tfor ( const uniform of this.uniforms ) {\n\n\t\t\tif ( this.updateByType( uniform ) === true ) {\n\n\t\t\t\tupdated = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateByType( uniform ) {\n\n\t\tif ( uniform.isNumberUniform ) return this.updateNumber( uniform );\n\t\tif ( uniform.isVector2Uniform ) return this.updateVector2( uniform );\n\t\tif ( uniform.isVector3Uniform ) return this.updateVector3( uniform );\n\t\tif ( uniform.isVector4Uniform ) return this.updateVector4( uniform );\n\t\tif ( uniform.isColorUniform ) return this.updateColor( uniform );\n\t\tif ( uniform.isMatrix3Uniform ) return this.updateMatrix3( uniform );\n\t\tif ( uniform.isMatrix4Uniform ) return this.updateMatrix4( uniform );\n\n\t\tconsole.error( 'THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform );\n\n\t}\n\n\tupdateNumber( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset ] !== v ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset ] = a[ offset ] = v;\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateVector2( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateVector3( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = v.z;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateVector4( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z || a[ offset + 4 ] !== v.w ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = v.z;\n\t\t\tb[ offset + 3 ] = a[ offset + 3 ] = v.w;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateColor( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst c = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== c.r || a[ offset + 1 ] !== c.g || a[ offset + 2 ] !== c.b ) {\n\n\t\t\tconst b = this.buffer;\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = c.r;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = c.g;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = c.b;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateMatrix3( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst e = uniform.getValue().elements;\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== e[ 0 ] || a[ offset + 1 ] !== e[ 1 ] || a[ offset + 2 ] !== e[ 2 ] ||\n\t\t\ta[ offset + 4 ] !== e[ 3 ] || a[ offset + 5 ] !== e[ 4 ] || a[ offset + 6 ] !== e[ 5 ] ||\n\t\t\ta[ offset + 8 ] !== e[ 6 ] || a[ offset + 9 ] !== e[ 7 ] || a[ offset + 10 ] !== e[ 8 ] ) {\n\n\t\t\tconst b = this.buffer;\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = e[ 0 ];\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = e[ 1 ];\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = e[ 2 ];\n\t\t\tb[ offset + 4 ] = a[ offset + 4 ] = e[ 3 ];\n\t\t\tb[ offset + 5 ] = a[ offset + 5 ] = e[ 4 ];\n\t\t\tb[ offset + 6 ] = a[ offset + 6 ] = e[ 5 ];\n\t\t\tb[ offset + 8 ] = a[ offset + 8 ] = e[ 6 ];\n\t\t\tb[ offset + 9 ] = a[ offset + 9 ] = e[ 7 ];\n\t\t\tb[ offset + 10 ] = a[ offset + 10 ] = e[ 8 ];\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateMatrix4( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst e = uniform.getValue().elements;\n\t\tconst offset = uniform.offset;\n\n\t\tif ( arraysEqual( a, e, offset ) === false ) {\n\n\t\t\tconst b = this.buffer;\n\t\t\tb.set( e, offset );\n\t\t\tsetArray( a, e, offset );\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t_getBufferForType( type ) {\n\n\t\tif ( type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4' ) return new Int32Array( this.buffer.buffer );\n\t\tif ( type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4' ) return new Uint32Array( this.buffer.buffer );\n\t\treturn this.buffer;\n\n\t}\n\n}\n\nfunction setArray( a, b, offset ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\ta[ offset + i ] = b[ i ];\n\n\t}\n\n}\n\nfunction arraysEqual( a, b, offset ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\tif ( a[ offset + i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nlet _id$3 = 0;\n\nclass NodeUniformsGroup extends UniformsGroup {\n\n\tconstructor( name, groupNode ) {\n\n\t\tsuper( name );\n\n\t\tthis.id = _id$3 ++;\n\t\tthis.groupNode = groupNode;\n\n\t\tthis.isNodeUniformsGroup = true;\n\n\t}\n\n\tgetNodes() {\n\n\t\tconst nodes = [];\n\n\t\tfor ( const uniform of this.uniforms ) {\n\n\t\t\tconst node = uniform.nodeUniform.node;\n\n\t\t\tif ( ! node ) throw new Error( 'NodeUniformsGroup: Uniform has no node.' );\n\n\t\t\tnodes.push( node );\n\n\t\t}\n\n\t\treturn nodes;\n\n\t}\n\n}\n\nlet _id$2 = 0;\n\nclass SampledTexture extends Binding {\n\n\tconstructor( name, texture ) {\n\n\t\tsuper( name );\n\n\t\tthis.id = _id$2 ++;\n\n\t\tthis.texture = texture;\n\t\tthis.version = texture ? texture.version : 0;\n\t\tthis.store = false;\n\t\tthis.generation = null;\n\n\t\tthis.isSampledTexture = true;\n\n\t}\n\n\tneedsBindingsUpdate( generation ) {\n\n\t\tconst { texture } = this;\n\n\t\tif ( generation !== this.generation ) {\n\n\t\t\tthis.generation = generation;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn texture.isVideoTexture;\n\n\t}\n\n\tupdate() {\n\n\t\tconst { texture, version } = this;\n\n\t\tif ( version !== texture.version ) {\n\n\t\t\tthis.version = texture.version;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n}\n\nclass NodeSampledTexture extends SampledTexture {\n\n\tconstructor( name, textureNode, groupNode, access = null ) {\n\n\t\tsuper( name, textureNode ? textureNode.value : null );\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.groupNode = groupNode;\n\n\t\tthis.access = access;\n\n\t}\n\n\tneedsBindingsUpdate( generation ) {\n\n\t\treturn this.textureNode.value !== this.texture || super.needsBindingsUpdate( generation );\n\n\t}\n\n\tupdate() {\n\n\t\tconst { textureNode } = this;\n\n\t\tif ( this.texture !== textureNode.value ) {\n\n\t\t\tthis.texture = textureNode.value;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn super.update();\n\n\t}\n\n}\n\nclass NodeSampledCubeTexture extends NodeSampledTexture {\n\n\tconstructor( name, textureNode, groupNode, access ) {\n\n\t\tsuper( name, textureNode, groupNode, access );\n\n\t\tthis.isSampledCubeTexture = true;\n\n\t}\n\n}\n\nclass NodeSampledTexture3D extends NodeSampledTexture {\n\n\tconstructor( name, textureNode, groupNode, access ) {\n\n\t\tsuper( name, textureNode, groupNode, access );\n\n\t\tthis.isSampledTexture3D = true;\n\n\t}\n\n}\n\nconst glslMethods = {\n\tatan2: 'atan',\n\ttextureDimensions: 'textureSize',\n\tequals: 'equal'\n};\n\nconst precisionLib = {\n\tlow: 'lowp',\n\tmedium: 'mediump',\n\thigh: 'highp'\n};\n\nconst supports$1 = {\n\tswizzleAssign: true,\n\tstorageBuffer: false\n};\n\nconst defaultPrecisions = `\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler3D;\nprecision highp samplerCube;\nprecision highp sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp usampler3D;\nprecision highp usamplerCube;\nprecision highp usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp isampler3D;\nprecision highp isamplerCube;\nprecision highp isampler2DArray;\n\nprecision lowp sampler2DShadow;\n`;\n\nclass GLSLNodeBuilder extends NodeBuilder {\n\n\tconstructor( object, renderer ) {\n\n\t\tsuper( object, renderer, new GLSLNodeParser() );\n\n\t\tthis.uniformGroups = {};\n\t\tthis.transforms = [];\n\t\tthis.extensions = {};\n\t\tthis.builtins = { vertex: [], fragment: [], compute: [] };\n\n\t\tthis.useComparisonMethod = true;\n\n\t}\n\n\tneedsToWorkingColorSpace( texture ) {\n\n\t\treturn texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn glslMethods[ method ] || method;\n\n\t}\n\n\tgetOutputStructName() {\n\n\t\treturn '';\n\n\t}\n\n\tbuildFunctionCode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\t\tconst flowData = this.flowShaderNode( shaderNode );\n\n\t\tconst parameters = [];\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tparameters.push( this.getType( input.type ) + ' ' + input.name );\n\n\t\t}\n\n\t\t//\n\n\t\tconst code = `${ this.getType( layout.type ) } ${ layout.name }( ${ parameters.join( ', ' ) } ) {\n\n\t${ flowData.vars }\n\n${ flowData.code }\n\treturn ${ flowData.result };\n\n}`;\n\n\t\t//\n\n\t\treturn code;\n\n\t}\n\n\tsetupPBO( storageBufferNode ) {\n\n\t\tconst attribute = storageBufferNode.value;\n\n\t\tif ( attribute.pbo === undefined ) {\n\n\t\t\tconst originalArray = attribute.array;\n\t\t\tconst numElements = attribute.count * attribute.itemSize;\n\n\t\t\tconst { itemSize } = attribute;\n\n\t\t\tconst isInteger = attribute.array.constructor.name.toLowerCase().includes( 'int' );\n\n\t\t\tlet format = isInteger ? RedIntegerFormat : RedFormat;\n\n\t\t\tif ( itemSize === 2 ) {\n\n\t\t\t\tformat = isInteger ? RGIntegerFormat : RGFormat;\n\n\t\t\t} else if ( itemSize === 3 ) {\n\n\t\t\t\tformat = isInteger ? RGBIntegerFormat : RGBFormat;\n\n\t\t\t} else if ( itemSize === 4 ) {\n\n\t\t\t\tformat = isInteger ? RGBAIntegerFormat : RGBAFormat;\n\n\t\t\t}\n\n\t\t\tconst typeMap = {\n\t\t\t\tFloat32Array: FloatType,\n\t\t\t\tUint8Array: UnsignedByteType,\n\t\t\t\tUint16Array: UnsignedShortType,\n\t\t\t\tUint32Array: UnsignedIntType,\n\t\t\t\tInt8Array: ByteType,\n\t\t\t\tInt16Array: ShortType,\n\t\t\t\tInt32Array: IntType,\n\t\t\t\tUint8ClampedArray: UnsignedByteType,\n\t\t\t};\n\n\t\t\tconst width = Math.pow( 2, Math.ceil( Math.log2( Math.sqrt( numElements / itemSize ) ) ) );\n\t\t\tlet height = Math.ceil( ( numElements / itemSize ) / width );\n\t\t\tif ( width * height * itemSize < numElements ) height ++; // Ensure enough space\n\n\t\t\tconst newSize = width * height * itemSize;\n\n\t\t\tconst newArray = new originalArray.constructor( newSize );\n\n\t\t\tnewArray.set( originalArray, 0 );\n\n\t\t\tattribute.array = newArray;\n\n\t\t\tconst pboTexture = new DataTexture( attribute.array, width, height, format, typeMap[ attribute.array.constructor.name ] || FloatType );\n\t\t\tpboTexture.needsUpdate = true;\n\t\t\tpboTexture.isPBOTexture = true;\n\n\t\t\tconst pbo = new TextureNode( pboTexture, null, null );\n\t\t\tpbo.setPrecision( 'high' );\n\n\t\t\tattribute.pboNode = pbo;\n\t\t\tattribute.pbo = pbo.value;\n\n\t\t\tthis.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );\n\n\t\t}\n\n\t}\n\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true ) {\n\n\t\t\treturn shaderStage.charAt( 0 ) + '_' + node.name;\n\n\t\t}\n\n\t\treturn super.getPropertyName( node, shaderStage );\n\n\t}\n\n\tgeneratePBO( storageArrayElementNode ) {\n\n\t\tconst { node, indexNode } = storageArrayElementNode;\n\t\tconst attribute = node.value;\n\n\t\tif ( this.renderer.backend.has( attribute ) ) {\n\n\t\t\tconst attributeData = this.renderer.backend.get( attribute );\n\t\t\tattributeData.pbo = attribute.pbo;\n\n\t\t}\n\n\t\tconst nodeUniform = this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );\n\t\tconst textureName = this.getPropertyName( nodeUniform );\n\n\t\tthis.increaseUsage( indexNode ); // force cache generate to be used as index in x,y\n\t\tconst indexSnippet = indexNode.build( this, 'uint' );\n\n\t\tconst elementNodeData = this.getDataFromNode( storageArrayElementNode );\n\n\t\tlet propertyName = elementNodeData.propertyName;\n\n\t\tif ( propertyName === undefined ) {\n\n\t\t\t// property element\n\n\t\t\tconst nodeVar = this.getVarFromNode( storageArrayElementNode );\n\n\t\t\tpropertyName = this.getPropertyName( nodeVar );\n\n\t\t\t// property size\n\n\t\t\tconst bufferNodeData = this.getDataFromNode( node );\n\n\t\t\tlet propertySizeName = bufferNodeData.propertySizeName;\n\n\t\t\tif ( propertySizeName === undefined ) {\n\n\t\t\t\tpropertySizeName = propertyName + 'Size';\n\n\t\t\t\tthis.getVarFromNode( node, propertySizeName, 'uint' );\n\n\t\t\t\tthis.addLineFlowCode( `${ propertySizeName } = uint( textureSize( ${ textureName }, 0 ).x )`, storageArrayElementNode );\n\n\t\t\t\tbufferNodeData.propertySizeName = propertySizeName;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst { itemSize } = attribute;\n\n\t\t\tconst channel = '.' + vectorComponents.join( '' ).slice( 0, itemSize );\n\t\t\tconst uvSnippet = `ivec2(${indexSnippet} % ${ propertySizeName }, ${indexSnippet} / ${ propertySizeName })`;\n\n\t\t\tconst snippet = this.generateTextureLoad( null, textureName, uvSnippet, null, '0' );\n\n\t\t\t//\n\n\n\t\t\tlet prefix = 'vec4';\n\n\t\t\tif ( attribute.pbo.type === UnsignedIntType ) {\n\n\t\t\t\tprefix = 'uvec4';\n\n\t\t\t} else if ( attribute.pbo.type === IntType ) {\n\n\t\t\t\tprefix = 'ivec4';\n\n\t\t\t}\n\n\t\t\tthis.addLineFlowCode( `${ propertyName } = ${prefix}(${ snippet })${channel}`, storageArrayElementNode );\n\n\t\t\telementNodeData.propertyName = propertyName;\n\n\t\t}\n\n\t\treturn propertyName;\n\n\t}\n\n\tgenerateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0' ) {\n\n\t\tif ( depthSnippet ) {\n\n\t\t\treturn `texelFetch( ${ textureProperty }, ivec3( ${ uvIndexSnippet }, ${ depthSnippet } ), ${ levelSnippet } )`;\n\n\t\t} else {\n\n\t\t\treturn `texelFetch( ${ textureProperty }, ${ uvIndexSnippet }, ${ levelSnippet } )`;\n\n\t\t}\n\n\t}\n\n\tgenerateTexture( texture, textureProperty, uvSnippet, depthSnippet ) {\n\n\t\tif ( texture.isDepthTexture ) {\n\n\t\t\treturn `texture( ${ textureProperty }, ${ uvSnippet } ).x`;\n\n\t\t} else {\n\n\t\t\tif ( depthSnippet ) uvSnippet = `vec3( ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\t\treturn `texture( ${ textureProperty }, ${ uvSnippet } )`;\n\n\t\t}\n\n\t}\n\n\tgenerateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet ) {\n\n\t\treturn `textureLod( ${ textureProperty }, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t}\n\n\tgenerateTextureBias( texture, textureProperty, uvSnippet, biasSnippet ) {\n\n\t\treturn `texture( ${ textureProperty }, ${ uvSnippet }, ${ biasSnippet } )`;\n\n\t}\n\n\tgenerateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet ) {\n\n\t\treturn `textureGrad( ${ textureProperty }, ${ uvSnippet }, ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;\n\n\t}\n\n\tgenerateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `texture( ${ textureProperty }, vec3( ${ uvSnippet }, ${ compareSnippet } ) )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippets.push( `${ this.getVar( variable.type, variable.name ) };` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\t' );\n\n\t}\n\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst uniformGroups = {};\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tlet snippet = null;\n\t\t\tlet group = false;\n\n\t\t\tif ( uniform.type === 'texture' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tlet typePrefix = '';\n\n\t\t\t\tif ( texture.isDataTexture === true ) {\n\n\n\t\t\t\t\tif ( texture.type === UnsignedIntType ) {\n\n\t\t\t\t\t\ttypePrefix = 'u';\n\n\t\t\t\t\t} else if ( texture.type === IntType ) {\n\n\t\t\t\t\t\ttypePrefix = 'i';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.compareFunction ) {\n\n\t\t\t\t\tsnippet = `sampler2DShadow ${ uniform.name };`;\n\n\t\t\t\t} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler2DArray ${ uniform.name };`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler2D ${ uniform.name };`;\n\n\t\t\t\t}\n\n\t\t\t} else if ( uniform.type === 'cubeTexture' ) {\n\n\t\t\t\tsnippet = `samplerCube ${ uniform.name };`;\n\n\t\t\t} else if ( uniform.type === 'texture3D' ) {\n\n\t\t\t\tsnippet = `sampler3D ${ uniform.name };`;\n\n\t\t\t} else if ( uniform.type === 'buffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.bufferType );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 ? bufferCount : '';\n\t\t\t\tsnippet = `${bufferNode.name} {\\n\\t${ bufferType } ${ uniform.name }[${ bufferCountSnippet }];\\n};\\n`;\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getVectorType( uniform.type );\n\n\t\t\t\tsnippet = `${ vectorType } ${ this.getPropertyName( uniform, shaderStage ) };`;\n\n\t\t\t\tgroup = true;\n\n\t\t\t}\n\n\t\t\tconst precision = uniform.node.precision;\n\n\t\t\tif ( precision !== null ) {\n\n\t\t\t\tsnippet = precisionLib[ precision ] + ' ' + snippet;\n\n\t\t\t}\n\n\t\t\tif ( group ) {\n\n\t\t\t\tsnippet = '\\t' + snippet;\n\n\t\t\t\tconst groupName = uniform.groupNode.name;\n\t\t\t\tconst groupSnippets = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = [] );\n\n\t\t\t\tgroupSnippets.push( snippet );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = 'uniform ' + snippet;\n\n\t\t\t\tbindingSnippets.push( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet output = '';\n\n\t\tfor ( const name in uniformGroups ) {\n\n\t\t\tconst groupSnippets = uniformGroups[ name ];\n\n\t\t\toutput += this._getGLSLUniformStruct( shaderStage + '_' + name, groupSnippets.join( '\\n' ) ) + '\\n';\n\n\t\t}\n\n\t\toutput += bindingSnippets.join( '\\n' );\n\n\t\treturn output;\n\n\t}\n\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet nodeType = super.getTypeFromAttribute( attribute );\n\n\t\tif ( /^[iu]/.test( nodeType ) && attribute.gpuType !== IntType ) {\n\n\t\t\tlet dataAttribute = attribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\t\tconst array = dataAttribute.array;\n\n\t\t\tif ( ( array instanceof Uint32Array || array instanceof Int32Array ) === false ) {\n\n\t\t\t\tnodeType = nodeType.slice( 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\tgetAttributes( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tlet location = 0;\n\n\t\t\tfor ( const attribute of attributes ) {\n\n\t\t\t\tsnippet += `layout( location = ${ location ++ } ) in ${ attribute.type } ${ attribute.name };\\n`;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\t\tconst members = struct.getMemberTypes();\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\tconst member = members[ i ];\n\t\t\tsnippets.push( `layout( location = ${i} ) out ${ member} m${i};` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\tgetStructs( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tif ( structs.length === 0 ) {\n\n\t\t\treturn 'layout( location = 0 ) out vec4 fragColor;\\n';\n\n\t\t}\n\n\t\tfor ( let index = 0, length = structs.length; index < length; index ++ ) {\n\n\t\t\tconst struct = structs[ index ];\n\n\t\t\tlet snippet = '\\n';\n\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\tsnippet += '\\n';\n\n\t\t\tsnippets.push( snippet );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\n' );\n\n\t}\n\n\tgetVaryings( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst varyings = this.varyings;\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( shaderStage === 'compute' ) varying.needsInterpolation = true;\n\t\t\t\tconst type = this.getType( varying.type );\n\t\t\t\tconst flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';\n\n\t\t\t\tsnippet += `${flat}${varying.needsInterpolation ? 'out' : '/*out*/'} ${type} ${varying.name};\\n`;\n\n\t\t\t}\n\n\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tconst type = this.getType( varying.type );\n\t\t\t\t\tconst flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';\n\n\t\t\t\t\tsnippet += `${flat}in ${type} ${varying.name};\\n`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const builtin of this.builtins[ shaderStage ] ) {\n\n\t\t\tsnippet += `${builtin};\\n`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\treturn 'uint( gl_VertexID )';\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\treturn 'uint( gl_InstanceID )';\n\n\t}\n\n\tgetInvocationLocalIndex() {\n\n\t\tconst workgroupSize = this.object.workgroupSize;\n\n\t\tconst size = workgroupSize.reduce( ( acc, curr ) => acc * curr, 1 );\n\n\t\treturn `uint( gl_InstanceID ) % ${size}u`;\n\n\t}\n\n\tgetDrawIndex() {\n\n\t\tconst extensions = this.renderer.backend.extensions;\n\n\t\tif ( extensions.has( 'WEBGL_multi_draw' ) ) {\n\n\t\t\treturn 'uint( gl_DrawID )';\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\treturn 'gl_FrontFacing';\n\n\t}\n\n\tgetFragCoord() {\n\n\t\treturn 'gl_FragCoord.xy';\n\n\t}\n\n\tgetFragDepth() {\n\n\t\treturn 'gl_FragDepth';\n\n\t}\n\n\tenableExtension( name, behavior, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.extensions[ shaderStage ] || ( this.extensions[ shaderStage ] = new Map() );\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tbehavior\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tgetExtensions( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tconst ext = this.renderer.backend.extensions;\n\t\t\tconst isBatchedMesh = this.object.isBatchedMesh;\n\n\t\t\tif ( isBatchedMesh && ext.has( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\tthis.enableExtension( 'GL_ANGLE_multi_draw', 'require', shaderStage );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensions = this.extensions[ shaderStage ];\n\n\t\tif ( extensions !== undefined ) {\n\n\t\t\tfor ( const { name, behavior } of extensions.values() ) {\n\n\t\t\t\tsnippets.push( `#extension ${name} : ${behavior}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\tgetClipDistance() {\n\n\t\treturn 'gl_ClipDistance';\n\n\t}\n\n\tisAvailable( name ) {\n\n\t\tlet result = supports$1[ name ];\n\n\t\tif ( result === undefined ) {\n\n\t\t\tlet extensionName;\n\n\t\t\tresult = false;\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'float32Filterable':\n\t\t\t\t\textensionName = 'OES_texture_float_linear';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'clipDistance':\n\t\t\t\t\textensionName = 'WEBGL_clip_cull_distance';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( extensionName !== undefined ) {\n\n\t\t\t\tconst extensions = this.renderer.backend.extensions;\n\n\t\t\t\tif ( extensions.has( extensionName ) ) {\n\n\t\t\t\t\textensions.get( extensionName );\n\t\t\t\t\tresult = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tsupports$1[ name ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn true;\n\n\t}\n\n\tenableHardwareClipping( planeCount ) {\n\n\t\tthis.enableExtension( 'GL_ANGLE_clip_cull_distance', 'require' );\n\n\t\tthis.builtins[ 'vertex' ].push( `out float gl_ClipDistance[ ${ planeCount } ]` );\n\n\t}\n\n\tregisterTransform( varyingName, attributeNode ) {\n\n\t\tthis.transforms.push( { varyingName, attributeNode } );\n\n\t}\n\n\tgetTransforms( /* shaderStage  */ ) {\n\n\t\tconst transforms = this.transforms;\n\n\t\tlet snippet = '';\n\n\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\tconst transform = transforms[ i ];\n\n\t\t\tconst attributeName = this.getPropertyName( transform.attributeNode );\n\n\t\t\tsnippet += `${ transform.varyingName } = ${ attributeName };\\n\\t`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t_getGLSLUniformStruct( name, vars ) {\n\n\t\treturn `\nlayout( std140 ) uniform ${name} {\n${vars}\n};`;\n\n\t}\n\n\t_getGLSLVertexCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// extensions \n${shaderData.extensions}\n\n// precision\n${ defaultPrecisions }\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// attributes\n${shaderData.attributes}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// transforms\n\t${shaderData.transforms}\n\n\t// flow\n\t${shaderData.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`;\n\n\t}\n\n\t_getGLSLFragmentCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// precision\n${ defaultPrecisions }\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\n${shaderData.structs}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tthis.sortBindingGroups();\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n\\t`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += 'gl_Position = ';\n\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( ! node.outputNode.isOutputStructNode ) {\n\n\t\t\t\t\t\t\tflow += 'fragColor = ';\n\t\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\n\t\t\tstageData.extensions = this.getExtensions( shaderStage );\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.transforms = this.getTransforms( shaderStage );\n\t\t\tstageData.flow = flow;\n\n\t\t}\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getGLSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getGLSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\tthis.computeShader = this._getGLSLVertexCode( shadersData.compute );\n\n\t\t}\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet uniformGPU = nodeData.uniformGPU;\n\n\t\tif ( uniformGPU === undefined ) {\n\n\t\t\tconst group = node.groupNode;\n\t\t\tconst groupName = group.name;\n\n\t\t\tconst bindings = this.getBindGroupArray( groupName, shaderStage );\n\n\t\t\tif ( type === 'texture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'texture3D' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'buffer' ) {\n\n\t\t\t\tnode.name = `NodeBuffer_${ node.id }`;\n\t\t\t\tuniformNode.name = `buffer${ node.id }`;\n\n\t\t\t\tconst buffer = new NodeUniformBuffer( node, group );\n\t\t\t\tbuffer.name = node.name;\n\n\t\t\t\tbindings.push( buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t} else {\n\n\t\t\t\tconst uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );\n\n\t\t\t\tlet uniformsGroup = uniformsStage[ groupName ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new NodeUniformsGroup( shaderStage + '_' + groupName, group );\n\t\t\t\t\t//uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tuniformsStage[ groupName ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n}\n\nlet vector2 = null;\nlet vector4 = null;\nlet color4 = null;\n\nclass Backend {\n\n\tconstructor( parameters = {} ) {\n\n\t\tthis.parameters = Object.assign( {}, parameters );\n\t\tthis.data = new WeakMap();\n\t\tthis.renderer = null;\n\t\tthis.domElement = null;\n\n\t}\n\n\tasync init( renderer ) {\n\n\t\tthis.renderer = renderer;\n\n\t}\n\n\t// render context\n\n\tbegin( /*renderContext*/ ) { }\n\n\tfinish( /*renderContext*/ ) { }\n\n\t// render object\n\n\tdraw( /*renderObject, info*/ ) { }\n\n\t// program\n\n\tcreateProgram( /*program*/ ) { }\n\n\tdestroyProgram( /*program*/ ) { }\n\n\t// bindings\n\n\tcreateBindings( /*bingGroup, bindings*/ ) { }\n\n\tupdateBindings( /*bingGroup, bindings*/ ) { }\n\n\t// pipeline\n\n\tcreateRenderPipeline( /*renderObject*/ ) { }\n\n\tcreateComputePipeline( /*computeNode, pipeline*/ ) { }\n\n\tdestroyPipeline( /*pipeline*/ ) { }\n\n\t// cache key\n\n\tneedsRenderUpdate( /*renderObject*/ ) { } // return Boolean ( fast test )\n\n\tgetRenderCacheKey( /*renderObject*/ ) { } // return String\n\n\t// node builder\n\n\tcreateNodeBuilder( /*renderObject*/ ) { } // return NodeBuilder (ADD IT)\n\n\t// textures\n\n\tcreateSampler( /*texture*/ ) { }\n\n\tcreateDefaultTexture( /*texture*/ ) { }\n\n\tcreateTexture( /*texture*/ ) { }\n\n\tcopyTextureToBuffer( /*texture, x, y, width, height*/ ) {}\n\n\t// attributes\n\n\tcreateAttribute( /*attribute*/ ) { }\n\n\tcreateIndexAttribute( /*attribute*/ ) { }\n\n\tupdateAttribute( /*attribute*/ ) { }\n\n\tdestroyAttribute( /*attribute*/ ) { }\n\n\t// canvas\n\n\tgetContext() { }\n\n\tupdateSize() { }\n\n\t// utils\n\n\tresolveTimestampAsync( /*renderContext, type*/ ) { }\n\n\thasFeatureAsync( /*name*/ ) { } // return Boolean\n\n\thasFeature( /*name*/ ) { } // return Boolean\n\n\tgetInstanceCount( renderObject ) {\n\n\t\tconst { object, geometry } = renderObject;\n\n\t\treturn geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.count > 1 ? object.count : 1 );\n\n\t}\n\n\tgetDrawingBufferSize() {\n\n\t\tvector2 = vector2 || new Vector2();\n\n\t\treturn this.renderer.getDrawingBufferSize( vector2 );\n\n\t}\n\n\tgetScissor() {\n\n\t\tvector4 = vector4 || new Vector4();\n\n\t\treturn this.renderer.getScissor( vector4 );\n\n\t}\n\n\tsetScissorTest( /*boolean*/ ) { }\n\n\tgetClearColor() {\n\n\t\tconst renderer = this.renderer;\n\n\t\tcolor4 = color4 || new Color4();\n\n\t\trenderer.getClearColor( color4 );\n\n\t\tcolor4.getRGB( color4, this.renderer.currentColorSpace );\n\n\t\treturn color4;\n\n\t}\n\n\tgetDomElement() {\n\n\t\tlet domElement = this.domElement;\n\n\t\tif ( domElement === null ) {\n\n\t\t\tdomElement = ( this.parameters.canvas !== undefined ) ? this.parameters.canvas : createCanvasElement();\n\n\t\t\t// OffscreenCanvas does not have setAttribute, see #22811\n\t\t\tif ( 'setAttribute' in domElement ) domElement.setAttribute( 'data-engine', `three.js r${REVISION} webgpu` );\n\n\t\t\tthis.domElement = domElement;\n\n\t\t}\n\n\t\treturn domElement;\n\n\t}\n\n\t// resource properties\n\n\tset( object, value ) {\n\n\t\tthis.data.set( object, value );\n\n\t}\n\n\tget( object ) {\n\n\t\tlet map = this.data.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tthis.data.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\thas( object ) {\n\n\t\treturn this.data.has( object );\n\n\t}\n\n\tdelete( object ) {\n\n\t\tthis.data.delete( object );\n\n\t}\n\n\tdispose() { }\n\n}\n\nlet _id$1 = 0;\n\nclass DualAttributeData {\n\n\tconstructor( attributeData, dualBuffer ) {\n\n\t\tthis.buffers = [ attributeData.bufferGPU, dualBuffer ];\n\t\tthis.type = attributeData.type;\n\t\tthis.bufferType = attributeData.bufferType;\n\t\tthis.pbo = attributeData.pbo;\n\t\tthis.byteLength = attributeData.byteLength;\n\t\tthis.bytesPerElement = attributeData.BYTES_PER_ELEMENT;\n\t\tthis.version = attributeData.version;\n\t\tthis.isInteger = attributeData.isInteger;\n\t\tthis.activeBufferIndex = 0;\n\t\tthis.baseId = attributeData.id;\n\n\t}\n\n\n\tget id() {\n\n\t\treturn `${ this.baseId }|${ this.activeBufferIndex }`;\n\n\t}\n\n\tget bufferGPU() {\n\n\t\treturn this.buffers[ this.activeBufferIndex ];\n\n\t}\n\n\tget transformBuffer() {\n\n\t\treturn this.buffers[ this.activeBufferIndex ^ 1 ];\n\n\t}\n\n\tswitchBuffers() {\n\n\t\tthis.activeBufferIndex ^= 1;\n\n\t}\n\n}\n\nclass WebGLAttributeUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t}\n\n\tcreateAttribute( attribute, bufferType ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst array = attribute.array;\n\t\tconst usage = attribute.usage || gl.STATIC_DRAW;\n\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\n\t\tlet bufferGPU = bufferData.bufferGPU;\n\n\t\tif ( bufferGPU === undefined ) {\n\n\t\t\tbufferGPU = this._createBuffer( gl, bufferType, array, usage );\n\n\t\t\tbufferData.bufferGPU = bufferGPU;\n\t\t\tbufferData.bufferType = bufferType;\n\t\t\tbufferData.version = bufferAttribute.version;\n\n\t\t}\n\n\t\t//attribute.onUploadCallback();\n\n\t\tlet type;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = gl.FLOAT;\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\tif ( attribute.isFloat16BufferAttribute ) {\n\n\t\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\n\t\t\t}\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = gl.SHORT;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = gl.UNSIGNED_INT;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = gl.INT;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = gl.BYTE;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else if ( array instanceof Uint8ClampedArray ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.WebGLBackend: Unsupported buffer data format: ' + array );\n\n\t\t}\n\n\t\tlet attributeData = {\n\t\t\tbufferGPU,\n\t\t\tbufferType,\n\t\t\ttype,\n\t\t\tbyteLength: array.byteLength,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version,\n\t\t\tpbo: attribute.pbo,\n\t\t\tisInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,\n\t\t\tid: _id$1 ++\n\t\t};\n\n\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {\n\n\t\t\t// create buffer for tranform feedback use\n\t\t\tconst bufferGPUDual = this._createBuffer( gl, bufferType, array, usage );\n\t\t\tattributeData = new DualAttributeData( attributeData, bufferGPUDual );\n\n\t\t}\n\n\t\tbackend.set( attribute, attributeData );\n\n\t}\n\n\tupdateAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst array = attribute.array;\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\t\tconst bufferType = bufferData.bufferType;\n\t\tconst updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;\n\n\t\tgl.bindBuffer( bufferType, bufferData.bufferGPU );\n\n\t\tif ( updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\t\t\t\tgl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray, range.start, range.count );\n\n\t\t\t}\n\n\t\t\tbufferAttribute.clearUpdateRanges();\n\n\t\t}\n\n\t\tgl.bindBuffer( bufferType, null );\n\n\t\tbufferData.version = bufferAttribute.version;\n\n\t}\n\n\tdestroyAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tbackend.delete( attribute.data );\n\n\t\t}\n\n\t\tconst attributeData = backend.get( attribute );\n\n\t\tgl.deleteBuffer( attributeData.bufferGPU );\n\n\t\tbackend.delete( attribute );\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst { bufferGPU } = backend.get( bufferAttribute );\n\n\t\tconst array = attribute.array;\n\t\tconst byteLength = array.byteLength;\n\n\t\tgl.bindBuffer( gl.COPY_READ_BUFFER, bufferGPU );\n\n\t\tconst writeBuffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );\n\t\tgl.bufferData( gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ );\n\n\t\tgl.copyBufferSubData( gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength );\n\n\t\tawait backend.utils._clientWaitAsync();\n\n\t\tconst dstBuffer = new attribute.array.constructor( array.length );\n\n\t\t// Ensure the buffer is bound before reading\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );\n\n\t\tgl.getBufferSubData( gl.COPY_WRITE_BUFFER, 0, dstBuffer );\n\n\t\tgl.deleteBuffer( writeBuffer );\n\n\t\tgl.bindBuffer( gl.COPY_READ_BUFFER, null );\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, null );\n\n\t\treturn dstBuffer.buffer;\n\n\t}\n\n\t_createBuffer( gl, bufferType, array, usage ) {\n\n\t\tconst bufferGPU = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, bufferGPU );\n\t\tgl.bufferData( bufferType, array, usage );\n\t\tgl.bindBuffer( bufferType, null );\n\n\t\treturn bufferGPU;\n\n\t}\n\n}\n\nlet initialized$1 = false, equationToGL, factorToGL;\n\nclass WebGLState {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.gl = this.backend.gl;\n\n\t\tthis.enabled = {};\n\t\tthis.currentFlipSided = null;\n\t\tthis.currentCullFace = null;\n\t\tthis.currentProgram = null;\n\t\tthis.currentBlendingEnabled = false;\n\t\tthis.currentBlending = null;\n\t\tthis.currentBlendSrc = null;\n\t\tthis.currentBlendDst = null;\n\t\tthis.currentBlendSrcAlpha = null;\n\t\tthis.currentBlendDstAlpha = null;\n\t\tthis.currentPremultipledAlpha = null;\n\t\tthis.currentPolygonOffsetFactor = null;\n\t\tthis.currentPolygonOffsetUnits = null;\n\t\tthis.currentColorMask = null;\n\t\tthis.currentDepthFunc = null;\n\t\tthis.currentDepthMask = null;\n\t\tthis.currentStencilFunc = null;\n\t\tthis.currentStencilRef = null;\n\t\tthis.currentStencilFuncMask = null;\n\t\tthis.currentStencilFail = null;\n\t\tthis.currentStencilZFail = null;\n\t\tthis.currentStencilZPass = null;\n\t\tthis.currentStencilMask = null;\n\t\tthis.currentLineWidth = null;\n\t\tthis.currentClippingPlanes = 0;\n\n\t\tthis.currentBoundFramebuffers = {};\n\t\tthis.currentDrawbuffers = new WeakMap();\n\n\t\tthis.maxTextures = this.gl.getParameter( this.gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\tthis.currentTextureSlot = null;\n\t\tthis.currentBoundTextures = {};\n\t\tthis.currentBoundBufferBases = {};\n\n\t\tif ( initialized$1 === false ) {\n\n\t\t\tthis._init( this.gl );\n\n\t\t\tinitialized$1 = true;\n\n\t\t}\n\n\t}\n\n\t_init( gl ) {\n\n\t\t// Store only WebGL constants here.\n\n\t\tequationToGL = {\n\t\t\t[ AddEquation ]: gl.FUNC_ADD,\n\t\t\t[ SubtractEquation ]: gl.FUNC_SUBTRACT,\n\t\t\t[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT\n\t\t};\n\n\t\tfactorToGL = {\n\t\t\t[ ZeroFactor ]: gl.ZERO,\n\t\t\t[ OneFactor ]: gl.ONE,\n\t\t\t[ SrcColorFactor ]: gl.SRC_COLOR,\n\t\t\t[ SrcAlphaFactor ]: gl.SRC_ALPHA,\n\t\t\t[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,\n\t\t\t[ DstColorFactor ]: gl.DST_COLOR,\n\t\t\t[ DstAlphaFactor ]: gl.DST_ALPHA,\n\t\t\t[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,\n\t\t\t[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,\n\t\t\t[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,\n\t\t\t[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA\n\t\t};\n\n\t}\n\n\tenable( id ) {\n\n\t\tconst { enabled } = this;\n\n\t\tif ( enabled[ id ] !== true ) {\n\n\t\t\tthis.gl.enable( id );\n\t\t\tenabled[ id ] = true;\n\n\t\t}\n\n\t}\n\n\tdisable( id ) {\n\n\t\tconst { enabled } = this;\n\n\t\tif ( enabled[ id ] !== false ) {\n\n\t\t\tthis.gl.disable( id );\n\t\t\tenabled[ id ] = false;\n\n\t\t}\n\n\t}\n\n\tsetFlipSided( flipSided ) {\n\n\t\tif ( this.currentFlipSided !== flipSided ) {\n\n\t\t\tconst { gl } = this;\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tthis.currentFlipSided = flipSided;\n\n\t\t}\n\n\t}\n\n\tsetCullFace( cullFace ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\tthis.enable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== this.currentCullFace ) {\n\n\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tthis.currentCullFace = cullFace;\n\n\t}\n\n\tsetLineWidth( width ) {\n\n\t\tconst { currentLineWidth, gl } = this;\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tgl.lineWidth( width );\n\n\t\t\tthis.currentLineWidth = width;\n\n\t\t}\n\n\t}\n\n\n\tsetBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( blending === NoBlending ) {\n\n\t\t\tif ( this.currentBlendingEnabled === true ) {\n\n\t\t\t\tthis.disable( gl.BLEND );\n\t\t\t\tthis.currentBlendingEnabled = false;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.currentBlendingEnabled === false ) {\n\n\t\t\tthis.enable( gl.BLEND );\n\t\t\tthis.currentBlendingEnabled = true;\n\n\t\t}\n\n\t\tif ( blending !== CustomBlending ) {\n\n\t\t\tif ( blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha ) {\n\n\t\t\t\tif ( this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation ) {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\n\t\t\t\t\tthis.currentBlendEquation = AddEquation;\n\t\t\t\t\tthis.currentBlendEquationAlpha = AddEquation;\n\n\t\t\t\t}\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ONE, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.currentBlendSrc = null;\n\t\t\t\tthis.currentBlendDst = null;\n\t\t\t\tthis.currentBlendSrcAlpha = null;\n\t\t\t\tthis.currentBlendDstAlpha = null;\n\n\t\t\t\tthis.currentBlending = blending;\n\t\t\t\tthis.currentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// custom blending\n\n\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\tif ( blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha ) {\n\n\t\t\tgl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );\n\n\t\t\tthis.currentBlendEquation = blendEquation;\n\t\t\tthis.currentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t}\n\n\t\tif ( blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha ) {\n\n\t\t\tgl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );\n\n\t\t\tthis.currentBlendSrc = blendSrc;\n\t\t\tthis.currentBlendDst = blendDst;\n\t\t\tthis.currentBlendSrcAlpha = blendSrcAlpha;\n\t\t\tthis.currentBlendDstAlpha = blendDstAlpha;\n\n\t\t}\n\n\t\tthis.currentBlending = blending;\n\t\tthis.currentPremultipledAlpha = false;\n\n\t}\n\n\tsetColorMask( colorMask ) {\n\n\t\tif ( this.currentColorMask !== colorMask ) {\n\n\t\t\tthis.gl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\tthis.currentColorMask = colorMask;\n\n\t\t}\n\n\t}\n\n\tsetDepthTest( depthTest ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( depthTest ) {\n\n\t\t\tthis.enable( gl.DEPTH_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.DEPTH_TEST );\n\n\t\t}\n\n\t}\n\n\tsetDepthMask( depthMask ) {\n\n\t\tif ( this.currentDepthMask !== depthMask ) {\n\n\t\t\tthis.gl.depthMask( depthMask );\n\t\t\tthis.currentDepthMask = depthMask;\n\n\t\t}\n\n\t}\n\n\tsetDepthFunc( depthFunc ) {\n\n\t\tif ( this.currentDepthFunc !== depthFunc ) {\n\n\t\t\tconst { gl } = this;\n\n\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t}\n\n\t\t\tthis.currentDepthFunc = depthFunc;\n\n\t\t}\n\n\t}\n\n\tsetStencilTest( stencilTest ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( stencilTest ) {\n\n\t\t\tthis.enable( gl.STENCIL_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.STENCIL_TEST );\n\n\t\t}\n\n\t}\n\n\tsetStencilMask( stencilMask ) {\n\n\t\tif ( this.currentStencilMask !== stencilMask ) {\n\n\t\t\tthis.gl.stencilMask( stencilMask );\n\t\t\tthis.currentStencilMask = stencilMask;\n\n\t\t}\n\n\t}\n\n\tsetStencilFunc( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tif ( this.currentStencilFunc !== stencilFunc ||\n\t\t\t this.currentStencilRef !== stencilRef ||\n\t\t\t this.currentStencilFuncMask !== stencilMask ) {\n\n\t\t\tthis.gl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t\tthis.currentStencilFunc = stencilFunc;\n\t\t\tthis.currentStencilRef = stencilRef;\n\t\t\tthis.currentStencilFuncMask = stencilMask;\n\n\t\t}\n\n\t}\n\n\tsetStencilOp( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tif ( this.currentStencilFail !== stencilFail ||\n\t\t\t this.currentStencilZFail !== stencilZFail ||\n\t\t\t this.currentStencilZPass !== stencilZPass ) {\n\n\t\t\tthis.gl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t\tthis.currentStencilFail = stencilFail;\n\t\t\tthis.currentStencilZFail = stencilZFail;\n\t\t\tthis.currentStencilZPass = stencilZPass;\n\n\t\t}\n\n\t}\n\n\tsetMaterial( material, frontFaceCW, hardwareClippingPlanes ) {\n\n\t\tconst { gl } = this;\n\n\t\tmaterial.side === DoubleSide\n\t\t\t? this.disable( gl.CULL_FACE )\n\t\t\t: this.enable( gl.CULL_FACE );\n\n\t\tlet flipSided = ( material.side === BackSide );\n\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\n\t\tthis.setFlipSided( flipSided );\n\n\t\t( material.blending === NormalBlending && material.transparent === false )\n\t\t\t? this.setBlending( NoBlending )\n\t\t\t: this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\tthis.setDepthFunc( material.depthFunc );\n\t\tthis.setDepthTest( material.depthTest );\n\t\tthis.setDepthMask( material.depthWrite );\n\t\tthis.setColorMask( material.colorWrite );\n\n\t\tconst stencilWrite = material.stencilWrite;\n\t\tthis.setStencilTest( stencilWrite );\n\t\tif ( stencilWrite ) {\n\n\t\t\tthis.setStencilMask( material.stencilWriteMask );\n\t\t\tthis.setStencilFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );\n\t\t\tthis.setStencilOp( material.stencilFail, material.stencilZFail, material.stencilZPass );\n\n\t\t}\n\n\t\tthis.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\tmaterial.alphaToCoverage === true && this.backend.renderer.samples > 1\n\t\t\t? this.enable( gl.SAMPLE_ALPHA_TO_COVERAGE )\n\t\t\t: this.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );\n\n\t\tif ( hardwareClippingPlanes > 0 ) {\n\n\t\t\tif ( this.currentClippingPlanes !== hardwareClippingPlanes ) {\n\n\t\t\t\tconst CLIP_DISTANCE0_WEBGL = 0x3000;\n\n\t\t\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\t\t\tif ( i < hardwareClippingPlanes ) {\n\n\t\t\t\t\t\tthis.enable( CLIP_DISTANCE0_WEBGL + i );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.disable( CLIP_DISTANCE0_WEBGL + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetPolygonOffset( polygonOffset, factor, units ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tthis.currentPolygonOffsetFactor = factor;\n\t\t\t\tthis.currentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t}\n\n\tuseProgram( program ) {\n\n\t\tif ( this.currentProgram !== program ) {\n\n\t\t\tthis.gl.useProgram( program );\n\n\t\t\tthis.currentProgram = program;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// framebuffer\n\n\n\tbindFramebuffer( target, framebuffer ) {\n\n\t\tconst { gl, currentBoundFramebuffers } = this;\n\n\t\tif ( currentBoundFramebuffers[ target ] !== framebuffer ) {\n\n\t\t\tgl.bindFramebuffer( target, framebuffer );\n\n\t\t\tcurrentBoundFramebuffers[ target ] = framebuffer;\n\n\t\t\t// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\n\t\t\tif ( target === gl.DRAW_FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\tif ( target === gl.FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tdrawBuffers( renderContext, framebuffer ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet drawBuffers = [];\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tdrawBuffers = this.currentDrawbuffers.get( framebuffer );\n\n\t\t\tif ( drawBuffers === undefined ) {\n\n\t\t\t\tdrawBuffers = [];\n\t\t\t\tthis.currentDrawbuffers.set( framebuffer, drawBuffers );\n\n\t\t\t}\n\n\n\t\t\tconst textures = renderContext.textures;\n\n\t\t\tif ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {\n\n\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\tdrawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t}\n\n\t\t\t\tdrawBuffers.length = textures.length;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\tif ( drawBuffers[ 0 ] !== gl.BACK ) {\n\n\t\t\t\tdrawBuffers[ 0 ] = gl.BACK;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tgl.drawBuffers( drawBuffers );\n\n\t\t}\n\n\t}\n\n\n\t// texture\n\n\tactiveTexture( webglSlot ) {\n\n\t\tconst { gl, currentTextureSlot, maxTextures } = this;\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tthis.currentTextureSlot = webglSlot;\n\n\t\t}\n\n\t}\n\n\tbindTexture( webglType, webglTexture, webglSlot ) {\n\n\t\tconst { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;\n\n\t\tif ( webglSlot === undefined ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\twebglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\t} else {\n\n\t\t\t\twebglSlot = currentTextureSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet boundTexture = currentBoundTextures[ webglSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ webglSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tthis.currentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t\tgl.bindTexture( webglType, webglTexture );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t}\n\n\tbindBufferBase( target, index, buffer ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst key = `${target}-${index}`;\n\n\t\tif ( this.currentBoundBufferBases[ key ] !== buffer ) {\n\n\t\t\tgl.bindBufferBase( target, index, buffer );\n\t\t\tthis.currentBoundBufferBases[ key ] = buffer;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\n\tunbindTexture() {\n\n\t\tconst { gl, currentTextureSlot, currentBoundTextures } = this;\n\n\t\tconst boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture !== undefined && boundTexture.type !== undefined ) {\n\n\t\t\tgl.bindTexture( boundTexture.type, null );\n\n\t\t\tboundTexture.type = undefined;\n\t\t\tboundTexture.texture = undefined;\n\n\t\t}\n\n\t}\n\n}\n\nclass WebGLUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.gl = this.backend.gl;\n\t\tthis.extensions = backend.extensions;\n\n\t}\n\n\tconvert( p, colorSpace = NoColorSpace ) {\n\n\t\tconst { gl, extensions } = this;\n\n\t\tlet extension;\n\n\t\tif ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;\n\t\tif ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;\n\n\t\tif ( p === ByteType ) return gl.BYTE;\n\t\tif ( p === ShortType ) return gl.SHORT;\n\t\tif ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;\n\t\tif ( p === IntType ) return gl.INT;\n\t\tif ( p === UnsignedIntType ) return gl.UNSIGNED_INT;\n\t\tif ( p === FloatType ) return gl.FLOAT;\n\n\t\tif ( p === HalfFloatType ) {\n\n\t\t\treturn gl.HALF_FLOAT;\n\n\t\t}\n\n\t\tif ( p === AlphaFormat ) return gl.ALPHA;\n\t\tif ( p === RGBFormat ) return gl.RGB;\n\t\tif ( p === RGBAFormat ) return gl.RGBA;\n\t\tif ( p === LuminanceFormat ) return gl.LUMINANCE;\n\t\tif ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;\n\t\tif ( p === DepthFormat ) return gl.DEPTH_COMPONENT;\n\t\tif ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;\n\n\t\t// WebGL2 formats.\n\n\t\tif ( p === RedFormat ) return gl.RED;\n\t\tif ( p === RedIntegerFormat ) return gl.RED_INTEGER;\n\t\tif ( p === RGFormat ) return gl.RG;\n\t\tif ( p === RGIntegerFormat ) return gl.RG_INTEGER;\n\t\tif ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;\n\n\t\t// S3TC\n\n\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\tif ( colorSpace === SRGBColorSpace ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// PVRTC\n\n\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ETC\n\n\t\tif ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;\n\t\t\t\tif ( p === RGBA_ETC2_EAC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ASTC\n\n\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\n\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\n\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\n\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\n\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_ASTC_4x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x12_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// BPTC\n\n\t\tif ( p === RGBA_BPTC_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_bptc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// RGTC\n\n\t\tif ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_rgtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n\t\t\t\tif ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\treturn gl.UNSIGNED_INT_24_8;\n\n\t\t}\n\n\t\t// if \"p\" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)\n\n\t\treturn ( gl[ p ] !== undefined ) ? gl[ p ] : null;\n\n\t}\n\n\t_clientWaitAsync() {\n\n\t\tconst { gl } = this;\n\n\t\tconst sync = gl.fenceSync( gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );\n\n\t\tgl.flush();\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tfunction test() {\n\n\t\t\t\tconst res = gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 );\n\n\t\t\t\tif ( res === gl.WAIT_FAILED ) {\n\n\t\t\t\t\tgl.deleteSync( sync );\n\n\t\t\t\t\treject();\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( res === gl.TIMEOUT_EXPIRED ) {\n\n\t\t\t\t\trequestAnimationFrame( test );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tgl.deleteSync( sync );\n\n\t\t\t\tresolve();\n\n\t\t\t}\n\n\t\t\ttest();\n\n\t\t} );\n\n\t}\n\n}\n\nlet initialized = false, wrappingToGL, filterToGL, compareToGL;\n\nclass WebGLTextureUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.gl = backend.gl;\n\t\tthis.extensions = backend.extensions;\n\t\tthis.defaultTextures = {};\n\n\t\tif ( initialized === false ) {\n\n\t\t\tthis._init( this.gl );\n\n\t\t\tinitialized = true;\n\n\t\t}\n\n\t}\n\n\t_init( gl ) {\n\n\t\t// Store only WebGL constants here.\n\n\t\twrappingToGL = {\n\t\t\t[ RepeatWrapping ]: gl.REPEAT,\n\t\t\t[ ClampToEdgeWrapping ]: gl.CLAMP_TO_EDGE,\n\t\t\t[ MirroredRepeatWrapping ]: gl.MIRRORED_REPEAT\n\t\t};\n\n\t\tfilterToGL = {\n\t\t\t[ NearestFilter ]: gl.NEAREST,\n\t\t\t[ NearestMipmapNearestFilter ]: gl.NEAREST_MIPMAP_NEAREST,\n\t\t\t[ NearestMipmapLinearFilter ]: gl.NEAREST_MIPMAP_LINEAR,\n\n\t\t\t[ LinearFilter ]: gl.LINEAR,\n\t\t\t[ LinearMipmapNearestFilter ]: gl.LINEAR_MIPMAP_NEAREST,\n\t\t\t[ LinearMipmapLinearFilter ]: gl.LINEAR_MIPMAP_LINEAR\n\t\t};\n\n\t\tcompareToGL = {\n\t\t\t[ NeverCompare ]: gl.NEVER,\n\t\t\t[ AlwaysCompare ]: gl.ALWAYS,\n\t\t\t[ LessCompare ]: gl.LESS,\n\t\t\t[ LessEqualCompare ]: gl.LEQUAL,\n\t\t\t[ EqualCompare ]: gl.EQUAL,\n\t\t\t[ GreaterEqualCompare ]: gl.GEQUAL,\n\t\t\t[ GreaterCompare ]: gl.GREATER,\n\t\t\t[ NotEqualCompare ]: gl.NOTEQUAL\n\t\t};\n\n\t}\n\n\tfilterFallback( f ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {\n\n\t\t\treturn gl.NEAREST;\n\n\t\t}\n\n\t\treturn gl.LINEAR;\n\n\t}\n\n\tgetGLTextureType( texture ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet glTextureType;\n\n\t\tif ( texture.isCubeTexture === true ) {\n\n\t\t\tglTextureType = gl.TEXTURE_CUBE_MAP;\n\n\t\t} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\tglTextureType = gl.TEXTURE_2D_ARRAY;\n\n\t\t} else if ( texture.isData3DTexture === true ) { // TODO: isCompressed3DTexture, wait for #26642\n\n\t\t\tglTextureType = gl.TEXTURE_3D;\n\n\t\t} else {\n\n\t\t\tglTextureType = gl.TEXTURE_2D;\n\n\n\t\t}\n\n\t\treturn glTextureType;\n\n\t}\n\n\tgetInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {\n\n\t\tconst { gl, extensions } = this;\n\n\t\tif ( internalFormatName !== null ) {\n\n\t\t\tif ( gl[ internalFormatName ] !== undefined ) return gl[ internalFormatName ];\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'' );\n\n\t\t}\n\n\t\tlet internalFormat = glFormat;\n\n\t\tif ( glFormat === gl.RED ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.R32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.R16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.R8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.R16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.R32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RED_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.R8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.R16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.R32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RG ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RG32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RG16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RG8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RG16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RG32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RG_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RG8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RG16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RG32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGB ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RGB32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGB16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGB8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGB16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGB32I;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8 : gl.RGB8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_6_5 ) internalFormat = gl.RGB565;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGB4;\n\t\t\tif ( glType === gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = gl.RGB9_E5;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGB_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGB8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGB16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGB32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGBA ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RGBA32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGBA16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGBA32I;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8_ALPHA8 : gl.RGBA8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGBA4;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGBA_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGBA32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.DEPTH_COMPONENT ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.DEPTH24_STENCIL8;\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.DEPTH_COMPONENT32F;\n\n\t\t}\n\n\t\tif ( glFormat === gl.DEPTH_STENCIL ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_INT_24_8 ) internalFormat = gl.DEPTH24_STENCIL8;\n\n\t\t}\n\n\t\tif ( internalFormat === gl.R16F || internalFormat === gl.R32F ||\n\t\t\tinternalFormat === gl.RG16F || internalFormat === gl.RG32F ||\n\t\t\tinternalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F ) {\n\n\t\t\textensions.get( 'EXT_color_buffer_float' );\n\n\t\t}\n\n\t\treturn internalFormat;\n\n\t}\n\n\tsetTextureParameters( textureType, texture ) {\n\n\t\tconst { gl, extensions, backend } = this;\n\n\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\tgl.pixelStorei( gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\tgl.pixelStorei( gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE );\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );\n\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );\n\n\t\tif ( textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );\n\n\t\t}\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );\n\n\n\t\tconst hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;\n\n\t\t// follow WebGPU backend mapping for texture filtering\n\t\tconst minFilter = texture.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture.minFilter;\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_MIN_FILTER, filterToGL[ minFilter ] );\n\n\t\tif ( texture.compareFunction ) {\n\n\t\t\tgl.texParameteri( textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE );\n\t\t\tgl.texParameteri( textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );\n\n\t\t}\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tif ( texture.magFilter === NearestFilter ) return;\n\t\t\tif ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;\n\t\t\tif ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2\n\n\t\t\tif ( texture.anisotropy > 1 ) {\n\n\t\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\t\t\tgl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, backend.getMaxAnisotropy() ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcreateDefaultTexture( texture ) {\n\n\t\tconst { gl, backend, defaultTextures } = this;\n\n\n\t\tconst glTextureType = this.getGLTextureType( texture );\n\n\t\tlet textureGPU = defaultTextures[ glTextureType ];\n\n\t\tif ( textureGPU === undefined ) {\n\n\t\t\ttextureGPU = gl.createTexture();\n\n\t\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\t\t\tgl.texParameteri( glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\t\t// gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\tdefaultTextures[ glTextureType ] = textureGPU;\n\n\t\t}\n\n\t\tbackend.set( texture, {\n\t\t\ttextureGPU,\n\t\t\tglTextureType,\n\t\t\tisDefault: true\n\t\t} );\n\n\t}\n\n\tcreateTexture( texture, options ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { levels, width, height, depth } = options;\n\n\t\tconst glFormat = backend.utils.convert( texture.format, texture.colorSpace );\n\t\tconst glType = backend.utils.convert( texture.type );\n\t\tconst glInternalFormat = this.getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );\n\n\t\tconst textureGPU = gl.createTexture();\n\t\tconst glTextureType = this.getGLTextureType( texture );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tthis.setTextureParameters( glTextureType, texture );\n\n\t\tif ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\tgl.texStorage3D( gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth );\n\n\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\tgl.texStorage3D( gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth );\n\n\t\t} else if ( ! texture.isVideoTexture ) {\n\n\t\t\tgl.texStorage2D( glTextureType, levels, glInternalFormat, width, height );\n\n\t\t}\n\n\t\tbackend.set( texture, {\n\t\t\ttextureGPU,\n\t\t\tglTextureType,\n\t\t\tglFormat,\n\t\t\tglType,\n\t\t\tglInternalFormat\n\t\t} );\n\n\t}\n\n\tcopyBufferToTexture( buffer, texture ) {\n\n\t\tconst { gl, backend } = this;\n\n\t\tconst { textureGPU, glTextureType, glFormat, glType } = backend.get( texture );\n\n\t\tconst { width, height } = texture.source.data;\n\n\t\tgl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, buffer );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, false );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );\n\t\tgl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, 0 );\n\n\t\tgl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, null );\n\n\t\tbackend.state.unbindTexture();\n\t\t// debug\n\t\t// const framebuffer = gl.createFramebuffer();\n\t\t// gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );\n\t\t// gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );\n\n\t\t// const readout = new Float32Array( width * height * 4 );\n\n\t\t// const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );\n\t\t// const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );\n\n\t\t// gl.readPixels( 0, 0, width, height, altFormat, altType, readout );\n\t\t// gl.bindFramebuffer( gl.FRAMEBUFFER, null );\n\t\t// console.log( readout );\n\n\t}\n\n\tupdateTexture( texture, options ) {\n\n\t\tconst { gl } = this;\n\t\tconst { width, height } = options;\n\t\tconst { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get( texture );\n\n\t\tif ( texture.isRenderTargetTexture || ( textureGPU === undefined /* unsupported texture format */ ) )\n\t\t\treturn;\n\n\t\tconst getImage = ( source ) => {\n\n\t\t\tif ( source.isDataTexture ) {\n\n\t\t\t\treturn source.image.data;\n\n\t\t\t} else if ( ( typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement ) ||\n\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement ) ||\n\t\t\t\t( typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap ) ||\n\t\t\t\tsource instanceof OffscreenCanvas ) {\n\n\t\t\t\treturn source;\n\n\t\t\t}\n\n\t\t\treturn source.data;\n\n\t\t};\n\n\t\tthis.backend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tthis.setTextureParameters( glTextureType, texture );\n\n\t\tif ( texture.isCompressedTexture ) {\n\n\t\t\tconst mipmaps = texture.mipmaps;\n\t\t\tconst image = options.image;\n\n\t\t\tfor ( let i = 0; i < mipmaps.length; i ++ ) {\n\n\t\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.isCompressedArrayTexture ) {\n\n\n\t\t\t\t\tif ( texture.format !== gl.RGBA ) {\n\n\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\tgl.compressedTexSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.texSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\tgl.compressedTexSubImage2D( gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'Unsupported compressed texture format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else if ( texture.isCubeTexture ) {\n\n\t\t\tconst images = options.images;\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tconst image = getImage( images[ i ] );\n\n\t\t\t\tgl.texSubImage2D( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image );\n\n\t\t\t}\n\n\t\t} else if ( texture.isDataArrayTexture ) {\n\n\t\t\tconst image = options.image;\n\n\t\t\tgl.texSubImage3D( gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\tconst image = options.image;\n\n\t\t\tgl.texSubImage3D( gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\ttexture.update();\n\n\t\t\tgl.texImage2D( glTextureType, 0, glInternalFormat, glFormat, glType, options.image );\n\n\n\t\t} else {\n\n\t\t\tconst image = getImage( options.image );\n\n\t\t\tgl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, image );\n\n\t\t}\n\n\t}\n\n\tgenerateMipmaps( texture ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { textureGPU, glTextureType } = backend.get( texture );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\t\tgl.generateMipmap( glTextureType );\n\n\t}\n\n\tdeallocateRenderBuffers( renderTarget ) {\n\n\t\tconst { gl, backend } = this;\n\n\t\t// remove framebuffer reference\n\t\tif ( renderTarget ) {\n\n\t\t\tconst renderContextData = backend.get( renderTarget );\n\n\t\t\trenderContextData.renderBufferStorageSetup = undefined;\n\n\t\t\tif ( renderContextData.framebuffers ) {\n\n\t\t\t\tfor ( const cacheKey in renderContextData.framebuffers ) {\n\n\t\t\t\t\tgl.deleteFramebuffer( renderContextData.framebuffers[ cacheKey ] );\n\n\t\t\t\t}\n\n\t\t\t\tdelete renderContextData.framebuffers;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.depthRenderbuffer ) {\n\n\t\t\t\tgl.deleteRenderbuffer( renderContextData.depthRenderbuffer );\n\t\t\t\tdelete renderContextData.depthRenderbuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.stencilRenderbuffer ) {\n\n\t\t\t\tgl.deleteRenderbuffer( renderContextData.stencilRenderbuffer );\n\t\t\t\tdelete renderContextData.stencilRenderbuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.msaaFrameBuffer ) {\n\n\t\t\t\tgl.deleteFramebuffer( renderContextData.msaaFrameBuffer );\n\t\t\t\tdelete renderContextData.msaaFrameBuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.msaaRenderbuffers ) {\n\n\t\t\t\tfor ( let i = 0; i < renderContextData.msaaRenderbuffers.length; i ++ ) {\n\n\t\t\t\t\tgl.deleteRenderbuffer( renderContextData.msaaRenderbuffers[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tdelete renderContextData.msaaRenderbuffers;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdestroyTexture( texture ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { textureGPU, renderTarget } = backend.get( texture );\n\n\t\tthis.deallocateRenderBuffers( renderTarget );\n\t\tgl.deleteTexture( textureGPU );\n\n\t\tbackend.delete( texture );\n\n\t}\n\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { state } = this.backend;\n\n\t\tconst { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get( dstTexture );\n\n\t\tlet width, height, minX, minY;\n\t\tlet dstX, dstY;\n\n\t\tif ( srcRegion !== null ) {\n\n\t\t\twidth = srcRegion.max.x - srcRegion.min.x;\n\t\t\theight = srcRegion.max.y - srcRegion.min.y;\n\t\t\tminX = srcRegion.min.x;\n\t\t\tminY = srcRegion.min.y;\n\n\t\t} else {\n\n\t\t\twidth = srcTexture.image.width;\n\t\t\theight = srcTexture.image.height;\n\t\t\tminX = 0;\n\t\t\tminY = 0;\n\n\t\t}\n\n\t\tif ( dstPosition !== null ) {\n\n\t\t\tdstX = dstPosition.x;\n\t\t\tdstY = dstPosition.y;\n\n\t\t} else {\n\n\t\t\tdstX = 0;\n\t\t\tdstY = 0;\n\n\t\t}\n\n\t\tstate.bindTexture( glTextureType, dstTextureGPU );\n\n\t\t// As another texture upload may have changed pixelStorei\n\t\t// parameters, make sure they are correct for the dstTexture\n\t\tgl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\tgl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\tconst currentUnpackRowLen = gl.getParameter( gl.UNPACK_ROW_LENGTH );\n\t\tconst currentUnpackImageHeight = gl.getParameter( gl.UNPACK_IMAGE_HEIGHT );\n\t\tconst currentUnpackSkipPixels = gl.getParameter( gl.UNPACK_SKIP_PIXELS );\n\t\tconst currentUnpackSkipRows = gl.getParameter( gl.UNPACK_SKIP_ROWS );\n\t\tconst currentUnpackSkipImages = gl.getParameter( gl.UNPACK_SKIP_IMAGES );\n\n\t\tconst image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;\n\n\t\tgl.pixelStorei( gl.UNPACK_ROW_LENGTH, image.width );\n\t\tgl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, image.height );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_PIXELS, minX );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_ROWS, minY );\n\n\t\tif ( srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture ) {\n\n\t\t\tconst srcTextureData = backend.get( srcTexture );\n\t\t\tconst dstTextureData = backend.get( dstTexture );\n\n\t\t\tconst srcRenderContextData = backend.get( srcTextureData.renderTarget );\n\t\t\tconst dstRenderContextData = backend.get( dstTextureData.renderTarget );\n\n\t\t\tconst srcFramebuffer = srcRenderContextData.framebuffers[ srcTextureData.cacheKey ];\n\t\t\tconst dstFramebuffer = dstRenderContextData.framebuffers[ dstTextureData.cacheKey ];\n\n\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, srcFramebuffer );\n\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, dstFramebuffer );\n\n\t\t\tlet mask = gl.COLOR_BUFFER_BIT;\n\n\t\t\tif ( srcTexture.isDepthTexture ) mask = gl.DEPTH_BUFFER_BIT;\n\n\t\t\tgl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, mask, gl.NEAREST );\n\n\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, null );\n\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );\n\n\t\t} else {\n\n\t\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t\tgl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data );\n\n\t\t\t} else {\n\n\t\t\t\tif ( srcTexture.isCompressedTexture ) {\n\n\t\t\t\t\tgl.compressedTexSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.pixelStorei( gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );\n\t\tgl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );\n\n\t\t// Generate mipmaps only when copying level 0\n\t\tif ( level === 0 && dstTexture.generateMipmaps ) gl.generateMipmap( gl.TEXTURE_2D );\n\n\t\tstate.unbindTexture();\n\n\t}\n\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tconst { gl } = this;\n\t\tconst { state } = this.backend;\n\n\t\tconst { textureGPU } = this.backend.get( texture );\n\n\t\tconst { x, y, z: width, w: height } = rectangle;\n\n\t\tconst requireDrawFrameBuffer = texture.isDepthTexture === true || ( renderContext.renderTarget && renderContext.renderTarget.samples > 0 );\n\n\t\tconst srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.gerDrawingBufferSize().y;\n\n\t\tif ( requireDrawFrameBuffer ) {\n\n\t\t\tconst partial = ( x !== 0 || y !== 0 );\n\t\t\tlet mask;\n\t\t\tlet attachment;\n\n\t\t\tif ( texture.isDepthTexture === true ) {\n\n\t\t\t\tmask = gl.DEPTH_BUFFER_BIT;\n\t\t\t\tattachment = gl.DEPTH_ATTACHMENT;\n\n\t\t\t\tif ( renderContext.stencil ) {\n\n\t\t\t\t\tmask |= gl.STENCIL_BUFFER_BIT;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tmask = gl.COLOR_BUFFER_BIT;\n\t\t\t\tattachment = gl.COLOR_ATTACHMENT0;\n\n\t\t\t}\n\n\t\t\tif ( partial ) {\n\n\t\t\t\tconst renderTargetContextData = this.backend.get( renderContext.renderTarget );\n\n\t\t\t\tconst fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];\n\t\t\t\tconst msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );\n\n\t\t\t\tconst flippedY = srcHeight - y - height;\n\n\t\t\t\tgl.blitFramebuffer( x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST );\n\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );\n\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, textureGPU );\n\n\t\t\t\tgl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height );\n\n\t\t\t\tstate.unbindTexture();\n\n\t\t\t} else {\n\n\t\t\t\tconst fb = gl.createFramebuffer();\n\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\n\t\t\t\tgl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0 );\n\t\t\t\tgl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST );\n\n\t\t\t\tgl.deleteFramebuffer( fb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, textureGPU );\n\t\t\tgl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height );\n\n\t\t\tstate.unbindTexture();\n\n\t\t}\n\n\t\tif ( texture.generateMipmaps ) this.generateMipmaps( texture );\n\n\t\tthis.backend._setFramebuffer( renderContext );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tsetupRenderBufferStorage( renderbuffer, renderContext ) {\n\n\t\tconst { gl } = this;\n\t\tconst renderTarget = renderContext.renderTarget;\n\n\t\tconst { samples, depthTexture, depthBuffer, stencilBuffer, width, height } = renderTarget;\n\n\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( depthBuffer && ! stencilBuffer ) {\n\n\t\t\tlet glInternalFormat = gl.DEPTH_COMPONENT24;\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tif ( depthTexture && depthTexture.isDepthTexture ) {\n\n\t\t\t\t\tif ( depthTexture.type === gl.FLOAT ) {\n\n\t\t\t\t\t\tglInternalFormat = gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, glInternalFormat, width, height );\n\n\t\t\t} else {\n\n\t\t\t\tgl.renderbufferStorage( gl.RENDERBUFFER, glInternalFormat, width, height );\n\n\t\t\t}\n\n\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else if ( depthBuffer && stencilBuffer ) {\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height );\n\n\t\t\t} else {\n\n\t\t\t\tgl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height );\n\n\t\t\t}\n\n\n\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );\n\n\t\t}\n\n\t}\n\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\tconst { backend, gl } = this;\n\n\t\tconst { textureGPU, glFormat, glType } = this.backend.get( texture );\n\n\t\tconst fb = gl.createFramebuffer();\n\n\t\tgl.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );\n\n\t\tconst target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;\n\n\t\tgl.framebufferTexture2D( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0 );\n\n\t\tconst typedArrayType = this._getTypedArrayType( glType );\n\t\tconst bytesPerTexel = this._getBytesPerTexel( glType, glFormat );\n\n\t\tconst elementCount = width * height;\n\t\tconst byteLength = elementCount * bytesPerTexel;\n\n\t\tconst buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );\n\t\tgl.bufferData( gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ );\n\t\tgl.readPixels( x, y, width, height, glFormat, glType, 0 );\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );\n\n\t\tawait backend.utils._clientWaitAsync();\n\n\t\tconst dstBuffer = new typedArrayType( byteLength / typedArrayType.BYTES_PER_ELEMENT );\n\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );\n\t\tgl.getBufferSubData( gl.PIXEL_PACK_BUFFER, 0, dstBuffer );\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );\n\n\t\tgl.deleteFramebuffer( fb );\n\n\t\treturn dstBuffer;\n\n\t}\n\n\t_getTypedArrayType( glType ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( glType === gl.UNSIGNED_BYTE ) return Uint8Array;\n\n\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT_5_6_5 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_INT ) return Uint32Array;\n\n\t\tif ( glType === gl.HALF_FLOAT ) return Uint16Array;\n\t\tif ( glType === gl.FLOAT ) return Float32Array;\n\n\t\tthrow new Error( `Unsupported WebGL type: ${glType}` );\n\n\t}\n\n\t_getBytesPerTexel( glType, glFormat ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet bytesPerComponent = 0;\n\n\t\tif ( glType === gl.UNSIGNED_BYTE ) bytesPerComponent = 1;\n\n\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ||\n\t\t\tglType === gl.UNSIGNED_SHORT_5_5_5_1 ||\n\t\t\tglType === gl.UNSIGNED_SHORT_5_6_5 ||\n\t\t\tglType === gl.UNSIGNED_SHORT ||\n\t\t\tglType === gl.HALF_FLOAT ) bytesPerComponent = 2;\n\n\t\tif ( glType === gl.UNSIGNED_INT ||\n\t\t\tglType === gl.FLOAT ) bytesPerComponent = 4;\n\n\t\tif ( glFormat === gl.RGBA ) return bytesPerComponent * 4;\n\t\tif ( glFormat === gl.RGB ) return bytesPerComponent * 3;\n\t\tif ( glFormat === gl.ALPHA ) return bytesPerComponent;\n\n\t}\n\n}\n\nclass WebGLExtensions {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.gl = this.backend.gl;\n\t\tthis.availableExtensions = this.gl.getSupportedExtensions();\n\n\t\tthis.extensions = {};\n\n\t}\n\n\tget( name ) {\n\n\t\tlet extension = this.extensions[ name ];\n\n\t\tif ( extension === undefined ) {\n\n\t\t\textension = this.gl.getExtension( name );\n\n\t\t\tthis.extensions[ name ] = extension;\n\n\t\t}\n\n\t\treturn extension;\n\n\t}\n\n\thas( name ) {\n\n\t\treturn this.availableExtensions.includes( name );\n\n\t}\n\n}\n\nclass WebGLCapabilities {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.maxAnisotropy = null;\n\n\t}\n\n\tgetMaxAnisotropy() {\n\n\t\tif ( this.maxAnisotropy !== null ) return this.maxAnisotropy;\n\n\t\tconst gl = this.backend.gl;\n\t\tconst extensions = this.backend.extensions;\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tthis.maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tthis.maxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn this.maxAnisotropy;\n\n\t}\n\n}\n\nconst GLFeatureName = {\n\n\t'WEBGL_multi_draw': 'WEBGL_multi_draw',\n\t'WEBGL_compressed_texture_astc': 'texture-compression-astc',\n\t'WEBGL_compressed_texture_etc': 'texture-compression-etc2',\n\t'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',\n\t'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n\t'WEBKIT_WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n\t'WEBGL_compressed_texture_s3tc': 'texture-compression-bc',\n\t'EXT_texture_compression_bptc': 'texture-compression-bptc',\n\t'EXT_disjoint_timer_query_webgl2': 'timestamp-query',\n\n};\n\nclass WebGLBufferRenderer {\n\n\tconstructor( backend ) {\n\n\t\tthis.gl = backend.gl;\n\t\tthis.extensions = backend.extensions;\n\t\tthis.info = backend.renderer.info;\n\t\tthis.mode = null;\n\t\tthis.index = 0;\n\t\tthis.type = null;\n\t\tthis.object = null;\n\n\t}\n\n\trender( start, count ) {\n\n\t\tconst { gl, mode, object, type, info, index } = this;\n\n\t\tif ( index !== 0 ) {\n\n\t\t\tgl.drawElements( mode, count, type, start );\n\n\t\t} else {\n\n\t\t\tgl.drawArrays( mode, start, count );\n\n\t\t}\n\n\t\tinfo.update( object, count, mode, 1 );\n\n\t}\n\n\trenderInstances( start, count, primcount ) {\n\n\t\tconst { gl, mode, type, index, object, info } = this;\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tif ( index !== 0 ) {\n\n\t\t\tgl.drawElementsInstanced( mode, count, type, start, primcount );\n\n\t\t} else {\n\n\t\t\tgl.drawArraysInstanced( mode, start, count, primcount );\n\n\t\t}\n\n\t\tinfo.update( object, count, mode, primcount );\n\n\t}\n\n\trenderMultiDraw( starts, counts, drawCount ) {\n\n\t\tconst { extensions, mode, object, info } = this;\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tthis.render( starts[ i ], counts[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.index !== 0 ) {\n\n\t\t\t\textension.multiDrawElementsWEBGL( mode, counts, 0, this.type, starts, 0, drawCount );\n\n\t\t\t} else {\n\n\t\t\t\textension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );\n\n\t\t\t}\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( object, elementCount, mode, 1 );\n\n\t\t}\n\n\t}\n\n\trenderMultiDrawInstances( starts, counts, drawCount, primcount ) {\n\n\t\tconst { extensions, mode, object, info } = this;\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tthis.renderInstances( starts[ i ], counts[ i ], primcount[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.index !== 0 ) {\n\n\t\t\t\textension.multiDrawElementsInstancedWEBGL( mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount );\n\n\t\t\t} else {\n\n\t\t\t\textension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );\n\n\t\t\t}\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ] * primcount[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( object, elementCount, mode, 1 );\n\n\t\t}\n\n\t}\n\n\t//\n\n}\n\n//\n\nclass WebGLBackend extends Backend {\n\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters );\n\n\t\tthis.isWebGLBackend = true;\n\n\t}\n\n\tinit( renderer ) {\n\n\t\tsuper.init( renderer );\n\n\t\t//\n\n\t\tconst parameters = this.parameters;\n\n\t\tconst glContext = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgl2' );\n\n\t \tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tconst contextLossInfo = {\n\t\t\t\tapi: 'WebGL',\n\t\t\t\tmessage: event.statusMessage || 'Unknown reason',\n\t\t\t\treason: null,\n\t\t\t\toriginalEvent: event\n\t\t\t};\n\n\t\t\trenderer.onDeviceLost( contextLossInfo );\n\n\t\t}\n\n\t\tthis._onContextLost = onContextLost;\n\n\t\trenderer.domElement.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\tthis.gl = glContext;\n\n\t\tthis.extensions = new WebGLExtensions( this );\n\t\tthis.capabilities = new WebGLCapabilities( this );\n\t\tthis.attributeUtils = new WebGLAttributeUtils( this );\n\t\tthis.textureUtils = new WebGLTextureUtils( this );\n\t\tthis.bufferRenderer = new WebGLBufferRenderer( this );\n\n\t\tthis.state = new WebGLState( this );\n\t\tthis.utils = new WebGLUtils( this );\n\n\t\tthis.vaoCache = {};\n\t\tthis.transformFeedbackCache = {};\n\t\tthis.discard = false;\n\t\tthis.trackTimestamp = ( parameters.trackTimestamp === true );\n\n\t\tthis.extensions.get( 'EXT_color_buffer_float' );\n\t\tthis.extensions.get( 'WEBGL_clip_cull_distance' );\n\t\tthis.extensions.get( 'OES_texture_float_linear' );\n\t\tthis.extensions.get( 'EXT_color_buffer_half_float' );\n\t\tthis.extensions.get( 'WEBGL_multisampled_render_to_texture' );\n\t\tthis.extensions.get( 'WEBGL_render_shared_exponent' );\n\t\tthis.extensions.get( 'WEBGL_multi_draw' );\n\n\t\tthis.disjoint = this.extensions.get( 'EXT_disjoint_timer_query_webgl2' );\n\t\tthis.parallel = this.extensions.get( 'KHR_parallel_shader_compile' );\n\n\t\tthis._knownBindings = new WeakSet();\n\n\t\tthis._currentContext = null;\n\n\t}\n\n\tget coordinateSystem() {\n\n\t\treturn WebGLCoordinateSystem;\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.attributeUtils.getArrayBufferAsync( attribute );\n\n\t}\n\n\tasync waitForGPU() {\n\n\t\tawait this.utils._clientWaitAsync();\n\n\t}\n\n\tinitTimestampQuery( renderContext ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( this.queryRunning ) {\n\n\t\t  if ( ! renderContextData.queryQueue ) renderContextData.queryQueue = [];\n\t\t  renderContextData.queryQueue.push( renderContext );\n\t\t  return;\n\n\t\t}\n\n\t\tif ( renderContextData.activeQuery ) {\n\n\t\t  this.gl.endQuery( this.disjoint.TIME_ELAPSED_EXT );\n\t\t  renderContextData.activeQuery = null;\n\n\t\t}\n\n\t\trenderContextData.activeQuery = this.gl.createQuery();\n\n\t\tif ( renderContextData.activeQuery !== null ) {\n\n\t\t  this.gl.beginQuery( this.disjoint.TIME_ELAPSED_EXT, renderContextData.activeQuery );\n\t\t  this.queryRunning = true;\n\n\t\t}\n\n\t}\n\n\t// timestamp utils\n\n\tprepareTimestampBuffer( renderContext ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( renderContextData.activeQuery ) {\n\n\t\t  this.gl.endQuery( this.disjoint.TIME_ELAPSED_EXT );\n\n\t\t  if ( ! renderContextData.gpuQueries ) renderContextData.gpuQueries = [];\n\t\t  renderContextData.gpuQueries.push( { query: renderContextData.activeQuery } );\n\t\t  renderContextData.activeQuery = null;\n\t\t  this.queryRunning = false;\n\n\t\t  if ( renderContextData.queryQueue && renderContextData.queryQueue.length > 0 ) {\n\n\t\t\t\tconst nextRenderContext = renderContextData.queryQueue.shift();\n\t\t\t\tthis.initTimestampQuery( nextRenderContext );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tasync resolveTimestampAsync( renderContext, type = 'render' ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( ! renderContextData.gpuQueries ) renderContextData.gpuQueries = [];\n\n\t\tfor ( let i = 0; i < renderContextData.gpuQueries.length; i ++ ) {\n\n\t\t  const queryInfo = renderContextData.gpuQueries[ i ];\n\t\t  const available = this.gl.getQueryParameter( queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE );\n\t\t  const disjoint = this.gl.getParameter( this.disjoint.GPU_DISJOINT_EXT );\n\n\t\t  if ( available && ! disjoint ) {\n\n\t\t\t\tconst elapsed = this.gl.getQueryParameter( queryInfo.query, this.gl.QUERY_RESULT );\n\t\t\t\tconst duration = Number( elapsed ) / 1000000; // Convert nanoseconds to milliseconds\n\t\t\t\tthis.gl.deleteQuery( queryInfo.query );\n\t\t\t\trenderContextData.gpuQueries.splice( i, 1 ); // Remove the processed query\n\t\t\t\ti --;\n\t\t\t\tthis.renderer.info.updateTimestamp( type, duration );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.gl;\n\n\t}\n\n\tbeginRender( renderContext ) {\n\n\t\tconst { gl } = this;\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t//\n\n\t\t//\n\n\t\tthis.initTimestampQuery( renderContext );\n\n\t\trenderContextData.previousContext = this._currentContext;\n\t\tthis._currentContext = renderContext;\n\n\t\tthis._setFramebuffer( renderContext );\n\n\t\tthis.clear( renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false );\n\n\t\t//\n\t\tif ( renderContext.viewport ) {\n\n\t\t\tthis.updateViewport( renderContext );\n\n\t\t} else {\n\n\t\t\tgl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );\n\n\t\t}\n\n\t\tif ( renderContext.scissor ) {\n\n\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\tgl.scissor( x, renderContext.height - height - y, width, height );\n\n\t\t}\n\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\t// Get a reference to the array of objects with queries. The renderContextData property\n\t\t\t// can be changed by another render pass before the async reading of all previous queries complete\n\t\t\trenderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;\n\t\t\trenderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n\t\t\trenderContextData.lastOcclusionObject = null;\n\t\t\trenderContextData.occlusionQueries = new Array( occlusionQueryCount );\n\t\t\trenderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );\n\t\t\trenderContextData.occlusionQueryIndex = 0;\n\n\t\t}\n\n\t}\n\n\tfinishRender( renderContext ) {\n\n\t\tconst { gl, state } = this;\n\t\tconst renderContextData = this.get( renderContext );\n\t\tconst previousContext = renderContextData.previousContext;\n\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tif ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {\n\n\t\t\t\tgl.endQuery( gl.ANY_SAMPLES_PASSED );\n\n\t\t\t}\n\n\t\t\tthis.resolveOccludedAsync( renderContext );\n\n\t\t}\n\n\t\tconst textures = renderContext.textures;\n\n\t\tif ( textures !== null ) {\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.generateMipmaps ) {\n\n\t\t\t\t\tthis.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._currentContext = previousContext;\n\n\t\tif ( renderContext.textures !== null && renderContext.renderTarget ) {\n\n\t\t\tconst renderTargetContextData = this.get( renderContext.renderTarget );\n\n\t\t\tconst { samples } = renderContext.renderTarget;\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tconst fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];\n\n\t\t\t\tconst mask = gl.COLOR_BUFFER_BIT;\n\n\t\t\t\tconst msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t\tconst textures = renderContext.textures;\n\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t// TODO Add support for MRT\n\n\t\t\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\t\t\t\tconst viewY = renderContext.height - height - y;\n\n\t\t\t\t\t\tgl.blitFramebuffer( x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST );\n\t\t\t\t\t\tgl.invalidateSubFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray, x, viewY, width, height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blitFramebuffer( 0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST );\n\t\t\t\t\t\tgl.invalidateFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tif ( previousContext !== null ) {\n\n\t\t\tthis._setFramebuffer( previousContext );\n\n\t\t\tif ( previousContext.viewport ) {\n\n\t\t\t\tthis.updateViewport( previousContext );\n\n\t\t\t} else {\n\n\t\t\t\tgl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.prepareTimestampBuffer( renderContext );\n\n\t}\n\n\tresolveOccludedAsync( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t// handle occlusion query results\n\n\t\tconst { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;\n\n\t\tif ( currentOcclusionQueries && currentOcclusionQueryObjects ) {\n\n\t\t\tconst occluded = new WeakSet();\n\t\t\tconst { gl } = this;\n\n\t\t\trenderContextData.currentOcclusionQueryObjects = null;\n\t\t\trenderContextData.currentOcclusionQueries = null;\n\n\t\t\tconst check = () => {\n\n\t\t\t\tlet completed = 0;\n\n\t\t\t\t// check all queries and requeue as appropriate\n\t\t\t\tfor ( let i = 0; i < currentOcclusionQueries.length; i ++ ) {\n\n\t\t\t\t\tconst query = currentOcclusionQueries[ i ];\n\n\t\t\t\t\tif ( query === null ) continue;\n\n\t\t\t\t\tif ( gl.getQueryParameter( query, gl.QUERY_RESULT_AVAILABLE ) ) {\n\n\t\t\t\t\t\tif ( gl.getQueryParameter( query, gl.QUERY_RESULT ) > 0 ) occluded.add( currentOcclusionQueryObjects[ i ] );\n\n\t\t\t\t\t\tcurrentOcclusionQueries[ i ] = null;\n\t\t\t\t\t\tgl.deleteQuery( query );\n\n\t\t\t\t\t\tcompleted ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( completed < currentOcclusionQueries.length ) {\n\n\t\t\t\t\trequestAnimationFrame( check );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderContextData.occluded = occluded;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcheck();\n\n\t\t}\n\n\t}\n\n\tisOccluded( renderContext, object ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\treturn renderContextData.occluded && renderContextData.occluded.has( object );\n\n\t}\n\n\tupdateViewport( renderContext ) {\n\n\t\tconst gl = this.gl;\n\t\tconst { x, y, width, height } = renderContext.viewportValue;\n\n\t\tgl.viewport( x, renderContext.height - height - y, width, height );\n\n\t}\n\n\tsetScissorTest( boolean ) {\n\n\t\tconst gl = this.gl;\n\n\t\tif ( boolean ) {\n\n\t\t\tgl.enable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tgl.disable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t}\n\n\tclear( color, depth, stencil, descriptor = null, setFrameBuffer = true ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( descriptor === null ) {\n\n\t\t\tconst clearColor = this.getClearColor();\n\n\t\t\t// premultiply alpha\n\n\t\t\tclearColor.r *= clearColor.a;\n\t\t\tclearColor.g *= clearColor.a;\n\t\t\tclearColor.b *= clearColor.a;\n\n\t\t\tdescriptor = {\n\t\t\t\ttextures: null,\n\t\t\t\tclearColorValue: clearColor\n\t\t\t};\n\n\t\t}\n\n\t\t//\n\n\t\tlet clear = 0;\n\n\t\tif ( color ) clear |= gl.COLOR_BUFFER_BIT;\n\t\tif ( depth ) clear |= gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil ) clear |= gl.STENCIL_BUFFER_BIT;\n\n\t\tif ( clear !== 0 ) {\n\n\t\t\tlet clearColor;\n\n\t\t\tif ( descriptor.clearColorValue ) {\n\n\t\t\t\tclearColor = descriptor.clearColorValue;\n\n\t\t\t} else {\n\n\t\t\t\tclearColor = this.getClearColor();\n\n\t\t\t\t// premultiply alpha\n\n\t\t\t\tclearColor.r *= clearColor.a;\n\t\t\t\tclearColor.g *= clearColor.a;\n\t\t\t\tclearColor.b *= clearColor.a;\n\n\t\t\t}\n\n\t\t\tif ( depth ) this.state.setDepthMask( true );\n\n\t\t\tif ( descriptor.textures === null ) {\n\n\t\t\t\tgl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearColor.a );\n\t\t\t\tgl.clear( clear );\n\n\t\t\t} else {\n\n\t\t\t\tif ( setFrameBuffer ) this._setFramebuffer( descriptor );\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tfor ( let i = 0; i < descriptor.textures.length; i ++ ) {\n\n\t\t\t\t\t\tgl.clearBufferfv( gl.COLOR, i, [ clearColor.r, clearColor.g, clearColor.b, clearColor.a ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( depth && stencil ) {\n\n\t\t\t\t\tgl.clearBufferfi( gl.DEPTH_STENCIL, 0, 1, 0 );\n\n\t\t\t\t} else if ( depth ) {\n\n\t\t\t\t\tgl.clearBufferfv( gl.DEPTH, 0, [ 1.0 ] );\n\n\t\t\t\t} else if ( stencil ) {\n\n\t\t\t\t\tgl.clearBufferiv( gl.STENCIL, 0, [ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tbeginCompute( computeGroup ) {\n\n\t\tconst { state, gl } = this;\n\n\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, null );\n\t\tthis.initTimestampQuery( computeGroup );\n\n\t}\n\n\tcompute( computeGroup, computeNode, bindings, pipeline ) {\n\n\t\tconst { state, gl } = this;\n\n\t\tif ( ! this.discard ) {\n\n\t\t\t// required here to handle async behaviour of render.compute()\n\t\t\tgl.enable( gl.RASTERIZER_DISCARD );\n\t\t\tthis.discard = true;\n\n\t\t}\n\n\t\tconst { programGPU, transformBuffers, attributes } = this.get( pipeline );\n\n\t\tconst vaoKey = this._getVaoKey( null, attributes );\n\n\t\tconst vaoGPU = this.vaoCache[ vaoKey ];\n\n\t\tif ( vaoGPU === undefined ) {\n\n\t\t\tthis._createVao( null, attributes );\n\n\t\t} else {\n\n\t\t\tgl.bindVertexArray( vaoGPU );\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\tthis._bindUniforms( bindings );\n\n\t\tconst transformFeedbackGPU = this._getTransformFeedback( transformBuffers );\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );\n\t\tgl.beginTransformFeedback( gl.POINTS );\n\n\t\tif ( attributes[ 0 ].isStorageInstancedBufferAttribute ) {\n\n\t\t\tgl.drawArraysInstanced( gl.POINTS, 0, 1, computeNode.count );\n\n\t\t} else {\n\n\t\t\tgl.drawArrays( gl.POINTS, 0, computeNode.count );\n\n\t\t}\n\n\t\tgl.endTransformFeedback();\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );\n\n\t\t// switch active buffers\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tconst dualAttributeData = transformBuffers[ i ];\n\n\t\t\tif ( dualAttributeData.pbo ) {\n\n\t\t\t\tthis.textureUtils.copyBufferToTexture( dualAttributeData.transformBuffer, dualAttributeData.pbo );\n\n\t\t\t}\n\n\t\t\tdualAttributeData.switchBuffers();\n\n\n\t\t}\n\n\t}\n\n\tfinishCompute( computeGroup ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.discard = false;\n\n\t\tgl.disable( gl.RASTERIZER_DISCARD );\n\n\t\tthis.prepareTimestampBuffer( computeGroup );\n\n\t\tif ( this._currentContext ) {\n\n\t\t\tthis._setFramebuffer( this._currentContext );\n\n\t\t}\n\n\t}\n\n\tdraw( renderObject/*, info*/ ) {\n\n\t\tconst { object, pipeline, material, context, hardwareClippingPlanes } = renderObject;\n\t\tconst { programGPU } = this.get( pipeline );\n\n\t\tconst { gl, state } = this;\n\n\t\tconst contextData = this.get( context );\n\n\t\tconst drawParams = renderObject.getDrawParameters();\n\n\t\tif ( drawParams === null ) return;\n\n\t\t//\n\n\t\tthis._bindUniforms( renderObject.getBindings() );\n\n\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\tstate.setMaterial( material, frontFaceCW, hardwareClippingPlanes );\n\n\t\tstate.useProgram( programGPU );\n\n\t\t//\n\n\t\tconst renderObjectData = this.get( renderObject );\n\n\t\tlet vaoGPU = renderObjectData.staticVao;\n\n\t\tif ( vaoGPU === undefined || renderObjectData.geometryId !== renderObject.geometry.id ) {\n\n\t\t\tconst vaoKey = this._getVaoKey( renderObject.getIndex(), renderObject.getAttributes() );\n\n\t\t\tvaoGPU = this.vaoCache[ vaoKey ];\n\n\t\t\tif ( vaoGPU === undefined ) {\n\n\t\t\t\tlet staticVao;\n\n\t\t\t\t( { vaoGPU, staticVao } = this._createVao( renderObject.getIndex(), renderObject.getAttributes() ) );\n\n\t\t\t\tif ( staticVao ) {\n\n\t\t\t\t\trenderObjectData.staticVao = vaoGPU;\n\t\t\t\t\trenderObjectData.geometryId = renderObject.geometry.id;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindVertexArray( vaoGPU );\n\n\t\t//\n\n\t\tconst index = renderObject.getIndex();\n\n\t\t//\n\n\t\tconst lastObject = contextData.lastOcclusionObject;\n\n\t\tif ( lastObject !== object && lastObject !== undefined ) {\n\n\t\t\tif ( lastObject !== null && lastObject.occlusionTest === true ) {\n\n\t\t\t\tgl.endQuery( gl.ANY_SAMPLES_PASSED );\n\n\t\t\t\tcontextData.occlusionQueryIndex ++;\n\n\t\t\t}\n\n\t\t\tif ( object.occlusionTest === true ) {\n\n\t\t\t\tconst query = gl.createQuery();\n\n\t\t\t\tgl.beginQuery( gl.ANY_SAMPLES_PASSED, query );\n\n\t\t\t\tcontextData.occlusionQueries[ contextData.occlusionQueryIndex ] = query;\n\t\t\t\tcontextData.occlusionQueryObjects[ contextData.occlusionQueryIndex ] = object;\n\n\t\t\t}\n\n\t\t\tcontextData.lastOcclusionObject = object;\n\n\t\t}\n\n\t\t//\n\t\tconst renderer = this.bufferRenderer;\n\n\t\tif ( object.isPoints ) renderer.mode = gl.POINTS;\n\t\telse if ( object.isLineSegments ) renderer.mode = gl.LINES;\n\t\telse if ( object.isLine ) renderer.mode = gl.LINE_STRIP;\n\t\telse if ( object.isLineLoop ) renderer.mode = gl.LINE_LOOP;\n\t\telse {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * this.renderer.getPixelRatio() );\n\t\t\t\trenderer.mode = gl.LINES;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.mode = gl.TRIANGLES;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst { vertexCount, instanceCount } = drawParams;\n\t\tlet { firstVertex } = drawParams;\n\n\t\trenderer.object = object;\n\n\t\tif ( index !== null ) {\n\n\t\t\tfirstVertex *= index.array.BYTES_PER_ELEMENT;\n\n\t\t\tconst indexData = this.get( index );\n\n\t\t\trenderer.index = index.count;\n\t\t\trenderer.type = indexData.type;\n\n\t\t} else {\n\n\t\t\trenderer.index = 0;\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tif ( object._multiDrawInstances !== null ) {\n\n\t\t\t\trenderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );\n\n\t\t\t} else if ( ! this.hasFeature( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\twarnOnce( 'THREE.WebGLRenderer: WEBGL_multi_draw not supported.' );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );\n\n\t\t\t}\n\n\t\t} else if ( instanceCount > 1 ) {\n\n\t\t\trenderer.renderInstances( firstVertex, vertexCount, instanceCount );\n\n\t\t} else {\n\n\t\t\trenderer.render( firstVertex, vertexCount );\n\n\t\t}\n\t\t//\n\n\t\tgl.bindVertexArray( null );\n\n\t}\n\n\tneedsRenderUpdate( /*renderObject*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetRenderCacheKey( /*renderObject*/ ) {\n\n\t\treturn '';\n\n\t}\n\n\t// textures\n\n\tcreateDefaultTexture( texture ) {\n\n\t\tthis.textureUtils.createDefaultTexture( texture );\n\n\t}\n\n\tcreateTexture( texture, options ) {\n\n\t\tthis.textureUtils.createTexture( texture, options );\n\n\t}\n\n\tupdateTexture( texture, options ) {\n\n\t\tthis.textureUtils.updateTexture( texture, options );\n\n\t}\n\n\tgenerateMipmaps( texture ) {\n\n\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t}\n\n\n\tdestroyTexture( texture ) {\n\n\t\tthis.textureUtils.destroyTexture( texture );\n\n\t}\n\n\tcopyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\treturn this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );\n\n\t}\n\n\tcreateSampler( /*texture*/ ) {\n\n\t\t//console.warn( 'Abstract class.' );\n\n\t}\n\n\tdestroySampler() {}\n\n\t// node builder\n\n\tcreateNodeBuilder( object, renderer ) {\n\n\t\treturn new GLSLNodeBuilder( object, renderer );\n\n\t}\n\n\t// program\n\n\tcreateProgram( program ) {\n\n\t\tconst gl = this.gl;\n\t\tconst { stage, code } = program;\n\n\t\tconst shader = stage === 'fragment' ? gl.createShader( gl.FRAGMENT_SHADER ) : gl.createShader( gl.VERTEX_SHADER );\n\n\t\tgl.shaderSource( shader, code );\n\t\tgl.compileShader( shader );\n\n\t\tthis.set( program, {\n\t\t\tshaderGPU: shader\n\t\t} );\n\n\t}\n\n\tdestroyProgram( /*program*/ ) {\n\n\t\tconsole.warn( 'Abstract class.' );\n\n\t}\n\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tconst gl = this.gl;\n\t\tconst pipeline = renderObject.pipeline;\n\n\t\t// Program\n\n\t\tconst { fragmentProgram, vertexProgram } = pipeline;\n\n\t\tconst programGPU = gl.createProgram();\n\n\t\tconst fragmentShader = this.get( fragmentProgram ).shaderGPU;\n\t\tconst vertexShader = this.get( vertexProgram ).shaderGPU;\n\n\t\tgl.attachShader( programGPU, fragmentShader );\n\t\tgl.attachShader( programGPU, vertexShader );\n\t\tgl.linkProgram( programGPU );\n\n\t\tthis.set( pipeline, {\n\t\t\tprogramGPU,\n\t\t\tfragmentShader,\n\t\t\tvertexShader\n\t\t} );\n\n\t\tif ( promises !== null && this.parallel ) {\n\n\t\t\tconst p = new Promise( ( resolve /*, reject*/ ) => {\n\n\t\t\t\tconst parallel = this.parallel;\n\t\t\t\tconst checkStatus = () => {\n\n\t\t\t\t\tif ( gl.getProgramParameter( programGPU, parallel.COMPLETION_STATUS_KHR ) ) {\n\n\t\t\t\t\t\tthis._completeCompile( renderObject, pipeline );\n\t\t\t\t\t\tresolve();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\trequestAnimationFrame( checkStatus );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tcheckStatus();\n\n\t\t\t} );\n\n\t\t\tpromises.push( p );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._completeCompile( renderObject, pipeline );\n\n\t}\n\n\t_handleSource( string, errorLine ) {\n\n\t\tconst lines = string.split( '\\n' );\n\t\tconst lines2 = [];\n\n\t\tconst from = Math.max( errorLine - 6, 0 );\n\t\tconst to = Math.min( errorLine + 6, lines.length );\n\n\t\tfor ( let i = from; i < to; i ++ ) {\n\n\t\t\tconst line = i + 1;\n\t\t\tlines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );\n\n\t\t}\n\n\t\treturn lines2.join( '\\n' );\n\n\t}\n\n\t_getShaderErrors( gl, shader, type ) {\n\n\t\tconst status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );\n\t\tconst errors = gl.getShaderInfoLog( shader ).trim();\n\n\t\tif ( status && errors === '' ) return '';\n\n\t\tconst errorMatches = /ERROR: 0:(\\d+)/.exec( errors );\n\t\tif ( errorMatches ) {\n\n\t\t\tconst errorLine = parseInt( errorMatches[ 1 ] );\n\t\t\treturn type.toUpperCase() + '\\n\\n' + errors + '\\n\\n' + this._handleSource( gl.getShaderSource( shader ), errorLine );\n\n\t\t} else {\n\n\t\t\treturn errors;\n\n\t\t}\n\n\t}\n\n\t_logProgramError( programGPU, glFragmentShader, glVertexShader ) {\n\n\t\tif ( this.renderer.debug.checkShaderErrors ) {\n\n\t\t\tconst gl = this.gl;\n\n\t\t\tconst programLog = gl.getProgramInfoLog( programGPU ).trim();\n\n\t\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\n\t\t\t\tif ( typeof this.renderer.debug.onShaderError === 'function' ) {\n\n\t\t\t\t\tthis.renderer.debug.onShaderError( gl, programGPU, glVertexShader, glFragmentShader );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// default error reporting\n\n\t\t\t\t\tconst vertexErrors = this._getShaderErrors( gl, glVertexShader, 'vertex' );\n\t\t\t\t\tconst fragmentErrors = this._getShaderErrors( gl, glFragmentShader, 'fragment' );\n\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +\n\t\t\t\t\t\t'VALIDATE_STATUS ' + gl.getProgramParameter( programGPU, gl.VALIDATE_STATUS ) + '\\n\\n' +\n\t\t\t\t\t\t'Program Info Log: ' + programLog + '\\n' +\n\t\t\t\t\t\tvertexErrors + '\\n' +\n\t\t\t\t\t\tfragmentErrors\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} else if ( programLog !== '' ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_completeCompile( renderObject, pipeline ) {\n\n\t\tconst { state, gl } = this;\n\t\tconst pipelineData = this.get( pipeline );\n\t\tconst { programGPU, fragmentShader, vertexShader } = pipelineData;\n\n\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\t\t\tthis._logProgramError( programGPU, fragmentShader, vertexShader );\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\t// Bindings\n\n\t\tconst bindings = renderObject.getBindings();\n\n\t\tthis._setupBindings( bindings, programGPU );\n\n\t\t//\n\n\t\tthis.set( pipeline, {\n\t\t\tprogramGPU\n\t\t} );\n\n\t}\n\n\tcreateComputePipeline( computePipeline, bindings ) {\n\n\t\tconst { state, gl } = this;\n\n\t\t// Program\n\n\t\tconst fragmentProgram = {\n\t\t\tstage: 'fragment',\n\t\t\tcode: '#version 300 es\\nprecision highp float;\\nvoid main() {}'\n\t\t};\n\n\t\tthis.createProgram( fragmentProgram );\n\n\t\tconst { computeProgram } = computePipeline;\n\n\t\tconst programGPU = gl.createProgram();\n\n\t\tconst fragmentShader = this.get( fragmentProgram ).shaderGPU;\n\t\tconst vertexShader = this.get( computeProgram ).shaderGPU;\n\n\t\tconst transforms = computeProgram.transforms;\n\n\t\tconst transformVaryingNames = [];\n\t\tconst transformAttributeNodes = [];\n\n\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\tconst transform = transforms[ i ];\n\n\t\t\ttransformVaryingNames.push( transform.varyingName );\n\t\t\ttransformAttributeNodes.push( transform.attributeNode );\n\n\t\t}\n\n\t\tgl.attachShader( programGPU, fragmentShader );\n\t\tgl.attachShader( programGPU, vertexShader );\n\n\t\tgl.transformFeedbackVaryings(\n\t\t\tprogramGPU,\n\t\t\ttransformVaryingNames,\n\t\t\tgl.SEPARATE_ATTRIBS\n\t\t);\n\n\t\tgl.linkProgram( programGPU );\n\n\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\t\t\tthis._logProgramError( programGPU, fragmentShader, vertexShader );\n\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\t// Bindings\n\n\t\tthis._setupBindings( bindings, programGPU );\n\n\t\tconst attributeNodes = computeProgram.attributes;\n\t\tconst attributes = [];\n\t\tconst transformBuffers = [];\n\n\t\tfor ( let i = 0; i < attributeNodes.length; i ++ ) {\n\n\t\t\tconst attribute = attributeNodes[ i ].node.attribute;\n\n\t\t\tattributes.push( attribute );\n\n\t\t\tif ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < transformAttributeNodes.length; i ++ ) {\n\n\t\t\tconst attribute = transformAttributeNodes[ i ].attribute;\n\n\t\t\tif ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t\t\tconst attributeData = this.get( attribute );\n\n\t\t\ttransformBuffers.push( attributeData );\n\n\t\t}\n\n\t\t//\n\n\t\tthis.set( computePipeline, {\n\t\t\tprogramGPU,\n\t\t\ttransformBuffers,\n\t\t\tattributes\n\t\t} );\n\n\t}\n\n\tcreateBindings( bindGroup, bindings ) {\n\n\t\tif ( this._knownBindings.has( bindings ) === false ) {\n\n\t\t\tthis._knownBindings.add( bindings );\n\n\t\t\tlet uniformBuffers = 0;\n\t\t\tlet textures = 0;\n\n\t\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\t\tthis.set( bindGroup, {\n\t\t\t\t\ttextures: textures,\n\t\t\t\t\tuniformBuffers: uniformBuffers\n\t\t\t\t} );\n\n\t\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\t\tif ( binding.isUniformBuffer ) uniformBuffers ++;\n\t\t\t\t\tif ( binding.isSampledTexture ) textures ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.updateBindings( bindGroup, bindings );\n\n\t}\n\n\tupdateBindings( bindGroup /*, bindings*/ ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst bindGroupData = this.get( bindGroup );\n\n\t\tlet i = bindGroupData.uniformBuffers;\n\t\tlet t = bindGroupData.textures;\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\tconst data = binding.buffer;\n\t\t\t\tconst bufferGPU = gl.createBuffer();\n\n\t\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );\n\n\t\t\t\tthis.set( binding, {\n\t\t\t\t\tindex: i ++,\n\t\t\t\t\tbufferGPU\n\t\t\t\t} );\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst { textureGPU, glTextureType } = this.get( binding.texture );\n\n\t\t\t\tthis.set( binding, {\n\t\t\t\t\tindex: t ++,\n\t\t\t\t\ttextureGPU,\n\t\t\t\t\tglTextureType\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateBinding( binding ) {\n\n\t\tconst gl = this.gl;\n\n\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\tconst bindingData = this.get( binding );\n\t\t\tconst bufferGPU = bindingData.bufferGPU;\n\t\t\tconst data = binding.buffer;\n\n\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );\n\n\t\t}\n\n\t}\n\n\t// attributes\n\n\tcreateIndexAttribute( attribute ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t}\n\n\tcreateAttribute( attribute ) {\n\n\t\tif ( this.has( attribute ) ) return;\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t}\n\n\tcreateStorageAttribute( attribute ) {\n\n\t\tif ( this.has( attribute ) ) return;\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t}\n\n\tupdateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.updateAttribute( attribute );\n\n\t}\n\n\tdestroyAttribute( attribute ) {\n\n\t\tthis.attributeUtils.destroyAttribute( attribute );\n\n\t}\n\n\tupdateSize() {\n\n\t\t//console.warn( 'Abstract class.' );\n\n\t}\n\n\thasFeature( name ) {\n\n\t\tconst keysMatching = Object.keys( GLFeatureName ).filter( key => GLFeatureName[ key ] === name );\n\n\t\tconst extensions = this.extensions;\n\n\t\tfor ( let i = 0; i < keysMatching.length; i ++ ) {\n\n\t\t\tif ( extensions.has( keysMatching[ i ] ) ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetMaxAnisotropy() {\n\n\t\treturn this.capabilities.getMaxAnisotropy();\n\n\t}\n\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level ) {\n\n\t\tthis.textureUtils.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );\n\n\t}\n\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tthis.textureUtils.copyFramebufferToTexture( texture, renderContext, rectangle );\n\n\t}\n\n\t_setFramebuffer( descriptor ) {\n\n\t\tconst { gl, state } = this;\n\n\t\tlet currentFrameBuffer = null;\n\n\t\tif ( descriptor.textures !== null ) {\n\n\t\t\tconst renderTarget = descriptor.renderTarget;\n\t\t\tconst renderTargetContextData = this.get( renderTarget );\n\t\t\tconst { samples, depthBuffer, stencilBuffer } = renderTarget;\n\n\t\t\tconst isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\n\t\t\tlet msaaFb = renderTargetContextData.msaaFrameBuffer;\n\t\t\tlet depthRenderbuffer = renderTargetContextData.depthRenderbuffer;\n\n\t\t\tconst cacheKey = getCacheKey( descriptor );\n\n\t\t\tlet fb;\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetContextData.cubeFramebuffers || ( renderTargetContextData.cubeFramebuffers = {} );\n\n\t\t\t\tfb = renderTargetContextData.cubeFramebuffers[ cacheKey ];\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetContextData.framebuffers || ( renderTargetContextData.framebuffers = {} );\n\n\t\t\t\tfb = renderTargetContextData.framebuffers[ cacheKey ];\n\n\t\t\t}\n\n\t\t\tif ( fb === undefined ) {\n\n\t\t\t\tfb = gl.createFramebuffer();\n\n\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, fb );\n\n\t\t\t\tconst textures = descriptor.textures;\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\trenderTargetContextData.cubeFramebuffers[ cacheKey ] = fb;\n\n\t\t\t\t\tconst { textureGPU } = this.get( textures[ 0 ] );\n\n\t\t\t\t\tconst cubeFace = this.renderer._activeCubeFace;\n\n\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderTargetContextData.framebuffers[ cacheKey ] = fb;\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\tconst textureData = this.get( texture );\n\t\t\t\t\t\ttextureData.renderTarget = descriptor.renderTarget;\n\t\t\t\t\t\ttextureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n\t\t\t\t\t\tconst attachment = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.drawBuffers( descriptor, fb );\n\n\t\t\t\t}\n\n\t\t\t\tif ( descriptor.depthTexture !== null ) {\n\n\t\t\t\t\tconst textureData = this.get( descriptor.depthTexture );\n\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\ttextureData.renderTarget = descriptor.renderTarget;\n\t\t\t\t\ttextureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tif ( msaaFb === undefined ) {\n\n\t\t\t\t\tconst invalidationArray = [];\n\n\t\t\t\t\tmsaaFb = gl.createFramebuffer();\n\n\t\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, msaaFb );\n\n\t\t\t\t\tconst msaaRenderbuffers = [];\n\n\t\t\t\t\tconst textures = descriptor.textures;\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tmsaaRenderbuffers[ i ] = gl.createRenderbuffer();\n\n\t\t\t\t\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\n\t\t\t\t\t\tinvalidationArray.push( gl.COLOR_ATTACHMENT0 + i );\n\n\t\t\t\t\t\tif ( depthBuffer ) {\n\n\t\t\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\t\t\tinvalidationArray.push( depthStyle );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst texture = descriptor.textures[ i ];\n\t\t\t\t\t\tconst textureData = this.get( texture );\n\n\t\t\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height );\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderTargetContextData.msaaFrameBuffer = msaaFb;\n\t\t\t\t\trenderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;\n\n\t\t\t\t\tif ( depthRenderbuffer === undefined ) {\n\n\t\t\t\t\t\tdepthRenderbuffer = gl.createRenderbuffer();\n\t\t\t\t\t\tthis.textureUtils.setupRenderBufferStorage( depthRenderbuffer, descriptor );\n\n\t\t\t\t\t\trenderTargetContextData.depthRenderbuffer = depthRenderbuffer;\n\n\t\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\t\tinvalidationArray.push( depthStyle );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderTargetContextData.invalidationArray = invalidationArray;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t} else {\n\n\t\t\t\tcurrentFrameBuffer = fb;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, currentFrameBuffer );\n\n\t}\n\n\n\t_getVaoKey( index, attributes ) {\n\n\t\tlet key = [];\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst indexData = this.get( index );\n\n\t\t\tkey += ':' + indexData.id;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\n\n\t\t\tconst attributeData = this.get( attributes[ i ] );\n\n\t\t\tkey += ':' + attributeData.id;\n\n\t\t}\n\n\t\treturn key;\n\n\t}\n\n\t_createVao( index, attributes ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst vaoGPU = gl.createVertexArray();\n\t\tlet key = '';\n\n\t\tlet staticVao = true;\n\n\t\tgl.bindVertexArray( vaoGPU );\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst indexData = this.get( index );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, indexData.bufferGPU );\n\n\t\t\tkey += ':' + indexData.id;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\n\n\t\t\tconst attribute = attributes[ i ];\n\t\t\tconst attributeData = this.get( attribute );\n\n\t\t\tkey += ':' + attributeData.id;\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, attributeData.bufferGPU );\n\t\t\tgl.enableVertexAttribArray( i );\n\n\t\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) staticVao = false;\n\n\t\t\tlet stride, offset;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute === true ) {\n\n\t\t\t\tstride = attribute.data.stride * attributeData.bytesPerElement;\n\t\t\t\toffset = attribute.offset * attributeData.bytesPerElement;\n\n\t\t\t} else {\n\n\t\t\t\tstride = 0;\n\t\t\t\toffset = 0;\n\n\t\t\t}\n\n\t\t\tif ( attributeData.isInteger ) {\n\n\t\t\t\tgl.vertexAttribIPointer( i, attribute.itemSize, attributeData.type, stride, offset );\n\n\t\t\t} else {\n\n\t\t\t\tgl.vertexAttribPointer( i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset );\n\n\t\t\t}\n\n\t\t\tif ( attribute.isInstancedBufferAttribute && ! attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tgl.vertexAttribDivisor( i, attribute.meshPerAttribute );\n\n\t\t\t} else if ( attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\tgl.vertexAttribDivisor( i, attribute.data.meshPerAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, null );\n\n\t\tthis.vaoCache[ key ] = vaoGPU;\n\n\t\treturn { vaoGPU, staticVao };\n\n\t}\n\n\t_getTransformFeedback( transformBuffers ) {\n\n\t\tlet key = '';\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tkey += ':' + transformBuffers[ i ].id;\n\n\t\t}\n\n\t\tlet transformFeedbackGPU = this.transformFeedbackCache[ key ];\n\n\t\tif ( transformFeedbackGPU !== undefined ) {\n\n\t\t\treturn transformFeedbackGPU;\n\n\t\t}\n\n\t\tconst { gl } = this;\n\n\t\ttransformFeedbackGPU = gl.createTransformFeedback();\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tconst attributeData = transformBuffers[ i ];\n\n\t\t\tgl.bindBufferBase( gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer );\n\n\t\t}\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );\n\n\t\tthis.transformFeedbackCache[ key ] = transformFeedbackGPU;\n\n\t\treturn transformFeedbackGPU;\n\n\t}\n\n\n\t_setupBindings( bindings, programGPU ) {\n\n\t\tconst gl = this.gl;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\tconst bindingData = this.get( binding );\n\t\t\t\tconst index = bindingData.index;\n\n\t\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\t\tconst location = gl.getUniformBlockIndex( programGPU, binding.name );\n\t\t\t\t\tgl.uniformBlockBinding( programGPU, location, index );\n\n\t\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\t\tconst location = gl.getUniformLocation( programGPU, binding.name );\n\t\t\t\t\tgl.uniform1i( location, index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_bindUniforms( bindings ) {\n\n\t\tconst { gl, state } = this;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\tconst bindingData = this.get( binding );\n\t\t\t\tconst index = bindingData.index;\n\n\t\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\t\t// TODO USE bindBufferRange to group multiple uniform buffers\n\t\t\t\t\tstate.bindBufferBase( gl.UNIFORM_BUFFER, index, bindingData.bufferGPU );\n\n\t\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\t\tstate.bindTexture( bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.renderer.domElement.removeEventListener( 'webglcontextlost', this._onContextLost );\n\n\t}\n\n}\n\nconst GPUPrimitiveTopology = {\n\tPointList: 'point-list',\n\tLineList: 'line-list',\n\tLineStrip: 'line-strip',\n\tTriangleList: 'triangle-list',\n\tTriangleStrip: 'triangle-strip',\n};\n\nconst GPUCompareFunction = {\n\tNever: 'never',\n\tLess: 'less',\n\tEqual: 'equal',\n\tLessEqual: 'less-equal',\n\tGreater: 'greater',\n\tNotEqual: 'not-equal',\n\tGreaterEqual: 'greater-equal',\n\tAlways: 'always'\n};\n\nconst GPUStoreOp = {\n\tStore: 'store',\n\tDiscard: 'discard'\n};\n\nconst GPULoadOp = {\n\tLoad: 'load',\n\tClear: 'clear'\n};\n\nconst GPUFrontFace = {\n\tCCW: 'ccw',\n\tCW: 'cw'\n};\n\nconst GPUCullMode = {\n\tNone: 'none',\n\tFront: 'front',\n\tBack: 'back'\n};\n\nconst GPUIndexFormat = {\n\tUint16: 'uint16',\n\tUint32: 'uint32'\n};\n\nconst GPUTextureFormat = {\n\n\t// 8-bit formats\n\n\tR8Unorm: 'r8unorm',\n\tR8Snorm: 'r8snorm',\n\tR8Uint: 'r8uint',\n\tR8Sint: 'r8sint',\n\n\t// 16-bit formats\n\n\tR16Uint: 'r16uint',\n\tR16Sint: 'r16sint',\n\tR16Float: 'r16float',\n\tRG8Unorm: 'rg8unorm',\n\tRG8Snorm: 'rg8snorm',\n\tRG8Uint: 'rg8uint',\n\tRG8Sint: 'rg8sint',\n\n\t// 32-bit formats\n\n\tR32Uint: 'r32uint',\n\tR32Sint: 'r32sint',\n\tR32Float: 'r32float',\n\tRG16Uint: 'rg16uint',\n\tRG16Sint: 'rg16sint',\n\tRG16Float: 'rg16float',\n\tRGBA8Unorm: 'rgba8unorm',\n\tRGBA8UnormSRGB: 'rgba8unorm-srgb',\n\tRGBA8Snorm: 'rgba8snorm',\n\tRGBA8Uint: 'rgba8uint',\n\tRGBA8Sint: 'rgba8sint',\n\tBGRA8Unorm: 'bgra8unorm',\n\tBGRA8UnormSRGB: 'bgra8unorm-srgb',\n\t// Packed 32-bit formats\n\tRGB9E5UFloat: 'rgb9e5ufloat',\n\tRGB10A2Unorm: 'rgb10a2unorm',\n\tRG11B10uFloat: 'rgb10a2unorm',\n\n\t// 64-bit formats\n\n\tRG32Uint: 'rg32uint',\n\tRG32Sint: 'rg32sint',\n\tRG32Float: 'rg32float',\n\tRGBA16Uint: 'rgba16uint',\n\tRGBA16Sint: 'rgba16sint',\n\tRGBA16Float: 'rgba16float',\n\n\t// 128-bit formats\n\n\tRGBA32Uint: 'rgba32uint',\n\tRGBA32Sint: 'rgba32sint',\n\tRGBA32Float: 'rgba32float',\n\n\t// Depth and stencil formats\n\n\tStencil8: 'stencil8',\n\tDepth16Unorm: 'depth16unorm',\n\tDepth24Plus: 'depth24plus',\n\tDepth24PlusStencil8: 'depth24plus-stencil8',\n\tDepth32Float: 'depth32float',\n\n\t// 'depth32float-stencil8' extension\n\n\tDepth32FloatStencil8: 'depth32float-stencil8',\n\n\t// BC compressed formats usable if 'texture-compression-bc' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tBC1RGBAUnorm: 'bc1-rgba-unorm',\n\tBC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',\n\tBC2RGBAUnorm: 'bc2-rgba-unorm',\n\tBC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',\n\tBC3RGBAUnorm: 'bc3-rgba-unorm',\n\tBC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',\n\tBC4RUnorm: 'bc4-r-unorm',\n\tBC4RSnorm: 'bc4-r-snorm',\n\tBC5RGUnorm: 'bc5-rg-unorm',\n\tBC5RGSnorm: 'bc5-rg-snorm',\n\tBC6HRGBUFloat: 'bc6h-rgb-ufloat',\n\tBC6HRGBFloat: 'bc6h-rgb-float',\n\tBC7RGBAUnorm: 'bc7-rgba-unorm',\n\tBC7RGBAUnormSRGB: 'bc7-rgba-srgb',\n\n\t// ETC2 compressed formats usable if 'texture-compression-etc2' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tETC2RGB8Unorm: 'etc2-rgb8unorm',\n\tETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',\n\tETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',\n\tETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',\n\tETC2RGBA8Unorm: 'etc2-rgba8unorm',\n\tETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',\n\tEACR11Unorm: 'eac-r11unorm',\n\tEACR11Snorm: 'eac-r11snorm',\n\tEACRG11Unorm: 'eac-rg11unorm',\n\tEACRG11Snorm: 'eac-rg11snorm',\n\n\t// ASTC compressed formats usable if 'texture-compression-astc' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tASTC4x4Unorm: 'astc-4x4-unorm',\n\tASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',\n\tASTC5x4Unorm: 'astc-5x4-unorm',\n\tASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',\n\tASTC5x5Unorm: 'astc-5x5-unorm',\n\tASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',\n\tASTC6x5Unorm: 'astc-6x5-unorm',\n\tASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',\n\tASTC6x6Unorm: 'astc-6x6-unorm',\n\tASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',\n\tASTC8x5Unorm: 'astc-8x5-unorm',\n\tASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',\n\tASTC8x6Unorm: 'astc-8x6-unorm',\n\tASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',\n\tASTC8x8Unorm: 'astc-8x8-unorm',\n\tASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',\n\tASTC10x5Unorm: 'astc-10x5-unorm',\n\tASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',\n\tASTC10x6Unorm: 'astc-10x6-unorm',\n\tASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',\n\tASTC10x8Unorm: 'astc-10x8-unorm',\n\tASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',\n\tASTC10x10Unorm: 'astc-10x10-unorm',\n\tASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',\n\tASTC12x10Unorm: 'astc-12x10-unorm',\n\tASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',\n\tASTC12x12Unorm: 'astc-12x12-unorm',\n\tASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb',\n\n};\n\nconst GPUAddressMode = {\n\tClampToEdge: 'clamp-to-edge',\n\tRepeat: 'repeat',\n\tMirrorRepeat: 'mirror-repeat'\n};\n\nconst GPUFilterMode = {\n\tLinear: 'linear',\n\tNearest: 'nearest'\n};\n\nconst GPUBlendFactor = {\n\tZero: 'zero',\n\tOne: 'one',\n\tSrc: 'src',\n\tOneMinusSrc: 'one-minus-src',\n\tSrcAlpha: 'src-alpha',\n\tOneMinusSrcAlpha: 'one-minus-src-alpha',\n\tDst: 'dst',\n\tOneMinusDstColor: 'one-minus-dst',\n\tDstAlpha: 'dst-alpha',\n\tOneMinusDstAlpha: 'one-minus-dst-alpha',\n\tSrcAlphaSaturated: 'src-alpha-saturated',\n\tConstant: 'constant',\n\tOneMinusConstant: 'one-minus-constant'\n};\n\nconst GPUBlendOperation = {\n\tAdd: 'add',\n\tSubtract: 'subtract',\n\tReverseSubtract: 'reverse-subtract',\n\tMin: 'min',\n\tMax: 'max'\n};\n\nconst GPUColorWriteFlags = {\n\tNone: 0,\n\tRed: 0x1,\n\tGreen: 0x2,\n\tBlue: 0x4,\n\tAlpha: 0x8,\n\tAll: 0xF\n};\n\nconst GPUStencilOperation = {\n\tKeep: 'keep',\n\tZero: 'zero',\n\tReplace: 'replace',\n\tInvert: 'invert',\n\tIncrementClamp: 'increment-clamp',\n\tDecrementClamp: 'decrement-clamp',\n\tIncrementWrap: 'increment-wrap',\n\tDecrementWrap: 'decrement-wrap'\n};\n\nconst GPUBufferBindingType = {\n\tUniform: 'uniform',\n\tStorage: 'storage',\n\tReadOnlyStorage: 'read-only-storage'\n};\n\nconst GPUStorageTextureAccess = {\n\tWriteOnly: 'write-only',\n\tReadOnly: 'read-only',\n\tReadWrite: 'read-write',\n};\n\nconst GPUTextureSampleType = {\n\tFloat: 'float',\n\tUnfilterableFloat: 'unfilterable-float',\n\tDepth: 'depth',\n\tSInt: 'sint',\n\tUInt: 'uint'\n};\n\nconst GPUTextureDimension = {\n\tOneD: '1d',\n\tTwoD: '2d',\n\tThreeD: '3d'\n};\n\nconst GPUTextureViewDimension = {\n\tOneD: '1d',\n\tTwoD: '2d',\n\tTwoDArray: '2d-array',\n\tCube: 'cube',\n\tCubeArray: 'cube-array',\n\tThreeD: '3d'\n};\n\nconst GPUTextureAspect = {\n\tAll: 'all',\n\tStencilOnly: 'stencil-only',\n\tDepthOnly: 'depth-only'\n};\n\nconst GPUInputStepMode = {\n\tVertex: 'vertex',\n\tInstance: 'instance'\n};\n\nconst GPUFeatureName = {\n\tDepthClipControl: 'depth-clip-control',\n\tDepth32FloatStencil8: 'depth32float-stencil8',\n\tTextureCompressionBC: 'texture-compression-bc',\n\tTextureCompressionETC2: 'texture-compression-etc2',\n\tTextureCompressionASTC: 'texture-compression-astc',\n\tTimestampQuery: 'timestamp-query',\n\tIndirectFirstInstance: 'indirect-first-instance',\n\tShaderF16: 'shader-f16',\n\tRG11B10UFloat: 'rg11b10ufloat-renderable',\n\tBGRA8UNormStorage: 'bgra8unorm-storage',\n\tFloat32Filterable: 'float32-filterable',\n\tClipDistances: 'clip-distances',\n\tDualSourceBlending: 'dual-source-blending',\n\tSubgroups: 'subgroups'\n};\n\nclass Sampler extends Binding {\n\n\tconstructor( name, texture ) {\n\n\t\tsuper( name );\n\n\t\tthis.texture = texture;\n\t\tthis.version = texture ? texture.version : 0;\n\n\t\tthis.isSampler = true;\n\n\t}\n\n}\n\nclass NodeSampler extends Sampler {\n\n\tconstructor( name, textureNode, groupNode ) {\n\n\t\tsuper( name, textureNode ? textureNode.value : null );\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\tupdate() {\n\n\t\tthis.texture = this.textureNode.value;\n\n\t}\n\n}\n\nclass StorageBuffer extends Buffer {\n\n\tconstructor( name, attribute ) {\n\n\t\tsuper( name, attribute ? attribute.array : null );\n\n\t\tthis.attribute = attribute;\n\n\t\tthis.isStorageBuffer = true;\n\n\t}\n\n}\n\nlet _id = 0;\n\nclass NodeStorageBuffer extends StorageBuffer {\n\n\tconstructor( nodeUniform, groupNode ) {\n\n\t\tsuper( 'StorageBuffer_' + _id ++, nodeUniform ? nodeUniform.value : null );\n\n\t\tthis.nodeUniform = nodeUniform;\n\t\tthis.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\tget buffer() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n}\n\nclass WebGPUTexturePassUtils extends DataMap {\n\n\tconstructor( device ) {\n\n\t\tsuper();\n\n\t\tthis.device = device;\n\n\t\tconst mipmapVertexSource = `\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n`;\n\n\t\tconst mipmapFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n`;\n\n\t\tconst flipYFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );\n\n}\n`;\n\t\tthis.mipmapSampler = device.createSampler( { minFilter: GPUFilterMode.Linear } );\n\t\tthis.flipYSampler = device.createSampler( { minFilter: GPUFilterMode.Nearest } ); //@TODO?: Consider using textureLoad()\n\n\t\t// We'll need a new pipeline for every texture format used.\n\t\tthis.transferPipelines = {};\n\t\tthis.flipYPipelines = {};\n\n\t\tthis.mipmapVertexShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'mipmapVertex',\n\t\t\tcode: mipmapVertexSource\n\t\t} );\n\n\t\tthis.mipmapFragmentShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'mipmapFragment',\n\t\t\tcode: mipmapFragmentSource\n\t\t} );\n\n\t\tthis.flipYFragmentShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'flipYFragment',\n\t\t\tcode: flipYFragmentSource\n\t\t} );\n\n\t}\n\n\tgetTransferPipeline( format ) {\n\n\t\tlet pipeline = this.transferPipelines[ format ];\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = this.device.createRenderPipeline( {\n\t\t\t\tlabel: `mipmap-${ format }`,\n\t\t\t\tvertex: {\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\n\t\t\t\t\tentryPoint: 'main'\n\t\t\t\t},\n\t\t\t\tfragment: {\n\t\t\t\t\tmodule: this.mipmapFragmentShaderModule,\n\t\t\t\t\tentryPoint: 'main',\n\t\t\t\t\ttargets: [ { format } ]\n\t\t\t\t},\n\t\t\t\tprimitive: {\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\n\t\t\t\t},\n\t\t\t\tlayout: 'auto'\n\t\t\t} );\n\n\t\t\tthis.transferPipelines[ format ] = pipeline;\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\tgetFlipYPipeline( format ) {\n\n\t\tlet pipeline = this.flipYPipelines[ format ];\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = this.device.createRenderPipeline( {\n\t\t\t\tlabel: `flipY-${ format }`,\n\t\t\t\tvertex: {\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\n\t\t\t\t\tentryPoint: 'main'\n\t\t\t\t},\n\t\t\t\tfragment: {\n\t\t\t\t\tmodule: this.flipYFragmentShaderModule,\n\t\t\t\t\tentryPoint: 'main',\n\t\t\t\t\ttargets: [ { format } ]\n\t\t\t\t},\n\t\t\t\tprimitive: {\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\n\t\t\t\t},\n\t\t\t\tlayout: 'auto'\n\t\t\t} );\n\n\t\t\tthis.flipYPipelines[ format ] = pipeline;\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\tflipY( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {\n\n\t\tconst format = textureGPUDescriptor.format;\n\t\tconst { width, height } = textureGPUDescriptor.size;\n\n\t\tconst transferPipeline = this.getTransferPipeline( format );\n\t\tconst flipYPipeline = this.getFlipYPipeline( format );\n\n\t\tconst tempTexture = this.device.createTexture( {\n\t\t\tsize: { width, height, depthOrArrayLayers: 1 },\n\t\t\tformat,\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n\t\t} );\n\n\t\tconst srcView = textureGPU.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer\n\t\t} );\n\n\t\tconst dstView = tempTexture.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer: 0\n\t\t} );\n\n\t\tconst commandEncoder = this.device.createCommandEncoder( {} );\n\n\t\tconst pass = ( pipeline, sourceView, destinationView ) => {\n\n\t\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\n\n\t\t\tconst bindGroup = this.device.createBindGroup( {\n\t\t\t\tlayout: bindGroupLayout,\n\t\t\t\tentries: [ {\n\t\t\t\t\tbinding: 0,\n\t\t\t\t\tresource: this.flipYSampler\n\t\t\t\t}, {\n\t\t\t\t\tbinding: 1,\n\t\t\t\t\tresource: sourceView\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: destinationView,\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tpassEncoder.setPipeline( pipeline );\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\n\t\t\tpassEncoder.end();\n\n\t\t};\n\n\t\tpass( transferPipeline, srcView, dstView );\n\t\tpass( flipYPipeline, dstView, srcView );\n\n\t\tthis.device.queue.submit( [ commandEncoder.finish() ] );\n\n\t\ttempTexture.destroy();\n\n\t}\n\n\tgenerateMipmaps( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {\n\n\t\tconst textureData = this.get( textureGPU );\n\n\t\tif ( textureData.useCount === undefined ) {\n\n\t\t\ttextureData.useCount = 0;\n\t\t\ttextureData.layers = [];\n\n\t\t}\n\n\t\tconst passes = textureData.layers[ baseArrayLayer ] || this._mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer );\n\n\t\tconst commandEncoder = this.device.createCommandEncoder( {} );\n\n\t\tthis._mipmapRunBundles( commandEncoder, passes );\n\n\t\tthis.device.queue.submit( [ commandEncoder.finish() ] );\n\n\t\tif ( textureData.useCount !== 0 ) textureData.layers[ baseArrayLayer ] = passes;\n\n\t\ttextureData.useCount ++;\n\n\t}\n\n\t_mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer ) {\n\n\t\tconst pipeline = this.getTransferPipeline( textureGPUDescriptor.format );\n\n\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\n\n\t\tlet srcView = textureGPU.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer\n\t\t} );\n\n\t\tconst passes = [];\n\n\t\tfor ( let i = 1; i < textureGPUDescriptor.mipLevelCount; i ++ ) {\n\n\t\t\tconst bindGroup = this.device.createBindGroup( {\n\t\t\t\tlayout: bindGroupLayout,\n\t\t\t\tentries: [ {\n\t\t\t\t\tbinding: 0,\n\t\t\t\t\tresource: this.mipmapSampler\n\t\t\t\t}, {\n\t\t\t\t\tbinding: 1,\n\t\t\t\t\tresource: srcView\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tconst dstView = textureGPU.createView( {\n\t\t\t\tbaseMipLevel: i,\n\t\t\t\tmipLevelCount: 1,\n\t\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\t\tbaseArrayLayer\n\t\t\t} );\n\n\t\t\tconst passDescriptor = {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: dstView,\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\n\t\t\t\t} ]\n\t\t\t};\n\n\t\t\tconst passEncoder = this.device.createRenderBundleEncoder( {\n\t\t\t\tcolorFormats: [ textureGPUDescriptor.format ]\n\t\t\t} );\n\n\t\t\tpassEncoder.setPipeline( pipeline );\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\n\n\t\t\tpasses.push( {\n\t\t\t\trenderBundles: [ passEncoder.finish() ],\n\t\t\t\tpassDescriptor\n\t\t\t} );\n\n\t\t\tsrcView = dstView;\n\n\t\t}\n\n\t\treturn passes;\n\n\t}\n\n\t_mipmapRunBundles( commandEncoder, passes ) {\n\n\t\tconst levels = passes.length;\n\n\t\tfor ( let i = 0; i < levels; i ++ ) {\n\n\t\t\tconst pass = passes[ i ];\n\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( pass.passDescriptor );\n\n\t\t\tpassEncoder.executeBundles( pass.renderBundles );\n\n\t\t\tpassEncoder.end();\n\n\t\t}\n\n\t}\n\n}\n\nconst _compareToWebGPU = {\n\t[ NeverCompare ]: 'never',\n\t[ LessCompare ]: 'less',\n\t[ EqualCompare ]: 'equal',\n\t[ LessEqualCompare ]: 'less-equal',\n\t[ GreaterCompare ]: 'greater',\n\t[ GreaterEqualCompare ]: 'greater-equal',\n\t[ AlwaysCompare ]: 'always',\n\t[ NotEqualCompare ]: 'not-equal'\n};\n\nconst _flipMap = [ 0, 1, 3, 2, 4, 5 ];\n\nclass WebGPUTextureUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis._passUtils = null;\n\n\t\tthis.defaultTexture = {};\n\t\tthis.defaultCubeTexture = {};\n\t\tthis.defaultVideoFrame = null;\n\n\t\tthis.colorBuffer = null;\n\n\t\tthis.depthTexture = new DepthTexture();\n\t\tthis.depthTexture.name = 'depthBuffer';\n\n\t}\n\n\tcreateSampler( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst textureGPU = backend.get( texture );\n\n\t\tconst samplerDescriptorGPU = {\n\t\t\taddressModeU: this._convertAddressMode( texture.wrapS ),\n\t\t\taddressModeV: this._convertAddressMode( texture.wrapT ),\n\t\t\taddressModeW: this._convertAddressMode( texture.wrapR ),\n\t\t\tmagFilter: this._convertFilterMode( texture.magFilter ),\n\t\t\tminFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\tmipmapFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\tmaxAnisotropy: 1\n\t\t};\n\n\t\t// anisotropy can only be used when all filter modes are set to linear.\n\n\t\tif ( samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear ) {\n\n\t\t\tsamplerDescriptorGPU.maxAnisotropy = texture.anisotropy;\n\n\t\t}\n\n\t\tif ( texture.isDepthTexture && texture.compareFunction !== null ) {\n\n\t\t\tsamplerDescriptorGPU.compare = _compareToWebGPU[ texture.compareFunction ];\n\n\t\t}\n\n\t\ttextureGPU.sampler = device.createSampler( samplerDescriptorGPU );\n\n\t}\n\n\tcreateDefaultTexture( texture ) {\n\n\t\tlet textureGPU;\n\n\t\tconst format = getFormat( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\ttextureGPU = this._getDefaultCubeTextureGPU( format );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\tthis.backend.get( texture ).externalTexture = this._getDefaultVideoFrame();\n\n\t\t} else {\n\n\t\t\ttextureGPU = this._getDefaultTextureGPU( format );\n\n\t\t}\n\n\t\tthis.backend.get( texture ).texture = textureGPU;\n\n\t}\n\n\tcreateTexture( texture, options = {} ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.initialized ) {\n\n\t\t\tthrow new Error( 'WebGPUTextureUtils: Texture already initialized.' );\n\n\t\t}\n\n\t\tif ( options.needsMipmaps === undefined ) options.needsMipmaps = false;\n\t\tif ( options.levels === undefined ) options.levels = 1;\n\t\tif ( options.depth === undefined ) options.depth = 1;\n\n\t\tconst { width, height, depth, levels } = options;\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tif ( options.renderTarget ) {\n\n\t\t\t\toptions.format = this.backend.utils.getCurrentColorFormat( options.renderTarget );\n\n\t\t\t} else {\n\n\t\t\t\toptions.format = this.backend.utils.getPreferredCanvasFormat();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst dimension = this._getDimension( texture );\n\t\tconst format = texture.internalFormat || options.format || getFormat( texture, backend.device );\n\n\t\ttextureData.format = format;\n\n\t\tlet sampleCount = options.sampleCount !== undefined ? options.sampleCount : 1;\n\n\t\tsampleCount = backend.utils.getSampleCount( sampleCount );\n\n\t\tconst primarySampleCount = texture.isRenderTargetTexture && ! texture.isMultisampleRenderTargetTexture ? 1 : sampleCount;\n\n\t\tlet usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n\n\t\tif ( texture.isStorageTexture === true ) {\n\n\t\t\tusage |= GPUTextureUsage.STORAGE_BINDING;\n\n\t\t}\n\n\t\tif ( texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true ) {\n\n\t\t\tusage |= GPUTextureUsage.RENDER_ATTACHMENT;\n\n\t\t}\n\n\t\tconst textureDescriptorGPU = {\n\t\t\tlabel: texture.name,\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: depth,\n\t\t\t},\n\t\t\tmipLevelCount: levels,\n\t\t\tsampleCount: primarySampleCount,\n\t\t\tdimension: dimension,\n\t\t\tformat: format,\n\t\t\tusage: usage\n\t\t};\n\n\t\t// texture creation\n\n\t\tif ( texture.isVideoTexture ) {\n\n\t\t\tconst video = texture.source.data;\n\t\t\tconst videoFrame = new VideoFrame( video );\n\n\t\t\ttextureDescriptorGPU.size.width = videoFrame.displayWidth;\n\t\t\ttextureDescriptorGPU.size.height = videoFrame.displayHeight;\n\n\t\t\tvideoFrame.close();\n\n\t\t\ttextureData.externalTexture = video;\n\n\t\t} else {\n\n\t\t\tif ( format === undefined ) {\n\n\t\t\t\tconsole.warn( 'WebGPURenderer: Texture format not supported.' );\n\n\t\t\t\treturn this.createDefaultTexture( texture );\n\n\t\t\t}\n\n\t\t\ttextureData.texture = backend.device.createTexture( textureDescriptorGPU );\n\n\t\t}\n\n\t\tif ( texture.isRenderTargetTexture && sampleCount > 1 && ! texture.isMultisampleRenderTargetTexture ) {\n\n\t\t\tconst msaaTextureDescriptorGPU = Object.assign( {}, textureDescriptorGPU );\n\n\t\t\tmsaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';\n\t\t\tmsaaTextureDescriptorGPU.sampleCount = sampleCount;\n\n\t\t\ttextureData.msaaTexture = backend.device.createTexture( msaaTextureDescriptorGPU );\n\n\t\t}\n\n\t\ttextureData.initialized = true;\n\n\t\ttextureData.textureDescriptorGPU = textureDescriptorGPU;\n\n\t}\n\n\tdestroyTexture( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.texture !== undefined ) textureData.texture.destroy();\n\n\t\tif ( textureData.msaaTexture !== undefined ) textureData.msaaTexture.destroy();\n\n\t\tbackend.delete( texture );\n\n\t}\n\n\tdestroySampler( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tdelete textureData.sampler;\n\n\t}\n\n\tgenerateMipmaps( texture ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst depth = texture.image.depth || 1;\n\n\t\t\tfor ( let i = 0; i < depth; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetColorBuffer() {\n\n\t\tif ( this.colorBuffer ) this.colorBuffer.destroy();\n\n\t\tconst backend = this.backend;\n\t\tconst { width, height } = backend.getDrawingBufferSize();\n\n\t\tthis.colorBuffer = backend.device.createTexture( {\n\t\t\tlabel: 'colorBuffer',\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t},\n\t\t\tsampleCount: backend.utils.getSampleCount( backend.renderer.samples ),\n\t\t\tformat: backend.utils.getPreferredCanvasFormat(),\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n\t\t} );\n\n\t\treturn this.colorBuffer;\n\n\t}\n\n\tgetDepthBuffer( depth = true, stencil = false ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { width, height } = backend.getDrawingBufferSize();\n\n\t\tconst depthTexture = this.depthTexture;\n\t\tconst depthTextureGPU = backend.get( depthTexture ).texture;\n\n\t\tlet format, type;\n\n\t\tif ( stencil ) {\n\n\t\t\tformat = DepthStencilFormat;\n\t\t\ttype = UnsignedInt248Type;\n\n\t\t} else if ( depth ) {\n\n\t\t\tformat = DepthFormat;\n\t\t\ttype = UnsignedIntType;\n\n\t\t}\n\n\t\tif ( depthTextureGPU !== undefined ) {\n\n\t\t\tif ( depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type ) {\n\n\t\t\t\treturn depthTextureGPU;\n\n\t\t\t}\n\n\t\t\tthis.destroyTexture( depthTexture );\n\n\t\t}\n\n\t\tdepthTexture.name = 'depthBuffer';\n\t\tdepthTexture.format = format;\n\t\tdepthTexture.type = type;\n\t\tdepthTexture.image.width = width;\n\t\tdepthTexture.image.height = height;\n\n\t\tthis.createTexture( depthTexture, { sampleCount: backend.utils.getSampleCount( backend.renderer.samples ), width, height } );\n\n\t\treturn backend.get( depthTexture ).texture;\n\n\t}\n\n\tupdateTexture( texture, options ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tconst { textureDescriptorGPU } = textureData;\n\n\t\tif ( texture.isRenderTargetTexture || ( textureDescriptorGPU === undefined /* unsupported texture format */ ) )\n\t\t\treturn;\n\n\t\t// transfer texture data\n\n\t\tif ( texture.isDataTexture ) {\n\n\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );\n\n\t\t} else if ( texture.isDataArrayTexture || texture.isData3DTexture ) {\n\n\t\t\tfor ( let i = 0; i < options.image.depth; i ++ ) {\n\n\t\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i );\n\n\t\t\t}\n\n\t\t} else if ( texture.isCompressedTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\tthis._copyCompressedBufferToTexture( texture.mipmaps, textureData.texture, textureDescriptorGPU );\n\n\t\t} else if ( texture.isCubeTexture ) {\n\n\t\t\tthis._copyCubeMapToTexture( options.images, textureData.texture, textureDescriptorGPU, texture.flipY );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\tconst video = texture.source.data;\n\n\t\t\ttextureData.externalTexture = video;\n\n\t\t} else {\n\n\t\t\tthis._copyImageToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );\n\n\t\t}\n\n\t\t//\n\n\t\ttextureData.version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tconst textureData = this.backend.get( texture );\n\t\tconst textureGPU = textureData.texture;\n\t\tconst format = textureData.textureDescriptorGPU.format;\n\t\tconst bytesPerTexel = this._getBytesPerTexel( format );\n\n\t\tlet bytesPerRow = width * bytesPerTexel;\n\t\tbytesPerRow = Math.ceil( bytesPerRow / 256 ) * 256; // Align to 256 bytes\n\n\t\tconst readBuffer = device.createBuffer(\n\t\t\t{\n\t\t\t\tsize: width * height * bytesPerTexel,\n\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t}\n\t\t);\n\n\t\tconst encoder = device.createCommandEncoder();\n\n\t\tencoder.copyTextureToBuffer(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\torigin: { x, y, z: faceIndex },\n\t\t\t},\n\t\t\t{\n\t\t\t\tbuffer: readBuffer,\n\t\t\t\tbytesPerRow: bytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t}\n\n\t\t);\n\n\t\tconst typedArrayType = this._getTypedArrayType( format );\n\n\t\tdevice.queue.submit( [ encoder.finish() ] );\n\n\t\tawait readBuffer.mapAsync( GPUMapMode.READ );\n\n\t\tconst buffer = readBuffer.getMappedRange();\n\n\t\treturn new typedArrayType( buffer );\n\n\t}\n\n\t_isEnvironmentTexture( texture ) {\n\n\t\tconst mapping = texture.mapping;\n\n\t\treturn ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\n\n\t}\n\n\t_getDefaultTextureGPU( format ) {\n\n\t\tlet defaultTexture = this.defaultTexture[ format ];\n\n\t\tif ( defaultTexture === undefined ) {\n\n\t\t\tconst texture = new Texture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, format } );\n\n\t\t\tthis.defaultTexture[ format ] = defaultTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultTexture ).texture;\n\n\t}\n\n\t_getDefaultCubeTextureGPU( format ) {\n\n\t\tlet defaultCubeTexture = this.defaultTexture[ format ];\n\n\t\tif ( defaultCubeTexture === undefined ) {\n\n\t\t\tconst texture = new CubeTexture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, depth: 6 } );\n\n\t\t\tthis.defaultCubeTexture[ format ] = defaultCubeTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultCubeTexture ).texture;\n\n\t}\n\n\t_getDefaultVideoFrame() {\n\n\t\tlet defaultVideoFrame = this.defaultVideoFrame;\n\n\t\tif ( defaultVideoFrame === null ) {\n\n\t\t\tconst init = {\n\t\t\t\ttimestamp: 0,\n\t\t\t\tcodedWidth: 1,\n\t\t\t\tcodedHeight: 1,\n\t\t\t\tformat: 'RGBA',\n\t\t\t};\n\n\t\t\tthis.defaultVideoFrame = defaultVideoFrame = new VideoFrame( new Uint8Array( [ 0, 0, 0, 0xff ] ), init );\n\n\t\t}\n\n\t\treturn defaultVideoFrame;\n\n\t}\n\n\t_copyCubeMapToTexture( images, textureGPU, textureDescriptorGPU, flipY ) {\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst image = images[ i ];\n\n\t\t\tconst flipIndex = flipY === true ? _flipMap[ i ] : i;\n\n\t\t\tif ( image.isDataTexture ) {\n\n\t\t\t\tthis._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY );\n\n\t\t\t} else {\n\n\t\t\t\tthis._copyImageToTexture( image, textureGPU, textureDescriptorGPU, flipIndex, flipY );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_copyImageToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tdevice.queue.copyExternalImageToTexture(\n\t\t\t{\n\t\t\t\tsource: image\n\t\t\t}, {\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: 0,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth }\n\t\t\t}, {\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t}\n\t\t);\n\n\t\tif ( flipY === true ) {\n\n\t\t\tthis._flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t\t}\n\n\t}\n\n\t_getPassUtils() {\n\n\t\tlet passUtils = this._passUtils;\n\n\t\tif ( passUtils === null ) {\n\n\t\t\tthis._passUtils = passUtils = new WebGPUTexturePassUtils( this.backend.device );\n\n\t\t}\n\n\t\treturn passUtils;\n\n\t}\n\n\t_generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer = 0 ) {\n\n\t\tthis._getPassUtils().generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer );\n\n\t}\n\n\t_flipY( textureGPU, textureDescriptorGPU, originDepth = 0 ) {\n\n\t\tthis._getPassUtils().flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t}\n\n\t_copyBufferToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0 ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\t\t// @TODO: Consider to support valid buffer layouts with other formats like RGB\n\n\t\tconst device = this.backend.device;\n\n\t\tconst data = image.data;\n\n\t\tconst bytesPerTexel = this._getBytesPerTexel( textureDescriptorGPU.format );\n\t\tconst bytesPerRow = image.width * bytesPerTexel;\n\n\t\tdevice.queue.writeTexture(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: 0,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth }\n\t\t\t},\n\t\t\tdata,\n\t\t\t{\n\t\t\t\toffset: image.width * image.height * bytesPerTexel * depth,\n\t\t\t\tbytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t} );\n\n\t\tif ( flipY === true ) {\n\n\t\t\tthis._flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t\t}\n\n\t}\n\n\t_copyCompressedBufferToTexture( mipmaps, textureGPU, textureDescriptorGPU ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\n\t\tconst device = this.backend.device;\n\n\t\tconst blockData = this._getBlockData( textureDescriptorGPU.format );\n\t\tconst isTextureArray = textureDescriptorGPU.size.depthOrArrayLayers > 1;\n\n\t\tfor ( let i = 0; i < mipmaps.length; i ++ ) {\n\n\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\tconst width = mipmap.width;\n\t\t\tconst height = mipmap.height;\n\t\t\tconst depth = isTextureArray ? textureDescriptorGPU.size.depthOrArrayLayers : 1;\n\n\t\t\tconst bytesPerRow = Math.ceil( width / blockData.width ) * blockData.byteLength;\n\t\t\tconst bytesPerImage = bytesPerRow * Math.ceil( height / blockData.height );\n\n\t\t\tfor ( let j = 0; j < depth; j ++ ) {\n\n\t\t\t\tdevice.queue.writeTexture(\n\t\t\t\t\t{\n\t\t\t\t\t\ttexture: textureGPU,\n\t\t\t\t\t\tmipLevel: i,\n\t\t\t\t\t\torigin: { x: 0, y: 0, z: j }\n\t\t\t\t\t},\n\t\t\t\t\tmipmap.data,\n\t\t\t\t\t{\n\t\t\t\t\t\toffset: j * bytesPerImage,\n\t\t\t\t\t\tbytesPerRow,\n\t\t\t\t\t\trowsPerImage: Math.ceil( height / blockData.height )\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\twidth: Math.ceil( width / blockData.width ) * blockData.width,\n\t\t\t\t\t\theight: Math.ceil( height / blockData.height ) * blockData.height,\n\t\t\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_getBlockData( format ) {\n\n\t\t// this method is only relevant for compressed texture formats\n\n\t\tif ( format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB ) return { byteLength: 8, width: 4, height: 4 }; // DXT1\n\t\tif ( format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT3\n\t\tif ( format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT5\n\t\tif ( format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm ) return { byteLength: 8, width: 4, height: 4 }; // RGTC1\n\t\tif ( format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm ) return { byteLength: 16, width: 4, height: 4 }; // RGTC2\n\t\tif ( format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)\n\t\tif ( format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)\n\n\t\tif ( format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Unorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Snorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Unorm ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Snorm ) return { byteLength: 16, width: 4, height: 4 };\n\n\t\tif ( format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB ) return { byteLength: 16, width: 5, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB ) return { byteLength: 16, width: 5, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB ) return { byteLength: 16, width: 6, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB ) return { byteLength: 16, width: 6, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB ) return { byteLength: 16, width: 8, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB ) return { byteLength: 16, width: 8, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB ) return { byteLength: 16, width: 8, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB ) return { byteLength: 16, width: 10, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB ) return { byteLength: 16, width: 10, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB ) return { byteLength: 16, width: 10, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB ) return { byteLength: 16, width: 10, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB ) return { byteLength: 16, width: 12, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB ) return { byteLength: 16, width: 12, height: 12 };\n\n\t}\n\n\t_convertAddressMode( value ) {\n\n\t\tlet addressMode = GPUAddressMode.ClampToEdge;\n\n\t\tif ( value === RepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.Repeat;\n\n\t\t} else if ( value === MirroredRepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.MirrorRepeat;\n\n\t\t}\n\n\t\treturn addressMode;\n\n\t}\n\n\t_convertFilterMode( value ) {\n\n\t\tlet filterMode = GPUFilterMode.Linear;\n\n\t\tif ( value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter ) {\n\n\t\t\tfilterMode = GPUFilterMode.Nearest;\n\n\t\t}\n\n\t\treturn filterMode;\n\n\t}\n\n\t_getBytesPerTexel( format ) {\n\n\t\t// 8-bit formats\n\t\tif ( format === GPUTextureFormat.R8Unorm ||\n\t\t\tformat === GPUTextureFormat.R8Snorm ||\n\t\t\tformat === GPUTextureFormat.R8Uint ||\n\t\t\tformat === GPUTextureFormat.R8Sint ) return 1;\n\n\t\t// 16-bit formats\n\t\tif ( format === GPUTextureFormat.R16Uint ||\n\t\t\tformat === GPUTextureFormat.R16Sint ||\n\t\t\tformat === GPUTextureFormat.R16Float ||\n\t\t\tformat === GPUTextureFormat.RG8Unorm ||\n\t\t\tformat === GPUTextureFormat.RG8Snorm ||\n\t\t\tformat === GPUTextureFormat.RG8Uint ||\n\t\t\tformat === GPUTextureFormat.RG8Sint ) return 2;\n\n\t\t// 32-bit formats\n\t\tif ( format === GPUTextureFormat.R32Uint ||\n\t\t\tformat === GPUTextureFormat.R32Sint ||\n\t\t\tformat === GPUTextureFormat.R32Float ||\n\t\t\tformat === GPUTextureFormat.RG16Uint ||\n\t\t\tformat === GPUTextureFormat.RG16Sint ||\n\t\t\tformat === GPUTextureFormat.RG16Float ||\n\t\t\tformat === GPUTextureFormat.RGBA8Unorm ||\n\t\t\tformat === GPUTextureFormat.RGBA8UnormSRGB ||\n\t\t\tformat === GPUTextureFormat.RGBA8Snorm ||\n\t\t\tformat === GPUTextureFormat.RGBA8Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA8Sint ||\n\t\t\tformat === GPUTextureFormat.BGRA8Unorm ||\n\t\t\tformat === GPUTextureFormat.BGRA8UnormSRGB ||\n\t\t\t// Packed 32-bit formats\n\t\t\tformat === GPUTextureFormat.RGB9E5UFloat ||\n\t\t\tformat === GPUTextureFormat.RGB10A2Unorm ||\n\t\t\tformat === GPUTextureFormat.RG11B10UFloat ||\n\t\t\tformat === GPUTextureFormat.Depth32Float ||\n\t\t\tformat === GPUTextureFormat.Depth24Plus ||\n\t\t\tformat === GPUTextureFormat.Depth24PlusStencil8 ||\n\t\t\tformat === GPUTextureFormat.Depth32FloatStencil8 ) return 4;\n\n\t\t// 64-bit formats\n\t\tif ( format === GPUTextureFormat.RG32Uint ||\n\t\t\tformat === GPUTextureFormat.RG32Sint ||\n\t\t\tformat === GPUTextureFormat.RG32Float ||\n\t\t\tformat === GPUTextureFormat.RGBA16Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA16Sint ||\n\t\t\tformat === GPUTextureFormat.RGBA16Float ) return 8;\n\n\t\t// 128-bit formats\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA32Sint ||\n\t\t\tformat === GPUTextureFormat.RGBA32Float ) return 16;\n\n\n\t}\n\n\t_getTypedArrayType( format ) {\n\n\t\tif ( format === GPUTextureFormat.R8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.R8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Snorm ) return Int8Array;\n\n\n\t\tif ( format === GPUTextureFormat.R16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.R16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RG16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.R16Float ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Float ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Float ) return Uint16Array;\n\n\n\t\tif ( format === GPUTextureFormat.R32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.R32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.R32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RG32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RG32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Float ) return Float32Array;\n\n\t\tif ( format === GPUTextureFormat.BGRA8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.BGRA8UnormSRGB ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGB10A2Unorm ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGB9E5UFloat ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG11B10UFloat ) return Uint32Array;\n\n\t\tif ( format === GPUTextureFormat.Depth32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.Depth24Plus ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.Depth24PlusStencil8 ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.Depth32FloatStencil8 ) return Float32Array;\n\n\t}\n\n\t_getDimension( texture ) {\n\n\t\tlet dimension;\n\n\t\tif ( texture.isData3DTexture ) {\n\n\t\t\tdimension = GPUTextureDimension.ThreeD;\n\n\t\t} else {\n\n\t\t\tdimension = GPUTextureDimension.TwoD;\n\n\t\t}\n\n\t\treturn dimension;\n\n\t}\n\n}\n\nfunction getFormat( texture, device = null ) {\n\n\tconst format = texture.format;\n\tconst type = texture.type;\n\tconst colorSpace = texture.colorSpace;\n\n\tlet formatGPU;\n\n\tif ( texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBA_S3TC_DXT1_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT3_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGB_ETC2_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ETC2_EAC_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_4x4_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x4_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x8_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x8_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x10_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x10_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x12_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBAFormat:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t} else {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBAFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Uint;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBAFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGBFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt5999Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGB9E5UFloat;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RedFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth16Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24Plus;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with DepthFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthStencilFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt248Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24PlusStencil8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tif ( device && device.features.has( GPUFeatureName.Depth32FloatStencil8 ) === false ) {\n\n\t\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the \"depth32float-stencil8\" GPU feature.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32FloatStencil8;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGBAIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t}\n\n\treturn formatGPU;\n\n}\n\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/i;\nconst propertiesRegexp = /([a-z_0-9]+)\\s*:\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/ig;\n\nconst wgslTypeLib$1 = {\n\t'f32': 'float',\n\t'i32': 'int',\n\t'u32': 'uint',\n\t'bool': 'bool',\n\n\t'vec2<f32>': 'vec2',\n \t'vec2<i32>': 'ivec2',\n \t'vec2<u32>': 'uvec2',\n \t'vec2<bool>': 'bvec2',\n\n\t'vec2f': 'vec2',\n\t'vec2i': 'ivec2',\n\t'vec2u': 'uvec2',\n\t'vec2b': 'bvec2',\n\n\t'vec3<f32>': 'vec3',\n\t'vec3<i32>': 'ivec3',\n\t'vec3<u32>': 'uvec3',\n\t'vec3<bool>': 'bvec3',\n\n\t'vec3f': 'vec3',\n\t'vec3i': 'ivec3',\n\t'vec3u': 'uvec3',\n\t'vec3b': 'bvec3',\n\n\t'vec4<f32>': 'vec4',\n\t'vec4<i32>': 'ivec4',\n\t'vec4<u32>': 'uvec4',\n\t'vec4<bool>': 'bvec4',\n\n\t'vec4f': 'vec4',\n\t'vec4i': 'ivec4',\n\t'vec4u': 'uvec4',\n\t'vec4b': 'bvec4',\n\n\t'mat2x2<f32>': 'mat2',\n\t'mat2x2f': 'mat2',\n\n\t'mat3x3<f32>': 'mat3',\n\t'mat3x3f': 'mat3',\n\n\t'mat4x4<f32>': 'mat4',\n\t'mat4x4f': 'mat4',\n\n\t'sampler': 'sampler',\n\n\t'texture_1d': 'texture',\n\n\t'texture_2d': 'texture',\n\t'texture_2d_array': 'texture',\n\t'texture_multisampled_2d': 'cubeTexture',\n\n\t'texture_depth_2d': 'depthTexture',\n\n\t'texture_3d': 'texture3D',\n\n\t'texture_cube': 'cubeTexture',\n\t'texture_cube_array': 'cubeTexture',\n\n\t'texture_storage_1d': 'storageTexture',\n\t'texture_storage_2d': 'storageTexture',\n\t'texture_storage_2d_array': 'storageTexture',\n\t'texture_storage_3d': 'storageTexture'\n\n};\n\nconst parse = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst declaration = source.match( declarationRegexp );\n\n\tif ( declaration !== null && declaration.length === 4 ) {\n\n\t\tconst inputsCode = declaration[ 2 ];\n\t\tconst propsMatches = [];\n\t\tlet match = null;\n\n\t\twhile ( ( match = propertiesRegexp.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( { name: match[ 1 ], type: match[ 2 ] } );\n\n\t\t}\n\n\t\t// Process matches to correctly pair names and types\n\t\tconst inputs = [];\n\t\tfor ( let i = 0; i < propsMatches.length; i ++ ) {\n\n\t\t\tconst { name, type } = propsMatches[ i ];\n\n\t\t\tlet resolvedType = type;\n\n\t\t\tif ( resolvedType.startsWith( 'ptr' ) ) {\n\n\t\t\t\tresolvedType = 'pointer';\n\n\t\t\t} else {\n\n\t\t\t\tif ( resolvedType.startsWith( 'texture' ) ) {\n\n\t\t\t\t\tresolvedType = type.split( '<' )[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tresolvedType = wgslTypeLib$1[ resolvedType ];\n\n\t\t\t}\n\n\t\t\tinputs.push( new NodeFunctionInput( resolvedType, name ) );\n\n\t\t}\n\n\t\tconst blockCode = source.substring( declaration[ 0 ].length );\n\t\tconst outputType = declaration[ 3 ] || 'void';\n\n\t\tconst name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\t\tconst type = wgslTypeLib$1[ outputType ] || outputType;\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\toutputType\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a WGSL code.' );\n\n\t}\n\n};\n\nclass WGSLNodeFunction extends NodeFunction {\n\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, inputsCode, blockCode, outputType } = parse( source );\n\n\t\tsuper( type, inputs, name );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.outputType = outputType;\n\n\t}\n\n\tgetCode( name = this.name ) {\n\n\t\tconst outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';\n\n\t\treturn `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ outputType }` + this.blockCode;\n\n\t}\n\n}\n\nclass WGSLNodeParser extends NodeParser {\n\n\tparseFunction( source ) {\n\n\t\treturn new WGSLNodeFunction( source );\n\n\t}\n\n}\n\n// GPUShaderStage is not defined in browsers not supporting WebGPU\nconst GPUShaderStage = ( typeof self !== 'undefined' ) ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };\n\nconst accessNames = {\n\t[ NodeAccess.READ_ONLY ]: 'read',\n\t[ NodeAccess.WRITE_ONLY ]: 'write',\n\t[ NodeAccess.READ_WRITE ]: 'read_write'\n};\n\nconst wrapNames = {\n\t[ RepeatWrapping ]: 'repeat',\n\t[ ClampToEdgeWrapping ]: 'clamp',\n\t[ MirroredRepeatWrapping ]: 'mirror'\n};\n\nconst gpuShaderStageLib = {\n\t'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,\n\t'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,\n\t'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4\n};\n\nconst supports = {\n\tinstance: true,\n\tswizzleAssign: false,\n\tstorageBuffer: true\n};\n\nconst wgslFnOpLib = {\n\t'^^': 'tsl_xor'\n};\n\nconst wgslTypeLib = {\n\tfloat: 'f32',\n\tint: 'i32',\n\tuint: 'u32',\n\tbool: 'bool',\n\tcolor: 'vec3<f32>',\n\n\tvec2: 'vec2<f32>',\n\tivec2: 'vec2<i32>',\n\tuvec2: 'vec2<u32>',\n\tbvec2: 'vec2<bool>',\n\n\tvec3: 'vec3<f32>',\n\tivec3: 'vec3<i32>',\n\tuvec3: 'vec3<u32>',\n\tbvec3: 'vec3<bool>',\n\n\tvec4: 'vec4<f32>',\n\tivec4: 'vec4<i32>',\n\tuvec4: 'vec4<u32>',\n\tbvec4: 'vec4<bool>',\n\n\tmat2: 'mat2x2<f32>',\n\tmat3: 'mat3x3<f32>',\n\tmat4: 'mat4x4<f32>'\n};\n\nconst wgslCodeCache = {};\n\nconst wgslPolyfill = {\n\ttsl_xor: new CodeNode( 'fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }' ),\n\tmod_float: new CodeNode( 'fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }' ),\n\tmod_vec2: new CodeNode( 'fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }' ),\n\tmod_vec3: new CodeNode( 'fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }' ),\n\tmod_vec4: new CodeNode( 'fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }' ),\n\tequals_bool: new CodeNode( 'fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }' ),\n\tequals_bvec2: new CodeNode( 'fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }' ),\n\tequals_bvec3: new CodeNode( 'fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }' ),\n\tequals_bvec4: new CodeNode( 'fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }' ),\n\trepeatWrapping_float: new CodeNode( 'fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }' ),\n\tmirrorWrapping_float: new CodeNode( 'fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }' ),\n\tclampWrapping_float: new CodeNode( 'fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }' ),\n\tbiquadraticTexture: new CodeNode( /* wgsl */`\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {\n\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n` )\n};\n\nconst wgslMethods = {\n\tdFdx: 'dpdx',\n\tdFdy: '- dpdy',\n\tmod_float: 'tsl_mod_float',\n\tmod_vec2: 'tsl_mod_vec2',\n\tmod_vec3: 'tsl_mod_vec3',\n\tmod_vec4: 'tsl_mod_vec4',\n\tequals_bool: 'tsl_equals_bool',\n\tequals_bvec2: 'tsl_equals_bvec2',\n\tequals_bvec3: 'tsl_equals_bvec3',\n\tequals_bvec4: 'tsl_equals_bvec4',\n\tinversesqrt: 'inverseSqrt',\n\tbitcast: 'bitcast<f32>'\n};\n\n// WebGPU issue: does not support pow() with negative base on Windows\n\nif ( typeof navigator !== 'undefined' && /Windows/g.test( navigator.userAgent ) ) {\n\n\twgslPolyfill.pow_float = new CodeNode( 'fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }' );\n\twgslPolyfill.pow_vec2 = new CodeNode( 'fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [ wgslPolyfill.pow_float ] );\n\twgslPolyfill.pow_vec3 = new CodeNode( 'fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [ wgslPolyfill.pow_float ] );\n\twgslPolyfill.pow_vec4 = new CodeNode( 'fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [ wgslPolyfill.pow_float ] );\n\n\twgslMethods.pow_float = 'tsl_pow_float';\n\twgslMethods.pow_vec2 = 'tsl_pow_vec2';\n\twgslMethods.pow_vec3 = 'tsl_pow_vec3';\n\twgslMethods.pow_vec4 = 'tsl_pow_vec4';\n\n}\n\n//\n\nlet diagnostics = '';\n\nif ( ( typeof navigator !== 'undefined' && /Firefox|Deno/g.test( navigator.userAgent ) ) !== true ) {\n\n\tdiagnostics += 'diagnostic( off, derivative_uniformity );\\n';\n\n}\n\n//\n\nclass WGSLNodeBuilder extends NodeBuilder {\n\n\tconstructor( object, renderer ) {\n\n\t\tsuper( object, renderer, new WGSLNodeParser() );\n\n\t\tthis.uniformGroups = {};\n\n\t\tthis.builtins = {};\n\n\t\tthis.directives = {};\n\n\t\tthis.scopedArrays = new Map();\n\n\t}\n\n\tneedsToWorkingColorSpace( texture ) {\n\n\t\treturn texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n\n\t}\n\n\t_generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\tif ( depthSnippet ) {\n\n\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\t\t} else {\n\n\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet } )`;\n\n\t\t\t}\n\n\t\t} else if ( this.isFilteredTexture( texture ) ) {\n\n\t\t\treturn this.generateFilteredTexture( texture, textureProperty, uvSnippet );\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0' );\n\n\t\t}\n\n\t}\n\n\t_generateVideoSample( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleBaseClampToEdge( ${ textureProperty }, ${ textureProperty }_sampler, vec2<f32>( ${ uvSnippet }.x, 1.0 - ${ uvSnippet }.y ) )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.VideoTexture does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t_generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' && this.isUnfilterable( texture ) === false ) {\n\n\t\t\treturn `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t\t} else if ( this.isFilteredTexture( texture ) ) {\n\n\t\t\treturn this.generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet );\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet );\n\n\t\t}\n\n\t}\n\n\tgenerateWrapFunction( texture ) {\n\n\t\tconst functionName = `tsl_coord_${ wrapNames[ texture.wrapS ] }S_${ wrapNames[ texture.wrapT ] }T`;\n\n\t\tlet nodeCode = wgslCodeCache[ functionName ];\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst includes = [];\n\n\t\t\tlet code = `fn ${ functionName }( coord : vec2f ) -> vec2f {\\n\\n\\treturn vec2f(\\n`;\n\n\t\t\tconst addWrapSnippet = ( wrap, axis ) => {\n\n\t\t\t\tif ( wrap === RepeatWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.repeatWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_repeatWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else if ( wrap === ClampToEdgeWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.clampWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_clampWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else if ( wrap === MirroredRepeatWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.mirrorWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_mirrorWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcode += `\\t\\tcoord.${ axis }`;\n\n\t\t\t\t\tconsole.warn( `WebGPURenderer: Unsupported texture wrap type \"${ wrap }\" for vertex shader.` );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\taddWrapSnippet( texture.wrapS, 'x' );\n\n\t\t\tcode += ',\\n';\n\n\t\t\taddWrapSnippet( texture.wrapT, 'y' );\n\n\t\t\tcode += '\\n\\t);\\n\\n}\\n';\n\n\t\t\twgslCodeCache[ functionName ] = nodeCode = new CodeNode( code, includes );\n\n\t\t}\n\n\t\tnodeCode.build( this );\n\n\t\treturn functionName;\n\n\t}\n\n\tgenerateTextureDimension( texture, textureProperty, levelSnippet ) {\n\n\t\tconst textureData = this.getDataFromNode( texture, this.shaderStage, this.globalCache );\n\n\t\tif ( textureData.dimensionsSnippet === undefined ) textureData.dimensionsSnippet = {};\n\n\t\tlet textureDimensionNode = textureData.dimensionsSnippet[ levelSnippet ];\n\n\t\tif ( textureData.dimensionsSnippet[ levelSnippet ] === undefined ) {\n\n\t\t\tlet textureDimensionsParams;\n\n\t\t\tif ( texture.isMultisampleRenderTargetTexture === true ) {\n\n\t\t\t\ttextureDimensionsParams = textureProperty;\n\n\t\t\t} else {\n\n\t\t\t\ttextureDimensionsParams = `${ textureProperty }, u32( ${ levelSnippet } )`;\n\n\t\t\t}\n\n\t\t\ttextureDimensionNode = new VarNode( new ExpressionNode( `textureDimensions( ${ textureDimensionsParams } )`, 'uvec2' ) );\n\n\t\t\ttextureData.dimensionsSnippet[ levelSnippet ] = textureDimensionNode;\n\n\t\t}\n\n\t\treturn textureDimensionNode.build( this );\n\n\t}\n\n\tgenerateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet = '0u' ) {\n\n\t\tthis._include( 'biquadraticTexture' );\n\n\t\tconst wrapFunction = this.generateWrapFunction( texture );\n\t\tconst textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );\n\n\t\treturn `tsl_biquadraticTexture( ${ textureProperty }, ${ wrapFunction }( ${ uvSnippet } ), ${ textureDimension }, u32( ${ levelSnippet } ) )`;\n\n\t}\n\n\tgenerateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet = '0u' ) {\n\n\t\tconst wrapFunction = this.generateWrapFunction( texture );\n\t\tconst textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );\n\n\t\tconst coordSnippet = `vec2u( ${ wrapFunction }( ${ uvSnippet } ) * vec2f( ${ textureDimension } ) )`;\n\n\t\treturn this.generateTextureLoad( texture, textureProperty, coordSnippet, depthSnippet, levelSnippet );\n\n\t}\n\n\tgenerateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u' ) {\n\n\t\tif ( texture.isVideoTexture === true || texture.isStorageTexture === true ) {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet } )`;\n\n\t\t} else if ( depthSnippet ) {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, u32( ${ levelSnippet } ) )`;\n\n\t\t} else {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, u32( ${ levelSnippet } ) )`;\n\n\t\t}\n\n\t}\n\n\tgenerateTextureStore( texture, textureProperty, uvIndexSnippet, valueSnippet ) {\n\n\t\treturn `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ valueSnippet } )`;\n\n\t}\n\n\tisSampleCompare( texture ) {\n\n\t\treturn texture.isDepthTexture === true && texture.compareFunction !== null;\n\n\t}\n\n\tisUnfilterable( texture ) {\n\n\t\treturn this.getComponentTypeFromTexture( texture ) !== 'float' ||\n\t\t\t( ! this.isAvailable( 'float32Filterable' ) && texture.isDataTexture === true && texture.type === FloatType ) ||\n\t\t\t( this.isSampleCompare( texture ) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter ) ||\n\t\t\ttexture.isMultisampleRenderTargetTexture === true;\n\n\t}\n\n\tgenerateTexture( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tlet snippet = null;\n\n\t\tif ( texture.isVideoTexture === true ) {\n\n\t\t\tsnippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );\n\n\t\t} else if ( this.isUnfilterable( texture ) ) {\n\n\t\t\tsnippet = this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage );\n\n\t\t} else {\n\n\t\t\tsnippet = this._generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgenerateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\t// TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy\n\t\t\treturn `textureSampleGrad( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet },  ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.TextureNode.gradient() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\tgenerateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ compareSnippet } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\tgenerateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tlet snippet = null;\n\n\t\tif ( texture.isVideoTexture === true ) {\n\n\t\t\tsnippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );\n\n\t\t} else {\n\n\t\t\tsnippet = this._generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgenerateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleBias( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ biasSnippet } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.TextureNode.biasNode does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeVarying === true && node.needsInterpolation === true ) {\n\n\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\treturn `varyings.${ node.name }`;\n\n\t\t\t}\n\n\t\t} else if ( node.isNodeUniform === true ) {\n\n\t\t\tconst name = node.name;\n\t\t\tconst type = node.type;\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {\n\n\t\t\t\treturn name;\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {\n\n\t\t\t\treturn `NodeBuffer_${ node.id }.${name}`;\n\n\t\t\t} else {\n\n\t\t\t\treturn node.groupNode.name + '.' + name;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.getPropertyName( node );\n\n\t}\n\n\tgetOutputStructName() {\n\n\t\treturn 'output';\n\n\t}\n\n\t_getUniformGroupCount( shaderStage ) {\n\n\t\treturn Object.keys( this.uniforms[ shaderStage ] ).length;\n\n\t}\n\n\tgetFunctionOperator( op ) {\n\n\t\tconst fnOp = wgslFnOpLib[ op ];\n\n\t\tif ( fnOp !== undefined ) {\n\n\t\t\tthis._include( fnOp );\n\n\t\t\treturn fnOp;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tgetNodeAccess( node, shaderStage ) {\n\n\t\tif ( shaderStage !== 'compute' )\n\t\t\treturn NodeAccess.READ_ONLY;\n\n\t\treturn node.access;\n\n\t}\n\n\tgetStorageAccess( node, shaderStage ) {\n\n\t\treturn accessNames[ this.getNodeAccess( node, shaderStage ) ];\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tif ( nodeData.uniformGPU === undefined ) {\n\n\t\t\tlet uniformGPU;\n\n\t\t\tconst group = node.groupNode;\n\t\t\tconst groupName = group.name;\n\n\t\t\tconst bindings = this.getBindGroupArray( groupName, shaderStage );\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {\n\n\t\t\t\tlet texture = null;\n\n\t\t\t\tconst access = this.getNodeAccess( node, shaderStage );\n\n\t\t\t\tif ( type === 'texture' || type === 'storageTexture' ) {\n\n\t\t\t\t\ttexture = new NodeSampledTexture( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\t\ttexture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t} else if ( type === 'texture3D' ) {\n\n\t\t\t\t\ttexture = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.store = node.isStorageTextureNode === true;\n\t\t\t\ttexture.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\tif ( shaderStage === 'fragment' && this.isUnfilterable( node.value ) === false && texture.store === false ) {\n\n\t\t\t\t\tconst sampler = new NodeSampler( `${uniformNode.name}_sampler`, uniformNode.node, group );\n\t\t\t\t\tsampler.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tbindings.push( sampler, texture );\n\n\t\t\t\t\tuniformGPU = [ sampler, texture ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbindings.push( texture );\n\n\t\t\t\t\tuniformGPU = [ texture ];\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tconst bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;\n\n\t\t\t\tconst buffer = new bufferClass( node, group );\n\t\t\t\tbuffer.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\tbindings.push( buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t} else {\n\n\t\t\t\tconst uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );\n\n\t\t\t\tlet uniformsGroup = uniformsStage[ groupName ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new NodeUniformsGroup( groupName, group );\n\t\t\t\t\tuniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tuniformsStage[ groupName ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n\tgetBuiltin( name, property, type, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.builtins[ shaderStage ] || ( this.builtins[ shaderStage ] = new Map() );\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tproperty,\n\t\t\t\ttype\n\t\t\t} );\n\n\t\t}\n\n\t\treturn property;\n\n\t}\n\n\thasBuiltin( name, shaderStage = this.shaderStage ) {\n\n\t\treturn ( this.builtins[ shaderStage ] !== undefined && this.builtins[ shaderStage ].has( name ) );\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'vertex_index', 'vertexIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'vertexIndex';\n\n\t}\n\n\tbuildFunctionCode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\t\tconst flowData = this.flowShaderNode( shaderNode );\n\n\t\tconst parameters = [];\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tparameters.push( input.name + ' : ' + this.getType( input.type ) );\n\n\t\t}\n\n\t\t//\n\n\t\tlet code = `fn ${ layout.name }( ${ parameters.join( ', ' ) } ) -> ${ this.getType( layout.type ) } {\n${ flowData.vars }\n${ flowData.code }\n`;\n\n\t\tif ( flowData.result ) {\n\n\t\t\tcode += `\\treturn ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tcode += '\\n}\\n';\n\n\t\t//\n\n\t\treturn code;\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'instanceIndex';\n\n\t}\n\n\tgetInvocationLocalIndex() {\n\n\t\treturn this.getBuiltin( 'local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute' );\n\n\t}\n\n\tgetSubgroupSize() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );\n\n\t}\n\n\tgetInvocationSubgroupIndex() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute' );\n\n\t}\n\n\tgetSubgroupIndex() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_id', 'subgroupIndex', 'u32', 'attribute' );\n\n\t}\n\n\tgetDrawIndex() {\n\n\t\treturn null;\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\treturn this.getBuiltin( 'front_facing', 'isFront', 'bool' );\n\n\t}\n\n\tgetFragCoord() {\n\n\t\treturn this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>' ) + '.xy';\n\n\t}\n\n\tgetFragDepth() {\n\n\t\treturn 'output.' + this.getBuiltin( 'frag_depth', 'depth', 'f32', 'output' );\n\n\t}\n\n\tgetClipDistance() {\n\n\t\treturn 'varyings.hw_clip_distances';\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\tenableDirective( name, shaderStage = this.shaderStage ) {\n\n\t\tconst stage = this.directives[ shaderStage ] || ( this.directives[ shaderStage ] = new Set() );\n\t\tstage.add( name );\n\n\t}\n\n\tgetDirectives( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst directives = this.directives[ shaderStage ];\n\n\t\tif ( directives !== undefined ) {\n\n\t\t\tfor ( const directive of directives ) {\n\n\t\t\t\tsnippets.push( `enable ${directive};` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\tenableSubGroups() {\n\n\t\tthis.enableDirective( 'subgroups' );\n\n\t}\n\n\tenableSubgroupsF16() {\n\n\t\tthis.enableDirective( 'subgroups-f16' );\n\n\t}\n\n\tenableClipDistances() {\n\n\t\tthis.enableDirective( 'clip_distances' );\n\n\t}\n\n\tenableShaderF16() {\n\n\t\tthis.enableDirective( 'f16' );\n\n\t}\n\n\tenableDualSourceBlending() {\n\n\t\tthis.enableDirective( 'dual_source_blending' );\n\n\t}\n\n\tenableHardwareClipping( planeCount ) {\n\n\t\tthis.enableClipDistances();\n\t\tthis.getBuiltin( 'clip_distances', 'hw_clip_distances', `array<f32, ${ planeCount } >`, 'vertex' );\n\n\t}\n\n\tgetBuiltins( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst builtins = this.builtins[ shaderStage ];\n\n\t\tif ( builtins !== undefined ) {\n\n\t\t\tfor ( const { name, property, type } of builtins.values() ) {\n\n\t\t\t\tsnippets.push( `@builtin( ${name} ) ${property} : ${type}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\tgetScopedArray( name, scope, bufferType, bufferCount ) {\n\n\t\tif ( this.scopedArrays.has( name ) === false ) {\n\n\t\t\tthis.scopedArrays.set( name, {\n\t\t\t\tname,\n\t\t\t\tscope,\n\t\t\t\tbufferType,\n\t\t\t\tbufferCount\n\t\t\t} );\n\n\t\t}\n\n\t\treturn name;\n\n\t}\n\n\tgetScopedArrays( shaderStage ) {\n\n\t\tif ( shaderStage !== 'compute' ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst snippets = [];\n\n\t\tfor ( const { name, scope, bufferType, bufferCount } of this.scopedArrays.values() ) {\n\n\t\t\tconst type = this.getType( bufferType );\n\n\t\t\tsnippets.push( `var<${scope}> ${name}: array< ${type}, ${bufferCount} >;` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\tgetAttributes( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tthis.getBuiltin( 'global_invocation_id', 'id', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'local_invocation_id', 'localId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute' );\n\n\t\t\tif ( this.renderer.hasFeature( 'subgroups' ) ) {\n\n\t\t\t\tthis.enableDirective( 'subgroups', shaderStage );\n\t\t\t\tthis.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tconst builtins = this.getBuiltins( 'attribute' );\n\n\t\t\tif ( builtins ) snippets.push( builtins );\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tfor ( let index = 0, length = attributes.length; index < length; index ++ ) {\n\n\t\t\t\tconst attribute = attributes[ index ];\n\t\t\t\tconst name = attribute.name;\n\t\t\t\tconst type = this.getType( attribute.type );\n\n\t\t\t\tsnippets.push( `@location( ${index} ) ${ name } : ${ type }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\t\tconst members = struct.getMemberTypes();\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\tconst member = members[ i ];\n\t\t\tsnippets.push( `\\t@location( ${i} ) m${i} : ${ member }<f32>` );\n\n\t\t}\n\n\t\tconst builtins = this.getBuiltins( 'output' );\n\n\t\tif ( builtins ) snippets.push( '\\t' + builtins );\n\n\t\treturn snippets.join( ',\\n' );\n\n\t}\n\n\tgetStructs( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tfor ( let index = 0, length = structs.length; index < length; index ++ ) {\n\n\t\t\tconst struct = structs[ index ];\n\t\t\tconst name = struct.name;\n\n\t\t\tlet snippet = `\\struct ${ name } {\\n`;\n\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\tsnippet += '\\n}';\n\n\n\t\t\tsnippets.push( snippet );\n\n\t\t\tsnippets.push( `\\nvar<private> output : ${ name };\\n\\n` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\n' );\n\n\t}\n\n\tgetVar( type, name ) {\n\n\t\treturn `var ${ name } : ${ this.getType( type ) }`;\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippets.push( `\\t${ this.getVar( variable.type, variable.name ) };` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `\\n${ snippets.join( '\\n' ) }\\n`;\n\n\t}\n\n\tgetVaryings( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tthis.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst vars = this.vars[ shaderStage ];\n\n\t\t\tfor ( let index = 0; index < varyings.length; index ++ ) {\n\n\t\t\t\tconst varying = varyings[ index ];\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tlet attributesSnippet = `@location( ${index} )`;\n\n\t\t\t\t\tif ( /^(int|uint|ivec|uvec)/.test( varying.type ) ) {\n\n\t\t\t\t\t\tattributesSnippet += ' @interpolate( flat )';\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsnippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );\n\n\t\t\t\t} else if ( shaderStage === 'vertex' && vars.includes( varying ) === false ) {\n\n\t\t\t\t\tvars.push( varying );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst builtins = this.getBuiltins( shaderStage );\n\n\t\tif ( builtins ) snippets.push( builtins );\n\n\t\tconst code = snippets.join( ',\\n\\t' );\n\n\t\treturn shaderStage === 'vertex' ? this._getWGSLStruct( 'VaryingsStruct', '\\t' + code ) : code;\n\n\t}\n\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst bufferSnippets = [];\n\t\tconst structSnippets = [];\n\t\tconst uniformGroups = {};\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tconst groupName = uniform.groupNode.name;\n\t\t\tconst uniformIndexes = this.bindingsIndexes[ groupName ];\n\n\t\t\tif ( uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tif ( shaderStage === 'fragment' && this.isUnfilterable( texture ) === false && uniform.node.isStorageTextureNode !== true ) {\n\n\t\t\t\t\tif ( this.isSampleCompare( texture ) ) {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler_comparison;` );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler;` );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlet textureType;\n\n\t\t\t\tlet multisampled = '';\n\n\t\t\t\tif ( texture.isMultisampleRenderTargetTexture === true ) {\n\n\t\t\t\t\tmultisampled = '_multisampled';\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.isCubeTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_cube<f32>';\n\n\t\t\t\t} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_2d_array<f32>';\n\n\t\t\t\t} else if ( texture.isDepthTexture === true ) {\n\n\t\t\t\t\ttextureType = `texture_depth${multisampled}_2d`;\n\n\t\t\t\t} else if ( texture.isVideoTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_external';\n\n\t\t\t\t} else if ( texture.isData3DTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_3d<f32>';\n\n\t\t\t\t} else if ( uniform.node.isStorageTextureNode === true ) {\n\n\t\t\t\t\tconst format = getFormat( texture );\n\t\t\t\t\tconst access = this.getStorageAccess( uniform.node, shaderStage );\n\n\t\t\t\t\ttextureType = `texture_storage_2d<${ format }, ${ access }>`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst componentPrefix = this.getComponentTypeFromTexture( texture ).charAt( 0 );\n\n\t\t\t\t\ttextureType = `texture${multisampled}_2d<${ componentPrefix }32>`;\n\n\t\t\t\t}\n\n\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name } : ${ textureType };` );\n\n\t\t\t} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.bufferType );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';\n\t\t\t\tconst bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`;\n\t\t\t\tconst bufferSnippet = `\\t${ uniform.name } : array< ${ bufferTypeSnippet }${ bufferCountSnippet } >\\n`;\n\t\t\t\tconst bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${ this.getStorageAccess( bufferNode, shaderStage ) }` : 'uniform';\n\n\t\t\t\tbufferSnippets.push( this._getWGSLStructBinding( 'NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, uniformIndexes.binding ++, uniformIndexes.group ) );\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getType( this.getVectorType( uniform.type ) );\n\t\t\t\tconst groupName = uniform.groupNode.name;\n\n\t\t\t\tconst group = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = {\n\t\t\t\t\tindex: uniformIndexes.binding ++,\n\t\t\t\t\tid: uniformIndexes.group,\n\t\t\t\t\tsnippets: []\n\t\t\t\t} );\n\n\t\t\t\tgroup.snippets.push( `\\t${ uniform.name } : ${ vectorType }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const name in uniformGroups ) {\n\n\t\t\tconst group = uniformGroups[ name ];\n\n\t\t\tstructSnippets.push( this._getWGSLStructBinding( name, group.snippets.join( ',\\n' ), 'uniform', group.index, group.id ) );\n\n\t\t}\n\n\t\tlet code = bindingSnippets.join( '\\n' );\n\t\tcode += bufferSnippets.join( '\\n' );\n\t\tcode += structSnippets.join( '\\n' );\n\n\t\treturn code;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tthis.sortBindingGroups();\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.directives = this.getDirectives( shaderStage );\n\t\t\tstageData.scopedArrays = this.getScopedArrays( shaderStage );\n\n\t\t\t//\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tconst outputNode = mainNode.outputNode;\n\t\t\tconst isOutputStruct = ( outputNode !== undefined && outputNode.isOutputStructNode === true );\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n\\t`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += `varyings.Vertex = ${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( isOutputStruct ) {\n\n\t\t\t\t\t\t\tstageData.returnType = outputNode.nodeType;\n\n\t\t\t\t\t\t\tflow += `return ${ flowSlotData.result };`;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tlet structSnippet = '\\t@location(0) color: vec4<f32>';\n\n\t\t\t\t\t\t\tconst builtins = this.getBuiltins( 'output' );\n\n\t\t\t\t\t\t\tif ( builtins ) structSnippet += ',\\n\\t' + builtins;\n\n\t\t\t\t\t\t\tstageData.returnType = 'OutputStruct';\n\t\t\t\t\t\t\tstageData.structs += this._getWGSLStruct( 'OutputStruct', structSnippet );\n\t\t\t\t\t\t\tstageData.structs += '\\nvar<private> output : OutputStruct;\\n\\n';\n\n\t\t\t\t\t\t\tflow += `output.color = ${ flowSlotData.result };\\n\\n\\treturn output;`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstageData.flow = flow;\n\n\n\t\t}\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getWGSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\tthis.computeShader = this._getWGSLComputeCode( shadersData.compute, ( this.object.workgroupSize || [ 64 ] ).join( ', ' ) );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method, output = null ) {\n\n\t\tlet wgslMethod;\n\n\t\tif ( output !== null ) {\n\n\t\t\twgslMethod = this._getWGSLMethod( method + '_' + output );\n\n\t\t}\n\n\t\tif ( wgslMethod === undefined ) {\n\n\t\t\twgslMethod = this._getWGSLMethod( method );\n\n\t\t}\n\n\t\treturn wgslMethod || method;\n\n\t}\n\n\tgetType( type ) {\n\n\t\treturn wgslTypeLib[ type ] || type;\n\n\t}\n\n\tisAvailable( name ) {\n\n\t\tlet result = supports[ name ];\n\n\t\tif ( result === undefined ) {\n\n\t\t\tif ( name === 'float32Filterable' ) {\n\n\t\t\t\tresult = this.renderer.hasFeature( 'float32-filterable' );\n\n\t\t\t} else if ( name === 'clipDistance' ) {\n\n\t\t\t\tresult = this.renderer.hasFeature( 'clip-distances' );\n\n\t\t\t}\n\n\t\t\tsupports[ name ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t_getWGSLMethod( method ) {\n\n\t\tif ( wgslPolyfill[ method ] !== undefined ) {\n\n\t\t\tthis._include( method );\n\n\t\t}\n\n\t\treturn wgslMethods[ method ];\n\n\t}\n\n\t_include( name ) {\n\n\t\tconst codeNode = wgslPolyfill[ name ];\n\t\tcodeNode.build( this );\n\n\t\tif ( this.currentFunctionNode !== null ) {\n\n\t\t\tthis.currentFunctionNode.includes.push( codeNode );\n\n\t\t}\n\n\t\treturn codeNode;\n\n\t}\n\n\t_getWGSLVertexCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n// directives\n${shaderData.directives}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( ${shaderData.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn varyings;\n\n}\n`;\n\n\t}\n\n\t_getWGSLFragmentCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n// global\n${ diagnostics }\n\n// uniforms\n${shaderData.uniforms}\n\n// structs\n${shaderData.structs}\n\n// codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t_getWGSLComputeCode( shaderData, workgroupSize ) {\n\n\t\treturn `${ this.getSignature() }\n// directives\n${shaderData.directives}\n\n// system\nvar<private> instanceIndex : u32;\n\n// locals\n${shaderData.scopedArrays}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@compute @workgroup_size( ${workgroupSize} )\nfn main( ${shaderData.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x + id.y * numWorkgroups.x * u32(${workgroupSize}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${workgroupSize});\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t_getWGSLStruct( name, vars ) {\n\n\t\treturn `\nstruct ${name} {\n${vars}\n};`;\n\n\t}\n\n\t_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {\n\n\t\tconst structName = name + 'Struct';\n\t\tconst structSnippet = this._getWGSLStruct( structName, vars );\n\n\t\treturn `${structSnippet}\n@binding( ${binding} ) @group( ${group} )\nvar<${access}> ${name} : ${structName};`;\n\n\t}\n\n}\n\nclass WebGPUUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t}\n\n\tgetCurrentDepthStencilFormat( renderContext ) {\n\n\t\tlet format;\n\n\t\tif ( renderContext.depthTexture !== null ) {\n\n\t\t\tformat = this.getTextureFormatGPU( renderContext.depthTexture );\n\n\t\t} else if ( renderContext.depth && renderContext.stencil ) {\n\n\t\t\tformat = GPUTextureFormat.Depth24PlusStencil8;\n\n\t\t} else if ( renderContext.depth ) {\n\n\t\t\tformat = GPUTextureFormat.Depth24Plus;\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\tgetTextureFormatGPU( texture ) {\n\n\t\treturn this.backend.get( texture ).format;\n\n\t}\n\n\tgetCurrentColorFormat( renderContext ) {\n\n\t\tlet format;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tformat = this.getTextureFormatGPU( renderContext.textures[ 0 ] );\n\n\t\t} else {\n\n\t\t\tformat = this.getPreferredCanvasFormat(); // default context format\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\tgetCurrentColorSpace( renderContext ) {\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\treturn renderContext.textures[ 0 ].colorSpace;\n\n\t\t}\n\n\t\treturn this.backend.renderer.outputColorSpace;\n\n\t}\n\n\tgetPrimitiveTopology( object, material ) {\n\n\t\tif ( object.isPoints ) return GPUPrimitiveTopology.PointList;\n\t\telse if ( object.isLineSegments || ( object.isMesh && material.wireframe === true ) ) return GPUPrimitiveTopology.LineList;\n\t\telse if ( object.isLine ) return GPUPrimitiveTopology.LineStrip;\n\t\telse if ( object.isMesh ) return GPUPrimitiveTopology.TriangleList;\n\n\t}\n\n\tgetSampleCount( sampleCount ) {\n\n\t\tlet count = 1;\n\n\t\tif ( sampleCount > 1 ) {\n\n\t\t\t// WebGPU only supports power-of-two sample counts and 2 is not a valid value\n\t\t\tcount = Math.pow( 2, Math.floor( Math.log2( sampleCount ) ) );\n\n\t\t\tif ( count === 2 ) {\n\n\t\t\t\tcount = 4;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tgetSampleCountRenderContext( renderContext ) {\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\treturn this.getSampleCount( renderContext.sampleCount );\n\n\t\t}\n\n\t\treturn this.getSampleCount( this.backend.renderer.samples );\n\n\t}\n\n\tgetPreferredCanvasFormat() {\n\n\t\t// TODO: Remove this check when Quest 34.5 is out\n\t\t// https://github.com/mrdoob/three.js/pull/29221/files#r1731833949\n\n\t\tif ( navigator.userAgent.includes( 'Quest' ) ) {\n\n\t\t\treturn GPUTextureFormat.BGRA8Unorm;\n\n\t\t} else {\n\n\t\t\treturn navigator.gpu.getPreferredCanvasFormat();\n\n\t\t}\n\n\t}\n\n}\n\nconst typedArraysToVertexFormatPrefix = new Map( [\n\t[ Int8Array, [ 'sint8', 'snorm8' ]],\n\t[ Uint8Array, [ 'uint8', 'unorm8' ]],\n\t[ Int16Array, [ 'sint16', 'snorm16' ]],\n\t[ Uint16Array, [ 'uint16', 'unorm16' ]],\n\t[ Int32Array, [ 'sint32', 'snorm32' ]],\n\t[ Uint32Array, [ 'uint32', 'unorm32' ]],\n\t[ Float32Array, [ 'float32', ]],\n] );\n\nconst typedAttributeToVertexFormatPrefix = new Map( [\n\t[ Float16BufferAttribute, [ 'float16', ]],\n] );\n\nconst typeArraysToVertexFormatPrefixForItemSize1 = new Map( [\n\t[ Int32Array, 'sint32' ],\n\t[ Int16Array, 'sint32' ], // patch for INT16\n\t[ Uint32Array, 'uint32' ],\n\t[ Uint16Array, 'uint32' ], // patch for UINT16\n\t[ Float32Array, 'float32' ]\n] );\n\nclass WebGPUAttributeUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t}\n\n\tcreateAttribute( attribute, usage ) {\n\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\tconst backend = this.backend;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\n\t\tlet buffer = bufferData.buffer;\n\n\t\tif ( buffer === undefined ) {\n\n\t\t\tconst device = backend.device;\n\n\t\t\tlet array = bufferAttribute.array;\n\n\t\t\t// patch for INT16 and UINT16\n\t\t\tif ( attribute.normalized === false && ( array.constructor === Int16Array || array.constructor === Uint16Array ) ) {\n\n\t\t\t\tconst tempArray = new Uint32Array( array.length );\n\t\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\t\ttempArray[ i ] = array[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tarray = tempArray;\n\n\t\t\t}\n\n\t\t\tbufferAttribute.array = array;\n\n\t\t\tif ( ( bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute ) && bufferAttribute.itemSize === 3 ) {\n\n\t\t\t\tarray = new array.constructor( bufferAttribute.count * 4 );\n\n\t\t\t\tfor ( let i = 0; i < bufferAttribute.count; i ++ ) {\n\n\t\t\t\t\tarray.set( bufferAttribute.array.subarray( i * 3, i * 3 + 3 ), i * 4 );\n\n\t\t\t\t}\n\n\t\t\t\t// Update BufferAttribute\n\t\t\t\tbufferAttribute.itemSize = 4;\n\t\t\t\tbufferAttribute.array = array;\n\n\t\t\t}\n\n\t\t\tconst size = array.byteLength + ( ( 4 - ( array.byteLength % 4 ) ) % 4 ); // ensure 4 byte alignment, see #20441\n\n\t\t\tbuffer = device.createBuffer( {\n\t\t\t\tlabel: bufferAttribute.name,\n\t\t\t\tsize: size,\n\t\t\t\tusage: usage,\n\t\t\t\tmappedAtCreation: true\n\t\t\t} );\n\n\t\t\tnew array.constructor( buffer.getMappedRange() ).set( array );\n\n\t\t\tbuffer.unmap();\n\n\t\t\tbufferData.buffer = buffer;\n\n\t\t}\n\n\t}\n\n\tupdateAttribute( attribute ) {\n\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst buffer = backend.get( bufferAttribute ).buffer;\n\n\t\tconst array = bufferAttribute.array;\n\t\tconst isTypedArray = this._isTypedArray( array );\n\t\tconst updateRanges = bufferAttribute.updateRanges;\n\n\t\tif ( updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tdevice.queue.writeBuffer(\n\t\t\t\tbuffer,\n\t\t\t\t0,\n\t\t\t\tarray,\n\t\t\t\t0\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tconst byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\n\t\t\t\tconst dataOffset = range.start * byteOffsetFactor;\n\t\t\t\tconst size = range.count * byteOffsetFactor;\n\n\t\t\t\tdevice.queue.writeBuffer(\n\t\t\t\t\tbuffer,\n\t\t\t\t\t0,\n\t\t\t\t\tarray,\n\t\t\t\t\tdataOffset,\n\t\t\t\t\tsize\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tbufferAttribute.clearUpdateRanges();\n\n\t\t}\n\n\t}\n\n\tcreateShaderVertexBuffers( renderObject ) {\n\n\t\tconst attributes = renderObject.getAttributes();\n\t\tconst vertexBuffers = new Map();\n\n\t\tfor ( let slot = 0; slot < attributes.length; slot ++ ) {\n\n\t\t\tconst geometryAttribute = attributes[ slot ];\n\t\t\tconst bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;\n\t\t\tconst bufferAttribute = this._getBufferAttribute( geometryAttribute );\n\n\t\t\tlet vertexBufferLayout = vertexBuffers.get( bufferAttribute );\n\n\t\t\tif ( vertexBufferLayout === undefined ) {\n\n\t\t\t\tlet arrayStride, stepMode;\n\n\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute === true ) {\n\n\t\t\t\t\tarrayStride = geometryAttribute.data.stride * bytesPerElement;\n\t\t\t\t\tstepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarrayStride = geometryAttribute.itemSize * bytesPerElement;\n\t\t\t\t\tstepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n\n\t\t\t\t}\n\n\t\t\t\t// patch for INT16 and UINT16\n\t\t\t\tif ( geometryAttribute.normalized === false && ( geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array ) ) {\n\n\t\t\t\t\tarrayStride = 4;\n\n\t\t\t\t}\n\n\t\t\t\tvertexBufferLayout = {\n\t\t\t\t\tarrayStride,\n\t\t\t\t\tattributes: [],\n\t\t\t\t\tstepMode\n\t\t\t\t};\n\n\t\t\t\tvertexBuffers.set( bufferAttribute, vertexBufferLayout );\n\n\t\t\t}\n\n\t\t\tconst format = this._getVertexFormat( geometryAttribute );\n\t\t\tconst offset = ( geometryAttribute.isInterleavedBufferAttribute === true ) ? geometryAttribute.offset * bytesPerElement : 0;\n\n\t\t\tvertexBufferLayout.attributes.push( {\n\t\t\t\tshaderLocation: slot,\n\t\t\t\toffset,\n\t\t\t\tformat\n\t\t\t} );\n\n\t\t}\n\n\t\treturn Array.from( vertexBuffers.values() );\n\n\t}\n\n\tdestroyAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst data = backend.get( this._getBufferAttribute( attribute ) );\n\n\t\tdata.buffer.destroy();\n\n\t\tbackend.delete( attribute );\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst data = backend.get( this._getBufferAttribute( attribute ) );\n\n\t\tconst bufferGPU = data.buffer;\n\t\tconst size = bufferGPU.size;\n\n\t\tconst readBufferGPU = device.createBuffer( {\n\t\t\tlabel: attribute.name,\n\t\t\tsize,\n\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t} );\n\n\n\t\tconst cmdEncoder = device.createCommandEncoder( {} );\n\n\t\tcmdEncoder.copyBufferToBuffer(\n\t\t\tbufferGPU,\n\t\t\t0,\n\t\t\treadBufferGPU,\n\t\t\t0,\n\t\t\tsize\n\t\t);\n\n\t\treadBufferGPU.unmap();\n\n\t\tconst gpuCommands = cmdEncoder.finish();\n\t\tdevice.queue.submit( [ gpuCommands ] );\n\n\t\tawait readBufferGPU.mapAsync( GPUMapMode.READ );\n\n\t\tconst arrayBuffer = readBufferGPU.getMappedRange();\n\n\t\treturn arrayBuffer;\n\n\t}\n\n\t_getVertexFormat( geometryAttribute ) {\n\n\t\tconst { itemSize, normalized } = geometryAttribute;\n\t\tconst ArrayType = geometryAttribute.array.constructor;\n\t\tconst AttributeType = geometryAttribute.constructor;\n\n\t\tlet format;\n\n\t\tif ( itemSize == 1 ) {\n\n\t\t\tformat = typeArraysToVertexFormatPrefixForItemSize1.get( ArrayType );\n\n\t\t} else {\n\n\t\t\tconst prefixOptions = typedAttributeToVertexFormatPrefix.get( AttributeType ) || typedArraysToVertexFormatPrefix.get( ArrayType );\n\t\t\tconst prefix = prefixOptions[ normalized ? 1 : 0 ];\n\n\t\t\tif ( prefix ) {\n\n\t\t\t\tconst bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;\n\t\t\t\tconst paddedBytesPerUnit = Math.floor( ( bytesPerUnit + 3 ) / 4 ) * 4;\n\t\t\t\tconst paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;\n\n\t\t\t\tif ( paddedItemSize % 1 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.WebGPUAttributeUtils: Bad vertex format item size.' );\n\n\t\t\t\t}\n\n\t\t\t\tformat = `${prefix}x${paddedItemSize}`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! format ) {\n\n\t\t\tconsole.error( 'THREE.WebGPUAttributeUtils: Vertex format not supported yet.' );\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\t_isTypedArray( array ) {\n\n\t\treturn ArrayBuffer.isView( array ) && ! ( array instanceof DataView );\n\n\t}\n\n\t_getBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn attribute;\n\n\t}\n\n}\n\nclass WebGPUBindingUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\t\tthis.bindGroupLayoutCache = new WeakMap();\n\n\t}\n\n\tcreateBindingsLayout( bindGroup ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst entries = [];\n\n\t\tlet index = 0;\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tconst bindingGPU = {\n\t\t\t\tbinding: index ++,\n\t\t\t\tvisibility: binding.visibility\n\t\t\t};\n\n\t\t\tif ( binding.isUniformBuffer || binding.isStorageBuffer ) {\n\n\t\t\t\tconst buffer = {}; // GPUBufferBindingLayout\n\n\t\t\t\tif ( binding.isStorageBuffer ) {\n\n\t\t\t\t\tif ( binding.visibility & 4 ) {\n\n\t\t\t\t\t\t// compute\n\n\t\t\t\t\t\tif ( binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY ) {\n\n\t\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.Storage;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.ReadOnlyStorage;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.ReadOnlyStorage;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.buffer = buffer;\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst sampler = {}; // GPUSamplerBindingLayout\n\n\t\t\t\tif ( binding.texture.isDepthTexture ) {\n\n\t\t\t\t\tif ( binding.texture.compareFunction !== null ) {\n\n\t\t\t\t\t\tsampler.type = 'comparison';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.sampler = sampler;\n\n\t\t\t} else if ( binding.isSampledTexture && binding.texture.isVideoTexture ) {\n\n\t\t\t\tbindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout\n\n\t\t\t} else if ( binding.isSampledTexture && binding.store ) {\n\n\t\t\t\tconst storageTexture = {}; // GPUStorageTextureBindingLayout\n\t\t\t\tstorageTexture.format = this.backend.get( binding.texture ).texture.format;\n\n\t\t\t\tconst access = binding.access;\n\n\t\t\t\tif ( access === NodeAccess.READ_WRITE ) {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.ReadWrite;\n\n\t\t\t\t} else if ( access === NodeAccess.WRITE_ONLY ) {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.WriteOnly;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.ReadOnly;\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.storageTexture = storageTexture;\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst texture = {}; // GPUTextureBindingLayout\n\n\t\t\t\tif ( binding.texture.isMultisampleRenderTargetTexture === true ) {\n\n\t\t\t\t\ttexture.multisampled = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.texture.isDepthTexture ) {\n\n\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.Depth;\n\n\t\t\t\t} else if ( binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture ) {\n\n\t\t\t\t\tconst type = binding.texture.type;\n\n\t\t\t\t\tif ( type === IntType ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.SInt;\n\n\t\t\t\t\t} else if ( type === UnsignedIntType ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UInt;\n\n\t\t\t\t\t} else if ( type === FloatType ) {\n\n\t\t\t\t\t\tif ( this.backend.hasFeature( 'float32-filterable' ) ) {\n\n\t\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.Float;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.isSampledCubeTexture ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.Cube;\n\n\t\t\t\t} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.TwoDArray;\n\n\t\t\t\t} else if ( binding.isSampledTexture3D ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.ThreeD;\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.texture = texture;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( `WebGPUBindingUtils: Unsupported binding \"${ binding }\".` );\n\n\t\t\t}\n\n\t\t\tentries.push( bindingGPU );\n\n\t\t}\n\n\t\treturn device.createBindGroupLayout( { entries } );\n\n\t}\n\n\tcreateBindings( bindGroup, bindings, cacheIndex, version = 0 ) {\n\n\t\tconst { backend, bindGroupLayoutCache } = this;\n\t\tconst bindingsData = backend.get( bindGroup );\n\n\t\t// setup (static) binding layout and (dynamic) binding group\n\n\t\tlet bindLayoutGPU = bindGroupLayoutCache.get( bindGroup.bindingsReference );\n\n\t\tif ( bindLayoutGPU === undefined ) {\n\n\t\t\tbindLayoutGPU = this.createBindingsLayout( bindGroup );\n\t\t\tbindGroupLayoutCache.set( bindGroup.bindingsReference, bindLayoutGPU );\n\n\t\t}\n\n\t\tlet bindGroupGPU;\n\n\t\tif ( cacheIndex > 0 ) {\n\n\t\t\tif ( bindingsData.groups === undefined ) {\n\n\t\t\t\tbindingsData.groups = [];\n\t\t\t\tbindingsData.versions = [];\n\n\t\t\t}\n\n\t\t\tif ( bindingsData.versions[ cacheIndex ] === version ) {\n\n\t\t\t\tbindGroupGPU = bindingsData.groups[ cacheIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( bindGroupGPU === undefined ) {\n\n\t\t\tbindGroupGPU = this.createBindGroup( bindGroup, bindLayoutGPU );\n\n\t\t\tif ( cacheIndex > 0 ) {\n\n\t\t\t\tbindingsData.groups[ cacheIndex ] = bindGroupGPU;\n\t\t\t\tbindingsData.versions[ cacheIndex ] = version;\n\n\t\t\t}\n\n\t\t}\n\n\t\tbindingsData.group = bindGroupGPU;\n\t\tbindingsData.layout = bindLayoutGPU;\n\n\t}\n\n\tupdateBinding( binding ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst buffer = binding.buffer;\n\t\tconst bufferGPU = backend.get( binding ).buffer;\n\n\t\tdevice.queue.writeBuffer( bufferGPU, 0, buffer, 0 );\n\n\t}\n\n\tcreateBindGroup( bindGroup, layoutGPU ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tlet bindingPoint = 0;\n\t\tconst entriesGPU = [];\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isUniformBuffer ) {\n\n\t\t\t\tconst bindingData = backend.get( binding );\n\n\t\t\t\tif ( bindingData.buffer === undefined ) {\n\n\t\t\t\t\tconst byteLength = binding.byteLength;\n\n\t\t\t\t\tconst usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n\n\t\t\t\t\tconst bufferGPU = device.createBuffer( {\n\t\t\t\t\t\tlabel: 'bindingBuffer_' + binding.name,\n\t\t\t\t\t\tsize: byteLength,\n\t\t\t\t\t\tusage: usage\n\t\t\t\t\t} );\n\n\t\t\t\t\tbindingData.buffer = bufferGPU;\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\n\n\t\t\t} else if ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst bindingData = backend.get( binding );\n\n\t\t\t\tif ( bindingData.buffer === undefined ) {\n\n\t\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\t\t//const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;\n\n\t\t\t\t\t//backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer\n\n\t\t\t\t\tbindingData.buffer = backend.get( attribute ).buffer;\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst textureGPU = backend.get( binding.texture );\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: textureGPU.sampler } );\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst textureData = backend.get( binding.texture );\n\n\t\t\t\tlet resourceGPU;\n\n\t\t\t\tif ( textureData.externalTexture !== undefined ) {\n\n\t\t\t\t\tresourceGPU = device.importExternalTexture( { source: textureData.externalTexture } );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;\n\t\t\t\t\tconst propertyName = `view-${ textureData.texture.width }-${ textureData.texture.height }-${ mipLevelCount }`;\n\n\t\t\t\t\tresourceGPU = textureData[ propertyName ];\n\n\t\t\t\t\tif ( resourceGPU === undefined ) {\n\n\t\t\t\t\t\tconst aspectGPU = GPUTextureAspect.All;\n\n\t\t\t\t\t\tlet dimensionViewGPU;\n\n\t\t\t\t\t\tif ( binding.isSampledCubeTexture ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.Cube;\n\n\t\t\t\t\t\t} else if ( binding.isSampledTexture3D ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.ThreeD;\n\n\t\t\t\t\t\t} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.TwoDArray;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.TwoD;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresourceGPU = textureData[ propertyName ] = textureData.texture.createView( { aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount } );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: resourceGPU } );\n\n\t\t\t}\n\n\t\t\tbindingPoint ++;\n\n\t\t}\n\n\t\treturn device.createBindGroup( {\n\t\t\tlabel: 'bindGroup_' + bindGroup.name,\n\t\t\tlayout: layoutGPU,\n\t\t\tentries: entriesGPU\n\t\t} );\n\n\t}\n\n}\n\nclass WebGPUPipelineUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t}\n\n\t_getSampleCount( renderObjectContext ) {\n\n\t\treturn this.backend.utils.getSampleCountRenderContext( renderObjectContext );\n\n\t}\n\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tconst { object, material, geometry, pipeline } = renderObject;\n\t\tconst { vertexProgram, fragmentProgram } = pipeline;\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\t\tconst utils = backend.utils;\n\n\t\tconst pipelineData = backend.get( pipeline );\n\n\t\t// bind group layouts\n\n\t\tconst bindGroupLayouts = [];\n\n\t\tfor ( const bindGroup of renderObject.getBindings() ) {\n\n\t\t\tconst bindingsData = backend.get( bindGroup );\n\n\t\t\tbindGroupLayouts.push( bindingsData.layout );\n\n\t\t}\n\n\t\t// vertex buffers\n\n\t\tconst vertexBuffers = backend.attributeUtils.createShaderVertexBuffers( renderObject );\n\n\t\t// blending\n\n\t\tlet blending;\n\n\t\tif ( material.transparent === true && material.blending !== NoBlending ) {\n\n\t\t\tblending = this._getBlending( material );\n\n\t\t}\n\n\t\t// stencil\n\n\t\tlet stencilFront = {};\n\n\t\tif ( material.stencilWrite === true ) {\n\n\t\t\tstencilFront = {\n\t\t\t\tcompare: this._getStencilCompare( material ),\n\t\t\t\tfailOp: this._getStencilOperation( material.stencilFail ),\n\t\t\t\tdepthFailOp: this._getStencilOperation( material.stencilZFail ),\n\t\t\t\tpassOp: this._getStencilOperation( material.stencilZPass )\n\t\t\t};\n\n\t\t}\n\n\t\tconst colorWriteMask = this._getColorWriteMask( material );\n\n\t\tconst targets = [];\n\n\t\tif ( renderObject.context.textures !== null ) {\n\n\t\t\tconst textures = renderObject.context.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst colorFormat = utils.getTextureFormatGPU( textures[ i ] );\n\n\t\t\t\ttargets.push( {\n\t\t\t\t\tformat: colorFormat,\n\t\t\t\t\tblend: blending,\n\t\t\t\t\twriteMask: colorWriteMask\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst colorFormat = utils.getCurrentColorFormat( renderObject.context );\n\n\t\t\ttargets.push( {\n\t\t\t\tformat: colorFormat,\n\t\t\t\tblend: blending,\n\t\t\t\twriteMask: colorWriteMask\n\t\t\t} );\n\n\t\t}\n\n\t\tconst vertexModule = backend.get( vertexProgram ).module;\n\t\tconst fragmentModule = backend.get( fragmentProgram ).module;\n\n\t\tconst primitiveState = this._getPrimitiveState( object, geometry, material );\n\t\tconst depthCompare = this._getDepthCompare( material );\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );\n\n\t\tconst sampleCount = this._getSampleCount( renderObject.context );\n\n\t\tconst pipelineDescriptor = {\n\t\t\tlabel: `renderPipeline_${ material.name || material.type }_${ material.id }`,\n\t\t\tvertex: Object.assign( {}, vertexModule, { buffers: vertexBuffers } ),\n\t\t\tfragment: Object.assign( {}, fragmentModule, { targets } ),\n\t\t\tprimitive: primitiveState,\n\t\t\tmultisample: {\n\t\t\t\tcount: sampleCount,\n\t\t\t\talphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1\n\t\t\t},\n\t\t\tlayout: device.createPipelineLayout( {\n\t\t\t\tbindGroupLayouts\n\t\t\t} )\n\t\t};\n\n\n\t\tconst depthStencil = {};\n\t\tconst renderDepth = renderObject.context.depth;\n\t\tconst renderStencil = renderObject.context.stencil;\n\n\t\tif ( renderDepth === true || renderStencil === true ) {\n\n\t\t\tif ( renderDepth === true ) {\n\n\t\t\t\tdepthStencil.format = depthStencilFormat;\n\t\t\t\tdepthStencil.depthWriteEnabled = material.depthWrite;\n\t\t\t\tdepthStencil.depthCompare = depthCompare;\n\n\t\t\t}\n\n\t\t\tif ( renderStencil === true ) {\n\n\t\t\t\tdepthStencil.stencilFront = stencilFront;\n\t\t\t\tdepthStencil.stencilBack = {}; // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)\n\t\t\t\tdepthStencil.stencilReadMask = material.stencilFuncMask;\n\t\t\t\tdepthStencil.stencilWriteMask = material.stencilWriteMask;\n\n\t\t\t}\n\n\t\t\tpipelineDescriptor.depthStencil = depthStencil;\n\n\t\t}\n\n\n\t\tif ( promises === null ) {\n\n\t\t\tpipelineData.pipeline = device.createRenderPipeline( pipelineDescriptor );\n\n\t\t} else {\n\n\t\t\tconst p = new Promise( ( resolve /*, reject*/ ) => {\n\n\t\t\t\tdevice.createRenderPipelineAsync( pipelineDescriptor ).then( pipeline => {\n\n\t\t\t\t\tpipelineData.pipeline = pipeline;\n\t\t\t\t\tresolve();\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t\tpromises.push( p );\n\n\t\t}\n\n\t}\n\n\tcreateBundleEncoder( renderContext ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { utils, device } = backend;\n\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderContext );\n\t\tconst colorFormat = utils.getCurrentColorFormat( renderContext );\n\t\tconst sampleCount = this._getSampleCount( renderContext );\n\n\t\tconst descriptor = {\n\t\t\tlabel: 'renderBundleEncoder',\n\t\t\tcolorFormats: [ colorFormat ],\n\t\t\tdepthStencilFormat,\n\t\t\tsampleCount\n\t\t};\n\n\t\treturn device.createRenderBundleEncoder( descriptor );\n\n\t}\n\n\tcreateComputePipeline( pipeline, bindings ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst computeProgram = backend.get( pipeline.computeProgram ).module;\n\n\t\tconst pipelineGPU = backend.get( pipeline );\n\n\t\t// bind group layouts\n\n\t\tconst bindGroupLayouts = [];\n\n\t\tfor ( const bindingsGroup of bindings ) {\n\n\t\t\tconst bindingsData = backend.get( bindingsGroup );\n\n\t\t\tbindGroupLayouts.push( bindingsData.layout );\n\n\t\t}\n\n\t\tpipelineGPU.pipeline = device.createComputePipeline( {\n\t\t\tcompute: computeProgram,\n\t\t\tlayout: device.createPipelineLayout( {\n\t\t\t\tbindGroupLayouts\n\t\t\t} )\n\t\t} );\n\n\t}\n\n\t_getBlending( material ) {\n\n\t\tlet color, alpha;\n\n\t\tconst blending = material.blending;\n\t\tconst blendSrc = material.blendSrc;\n\t\tconst blendDst = material.blendDst;\n\t\tconst blendEquation = material.blendEquation;\n\n\n\t\tif ( blending === CustomBlending ) {\n\n\t\t\tconst blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;\n\t\t\tconst blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;\n\t\t\tconst blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;\n\n\t\t\tcolor = {\n\t\t\t\tsrcFactor: this._getBlendFactor( blendSrc ),\n\t\t\t\tdstFactor: this._getBlendFactor( blendDst ),\n\t\t\t\toperation: this._getBlendOperation( blendEquation )\n\t\t\t};\n\n\t\t\talpha = {\n\t\t\t\tsrcFactor: this._getBlendFactor( blendSrcAlpha ),\n\t\t\t\tdstFactor: this._getBlendFactor( blendDstAlpha ),\n\t\t\t\toperation: this._getBlendOperation( blendEquationAlpha )\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconst premultipliedAlpha = material.premultipliedAlpha;\n\n\t\t\tconst setBlend = ( srcRGB, dstRGB, srcAlpha, dstAlpha ) => {\n\n\t\t\t\tcolor = {\n\t\t\t\t\tsrcFactor: srcRGB,\n\t\t\t\t\tdstFactor: dstRGB,\n\t\t\t\t\toperation: GPUBlendOperation.Add\n\t\t\t\t};\n\n\t\t\t\talpha = {\n\t\t\t\t\tsrcFactor: srcAlpha,\n\t\t\t\t\tdstFactor: dstAlpha,\n\t\t\t\t\toperation: GPUBlendOperation.Add\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( color !== undefined && alpha !== undefined ) {\n\n\t\t\treturn { color, alpha };\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.WebGPURenderer: Invalid blending: ', blending );\n\n\t\t}\n\n\t}\n\n\t_getBlendFactor( blend ) {\n\n\t\tlet blendFactor;\n\n\t\tswitch ( blend ) {\n\n\t\t\tcase ZeroFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Zero;\n\t\t\t\tbreak;\n\n\t\t\tcase OneFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.One;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Src;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusSrcColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusSrc;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.SrcAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusSrcAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusSrcAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase DstColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Dst;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusDstColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusDstColor;\n\t\t\t\tbreak;\n\n\t\t\tcase DstAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.DstAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusDstAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusDstAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcAlphaSaturateFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.SrcAlphaSaturated;\n\t\t\t\tbreak;\n\n\t\t\tcase BlendColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Constant;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusBlendColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusConstant;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPURenderer: Blend factor not supported.', blend );\n\n\t\t}\n\n\t\treturn blendFactor;\n\n\t}\n\n\t_getStencilCompare( material ) {\n\n\t\tlet stencilCompare;\n\n\t\tconst stencilFunc = material.stencilFunc;\n\n\t\tswitch ( stencilFunc ) {\n\n\t\t\tcase NeverStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Never;\n\t\t\t\tbreak;\n\n\t\t\tcase AlwaysStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Always;\n\t\t\t\tbreak;\n\n\t\t\tcase LessStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Less;\n\t\t\t\tbreak;\n\n\t\t\tcase LessEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.LessEqual;\n\t\t\t\tbreak;\n\n\t\t\tcase EqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Equal;\n\t\t\t\tbreak;\n\n\t\t\tcase GreaterEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.GreaterEqual;\n\t\t\t\tbreak;\n\n\t\t\tcase GreaterStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Greater;\n\t\t\t\tbreak;\n\n\t\t\tcase NotEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.NotEqual;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPURenderer: Invalid stencil function.', stencilFunc );\n\n\t\t}\n\n\t\treturn stencilCompare;\n\n\t}\n\n\t_getStencilOperation( op ) {\n\n\t\tlet stencilOperation;\n\n\t\tswitch ( op ) {\n\n\t\t\tcase KeepStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Keep;\n\t\t\t\tbreak;\n\n\t\t\tcase ZeroStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Zero;\n\t\t\t\tbreak;\n\n\t\t\tcase ReplaceStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Replace;\n\t\t\t\tbreak;\n\n\t\t\tcase InvertStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Invert;\n\t\t\t\tbreak;\n\n\t\t\tcase IncrementStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.IncrementClamp;\n\t\t\t\tbreak;\n\n\t\t\tcase DecrementStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.DecrementClamp;\n\t\t\t\tbreak;\n\n\t\t\tcase IncrementWrapStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.IncrementWrap;\n\t\t\t\tbreak;\n\n\t\t\tcase DecrementWrapStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.DecrementWrap;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPURenderer: Invalid stencil operation.', stencilOperation );\n\n\t\t}\n\n\t\treturn stencilOperation;\n\n\t}\n\n\t_getBlendOperation( blendEquation ) {\n\n\t\tlet blendOperation;\n\n\t\tswitch ( blendEquation ) {\n\n\t\t\tcase AddEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Add;\n\t\t\t\tbreak;\n\n\t\t\tcase SubtractEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Subtract;\n\t\t\t\tbreak;\n\n\t\t\tcase ReverseSubtractEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.ReverseSubtract;\n\t\t\t\tbreak;\n\n\t\t\tcase MinEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Min;\n\t\t\t\tbreak;\n\n\t\t\tcase MaxEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Max;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPUPipelineUtils: Blend equation not supported.', blendEquation );\n\n\t\t}\n\n\t\treturn blendOperation;\n\n\t}\n\n\t_getPrimitiveState( object, geometry, material ) {\n\n\t\tconst descriptor = {};\n\t\tconst utils = this.backend.utils;\n\n\t\tdescriptor.topology = utils.getPrimitiveTopology( object, material );\n\n\t\tif ( geometry.index !== null && object.isLine === true && object.isLineSegments !== true ) {\n\n\t\t\tdescriptor.stripIndexFormat = ( geometry.index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n\n\t\t}\n\n\t\tswitch ( material.side ) {\n\n\t\t\tcase FrontSide:\n\t\t\t\tdescriptor.frontFace = GPUFrontFace.CCW;\n\t\t\t\tdescriptor.cullMode = GPUCullMode.Back;\n\t\t\t\tbreak;\n\n\t\t\tcase BackSide:\n\t\t\t\tdescriptor.frontFace = GPUFrontFace.CCW;\n\t\t\t\tdescriptor.cullMode = GPUCullMode.Front;\n\t\t\t\tbreak;\n\n\t\t\tcase DoubleSide:\n\t\t\t\tdescriptor.frontFace = GPUFrontFace.CCW;\n\t\t\t\tdescriptor.cullMode = GPUCullMode.None;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPUPipelineUtils: Unknown material.side value.', material.side );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\t_getColorWriteMask( material ) {\n\n\t\treturn ( material.colorWrite === true ) ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;\n\n\t}\n\n\t_getDepthCompare( material ) {\n\n\t\tlet depthCompare;\n\n\t\tif ( material.depthTest === false ) {\n\n\t\t\tdepthCompare = GPUCompareFunction.Always;\n\n\t\t} else {\n\n\t\t\tconst depthFunc = material.depthFunc;\n\n\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\tcase NeverDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Never;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AlwaysDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Always;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Less;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.LessEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Equal;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.GreaterEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Greater;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NotEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.NotEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error( 'THREE.WebGPUPipelineUtils: Invalid depth function.', depthFunc );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn depthCompare;\n\n\t}\n\n}\n\n/*// debugger tools\nimport 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';\n//*/\n\n\n//\n\nclass WebGPUBackend extends Backend {\n\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters );\n\n\t\tthis.isWebGPUBackend = true;\n\n\t\t// some parameters require default values other than \"undefined\"\n\t\tthis.parameters.alpha = ( parameters.alpha === undefined ) ? true : parameters.alpha;\n\n\t\tthis.parameters.requiredLimits = ( parameters.requiredLimits === undefined ) ? {} : parameters.requiredLimits;\n\n\t\tthis.trackTimestamp = ( parameters.trackTimestamp === true );\n\n\t\tthis.device = null;\n\t\tthis.context = null;\n\t\tthis.colorBuffer = null;\n\t\tthis.defaultRenderPassdescriptor = null;\n\n\t\tthis.utils = new WebGPUUtils( this );\n\t\tthis.attributeUtils = new WebGPUAttributeUtils( this );\n\t\tthis.bindingUtils = new WebGPUBindingUtils( this );\n\t\tthis.pipelineUtils = new WebGPUPipelineUtils( this );\n\t\tthis.textureUtils = new WebGPUTextureUtils( this );\n\t\tthis.occludedResolveCache = new Map();\n\n\t}\n\n\tasync init( renderer ) {\n\n\t\tawait super.init( renderer );\n\n\t\t//\n\n\t\tconst parameters = this.parameters;\n\n\t\t// create the device if it is not passed with parameters\n\n\t\tlet device;\n\n\t\tif ( parameters.device === undefined ) {\n\n\t\t\tconst adapterOptions = {\n\t\t\t\tpowerPreference: parameters.powerPreference\n\t\t\t};\n\n\t\t\tconst adapter = ( typeof navigator !== 'undefined' ) ? await navigator.gpu.requestAdapter( adapterOptions ) : null;\n\n\t\t\tif ( adapter === null ) {\n\n\t\t\t\tthrow new Error( 'WebGPUBackend: Unable to create WebGPU adapter.' );\n\n\t\t\t}\n\n\t\t\t// feature support\n\n\t\t\tconst features = Object.values( GPUFeatureName );\n\n\t\t\tconst supportedFeatures = [];\n\n\t\t\tfor ( const name of features ) {\n\n\t\t\t\tif ( adapter.features.has( name ) ) {\n\n\t\t\t\t\tsupportedFeatures.push( name );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst deviceDescriptor = {\n\t\t\t\trequiredFeatures: supportedFeatures,\n\t\t\t\trequiredLimits: parameters.requiredLimits\n\t\t\t};\n\n\t\t\tdevice = await adapter.requestDevice( deviceDescriptor );\n\n\t\t} else {\n\n\t\t\tdevice = parameters.device;\n\n\t\t}\n\n\t\tdevice.lost.then( ( info ) => {\n\n\t\t\tconst deviceLossInfo = {\n\t\t\t\tapi: 'WebGPU',\n\t\t\t\tmessage: info.message || 'Unknown reason',\n\t\t\t\treason: info.reason || null,\n\t\t\t\toriginalEvent: info\n\t\t\t};\n\n\t\t\trenderer.onDeviceLost( deviceLossInfo );\n\n\t\t} );\n\n\t\tconst context = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgpu' );\n\n\t\tthis.device = device;\n\t\tthis.context = context;\n\n\t\tconst alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';\n\n\t\tthis.trackTimestamp = this.trackTimestamp && this.hasFeature( GPUFeatureName.TimestampQuery );\n\n\t\tthis.context.configure( {\n\t\t\tdevice: this.device,\n\t\t\tformat: this.utils.getPreferredCanvasFormat(),\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n\t\t\talphaMode: alphaMode\n\t\t} );\n\n\t\tthis.updateSize();\n\n\t}\n\n\tget coordinateSystem() {\n\n\t\treturn WebGPUCoordinateSystem;\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.attributeUtils.getArrayBufferAsync( attribute );\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\t_getDefaultRenderPassDescriptor() {\n\n\t\tlet descriptor = this.defaultRenderPassdescriptor;\n\n\t\tif ( descriptor === null ) {\n\n\t\t\tconst renderer = this.renderer;\n\n\t\t\tdescriptor = {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: null\n\t\t\t\t} ],\n\t\t\t};\n\n\t\t\tif ( this.renderer.depth === true || this.renderer.stencil === true ) {\n\n\t\t\t\tdescriptor.depthStencilAttachment = {\n\t\t\t\t\tview: this.textureUtils.getDepthBuffer( renderer.depth, renderer.stencil ).createView()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\t\tif ( this.renderer.samples > 0 ) {\n\n\t\t\t\tcolorAttachment.view = this.colorBuffer.createView();\n\n\t\t\t} else {\n\n\t\t\t\tcolorAttachment.resolveTarget = undefined;\n\n\t\t\t}\n\n\t\t\tthis.defaultRenderPassdescriptor = descriptor;\n\n\t\t}\n\n\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\tif ( this.renderer.samples > 0 ) {\n\n\t\t\tcolorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n\n\t\t} else {\n\n\t\t\tcolorAttachment.view = this.context.getCurrentTexture().createView();\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\t_getRenderPassDescriptor( renderContext ) {\n\n\t\tconst renderTarget = renderContext.renderTarget;\n\t\tconst renderTargetData = this.get( renderTarget );\n\n\t\tlet descriptors = renderTargetData.descriptors;\n\n\t\tif ( descriptors === undefined ||\n\t\t\trenderTargetData.width !== renderTarget.width ||\n\t\t\trenderTargetData.height !== renderTarget.height ||\n\t\t\trenderTargetData.activeMipmapLevel !== renderTarget.activeMipmapLevel ||\n\t\t\trenderTargetData.samples !== renderTarget.samples\n\t\t) {\n\n\t\t\tdescriptors = {};\n\n\t\t\trenderTargetData.descriptors = descriptors;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\trenderTarget.removeEventListener( 'dispose', onDispose );\n\n\t\t\t\tthis.delete( renderTarget );\n\n\t\t\t};\n\n\t\t\trenderTarget.addEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t\tconst cacheKey = renderContext.getCacheKey();\n\n\t\tlet descriptor = descriptors[ cacheKey ];\n\n\t\tif ( descriptor === undefined ) {\n\n\t\t\tconst textures = renderContext.textures;\n\t\t\tconst colorAttachments = [];\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst textureData = this.get( textures[ i ] );\n\n\t\t\t\tconst textureView = textureData.texture.createView( {\n\t\t\t\t\tbaseMipLevel: renderContext.activeMipmapLevel,\n\t\t\t\t\tmipLevelCount: 1,\n\t\t\t\t\tbaseArrayLayer: renderContext.activeCubeFace,\n\t\t\t\t\tdimension: GPUTextureViewDimension.TwoD\n\t\t\t\t} );\n\n\t\t\t\tlet view, resolveTarget;\n\n\t\t\t\tif ( textureData.msaaTexture !== undefined ) {\n\n\t\t\t\t\tview = textureData.msaaTexture.createView();\n\t\t\t\t\tresolveTarget = textureView;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tview = textureView;\n\t\t\t\t\tresolveTarget = undefined;\n\n\t\t\t\t}\n\n\t\t\t\tcolorAttachments.push( {\n\t\t\t\t\tview,\n\t\t\t\t\tresolveTarget,\n\t\t\t\t\tloadOp: GPULoadOp.Load,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store\n\t\t\t\t} );\n\n\t\t\t}\n\n\n\t\t\tdescriptor = {\n\t\t\t\tcolorAttachments,\n\t\t\t};\n\n\t\t\tif ( renderContext.depth ) {\n\n\t\t\t\tconst depthTextureData = this.get( renderContext.depthTexture );\n\n\t\t\t\tconst depthStencilAttachment = {\n\t\t\t\t\tview: depthTextureData.texture.createView()\n\t\t\t\t};\n\t\t\t\tdescriptor.depthStencilAttachment = depthStencilAttachment;\n\n\t\t\t}\n\n\t\t\tdescriptors[ cacheKey ] = descriptor;\n\n\t\t\trenderTargetData.width = renderTarget.width;\n\t\t\trenderTargetData.height = renderTarget.height;\n\t\t\trenderTargetData.samples = renderTarget.samples;\n\t\t\trenderTargetData.activeMipmapLevel = renderTarget.activeMipmapLevel;\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\tbeginRender( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tconst device = this.device;\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tlet occlusionQuerySet;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tif ( renderContextData.currentOcclusionQuerySet ) renderContextData.currentOcclusionQuerySet.destroy();\n\t\t\tif ( renderContextData.currentOcclusionQueryBuffer ) renderContextData.currentOcclusionQueryBuffer.destroy();\n\n\t\t\t// Get a reference to the array of objects with queries. The renderContextData property\n\t\t\t// can be changed by another render pass before the buffer.mapAsyc() completes.\n\t\t\trenderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;\n\t\t\trenderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;\n\t\t\trenderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n\t\t\t//\n\n\t\t\tocclusionQuerySet = device.createQuerySet( { type: 'occlusion', count: occlusionQueryCount, label: `occlusionQuerySet_${ renderContext.id }` } );\n\n\t\t\trenderContextData.occlusionQuerySet = occlusionQuerySet;\n\t\t\trenderContextData.occlusionQueryIndex = 0;\n\t\t\trenderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );\n\n\t\t\trenderContextData.lastOcclusionObject = null;\n\n\t\t}\n\n\t\tlet descriptor;\n\n\t\tif ( renderContext.textures === null ) {\n\n\t\t\tdescriptor = this._getDefaultRenderPassDescriptor();\n\n\t\t} else {\n\n\t\t\tdescriptor = this._getRenderPassDescriptor( renderContext );\n\n\t\t}\n\n\t\tthis.initTimestampQuery( renderContext, descriptor );\n\n\t\tdescriptor.occlusionQuerySet = occlusionQuerySet;\n\n\t\tconst depthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst colorAttachments = descriptor.colorAttachments;\n\n\t\t\tfor ( let i = 0; i < colorAttachments.length; i ++ ) {\n\n\t\t\t\tconst colorAttachment = colorAttachments[ i ];\n\n\t\t\t\tif ( renderContext.clearColor ) {\n\n\t\t\t\t\tcolorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : { r: 0, g: 0, b: 0, a: 1 };\n\t\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\t\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\t\tif ( renderContext.clearColor ) {\n\n\t\t\t\tcolorAttachment.clearValue = renderContext.clearColorValue;\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderContext.depth ) {\n\n\t\t\tif ( renderContext.clearDepth ) {\n\n\t\t\t\tdepthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( renderContext.stencil ) {\n\n\t\t\tif ( renderContext.clearStencil ) {\n\n\t\t\t\tdepthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst encoder = device.createCommandEncoder( { label: 'renderContext_' + renderContext.id } );\n\t\tconst currentPass = encoder.beginRenderPass( descriptor );\n\n\t\t//\n\n\t\trenderContextData.descriptor = descriptor;\n\t\trenderContextData.encoder = encoder;\n\t\trenderContextData.currentPass = currentPass;\n\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\t\trenderContextData.renderBundles = [];\n\n\t\t//\n\n\t\tif ( renderContext.viewport ) {\n\n\t\t\tthis.updateViewport( renderContext );\n\n\t\t}\n\n\t\tif ( renderContext.scissor ) {\n\n\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\tcurrentPass.setScissorRect( x, y, width, height );\n\n\t\t}\n\n\t}\n\n\tfinishRender( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( renderContextData.renderBundles.length > 0 ) {\n\n\t\t\trenderContextData.currentPass.executeBundles( renderContextData.renderBundles );\n\n\t\t}\n\n\t\tif ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {\n\n\t\t\trenderContextData.currentPass.endOcclusionQuery();\n\n\t\t}\n\n\t\trenderContextData.currentPass.end();\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tconst bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results\n\n\t\t\t//\n\n\t\t\tlet queryResolveBuffer = this.occludedResolveCache.get( bufferSize );\n\n\t\t\tif ( queryResolveBuffer === undefined ) {\n\n\t\t\t\tqueryResolveBuffer = this.device.createBuffer(\n\t\t\t\t\t{\n\t\t\t\t\t\tsize: bufferSize,\n\t\t\t\t\t\tusage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tthis.occludedResolveCache.set( bufferSize, queryResolveBuffer );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst readBuffer = this.device.createBuffer(\n\t\t\t\t{\n\t\t\t\t\tsize: bufferSize,\n\t\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined\n\t\t\trenderContextData.encoder.resolveQuerySet( renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0 );\n\t\t\trenderContextData.encoder.copyBufferToBuffer( queryResolveBuffer, 0, readBuffer, 0, bufferSize );\n\n\t\t\trenderContextData.occlusionQueryBuffer = readBuffer;\n\n\t\t\t//\n\n\t\t\tthis.resolveOccludedAsync( renderContext );\n\n\t\t}\n\n\t\tthis.prepareTimestampBuffer( renderContext, renderContextData.encoder );\n\n\t\tthis.device.queue.submit( [ renderContextData.encoder.finish() ] );\n\n\n\t\t//\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst textures = renderContext.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.generateMipmaps === true ) {\n\n\t\t\t\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tisOccluded( renderContext, object ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\treturn renderContextData.occluded && renderContextData.occluded.has( object );\n\n\t}\n\n\tasync resolveOccludedAsync( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t// handle occlusion query results\n\n\t\tconst { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;\n\n\t\tif ( currentOcclusionQueryBuffer && currentOcclusionQueryObjects ) {\n\n\t\t\tconst occluded = new WeakSet();\n\n\t\t\trenderContextData.currentOcclusionQueryObjects = null;\n\t\t\trenderContextData.currentOcclusionQueryBuffer = null;\n\n\t\t\tawait currentOcclusionQueryBuffer.mapAsync( GPUMapMode.READ );\n\n\t\t\tconst buffer = currentOcclusionQueryBuffer.getMappedRange();\n\t\t\tconst results = new BigUint64Array( buffer );\n\n\t\t\tfor ( let i = 0; i < currentOcclusionQueryObjects.length; i ++ ) {\n\n\t\t\t\tif ( results[ i ] !== BigInt( 0 ) ) {\n\n\t\t\t\t\toccluded.add( currentOcclusionQueryObjects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentOcclusionQueryBuffer.destroy();\n\n\t\t\trenderContextData.occluded = occluded;\n\n\t\t}\n\n\t}\n\n\tupdateViewport( renderContext ) {\n\n\t\tconst { currentPass } = this.get( renderContext );\n\t\tconst { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;\n\n\t\tcurrentPass.setViewport( x, y, width, height, minDepth, maxDepth );\n\n\t}\n\n\tclear( color, depth, stencil, renderTargetData = null ) {\n\n\t\tconst device = this.device;\n\t\tconst renderer = this.renderer;\n\n\t\tlet colorAttachments = [];\n\n\t\tlet depthStencilAttachment;\n\t\tlet clearValue;\n\n\t\tlet supportsDepth;\n\t\tlet supportsStencil;\n\n\t\tif ( color ) {\n\n\t\t\tconst clearColor = this.getClearColor();\n\n\t\t\tif ( this.renderer.alpha === true ) {\n\n\t\t\t\t// premultiply alpha\n\n\t\t\t\tconst a = clearColor.a;\n\n\t\t\t\tclearValue = { r: clearColor.r * a, g: clearColor.g * a, b: clearColor.b * a, a: a };\n\n\t\t\t} else {\n\n\t\t\t\tclearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( renderTargetData === null ) {\n\n\t\t\tsupportsDepth = renderer.depth;\n\t\t\tsupportsStencil = renderer.stencil;\n\n\t\t\tconst descriptor = this._getDefaultRenderPassDescriptor();\n\n\t\t\tif ( color ) {\n\n\t\t\t\tcolorAttachments = descriptor.colorAttachments;\n\n\t\t\t\tconst colorAttachment = colorAttachments[ 0 ];\n\n\t\t\t\tcolorAttachment.clearValue = clearValue;\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t\tif ( supportsDepth || supportsStencil ) {\n\n\t\t\t\tdepthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsupportsDepth = renderTargetData.depth;\n\t\t\tsupportsStencil = renderTargetData.stencil;\n\n\t\t\tif ( color ) {\n\n\t\t\t\tfor ( const texture of renderTargetData.textures ) {\n\n\t\t\t\t\tconst textureData = this.get( texture );\n\t\t\t\t\tconst textureView = textureData.texture.createView();\n\n\t\t\t\t\tlet view, resolveTarget;\n\n\t\t\t\t\tif ( textureData.msaaTexture !== undefined ) {\n\n\t\t\t\t\t\tview = textureData.msaaTexture.createView();\n\t\t\t\t\t\tresolveTarget = textureView;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tview = textureView;\n\t\t\t\t\t\tresolveTarget = undefined;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcolorAttachments.push( {\n\t\t\t\t\t\tview,\n\t\t\t\t\t\tresolveTarget,\n\t\t\t\t\t\tclearValue,\n\t\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\t\tstoreOp: GPUStoreOp.Store\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( supportsDepth || supportsStencil ) {\n\n\t\t\t\tconst depthTextureData = this.get( renderTargetData.depthTexture );\n\n\t\t\t\tdepthStencilAttachment = {\n\t\t\t\t\tview: depthTextureData.texture.createView()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( supportsDepth ) {\n\n\t\t\tif ( depth ) {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.depthClearValue = renderer.getClearDepth();\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( supportsStencil ) {\n\n\t\t\tif ( stencil ) {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.stencilClearValue = renderer.getClearStencil();\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst encoder = device.createCommandEncoder( {} );\n\t\tconst currentPass = encoder.beginRenderPass( {\n\t\t\tcolorAttachments,\n\t\t\tdepthStencilAttachment\n\t\t} );\n\n\t\tcurrentPass.end();\n\n\t\tdevice.queue.submit( [ encoder.finish() ] );\n\n\t}\n\n\t// compute\n\n\tbeginCompute( computeGroup ) {\n\n\t\tconst groupGPU = this.get( computeGroup );\n\n\n\t\tconst descriptor = {};\n\n\t\tthis.initTimestampQuery( computeGroup, descriptor );\n\n\t\tgroupGPU.cmdEncoderGPU = this.device.createCommandEncoder();\n\n\t\tgroupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass( descriptor );\n\n\t}\n\n\tcompute( computeGroup, computeNode, bindings, pipeline ) {\n\n\t\tconst { passEncoderGPU } = this.get( computeGroup );\n\n\t\t// pipeline\n\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\n\t\tpassEncoderGPU.setPipeline( pipelineGPU );\n\n\t\t// bind groups\n\n\t\tfor ( let i = 0, l = bindings.length; i < l; i ++ ) {\n\n\t\t\tconst bindGroup = bindings[ i ];\n\t\t\tconst bindingsData = this.get( bindGroup );\n\n\t\t\tpassEncoderGPU.setBindGroup( i, bindingsData.group );\n\n\t\t}\n\n\t\tconst maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;\n\n\t\tconst computeNodeData = this.get( computeNode );\n\n\t\tif ( computeNodeData.dispatchSize === undefined ) computeNodeData.dispatchSize = { x: 0, y: 1, z: 1 };\n\n\t\tconst { dispatchSize } = computeNodeData;\n\n\t\tif ( computeNode.dispatchCount > maxComputeWorkgroupsPerDimension ) {\n\n\t\t\tdispatchSize.x = Math.min( computeNode.dispatchCount, maxComputeWorkgroupsPerDimension );\n\t\t\tdispatchSize.y = Math.ceil( computeNode.dispatchCount / maxComputeWorkgroupsPerDimension );\n\n\t\t} else {\n\n\t\t\tdispatchSize.x = computeNode.dispatchCount;\n\n\t\t}\n\n\t\tpassEncoderGPU.dispatchWorkgroups(\n\t\t\tdispatchSize.x,\n\t\t\tdispatchSize.y,\n\t\t\tdispatchSize.z\n\t\t);\n\n\t}\n\n\tfinishCompute( computeGroup ) {\n\n\t\tconst groupData = this.get( computeGroup );\n\n\t\tgroupData.passEncoderGPU.end();\n\n\t\tthis.prepareTimestampBuffer( computeGroup, groupData.cmdEncoderGPU );\n\n\t\tthis.device.queue.submit( [ groupData.cmdEncoderGPU.finish() ] );\n\n\t}\n\n\tasync waitForGPU() {\n\n\t\tawait this.device.queue.onSubmittedWorkDone();\n\n\t}\n\n\t// render object\n\n\tdraw( renderObject, info ) {\n\n\t\tconst { object, context, pipeline } = renderObject;\n\t\tconst bindings = renderObject.getBindings();\n\t\tconst renderContextData = this.get( context );\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\n\t\tconst currentSets = renderContextData.currentSets;\n\t\tconst passEncoderGPU = renderContextData.currentPass;\n\n\t\tconst drawParams = renderObject.getDrawParameters();\n\n\t\tif ( drawParams === null ) return;\n\n\t\t// pipeline\n\n\t\tif ( currentSets.pipeline !== pipelineGPU ) {\n\n\t\t\tpassEncoderGPU.setPipeline( pipelineGPU );\n\n\t\t\tcurrentSets.pipeline = pipelineGPU;\n\n\t\t}\n\n\t\t// bind groups\n\n\t\tconst currentBindingGroups = currentSets.bindingGroups;\n\n\t\tfor ( let i = 0, l = bindings.length; i < l; i ++ ) {\n\n\t\t\tconst bindGroup = bindings[ i ];\n\t\t\tconst bindingsData = this.get( bindGroup );\n\n\t\t\tif ( currentBindingGroups[ bindGroup.index ] !== bindGroup.id ) {\n\n\t\t\t\tpassEncoderGPU.setBindGroup( bindGroup.index, bindingsData.group );\n\t\t\t\tcurrentBindingGroups[ bindGroup.index ] = bindGroup.id;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst index = renderObject.getIndex();\n\n\t\tconst hasIndex = ( index !== null );\n\n\t\t// index\n\n\t\tif ( hasIndex === true ) {\n\n\t\t\tif ( currentSets.index !== index ) {\n\n\t\t\t\tconst buffer = this.get( index ).buffer;\n\t\t\t\tconst indexFormat = ( index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n\n\t\t\t\tpassEncoderGPU.setIndexBuffer( buffer, indexFormat );\n\n\t\t\t\tcurrentSets.index = index;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// vertex buffers\n\n\t\tconst vertexBuffers = renderObject.getVertexBuffers();\n\n\t\tfor ( let i = 0, l = vertexBuffers.length; i < l; i ++ ) {\n\n\t\t\tconst vertexBuffer = vertexBuffers[ i ];\n\n\t\t\tif ( currentSets.attributes[ i ] !== vertexBuffer ) {\n\n\t\t\t\tconst buffer = this.get( vertexBuffer ).buffer;\n\t\t\t\tpassEncoderGPU.setVertexBuffer( i, buffer );\n\n\t\t\t\tcurrentSets.attributes[ i ] = vertexBuffer;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// occlusion queries - handle multiple consecutive draw calls for an object\n\n\t\tif ( renderContextData.occlusionQuerySet !== undefined ) {\n\n\t\t\tconst lastObject = renderContextData.lastOcclusionObject;\n\n\t\t\tif ( lastObject !== object ) {\n\n\t\t\t\tif ( lastObject !== null && lastObject.occlusionTest === true ) {\n\n\t\t\t\t\tpassEncoderGPU.endOcclusionQuery();\n\t\t\t\t\trenderContextData.occlusionQueryIndex ++;\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.occlusionTest === true ) {\n\n\t\t\t\t\tpassEncoderGPU.beginOcclusionQuery( renderContextData.occlusionQueryIndex );\n\t\t\t\t\trenderContextData.occlusionQueryObjects[ renderContextData.occlusionQueryIndex ] = object;\n\n\t\t\t\t}\n\n\t\t\t\trenderContextData.lastOcclusionObject = object;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// draw\n\n\t\tif ( object.isBatchedMesh === true ) {\n\n\t\t\tconst starts = object._multiDrawStarts;\n\t\t\tconst counts = object._multiDrawCounts;\n\t\t\tconst drawCount = object._multiDrawCount;\n\t\t\tconst drawInstances = object._multiDrawInstances;\n\n\t\t\tconst bytesPerElement = hasIndex ? index.array.BYTES_PER_ELEMENT : 1;\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tconst count = drawInstances ? drawInstances[ i ] : 1;\n\t\t\t\tconst firstInstance = count > 1 ? 0 : i;\n\n\t\t\t\tpassEncoderGPU.drawIndexed( counts[ i ], count, starts[ i ] / bytesPerElement, 0, firstInstance );\n\n\t\t\t}\n\n\t\t} else if ( hasIndex === true ) {\n\n\t\t\tconst { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParams;\n\n\t\t\tconst indirect = renderObject.getIndirect();\n\n\t\t\tif ( indirect !== null ) {\n\n\t\t\t\tconst buffer = this.get( indirect ).buffer;\n\n\t\t\t\tpassEncoderGPU.drawIndexedIndirect( buffer, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tpassEncoderGPU.drawIndexed( indexCount, instanceCount, firstIndex, 0, 0 );\n\n\t\t\t}\n\n\t\t\tinfo.update( object, indexCount, instanceCount );\n\n\t\t} else {\n\n\t\t\tconst { vertexCount, instanceCount, firstVertex } = drawParams;\n\n\t\t\tconst indirect = renderObject.getIndirect();\n\n\t\t\tif ( indirect !== null ) {\n\n\t\t\t\tconst buffer = this.get( indirect ).buffer;\n\n\t\t\t\tpassEncoderGPU.drawIndirect( buffer, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tpassEncoderGPU.draw( vertexCount, instanceCount, firstVertex, 0 );\n\n\t\t\t}\n\n\t\t\tinfo.update( object, vertexCount, instanceCount );\n\n\t\t}\n\n\t}\n\n\t// cache key\n\n\tneedsRenderUpdate( renderObject ) {\n\n\t\tconst data = this.get( renderObject );\n\n\t\tconst { object, material } = renderObject;\n\n\t\tconst utils = this.utils;\n\n\t\tconst sampleCount = utils.getSampleCountRenderContext( renderObject.context );\n\t\tconst colorSpace = utils.getCurrentColorSpace( renderObject.context );\n\t\tconst colorFormat = utils.getCurrentColorFormat( renderObject.context );\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );\n\t\tconst primitiveTopology = utils.getPrimitiveTopology( object, material );\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( data.material !== material || data.materialVersion !== material.version ||\n\t\t\tdata.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||\n\t\t\tdata.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||\n\t\t\tdata.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||\n\t\t\tdata.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||\n\t\t\tdata.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||\n\t\t\tdata.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||\n\t\t\tdata.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||\n\t\t\tdata.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage ||\n\t\t\tdata.sampleCount !== sampleCount || data.colorSpace !== colorSpace ||\n\t\t\tdata.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat ||\n\t\t\tdata.primitiveTopology !== primitiveTopology ||\n\t\t\tdata.clippingContextCacheKey !== renderObject.clippingContextCacheKey\n\t\t) {\n\n\t\t\tdata.material = material; data.materialVersion = material.version;\n\t\t\tdata.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;\n\t\t\tdata.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;\n\t\t\tdata.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;\n\t\t\tdata.colorWrite = material.colorWrite;\n\t\t\tdata.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;\n\t\t\tdata.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;\n\t\t\tdata.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;\n\t\t\tdata.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;\n\t\t\tdata.side = material.side; data.alphaToCoverage = material.alphaToCoverage;\n\t\t\tdata.sampleCount = sampleCount;\n\t\t\tdata.colorSpace = colorSpace;\n\t\t\tdata.colorFormat = colorFormat;\n\t\t\tdata.depthStencilFormat = depthStencilFormat;\n\t\t\tdata.primitiveTopology = primitiveTopology;\n\t\t\tdata.clippingContextCacheKey = renderObject.clippingContextCacheKey;\n\n\t\t\tneedsUpdate = true;\n\n\t\t}\n\n\t\treturn needsUpdate;\n\n\t}\n\n\tgetRenderCacheKey( renderObject ) {\n\n\t\tconst { object, material } = renderObject;\n\n\t\tconst utils = this.utils;\n\t\tconst renderContext = renderObject.context;\n\n\t\treturn [\n\t\t\tmaterial.transparent, material.blending, material.premultipliedAlpha,\n\t\t\tmaterial.blendSrc, material.blendDst, material.blendEquation,\n\t\t\tmaterial.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,\n\t\t\tmaterial.colorWrite,\n\t\t\tmaterial.depthWrite, material.depthTest, material.depthFunc,\n\t\t\tmaterial.stencilWrite, material.stencilFunc,\n\t\t\tmaterial.stencilFail, material.stencilZFail, material.stencilZPass,\n\t\t\tmaterial.stencilFuncMask, material.stencilWriteMask,\n\t\t\tmaterial.side,\n\t\t\tutils.getSampleCountRenderContext( renderContext ),\n\t\t\tutils.getCurrentColorSpace( renderContext ), utils.getCurrentColorFormat( renderContext ), utils.getCurrentDepthStencilFormat( renderContext ),\n\t\t\tutils.getPrimitiveTopology( object, material ),\n\t\t\trenderObject.getGeometryCacheKey(),\n\t\t\trenderObject.clippingContextCacheKey\n\t\t].join();\n\n\t}\n\n\t// textures\n\n\tcreateSampler( texture ) {\n\n\t\tthis.textureUtils.createSampler( texture );\n\n\t}\n\n\tdestroySampler( texture ) {\n\n\t\tthis.textureUtils.destroySampler( texture );\n\n\t}\n\n\tcreateDefaultTexture( texture ) {\n\n\t\tthis.textureUtils.createDefaultTexture( texture );\n\n\t}\n\n\tcreateTexture( texture, options ) {\n\n\t\tthis.textureUtils.createTexture( texture, options );\n\n\t}\n\n\tupdateTexture( texture, options ) {\n\n\t\tthis.textureUtils.updateTexture( texture, options );\n\n\t}\n\n\tgenerateMipmaps( texture ) {\n\n\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t}\n\n\tdestroyTexture( texture ) {\n\n\t\tthis.textureUtils.destroyTexture( texture );\n\n\t}\n\n\tcopyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\treturn this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );\n\n\t}\n\n\n\tinitTimestampQuery( renderContext, descriptor ) {\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( ! renderContextData.timeStampQuerySet ) {\n\n\n\t\t\tconst type = renderContext.isComputeNode ? 'compute' : 'render';\n\t\t\tconst timeStampQuerySet = this.device.createQuerySet( { type: 'timestamp', count: 2, label: `timestamp_${type}_${renderContext.id}` } );\n\n\t\t\tconst timestampWrites = {\n\t\t\t\tquerySet: timeStampQuerySet,\n\t\t\t\tbeginningOfPassWriteIndex: 0, // Write timestamp in index 0 when pass begins.\n\t\t\t\tendOfPassWriteIndex: 1, // Write timestamp in index 1 when pass ends.\n\t\t\t};\n\n\t\t\tObject.assign( descriptor, { timestampWrites } );\n\n\t\t\trenderContextData.timeStampQuerySet = timeStampQuerySet;\n\n\t\t}\n\n\t}\n\n\t// timestamp utils\n\n\tprepareTimestampBuffer( renderContext, encoder ) {\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\n\t\tconst size = 2 * BigInt64Array.BYTES_PER_ELEMENT;\n\n\t\tif ( renderContextData.currentTimestampQueryBuffers === undefined ) {\n\n\t\t\trenderContextData.currentTimestampQueryBuffers = {\n\t\t\t\tresolveBuffer: this.device.createBuffer( {\n\t\t\t\t\tlabel: 'timestamp resolve buffer',\n\t\t\t\t\tsize: size,\n\t\t\t\t\tusage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,\n\t\t\t\t} ),\n\t\t\t\tresultBuffer: this.device.createBuffer( {\n\t\t\t\t\tlabel: 'timestamp result buffer',\n\t\t\t\t\tsize: size,\n\t\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n\t\t\t\t} )\n\t\t\t};\n\n\t\t}\n\n\t\tconst { resolveBuffer, resultBuffer } = renderContextData.currentTimestampQueryBuffers;\n\n\n\t\tencoder.resolveQuerySet( renderContextData.timeStampQuerySet, 0, 2, resolveBuffer, 0 );\n\n\t\tif ( resultBuffer.mapState === 'unmapped' ) {\n\n\t\t\tencoder.copyBufferToBuffer( resolveBuffer, 0, resultBuffer, 0, size );\n\n\t\t}\n\n\t}\n\n\tasync resolveTimestampAsync( renderContext, type = 'render' ) {\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( renderContextData.currentTimestampQueryBuffers === undefined ) return;\n\n\t\tconst { resultBuffer } = renderContextData.currentTimestampQueryBuffers;\n\n\t\tawait this.device.queue.onSubmittedWorkDone();\n\n\t\tif ( resultBuffer.mapState === 'unmapped' ) {\n\n\t\t\tresultBuffer.mapAsync( GPUMapMode.READ ).then( () => {\n\n\t\t\t\tconst times = new BigUint64Array( resultBuffer.getMappedRange() );\n\t\t\t\tconst duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;\n\n\n\t\t\t\tthis.renderer.info.updateTimestamp( type, duration );\n\n\t\t\t\tresultBuffer.unmap();\n\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// node builder\n\n\tcreateNodeBuilder( object, renderer ) {\n\n\t\treturn new WGSLNodeBuilder( object, renderer );\n\n\t}\n\n\t// program\n\n\tcreateProgram( program ) {\n\n\t\tconst programGPU = this.get( program );\n\n\t\tprogramGPU.module = {\n\t\t\tmodule: this.device.createShaderModule( { code: program.code, label: program.stage } ),\n\t\t\tentryPoint: 'main'\n\t\t};\n\n\t}\n\n\tdestroyProgram( program ) {\n\n\t\tthis.delete( program );\n\n\t}\n\n\t// pipelines\n\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tthis.pipelineUtils.createRenderPipeline( renderObject, promises );\n\n\t}\n\n\tcreateComputePipeline( computePipeline, bindings ) {\n\n\t\tthis.pipelineUtils.createComputePipeline( computePipeline, bindings );\n\n\t}\n\n\tbeginBundle( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\trenderContextData._currentPass = renderContextData.currentPass;\n\t\trenderContextData._currentSets = renderContextData.currentSets;\n\n\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\t\trenderContextData.currentPass = this.pipelineUtils.createBundleEncoder( renderContext );\n\n\t}\n\n\tfinishBundle( renderContext, bundle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tconst bundleEncoder = renderContextData.currentPass;\n\t\tconst bundleGPU = bundleEncoder.finish();\n\n\t\tthis.get( bundle ).bundleGPU = bundleGPU;\n\n\t\t// restore render pass state\n\n\t\trenderContextData.currentSets = renderContextData._currentSets;\n\t\trenderContextData.currentPass = renderContextData._currentPass;\n\n\t}\n\n\taddBundle( renderContext, bundle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\trenderContextData.renderBundles.push( this.get( bundle ).bundleGPU );\n\n\t}\n\n\t// bindings\n\n\tcreateBindings( bindGroup, bindings, cacheIndex, version ) {\n\n\t\tthis.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );\n\n\t}\n\n\tupdateBindings( bindGroup, bindings, cacheIndex, version ) {\n\n\t\tthis.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );\n\n\t}\n\n\tupdateBinding( binding ) {\n\n\t\tthis.bindingUtils.updateBinding( binding );\n\n\t}\n\n\t// attributes\n\n\tcreateIndexAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\tcreateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\tcreateStorageAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\tcreateIndirectStorageAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\tupdateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.updateAttribute( attribute );\n\n\t}\n\n\tdestroyAttribute( attribute ) {\n\n\t\tthis.attributeUtils.destroyAttribute( attribute );\n\n\t}\n\n\t// canvas\n\n\tupdateSize() {\n\n\t\tthis.colorBuffer = this.textureUtils.getColorBuffer();\n\t\tthis.defaultRenderPassdescriptor = null;\n\n\t}\n\n\t// utils public\n\n\tgetMaxAnisotropy() {\n\n\t\treturn 16;\n\n\t}\n\n\thasFeature( name ) {\n\n\t\treturn this.device.features.has( name );\n\n\t}\n\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\tlet dstX = 0;\n\t\tlet dstY = 0;\n\t\tlet dstLayer = 0;\n\n\t\tlet srcX = 0;\n\t\tlet srcY = 0;\n\t\tlet srcLayer = 0;\n\n\t\tlet srcWidth = srcTexture.image.width;\n\t\tlet srcHeight = srcTexture.image.height;\n\n\t\tif ( srcRegion !== null ) {\n\n\t\t\tsrcX = srcRegion.x;\n\t\t\tsrcY = srcRegion.y;\n\t\t\tsrcLayer = srcRegion.z || 0;\n\t\t\tsrcWidth = srcRegion.width;\n\t\t\tsrcHeight = srcRegion.height;\n\n\t\t}\n\n\t\tif ( dstPosition !== null ) {\n\n\t\t\tdstX = dstPosition.x;\n\t\t\tdstY = dstPosition.y;\n\t\t\tdstLayer = dstPosition.z || 0;\n\n\t\t}\n\n\t\tconst encoder = this.device.createCommandEncoder( { label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id } );\n\n\t\tconst sourceGPU = this.get( srcTexture ).texture;\n\t\tconst destinationGPU = this.get( dstTexture ).texture;\n\n\t\tencoder.copyTextureToTexture(\n\t\t\t{\n\t\t\t\ttexture: sourceGPU,\n\t\t\t\tmipLevel: level,\n\t\t\t\torigin: { x: srcX, y: srcY, z: srcLayer }\n\t\t\t},\n\t\t\t{\n\t\t\t\ttexture: destinationGPU,\n\t\t\t\tmipLevel: level,\n\t\t\t\torigin: { x: dstX, y: dstY, z: dstLayer }\n\t\t\t},\n\t\t\t[\n\t\t\t\tsrcWidth,\n\t\t\t\tsrcHeight,\n\t\t\t\t1\n\t\t\t]\n\t\t);\n\n\t\tthis.device.queue.submit( [ encoder.finish() ] );\n\n\t}\n\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tlet sourceGPU = null;\n\n\t\tif ( renderContext.renderTarget ) {\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\tsourceGPU = this.get( renderContext.depthTexture ).texture;\n\n\t\t\t} else {\n\n\t\t\t\tsourceGPU = this.get( renderContext.textures[ 0 ] ).texture;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\tsourceGPU = this.textureUtils.getDepthBuffer( renderContext.depth, renderContext.stencil );\n\n\t\t\t} else {\n\n\t\t\t\tsourceGPU = this.context.getCurrentTexture();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst destinationGPU = this.get( texture ).texture;\n\n\t\tif ( sourceGPU.format !== destinationGPU.format ) {\n\n\t\t\tconsole.error( 'WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet encoder;\n\n\t\tif ( renderContextData.currentPass ) {\n\n\t\t\trenderContextData.currentPass.end();\n\n\t\t\tencoder = renderContextData.encoder;\n\n\t\t} else {\n\n\t\t\tencoder = this.device.createCommandEncoder( { label: 'copyFramebufferToTexture_' + texture.id } );\n\n\t\t}\n\n\t\tencoder.copyTextureToTexture(\n\t\t\t{\n\t\t\t\ttexture: sourceGPU,\n\t\t\t\torigin: [ rectangle.x, rectangle.y, 0 ],\n\t\t\t},\n\t\t\t{\n\t\t\t\ttexture: destinationGPU\n\t\t\t},\n\t\t\t[\n\t\t\t\trectangle.z,\n\t\t\t\trectangle.w\n\t\t\t]\n\t\t);\n\n\t\tif ( texture.generateMipmaps ) this.textureUtils.generateMipmaps( texture );\n\n\t\tif ( renderContextData.currentPass ) {\n\n\t\t\tconst { descriptor } = renderContextData;\n\n\t\t\tfor ( let i = 0; i < descriptor.colorAttachments.length; i ++ ) {\n\n\t\t\t\tdescriptor.colorAttachments[ i ].loadOp = GPULoadOp.Load;\n\n\t\t\t}\n\n\t\t\tif ( renderContext.depth ) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\tif ( renderContext.stencil ) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\n\t\t\trenderContextData.currentPass = encoder.beginRenderPass( descriptor );\n\t\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\n\t\t\tif ( renderContext.viewport ) {\n\n\t\t\t\tthis.updateViewport( renderContext );\n\n\t\t\t}\n\n\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\t\trenderContextData.currentPass.setScissorRect( x, y, width, height );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.device.queue.submit( [ encoder.finish() ] );\n\n\t\t}\n\n\t}\n\n}\n\nclass IESSpotLight extends SpotLight {\n\n\tconstructor( color, intensity, distance, angle, penumbra, decay ) {\n\n\t\tsuper( color, intensity, distance, angle, penumbra, decay );\n\n\t\tthis.iesMap = null;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.iesMap = source.iesMap;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass StandardNodeLibrary extends NodeLibrary {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.addMaterial( MeshPhongNodeMaterial, 'MeshPhongMaterial' );\n\t\tthis.addMaterial( MeshStandardNodeMaterial, 'MeshStandardMaterial' );\n\t\tthis.addMaterial( MeshPhysicalNodeMaterial, 'MeshPhysicalMaterial' );\n\t\tthis.addMaterial( MeshToonNodeMaterial, 'MeshToonMaterial' );\n\t\tthis.addMaterial( MeshBasicNodeMaterial, 'MeshBasicMaterial' );\n\t\tthis.addMaterial( MeshLambertNodeMaterial, 'MeshLambertMaterial' );\n\t\tthis.addMaterial( MeshNormalNodeMaterial, 'MeshNormalMaterial' );\n\t\tthis.addMaterial( MeshMatcapNodeMaterial, 'MeshMatcapMaterial' );\n\t\tthis.addMaterial( LineBasicNodeMaterial, 'LineBasicMaterial' );\n\t\tthis.addMaterial( LineDashedNodeMaterial, 'LineDashedMaterial' );\n\t\tthis.addMaterial( PointsNodeMaterial, 'PointsMaterial' );\n\t\tthis.addMaterial( SpriteNodeMaterial, 'SpriteMaterial' );\n\t\tthis.addMaterial( ShadowNodeMaterial, 'ShadowMaterial' );\n\n\t\tthis.addLight( PointLightNode, PointLight );\n\t\tthis.addLight( DirectionalLightNode, DirectionalLight );\n\t\tthis.addLight( RectAreaLightNode, RectAreaLight );\n\t\tthis.addLight( SpotLightNode, SpotLight );\n\t\tthis.addLight( AmbientLightNode, AmbientLight );\n\t\tthis.addLight( HemisphereLightNode, HemisphereLight );\n\t\tthis.addLight( LightProbeNode, LightProbe );\n\t\tthis.addLight( IESSpotLightNode, IESSpotLight );\n\n\t\tthis.addToneMapping( linearToneMapping, LinearToneMapping );\n\t\tthis.addToneMapping( reinhardToneMapping, ReinhardToneMapping );\n\t\tthis.addToneMapping( cineonToneMapping, CineonToneMapping );\n\t\tthis.addToneMapping( acesFilmicToneMapping, ACESFilmicToneMapping );\n\t\tthis.addToneMapping( agxToneMapping, AgXToneMapping );\n\t\tthis.addToneMapping( neutralToneMapping, NeutralToneMapping );\n\n\t}\n\n}\n\n/*\nconst debugHandler = {\n\n\tget: function ( target, name ) {\n\n\t\t// Add |update\n\t\tif ( /^(create|destroy)/.test( name ) ) console.log( 'WebGPUBackend.' + name );\n\n\t\treturn target[ name ];\n\n\t}\n\n};\n*/\nclass WebGPURenderer extends Renderer {\n\n\tconstructor( parameters = {} ) {\n\n\t\tlet BackendClass;\n\n\t\tif ( parameters.forceWebGL ) {\n\n\t\t\tBackendClass = WebGLBackend;\n\n\t\t} else {\n\n\t\t\tBackendClass = WebGPUBackend;\n\n\t\t\tparameters.getFallback = () => {\n\n\t\t\t\tconsole.warn( 'THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.' );\n\n\t\t\t\treturn new WebGLBackend( parameters );\n\n\t\t\t};\n\n\t\t}\n\n\t\tconst backend = new BackendClass( parameters );\n\n\t\t//super( new Proxy( backend, debugHandler ) );\n\t\tsuper( backend, parameters );\n\n\t\tthis.library = new StandardNodeLibrary();\n\n\t\tthis.isWebGPURenderer = true;\n\n\t}\n\n}\n\nclass BundleGroup extends Group {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBundleGroup = true;\n\n\t\tthis.type = 'BundleGroup';\n\n\t\tthis.static = true;\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n}\n\nconst _material = /*@__PURE__*/ new NodeMaterial();\nconst _quadMesh = /*@__PURE__*/ new QuadMesh( _material );\n\nclass PostProcessing {\n\n\tconstructor( renderer, outputNode = vec4( 0, 0, 1, 1 ) ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.outputNode = outputNode;\n\n\t\tthis.outputColorTransform = true;\n\n\t\tthis.needsUpdate = true;\n\n\t\t_material.name = 'PostProcessing';\n\n\t}\n\n\trender() {\n\n\t\tthis.update();\n\n\t\tconst renderer = this.renderer;\n\n\t\tconst toneMapping = renderer.toneMapping;\n\t\tconst outputColorSpace = renderer.outputColorSpace;\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.outputColorSpace = LinearSRGBColorSpace;\n\n\t\t//\n\n\t\t_quadMesh.render( renderer );\n\n\t\t//\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.outputColorSpace = outputColorSpace;\n\n\t}\n\n\tupdate() {\n\n\t\tif ( this.needsUpdate === true ) {\n\n\t\t\tconst renderer = this.renderer;\n\n\t\t\tconst toneMapping = renderer.toneMapping;\n\t\t\tconst outputColorSpace = renderer.outputColorSpace;\n\n\t\t\t_quadMesh.material.fragmentNode = this.outputColorTransform === true ? renderOutput( this.outputNode, toneMapping, outputColorSpace ) : this.outputNode.context( { toneMapping, outputColorSpace } );\n\t\t\t_quadMesh.material.needsUpdate = true;\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t}\n\n\t}\n\n\tasync renderAsync() {\n\n\t\tthis.update();\n\n\t\tconst renderer = this.renderer;\n\n\t\tconst toneMapping = renderer.toneMapping;\n\t\tconst outputColorSpace = renderer.outputColorSpace;\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.outputColorSpace = LinearSRGBColorSpace;\n\n\t\t//\n\n\t\tawait _quadMesh.renderAsync( renderer );\n\n\t\t//\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.outputColorSpace = outputColorSpace;\n\n\t}\n\n}\n\n// renderer state\n\nfunction saveRendererState( renderer, state = {} ) {\n\n\tstate.toneMapping = renderer.toneMapping;\n\tstate.toneMappingExposure = renderer.toneMappingExposure;\n\tstate.outputColorSpace = renderer.outputColorSpace;\n\tstate.renderTarget = renderer.getRenderTarget();\n\tstate.activeCubeFace = renderer.getActiveCubeFace();\n\tstate.activeMipmapLevel = renderer.getActiveMipmapLevel();\n\tstate.renderObjectFunction = renderer.getRenderObjectFunction();\n\tstate.pixelRatio = renderer.getPixelRatio();\n\tstate.mrt = renderer.getMRT();\n\tstate.clearColor = renderer.getClearColor( state.clearColor || new Color() );\n\tstate.clearAlpha = renderer.getClearAlpha();\n\tstate.autoClear = renderer.autoClear;\n\tstate.scissorTest = renderer.getScissorTest();\n\n\treturn state;\n\n}\n\nfunction resetRendererState( renderer, state ) {\n\n\tstate = saveRendererState( renderer, state );\n\n\trenderer.setMRT( null );\n\trenderer.setRenderObjectFunction( null );\n\trenderer.setClearColor( 0x000000, 1 );\n\trenderer.autoClear = true;\n\n\treturn state;\n\n}\n\nfunction restoreRendererState( renderer, state ) {\n\n\trenderer.toneMapping = state.toneMapping;\n\trenderer.toneMappingExposure = state.toneMappingExposure;\n\trenderer.outputColorSpace = state.outputColorSpace;\n\trenderer.setRenderTarget( state.renderTarget, state.activeCubeFace, state.activeMipmapLevel );\n\trenderer.setRenderObjectFunction( state.renderObjectFunction );\n\trenderer.setPixelRatio( state.pixelRatio );\n\trenderer.setMRT( state.mrt );\n\trenderer.setClearColor( state.clearColor, state.clearAlpha );\n\trenderer.autoClear = state.autoClear;\n\trenderer.setScissorTest( state.scissorTest );\n\n}\n\n// renderer and scene state\n\nfunction saveRendererAndSceneState( renderer, scene, state = {} ) {\n\n\tstate = saveRendererState( renderer, state );\n\tstate.background = scene.background;\n\tstate.backgroundNode = scene.backgroundNode;\n\tstate.overrideMaterial = scene.overrideMaterial;\n\n\treturn state;\n\n}\n\nfunction resetRendererAndSceneState( renderer, scene, state ) {\n\n\tstate = saveRendererAndSceneState( renderer, scene, state );\n\n\tscene.background = null;\n\tscene.backgroundNode = null;\n\tscene.overrideMaterial = null;\n\n\treturn state;\n\n}\n\nfunction restoreRendererAndSceneState( renderer, scene, state ) {\n\n\trestoreRendererState( renderer, state );\n\n\tscene.background = state.background;\n\tscene.backgroundNode = state.backgroundNode;\n\tscene.overrideMaterial = state.overrideMaterial;\n\n}\n\nvar PostProcessingUtils = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tresetRendererAndSceneState: resetRendererAndSceneState,\n\tresetRendererState: resetRendererState,\n\trestoreRendererAndSceneState: restoreRendererAndSceneState,\n\trestoreRendererState: restoreRendererState,\n\tsaveRendererAndSceneState: saveRendererAndSceneState,\n\tsaveRendererState: saveRendererState\n});\n\nclass StorageTexture extends Texture {\n\n\tconstructor( width = 1, height = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.image = { width, height };\n\n\t\tthis.magFilter = LinearFilter;\n\t\tthis.minFilter = LinearFilter;\n\n\t\tthis.isStorageTexture = true;\n\n\t}\n\n}\n\nclass IndirectStorageBufferAttribute extends StorageBufferAttribute {\n\n\tconstructor( array, itemSize ) {\n\n\t\tsuper( array, itemSize, Uint32Array );\n\n\t\tthis.isIndirectStorageBufferAttribute = true;\n\n\t}\n\n}\n\nclass NodeLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.textures = {};\n\t\tthis.nodes = {};\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, ( text ) => {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( this.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tthis.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparseNodes( json ) {\n\n\t\tconst nodes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( const nodeJSON of json ) {\n\n\t\t\t\tconst { uuid, type } = nodeJSON;\n\n\t\t\t\tnodes[ uuid ] = this.createNodeFromType( type );\n\t\t\t\tnodes[ uuid ].uuid = uuid;\n\n\t\t\t}\n\n\t\t\tconst meta = { nodes, textures: this.textures };\n\n\t\t\tfor ( const nodeJSON of json ) {\n\n\t\t\t\tnodeJSON.meta = meta;\n\n\t\t\t\tconst node = nodes[ nodeJSON.uuid ];\n\t\t\t\tnode.deserialize( nodeJSON );\n\n\t\t\t\tdelete nodeJSON.meta;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodes;\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst node = this.createNodeFromType( json.type );\n\t\tnode.uuid = json.uuid;\n\n\t\tconst nodes = this.parseNodes( json.nodes );\n\t\tconst meta = { nodes, textures: this.textures };\n\n\t\tjson.meta = meta;\n\n\t\tnode.deserialize( json );\n\n\t\tdelete json.meta;\n\n\t\treturn node;\n\n\t}\n\n\tsetTextures( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\tcreateNodeFromType( type ) {\n\n\t\tif ( this.nodes[ type ] === undefined ) {\n\n\t\t\tconsole.error( 'THREE.NodeLoader: Node type not found:', type );\n\t\t\treturn float();\n\n\t\t}\n\n\t\treturn nodeObject( new this.nodes[ type ]() );\n\n\t}\n\n}\n\nclass NodeMaterialLoader extends MaterialLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.nodes = {};\n\t\tthis.nodeMaterials = {};\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst material = super.parse( json );\n\n\t\tconst nodes = this.nodes;\n\t\tconst inputNodes = json.inputNodes;\n\n\t\tfor ( const property in inputNodes ) {\n\n\t\t\tconst uuid = inputNodes[ property ];\n\n\t\t\tmaterial[ property ] = nodes[ uuid ];\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\tsetNodeMaterials( value ) {\n\n\t\tthis.nodeMaterials = value;\n\t\treturn this;\n\n\t}\n\n\tcreateMaterialFromType( type ) {\n\n\t\tconst materialClass = this.nodeMaterials[ type ];\n\n\t\tif ( materialClass !== undefined ) {\n\n\t\t\treturn new materialClass();\n\n\t\t}\n\n\t\treturn super.createMaterialFromType( type );\n\n\t}\n\n}\n\nclass NodeObjectLoader extends ObjectLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.nodes = {};\n\t\tthis.nodeMaterials = {};\n\n\t\tthis._nodesJSON = null;\n\n\t}\n\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\tsetNodeMaterials( value ) {\n\n\t\tthis.nodeMaterials = value;\n\t\treturn this;\n\n\t}\n\n\tparse( json, onLoad ) {\n\n\t\tthis._nodesJSON = json.nodes;\n\n\t\tconst data = super.parse( json, onLoad );\n\n\t\tthis._nodesJSON = null; // dispose\n\n\t\treturn data;\n\n\t}\n\n\tparseNodes( json, textures ) {\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new NodeLoader();\n\t\t\tloader.setNodes( this.nodes );\n\t\t\tloader.setTextures( textures );\n\n\t\t\treturn loader.parseNodes( json );\n\n\t\t}\n\n\t\treturn {};\n\n\t}\n\n\tparseMaterials( json, textures ) {\n\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst nodes = this.parseNodes( this._nodesJSON, textures );\n\n\t\t\tconst loader = new NodeMaterialLoader();\n\t\t\tloader.setTextures( textures );\n\t\t\tloader.setNodes( nodes );\n\t\t\tloader.setNodeMaterials( this.nodeMaterials );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tmaterials[ data.uuid ] = loader.parse( data );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n}\n\nclass ClippingGroup extends Group {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isClippingGroup = true;\n\t\tthis.clippingPlanes = [];\n\t\tthis.enabled = true;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t}\n\n}\n\nexport { ACESFilmicToneMapping, AONode, AddEquation, AddOperation, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightNode, AnalyticLightNode, ArrayElementNode, AssignNode, AttributeNode, BackSide, BasicEnvironmentNode, BasicShadowMap, BatchNode, BoxGeometry, BufferAttribute, BufferAttributeNode, BufferGeometry, BufferNode, BumpMapNode, BundleGroup, BypassNode, ByteType, CacheNode, CineonToneMapping, ClampToEdgeWrapping, ClippingGroup, CodeNode, Color, ColorManagement, ColorSpaceNode, ComputeNode, ConstNode, ContextNode, ConvertNode, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureNode, CubeUVReflectionMapping, CullFaceBack, CullFaceFront, CullFaceNone, CustomBlending, DataArrayTexture, DataTexture, DecrementStencilOp, DecrementWrapStencilOp, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightNode, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicDrawUsage, EnvironmentNode, EqualCompare, EqualDepth, EqualStencilFunc, EquirectUVNode, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExpressionNode, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, FogExp2Node, FogNode, FogRangeNode, FramebufferTexture, FrontFacingNode, FrontSide, Frustum, FunctionCallNode, FunctionNode, FunctionOverloadingNode, GLSLNodeParser, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, Group, HalfFloatType, HemisphereLight, HemisphereLightNode, IESSpotLight, IESSpotLightNode, IncrementStencilOp, IncrementWrapStencilOp, IndexNode, IndirectStorageBufferAttribute, InstanceNode, InstancedBufferAttribute, InstancedInterleavedBuffer, InstancedMeshNode, InstancedPointsNodeMaterial, IntType, InterleavedBuffer, InterleavedBufferAttribute, InvertStencilOp, IrradianceNode, JoinNode, KeepStencilOp, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, LightProbe, LightProbeNode, Lighting, LightingContextNode, LightingModel, LightingNode, LightsNode, Line2NodeMaterial, LineBasicMaterial, LineBasicNodeMaterial, LineDashedMaterial, LineDashedNodeMaterial, LinearFilter, LinearMipMapLinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, Loader, LoopNode, LuminanceAlphaFormat, LuminanceFormat, MRTNode, MatcapUVNode, Material, MaterialLoader, MaterialNode, MaterialReferenceNode, MathUtils, Matrix3, Matrix4, MaxEquation, MaxMipLevelNode, Mesh, MeshBasicMaterial, MeshBasicNodeMaterial, MeshLambertMaterial, MeshLambertNodeMaterial, MeshMatcapMaterial, MeshMatcapNodeMaterial, MeshNormalMaterial, MeshNormalNodeMaterial, MeshPhongMaterial, MeshPhongNodeMaterial, MeshPhysicalMaterial, MeshPhysicalNodeMaterial, MeshSSSNodeMaterial, MeshStandardMaterial, MeshStandardNodeMaterial, MeshToonMaterial, MeshToonNodeMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, ModelNode, ModelViewProjectionNode, MorphNode, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, Node, NodeAccess, NodeAttribute, NodeBuilder, NodeCache, NodeCode, NodeFrame, NodeFunctionInput, NodeLoader, NodeMaterial, NodeMaterialLoader, NodeMaterialObserver, NodeObjectLoader, NodeShaderStage, NodeType, NodeUniform, NodeUpdateType, NodeUtils, NodeVar, NodeVarying, NormalBlending, NormalMapNode, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, Object3D, Object3DNode, ObjectLoader, ObjectSpaceNormalMap, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, OutputStructNode, PCFShadowMap, PMREMGenerator, PMREMNode, ParameterNode, PassNode, PerspectiveCamera, PhongLightingModel, PhysicalLightingModel, Plane, PointLight, PointLightNode, PointUVNode, PointsMaterial, PointsNodeMaterial, PostProcessing, PostProcessingUtils, PosterizeNode, PropertyNode, QuadMesh, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBFormat, RGBIntegerFormat, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RTTNode, RangeNode, RectAreaLight, RectAreaLightNode, RedFormat, RedIntegerFormat, ReferenceNode, ReflectorNode, ReinhardToneMapping, RemapNode, RenderOutputNode, RenderTarget, RendererReferenceNode, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RotateNode, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, SceneNode, ScreenNode, ScriptableNode, ScriptableValueNode, SetNode, ShadowMaterial, ShadowNode, ShadowNodeMaterial, ShortType, SkinningNode, SphereGeometry, SplitNode, SpotLight, SpotLightNode, SpriteMaterial, SpriteNodeMaterial, SpriteSheetUVNode, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StackNode, StaticDrawUsage, StorageArrayElementNode, StorageBufferAttribute, StorageBufferNode, StorageInstancedBufferAttribute, StorageTexture, StorageTextureNode, SubtractEquation, SubtractiveBlending, TSL, TangentSpaceNormalMap, TempNode, Texture, Texture3DNode, TextureNode, TextureSizeNode, ToneMappingNode, ToonOutlinePassNode, TriplanarTexturesNode, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, UniformArrayNode, UniformGroupNode, UniformNode, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, UserDataNode, VSMShadowMap, VarNode, VaryingNode, Vector2, Vector3, Vector4, VertexColorNode, ViewportDepthNode, ViewportDepthTextureNode, ViewportSharedTextureNode, ViewportTextureNode, VolumeNodeMaterial, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGPUCoordinateSystem, WebGPURenderer, ZeroFactor, ZeroStencilOp, createCanvasElement, defaultBuildStages, defaultShaderStages, shaderStages, vectorComponents };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}