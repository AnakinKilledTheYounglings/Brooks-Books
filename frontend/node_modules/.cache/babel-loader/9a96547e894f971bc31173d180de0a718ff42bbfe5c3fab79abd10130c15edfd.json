{"ast":null,"code":"/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nimport { Color, Vector2, Vector3, Vector4, Matrix3, Matrix4, EventDispatcher, MathUtils, ColorManagement, SRGBTransfer, NoToneMapping, StaticDrawUsage, InterleavedBuffer, DynamicDrawUsage, InterleavedBufferAttribute, NoColorSpace, UnsignedIntType, IntType, WebGLCoordinateSystem, BackSide, CubeReflectionMapping, CubeRefractionMapping, WebGPUCoordinateSystem, TangentSpaceNormalMap, ObjectSpaceNormalMap, InstancedInterleavedBuffer, InstancedBufferAttribute, DataArrayTexture, FloatType, FramebufferTexture, LinearMipmapLinearFilter, DepthTexture, Material, NormalBlending, PointsMaterial, LineBasicMaterial, LineDashedMaterial, NoBlending, MeshNormalMaterial, WebGLCubeRenderTarget, BoxGeometry, Mesh, Scene, LinearFilter, CubeCamera, CubeTexture, EquirectangularReflectionMapping, EquirectangularRefractionMapping, AddOperation, MixOperation, MultiplyOperation, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, Texture, MeshStandardMaterial, MeshPhysicalMaterial, MeshToonMaterial, MeshMatcapMaterial, SpriteMaterial, ShadowMaterial, Uint32BufferAttribute, Uint16BufferAttribute, DoubleSide, DepthStencilFormat, DepthFormat, UnsignedInt248Type, UnsignedByteType, RenderTarget, Plane, Object3D, HalfFloatType, LinearMipMapLinearFilter, OrthographicCamera, BufferGeometry, Float32BufferAttribute, BufferAttribute, UVMapping, Euler, LinearSRGBColorSpace, LessCompare, VSMShadowMap, RGFormat, BasicShadowMap, SphereGeometry, CubeUVReflectionMapping, PerspectiveCamera, RGBAFormat, LinearMipmapNearestFilter, NearestMipmapLinearFilter, Float16BufferAttribute, REVISION, SRGBColorSpace, PCFShadowMap, FrontSide, Frustum, DataTexture, RedIntegerFormat, RedFormat, RGIntegerFormat, RGBIntegerFormat, RGBFormat, RGBAIntegerFormat, UnsignedShortType, ByteType, ShortType, createCanvasElement, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, SrcAlphaFactor, SrcAlphaSaturateFactor, DstColorFactor, DstAlphaFactor, OneMinusSrcColorFactor, OneMinusSrcAlphaFactor, OneMinusDstColorFactor, OneMinusDstAlphaFactor, CullFaceNone, CullFaceBack, CullFaceFront, CustomBlending, MultiplyBlending, SubtractiveBlending, AdditiveBlending, NotEqualDepth, GreaterDepth, GreaterEqualDepth, EqualDepth, LessEqualDepth, LessDepth, AlwaysDepth, NeverDepth, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt5999Type, AlphaFormat, LuminanceFormat, LuminanceAlphaFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, RED_RGTC1_Format, SIGNED_RED_RGTC1_Format, RED_GREEN_RGTC2_Format, SIGNED_RED_GREEN_RGTC2_Format, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NeverCompare, AlwaysCompare, LessEqualCompare, EqualCompare, GreaterEqualCompare, GreaterCompare, NotEqualCompare, warnOnce, NotEqualStencilFunc, GreaterStencilFunc, GreaterEqualStencilFunc, EqualStencilFunc, LessEqualStencilFunc, LessStencilFunc, AlwaysStencilFunc, NeverStencilFunc, DecrementWrapStencilOp, IncrementWrapStencilOp, DecrementStencilOp, IncrementStencilOp, InvertStencilOp, ReplaceStencilOp, ZeroStencilOp, KeepStencilOp, MaxEquation, MinEquation, SpotLight, PointLight, DirectionalLight, RectAreaLight, AmbientLight, HemisphereLight, LightProbe, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, AgXToneMapping, NeutralToneMapping, Group, Loader, FileLoader, MaterialLoader, ObjectLoader } from './three.core.js';\nexport { AdditiveAnimationBlendMode, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BasicDepthPacking, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxHelper, BufferGeometryLoader, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CircleGeometry, Clock, ColorKeyframeTrack, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeTextureLoader, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceFrontBack, Curve, CurvePath, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataTextureLoader, DataUtils, DefaultLoadingManager, DetachedBindMode, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DynamicCopyUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, ExtrudeGeometry, Fog, FogExp2, GLBufferAttribute, GLSL1, GLSL3, GridHelper, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, InstancedBufferGeometry, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, KeyframeTrack, LOD, LatheGeometry, Layers, Light, Line, Line3, LineCurve, LineCurve3, LineLoop, LineSegments, LinearInterpolant, LinearMipMapNearestFilter, LinearTransfer, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, MOUSE, Matrix2, MeshDepthMaterial, MeshDistanceMaterial, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NormalAnimationBlendMode, NumberKeyframeTrack, OctahedronGeometry, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, PCFSoftShadowMap, Path, PlaneGeometry, PlaneHelper, PointLightHelper, Points, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RGBADepthPacking, RGBDepthPacking, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGDepthPacking, RawShaderMaterial, Ray, Raycaster, RingGeometry, ShaderMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, Spherical, SphericalHarmonics3, SplineCurve, SpotLightHelper, Sprite, StaticCopyUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, TOUCH, TetrahedronGeometry, TextureLoader, TextureUtils, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, VectorKeyframeTrack, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLMultipleRenderTargets, WebGLRenderTarget, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding } from './three.core.js';\nconst refreshUniforms = ['alphaMap', 'alphaTest', 'anisotropy', 'anisotropyMap', 'anisotropyRotation', 'aoMap', 'attenuationColor', 'attenuationDistance', 'bumpMap', 'clearcoat', 'clearcoatMap', 'clearcoatNormalMap', 'clearcoatNormalScale', 'clearcoatRoughness', 'color', 'dispersion', 'displacementMap', 'emissive', 'emissiveMap', 'envMap', 'gradientMap', 'ior', 'iridescence', 'iridescenceIOR', 'iridescenceMap', 'iridescenceThicknessMap', 'lightMap', 'map', 'matcap', 'metalness', 'metalnessMap', 'normalMap', 'normalScale', 'opacity', 'roughness', 'roughnessMap', 'sheen', 'sheenColor', 'sheenColorMap', 'sheenRoughnessMap', 'shininess', 'specular', 'specularColor', 'specularColorMap', 'specularIntensity', 'specularIntensityMap', 'specularMap', 'thickness', 'transmission', 'transmissionMap'];\nclass NodeMaterialObserver {\n  constructor(builder) {\n    this.renderObjects = new WeakMap();\n    this.hasNode = this.containsNode(builder);\n    this.hasAnimation = builder.object.isSkinnedMesh === true;\n    this.refreshUniforms = refreshUniforms;\n    this.renderId = 0;\n  }\n  firstInitialization(renderObject) {\n    const hasInitialized = this.renderObjects.has(renderObject);\n    if (hasInitialized === false) {\n      this.getRenderObjectData(renderObject);\n      return true;\n    }\n    return false;\n  }\n  getRenderObjectData(renderObject) {\n    let data = this.renderObjects.get(renderObject);\n    if (data === undefined) {\n      const {\n        geometry,\n        material,\n        object\n      } = renderObject;\n      data = {\n        material: this.getMaterialData(material),\n        geometry: {\n          attributes: this.getAttributesData(geometry.attributes),\n          indexVersion: geometry.index ? geometry.index.version : null,\n          drawRange: {\n            start: geometry.drawRange.start,\n            count: geometry.drawRange.count\n          }\n        },\n        worldMatrix: object.matrixWorld.clone()\n      };\n      if (object.center) {\n        data.center = object.center.clone();\n      }\n      if (object.morphTargetInfluences) {\n        data.morphTargetInfluences = object.morphTargetInfluences.slice();\n      }\n      if (renderObject.bundle !== null) {\n        data.version = renderObject.bundle.version;\n      }\n      if (data.material.transmission > 0) {\n        const {\n          width,\n          height\n        } = renderObject.context;\n        data.bufferWidth = width;\n        data.bufferHeight = height;\n      }\n      this.renderObjects.set(renderObject, data);\n    }\n    return data;\n  }\n  getAttributesData(attributes) {\n    const attributesData = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      attributesData[name] = {\n        version: attribute.version\n      };\n    }\n    return attributesData;\n  }\n  containsNode(builder) {\n    const material = builder.material;\n    for (const property in material) {\n      if (material[property] && material[property].isNode) return true;\n    }\n    if (builder.renderer.nodes.modelViewMatrix !== null || builder.renderer.nodes.modelNormalViewMatrix !== null) return true;\n    return false;\n  }\n  getMaterialData(material) {\n    const data = {};\n    for (const property of this.refreshUniforms) {\n      const value = material[property];\n      if (value === null || value === undefined) continue;\n      if (typeof value === 'object' && value.clone !== undefined) {\n        if (value.isTexture === true) {\n          data[property] = {\n            id: value.id,\n            version: value.version\n          };\n        } else {\n          data[property] = value.clone();\n        }\n      } else {\n        data[property] = value;\n      }\n    }\n    return data;\n  }\n  equals(renderObject) {\n    const {\n      object,\n      material,\n      geometry\n    } = renderObject;\n    const renderObjectData = this.getRenderObjectData(renderObject);\n\n    // world matrix\n\n    if (renderObjectData.worldMatrix.equals(object.matrixWorld) !== true) {\n      renderObjectData.worldMatrix.copy(object.matrixWorld);\n      return false;\n    }\n\n    // material\n\n    const materialData = renderObjectData.material;\n    for (const property in materialData) {\n      const value = materialData[property];\n      const mtlValue = material[property];\n      if (value.equals !== undefined) {\n        if (value.equals(mtlValue) === false) {\n          value.copy(mtlValue);\n          return false;\n        }\n      } else if (mtlValue.isTexture === true) {\n        if (value.id !== mtlValue.id || value.version !== mtlValue.version) {\n          value.id = mtlValue.id;\n          value.version = mtlValue.version;\n          return false;\n        }\n      } else if (value !== mtlValue) {\n        materialData[property] = mtlValue;\n        return false;\n      }\n    }\n    if (materialData.transmission > 0) {\n      const {\n        width,\n        height\n      } = renderObject.context;\n      if (renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height) {\n        renderObjectData.bufferWidth = width;\n        renderObjectData.bufferHeight = height;\n        return false;\n      }\n    }\n\n    // geometry\n\n    const storedGeometryData = renderObjectData.geometry;\n    const attributes = geometry.attributes;\n    const storedAttributes = storedGeometryData.attributes;\n    const storedAttributeNames = Object.keys(storedAttributes);\n    const currentAttributeNames = Object.keys(attributes);\n    if (storedAttributeNames.length !== currentAttributeNames.length) {\n      renderObjectData.geometry.attributes = this.getAttributesData(attributes);\n      return false;\n    }\n\n    // compare each attribute\n\n    for (const name of storedAttributeNames) {\n      const storedAttributeData = storedAttributes[name];\n      const attribute = attributes[name];\n      if (attribute === undefined) {\n        // attribute was removed\n        delete storedAttributes[name];\n        return false;\n      }\n      if (storedAttributeData.version !== attribute.version) {\n        storedAttributeData.version = attribute.version;\n        return false;\n      }\n    }\n\n    // check index\n\n    const index = geometry.index;\n    const storedIndexVersion = storedGeometryData.indexVersion;\n    const currentIndexVersion = index ? index.version : null;\n    if (storedIndexVersion !== currentIndexVersion) {\n      storedGeometryData.indexVersion = currentIndexVersion;\n      return false;\n    }\n\n    // check drawRange\n\n    if (storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count) {\n      storedGeometryData.drawRange.start = geometry.drawRange.start;\n      storedGeometryData.drawRange.count = geometry.drawRange.count;\n      return false;\n    }\n\n    // morph targets\n\n    if (renderObjectData.morphTargetInfluences) {\n      let morphChanged = false;\n      for (let i = 0; i < renderObjectData.morphTargetInfluences.length; i++) {\n        if (renderObjectData.morphTargetInfluences[i] !== object.morphTargetInfluences[i]) {\n          morphChanged = true;\n        }\n      }\n      if (morphChanged) return true;\n    }\n\n    // center\n\n    if (renderObjectData.center) {\n      if (renderObjectData.center.equals(object.center) === false) {\n        renderObjectData.center.copy(object.center);\n        return true;\n      }\n    }\n\n    // bundle\n\n    if (renderObject.bundle !== null) {\n      renderObjectData.version = renderObject.bundle.version;\n    }\n    return true;\n  }\n  needsRefresh(renderObject, nodeFrame) {\n    if (this.hasNode || this.hasAnimation || this.firstInitialization(renderObject)) return true;\n    const {\n      renderId\n    } = nodeFrame;\n    if (this.renderId !== renderId) {\n      this.renderId = renderId;\n      return true;\n    }\n    const isStatic = renderObject.object.static === true;\n    const isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData(renderObject).version === renderObject.bundle.version;\n    if (isStatic || isBundle) return false;\n    const notEqual = this.equals(renderObject) !== true;\n    return notEqual;\n  }\n}\n\n// cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.\n// A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.\n// Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.\n// See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480\n// https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\nfunction cyrb53(value, seed = 0) {\n  let h1 = 0xdeadbeef ^ seed,\n    h2 = 0x41c6ce57 ^ seed;\n  if (value instanceof Array) {\n    for (let i = 0, val; i < value.length; i++) {\n      val = value[i];\n      h1 = Math.imul(h1 ^ val, 2654435761);\n      h2 = Math.imul(h2 ^ val, 1597334677);\n    }\n  } else {\n    for (let i = 0, ch; i < value.length; i++) {\n      ch = value.charCodeAt(i);\n      h1 = Math.imul(h1 ^ ch, 2654435761);\n      h2 = Math.imul(h2 ^ ch, 1597334677);\n    }\n  }\n  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);\n  h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);\n  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);\n  h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);\n  return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n}\nconst hashString = str => cyrb53(str);\nconst hashArray = array => cyrb53(array);\nconst hash$1 = (...params) => cyrb53(params);\nfunction getCacheKey$1(object, force = false) {\n  const values = [];\n  if (object.isNode === true) {\n    values.push(object.id);\n    object = object.getSelf();\n  }\n  for (const {\n    property,\n    childNode\n  } of getNodeChildren(object)) {\n    values.push(values, cyrb53(property.slice(0, -4)), childNode.getCacheKey(force));\n  }\n  return cyrb53(values);\n}\nfunction* getNodeChildren(node, toJSON = false) {\n  for (const property in node) {\n    // Ignore private properties.\n    if (property.startsWith('_') === true) continue;\n    const object = node[property];\n    if (Array.isArray(object) === true) {\n      for (let i = 0; i < object.length; i++) {\n        const child = object[i];\n        if (child && (child.isNode === true || toJSON && typeof child.toJSON === 'function')) {\n          yield {\n            property,\n            index: i,\n            childNode: child\n          };\n        }\n      }\n    } else if (object && object.isNode === true) {\n      yield {\n        property,\n        childNode: object\n      };\n    } else if (typeof object === 'object') {\n      for (const subProperty in object) {\n        const child = object[subProperty];\n        if (child && (child.isNode === true || toJSON && typeof child.toJSON === 'function')) {\n          yield {\n            property,\n            index: subProperty,\n            childNode: child\n          };\n        }\n      }\n    }\n  }\n}\nconst typeFromLength = /*@__PURE__*/new Map([[1, 'float'], [2, 'vec2'], [3, 'vec3'], [4, 'vec4'], [9, 'mat3'], [16, 'mat4']]);\nfunction getTypeFromLength(length) {\n  return typeFromLength.get(length);\n}\nfunction getLengthFromType(type) {\n  if (/float|int|uint/.test(type)) return 1;\n  if (/vec2/.test(type)) return 2;\n  if (/vec3/.test(type)) return 3;\n  if (/vec4/.test(type)) return 4;\n  if (/mat3/.test(type)) return 9;\n  if (/mat4/.test(type)) return 16;\n  console.error('THREE.TSL: Unsupported type:', type);\n}\nfunction getValueType(value) {\n  if (value === undefined || value === null) return null;\n  const typeOf = typeof value;\n  if (value.isNode === true) {\n    return 'node';\n  } else if (typeOf === 'number') {\n    return 'float';\n  } else if (typeOf === 'boolean') {\n    return 'bool';\n  } else if (typeOf === 'string') {\n    return 'string';\n  } else if (typeOf === 'function') {\n    return 'shader';\n  } else if (value.isVector2 === true) {\n    return 'vec2';\n  } else if (value.isVector3 === true) {\n    return 'vec3';\n  } else if (value.isVector4 === true) {\n    return 'vec4';\n  } else if (value.isMatrix3 === true) {\n    return 'mat3';\n  } else if (value.isMatrix4 === true) {\n    return 'mat4';\n  } else if (value.isColor === true) {\n    return 'color';\n  } else if (value instanceof ArrayBuffer) {\n    return 'ArrayBuffer';\n  }\n  return null;\n}\nfunction getValueFromType(type, ...params) {\n  const last4 = type ? type.slice(-4) : undefined;\n  if (params.length === 1) {\n    // ensure same behaviour as in NodeBuilder.format()\n\n    if (last4 === 'vec2') params = [params[0], params[0]];else if (last4 === 'vec3') params = [params[0], params[0], params[0]];else if (last4 === 'vec4') params = [params[0], params[0], params[0], params[0]];\n  }\n  if (type === 'color') {\n    return new Color(...params);\n  } else if (last4 === 'vec2') {\n    return new Vector2(...params);\n  } else if (last4 === 'vec3') {\n    return new Vector3(...params);\n  } else if (last4 === 'vec4') {\n    return new Vector4(...params);\n  } else if (last4 === 'mat3') {\n    return new Matrix3(...params);\n  } else if (last4 === 'mat4') {\n    return new Matrix4(...params);\n  } else if (type === 'bool') {\n    return params[0] || false;\n  } else if (type === 'float' || type === 'int' || type === 'uint') {\n    return params[0] || 0;\n  } else if (type === 'string') {\n    return params[0] || '';\n  } else if (type === 'ArrayBuffer') {\n    return base64ToArrayBuffer(params[0]);\n  }\n  return null;\n}\nfunction arrayBufferToBase64(arrayBuffer) {\n  let chars = '';\n  const array = new Uint8Array(arrayBuffer);\n  for (let i = 0; i < array.length; i++) {\n    chars += String.fromCharCode(array[i]);\n  }\n  return btoa(chars);\n}\nfunction base64ToArrayBuffer(base64) {\n  return Uint8Array.from(atob(base64), c => c.charCodeAt(0)).buffer;\n}\nvar NodeUtils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  arrayBufferToBase64: arrayBufferToBase64,\n  base64ToArrayBuffer: base64ToArrayBuffer,\n  getCacheKey: getCacheKey$1,\n  getLengthFromType: getLengthFromType,\n  getNodeChildren: getNodeChildren,\n  getTypeFromLength: getTypeFromLength,\n  getValueFromType: getValueFromType,\n  getValueType: getValueType,\n  hash: hash$1,\n  hashArray: hashArray,\n  hashString: hashString\n});\nconst NodeShaderStage = {\n  VERTEX: 'vertex',\n  FRAGMENT: 'fragment'\n};\nconst NodeUpdateType = {\n  NONE: 'none',\n  FRAME: 'frame',\n  RENDER: 'render',\n  OBJECT: 'object'\n};\nconst NodeType = {\n  BOOLEAN: 'bool',\n  INTEGER: 'int',\n  FLOAT: 'float',\n  VECTOR2: 'vec2',\n  VECTOR3: 'vec3',\n  VECTOR4: 'vec4',\n  MATRIX2: 'mat2',\n  MATRIX3: 'mat3',\n  MATRIX4: 'mat4'\n};\nconst NodeAccess = {\n  READ_ONLY: 'readOnly',\n  WRITE_ONLY: 'writeOnly',\n  READ_WRITE: 'readWrite'\n};\nconst defaultShaderStages = ['fragment', 'vertex'];\nconst defaultBuildStages = ['setup', 'analyze', 'generate'];\nconst shaderStages = [...defaultShaderStages, 'compute'];\nconst vectorComponents = ['x', 'y', 'z', 'w'];\nlet _nodeId = 0;\nclass Node extends EventDispatcher {\n  static get type() {\n    return 'Node';\n  }\n  constructor(nodeType = null) {\n    super();\n    this.nodeType = nodeType;\n    this.updateType = NodeUpdateType.NONE;\n    this.updateBeforeType = NodeUpdateType.NONE;\n    this.updateAfterType = NodeUpdateType.NONE;\n    this.uuid = MathUtils.generateUUID();\n    this.version = 0;\n    this._cacheKey = null;\n    this._cacheKeyVersion = 0;\n    this.global = false;\n    this.isNode = true;\n    Object.defineProperty(this, 'id', {\n      value: _nodeId++\n    });\n  }\n  set needsUpdate(value) {\n    if (value === true) {\n      this.version++;\n    }\n  }\n  get type() {\n    return this.constructor.type;\n  }\n  onUpdate(callback, updateType) {\n    this.updateType = updateType;\n    this.update = callback.bind(this.getSelf());\n    return this;\n  }\n  onFrameUpdate(callback) {\n    return this.onUpdate(callback, NodeUpdateType.FRAME);\n  }\n  onRenderUpdate(callback) {\n    return this.onUpdate(callback, NodeUpdateType.RENDER);\n  }\n  onObjectUpdate(callback) {\n    return this.onUpdate(callback, NodeUpdateType.OBJECT);\n  }\n  onReference(callback) {\n    this.updateReference = callback.bind(this.getSelf());\n    return this;\n  }\n  getSelf() {\n    // Returns non-node object.\n\n    return this.self || this;\n  }\n  updateReference(/*state*/\n  ) {\n    return this;\n  }\n  isGlobal(/*builder*/\n  ) {\n    return this.global;\n  }\n  *getChildren() {\n    for (const {\n      childNode\n    } of getNodeChildren(this)) {\n      yield childNode;\n    }\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n  traverse(callback) {\n    callback(this);\n    for (const childNode of this.getChildren()) {\n      childNode.traverse(callback);\n    }\n  }\n  getCacheKey(force = false) {\n    force = force || this.version !== this._cacheKeyVersion;\n    if (force === true || this._cacheKey === null) {\n      this._cacheKey = getCacheKey$1(this, force);\n      this._cacheKeyVersion = this.version;\n    }\n    return this._cacheKey;\n  }\n  getScope() {\n    return this;\n  }\n  getHash(/*builder*/\n  ) {\n    return this.uuid;\n  }\n  getUpdateType() {\n    return this.updateType;\n  }\n  getUpdateBeforeType() {\n    return this.updateBeforeType;\n  }\n  getUpdateAfterType() {\n    return this.updateAfterType;\n  }\n  getElementType(builder) {\n    const type = this.getNodeType(builder);\n    const elementType = builder.getElementType(type);\n    return elementType;\n  }\n  getNodeType(builder) {\n    const nodeProperties = builder.getNodeProperties(this);\n    if (nodeProperties.outputNode) {\n      return nodeProperties.outputNode.getNodeType(builder);\n    }\n    return this.nodeType;\n  }\n  getShared(builder) {\n    const hash = this.getHash(builder);\n    const nodeFromHash = builder.getNodeFromHash(hash);\n    return nodeFromHash || this;\n  }\n  setup(builder) {\n    const nodeProperties = builder.getNodeProperties(this);\n    let index = 0;\n    for (const childNode of this.getChildren()) {\n      nodeProperties['node' + index++] = childNode;\n    }\n\n    // return a outputNode if exists\n    return null;\n  }\n  analyze(builder) {\n    const usageCount = builder.increaseUsage(this);\n    if (usageCount === 1) {\n      // node flow children\n\n      const nodeProperties = builder.getNodeProperties(this);\n      for (const childNode of Object.values(nodeProperties)) {\n        if (childNode && childNode.isNode === true) {\n          childNode.build(builder);\n        }\n      }\n    }\n  }\n  generate(builder, output) {\n    const {\n      outputNode\n    } = builder.getNodeProperties(this);\n    if (outputNode && outputNode.isNode === true) {\n      return outputNode.build(builder, output);\n    }\n  }\n  updateBefore(/*frame*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  updateAfter(/*frame*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  update(/*frame*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  build(builder, output = null) {\n    const refNode = this.getShared(builder);\n    if (this !== refNode) {\n      return refNode.build(builder, output);\n    }\n    builder.addNode(this);\n    builder.addChain(this);\n\n    /* Build stages expected results:\n    \t- \"setup\"\t\t-> Node\n    \t- \"analyze\"\t\t-> null\n    \t- \"generate\"\t-> String\n    */\n    let result = null;\n    const buildStage = builder.getBuildStage();\n    if (buildStage === 'setup') {\n      this.updateReference(builder);\n      const properties = builder.getNodeProperties(this);\n      if (properties.initialized !== true) {\n        const stackNodesBeforeSetup = builder.stack.nodes.length;\n        properties.initialized = true;\n        properties.outputNode = this.setup(builder);\n        if (properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeSetup) ;\n        for (const childNode of Object.values(properties)) {\n          if (childNode && childNode.isNode === true) {\n            childNode.build(builder);\n          }\n        }\n      }\n    } else if (buildStage === 'analyze') {\n      this.analyze(builder);\n    } else if (buildStage === 'generate') {\n      const isGenerateOnce = this.generate.length === 1;\n      if (isGenerateOnce) {\n        const type = this.getNodeType(builder);\n        const nodeData = builder.getDataFromNode(this);\n        result = nodeData.snippet;\n        if (result === undefined) {\n          result = this.generate(builder) || '';\n          nodeData.snippet = result;\n        } else if (nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined) {\n          builder.addFlowCodeHierarchy(this, builder.context.nodeBlock);\n        }\n        result = builder.format(result, type, output);\n      } else {\n        result = this.generate(builder, output) || '';\n      }\n    }\n    builder.removeChain(this);\n    builder.addSequentialNode(this);\n    return result;\n  }\n  getSerializeChildren() {\n    return getNodeChildren(this);\n  }\n  serialize(json) {\n    const nodeChildren = this.getSerializeChildren();\n    const inputNodes = {};\n    for (const {\n      property,\n      index,\n      childNode\n    } of nodeChildren) {\n      if (index !== undefined) {\n        if (inputNodes[property] === undefined) {\n          inputNodes[property] = Number.isInteger(index) ? [] : {};\n        }\n        inputNodes[property][index] = childNode.toJSON(json.meta).uuid;\n      } else {\n        inputNodes[property] = childNode.toJSON(json.meta).uuid;\n      }\n    }\n    if (Object.keys(inputNodes).length > 0) {\n      json.inputNodes = inputNodes;\n    }\n  }\n  deserialize(json) {\n    if (json.inputNodes !== undefined) {\n      const nodes = json.meta.nodes;\n      for (const property in json.inputNodes) {\n        if (Array.isArray(json.inputNodes[property])) {\n          const inputArray = [];\n          for (const uuid of json.inputNodes[property]) {\n            inputArray.push(nodes[uuid]);\n          }\n          this[property] = inputArray;\n        } else if (typeof json.inputNodes[property] === 'object') {\n          const inputObject = {};\n          for (const subProperty in json.inputNodes[property]) {\n            const uuid = json.inputNodes[property][subProperty];\n            inputObject[subProperty] = nodes[uuid];\n          }\n          this[property] = inputObject;\n        } else {\n          const uuid = json.inputNodes[property];\n          this[property] = nodes[uuid];\n        }\n      }\n    }\n  }\n  toJSON(meta) {\n    const {\n      uuid,\n      type\n    } = this;\n    const isRoot = meta === undefined || typeof meta === 'string';\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n\n    // serialize\n\n    let data = meta.nodes[uuid];\n    if (data === undefined) {\n      data = {\n        uuid,\n        type,\n        meta,\n        metadata: {\n          version: 4.6,\n          type: 'Node',\n          generator: 'Node.toJSON'\n        }\n      };\n      if (isRoot !== true) meta.nodes[data.uuid] = data;\n      this.serialize(data);\n      delete data.meta;\n    }\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n}\nclass ArrayElementNode extends Node {\n  static get type() {\n    return 'ArrayElementNode';\n  } // @TODO: If extending from TempNode it breaks webgpu_compute\n\n  constructor(node, indexNode) {\n    super();\n    this.node = node;\n    this.indexNode = indexNode;\n    this.isArrayElementNode = true;\n  }\n  getNodeType(builder) {\n    return this.node.getElementType(builder);\n  }\n  generate(builder) {\n    const nodeSnippet = this.node.build(builder);\n    const indexSnippet = this.indexNode.build(builder, 'uint');\n    return `${nodeSnippet}[ ${indexSnippet} ]`;\n  }\n}\nclass ConvertNode extends Node {\n  static get type() {\n    return 'ConvertNode';\n  }\n  constructor(node, convertTo) {\n    super();\n    this.node = node;\n    this.convertTo = convertTo;\n  }\n  getNodeType(builder) {\n    const requestType = this.node.getNodeType(builder);\n    let convertTo = null;\n    for (const overloadingType of this.convertTo.split('|')) {\n      if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {\n        convertTo = overloadingType;\n      }\n    }\n    return convertTo;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.convertTo = this.convertTo;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.convertTo = data.convertTo;\n  }\n  generate(builder, output) {\n    const node = this.node;\n    const type = this.getNodeType(builder);\n    const snippet = node.build(builder, type);\n    return builder.format(snippet, type, output);\n  }\n}\nclass TempNode extends Node {\n  static get type() {\n    return 'TempNode';\n  }\n  constructor(type) {\n    super(type);\n    this.isTempNode = true;\n  }\n  hasDependencies(builder) {\n    return builder.getDataFromNode(this).usageCount > 1;\n  }\n  build(builder, output) {\n    const buildStage = builder.getBuildStage();\n    if (buildStage === 'generate') {\n      const type = builder.getVectorType(this.getNodeType(builder, output));\n      const nodeData = builder.getDataFromNode(this);\n      if (nodeData.propertyName !== undefined) {\n        return builder.format(nodeData.propertyName, type, output);\n      } else if (type !== 'void' && output !== 'void' && this.hasDependencies(builder)) {\n        const snippet = super.build(builder, type);\n        const nodeVar = builder.getVarFromNode(this, null, type);\n        const propertyName = builder.getPropertyName(nodeVar);\n        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);\n        nodeData.snippet = snippet;\n        nodeData.propertyName = propertyName;\n        return builder.format(nodeData.propertyName, type, output);\n      }\n    }\n    return super.build(builder, output);\n  }\n}\nclass JoinNode extends TempNode {\n  static get type() {\n    return 'JoinNode';\n  }\n  constructor(nodes = [], nodeType = null) {\n    super(nodeType);\n    this.nodes = nodes;\n  }\n  getNodeType(builder) {\n    if (this.nodeType !== null) {\n      return builder.getVectorType(this.nodeType);\n    }\n    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    const nodes = this.nodes;\n    const primitiveType = builder.getComponentType(type);\n    const snippetValues = [];\n    for (const input of nodes) {\n      let inputSnippet = input.build(builder);\n      const inputPrimitiveType = builder.getComponentType(input.getNodeType(builder));\n      if (inputPrimitiveType !== primitiveType) {\n        inputSnippet = builder.format(inputSnippet, inputPrimitiveType, primitiveType);\n      }\n      snippetValues.push(inputSnippet);\n    }\n    const snippet = `${builder.getType(type)}( ${snippetValues.join(', ')} )`;\n    return builder.format(snippet, type, output);\n  }\n}\nconst stringVectorComponents = vectorComponents.join('');\nclass SplitNode extends Node {\n  static get type() {\n    return 'SplitNode';\n  }\n  constructor(node, components = 'x') {\n    super();\n    this.node = node;\n    this.components = components;\n    this.isSplitNode = true;\n  }\n  getVectorLength() {\n    let vectorLength = this.components.length;\n    for (const c of this.components) {\n      vectorLength = Math.max(vectorComponents.indexOf(c) + 1, vectorLength);\n    }\n    return vectorLength;\n  }\n  getComponentType(builder) {\n    return builder.getComponentType(this.node.getNodeType(builder));\n  }\n  getNodeType(builder) {\n    return builder.getTypeFromLength(this.components.length, this.getComponentType(builder));\n  }\n  generate(builder, output) {\n    const node = this.node;\n    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));\n    let snippet = null;\n    if (nodeTypeLength > 1) {\n      let type = null;\n      const componentsLength = this.getVectorLength();\n      if (componentsLength >= nodeTypeLength) {\n        // needed expand the input node\n\n        type = builder.getTypeFromLength(this.getVectorLength(), this.getComponentType(builder));\n      }\n      const nodeSnippet = node.build(builder, type);\n      if (this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice(0, this.components.length)) {\n        // unnecessary swizzle\n\n        snippet = builder.format(nodeSnippet, type, output);\n      } else {\n        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output);\n      }\n    } else {\n      // ignore .components if .node returns float/integer\n\n      snippet = node.build(builder, output);\n    }\n    return snippet;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.components = this.components;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.components = data.components;\n  }\n}\nclass SetNode extends TempNode {\n  static get type() {\n    return 'SetNode';\n  }\n  constructor(sourceNode, components, targetNode) {\n    super();\n    this.sourceNode = sourceNode;\n    this.components = components;\n    this.targetNode = targetNode;\n  }\n  getNodeType(builder) {\n    return this.sourceNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const {\n      sourceNode,\n      components,\n      targetNode\n    } = this;\n    const sourceType = this.getNodeType(builder);\n    const targetType = builder.getTypeFromLength(components.length, targetNode.getNodeType(builder));\n    const targetSnippet = targetNode.build(builder, targetType);\n    const sourceSnippet = sourceNode.build(builder, sourceType);\n    const length = builder.getTypeLength(sourceType);\n    const snippetValues = [];\n    for (let i = 0; i < length; i++) {\n      const component = vectorComponents[i];\n      if (component === components[0]) {\n        snippetValues.push(targetSnippet);\n        i += components.length - 1;\n      } else {\n        snippetValues.push(sourceSnippet + '.' + component);\n      }\n    }\n    return `${builder.getType(sourceType)}( ${snippetValues.join(', ')} )`;\n  }\n}\nclass FlipNode extends TempNode {\n  static get type() {\n    return 'FlipNode';\n  }\n  constructor(sourceNode, components) {\n    super();\n    this.sourceNode = sourceNode;\n    this.components = components;\n  }\n  getNodeType(builder) {\n    return this.sourceNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const {\n      components,\n      sourceNode\n    } = this;\n    const sourceType = this.getNodeType(builder);\n    const sourceSnippet = sourceNode.build(builder);\n    const sourceCache = builder.getVarFromNode(this);\n    const sourceProperty = builder.getPropertyName(sourceCache);\n    builder.addLineFlowCode(sourceProperty + ' = ' + sourceSnippet, this);\n    const length = builder.getTypeLength(sourceType);\n    const snippetValues = [];\n    let componentIndex = 0;\n    for (let i = 0; i < length; i++) {\n      const component = vectorComponents[i];\n      if (component === components[componentIndex]) {\n        snippetValues.push('1.0 - ' + (sourceProperty + '.' + component));\n        componentIndex++;\n      } else {\n        snippetValues.push(sourceProperty + '.' + component);\n      }\n    }\n    return `${builder.getType(sourceType)}( ${snippetValues.join(', ')} )`;\n  }\n}\nclass InputNode extends Node {\n  static get type() {\n    return 'InputNode';\n  }\n  constructor(value, nodeType = null) {\n    super(nodeType);\n    this.isInputNode = true;\n    this.value = value;\n    this.precision = null;\n  }\n  getNodeType(/*builder*/\n  ) {\n    if (this.nodeType === null) {\n      return getValueType(this.value);\n    }\n    return this.nodeType;\n  }\n  getInputType(builder) {\n    return this.getNodeType(builder);\n  }\n  setPrecision(precision) {\n    this.precision = precision;\n    return this;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.value = this.value;\n    if (this.value && this.value.toArray) data.value = this.value.toArray();\n    data.valueType = getValueType(this.value);\n    data.nodeType = this.nodeType;\n    if (data.valueType === 'ArrayBuffer') data.value = arrayBufferToBase64(data.value);\n    data.precision = this.precision;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.nodeType = data.nodeType;\n    this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;\n    this.precision = data.precision || null;\n    if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);\n  }\n  generate(/*builder, output*/\n  ) {\n    console.warn('Abstract function.');\n  }\n}\nclass ConstNode extends InputNode {\n  static get type() {\n    return 'ConstNode';\n  }\n  constructor(value, nodeType = null) {\n    super(value, nodeType);\n    this.isConstNode = true;\n  }\n  generateConst(builder) {\n    return builder.generateConst(this.getNodeType(builder), this.value);\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    return builder.format(this.generateConst(builder), type, output);\n  }\n}\n\n//\n\nlet currentStack = null;\nconst NodeElements = new Map();\nfunction addMethodChaining(name, nodeElement) {\n  if (NodeElements.has(name)) {\n    console.warn(`Redefinition of method chaining ${name}`);\n    return;\n  }\n  if (typeof nodeElement !== 'function') throw new Error(`Node element ${name} is not a function`);\n  NodeElements.set(name, nodeElement);\n}\nconst parseSwizzle = props => props.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\nconst parseSwizzleAndSort = props => parseSwizzle(props).split('').sort().join('');\nconst shaderNodeHandler = {\n  setup(NodeClosure, params) {\n    const inputs = params.shift();\n    return NodeClosure(nodeObjects(inputs), ...params);\n  },\n  get(node, prop, nodeObj) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (node.isStackNode !== true && prop === 'assign') {\n        return (...params) => {\n          currentStack.assign(nodeObj, ...params);\n          return nodeObj;\n        };\n      } else if (NodeElements.has(prop)) {\n        const nodeElement = NodeElements.get(prop);\n        return node.isStackNode ? (...params) => nodeObj.add(nodeElement(...params)) : (...params) => nodeElement(nodeObj, ...params);\n      } else if (prop === 'self') {\n        return node;\n      } else if (prop.endsWith('Assign') && NodeElements.has(prop.slice(0, prop.length - 'Assign'.length))) {\n        const nodeElement = NodeElements.get(prop.slice(0, prop.length - 'Assign'.length));\n        return node.isStackNode ? (...params) => nodeObj.assign(params[0], nodeElement(...params)) : (...params) => nodeObj.assign(nodeElement(nodeObj, ...params));\n      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n\n        prop = parseSwizzle(prop);\n        return nodeObject(new SplitNode(nodeObj, prop));\n      } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {\n        // set properties ( swizzle ) and sort to xyzw sequence\n\n        prop = parseSwizzleAndSort(prop.slice(3).toLowerCase());\n        return value => nodeObject(new SetNode(node, prop, value));\n      } else if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {\n        // set properties ( swizzle ) and sort to xyzw sequence\n\n        prop = parseSwizzleAndSort(prop.slice(4).toLowerCase());\n        return () => nodeObject(new FlipNode(nodeObject(node), prop));\n      } else if (prop === 'width' || prop === 'height' || prop === 'depth') {\n        // accessing property\n\n        if (prop === 'width') prop = 'x';else if (prop === 'height') prop = 'y';else if (prop === 'depth') prop = 'z';\n        return nodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n\n        return nodeObject(new ArrayElementNode(nodeObj, new ConstNode(Number(prop), 'uint')));\n      }\n    }\n    return Reflect.get(node, prop, nodeObj);\n  },\n  set(node, prop, value, nodeObj) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      // setting properties\n\n      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\\d+$/.test(prop) === true) {\n        nodeObj[prop].assign(value);\n        return true;\n      }\n    }\n    return Reflect.set(node, prop, value, nodeObj);\n  }\n};\nconst nodeObjectsCacheMap = new WeakMap();\nconst nodeBuilderFunctionsCacheMap = new WeakMap();\nconst ShaderNodeObject = function (obj, altType = null) {\n  const type = getValueType(obj);\n  if (type === 'node') {\n    let nodeObject = nodeObjectsCacheMap.get(obj);\n    if (nodeObject === undefined) {\n      nodeObject = new Proxy(obj, shaderNodeHandler);\n      nodeObjectsCacheMap.set(obj, nodeObject);\n      nodeObjectsCacheMap.set(nodeObject, nodeObject);\n    }\n    return nodeObject;\n  } else if (altType === null && (type === 'float' || type === 'boolean') || type && type !== 'shader' && type !== 'string') {\n    return nodeObject(getConstNode(obj, altType));\n  } else if (type === 'shader') {\n    return Fn(obj);\n  }\n  return obj;\n};\nconst ShaderNodeObjects = function (objects, altType = null) {\n  for (const name in objects) {\n    objects[name] = nodeObject(objects[name], altType);\n  }\n  return objects;\n};\nconst ShaderNodeArray = function (array, altType = null) {\n  const len = array.length;\n  for (let i = 0; i < len; i++) {\n    array[i] = nodeObject(array[i], altType);\n  }\n  return array;\n};\nconst ShaderNodeProxy = function (NodeClass, scope = null, factor = null, settings = null) {\n  const assignNode = node => nodeObject(settings !== null ? Object.assign(node, settings) : node);\n  if (scope === null) {\n    return (...params) => {\n      return assignNode(new NodeClass(...nodeArray(params)));\n    };\n  } else if (factor !== null) {\n    factor = nodeObject(factor);\n    return (...params) => {\n      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));\n    };\n  } else {\n    return (...params) => {\n      return assignNode(new NodeClass(scope, ...nodeArray(params)));\n    };\n  }\n};\nconst ShaderNodeImmutable = function (NodeClass, ...params) {\n  return nodeObject(new NodeClass(...nodeArray(params)));\n};\nclass ShaderCallNodeInternal extends Node {\n  constructor(shaderNode, inputNodes) {\n    super();\n    this.shaderNode = shaderNode;\n    this.inputNodes = inputNodes;\n  }\n  getNodeType(builder) {\n    return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);\n  }\n  call(builder) {\n    const {\n      shaderNode,\n      inputNodes\n    } = this;\n    const properties = builder.getNodeProperties(shaderNode);\n    if (properties.onceOutput) return properties.onceOutput;\n\n    //\n\n    let result = null;\n    if (shaderNode.layout) {\n      let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);\n      if (functionNodesCacheMap === undefined) {\n        functionNodesCacheMap = new WeakMap();\n        nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);\n      }\n      let functionNode = functionNodesCacheMap.get(shaderNode);\n      if (functionNode === undefined) {\n        functionNode = nodeObject(builder.buildFunctionNode(shaderNode));\n        functionNodesCacheMap.set(shaderNode, functionNode);\n      }\n      if (builder.currentFunctionNode !== null) {\n        builder.currentFunctionNode.includes.push(functionNode);\n      }\n      result = nodeObject(functionNode.call(inputNodes));\n    } else {\n      const jsFunc = shaderNode.jsFunc;\n      const outputNode = inputNodes !== null ? jsFunc(inputNodes, builder) : jsFunc(builder);\n      result = nodeObject(outputNode);\n    }\n    if (shaderNode.once) {\n      properties.onceOutput = result;\n    }\n    return result;\n  }\n  getOutputNode(builder) {\n    const properties = builder.getNodeProperties(this);\n    if (properties.outputNode === null) {\n      properties.outputNode = this.setupOutput(builder);\n    }\n    return properties.outputNode;\n  }\n  setup(builder) {\n    return this.getOutputNode(builder);\n  }\n  setupOutput(builder) {\n    builder.addStack();\n    builder.stack.outputNode = this.call(builder);\n    return builder.removeStack();\n  }\n  generate(builder, output) {\n    const outputNode = this.getOutputNode(builder);\n    return outputNode.build(builder, output);\n  }\n}\nclass ShaderNodeInternal extends Node {\n  constructor(jsFunc, nodeType) {\n    super(nodeType);\n    this.jsFunc = jsFunc;\n    this.layout = null;\n    this.global = true;\n    this.once = false;\n  }\n  setLayout(layout) {\n    this.layout = layout;\n    return this;\n  }\n  call(inputs = null) {\n    nodeObjects(inputs);\n    return nodeObject(new ShaderCallNodeInternal(this, inputs));\n  }\n  setup() {\n    return this.call();\n  }\n}\nconst bools = [false, true];\nconst uints = [0, 1, 2, 3];\nconst ints = [-1, -2];\nconst floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nconst boolsCacheMap = new Map();\nfor (const bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));\nconst uintsCacheMap = new Map();\nfor (const uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));\nconst intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));\nfor (const int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));\nconst floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));\nfor (const float of floats) floatsCacheMap.set(float, new ConstNode(float));\nfor (const float of floats) floatsCacheMap.set(-float, new ConstNode(-float));\nconst cacheMaps = {\n  bool: boolsCacheMap,\n  uint: uintsCacheMap,\n  ints: intsCacheMap,\n  float: floatsCacheMap\n};\nconst constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\nconst getConstNode = (value, type) => {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value, type);\n  }\n};\nconst safeGetNodeType = node => {\n  try {\n    return node.getNodeType();\n  } catch (_) {\n    return undefined;\n  }\n};\nconst ConvertType = function (type, cacheMap = null) {\n  return (...params) => {\n    if (params.length === 0 || !['bool', 'float', 'int', 'uint'].includes(type) && params.every(param => typeof param !== 'object')) {\n      params = [getValueFromType(type, ...params)];\n    }\n    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n      return nodeObject(cacheMap.get(params[0]));\n    }\n    if (params.length === 1) {\n      const node = getConstNode(params[0], type);\n      if (safeGetNodeType(node) === type) return nodeObject(node);\n      return nodeObject(new ConvertNode(node, type));\n    }\n    const nodes = params.map(param => getConstNode(param));\n    return nodeObject(new JoinNode(nodes, type));\n  };\n};\n\n// exports\n\nconst defined = v => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function\n\n// utils\n\nconst getConstNodeType = value => value !== undefined && value !== null ? value.nodeType || value.convertTo || (typeof value === 'string' ? value : null) : null;\n\n// shader node base\n\nfunction ShaderNode(jsFunc, nodeType) {\n  return new Proxy(new ShaderNodeInternal(jsFunc, nodeType), shaderNodeHandler);\n}\nconst nodeObject = (val, altType = null) => /* new */ShaderNodeObject(val, altType);\nconst nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);\nconst nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);\nconst nodeProxy = (...params) => new ShaderNodeProxy(...params);\nconst nodeImmutable = (...params) => new ShaderNodeImmutable(...params);\nconst Fn = (jsFunc, nodeType) => {\n  const shaderNode = new ShaderNode(jsFunc, nodeType);\n  const fn = (...params) => {\n    let inputs;\n    nodeObjects(params);\n    if (params[0] && params[0].isNode) {\n      inputs = [...params];\n    } else {\n      inputs = params[0];\n    }\n    return shaderNode.call(inputs);\n  };\n  fn.shaderNode = shaderNode;\n  fn.setLayout = layout => {\n    shaderNode.setLayout(layout);\n    return fn;\n  };\n  fn.once = () => {\n    shaderNode.once = true;\n    return fn;\n  };\n  return fn;\n};\nconst tslFn = (...params) => {\n  // @deprecated, r168\n\n  console.warn('TSL.ShaderNode: tslFn() has been renamed to Fn().');\n  return Fn(...params);\n};\n\n//\n\naddMethodChaining('toGlobal', node => {\n  node.global = true;\n  return node;\n});\n\n//\n\nconst setCurrentStack = stack => {\n  currentStack = stack;\n};\nconst getCurrentStack = () => currentStack;\nconst If = (...params) => currentStack.If(...params);\nfunction append(node) {\n  if (currentStack) currentStack.add(node);\n  return node;\n}\naddMethodChaining('append', append);\n\n// types\n\nconst color = new ConvertType('color');\nconst float = new ConvertType('float', cacheMaps.float);\nconst int = new ConvertType('int', cacheMaps.ints);\nconst uint = new ConvertType('uint', cacheMaps.uint);\nconst bool = new ConvertType('bool', cacheMaps.bool);\nconst vec2 = new ConvertType('vec2');\nconst ivec2 = new ConvertType('ivec2');\nconst uvec2 = new ConvertType('uvec2');\nconst bvec2 = new ConvertType('bvec2');\nconst vec3 = new ConvertType('vec3');\nconst ivec3 = new ConvertType('ivec3');\nconst uvec3 = new ConvertType('uvec3');\nconst bvec3 = new ConvertType('bvec3');\nconst vec4 = new ConvertType('vec4');\nconst ivec4 = new ConvertType('ivec4');\nconst uvec4 = new ConvertType('uvec4');\nconst bvec4 = new ConvertType('bvec4');\nconst mat2 = new ConvertType('mat2');\nconst mat3 = new ConvertType('mat3');\nconst mat4 = new ConvertType('mat4');\nconst string = (value = '') => nodeObject(new ConstNode(value, 'string'));\nconst arrayBuffer = value => nodeObject(new ConstNode(value, 'ArrayBuffer'));\naddMethodChaining('toColor', color);\naddMethodChaining('toFloat', float);\naddMethodChaining('toInt', int);\naddMethodChaining('toUint', uint);\naddMethodChaining('toBool', bool);\naddMethodChaining('toVec2', vec2);\naddMethodChaining('toIVec2', ivec2);\naddMethodChaining('toUVec2', uvec2);\naddMethodChaining('toBVec2', bvec2);\naddMethodChaining('toVec3', vec3);\naddMethodChaining('toIVec3', ivec3);\naddMethodChaining('toUVec3', uvec3);\naddMethodChaining('toBVec3', bvec3);\naddMethodChaining('toVec4', vec4);\naddMethodChaining('toIVec4', ivec4);\naddMethodChaining('toUVec4', uvec4);\naddMethodChaining('toBVec4', bvec4);\naddMethodChaining('toMat2', mat2);\naddMethodChaining('toMat3', mat3);\naddMethodChaining('toMat4', mat4);\n\n// basic nodes\n\nconst element = /*@__PURE__*/nodeProxy(ArrayElementNode);\nconst convert = (node, types) => nodeObject(new ConvertNode(nodeObject(node), types));\nconst split = (node, channels) => nodeObject(new SplitNode(nodeObject(node), channels));\naddMethodChaining('element', element);\naddMethodChaining('convert', convert);\nclass UniformGroupNode extends Node {\n  static get type() {\n    return 'UniformGroupNode';\n  }\n  constructor(name, shared = false, order = 1) {\n    super('string');\n    this.name = name;\n    this.version = 0;\n    this.shared = shared;\n    this.order = order;\n    this.isUniformGroup = true;\n  }\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.name = this.name;\n    data.version = this.version;\n    data.shared = this.shared;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.name = data.name;\n    this.version = data.version;\n    this.shared = data.shared;\n  }\n}\nconst uniformGroup = name => new UniformGroupNode(name);\nconst sharedUniformGroup = (name, order = 0) => new UniformGroupNode(name, true, order);\nconst frameGroup = /*@__PURE__*/sharedUniformGroup('frame');\nconst renderGroup = /*@__PURE__*/sharedUniformGroup('render');\nconst objectGroup = /*@__PURE__*/uniformGroup('object');\nclass UniformNode extends InputNode {\n  static get type() {\n    return 'UniformNode';\n  }\n  constructor(value, nodeType = null) {\n    super(value, nodeType);\n    this.isUniformNode = true;\n    this.name = '';\n    this.groupNode = objectGroup;\n  }\n  label(name) {\n    this.name = name;\n    return this;\n  }\n  setGroup(group) {\n    this.groupNode = group;\n    return this;\n  }\n  getGroup() {\n    return this.groupNode;\n  }\n  getUniformHash(builder) {\n    return this.getHash(builder);\n  }\n  onUpdate(callback, updateType) {\n    const self = this.getSelf();\n    callback = callback.bind(self);\n    return super.onUpdate(frame => {\n      const value = callback(frame, self);\n      if (value !== undefined) {\n        this.value = value;\n      }\n    }, updateType);\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    const hash = this.getUniformHash(builder);\n    let sharedNode = builder.getNodeFromHash(hash);\n    if (sharedNode === undefined) {\n      builder.setHashNode(this, hash);\n      sharedNode = this;\n    }\n    const sharedNodeType = sharedNode.getInputType(builder);\n    const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label);\n    const propertyName = builder.getPropertyName(nodeUniform);\n    if (builder.context.label !== undefined) delete builder.context.label;\n    return builder.format(propertyName, type, output);\n  }\n}\nconst uniform = (arg1, arg2) => {\n  const nodeType = getConstNodeType(arg2 || arg1);\n\n  // @TODO: get ConstNode from .traverse() in the future\n  const value = arg1 && arg1.isNode === true ? arg1.node && arg1.node.value || arg1.value : arg1;\n  return nodeObject(new UniformNode(value, nodeType));\n};\nclass PropertyNode extends Node {\n  static get type() {\n    return 'PropertyNode';\n  }\n  constructor(nodeType, name = null, varying = false) {\n    super(nodeType);\n    this.name = name;\n    this.varying = varying;\n    this.isPropertyNode = true;\n  }\n  getHash(builder) {\n    return this.name || super.getHash(builder);\n  }\n  isGlobal(/*builder*/\n  ) {\n    return true;\n  }\n  generate(builder) {\n    let nodeVar;\n    if (this.varying === true) {\n      nodeVar = builder.getVaryingFromNode(this, this.name);\n      nodeVar.needsInterpolation = true;\n    } else {\n      nodeVar = builder.getVarFromNode(this, this.name);\n    }\n    return builder.getPropertyName(nodeVar);\n  }\n}\nconst property = (type, name) => nodeObject(new PropertyNode(type, name));\nconst varyingProperty = (type, name) => nodeObject(new PropertyNode(type, name, true));\nconst diffuseColor = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec4', 'DiffuseColor');\nconst emissive = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'EmissiveColor');\nconst roughness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Roughness');\nconst metalness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Metalness');\nconst clearcoat = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Clearcoat');\nconst clearcoatRoughness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'ClearcoatRoughness');\nconst sheen = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'Sheen');\nconst sheenRoughness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'SheenRoughness');\nconst iridescence = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Iridescence');\nconst iridescenceIOR = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'IridescenceIOR');\nconst iridescenceThickness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'IridescenceThickness');\nconst alphaT = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'AlphaT');\nconst anisotropy = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Anisotropy');\nconst anisotropyT = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'AnisotropyT');\nconst anisotropyB = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'AnisotropyB');\nconst specularColor = /*@__PURE__*/nodeImmutable(PropertyNode, 'color', 'SpecularColor');\nconst specularF90 = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'SpecularF90');\nconst shininess = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Shininess');\nconst output = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec4', 'Output');\nconst dashSize = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'dashSize');\nconst gapSize = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'gapSize');\nconst pointWidth = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'pointWidth');\nconst ior = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'IOR');\nconst transmission = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Transmission');\nconst thickness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Thickness');\nconst attenuationDistance = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'AttenuationDistance');\nconst attenuationColor = /*@__PURE__*/nodeImmutable(PropertyNode, 'color', 'AttenuationColor');\nconst dispersion = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Dispersion');\nclass AssignNode extends TempNode {\n  static get type() {\n    return 'AssignNode';\n  }\n  constructor(targetNode, sourceNode) {\n    super();\n    this.targetNode = targetNode;\n    this.sourceNode = sourceNode;\n  }\n  hasDependencies() {\n    return false;\n  }\n  getNodeType(builder, output) {\n    return output !== 'void' ? this.targetNode.getNodeType(builder) : 'void';\n  }\n  needsSplitAssign(builder) {\n    const {\n      targetNode\n    } = this;\n    if (builder.isAvailable('swizzleAssign') === false && targetNode.isSplitNode && targetNode.components.length > 1) {\n      const targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));\n      const assignDiferentVector = vectorComponents.join('').slice(0, targetLength) !== targetNode.components;\n      return assignDiferentVector;\n    }\n    return false;\n  }\n  generate(builder, output) {\n    const {\n      targetNode,\n      sourceNode\n    } = this;\n    const needsSplitAssign = this.needsSplitAssign(builder);\n    const targetType = targetNode.getNodeType(builder);\n    const target = targetNode.context({\n      assign: true\n    }).build(builder);\n    const source = sourceNode.build(builder, targetType);\n    const sourceType = sourceNode.getNodeType(builder);\n    const nodeData = builder.getDataFromNode(this);\n\n    //\n\n    let snippet;\n    if (nodeData.initialized === true) {\n      if (output !== 'void') {\n        snippet = target;\n      }\n    } else if (needsSplitAssign) {\n      const sourceVar = builder.getVarFromNode(this, null, targetType);\n      const sourceProperty = builder.getPropertyName(sourceVar);\n      builder.addLineFlowCode(`${sourceProperty} = ${source}`, this);\n      const targetRoot = targetNode.node.context({\n        assign: true\n      }).build(builder);\n      for (let i = 0; i < targetNode.components.length; i++) {\n        const component = targetNode.components[i];\n        builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} ]`, this);\n      }\n      if (output !== 'void') {\n        snippet = target;\n      }\n    } else {\n      snippet = `${target} = ${source}`;\n      if (output === 'void' || sourceType === 'void') {\n        builder.addLineFlowCode(snippet, this);\n        if (output !== 'void') {\n          snippet = target;\n        }\n      }\n    }\n    nodeData.initialized = true;\n    return builder.format(snippet, targetType, output);\n  }\n}\nconst assign = /*@__PURE__*/nodeProxy(AssignNode);\naddMethodChaining('assign', assign);\nclass FunctionCallNode extends TempNode {\n  static get type() {\n    return 'FunctionCallNode';\n  }\n  constructor(functionNode = null, parameters = {}) {\n    super();\n    this.functionNode = functionNode;\n    this.parameters = parameters;\n  }\n  setParameters(parameters) {\n    this.parameters = parameters;\n    return this;\n  }\n  getParameters() {\n    return this.parameters;\n  }\n  getNodeType(builder) {\n    return this.functionNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const params = [];\n    const functionNode = this.functionNode;\n    const inputs = functionNode.getInputs(builder);\n    const parameters = this.parameters;\n    const generateInput = (node, inputNode) => {\n      const type = inputNode.type;\n      const pointer = type === 'pointer';\n      let output;\n      if (pointer) output = '&' + node.build(builder);else output = node.build(builder, type);\n      return output;\n    };\n    if (Array.isArray(parameters)) {\n      for (let i = 0; i < parameters.length; i++) {\n        params.push(generateInput(parameters[i], inputs[i]));\n      }\n    } else {\n      for (const inputNode of inputs) {\n        const node = parameters[inputNode.name];\n        if (node !== undefined) {\n          params.push(generateInput(node, inputNode));\n        } else {\n          throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);\n        }\n      }\n    }\n    const functionName = functionNode.build(builder, 'property');\n    return `${functionName}( ${params.join(', ')} )`;\n  }\n}\nconst call = (func, ...params) => {\n  params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);\n  return nodeObject(new FunctionCallNode(nodeObject(func), params));\n};\naddMethodChaining('call', call);\nclass OperatorNode extends TempNode {\n  static get type() {\n    return 'OperatorNode';\n  }\n  constructor(op, aNode, bNode, ...params) {\n    super();\n    if (params.length > 0) {\n      let finalOp = new OperatorNode(op, aNode, bNode);\n      for (let i = 0; i < params.length - 1; i++) {\n        finalOp = new OperatorNode(op, finalOp, params[i]);\n      }\n      aNode = finalOp;\n      bNode = params[params.length - 1];\n    }\n    this.op = op;\n    this.aNode = aNode;\n    this.bNode = bNode;\n  }\n  getNodeType(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const typeA = aNode.getNodeType(builder);\n    const typeB = typeof bNode !== 'undefined' ? bNode.getNodeType(builder) : null;\n    if (typeA === 'void' || typeB === 'void') {\n      return 'void';\n    } else if (op === '%') {\n      return typeA;\n    } else if (op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<') {\n      return builder.getIntegerType(typeA);\n    } else if (op === '!' || op === '==' || op === '&&' || op === '||' || op === '^^') {\n      return 'bool';\n    } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {\n      const typeLength = output ? builder.getTypeLength(output) : Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));\n      return typeLength > 1 ? `bvec${typeLength}` : 'bool';\n    } else {\n      if (typeA === 'float' && builder.isMatrix(typeB)) {\n        return typeB;\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n\n        return builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n\n        return builder.getVectorFromMatrix(typeB);\n      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {\n        // anytype x anytype: use the greater length vector\n\n        return typeB;\n      }\n      return typeA;\n    }\n  }\n  generate(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const type = this.getNodeType(builder, output);\n    let typeA = null;\n    let typeB = null;\n    if (type !== 'void') {\n      typeA = aNode.getNodeType(builder);\n      typeB = typeof bNode !== 'undefined' ? bNode.getNodeType(builder) : null;\n      if (op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==') {\n        if (builder.isVector(typeA)) {\n          typeB = typeA;\n        } else if (typeA !== typeB) {\n          typeA = typeB = 'float';\n        }\n      } else if (op === '>>' || op === '<<') {\n        typeA = type;\n        typeB = builder.changeComponentType(typeB, 'uint');\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n\n        typeB = builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n\n        typeA = builder.getVectorFromMatrix(typeB);\n      } else {\n        // anytype x anytype\n\n        typeA = typeB = type;\n      }\n    } else {\n      typeA = typeB = type;\n    }\n    const a = aNode.build(builder, typeA);\n    const b = typeof bNode !== 'undefined' ? bNode.build(builder, typeB) : null;\n    const outputLength = builder.getTypeLength(output);\n    const fnOpSnippet = builder.getFunctionOperator(op);\n    if (output !== 'void') {\n      if (op === '<' && outputLength > 1) {\n        if (builder.useComparisonMethod) {\n          return builder.format(`${builder.getMethod('lessThan', output)}( ${a}, ${b} )`, type, output);\n        } else {\n          return builder.format(`( ${a} < ${b} )`, type, output);\n        }\n      } else if (op === '<=' && outputLength > 1) {\n        if (builder.useComparisonMethod) {\n          return builder.format(`${builder.getMethod('lessThanEqual', output)}( ${a}, ${b} )`, type, output);\n        } else {\n          return builder.format(`( ${a} <= ${b} )`, type, output);\n        }\n      } else if (op === '>' && outputLength > 1) {\n        if (builder.useComparisonMethod) {\n          return builder.format(`${builder.getMethod('greaterThan', output)}( ${a}, ${b} )`, type, output);\n        } else {\n          return builder.format(`( ${a} > ${b} )`, type, output);\n        }\n      } else if (op === '>=' && outputLength > 1) {\n        if (builder.useComparisonMethod) {\n          return builder.format(`${builder.getMethod('greaterThanEqual', output)}( ${a}, ${b} )`, type, output);\n        } else {\n          return builder.format(`( ${a} >= ${b} )`, type, output);\n        }\n      } else if (op === '!' || op === '~') {\n        return builder.format(`(${op}${a})`, typeA, output);\n      } else if (fnOpSnippet) {\n        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output);\n      } else {\n        return builder.format(`( ${a} ${op} ${b} )`, type, output);\n      }\n    } else if (typeA !== 'void') {\n      if (fnOpSnippet) {\n        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output);\n      } else {\n        return builder.format(`${a} ${op} ${b}`, type, output);\n      }\n    }\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.op = this.op;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.op = data.op;\n  }\n}\nconst add = /*@__PURE__*/nodeProxy(OperatorNode, '+');\nconst sub = /*@__PURE__*/nodeProxy(OperatorNode, '-');\nconst mul = /*@__PURE__*/nodeProxy(OperatorNode, '*');\nconst div = /*@__PURE__*/nodeProxy(OperatorNode, '/');\nconst modInt = /*@__PURE__*/nodeProxy(OperatorNode, '%');\nconst equal = /*@__PURE__*/nodeProxy(OperatorNode, '==');\nconst notEqual = /*@__PURE__*/nodeProxy(OperatorNode, '!=');\nconst lessThan = /*@__PURE__*/nodeProxy(OperatorNode, '<');\nconst greaterThan = /*@__PURE__*/nodeProxy(OperatorNode, '>');\nconst lessThanEqual = /*@__PURE__*/nodeProxy(OperatorNode, '<=');\nconst greaterThanEqual = /*@__PURE__*/nodeProxy(OperatorNode, '>=');\nconst and = /*@__PURE__*/nodeProxy(OperatorNode, '&&');\nconst or = /*@__PURE__*/nodeProxy(OperatorNode, '||');\nconst not = /*@__PURE__*/nodeProxy(OperatorNode, '!');\nconst xor = /*@__PURE__*/nodeProxy(OperatorNode, '^^');\nconst bitAnd = /*@__PURE__*/nodeProxy(OperatorNode, '&');\nconst bitNot = /*@__PURE__*/nodeProxy(OperatorNode, '~');\nconst bitOr = /*@__PURE__*/nodeProxy(OperatorNode, '|');\nconst bitXor = /*@__PURE__*/nodeProxy(OperatorNode, '^');\nconst shiftLeft = /*@__PURE__*/nodeProxy(OperatorNode, '<<');\nconst shiftRight = /*@__PURE__*/nodeProxy(OperatorNode, '>>');\naddMethodChaining('add', add);\naddMethodChaining('sub', sub);\naddMethodChaining('mul', mul);\naddMethodChaining('div', div);\naddMethodChaining('modInt', modInt);\naddMethodChaining('equal', equal);\naddMethodChaining('notEqual', notEqual);\naddMethodChaining('lessThan', lessThan);\naddMethodChaining('greaterThan', greaterThan);\naddMethodChaining('lessThanEqual', lessThanEqual);\naddMethodChaining('greaterThanEqual', greaterThanEqual);\naddMethodChaining('and', and);\naddMethodChaining('or', or);\naddMethodChaining('not', not);\naddMethodChaining('xor', xor);\naddMethodChaining('bitAnd', bitAnd);\naddMethodChaining('bitNot', bitNot);\naddMethodChaining('bitOr', bitOr);\naddMethodChaining('bitXor', bitXor);\naddMethodChaining('shiftLeft', shiftLeft);\naddMethodChaining('shiftRight', shiftRight);\nconst remainder = (...params) => {\n  // @deprecated, r168\n\n  console.warn('TSL.OperatorNode: .remainder() has been renamed to .modInt().');\n  return modInt(...params);\n};\naddMethodChaining('remainder', remainder);\nclass MathNode extends TempNode {\n  static get type() {\n    return 'MathNode';\n  }\n  constructor(method, aNode, bNode = null, cNode = null) {\n    super();\n    this.method = method;\n    this.aNode = aNode;\n    this.bNode = bNode;\n    this.cNode = cNode;\n  }\n  getInputType(builder) {\n    const aType = this.aNode.getNodeType(builder);\n    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;\n    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;\n    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);\n    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);\n    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);\n    if (aLen > bLen && aLen > cLen) {\n      return aType;\n    } else if (bLen > cLen) {\n      return bType;\n    } else if (cLen > aLen) {\n      return cType;\n    }\n    return aType;\n  }\n  getNodeType(builder) {\n    const method = this.method;\n    if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {\n      return 'float';\n    } else if (method === MathNode.CROSS) {\n      return 'vec3';\n    } else if (method === MathNode.ALL) {\n      return 'bool';\n    } else if (method === MathNode.EQUALS) {\n      return builder.changeComponentType(this.aNode.getNodeType(builder), 'bool');\n    } else if (method === MathNode.MOD) {\n      return this.aNode.getNodeType(builder);\n    } else {\n      return this.getInputType(builder);\n    }\n  }\n  generate(builder, output) {\n    const method = this.method;\n    const type = this.getNodeType(builder);\n    const inputType = this.getInputType(builder);\n    const a = this.aNode;\n    const b = this.bNode;\n    const c = this.cNode;\n    const isWebGL = builder.renderer.isWebGLRenderer === true;\n    if (method === MathNode.TRANSFORM_DIRECTION) {\n      // dir can be either a direction vector or a normal vector\n      // upper-left 3x3 of matrix is assumed to be orthogonal\n\n      let tA = a;\n      let tB = b;\n      if (builder.isMatrix(tA.getNodeType(builder))) {\n        tB = vec4(vec3(tB), 0.0);\n      } else {\n        tA = vec4(vec3(tA), 0.0);\n      }\n      const mulNode = mul(tA, tB).xyz;\n      return normalize(mulNode).build(builder, output);\n    } else if (method === MathNode.NEGATE) {\n      return builder.format('( - ' + a.build(builder, inputType) + ' )', type, output);\n    } else if (method === MathNode.ONE_MINUS) {\n      return sub(1.0, a).build(builder, output);\n    } else if (method === MathNode.RECIPROCAL) {\n      return div(1.0, a).build(builder, output);\n    } else if (method === MathNode.DIFFERENCE) {\n      return abs(sub(a, b)).build(builder, output);\n    } else {\n      const params = [];\n      if (method === MathNode.CROSS || method === MathNode.MOD) {\n        params.push(a.build(builder, type), b.build(builder, type));\n      } else if (isWebGL && method === MathNode.STEP) {\n        params.push(a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? 'float' : inputType), b.build(builder, inputType));\n      } else if (isWebGL && (method === MathNode.MIN || method === MathNode.MAX) || method === MathNode.MOD) {\n        params.push(a.build(builder, inputType), b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? 'float' : inputType));\n      } else if (method === MathNode.REFRACT) {\n        params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, 'float'));\n      } else if (method === MathNode.MIX) {\n        params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? 'float' : inputType));\n      } else {\n        params.push(a.build(builder, inputType));\n        if (b !== null) params.push(b.build(builder, inputType));\n        if (c !== null) params.push(c.build(builder, inputType));\n      }\n      return builder.format(`${builder.getMethod(method, type)}( ${params.join(', ')} )`, type, output);\n    }\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.method = this.method;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.method = data.method;\n  }\n}\n\n// 1 input\n\nMathNode.ALL = 'all';\nMathNode.ANY = 'any';\nMathNode.EQUALS = 'equals';\nMathNode.RADIANS = 'radians';\nMathNode.DEGREES = 'degrees';\nMathNode.EXP = 'exp';\nMathNode.EXP2 = 'exp2';\nMathNode.LOG = 'log';\nMathNode.LOG2 = 'log2';\nMathNode.SQRT = 'sqrt';\nMathNode.INVERSE_SQRT = 'inversesqrt';\nMathNode.FLOOR = 'floor';\nMathNode.CEIL = 'ceil';\nMathNode.NORMALIZE = 'normalize';\nMathNode.FRACT = 'fract';\nMathNode.SIN = 'sin';\nMathNode.COS = 'cos';\nMathNode.TAN = 'tan';\nMathNode.ASIN = 'asin';\nMathNode.ACOS = 'acos';\nMathNode.ATAN = 'atan';\nMathNode.ABS = 'abs';\nMathNode.SIGN = 'sign';\nMathNode.LENGTH = 'length';\nMathNode.NEGATE = 'negate';\nMathNode.ONE_MINUS = 'oneMinus';\nMathNode.DFDX = 'dFdx';\nMathNode.DFDY = 'dFdy';\nMathNode.ROUND = 'round';\nMathNode.RECIPROCAL = 'reciprocal';\nMathNode.TRUNC = 'trunc';\nMathNode.FWIDTH = 'fwidth';\nMathNode.BITCAST = 'bitcast';\nMathNode.TRANSPOSE = 'transpose';\n\n// 2 inputs\n\nMathNode.ATAN2 = 'atan2';\nMathNode.MIN = 'min';\nMathNode.MAX = 'max';\nMathNode.MOD = 'mod';\nMathNode.STEP = 'step';\nMathNode.REFLECT = 'reflect';\nMathNode.DISTANCE = 'distance';\nMathNode.DIFFERENCE = 'difference';\nMathNode.DOT = 'dot';\nMathNode.CROSS = 'cross';\nMathNode.POW = 'pow';\nMathNode.TRANSFORM_DIRECTION = 'transformDirection';\n\n// 3 inputs\n\nMathNode.MIX = 'mix';\nMathNode.CLAMP = 'clamp';\nMathNode.REFRACT = 'refract';\nMathNode.SMOOTHSTEP = 'smoothstep';\nMathNode.FACEFORWARD = 'faceforward';\nconst EPSILON = /*@__PURE__*/float(1e-6);\nconst INFINITY = /*@__PURE__*/float(1e6);\nconst PI = /*@__PURE__*/float(Math.PI);\nconst PI2 = /*@__PURE__*/float(Math.PI * 2);\nconst all = /*@__PURE__*/nodeProxy(MathNode, MathNode.ALL);\nconst any = /*@__PURE__*/nodeProxy(MathNode, MathNode.ANY);\nconst equals = /*@__PURE__*/nodeProxy(MathNode, MathNode.EQUALS);\nconst radians = /*@__PURE__*/nodeProxy(MathNode, MathNode.RADIANS);\nconst degrees = /*@__PURE__*/nodeProxy(MathNode, MathNode.DEGREES);\nconst exp = /*@__PURE__*/nodeProxy(MathNode, MathNode.EXP);\nconst exp2 = /*@__PURE__*/nodeProxy(MathNode, MathNode.EXP2);\nconst log = /*@__PURE__*/nodeProxy(MathNode, MathNode.LOG);\nconst log2 = /*@__PURE__*/nodeProxy(MathNode, MathNode.LOG2);\nconst sqrt = /*@__PURE__*/nodeProxy(MathNode, MathNode.SQRT);\nconst inverseSqrt = /*@__PURE__*/nodeProxy(MathNode, MathNode.INVERSE_SQRT);\nconst floor = /*@__PURE__*/nodeProxy(MathNode, MathNode.FLOOR);\nconst ceil = /*@__PURE__*/nodeProxy(MathNode, MathNode.CEIL);\nconst normalize = /*@__PURE__*/nodeProxy(MathNode, MathNode.NORMALIZE);\nconst fract = /*@__PURE__*/nodeProxy(MathNode, MathNode.FRACT);\nconst sin = /*@__PURE__*/nodeProxy(MathNode, MathNode.SIN);\nconst cos = /*@__PURE__*/nodeProxy(MathNode, MathNode.COS);\nconst tan = /*@__PURE__*/nodeProxy(MathNode, MathNode.TAN);\nconst asin = /*@__PURE__*/nodeProxy(MathNode, MathNode.ASIN);\nconst acos = /*@__PURE__*/nodeProxy(MathNode, MathNode.ACOS);\nconst atan = /*@__PURE__*/nodeProxy(MathNode, MathNode.ATAN);\nconst abs = /*@__PURE__*/nodeProxy(MathNode, MathNode.ABS);\nconst sign = /*@__PURE__*/nodeProxy(MathNode, MathNode.SIGN);\nconst length = /*@__PURE__*/nodeProxy(MathNode, MathNode.LENGTH);\nconst negate = /*@__PURE__*/nodeProxy(MathNode, MathNode.NEGATE);\nconst oneMinus = /*@__PURE__*/nodeProxy(MathNode, MathNode.ONE_MINUS);\nconst dFdx = /*@__PURE__*/nodeProxy(MathNode, MathNode.DFDX);\nconst dFdy = /*@__PURE__*/nodeProxy(MathNode, MathNode.DFDY);\nconst round = /*@__PURE__*/nodeProxy(MathNode, MathNode.ROUND);\nconst reciprocal = /*@__PURE__*/nodeProxy(MathNode, MathNode.RECIPROCAL);\nconst trunc = /*@__PURE__*/nodeProxy(MathNode, MathNode.TRUNC);\nconst fwidth = /*@__PURE__*/nodeProxy(MathNode, MathNode.FWIDTH);\nconst bitcast = /*@__PURE__*/nodeProxy(MathNode, MathNode.BITCAST);\nconst transpose = /*@__PURE__*/nodeProxy(MathNode, MathNode.TRANSPOSE);\nconst atan2 = /*@__PURE__*/nodeProxy(MathNode, MathNode.ATAN2);\nconst min$1 = /*@__PURE__*/nodeProxy(MathNode, MathNode.MIN);\nconst max$1 = /*@__PURE__*/nodeProxy(MathNode, MathNode.MAX);\nconst mod = /*@__PURE__*/nodeProxy(MathNode, MathNode.MOD);\nconst step = /*@__PURE__*/nodeProxy(MathNode, MathNode.STEP);\nconst reflect = /*@__PURE__*/nodeProxy(MathNode, MathNode.REFLECT);\nconst distance = /*@__PURE__*/nodeProxy(MathNode, MathNode.DISTANCE);\nconst difference = /*@__PURE__*/nodeProxy(MathNode, MathNode.DIFFERENCE);\nconst dot = /*@__PURE__*/nodeProxy(MathNode, MathNode.DOT);\nconst cross = /*@__PURE__*/nodeProxy(MathNode, MathNode.CROSS);\nconst pow = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW);\nconst pow2 = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW, 2);\nconst pow3 = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW, 3);\nconst pow4 = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW, 4);\nconst transformDirection = /*@__PURE__*/nodeProxy(MathNode, MathNode.TRANSFORM_DIRECTION);\nconst cbrt = a => mul(sign(a), pow(abs(a), 1.0 / 3.0));\nconst lengthSq = a => dot(a, a);\nconst mix = /*@__PURE__*/nodeProxy(MathNode, MathNode.MIX);\nconst clamp = (value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));\nconst saturate = value => clamp(value);\nconst refract = /*@__PURE__*/nodeProxy(MathNode, MathNode.REFRACT);\nconst smoothstep = /*@__PURE__*/nodeProxy(MathNode, MathNode.SMOOTHSTEP);\nconst faceForward = /*@__PURE__*/nodeProxy(MathNode, MathNode.FACEFORWARD);\nconst rand = /*@__PURE__*/Fn(([uv]) => {\n  const a = 12.9898,\n    b = 78.233,\n    c = 43758.5453;\n  const dt = dot(uv.xy, vec2(a, b)),\n    sn = mod(dt, PI);\n  return fract(sin(sn).mul(c));\n});\nconst mixElement = (t, e1, e2) => mix(e1, e2, t);\nconst smoothstepElement = (x, low, high) => smoothstep(low, high, x);\naddMethodChaining('all', all);\naddMethodChaining('any', any);\naddMethodChaining('equals', equals);\naddMethodChaining('radians', radians);\naddMethodChaining('degrees', degrees);\naddMethodChaining('exp', exp);\naddMethodChaining('exp2', exp2);\naddMethodChaining('log', log);\naddMethodChaining('log2', log2);\naddMethodChaining('sqrt', sqrt);\naddMethodChaining('inverseSqrt', inverseSqrt);\naddMethodChaining('floor', floor);\naddMethodChaining('ceil', ceil);\naddMethodChaining('normalize', normalize);\naddMethodChaining('fract', fract);\naddMethodChaining('sin', sin);\naddMethodChaining('cos', cos);\naddMethodChaining('tan', tan);\naddMethodChaining('asin', asin);\naddMethodChaining('acos', acos);\naddMethodChaining('atan', atan);\naddMethodChaining('abs', abs);\naddMethodChaining('sign', sign);\naddMethodChaining('length', length);\naddMethodChaining('lengthSq', lengthSq);\naddMethodChaining('negate', negate);\naddMethodChaining('oneMinus', oneMinus);\naddMethodChaining('dFdx', dFdx);\naddMethodChaining('dFdy', dFdy);\naddMethodChaining('round', round);\naddMethodChaining('reciprocal', reciprocal);\naddMethodChaining('trunc', trunc);\naddMethodChaining('fwidth', fwidth);\naddMethodChaining('atan2', atan2);\naddMethodChaining('min', min$1);\naddMethodChaining('max', max$1);\naddMethodChaining('mod', mod);\naddMethodChaining('step', step);\naddMethodChaining('reflect', reflect);\naddMethodChaining('distance', distance);\naddMethodChaining('dot', dot);\naddMethodChaining('cross', cross);\naddMethodChaining('pow', pow);\naddMethodChaining('pow2', pow2);\naddMethodChaining('pow3', pow3);\naddMethodChaining('pow4', pow4);\naddMethodChaining('transformDirection', transformDirection);\naddMethodChaining('mix', mixElement);\naddMethodChaining('clamp', clamp);\naddMethodChaining('refract', refract);\naddMethodChaining('smoothstep', smoothstepElement);\naddMethodChaining('faceForward', faceForward);\naddMethodChaining('difference', difference);\naddMethodChaining('saturate', saturate);\naddMethodChaining('cbrt', cbrt);\naddMethodChaining('transpose', transpose);\naddMethodChaining('rand', rand);\nclass ConditionalNode extends Node {\n  static get type() {\n    return 'ConditionalNode';\n  }\n  constructor(condNode, ifNode, elseNode = null) {\n    super();\n    this.condNode = condNode;\n    this.ifNode = ifNode;\n    this.elseNode = elseNode;\n  }\n  getNodeType(builder) {\n    const ifType = this.ifNode.getNodeType(builder);\n    if (this.elseNode !== null) {\n      const elseType = this.elseNode.getNodeType(builder);\n      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {\n        return elseType;\n      }\n    }\n    return ifType;\n  }\n  setup(builder) {\n    const condNode = this.condNode.cache();\n    const ifNode = this.ifNode.cache();\n    const elseNode = this.elseNode ? this.elseNode.cache() : null;\n\n    //\n\n    const currentNodeBlock = builder.context.nodeBlock;\n    builder.getDataFromNode(ifNode).parentNodeBlock = currentNodeBlock;\n    if (elseNode !== null) builder.getDataFromNode(elseNode).parentNodeBlock = currentNodeBlock;\n\n    //\n\n    const properties = builder.getNodeProperties(this);\n    properties.condNode = condNode;\n    properties.ifNode = ifNode.context({\n      nodeBlock: ifNode\n    });\n    properties.elseNode = elseNode ? elseNode.context({\n      nodeBlock: elseNode\n    }) : null;\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    const nodeData = builder.getDataFromNode(this);\n    if (nodeData.nodeProperty !== undefined) {\n      return nodeData.nodeProperty;\n    }\n    const {\n      condNode,\n      ifNode,\n      elseNode\n    } = builder.getNodeProperties(this);\n    const needsOutput = output !== 'void';\n    const nodeProperty = needsOutput ? property(type).build(builder) : '';\n    nodeData.nodeProperty = nodeProperty;\n    const nodeSnippet = condNode.build(builder, 'bool');\n    builder.addFlowCode(`\\n${builder.tab}if ( ${nodeSnippet} ) {\\n\\n`).addFlowTab();\n    let ifSnippet = ifNode.build(builder, type);\n    if (ifSnippet) {\n      if (needsOutput) {\n        ifSnippet = nodeProperty + ' = ' + ifSnippet + ';';\n      } else {\n        ifSnippet = 'return ' + ifSnippet + ';';\n      }\n    }\n    builder.removeFlowTab().addFlowCode(builder.tab + '\\t' + ifSnippet + '\\n\\n' + builder.tab + '}');\n    if (elseNode !== null) {\n      builder.addFlowCode(' else {\\n\\n').addFlowTab();\n      let elseSnippet = elseNode.build(builder, type);\n      if (elseSnippet) {\n        if (needsOutput) {\n          elseSnippet = nodeProperty + ' = ' + elseSnippet + ';';\n        } else {\n          elseSnippet = 'return ' + elseSnippet + ';';\n        }\n      }\n      builder.removeFlowTab().addFlowCode(builder.tab + '\\t' + elseSnippet + '\\n\\n' + builder.tab + '}\\n\\n');\n    } else {\n      builder.addFlowCode('\\n\\n');\n    }\n    return builder.format(nodeProperty, type, output);\n  }\n}\nconst select = /*@__PURE__*/nodeProxy(ConditionalNode);\naddMethodChaining('select', select);\n\n//\n\nconst cond = (...params) => {\n  // @deprecated, r168\n\n  console.warn('TSL.ConditionalNode: cond() has been renamed to select().');\n  return select(...params);\n};\naddMethodChaining('cond', cond);\nclass ContextNode extends Node {\n  static get type() {\n    return 'ContextNode';\n  }\n  constructor(node, value = {}) {\n    super();\n    this.isContextNode = true;\n    this.node = node;\n    this.value = value;\n  }\n  getScope() {\n    return this.node.getScope();\n  }\n  getNodeType(builder) {\n    return this.node.getNodeType(builder);\n  }\n  analyze(builder) {\n    this.node.build(builder);\n  }\n  setup(builder) {\n    const previousContext = builder.getContext();\n    builder.setContext({\n      ...builder.context,\n      ...this.value\n    });\n    const node = this.node.build(builder);\n    builder.setContext(previousContext);\n    return node;\n  }\n  generate(builder, output) {\n    const previousContext = builder.getContext();\n    builder.setContext({\n      ...builder.context,\n      ...this.value\n    });\n    const snippet = this.node.build(builder, output);\n    builder.setContext(previousContext);\n    return snippet;\n  }\n}\nconst context = /*@__PURE__*/nodeProxy(ContextNode);\nconst label = (node, name) => context(node, {\n  label: name\n});\naddMethodChaining('context', context);\naddMethodChaining('label', label);\nclass VarNode extends Node {\n  static get type() {\n    return 'VarNode';\n  }\n  constructor(node, name = null) {\n    super();\n    this.node = node;\n    this.name = name;\n    this.global = true;\n    this.isVarNode = true;\n  }\n  getHash(builder) {\n    return this.name || super.getHash(builder);\n  }\n  getNodeType(builder) {\n    return this.node.getNodeType(builder);\n  }\n  generate(builder) {\n    const {\n      node,\n      name\n    } = this;\n    const nodeVar = builder.getVarFromNode(this, name, builder.getVectorType(this.getNodeType(builder)));\n    const propertyName = builder.getPropertyName(nodeVar);\n    const snippet = node.build(builder, nodeVar.type);\n    builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);\n    return propertyName;\n  }\n}\nconst createVar = /*@__PURE__*/nodeProxy(VarNode);\naddMethodChaining('toVar', (...params) => createVar(...params).append());\n\n// Deprecated\n\nconst temp = node => {\n  // @deprecated, r170\n\n  console.warn('TSL: \"temp\" is deprecated. Use \".toVar()\" instead.');\n  return createVar(node);\n};\naddMethodChaining('temp', temp);\nclass VaryingNode extends Node {\n  static get type() {\n    return 'VaryingNode';\n  }\n  constructor(node, name = null) {\n    super();\n    this.node = node;\n    this.name = name;\n    this.isVaryingNode = true;\n  }\n  isGlobal() {\n    return true;\n  }\n  getHash(builder) {\n    return this.name || super.getHash(builder);\n  }\n  getNodeType(builder) {\n    // VaryingNode is auto type\n\n    return this.node.getNodeType(builder);\n  }\n  setupVarying(builder) {\n    const properties = builder.getNodeProperties(this);\n    let varying = properties.varying;\n    if (varying === undefined) {\n      const name = this.name;\n      const type = this.getNodeType(builder);\n      properties.varying = varying = builder.getVaryingFromNode(this, name, type);\n      properties.node = this.node;\n    }\n\n    // this property can be used to check if the varying can be optimized for a variable\n    varying.needsInterpolation || (varying.needsInterpolation = builder.shaderStage === 'fragment');\n    return varying;\n  }\n  setup(builder) {\n    this.setupVarying(builder);\n  }\n  analyze(builder) {\n    this.setupVarying(builder);\n    return this.node.analyze(builder);\n  }\n  generate(builder) {\n    const properties = builder.getNodeProperties(this);\n    const varying = this.setupVarying(builder);\n    if (properties.propertyName === undefined) {\n      const type = this.getNodeType(builder);\n      const propertyName = builder.getPropertyName(varying, NodeShaderStage.VERTEX);\n\n      // force node run in vertex stage\n      builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node, type, propertyName);\n      properties.propertyName = propertyName;\n    }\n    return builder.getPropertyName(varying);\n  }\n}\nconst varying = /*@__PURE__*/nodeProxy(VaryingNode);\naddMethodChaining('varying', varying);\nconst sRGBTransferEOTF = /*@__PURE__*/Fn(([color]) => {\n  const a = color.mul(0.9478672986).add(0.0521327014).pow(2.4);\n  const b = color.mul(0.0773993808);\n  const factor = color.lessThanEqual(0.04045);\n  const rgbResult = mix(a, b, factor);\n  return rgbResult;\n}).setLayout({\n  name: 'sRGBTransferEOTF',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }]\n});\nconst sRGBTransferOETF = /*@__PURE__*/Fn(([color]) => {\n  const a = color.pow(0.41666).mul(1.055).sub(0.055);\n  const b = color.mul(12.92);\n  const factor = color.lessThanEqual(0.0031308);\n  const rgbResult = mix(a, b, factor);\n  return rgbResult;\n}).setLayout({\n  name: 'sRGBTransferOETF',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }]\n});\nconst WORKING_COLOR_SPACE = 'WorkingColorSpace';\nconst OUTPUT_COLOR_SPACE = 'OutputColorSpace';\nclass ColorSpaceNode extends TempNode {\n  static get type() {\n    return 'ColorSpaceNode';\n  }\n  constructor(colorNode, source, target) {\n    super('vec4');\n    this.colorNode = colorNode;\n    this.source = source;\n    this.target = target;\n  }\n  resolveColorSpace(builder, colorSpace) {\n    if (colorSpace === WORKING_COLOR_SPACE) {\n      return ColorManagement.workingColorSpace;\n    } else if (colorSpace === OUTPUT_COLOR_SPACE) {\n      return builder.context.outputColorSpace || builder.renderer.outputColorSpace;\n    }\n    return colorSpace;\n  }\n  setup(builder) {\n    const {\n      colorNode\n    } = this;\n    const source = this.resolveColorSpace(builder, this.source);\n    const target = this.resolveColorSpace(builder, this.target);\n    let outputNode = colorNode;\n    if (ColorManagement.enabled === false || source === target || !source || !target) {\n      return outputNode;\n    }\n    if (ColorManagement.getTransfer(source) === SRGBTransfer) {\n      outputNode = vec4(sRGBTransferEOTF(outputNode.rgb), outputNode.a);\n    }\n    if (ColorManagement.getPrimaries(source) !== ColorManagement.getPrimaries(target)) {\n      outputNode = vec4(mat3(ColorManagement._getMatrix(new Matrix3(), source, target)).mul(outputNode.rgb), outputNode.a);\n    }\n    if (ColorManagement.getTransfer(target) === SRGBTransfer) {\n      outputNode = vec4(sRGBTransferOETF(outputNode.rgb), outputNode.a);\n    }\n    return outputNode;\n  }\n}\nconst toOutputColorSpace = node => nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, OUTPUT_COLOR_SPACE));\nconst toWorkingColorSpace = node => nodeObject(new ColorSpaceNode(nodeObject(node), OUTPUT_COLOR_SPACE, WORKING_COLOR_SPACE));\nconst workingToColorSpace = (node, colorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, colorSpace));\nconst colorSpaceToWorking = (node, colorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), colorSpace, WORKING_COLOR_SPACE));\nconst convertColorSpace = (node, sourceColorSpace, targetColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), sourceColorSpace, targetColorSpace));\naddMethodChaining('toOutputColorSpace', toOutputColorSpace);\naddMethodChaining('toWorkingColorSpace', toWorkingColorSpace);\naddMethodChaining('workingToColorSpace', workingToColorSpace);\naddMethodChaining('colorSpaceToWorking', colorSpaceToWorking);\nlet ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {\n  static get type() {\n    return 'ReferenceElementNode';\n  }\n  constructor(referenceNode, indexNode) {\n    super(referenceNode, indexNode);\n    this.referenceNode = referenceNode;\n    this.isReferenceElementNode = true;\n  }\n  getNodeType() {\n    return this.referenceNode.uniformType;\n  }\n  generate(builder) {\n    const snippet = super.generate(builder);\n    const arrayType = this.referenceNode.getNodeType();\n    const elementType = this.getNodeType();\n    return builder.format(snippet, arrayType, elementType);\n  }\n};\nclass ReferenceBaseNode extends Node {\n  static get type() {\n    return 'ReferenceBaseNode';\n  }\n  constructor(property, uniformType, object = null, count = null) {\n    super();\n    this.property = property;\n    this.uniformType = uniformType;\n    this.object = object;\n    this.count = count;\n    this.properties = property.split('.');\n    this.reference = object;\n    this.node = null;\n    this.group = null;\n    this.updateType = NodeUpdateType.OBJECT;\n  }\n  setGroup(group) {\n    this.group = group;\n    return this;\n  }\n  element(indexNode) {\n    return nodeObject(new ReferenceElementNode$1(this, nodeObject(indexNode)));\n  }\n  setNodeType(uniformType) {\n    const node = uniform(null, uniformType).getSelf();\n    if (this.group !== null) {\n      node.setGroup(this.group);\n    }\n    this.node = node;\n  }\n  getNodeType(builder) {\n    if (this.node === null) {\n      this.updateReference(builder);\n      this.updateValue();\n    }\n    return this.node.getNodeType(builder);\n  }\n  getValueFromReference(object = this.reference) {\n    const {\n      properties\n    } = this;\n    let value = object[properties[0]];\n    for (let i = 1; i < properties.length; i++) {\n      value = value[properties[i]];\n    }\n    return value;\n  }\n  updateReference(state) {\n    this.reference = this.object !== null ? this.object : state.object;\n    return this.reference;\n  }\n  setup() {\n    this.updateValue();\n    return this.node;\n  }\n  update(/*frame*/\n  ) {\n    this.updateValue();\n  }\n  updateValue() {\n    if (this.node === null) this.setNodeType(this.uniformType);\n    const value = this.getValueFromReference();\n    if (Array.isArray(value)) {\n      this.node.array = value;\n    } else {\n      this.node.value = value;\n    }\n  }\n}\nconst reference$1 = (name, type, object) => nodeObject(new ReferenceBaseNode(name, type, object));\nclass RendererReferenceNode extends ReferenceBaseNode {\n  static get type() {\n    return 'RendererReferenceNode';\n  }\n  constructor(property, inputType, renderer = null) {\n    super(property, inputType, renderer);\n    this.renderer = renderer;\n    this.setGroup(renderGroup);\n  }\n  updateReference(state) {\n    this.reference = this.renderer !== null ? this.renderer : state.renderer;\n    return this.reference;\n  }\n}\nconst rendererReference = (name, type, renderer) => nodeObject(new RendererReferenceNode(name, type, renderer));\nclass ToneMappingNode extends TempNode {\n  static get type() {\n    return 'ToneMappingNode';\n  }\n  constructor(toneMapping, exposureNode = toneMappingExposure, colorNode = null) {\n    super('vec3');\n    this.toneMapping = toneMapping;\n    this.exposureNode = exposureNode;\n    this.colorNode = colorNode;\n  }\n  getCacheKey() {\n    return hash$1(super.getCacheKey(), this.toneMapping);\n  }\n  setup(builder) {\n    const colorNode = this.colorNode || builder.context.color;\n    const toneMapping = this.toneMapping;\n    if (toneMapping === NoToneMapping) return colorNode;\n    let outputNode = null;\n    const toneMappingFn = builder.renderer.library.getToneMappingFunction(toneMapping);\n    if (toneMappingFn !== null) {\n      outputNode = vec4(toneMappingFn(colorNode.rgb, this.exposureNode), colorNode.a);\n    } else {\n      console.error('ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping);\n      outputNode = colorNode;\n    }\n    return outputNode;\n  }\n}\nconst toneMapping = (mapping, exposure, color) => nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color)));\nconst toneMappingExposure = /*@__PURE__*/rendererReference('toneMappingExposure', 'float');\naddMethodChaining('toneMapping', (color, mapping, exposure) => toneMapping(mapping, exposure, color));\nclass BufferAttributeNode extends InputNode {\n  static get type() {\n    return 'BufferAttributeNode';\n  }\n  constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {\n    super(value, bufferType);\n    this.isBufferNode = true;\n    this.bufferType = bufferType;\n    this.bufferStride = bufferStride;\n    this.bufferOffset = bufferOffset;\n    this.usage = StaticDrawUsage;\n    this.instanced = false;\n    this.attribute = null;\n    this.global = true;\n    if (value && value.isBufferAttribute === true) {\n      this.attribute = value;\n      this.usage = value.usage;\n      this.instanced = value.isInstancedBufferAttribute;\n    }\n  }\n  getHash(builder) {\n    if (this.bufferStride === 0 && this.bufferOffset === 0) {\n      let bufferData = builder.globalCache.getData(this.value);\n      if (bufferData === undefined) {\n        bufferData = {\n          node: this\n        };\n        builder.globalCache.setData(this.value, bufferData);\n      }\n      return bufferData.node.uuid;\n    }\n    return this.uuid;\n  }\n  getNodeType(builder) {\n    if (this.bufferType === null) {\n      this.bufferType = builder.getTypeFromAttribute(this.attribute);\n    }\n    return this.bufferType;\n  }\n  setup(builder) {\n    if (this.attribute !== null) return;\n    const type = this.getNodeType(builder);\n    const array = this.value;\n    const itemSize = builder.getTypeLength(type);\n    const stride = this.bufferStride || itemSize;\n    const offset = this.bufferOffset;\n    const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer(array, stride);\n    const bufferAttribute = new InterleavedBufferAttribute(buffer, itemSize, offset);\n    buffer.setUsage(this.usage);\n    this.attribute = bufferAttribute;\n    this.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute\n  }\n  generate(builder) {\n    const nodeType = this.getNodeType(builder);\n    const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);\n    const propertyName = builder.getPropertyName(nodeAttribute);\n    let output = null;\n    if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {\n      this.name = propertyName;\n      output = propertyName;\n    } else {\n      const nodeVarying = varying(this);\n      output = nodeVarying.build(builder, nodeType);\n    }\n    return output;\n  }\n  getInputType(/*builder*/\n  ) {\n    return 'bufferAttribute';\n  }\n  setUsage(value) {\n    this.usage = value;\n    if (this.attribute && this.attribute.isBufferAttribute === true) {\n      this.attribute.usage = value;\n    }\n    return this;\n  }\n  setInstanced(value) {\n    this.instanced = value;\n    return this;\n  }\n}\nconst bufferAttribute = (array, type, stride, offset) => nodeObject(new BufferAttributeNode(array, type, stride, offset));\nconst dynamicBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);\nconst instancedBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setInstanced(true);\nconst instancedDynamicBufferAttribute = (array, type, stride, offset) => dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);\naddMethodChaining('toAttribute', bufferNode => bufferAttribute(bufferNode.value));\nclass ComputeNode extends Node {\n  static get type() {\n    return 'ComputeNode';\n  }\n  constructor(computeNode, count, workgroupSize = [64]) {\n    super('void');\n    this.isComputeNode = true;\n    this.computeNode = computeNode;\n    this.count = count;\n    this.workgroupSize = workgroupSize;\n    this.dispatchCount = 0;\n    this.version = 1;\n    this.updateBeforeType = NodeUpdateType.OBJECT;\n    this.onInitFunction = null;\n    this.updateDispatchCount();\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  updateDispatchCount() {\n    const {\n      count,\n      workgroupSize\n    } = this;\n    let size = workgroupSize[0];\n    for (let i = 1; i < workgroupSize.length; i++) size *= workgroupSize[i];\n    this.dispatchCount = Math.ceil(count / size);\n  }\n  onInit(callback) {\n    this.onInitFunction = callback;\n    return this;\n  }\n  updateBefore({\n    renderer\n  }) {\n    renderer.compute(this);\n  }\n  generate(builder) {\n    const {\n      shaderStage\n    } = builder;\n    if (shaderStage === 'compute') {\n      const snippet = this.computeNode.build(builder, 'void');\n      if (snippet !== '') {\n        builder.addLineFlowCode(snippet, this);\n      }\n    }\n  }\n}\nconst compute = (node, count, workgroupSize) => nodeObject(new ComputeNode(nodeObject(node), count, workgroupSize));\naddMethodChaining('compute', compute);\nclass CacheNode extends Node {\n  static get type() {\n    return 'CacheNode';\n  }\n  constructor(node, parent = true) {\n    super();\n    this.node = node;\n    this.parent = parent;\n    this.isCacheNode = true;\n  }\n  getNodeType(builder) {\n    return this.node.getNodeType(builder);\n  }\n  build(builder, ...params) {\n    const previousCache = builder.getCache();\n    const cache = builder.getCacheFromNode(this, this.parent);\n    builder.setCache(cache);\n    const data = this.node.build(builder, ...params);\n    builder.setCache(previousCache);\n    return data;\n  }\n}\nconst cache = (node, ...params) => nodeObject(new CacheNode(nodeObject(node), ...params));\naddMethodChaining('cache', cache);\nclass BypassNode extends Node {\n  static get type() {\n    return 'BypassNode';\n  }\n  constructor(returnNode, callNode) {\n    super();\n    this.isBypassNode = true;\n    this.outputNode = returnNode;\n    this.callNode = callNode;\n  }\n  getNodeType(builder) {\n    return this.outputNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const snippet = this.callNode.build(builder, 'void');\n    if (snippet !== '') {\n      builder.addLineFlowCode(snippet, this);\n    }\n    return this.outputNode.build(builder);\n  }\n}\nconst bypass = /*@__PURE__*/nodeProxy(BypassNode);\naddMethodChaining('bypass', bypass);\nclass RemapNode extends Node {\n  static get type() {\n    return 'RemapNode';\n  }\n  constructor(node, inLowNode, inHighNode, outLowNode = float(0), outHighNode = float(1)) {\n    super();\n    this.node = node;\n    this.inLowNode = inLowNode;\n    this.inHighNode = inHighNode;\n    this.outLowNode = outLowNode;\n    this.outHighNode = outHighNode;\n    this.doClamp = true;\n  }\n  setup() {\n    const {\n      node,\n      inLowNode,\n      inHighNode,\n      outLowNode,\n      outHighNode,\n      doClamp\n    } = this;\n    let t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));\n    if (doClamp === true) t = t.clamp();\n    return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);\n  }\n}\nconst remap = /*@__PURE__*/nodeProxy(RemapNode, null, null, {\n  doClamp: false\n});\nconst remapClamp = /*@__PURE__*/nodeProxy(RemapNode);\naddMethodChaining('remap', remap);\naddMethodChaining('remapClamp', remapClamp);\nclass ExpressionNode extends Node {\n  static get type() {\n    return 'ExpressionNode';\n  }\n  constructor(snippet = '', nodeType = 'void') {\n    super(nodeType);\n    this.snippet = snippet;\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    const snippet = this.snippet;\n    if (type === 'void') {\n      builder.addLineFlowCode(snippet, this);\n    } else {\n      return builder.format(`( ${snippet} )`, type, output);\n    }\n  }\n}\nconst expression = /*@__PURE__*/nodeProxy(ExpressionNode);\nconst Discard = conditional => (conditional ? select(conditional, expression('discard')) : expression('discard')).append();\nconst Return = () => expression('return').append();\naddMethodChaining('discard', Discard);\nclass RenderOutputNode extends TempNode {\n  static get type() {\n    return 'RenderOutputNode';\n  }\n  constructor(colorNode, toneMapping, outputColorSpace) {\n    super('vec4');\n    this.colorNode = colorNode;\n    this.toneMapping = toneMapping;\n    this.outputColorSpace = outputColorSpace;\n    this.isRenderOutput = true;\n  }\n  setup({\n    context\n  }) {\n    let outputNode = this.colorNode || context.color;\n\n    // tone mapping\n\n    const toneMapping = (this.toneMapping !== null ? this.toneMapping : context.toneMapping) || NoToneMapping;\n    const outputColorSpace = (this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace) || NoColorSpace;\n    if (toneMapping !== NoToneMapping) {\n      outputNode = outputNode.toneMapping(toneMapping);\n    }\n\n    // working to output color space\n\n    if (outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace) {\n      outputNode = outputNode.workingToColorSpace(outputColorSpace);\n    }\n    return outputNode;\n  }\n}\nconst renderOutput = (color, toneMapping = null, outputColorSpace = null) => nodeObject(new RenderOutputNode(nodeObject(color), toneMapping, outputColorSpace));\naddMethodChaining('renderOutput', renderOutput);\n\n// Non-PURE exports list, side-effects are required here.\n// TSL Base Syntax\n\nfunction addNodeElement(name /*, nodeElement*/) {\n  console.warn('THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add', name);\n}\nclass AttributeNode extends Node {\n  static get type() {\n    return 'AttributeNode';\n  }\n  constructor(attributeName, nodeType = null) {\n    super(nodeType);\n    this.global = true;\n    this._attributeName = attributeName;\n  }\n  getHash(builder) {\n    return this.getAttributeName(builder);\n  }\n  getNodeType(builder) {\n    let nodeType = this.nodeType;\n    if (nodeType === null) {\n      const attributeName = this.getAttributeName(builder);\n      if (builder.hasGeometryAttribute(attributeName)) {\n        const attribute = builder.geometry.getAttribute(attributeName);\n        nodeType = builder.getTypeFromAttribute(attribute);\n      } else {\n        nodeType = 'float';\n      }\n    }\n    return nodeType;\n  }\n  setAttributeName(attributeName) {\n    this._attributeName = attributeName;\n    return this;\n  }\n  getAttributeName(/*builder*/\n  ) {\n    return this._attributeName;\n  }\n  generate(builder) {\n    const attributeName = this.getAttributeName(builder);\n    const nodeType = this.getNodeType(builder);\n    const geometryAttribute = builder.hasGeometryAttribute(attributeName);\n    if (geometryAttribute === true) {\n      const attribute = builder.geometry.getAttribute(attributeName);\n      const attributeType = builder.getTypeFromAttribute(attribute);\n      const nodeAttribute = builder.getAttribute(attributeName, attributeType);\n      if (builder.shaderStage === 'vertex') {\n        return builder.format(nodeAttribute.name, attributeType, nodeType);\n      } else {\n        const nodeVarying = varying(this);\n        return nodeVarying.build(builder, nodeType);\n      }\n    } else {\n      console.warn(`AttributeNode: Vertex attribute \"${attributeName}\" not found on geometry.`);\n      return builder.generateConst(nodeType);\n    }\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.global = this.global;\n    data._attributeName = this._attributeName;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.global = data.global;\n    this._attributeName = data._attributeName;\n  }\n}\nconst attribute = (name, nodeType) => nodeObject(new AttributeNode(name, nodeType));\nconst uv = index => attribute('uv' + (index > 0 ? index : ''), 'vec2');\nclass TextureSizeNode extends Node {\n  static get type() {\n    return 'TextureSizeNode';\n  }\n  constructor(textureNode, levelNode = null) {\n    super('uvec2');\n    this.isTextureSizeNode = true;\n    this.textureNode = textureNode;\n    this.levelNode = levelNode;\n  }\n  generate(builder, output) {\n    const textureProperty = this.textureNode.build(builder, 'property');\n    const level = this.levelNode === null ? '0' : this.levelNode.build(builder, 'int');\n    return builder.format(`${builder.getMethod('textureDimensions')}( ${textureProperty}, ${level} )`, this.getNodeType(builder), output);\n  }\n}\nconst textureSize = /*@__PURE__*/nodeProxy(TextureSizeNode);\nclass MaxMipLevelNode extends UniformNode {\n  static get type() {\n    return 'MaxMipLevelNode';\n  }\n  constructor(textureNode) {\n    super(0);\n    this._textureNode = textureNode;\n    this.updateType = NodeUpdateType.FRAME;\n  }\n  get textureNode() {\n    return this._textureNode;\n  }\n  get texture() {\n    return this._textureNode.value;\n  }\n  update() {\n    const texture = this.texture;\n    const images = texture.images;\n    const image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture.image;\n    if (image && image.width !== undefined) {\n      const {\n        width,\n        height\n      } = image;\n      this.value = Math.log2(Math.max(width, height));\n    }\n  }\n}\nconst maxMipLevel = /*@__PURE__*/nodeProxy(MaxMipLevelNode);\nclass TextureNode extends UniformNode {\n  static get type() {\n    return 'TextureNode';\n  }\n  constructor(value, uvNode = null, levelNode = null, biasNode = null) {\n    super(value);\n    this.isTextureNode = true;\n    this.uvNode = uvNode;\n    this.levelNode = levelNode;\n    this.biasNode = biasNode;\n    this.compareNode = null;\n    this.depthNode = null;\n    this.gradNode = null;\n    this.sampler = true;\n    this.updateMatrix = false;\n    this.updateType = NodeUpdateType.NONE;\n    this.referenceNode = null;\n    this._value = value;\n    this._matrixUniform = null;\n    this.setUpdateMatrix(uvNode === null);\n  }\n  set value(value) {\n    if (this.referenceNode) {\n      this.referenceNode.value = value;\n    } else {\n      this._value = value;\n    }\n  }\n  get value() {\n    return this.referenceNode ? this.referenceNode.value : this._value;\n  }\n  getUniformHash(/*builder*/\n  ) {\n    return this.value.uuid;\n  }\n  getNodeType(/*builder*/\n  ) {\n    if (this.value.isDepthTexture === true) return 'float';\n    if (this.value.type === UnsignedIntType) {\n      return 'uvec4';\n    } else if (this.value.type === IntType) {\n      return 'ivec4';\n    }\n    return 'vec4';\n  }\n  getInputType(/*builder*/\n  ) {\n    return 'texture';\n  }\n  getDefaultUV() {\n    return uv(this.value.channel);\n  }\n  updateReference(/*state*/\n  ) {\n    return this.value;\n  }\n  getTransformedUV(uvNode) {\n    if (this._matrixUniform === null) this._matrixUniform = uniform(this.value.matrix);\n    return this._matrixUniform.mul(vec3(uvNode, 1)).xy;\n  }\n  setUpdateMatrix(value) {\n    this.updateMatrix = value;\n    this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;\n    return this;\n  }\n  setupUV(builder, uvNode) {\n    const texture = this.value;\n    if (builder.isFlipY() && (texture.image instanceof ImageBitmap && texture.flipY === true || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true)) {\n      if (this.sampler) {\n        uvNode = uvNode.flipY();\n      } else {\n        uvNode = uvNode.setY(int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1));\n      }\n    }\n    return uvNode;\n  }\n  setup(builder) {\n    const properties = builder.getNodeProperties(this);\n    properties.referenceNode = this.referenceNode;\n\n    //\n\n    let uvNode = this.uvNode;\n    if ((uvNode === null || builder.context.forceUVContext === true) && builder.context.getUV) {\n      uvNode = builder.context.getUV(this);\n    }\n    if (!uvNode) uvNode = this.getDefaultUV();\n    if (this.updateMatrix === true) {\n      uvNode = this.getTransformedUV(uvNode);\n    }\n    uvNode = this.setupUV(builder, uvNode);\n\n    //\n\n    let levelNode = this.levelNode;\n    if (levelNode === null && builder.context.getTextureLevel) {\n      levelNode = builder.context.getTextureLevel(this);\n    }\n\n    //\n\n    properties.uvNode = uvNode;\n    properties.levelNode = levelNode;\n    properties.biasNode = this.biasNode;\n    properties.compareNode = this.compareNode;\n    properties.gradNode = this.gradNode;\n    properties.depthNode = this.depthNode;\n  }\n  generateUV(builder, uvNode) {\n    return uvNode.build(builder, this.sampler === true ? 'vec2' : 'ivec2');\n  }\n  generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet) {\n    const texture = this.value;\n    let snippet;\n    if (levelSnippet) {\n      snippet = builder.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet);\n    } else if (biasSnippet) {\n      snippet = builder.generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, depthSnippet);\n    } else if (gradSnippet) {\n      snippet = builder.generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet);\n    } else if (compareSnippet) {\n      snippet = builder.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet);\n    } else if (this.sampler === false) {\n      snippet = builder.generateTextureLoad(texture, textureProperty, uvSnippet, depthSnippet);\n    } else {\n      snippet = builder.generateTexture(texture, textureProperty, uvSnippet, depthSnippet);\n    }\n    return snippet;\n  }\n  generate(builder, output) {\n    const properties = builder.getNodeProperties(this);\n    const texture = this.value;\n    if (!texture || texture.isTexture !== true) {\n      throw new Error('TextureNode: Need a three.js texture.');\n    }\n    const textureProperty = super.generate(builder, 'property');\n    if (output === 'sampler') {\n      return textureProperty + '_sampler';\n    } else if (builder.isReference(output)) {\n      return textureProperty;\n    } else {\n      const nodeData = builder.getDataFromNode(this);\n      let propertyName = nodeData.propertyName;\n      if (propertyName === undefined) {\n        const {\n          uvNode,\n          levelNode,\n          biasNode,\n          compareNode,\n          depthNode,\n          gradNode\n        } = properties;\n        const uvSnippet = this.generateUV(builder, uvNode);\n        const levelSnippet = levelNode ? levelNode.build(builder, 'float') : null;\n        const biasSnippet = biasNode ? biasNode.build(builder, 'float') : null;\n        const depthSnippet = depthNode ? depthNode.build(builder, 'int') : null;\n        const compareSnippet = compareNode ? compareNode.build(builder, 'float') : null;\n        const gradSnippet = gradNode ? [gradNode[0].build(builder, 'vec2'), gradNode[1].build(builder, 'vec2')] : null;\n        const nodeVar = builder.getVarFromNode(this);\n        propertyName = builder.getPropertyName(nodeVar);\n        const snippet = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet);\n        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);\n        nodeData.snippet = snippet;\n        nodeData.propertyName = propertyName;\n      }\n      let snippet = propertyName;\n      const nodeType = this.getNodeType(builder);\n      if (builder.needsToWorkingColorSpace(texture)) {\n        snippet = colorSpaceToWorking(expression(snippet, nodeType), texture.colorSpace).setup(builder).build(builder, nodeType);\n      }\n      return builder.format(snippet, nodeType, output);\n    }\n  }\n  setSampler(value) {\n    this.sampler = value;\n    return this;\n  }\n  getSampler() {\n    return this.sampler;\n  }\n\n  // @TODO: Move to TSL\n\n  uv(uvNode) {\n    const textureNode = this.clone();\n    textureNode.uvNode = nodeObject(uvNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n  blur(amountNode) {\n    const textureNode = this.clone();\n    textureNode.biasNode = nodeObject(amountNode).mul(maxMipLevel(textureNode));\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n  level(levelNode) {\n    const textureNode = this.clone();\n    textureNode.levelNode = nodeObject(levelNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n  size(levelNode) {\n    return textureSize(this, levelNode);\n  }\n  bias(biasNode) {\n    const textureNode = this.clone();\n    textureNode.biasNode = nodeObject(biasNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n  compare(compareNode) {\n    const textureNode = this.clone();\n    textureNode.compareNode = nodeObject(compareNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n  grad(gradNodeX, gradNodeY) {\n    const textureNode = this.clone();\n    textureNode.gradNode = [nodeObject(gradNodeX), nodeObject(gradNodeY)];\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n  depth(depthNode) {\n    const textureNode = this.clone();\n    textureNode.depthNode = nodeObject(depthNode);\n    textureNode.referenceNode = this.getSelf();\n    return nodeObject(textureNode);\n  }\n\n  // --\n\n  serialize(data) {\n    super.serialize(data);\n    data.value = this.value.toJSON(data.meta).uuid;\n    data.sampler = this.sampler;\n    data.updateMatrix = this.updateMatrix;\n    data.updateType = this.updateType;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.value = data.meta.textures[data.value];\n    this.sampler = data.sampler;\n    this.updateMatrix = data.updateMatrix;\n    this.updateType = data.updateType;\n  }\n  update() {\n    const texture = this.value;\n    const matrixUniform = this._matrixUniform;\n    if (matrixUniform !== null) matrixUniform.value = texture.matrix;\n    if (texture.matrixAutoUpdate === true) {\n      texture.updateMatrix();\n    }\n  }\n  clone() {\n    const newNode = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);\n    newNode.sampler = this.sampler;\n    return newNode;\n  }\n}\nconst texture = /*@__PURE__*/nodeProxy(TextureNode);\nconst textureLoad = (...params) => texture(...params).setSampler(false);\n\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\nconst sampler = aTexture => (aTexture.isNode === true ? aTexture : texture(aTexture)).convert('sampler');\nconst cameraNear = /*@__PURE__*/uniform('float').label('cameraNear').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}) => camera.near);\nconst cameraFar = /*@__PURE__*/uniform('float').label('cameraFar').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}) => camera.far);\nconst cameraProjectionMatrix = /*@__PURE__*/uniform('mat4').label('cameraProjectionMatrix').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}) => camera.projectionMatrix);\nconst cameraProjectionMatrixInverse = /*@__PURE__*/uniform('mat4').label('cameraProjectionMatrixInverse').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}) => camera.projectionMatrixInverse);\nconst cameraViewMatrix = /*@__PURE__*/uniform('mat4').label('cameraViewMatrix').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}) => camera.matrixWorldInverse);\nconst cameraWorldMatrix = /*@__PURE__*/uniform('mat4').label('cameraWorldMatrix').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}) => camera.matrixWorld);\nconst cameraNormalMatrix = /*@__PURE__*/uniform('mat3').label('cameraNormalMatrix').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}) => camera.normalMatrix);\nconst cameraPosition = /*@__PURE__*/uniform(new Vector3()).label('cameraPosition').setGroup(renderGroup).onRenderUpdate(({\n  camera\n}, self) => self.value.setFromMatrixPosition(camera.matrixWorld));\nclass Object3DNode extends Node {\n  static get type() {\n    return 'Object3DNode';\n  }\n  constructor(scope, object3d = null) {\n    super();\n    this.scope = scope;\n    this.object3d = object3d;\n    this.updateType = NodeUpdateType.OBJECT;\n    this._uniformNode = new UniformNode(null);\n  }\n  getNodeType() {\n    const scope = this.scope;\n    if (scope === Object3DNode.WORLD_MATRIX) {\n      return 'mat4';\n    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE) {\n      return 'vec3';\n    }\n  }\n  update(frame) {\n    const object = this.object3d;\n    const uniformNode = this._uniformNode;\n    const scope = this.scope;\n    if (scope === Object3DNode.WORLD_MATRIX) {\n      uniformNode.value = object.matrixWorld;\n    } else if (scope === Object3DNode.POSITION) {\n      uniformNode.value = uniformNode.value || new Vector3();\n      uniformNode.value.setFromMatrixPosition(object.matrixWorld);\n    } else if (scope === Object3DNode.SCALE) {\n      uniformNode.value = uniformNode.value || new Vector3();\n      uniformNode.value.setFromMatrixScale(object.matrixWorld);\n    } else if (scope === Object3DNode.DIRECTION) {\n      uniformNode.value = uniformNode.value || new Vector3();\n      object.getWorldDirection(uniformNode.value);\n    } else if (scope === Object3DNode.VIEW_POSITION) {\n      const camera = frame.camera;\n      uniformNode.value = uniformNode.value || new Vector3();\n      uniformNode.value.setFromMatrixPosition(object.matrixWorld);\n      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);\n    }\n  }\n  generate(builder) {\n    const scope = this.scope;\n    if (scope === Object3DNode.WORLD_MATRIX) {\n      this._uniformNode.nodeType = 'mat4';\n    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE) {\n      this._uniformNode.nodeType = 'vec3';\n    }\n    return this._uniformNode.build(builder);\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.scope = this.scope;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.scope = data.scope;\n  }\n}\nObject3DNode.WORLD_MATRIX = 'worldMatrix';\nObject3DNode.POSITION = 'position';\nObject3DNode.SCALE = 'scale';\nObject3DNode.VIEW_POSITION = 'viewPosition';\nObject3DNode.DIRECTION = 'direction';\nconst objectDirection = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.DIRECTION);\nconst objectWorldMatrix = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX);\nconst objectPosition = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.POSITION);\nconst objectScale = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.SCALE);\nconst objectViewPosition = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.VIEW_POSITION);\nclass ModelNode extends Object3DNode {\n  static get type() {\n    return 'ModelNode';\n  }\n  constructor(scope) {\n    super(scope);\n  }\n  update(frame) {\n    this.object3d = frame.object;\n    super.update(frame);\n  }\n}\nconst modelDirection = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.DIRECTION);\nconst modelWorldMatrix = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.WORLD_MATRIX);\nconst modelPosition = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.POSITION);\nconst modelScale = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.SCALE);\nconst modelViewPosition = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);\nconst modelNormalMatrix = /*@__PURE__*/uniform(new Matrix3()).onObjectUpdate(({\n  object\n}, self) => self.value.getNormalMatrix(object.matrixWorld));\nconst modelWorldMatrixInverse = /*@__PURE__*/uniform(new Matrix4()).onObjectUpdate(({\n  object\n}, self) => self.value.copy(object.matrixWorld).invert());\nconst modelViewMatrix = /*@__PURE__*/cameraViewMatrix.mul(modelWorldMatrix).toVar('modelViewMatrix');\nconst highPrecisionModelViewMatrix = /*@__PURE__*/Fn(builder => {\n  builder.context.isHighPrecisionModelViewMatrix = true;\n  return uniform('mat4').onObjectUpdate(({\n    object,\n    camera\n  }) => {\n    return object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n  });\n}).once()().toVar('highPrecisionModelViewMatrix');\nconst highPrecisionModelNormalViewMatrix = /*@__PURE__*/Fn(builder => {\n  const isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;\n  return uniform('mat3').onObjectUpdate(({\n    object,\n    camera\n  }) => {\n    if (isHighPrecisionModelViewMatrix !== true) {\n      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n    }\n    return object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n  });\n}).once()().toVar('highPrecisionModelNormalMatrix');\nconst positionGeometry = /*@__PURE__*/attribute('position', 'vec3');\nconst positionLocal = /*@__PURE__*/positionGeometry.varying('positionLocal');\nconst positionPrevious = /*@__PURE__*/positionGeometry.varying('positionPrevious');\nconst positionWorld = /*@__PURE__*/modelWorldMatrix.mul(positionLocal).xyz.varying('v_positionWorld');\nconst positionWorldDirection = /*@__PURE__*/positionLocal.transformDirection(modelWorldMatrix).varying('v_positionWorldDirection').normalize().toVar('positionWorldDirection');\nconst positionView = /*@__PURE__*/modelViewMatrix.mul(positionLocal).xyz.varying('v_positionView');\nconst positionViewDirection = /*@__PURE__*/positionView.negate().varying('v_positionViewDirection').normalize().toVar('positionViewDirection');\nclass FrontFacingNode extends Node {\n  static get type() {\n    return 'FrontFacingNode';\n  }\n  constructor() {\n    super('bool');\n    this.isFrontFacingNode = true;\n  }\n  generate(builder) {\n    const {\n      renderer,\n      material\n    } = builder;\n    if (renderer.coordinateSystem === WebGLCoordinateSystem) {\n      if (material.side === BackSide) {\n        return 'false';\n      }\n    }\n    return builder.getFrontFacing();\n  }\n}\nconst frontFacing = /*@__PURE__*/nodeImmutable(FrontFacingNode);\nconst faceDirection = /*@__PURE__*/float(frontFacing).mul(2.0).sub(1.0);\nconst normalGeometry = /*@__PURE__*/attribute('normal', 'vec3');\nconst normalLocal = /*@__PURE__*/Fn(builder => {\n  if (builder.geometry.hasAttribute('normal') === false) {\n    console.warn('TSL.NormalNode: Vertex attribute \"normal\" not found on geometry.');\n    return vec3(0, 1, 0);\n  }\n  return normalGeometry;\n}, 'vec3').once()().toVar('normalLocal');\nconst normalFlat = /*@__PURE__*/positionView.dFdx().cross(positionView.dFdy()).normalize().toVar('normalFlat');\nconst normalView = /*@__PURE__*/Fn(builder => {\n  let node;\n  if (builder.material.flatShading === true) {\n    node = normalFlat;\n  } else {\n    node = varying(transformNormalToView(normalLocal), 'v_normalView').normalize();\n  }\n  return node;\n}, 'vec3').once()().toVar('normalView');\nconst normalWorld = /*@__PURE__*/varying(normalView.transformDirection(cameraViewMatrix), 'v_normalWorld').normalize().toVar('normalWorld');\nconst transformedNormalView = /*@__PURE__*/Fn(builder => {\n  return builder.context.setupNormal();\n}, 'vec3').once()().mul(faceDirection).toVar('transformedNormalView');\nconst transformedNormalWorld = /*@__PURE__*/transformedNormalView.transformDirection(cameraViewMatrix).toVar('transformedNormalWorld');\nconst transformedClearcoatNormalView = /*@__PURE__*/Fn(builder => {\n  return builder.context.setupClearcoatNormal();\n}, 'vec3').once()().mul(faceDirection).toVar('transformedClearcoatNormalView');\nconst transformNormal = /*@__PURE__*/Fn(([normal, matrix = modelWorldMatrix]) => {\n  const m = mat3(matrix);\n  const transformedNormal = normal.div(vec3(m[0].dot(m[0]), m[1].dot(m[1]), m[2].dot(m[2])));\n  return m.mul(transformedNormal).xyz;\n});\nconst transformNormalToView = /*@__PURE__*/Fn(([normal], builder) => {\n  const modelNormalViewMatrix = builder.renderer.nodes.modelNormalViewMatrix;\n  if (modelNormalViewMatrix !== null) {\n    return modelNormalViewMatrix.transformDirection(normal);\n  }\n\n  //\n\n  const transformedNormal = modelNormalMatrix.mul(normal);\n  return cameraViewMatrix.transformDirection(transformedNormal);\n});\nconst materialRefractionRatio = /*@__PURE__*/uniform(0).onReference(({\n  material\n}) => material).onRenderUpdate(({\n  material\n}) => material.refractionRatio);\nconst reflectView = /*@__PURE__*/positionViewDirection.negate().reflect(transformedNormalView);\nconst refractView = /*@__PURE__*/positionViewDirection.negate().refract(transformedNormalView, materialRefractionRatio);\nconst reflectVector = /*@__PURE__*/reflectView.transformDirection(cameraViewMatrix).toVar('reflectVector');\nconst refractVector = /*@__PURE__*/refractView.transformDirection(cameraViewMatrix).toVar('reflectVector');\nclass CubeTextureNode extends TextureNode {\n  static get type() {\n    return 'CubeTextureNode';\n  }\n  constructor(value, uvNode = null, levelNode = null, biasNode = null) {\n    super(value, uvNode, levelNode, biasNode);\n    this.isCubeTextureNode = true;\n  }\n  getInputType(/*builder*/\n  ) {\n    return 'cubeTexture';\n  }\n  getDefaultUV() {\n    const texture = this.value;\n    if (texture.mapping === CubeReflectionMapping) {\n      return reflectVector;\n    } else if (texture.mapping === CubeRefractionMapping) {\n      return refractVector;\n    } else {\n      console.error('THREE.CubeTextureNode: Mapping \"%s\" not supported.', texture.mapping);\n      return vec3(0, 0, 0);\n    }\n  }\n  setUpdateMatrix(/*updateMatrix*/) {} // Ignore .updateMatrix for CubeTextureNode\n\n  setupUV(builder, uvNode) {\n    const texture = this.value;\n    if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem || !texture.isRenderTargetTexture) {\n      return vec3(uvNode.x.negate(), uvNode.yz);\n    } else {\n      return uvNode;\n    }\n  }\n  generateUV(builder, cubeUV) {\n    return cubeUV.build(builder, 'vec3');\n  }\n}\nconst cubeTexture = /*@__PURE__*/nodeProxy(CubeTextureNode);\nclass BufferNode extends UniformNode {\n  static get type() {\n    return 'BufferNode';\n  }\n  constructor(value, bufferType, bufferCount = 0) {\n    super(value, bufferType);\n    this.isBufferNode = true;\n    this.bufferType = bufferType;\n    this.bufferCount = bufferCount;\n  }\n  getElementType(builder) {\n    return this.getNodeType(builder);\n  }\n  getInputType(/*builder*/\n  ) {\n    return 'buffer';\n  }\n}\nconst buffer = (value, type, count) => nodeObject(new BufferNode(value, type, count));\nclass UniformArrayElementNode extends ArrayElementNode {\n  static get type() {\n    return 'UniformArrayElementNode';\n  }\n  constructor(arrayBuffer, indexNode) {\n    super(arrayBuffer, indexNode);\n    this.isArrayBufferElementNode = true;\n  }\n  generate(builder) {\n    const snippet = super.generate(builder);\n    const type = this.getNodeType();\n    return builder.format(snippet, 'vec4', type);\n  }\n}\nclass UniformArrayNode extends BufferNode {\n  static get type() {\n    return 'UniformArrayNode';\n  }\n  constructor(value, elementType = null) {\n    super(null, 'vec4');\n    this.array = value;\n    this.elementType = elementType;\n    this._elementType = null;\n    this._elementLength = 0;\n    this.updateType = NodeUpdateType.RENDER;\n    this.isArrayBufferNode = true;\n  }\n  getElementType() {\n    return this.elementType || this._elementType;\n  }\n  getElementLength() {\n    return this._elementLength;\n  }\n  update(/*frame*/\n  ) {\n    const {\n      array,\n      value\n    } = this;\n    const elementLength = this.getElementLength();\n    const elementType = this.getElementType();\n    if (elementLength === 1) {\n      for (let i = 0; i < array.length; i++) {\n        const index = i * 4;\n        value[index] = array[i];\n      }\n    } else if (elementType === 'color') {\n      for (let i = 0; i < array.length; i++) {\n        const index = i * 4;\n        const vector = array[i];\n        value[index] = vector.r;\n        value[index + 1] = vector.g;\n        value[index + 2] = vector.b || 0;\n        //value[ index + 3 ] = vector.a || 0;\n      }\n    } else {\n      for (let i = 0; i < array.length; i++) {\n        const index = i * 4;\n        const vector = array[i];\n        value[index] = vector.x;\n        value[index + 1] = vector.y;\n        value[index + 2] = vector.z || 0;\n        value[index + 3] = vector.w || 0;\n      }\n    }\n  }\n  setup(builder) {\n    const length = this.array.length;\n    this._elementType = this.elementType === null ? getValueType(this.array[0]) : this.elementType;\n    this._elementLength = builder.getTypeLength(this._elementType);\n    let arrayType = Float32Array;\n    if (this._elementType.charAt(0) === 'i') arrayType = Int32Array;else if (this._elementType.charAt(0) === 'u') arrayType = Uint32Array;\n    this.value = new arrayType(length * 4);\n    this.bufferCount = length;\n    this.bufferType = builder.changeComponentType('vec4', builder.getComponentType(this._elementType));\n    return super.setup(builder);\n  }\n  element(indexNode) {\n    return nodeObject(new UniformArrayElementNode(this, nodeObject(indexNode)));\n  }\n}\nconst uniformArray = (values, nodeType) => nodeObject(new UniformArrayNode(values, nodeType));\n\n//\n\nconst uniforms = (values, nodeType) => {\n  // @deprecated, r168\n\n  console.warn('TSL.UniformArrayNode: uniforms() has been renamed to uniformArray().');\n  return nodeObject(new UniformArrayNode(values, nodeType));\n};\nclass ReferenceElementNode extends ArrayElementNode {\n  static get type() {\n    return 'ReferenceElementNode';\n  }\n  constructor(referenceNode, indexNode) {\n    super(referenceNode, indexNode);\n    this.referenceNode = referenceNode;\n    this.isReferenceElementNode = true;\n  }\n  getNodeType() {\n    return this.referenceNode.uniformType;\n  }\n  generate(builder) {\n    const snippet = super.generate(builder);\n    const arrayType = this.referenceNode.getNodeType();\n    const elementType = this.getNodeType();\n    return builder.format(snippet, arrayType, elementType);\n  }\n}\n\n// TODO: Extends this from ReferenceBaseNode\nclass ReferenceNode extends Node {\n  static get type() {\n    return 'ReferenceNode';\n  }\n  constructor(property, uniformType, object = null, count = null) {\n    super();\n    this.property = property;\n    this.uniformType = uniformType;\n    this.object = object;\n    this.count = count;\n    this.properties = property.split('.');\n    this.reference = object;\n    this.node = null;\n    this.group = null;\n    this.name = null;\n    this.updateType = NodeUpdateType.OBJECT;\n  }\n  element(indexNode) {\n    return nodeObject(new ReferenceElementNode(this, nodeObject(indexNode)));\n  }\n  setGroup(group) {\n    this.group = group;\n    return this;\n  }\n  label(name) {\n    this.name = name;\n    return this;\n  }\n  setNodeType(uniformType) {\n    let node = null;\n    if (this.count !== null) {\n      node = buffer(null, uniformType, this.count);\n    } else if (Array.isArray(this.getValueFromReference())) {\n      node = uniformArray(null, uniformType);\n    } else if (uniformType === 'texture') {\n      node = texture(null);\n    } else if (uniformType === 'cubeTexture') {\n      node = cubeTexture(null);\n    } else {\n      node = uniform(null, uniformType);\n    }\n    if (this.group !== null) {\n      node.setGroup(this.group);\n    }\n    if (this.name !== null) node.label(this.name);\n    this.node = node.getSelf();\n  }\n  getNodeType(builder) {\n    if (this.node === null) {\n      this.updateReference(builder);\n      this.updateValue();\n    }\n    return this.node.getNodeType(builder);\n  }\n  getValueFromReference(object = this.reference) {\n    const {\n      properties\n    } = this;\n    let value = object[properties[0]];\n    for (let i = 1; i < properties.length; i++) {\n      value = value[properties[i]];\n    }\n    return value;\n  }\n  updateReference(state) {\n    this.reference = this.object !== null ? this.object : state.object;\n    return this.reference;\n  }\n  setup() {\n    this.updateValue();\n    return this.node;\n  }\n  update(/*frame*/\n  ) {\n    this.updateValue();\n  }\n  updateValue() {\n    if (this.node === null) this.setNodeType(this.uniformType);\n    const value = this.getValueFromReference();\n    if (Array.isArray(value)) {\n      this.node.array = value;\n    } else {\n      this.node.value = value;\n    }\n  }\n}\nconst reference = (name, type, object) => nodeObject(new ReferenceNode(name, type, object));\nconst referenceBuffer = (name, type, count, object) => nodeObject(new ReferenceNode(name, type, object, count));\nclass MaterialReferenceNode extends ReferenceNode {\n  static get type() {\n    return 'MaterialReferenceNode';\n  }\n  constructor(property, inputType, material = null) {\n    super(property, inputType, material);\n    this.material = material;\n\n    //this.updateType = NodeUpdateType.RENDER;\n\n    this.isMaterialReferenceNode = true;\n  }\n\n  /*setNodeType( node ) {\n  \t\tsuper.setNodeType( node );\n  \t\tthis.node.groupNode = renderGroup;\n  \t}*/\n\n  updateReference(state) {\n    this.reference = this.material !== null ? this.material : state.material;\n    return this.reference;\n  }\n}\nconst materialReference = (name, type, material) => nodeObject(new MaterialReferenceNode(name, type, material));\nconst tangentGeometry = /*@__PURE__*/Fn(builder => {\n  if (builder.geometry.hasAttribute('tangent') === false) {\n    builder.geometry.computeTangents();\n  }\n  return attribute('tangent', 'vec4');\n})();\nconst tangentLocal = /*@__PURE__*/tangentGeometry.xyz.toVar('tangentLocal');\nconst tangentView = /*@__PURE__*/modelViewMatrix.mul(vec4(tangentLocal, 0)).xyz.varying('v_tangentView').normalize().toVar('tangentView');\nconst tangentWorld = /*@__PURE__*/tangentView.transformDirection(cameraViewMatrix).varying('v_tangentWorld').normalize().toVar('tangentWorld');\nconst transformedTangentView = /*@__PURE__*/tangentView.toVar('transformedTangentView');\nconst transformedTangentWorld = /*@__PURE__*/transformedTangentView.transformDirection(cameraViewMatrix).normalize().toVar('transformedTangentWorld');\nconst getBitangent = crossNormalTangent => crossNormalTangent.mul(tangentGeometry.w).xyz;\nconst bitangentGeometry = /*@__PURE__*/varying(getBitangent(normalGeometry.cross(tangentGeometry)), 'v_bitangentGeometry').normalize().toVar('bitangentGeometry');\nconst bitangentLocal = /*@__PURE__*/varying(getBitangent(normalLocal.cross(tangentLocal)), 'v_bitangentLocal').normalize().toVar('bitangentLocal');\nconst bitangentView = /*@__PURE__*/varying(getBitangent(normalView.cross(tangentView)), 'v_bitangentView').normalize().toVar('bitangentView');\nconst bitangentWorld = /*@__PURE__*/varying(getBitangent(normalWorld.cross(tangentWorld)), 'v_bitangentWorld').normalize().toVar('bitangentWorld');\nconst transformedBitangentView = /*@__PURE__*/getBitangent(transformedNormalView.cross(transformedTangentView)).normalize().toVar('transformedBitangentView');\nconst transformedBitangentWorld = /*@__PURE__*/transformedBitangentView.transformDirection(cameraViewMatrix).normalize().toVar('transformedBitangentWorld');\nconst TBNViewMatrix = /*@__PURE__*/mat3(tangentView, bitangentView, normalView);\nconst parallaxDirection = /*@__PURE__*/positionViewDirection.mul(TBNViewMatrix) /*.normalize()*/;\nconst parallaxUV = (uv, scale) => uv.sub(parallaxDirection.mul(scale));\nconst transformedBentNormalView = /*@__PURE__*/(() => {\n  // https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy\n\n  let bentNormal = anisotropyB.cross(positionViewDirection);\n  bentNormal = bentNormal.cross(anisotropyB).normalize();\n  bentNormal = mix(bentNormal, transformedNormalView, anisotropy.mul(roughness.oneMinus()).oneMinus().pow2().pow2()).normalize();\n  return bentNormal;\n})();\n\n// Normal Mapping Without Precomputed Tangents\n// http://www.thetenthplanet.de/archives/1180\n\nconst perturbNormal2Arb = /*@__PURE__*/Fn(inputs => {\n  const {\n    eye_pos,\n    surf_norm,\n    mapN,\n    uv\n  } = inputs;\n  const q0 = eye_pos.dFdx();\n  const q1 = eye_pos.dFdy();\n  const st0 = uv.dFdx();\n  const st1 = uv.dFdy();\n  const N = surf_norm; // normalized\n\n  const q1perp = q1.cross(N);\n  const q0perp = N.cross(q0);\n  const T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));\n  const B = q1perp.mul(st0.y).add(q0perp.mul(st1.y));\n  const det = T.dot(T).max(B.dot(B));\n  const scale = faceDirection.mul(det.inverseSqrt());\n  return add(T.mul(mapN.x, scale), B.mul(mapN.y, scale), N.mul(mapN.z)).normalize();\n});\nclass NormalMapNode extends TempNode {\n  static get type() {\n    return 'NormalMapNode';\n  }\n  constructor(node, scaleNode = null) {\n    super('vec3');\n    this.node = node;\n    this.scaleNode = scaleNode;\n    this.normalMapType = TangentSpaceNormalMap;\n  }\n  setup(builder) {\n    const {\n      normalMapType,\n      scaleNode\n    } = this;\n    let normalMap = this.node.mul(2.0).sub(1.0);\n    if (scaleNode !== null) {\n      normalMap = vec3(normalMap.xy.mul(scaleNode), normalMap.z);\n    }\n    let outputNode = null;\n    if (normalMapType === ObjectSpaceNormalMap) {\n      outputNode = transformNormalToView(normalMap);\n    } else if (normalMapType === TangentSpaceNormalMap) {\n      const tangent = builder.hasGeometryAttribute('tangent');\n      if (tangent === true) {\n        outputNode = TBNViewMatrix.mul(normalMap).normalize();\n      } else {\n        outputNode = perturbNormal2Arb({\n          eye_pos: positionView,\n          surf_norm: normalView,\n          mapN: normalMap,\n          uv: uv()\n        });\n      }\n    }\n    return outputNode;\n  }\n}\nconst normalMap = /*@__PURE__*/nodeProxy(NormalMapNode);\n\n// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\nconst dHdxy_fwd = Fn(({\n  textureNode,\n  bumpScale\n}) => {\n  // It's used to preserve the same TextureNode instance\n  const sampleTexture = callback => textureNode.cache().context({\n    getUV: texNode => callback(texNode.uvNode || uv()),\n    forceUVContext: true\n  });\n  const Hll = float(sampleTexture(uvNode => uvNode));\n  return vec2(float(sampleTexture(uvNode => uvNode.add(uvNode.dFdx()))).sub(Hll), float(sampleTexture(uvNode => uvNode.add(uvNode.dFdy()))).sub(Hll)).mul(bumpScale);\n});\n\n// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\nconst perturbNormalArb = Fn(inputs => {\n  const {\n    surf_pos,\n    surf_norm,\n    dHdxy\n  } = inputs;\n\n  // normalize is done to ensure that the bump map looks the same regardless of the texture's scale\n  const vSigmaX = surf_pos.dFdx().normalize();\n  const vSigmaY = surf_pos.dFdy().normalize();\n  const vN = surf_norm; // normalized\n\n  const R1 = vSigmaY.cross(vN);\n  const R2 = vN.cross(vSigmaX);\n  const fDet = vSigmaX.dot(R1).mul(faceDirection);\n  const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));\n  return fDet.abs().mul(surf_norm).sub(vGrad).normalize();\n});\nclass BumpMapNode extends TempNode {\n  static get type() {\n    return 'BumpMapNode';\n  }\n  constructor(textureNode, scaleNode = null) {\n    super('vec3');\n    this.textureNode = textureNode;\n    this.scaleNode = scaleNode;\n  }\n  setup() {\n    const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;\n    const dHdxy = dHdxy_fwd({\n      textureNode: this.textureNode,\n      bumpScale\n    });\n    return perturbNormalArb({\n      surf_pos: positionView,\n      surf_norm: normalView,\n      dHdxy\n    });\n  }\n}\nconst bumpMap = /*@__PURE__*/nodeProxy(BumpMapNode);\nconst _propertyCache = new Map();\nclass MaterialNode extends Node {\n  static get type() {\n    return 'MaterialNode';\n  }\n  constructor(scope) {\n    super();\n    this.scope = scope;\n  }\n  getCache(property, type) {\n    let node = _propertyCache.get(property);\n    if (node === undefined) {\n      node = materialReference(property, type);\n      _propertyCache.set(property, node);\n    }\n    return node;\n  }\n  getFloat(property) {\n    return this.getCache(property, 'float');\n  }\n  getColor(property) {\n    return this.getCache(property, 'color');\n  }\n  getTexture(property) {\n    return this.getCache(property === 'map' ? 'map' : property + 'Map', 'texture');\n  }\n  setup(builder) {\n    const material = builder.context.material;\n    const scope = this.scope;\n    let node = null;\n    if (scope === MaterialNode.COLOR) {\n      const colorNode = material.color !== undefined ? this.getColor(scope) : vec3();\n      if (material.map && material.map.isTexture === true) {\n        node = colorNode.mul(this.getTexture('map'));\n      } else {\n        node = colorNode;\n      }\n    } else if (scope === MaterialNode.OPACITY) {\n      const opacityNode = this.getFloat(scope);\n      if (material.alphaMap && material.alphaMap.isTexture === true) {\n        node = opacityNode.mul(this.getTexture('alpha'));\n      } else {\n        node = opacityNode;\n      }\n    } else if (scope === MaterialNode.SPECULAR_STRENGTH) {\n      if (material.specularMap && material.specularMap.isTexture === true) {\n        node = this.getTexture('specular').r;\n      } else {\n        node = float(1);\n      }\n    } else if (scope === MaterialNode.SPECULAR_INTENSITY) {\n      const specularIntensity = this.getFloat(scope);\n      if (material.specularMap) {\n        node = specularIntensity.mul(this.getTexture(scope).a);\n      } else {\n        node = specularIntensity;\n      }\n    } else if (scope === MaterialNode.SPECULAR_COLOR) {\n      const specularColorNode = this.getColor(scope);\n      if (material.specularColorMap && material.specularColorMap.isTexture === true) {\n        node = specularColorNode.mul(this.getTexture(scope).rgb);\n      } else {\n        node = specularColorNode;\n      }\n    } else if (scope === MaterialNode.ROUGHNESS) {\n      // TODO: cleanup similar branches\n\n      const roughnessNode = this.getFloat(scope);\n      if (material.roughnessMap && material.roughnessMap.isTexture === true) {\n        node = roughnessNode.mul(this.getTexture(scope).g);\n      } else {\n        node = roughnessNode;\n      }\n    } else if (scope === MaterialNode.METALNESS) {\n      const metalnessNode = this.getFloat(scope);\n      if (material.metalnessMap && material.metalnessMap.isTexture === true) {\n        node = metalnessNode.mul(this.getTexture(scope).b);\n      } else {\n        node = metalnessNode;\n      }\n    } else if (scope === MaterialNode.EMISSIVE) {\n      const emissiveIntensityNode = this.getFloat('emissiveIntensity');\n      const emissiveNode = this.getColor(scope).mul(emissiveIntensityNode);\n      if (material.emissiveMap && material.emissiveMap.isTexture === true) {\n        node = emissiveNode.mul(this.getTexture(scope));\n      } else {\n        node = emissiveNode;\n      }\n    } else if (scope === MaterialNode.NORMAL) {\n      if (material.normalMap) {\n        node = normalMap(this.getTexture('normal'), this.getCache('normalScale', 'vec2'));\n        node.normalMapType = material.normalMapType;\n      } else if (material.bumpMap) {\n        node = bumpMap(this.getTexture('bump').r, this.getFloat('bumpScale'));\n      } else {\n        node = normalView;\n      }\n    } else if (scope === MaterialNode.CLEARCOAT) {\n      const clearcoatNode = this.getFloat(scope);\n      if (material.clearcoatMap && material.clearcoatMap.isTexture === true) {\n        node = clearcoatNode.mul(this.getTexture(scope).r);\n      } else {\n        node = clearcoatNode;\n      }\n    } else if (scope === MaterialNode.CLEARCOAT_ROUGHNESS) {\n      const clearcoatRoughnessNode = this.getFloat(scope);\n      if (material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true) {\n        node = clearcoatRoughnessNode.mul(this.getTexture(scope).r);\n      } else {\n        node = clearcoatRoughnessNode;\n      }\n    } else if (scope === MaterialNode.CLEARCOAT_NORMAL) {\n      if (material.clearcoatNormalMap) {\n        node = normalMap(this.getTexture(scope), this.getCache(scope + 'Scale', 'vec2'));\n      } else {\n        node = normalView;\n      }\n    } else if (scope === MaterialNode.SHEEN) {\n      const sheenNode = this.getColor('sheenColor').mul(this.getFloat('sheen')); // Move this mul() to CPU\n\n      if (material.sheenColorMap && material.sheenColorMap.isTexture === true) {\n        node = sheenNode.mul(this.getTexture('sheenColor').rgb);\n      } else {\n        node = sheenNode;\n      }\n    } else if (scope === MaterialNode.SHEEN_ROUGHNESS) {\n      const sheenRoughnessNode = this.getFloat(scope);\n      if (material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true) {\n        node = sheenRoughnessNode.mul(this.getTexture(scope).a);\n      } else {\n        node = sheenRoughnessNode;\n      }\n      node = node.clamp(0.07, 1.0);\n    } else if (scope === MaterialNode.ANISOTROPY) {\n      if (material.anisotropyMap && material.anisotropyMap.isTexture === true) {\n        const anisotropyPolar = this.getTexture(scope);\n        const anisotropyMat = mat2(materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x);\n        node = anisotropyMat.mul(anisotropyPolar.rg.mul(2.0).sub(vec2(1.0)).normalize().mul(anisotropyPolar.b));\n      } else {\n        node = materialAnisotropyVector;\n      }\n    } else if (scope === MaterialNode.IRIDESCENCE_THICKNESS) {\n      const iridescenceThicknessMaximum = reference('1', 'float', material.iridescenceThicknessRange);\n      if (material.iridescenceThicknessMap) {\n        const iridescenceThicknessMinimum = reference('0', 'float', material.iridescenceThicknessRange);\n        node = iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(scope).g).add(iridescenceThicknessMinimum);\n      } else {\n        node = iridescenceThicknessMaximum;\n      }\n    } else if (scope === MaterialNode.TRANSMISSION) {\n      const transmissionNode = this.getFloat(scope);\n      if (material.transmissionMap) {\n        node = transmissionNode.mul(this.getTexture(scope).r);\n      } else {\n        node = transmissionNode;\n      }\n    } else if (scope === MaterialNode.THICKNESS) {\n      const thicknessNode = this.getFloat(scope);\n      if (material.thicknessMap) {\n        node = thicknessNode.mul(this.getTexture(scope).g);\n      } else {\n        node = thicknessNode;\n      }\n    } else if (scope === MaterialNode.IOR) {\n      node = this.getFloat(scope);\n    } else if (scope === MaterialNode.LIGHT_MAP) {\n      node = this.getTexture(scope).rgb.mul(this.getFloat('lightMapIntensity'));\n    } else if (scope === MaterialNode.AO_MAP) {\n      node = this.getTexture(scope).r.sub(1.0).mul(this.getFloat('aoMapIntensity')).add(1.0);\n    } else {\n      const outputType = this.getNodeType(builder);\n      node = this.getCache(scope, outputType);\n    }\n    return node;\n  }\n}\nMaterialNode.ALPHA_TEST = 'alphaTest';\nMaterialNode.COLOR = 'color';\nMaterialNode.OPACITY = 'opacity';\nMaterialNode.SHININESS = 'shininess';\nMaterialNode.SPECULAR = 'specular';\nMaterialNode.SPECULAR_STRENGTH = 'specularStrength';\nMaterialNode.SPECULAR_INTENSITY = 'specularIntensity';\nMaterialNode.SPECULAR_COLOR = 'specularColor';\nMaterialNode.REFLECTIVITY = 'reflectivity';\nMaterialNode.ROUGHNESS = 'roughness';\nMaterialNode.METALNESS = 'metalness';\nMaterialNode.NORMAL = 'normal';\nMaterialNode.CLEARCOAT = 'clearcoat';\nMaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';\nMaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';\nMaterialNode.EMISSIVE = 'emissive';\nMaterialNode.ROTATION = 'rotation';\nMaterialNode.SHEEN = 'sheen';\nMaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';\nMaterialNode.ANISOTROPY = 'anisotropy';\nMaterialNode.IRIDESCENCE = 'iridescence';\nMaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';\nMaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';\nMaterialNode.IOR = 'ior';\nMaterialNode.TRANSMISSION = 'transmission';\nMaterialNode.THICKNESS = 'thickness';\nMaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';\nMaterialNode.ATTENUATION_COLOR = 'attenuationColor';\nMaterialNode.LINE_SCALE = 'scale';\nMaterialNode.LINE_DASH_SIZE = 'dashSize';\nMaterialNode.LINE_GAP_SIZE = 'gapSize';\nMaterialNode.LINE_WIDTH = 'linewidth';\nMaterialNode.LINE_DASH_OFFSET = 'dashOffset';\nMaterialNode.POINT_WIDTH = 'pointWidth';\nMaterialNode.DISPERSION = 'dispersion';\nMaterialNode.LIGHT_MAP = 'light';\nMaterialNode.AO_MAP = 'ao';\nconst materialAlphaTest = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ALPHA_TEST);\nconst materialColor = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.COLOR);\nconst materialShininess = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SHININESS);\nconst materialEmissive = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.EMISSIVE);\nconst materialOpacity = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.OPACITY);\nconst materialSpecular = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR);\nconst materialSpecularIntensity = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR_INTENSITY);\nconst materialSpecularColor = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);\nconst materialSpecularStrength = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR_STRENGTH);\nconst materialReflectivity = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);\nconst materialRoughness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ROUGHNESS);\nconst materialMetalness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.METALNESS);\nconst materialNormal = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.NORMAL).context({\n  getUV: null\n});\nconst materialClearcoat = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT);\nconst materialClearcoatRoughness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS);\nconst materialClearcoatNormal = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_NORMAL).context({\n  getUV: null\n});\nconst materialRotation = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ROTATION);\nconst materialSheen = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SHEEN);\nconst materialSheenRoughness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SHEEN_ROUGHNESS);\nconst materialAnisotropy = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ANISOTROPY);\nconst materialIridescence = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE);\nconst materialIridescenceIOR = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_IOR);\nconst materialIridescenceThickness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS);\nconst materialTransmission = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.TRANSMISSION);\nconst materialThickness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.THICKNESS);\nconst materialIOR = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IOR);\nconst materialAttenuationDistance = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_DISTANCE);\nconst materialAttenuationColor = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_COLOR);\nconst materialLineScale = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_SCALE);\nconst materialLineDashSize = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_SIZE);\nconst materialLineGapSize = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_GAP_SIZE);\nconst materialLineWidth = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_WIDTH);\nconst materialLineDashOffset = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_OFFSET);\nconst materialPointWidth = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.POINT_WIDTH);\nconst materialDispersion = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.DISPERSION);\nconst materialLightMap = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LIGHT_MAP);\nconst materialAOMap = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.AO_MAP);\nconst materialAnisotropyVector = /*@__PURE__*/uniform(new Vector2()).onReference(function (frame) {\n  return frame.material;\n}).onRenderUpdate(function ({\n  material\n}) {\n  this.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));\n});\nclass ModelViewProjectionNode extends TempNode {\n  static get type() {\n    return 'ModelViewProjectionNode';\n  }\n  constructor(positionNode = null) {\n    super('vec4');\n    this.positionNode = positionNode;\n  }\n  setup(builder) {\n    if (builder.shaderStage === 'fragment') {\n      return varying(builder.context.mvp);\n    }\n    const position = this.positionNode || positionLocal;\n    const viewMatrix = builder.renderer.nodes.modelViewMatrix || modelViewMatrix;\n    return cameraProjectionMatrix.mul(viewMatrix).mul(position);\n  }\n}\nconst modelViewProjection = /*@__PURE__*/nodeProxy(ModelViewProjectionNode);\nclass IndexNode extends Node {\n  static get type() {\n    return 'IndexNode';\n  }\n  constructor(scope) {\n    super('uint');\n    this.scope = scope;\n    this.isInstanceIndexNode = true;\n  }\n  generate(builder) {\n    const nodeType = this.getNodeType(builder);\n    const scope = this.scope;\n    let propertyName;\n    if (scope === IndexNode.VERTEX) {\n      // The index of a vertex within a mesh.\n      propertyName = builder.getVertexIndex();\n    } else if (scope === IndexNode.INSTANCE) {\n      // The index of either a mesh instance or an invocation of a compute shader.\n      propertyName = builder.getInstanceIndex();\n    } else if (scope === IndexNode.DRAW) {\n      // The index of a draw call.\n      propertyName = builder.getDrawIndex();\n    } else if (scope === IndexNode.INVOCATION_LOCAL) {\n      // The index of a compute invocation within the scope of a workgroup load.\n      propertyName = builder.getInvocationLocalIndex();\n    } else if (scope === IndexNode.INVOCATION_SUBGROUP) {\n      // The index of a compute invocation within the scope of a subgroup.\n      propertyName = builder.getInvocationSubgroupIndex();\n    } else if (scope === IndexNode.SUBGROUP) {\n      // The index of the subgroup the current compute invocation belongs to.\n      propertyName = builder.getSubgroupIndex();\n    } else {\n      throw new Error('THREE.IndexNode: Unknown scope: ' + scope);\n    }\n    let output;\n    if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {\n      output = propertyName;\n    } else {\n      const nodeVarying = varying(this);\n      output = nodeVarying.build(builder, nodeType);\n    }\n    return output;\n  }\n}\nIndexNode.VERTEX = 'vertex';\nIndexNode.INSTANCE = 'instance';\nIndexNode.SUBGROUP = 'subgroup';\nIndexNode.INVOCATION_LOCAL = 'invocationLocal';\nIndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';\nIndexNode.DRAW = 'draw';\nconst vertexIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.VERTEX);\nconst instanceIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.INSTANCE);\nconst subgroupIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.SUBGROUP);\nconst invocationSubgroupIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.INVOCATION_SUBGROUP);\nconst invocationLocalIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.INVOCATION_LOCAL);\nconst drawIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.DRAW);\nclass InstanceNode extends Node {\n  static get type() {\n    return 'InstanceNode';\n  }\n  constructor(count, instanceMatrix, instanceColor) {\n    super('void');\n    this.count = count;\n    this.instanceMatrix = instanceMatrix;\n    this.instanceColor = instanceColor;\n    this.instanceMatrixNode = null;\n    this.instanceColorNode = null;\n    this.updateType = NodeUpdateType.FRAME;\n    this.buffer = null;\n    this.bufferColor = null;\n  }\n  setup(builder) {\n    const {\n      count,\n      instanceMatrix,\n      instanceColor\n    } = this;\n    let {\n      instanceMatrixNode,\n      instanceColorNode\n    } = this;\n    if (instanceMatrixNode === null) {\n      // Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.\n\n      if (count <= 1000) {\n        instanceMatrixNode = buffer(instanceMatrix.array, 'mat4', Math.max(count, 1)).element(instanceIndex);\n      } else {\n        const buffer = new InstancedInterleavedBuffer(instanceMatrix.array, 16, 1);\n        this.buffer = buffer;\n        const bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n        const instanceBuffers = [\n        // F.Signature -> bufferAttribute( array, type, stride, offset )\n        bufferFn(buffer, 'vec4', 16, 0), bufferFn(buffer, 'vec4', 16, 4), bufferFn(buffer, 'vec4', 16, 8), bufferFn(buffer, 'vec4', 16, 12)];\n        instanceMatrixNode = mat4(...instanceBuffers);\n      }\n      this.instanceMatrixNode = instanceMatrixNode;\n    }\n    if (instanceColor && instanceColorNode === null) {\n      const buffer = new InstancedBufferAttribute(instanceColor.array, 3);\n      const bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n      this.bufferColor = buffer;\n      instanceColorNode = vec3(bufferFn(buffer, 'vec3', 3, 0));\n      this.instanceColorNode = instanceColorNode;\n    }\n\n    // POSITION\n\n    const instancePosition = instanceMatrixNode.mul(positionLocal).xyz;\n    positionLocal.assign(instancePosition);\n\n    // NORMAL\n\n    if (builder.hasGeometryAttribute('normal')) {\n      const instanceNormal = transformNormal(normalLocal, instanceMatrixNode);\n\n      // ASSIGNS\n\n      normalLocal.assign(instanceNormal);\n    }\n\n    // COLOR\n\n    if (this.instanceColorNode !== null) {\n      varyingProperty('vec3', 'vInstanceColor').assign(this.instanceColorNode);\n    }\n  }\n  update(/*frame*/\n  ) {\n    if (this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer != null && this.instanceMatrix.version !== this.buffer.version) {\n      this.buffer.version = this.instanceMatrix.version;\n    }\n    if (this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor != null && this.instanceColor.version !== this.bufferColor.version) {\n      this.bufferColor.version = this.instanceColor.version;\n    }\n  }\n}\nconst instance = /*@__PURE__*/nodeProxy(InstanceNode);\nclass InstancedMeshNode extends InstanceNode {\n  static get type() {\n    return 'InstancedMeshNode';\n  }\n  constructor(instanceMesh) {\n    const {\n      count,\n      instanceMatrix,\n      instanceColor\n    } = instanceMesh;\n    super(count, instanceMatrix, instanceColor);\n    this.instanceMesh = instanceMesh;\n  }\n}\nconst instancedMesh = /*@__PURE__*/nodeProxy(InstancedMeshNode);\nclass BatchNode extends Node {\n  static get type() {\n    return 'BatchNode';\n  }\n  constructor(batchMesh) {\n    super('void');\n    this.batchMesh = batchMesh;\n    this.batchingIdNode = null;\n  }\n  setup(builder) {\n    // POSITION\n\n    if (this.batchingIdNode === null) {\n      if (builder.getDrawIndex() === null) {\n        this.batchingIdNode = instanceIndex;\n      } else {\n        this.batchingIdNode = drawIndex;\n      }\n    }\n    const getIndirectIndex = Fn(([id]) => {\n      const size = textureSize(textureLoad(this.batchMesh._indirectTexture), 0);\n      const x = int(id).modInt(int(size));\n      const y = int(id).div(int(size));\n      return textureLoad(this.batchMesh._indirectTexture, ivec2(x, y)).x;\n    }).setLayout({\n      name: 'getIndirectIndex',\n      type: 'uint',\n      inputs: [{\n        name: 'id',\n        type: 'int'\n      }]\n    });\n    const indirectId = getIndirectIndex(int(this.batchingIdNode));\n    const matricesTexture = this.batchMesh._matricesTexture;\n    const size = textureSize(textureLoad(matricesTexture), 0);\n    const j = float(indirectId).mul(4).toInt().toVar();\n    const x = j.modInt(size);\n    const y = j.div(int(size));\n    const batchingMatrix = mat4(textureLoad(matricesTexture, ivec2(x, y)), textureLoad(matricesTexture, ivec2(x.add(1), y)), textureLoad(matricesTexture, ivec2(x.add(2), y)), textureLoad(matricesTexture, ivec2(x.add(3), y)));\n    const colorsTexture = this.batchMesh._colorsTexture;\n    if (colorsTexture !== null) {\n      const getBatchingColor = Fn(([id]) => {\n        const size = textureSize(textureLoad(colorsTexture), 0).x;\n        const j = id;\n        const x = j.modInt(size);\n        const y = j.div(size);\n        return textureLoad(colorsTexture, ivec2(x, y)).rgb;\n      }).setLayout({\n        name: 'getBatchingColor',\n        type: 'vec3',\n        inputs: [{\n          name: 'id',\n          type: 'int'\n        }]\n      });\n      const color = getBatchingColor(indirectId);\n      varyingProperty('vec3', 'vBatchColor').assign(color);\n    }\n    const bm = mat3(batchingMatrix);\n    positionLocal.assign(batchingMatrix.mul(positionLocal));\n    const transformedNormal = normalLocal.div(vec3(bm[0].dot(bm[0]), bm[1].dot(bm[1]), bm[2].dot(bm[2])));\n    const batchingNormal = bm.mul(transformedNormal).xyz;\n    normalLocal.assign(batchingNormal);\n    if (builder.hasGeometryAttribute('tangent')) {\n      tangentLocal.mulAssign(bm);\n    }\n  }\n}\nconst batch = /*@__PURE__*/nodeProxy(BatchNode);\nconst _frameId = new WeakMap();\nclass SkinningNode extends Node {\n  static get type() {\n    return 'SkinningNode';\n  }\n  constructor(skinnedMesh, useReference = false) {\n    super('void');\n    this.skinnedMesh = skinnedMesh;\n    this.useReference = useReference;\n    this.updateType = NodeUpdateType.OBJECT;\n\n    //\n\n    this.skinIndexNode = attribute('skinIndex', 'uvec4');\n    this.skinWeightNode = attribute('skinWeight', 'vec4');\n    let bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;\n    if (useReference) {\n      bindMatrixNode = reference('bindMatrix', 'mat4');\n      bindMatrixInverseNode = reference('bindMatrixInverse', 'mat4');\n      boneMatricesNode = referenceBuffer('skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length);\n    } else {\n      bindMatrixNode = uniform(skinnedMesh.bindMatrix, 'mat4');\n      bindMatrixInverseNode = uniform(skinnedMesh.bindMatrixInverse, 'mat4');\n      boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length);\n    }\n    this.bindMatrixNode = bindMatrixNode;\n    this.bindMatrixInverseNode = bindMatrixInverseNode;\n    this.boneMatricesNode = boneMatricesNode;\n    this.previousBoneMatricesNode = null;\n  }\n  getSkinnedPosition(boneMatrices = this.boneMatricesNode, position = positionLocal) {\n    const {\n      skinIndexNode,\n      skinWeightNode,\n      bindMatrixNode,\n      bindMatrixInverseNode\n    } = this;\n    const boneMatX = boneMatrices.element(skinIndexNode.x);\n    const boneMatY = boneMatrices.element(skinIndexNode.y);\n    const boneMatZ = boneMatrices.element(skinIndexNode.z);\n    const boneMatW = boneMatrices.element(skinIndexNode.w);\n\n    // POSITION\n\n    const skinVertex = bindMatrixNode.mul(position);\n    const skinned = add(boneMatX.mul(skinWeightNode.x).mul(skinVertex), boneMatY.mul(skinWeightNode.y).mul(skinVertex), boneMatZ.mul(skinWeightNode.z).mul(skinVertex), boneMatW.mul(skinWeightNode.w).mul(skinVertex));\n    return bindMatrixInverseNode.mul(skinned).xyz;\n  }\n  getSkinnedNormal(boneMatrices = this.boneMatricesNode, normal = normalLocal) {\n    const {\n      skinIndexNode,\n      skinWeightNode,\n      bindMatrixNode,\n      bindMatrixInverseNode\n    } = this;\n    const boneMatX = boneMatrices.element(skinIndexNode.x);\n    const boneMatY = boneMatrices.element(skinIndexNode.y);\n    const boneMatZ = boneMatrices.element(skinIndexNode.z);\n    const boneMatW = boneMatrices.element(skinIndexNode.w);\n\n    // NORMAL\n\n    let skinMatrix = add(skinWeightNode.x.mul(boneMatX), skinWeightNode.y.mul(boneMatY), skinWeightNode.z.mul(boneMatZ), skinWeightNode.w.mul(boneMatW));\n    skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);\n    return skinMatrix.transformDirection(normal).xyz;\n  }\n  getPreviousSkinnedPosition(builder) {\n    const skinnedMesh = builder.object;\n    if (this.previousBoneMatricesNode === null) {\n      skinnedMesh.skeleton.previousBoneMatrices = new Float32Array(skinnedMesh.skeleton.boneMatrices);\n      this.previousBoneMatricesNode = referenceBuffer('skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length);\n    }\n    return this.getSkinnedPosition(this.previousBoneMatricesNode, positionPrevious);\n  }\n  needsPreviousBoneMatrices(builder) {\n    const mrt = builder.renderer.getMRT();\n    return mrt && mrt.has('velocity');\n  }\n  setup(builder) {\n    if (this.needsPreviousBoneMatrices(builder)) {\n      positionPrevious.assign(this.getPreviousSkinnedPosition(builder));\n    }\n    const skinPosition = this.getSkinnedPosition();\n    positionLocal.assign(skinPosition);\n    if (builder.hasGeometryAttribute('normal')) {\n      const skinNormal = this.getSkinnedNormal();\n      normalLocal.assign(skinNormal);\n      if (builder.hasGeometryAttribute('tangent')) {\n        tangentLocal.assign(skinNormal);\n      }\n    }\n  }\n  generate(builder, output) {\n    if (output !== 'void') {\n      return positionLocal.build(builder, output);\n    }\n  }\n  update(frame) {\n    const object = this.useReference ? frame.object : this.skinnedMesh;\n    const skeleton = object.skeleton;\n    if (_frameId.get(skeleton) === frame.frameId) return;\n    _frameId.set(skeleton, frame.frameId);\n    if (this.previousBoneMatricesNode !== null) skeleton.previousBoneMatrices.set(skeleton.boneMatrices);\n    skeleton.update();\n  }\n}\nconst skinning = skinnedMesh => nodeObject(new SkinningNode(skinnedMesh));\nconst skinningReference = skinnedMesh => nodeObject(new SkinningNode(skinnedMesh, true));\nclass LoopNode extends Node {\n  static get type() {\n    return 'LoopNode';\n  }\n  constructor(params = []) {\n    super();\n    this.params = params;\n  }\n  getVarName(index) {\n    return String.fromCharCode('i'.charCodeAt() + index);\n  }\n  getProperties(builder) {\n    const properties = builder.getNodeProperties(this);\n    if (properties.stackNode !== undefined) return properties;\n\n    //\n\n    const inputs = {};\n    for (let i = 0, l = this.params.length - 1; i < l; i++) {\n      const param = this.params[i];\n      const name = param.isNode !== true && param.name || this.getVarName(i);\n      const type = param.isNode !== true && param.type || 'int';\n      inputs[name] = expression(name, type);\n    }\n    const stack = builder.addStack(); // TODO: cache() it\n\n    properties.returnsNode = this.params[this.params.length - 1](inputs, stack, builder);\n    properties.stackNode = stack;\n    builder.removeStack();\n    return properties;\n  }\n  getNodeType(builder) {\n    const {\n      returnsNode\n    } = this.getProperties(builder);\n    return returnsNode ? returnsNode.getNodeType(builder) : 'void';\n  }\n  setup(builder) {\n    // setup properties\n\n    this.getProperties(builder);\n  }\n  generate(builder) {\n    const properties = this.getProperties(builder);\n    const params = this.params;\n    const stackNode = properties.stackNode;\n    for (let i = 0, l = params.length - 1; i < l; i++) {\n      const param = params[i];\n      let start = null,\n        end = null,\n        name = null,\n        type = null,\n        condition = null,\n        update = null;\n      if (param.isNode) {\n        type = 'int';\n        name = this.getVarName(i);\n        start = '0';\n        end = param.build(builder, type);\n        condition = '<';\n      } else {\n        type = param.type || 'int';\n        name = param.name || this.getVarName(i);\n        start = param.start;\n        end = param.end;\n        condition = param.condition;\n        update = param.update;\n        if (typeof start === 'number') start = builder.generateConst(type, start);else if (start && start.isNode) start = start.build(builder, type);\n        if (typeof end === 'number') end = builder.generateConst(type, end);else if (end && end.isNode) end = end.build(builder, type);\n        if (start !== undefined && end === undefined) {\n          start = start + ' - 1';\n          end = '0';\n          condition = '>=';\n        } else if (end !== undefined && start === undefined) {\n          start = '0';\n          condition = '<';\n        }\n        if (condition === undefined) {\n          if (Number(start) > Number(end)) {\n            condition = '>=';\n          } else {\n            condition = '<';\n          }\n        }\n      }\n      const internalParam = {\n        start,\n        end,\n        condition\n      };\n\n      //\n\n      const startSnippet = internalParam.start;\n      const endSnippet = internalParam.end;\n      let declarationSnippet = '';\n      let conditionalSnippet = '';\n      let updateSnippet = '';\n      if (!update) {\n        if (type === 'int' || type === 'uint') {\n          if (condition.includes('<')) update = '++';else update = '--';\n        } else {\n          if (condition.includes('<')) update = '+= 1.';else update = '-= 1.';\n        }\n      }\n      declarationSnippet += builder.getVar(type, name) + ' = ' + startSnippet;\n      conditionalSnippet += name + ' ' + condition + ' ' + endSnippet;\n      updateSnippet += name + ' ' + update;\n      const forSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;\n      builder.addFlowCode((i === 0 ? '\\n' : '') + builder.tab + forSnippet + ' {\\n\\n').addFlowTab();\n    }\n    const stackSnippet = stackNode.build(builder, 'void');\n    const returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : '';\n    builder.removeFlowTab().addFlowCode('\\n' + builder.tab + stackSnippet);\n    for (let i = 0, l = this.params.length - 1; i < l; i++) {\n      builder.addFlowCode((i === 0 ? '' : builder.tab) + '}\\n\\n').removeFlowTab();\n    }\n    builder.addFlowTab();\n    return returnsSnippet;\n  }\n}\nconst Loop = (...params) => nodeObject(new LoopNode(nodeArray(params, 'int'))).append();\nconst Continue = () => expression('continue').append();\nconst Break = () => expression('break').append();\n\n//\n\nconst loop = (...params) => {\n  // @deprecated, r168\n\n  console.warn('TSL.LoopNode: loop() has been renamed to Loop().');\n  return Loop(...params);\n};\nconst _morphTextures = /*@__PURE__*/new WeakMap();\nconst _morphVec4 = /*@__PURE__*/new Vector4();\nconst getMorph = /*@__PURE__*/Fn(({\n  bufferMap,\n  influence,\n  stride,\n  width,\n  depth,\n  offset\n}) => {\n  const texelIndex = int(vertexIndex).mul(stride).add(offset);\n  const y = texelIndex.div(width);\n  const x = texelIndex.sub(y.mul(width));\n  const bufferAttrib = textureLoad(bufferMap, ivec2(x, y)).depth(depth);\n  return bufferAttrib.mul(influence);\n});\nfunction getEntry(geometry) {\n  const hasMorphPosition = geometry.morphAttributes.position !== undefined;\n  const hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n  const hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n  // instead of using attributes, the WebGL 2 code path encodes morph targets\n  // into an array of data textures. Each layer represents a single morph target.\n\n  const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n  const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n  let entry = _morphTextures.get(geometry);\n  if (entry === undefined || entry.count !== morphTargetsCount) {\n    if (entry !== undefined) entry.texture.dispose();\n    const morphTargets = geometry.morphAttributes.position || [];\n    const morphNormals = geometry.morphAttributes.normal || [];\n    const morphColors = geometry.morphAttributes.color || [];\n    let vertexDataCount = 0;\n    if (hasMorphPosition === true) vertexDataCount = 1;\n    if (hasMorphNormals === true) vertexDataCount = 2;\n    if (hasMorphColors === true) vertexDataCount = 3;\n    let width = geometry.attributes.position.count * vertexDataCount;\n    let height = 1;\n    const maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'\n\n    if (width > maxTextureSize) {\n      height = Math.ceil(width / maxTextureSize);\n      width = maxTextureSize;\n    }\n    const buffer = new Float32Array(width * height * 4 * morphTargetsCount);\n    const bufferTexture = new DataArrayTexture(buffer, width, height, morphTargetsCount);\n    bufferTexture.type = FloatType;\n    bufferTexture.needsUpdate = true;\n\n    // fill buffer\n\n    const vertexDataStride = vertexDataCount * 4;\n    for (let i = 0; i < morphTargetsCount; i++) {\n      const morphTarget = morphTargets[i];\n      const morphNormal = morphNormals[i];\n      const morphColor = morphColors[i];\n      const offset = width * height * 4 * i;\n      for (let j = 0; j < morphTarget.count; j++) {\n        const stride = j * vertexDataStride;\n        if (hasMorphPosition === true) {\n          _morphVec4.fromBufferAttribute(morphTarget, j);\n          buffer[offset + stride + 0] = _morphVec4.x;\n          buffer[offset + stride + 1] = _morphVec4.y;\n          buffer[offset + stride + 2] = _morphVec4.z;\n          buffer[offset + stride + 3] = 0;\n        }\n        if (hasMorphNormals === true) {\n          _morphVec4.fromBufferAttribute(morphNormal, j);\n          buffer[offset + stride + 4] = _morphVec4.x;\n          buffer[offset + stride + 5] = _morphVec4.y;\n          buffer[offset + stride + 6] = _morphVec4.z;\n          buffer[offset + stride + 7] = 0;\n        }\n        if (hasMorphColors === true) {\n          _morphVec4.fromBufferAttribute(morphColor, j);\n          buffer[offset + stride + 8] = _morphVec4.x;\n          buffer[offset + stride + 9] = _morphVec4.y;\n          buffer[offset + stride + 10] = _morphVec4.z;\n          buffer[offset + stride + 11] = morphColor.itemSize === 4 ? _morphVec4.w : 1;\n        }\n      }\n    }\n    entry = {\n      count: morphTargetsCount,\n      texture: bufferTexture,\n      stride: vertexDataCount,\n      size: new Vector2(width, height)\n    };\n    _morphTextures.set(geometry, entry);\n    function disposeTexture() {\n      bufferTexture.dispose();\n      _morphTextures.delete(geometry);\n      geometry.removeEventListener('dispose', disposeTexture);\n    }\n    geometry.addEventListener('dispose', disposeTexture);\n  }\n  return entry;\n}\nclass MorphNode extends Node {\n  static get type() {\n    return 'MorphNode';\n  }\n  constructor(mesh) {\n    super('void');\n    this.mesh = mesh;\n    this.morphBaseInfluence = uniform(1);\n    this.updateType = NodeUpdateType.OBJECT;\n  }\n  setup(builder) {\n    const {\n      geometry\n    } = builder;\n    const hasMorphPosition = geometry.morphAttributes.position !== undefined;\n    const hasMorphNormals = geometry.hasAttribute('normal') && geometry.morphAttributes.normal !== undefined;\n    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n    const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n\n    // nodes\n\n    const {\n      texture: bufferMap,\n      stride,\n      size\n    } = getEntry(geometry);\n    if (hasMorphPosition === true) positionLocal.mulAssign(this.morphBaseInfluence);\n    if (hasMorphNormals === true) normalLocal.mulAssign(this.morphBaseInfluence);\n    const width = int(size.width);\n    Loop(morphTargetsCount, ({\n      i\n    }) => {\n      const influence = float(0).toVar();\n      if (this.mesh.count > 1 && this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined) {\n        influence.assign(textureLoad(this.mesh.morphTexture, ivec2(int(i).add(1), int(instanceIndex))).r);\n      } else {\n        influence.assign(reference('morphTargetInfluences', 'float').element(i).toVar());\n      }\n      if (hasMorphPosition === true) {\n        positionLocal.addAssign(getMorph({\n          bufferMap,\n          influence,\n          stride,\n          width,\n          depth: i,\n          offset: int(0)\n        }));\n      }\n      if (hasMorphNormals === true) {\n        normalLocal.addAssign(getMorph({\n          bufferMap,\n          influence,\n          stride,\n          width,\n          depth: i,\n          offset: int(1)\n        }));\n      }\n    });\n  }\n  update() {\n    const morphBaseInfluence = this.morphBaseInfluence;\n    if (this.mesh.geometry.morphTargetsRelative) {\n      morphBaseInfluence.value = 1;\n    } else {\n      morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a, b) => a + b, 0);\n    }\n  }\n}\nconst morphReference = /*@__PURE__*/nodeProxy(MorphNode);\nclass LightingNode extends Node {\n  static get type() {\n    return 'LightingNode';\n  }\n  constructor() {\n    super('vec3');\n    this.isLightingNode = true;\n  }\n  generate(/*builder*/\n  ) {\n    console.warn('Abstract function.');\n  }\n}\nclass AONode extends LightingNode {\n  static get type() {\n    return 'AONode';\n  }\n  constructor(aoNode = null) {\n    super();\n    this.aoNode = aoNode;\n  }\n  setup(builder) {\n    builder.context.ambientOcclusion.mulAssign(this.aoNode);\n  }\n}\nclass LightingContextNode extends ContextNode {\n  static get type() {\n    return 'LightingContextNode';\n  }\n  constructor(node, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {\n    super(node);\n    this.lightingModel = lightingModel;\n    this.backdropNode = backdropNode;\n    this.backdropAlphaNode = backdropAlphaNode;\n    this._value = null;\n  }\n  getContext() {\n    const {\n      backdropNode,\n      backdropAlphaNode\n    } = this;\n    const directDiffuse = vec3().toVar('directDiffuse'),\n      directSpecular = vec3().toVar('directSpecular'),\n      indirectDiffuse = vec3().toVar('indirectDiffuse'),\n      indirectSpecular = vec3().toVar('indirectSpecular');\n    const reflectedLight = {\n      directDiffuse,\n      directSpecular,\n      indirectDiffuse,\n      indirectSpecular\n    };\n    const context = {\n      radiance: vec3().toVar('radiance'),\n      irradiance: vec3().toVar('irradiance'),\n      iblIrradiance: vec3().toVar('iblIrradiance'),\n      ambientOcclusion: float(1).toVar('ambientOcclusion'),\n      reflectedLight,\n      backdrop: backdropNode,\n      backdropAlpha: backdropAlphaNode\n    };\n    return context;\n  }\n  setup(builder) {\n    this.value = this._value || (this._value = this.getContext());\n    this.value.lightingModel = this.lightingModel || builder.context.lightingModel;\n    return super.setup(builder);\n  }\n}\nconst lightingContext = /*@__PURE__*/nodeProxy(LightingContextNode);\nclass IrradianceNode extends LightingNode {\n  static get type() {\n    return 'IrradianceNode';\n  }\n  constructor(node) {\n    super();\n    this.node = node;\n  }\n  setup(builder) {\n    builder.context.irradiance.addAssign(this.node);\n  }\n}\nlet screenSizeVec, viewportVec;\nclass ScreenNode extends Node {\n  static get type() {\n    return 'ScreenNode';\n  }\n  constructor(scope) {\n    super();\n    this.scope = scope;\n    this.isViewportNode = true;\n  }\n  getNodeType() {\n    if (this.scope === ScreenNode.VIEWPORT) return 'vec4';else return 'vec2';\n  }\n  getUpdateType() {\n    let updateType = NodeUpdateType.NONE;\n    if (this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT) {\n      updateType = NodeUpdateType.RENDER;\n    }\n    this.updateType = updateType;\n    return updateType;\n  }\n  update({\n    renderer\n  }) {\n    const renderTarget = renderer.getRenderTarget();\n    if (this.scope === ScreenNode.VIEWPORT) {\n      if (renderTarget !== null) {\n        viewportVec.copy(renderTarget.viewport);\n      } else {\n        renderer.getViewport(viewportVec);\n        viewportVec.multiplyScalar(renderer.getPixelRatio());\n      }\n    } else {\n      if (renderTarget !== null) {\n        screenSizeVec.width = renderTarget.width;\n        screenSizeVec.height = renderTarget.height;\n      } else {\n        renderer.getDrawingBufferSize(screenSizeVec);\n      }\n    }\n  }\n  setup(/*builder*/\n  ) {\n    const scope = this.scope;\n    let output = null;\n    if (scope === ScreenNode.SIZE) {\n      output = uniform(screenSizeVec || (screenSizeVec = new Vector2()));\n    } else if (scope === ScreenNode.VIEWPORT) {\n      output = uniform(viewportVec || (viewportVec = new Vector4()));\n    } else {\n      output = vec2(screenCoordinate.div(screenSize));\n    }\n    return output;\n  }\n  generate(builder) {\n    if (this.scope === ScreenNode.COORDINATE) {\n      let coord = builder.getFragCoord();\n      if (builder.isFlipY()) {\n        // follow webgpu standards\n\n        const size = builder.getNodeProperties(screenSize).outputNode.build(builder);\n        coord = `${builder.getType('vec2')}( ${coord}.x, ${size}.y - ${coord}.y )`;\n      }\n      return coord;\n    }\n    return super.generate(builder);\n  }\n}\nScreenNode.COORDINATE = 'coordinate';\nScreenNode.VIEWPORT = 'viewport';\nScreenNode.SIZE = 'size';\nScreenNode.UV = 'uv';\n\n// Screen\n\nconst screenUV = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.UV);\nconst screenSize = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.SIZE);\nconst screenCoordinate = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.COORDINATE);\n\n// Viewport\n\nconst viewport = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.VIEWPORT);\nconst viewportSize = viewport.zw;\nconst viewportCoordinate = /*@__PURE__*/screenCoordinate.sub(viewport.xy);\nconst viewportUV = /*@__PURE__*/viewportCoordinate.div(viewportSize);\n\n// Deprecated\n\nconst viewportResolution = /*@__PURE__*/Fn(() => {\n  // @deprecated, r169\n\n  console.warn('TSL.ViewportNode: \"viewportResolution\" is deprecated. Use \"screenSize\" instead.');\n  return screenSize;\n}, 'vec2').once()();\nconst viewportTopLeft = /*@__PURE__*/Fn(() => {\n  // @deprecated, r168\n\n  console.warn('TSL.ViewportNode: \"viewportTopLeft\" is deprecated. Use \"screenUV\" instead.');\n  return screenUV;\n}, 'vec2').once()();\nconst viewportBottomLeft = /*@__PURE__*/Fn(() => {\n  // @deprecated, r168\n\n  console.warn('TSL.ViewportNode: \"viewportBottomLeft\" is deprecated. Use \"screenUV.flipY()\" instead.');\n  return screenUV.flipY();\n}, 'vec2').once()();\nconst _size$4 = /*@__PURE__*/new Vector2();\nclass ViewportTextureNode extends TextureNode {\n  static get type() {\n    return 'ViewportTextureNode';\n  }\n  constructor(uvNode = screenUV, levelNode = null, framebufferTexture = null) {\n    if (framebufferTexture === null) {\n      framebufferTexture = new FramebufferTexture();\n      framebufferTexture.minFilter = LinearMipmapLinearFilter;\n    }\n    super(framebufferTexture, uvNode, levelNode);\n    this.generateMipmaps = false;\n    this.isOutputTextureNode = true;\n    this.updateBeforeType = NodeUpdateType.FRAME;\n  }\n  updateBefore(frame) {\n    const renderer = frame.renderer;\n    renderer.getDrawingBufferSize(_size$4);\n\n    //\n\n    const framebufferTexture = this.value;\n    if (framebufferTexture.image.width !== _size$4.width || framebufferTexture.image.height !== _size$4.height) {\n      framebufferTexture.image.width = _size$4.width;\n      framebufferTexture.image.height = _size$4.height;\n      framebufferTexture.needsUpdate = true;\n    }\n\n    //\n\n    const currentGenerateMipmaps = framebufferTexture.generateMipmaps;\n    framebufferTexture.generateMipmaps = this.generateMipmaps;\n    renderer.copyFramebufferToTexture(framebufferTexture);\n    framebufferTexture.generateMipmaps = currentGenerateMipmaps;\n  }\n  clone() {\n    const viewportTextureNode = new this.constructor(this.uvNode, this.levelNode, this.value);\n    viewportTextureNode.generateMipmaps = this.generateMipmaps;\n    return viewportTextureNode;\n  }\n}\nconst viewportTexture = /*@__PURE__*/nodeProxy(ViewportTextureNode);\nconst viewportMipTexture = /*@__PURE__*/nodeProxy(ViewportTextureNode, null, null, {\n  generateMipmaps: true\n});\nlet sharedDepthbuffer = null;\nclass ViewportDepthTextureNode extends ViewportTextureNode {\n  static get type() {\n    return 'ViewportDepthTextureNode';\n  }\n  constructor(uvNode = screenUV, levelNode = null) {\n    if (sharedDepthbuffer === null) {\n      sharedDepthbuffer = new DepthTexture();\n    }\n    super(uvNode, levelNode, sharedDepthbuffer);\n  }\n}\nconst viewportDepthTexture = /*@__PURE__*/nodeProxy(ViewportDepthTextureNode);\nclass ViewportDepthNode extends Node {\n  static get type() {\n    return 'ViewportDepthNode';\n  }\n  constructor(scope, valueNode = null) {\n    super('float');\n    this.scope = scope;\n    this.valueNode = valueNode;\n    this.isViewportDepthNode = true;\n  }\n  generate(builder) {\n    const {\n      scope\n    } = this;\n    if (scope === ViewportDepthNode.DEPTH_BASE) {\n      return builder.getFragDepth();\n    }\n    return super.generate(builder);\n  }\n  setup({\n    camera\n  }) {\n    const {\n      scope\n    } = this;\n    const value = this.valueNode;\n    let node = null;\n    if (scope === ViewportDepthNode.DEPTH_BASE) {\n      if (value !== null) {\n        node = depthBase().assign(value);\n      }\n    } else if (scope === ViewportDepthNode.DEPTH) {\n      if (camera.isPerspectiveCamera) {\n        node = viewZToPerspectiveDepth(positionView.z, cameraNear, cameraFar);\n      } else {\n        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);\n      }\n    } else if (scope === ViewportDepthNode.LINEAR_DEPTH) {\n      if (value !== null) {\n        if (camera.isPerspectiveCamera) {\n          const viewZ = perspectiveDepthToViewZ(value, cameraNear, cameraFar);\n          node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\n        } else {\n          node = value;\n        }\n      } else {\n        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);\n      }\n    }\n    return node;\n  }\n}\nViewportDepthNode.DEPTH_BASE = 'depthBase';\nViewportDepthNode.DEPTH = 'depth';\nViewportDepthNode.LINEAR_DEPTH = 'linearDepth';\n\n// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera\n\n// -near maps to 0; -far maps to 1\nconst viewZToOrthographicDepth = (viewZ, near, far) => viewZ.add(near).div(near.sub(far));\n\n// maps orthographic depth in [ 0, 1 ] to viewZ\nconst orthographicDepthToViewZ = (depth, near, far) => near.sub(far).mul(depth).sub(near);\n\n// NOTE: https://twitter.com/gonnavis/status/1377183786949959682\n\n// -near maps to 0; -far maps to 1\nconst viewZToPerspectiveDepth = (viewZ, near, far) => near.add(viewZ).mul(far).div(far.sub(near).mul(viewZ));\n\n// maps perspective depth in [ 0, 1 ] to viewZ\nconst perspectiveDepthToViewZ = (depth, near, far) => near.mul(far).div(far.sub(near).mul(depth).sub(far));\n\n// -near maps to 0; -far maps to 1\nconst viewZToLogarithmicDepth = (viewZ, near, far) => {\n  // NOTE: viewZ must be negative--see explanation at the end of this comment block.\n  // The final logarithmic depth formula used here is adapted from one described in an\n  // article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),\n  // which was an improvement upon an earlier formula one described in an\n  // Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).\n  // Ulrich's formula is the following:\n  //     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )\n  //     where K = 2^k - 1, and k is the number of bits in the depth buffer.\n  // The Outerra variant ignored the camera near plane (it assumed it was 0) and instead\n  // opted for a \"C-constant\" for resolution adjustment of objects near the camera.\n  // Outerra states: \"Notice that the 'C' variant doesn’t use a near plane distance, it has it\n  // set at 0\" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).\n  // Ulrich's variant has the benefit of constant relative precision over the whole near-far range.\n  // It was debated here whether Outerra's \"C-constant\" or Ulrich's \"near plane\" variant should\n  // be used, and ultimately Ulrich's \"near plane\" version was chosen.\n  // Outerra eventually made another improvement to their original \"C-constant\" variant,\n  // but it still does not incorporate the camera near plane (for this version,\n  // see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).\n  // Here we make 4 changes to Ulrich's formula:\n  // 1. Clamp the camera near plane so we don't divide by 0.\n  // 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).\n  // 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).\n  // 4. To maintain consistency with the functions \"viewZToOrthographicDepth\" and \"viewZToPerspectiveDepth\",\n  //    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,\n  //    so we do the same here, hence the 'viewZ.negate()' call.\n  // For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u\n  near = near.max(1e-6).toVar();\n  const numerator = log2(viewZ.negate().div(near));\n  const denominator = log2(far.div(near));\n  return numerator.div(denominator);\n};\n\n// maps logarithmic depth in [ 0, 1 ] to viewZ\nconst logarithmicDepthToViewZ = (depth, near, far) => {\n  // NOTE: we add a 'negate()' call to the return value here to maintain consistency with\n  // the functions \"orthographicDepthToViewZ\" and \"perspectiveDepthToViewZ\" (they return\n  // a negative viewZ).\n  const exponent = depth.mul(log(far.div(near)));\n  return float(Math.E).pow(exponent).mul(near).negate();\n};\nconst depthBase = /*@__PURE__*/nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_BASE);\nconst depth = /*@__PURE__*/nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);\nconst linearDepth = /*@__PURE__*/nodeProxy(ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH);\nconst viewportLinearDepth = /*@__PURE__*/linearDepth(viewportDepthTexture());\ndepth.assign = value => depthBase(value);\nclass BuiltinNode extends Node {\n  constructor(name) {\n    super('float');\n    this.name = name;\n    this.isBuiltinNode = true;\n  }\n  generate(/* builder */\n  ) {\n    return this.name;\n  }\n}\nconst builtin = nodeProxy(BuiltinNode);\nclass ClippingNode extends Node {\n  static get type() {\n    return 'ClippingNode';\n  }\n  constructor(scope = ClippingNode.DEFAULT) {\n    super();\n    this.scope = scope;\n  }\n  setup(builder) {\n    super.setup(builder);\n    const clippingContext = builder.clippingContext;\n    const {\n      intersectionPlanes,\n      unionPlanes\n    } = clippingContext;\n    this.hardwareClipping = builder.material.hardwareClipping;\n    if (this.scope === ClippingNode.ALPHA_TO_COVERAGE) {\n      return this.setupAlphaToCoverage(intersectionPlanes, unionPlanes);\n    } else if (this.scope === ClippingNode.HARDWARE) {\n      return this.setupHardwareClipping(unionPlanes, builder);\n    } else {\n      return this.setupDefault(intersectionPlanes, unionPlanes);\n    }\n  }\n  setupAlphaToCoverage(intersectionPlanes, unionPlanes) {\n    return Fn(() => {\n      const distanceToPlane = float().toVar('distanceToPlane');\n      const distanceGradient = float().toVar('distanceToGradient');\n      const clipOpacity = float(1).toVar('clipOpacity');\n      const numUnionPlanes = unionPlanes.length;\n      if (!this.hardwareClipping && numUnionPlanes > 0) {\n        const clippingPlanes = uniformArray(unionPlanes);\n        Loop(numUnionPlanes, ({\n          i\n        }) => {\n          const plane = clippingPlanes.element(i);\n          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));\n          distanceGradient.assign(distanceToPlane.fwidth().div(2.0));\n          clipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane));\n        });\n      }\n      const numIntersectionPlanes = intersectionPlanes.length;\n      if (numIntersectionPlanes > 0) {\n        const clippingPlanes = uniformArray(intersectionPlanes);\n        const intersectionClipOpacity = float(1).toVar('intersectionClipOpacity');\n        Loop(numIntersectionPlanes, ({\n          i\n        }) => {\n          const plane = clippingPlanes.element(i);\n          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));\n          distanceGradient.assign(distanceToPlane.fwidth().div(2.0));\n          intersectionClipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane).oneMinus());\n        });\n        clipOpacity.mulAssign(intersectionClipOpacity.oneMinus());\n      }\n      diffuseColor.a.mulAssign(clipOpacity);\n      diffuseColor.a.equal(0.0).discard();\n    })();\n  }\n  setupDefault(intersectionPlanes, unionPlanes) {\n    return Fn(() => {\n      const numUnionPlanes = unionPlanes.length;\n      if (!this.hardwareClipping && numUnionPlanes > 0) {\n        const clippingPlanes = uniformArray(unionPlanes);\n        Loop(numUnionPlanes, ({\n          i\n        }) => {\n          const plane = clippingPlanes.element(i);\n          positionView.dot(plane.xyz).greaterThan(plane.w).discard();\n        });\n      }\n      const numIntersectionPlanes = intersectionPlanes.length;\n      if (numIntersectionPlanes > 0) {\n        const clippingPlanes = uniformArray(intersectionPlanes);\n        const clipped = bool(true).toVar('clipped');\n        Loop(numIntersectionPlanes, ({\n          i\n        }) => {\n          const plane = clippingPlanes.element(i);\n          clipped.assign(positionView.dot(plane.xyz).greaterThan(plane.w).and(clipped));\n        });\n        clipped.discard();\n      }\n    })();\n  }\n  setupHardwareClipping(unionPlanes, builder) {\n    const numUnionPlanes = unionPlanes.length;\n    builder.enableHardwareClipping(numUnionPlanes);\n    return Fn(() => {\n      const clippingPlanes = uniformArray(unionPlanes);\n      const hw_clip_distances = builtin(builder.getClipDistance());\n      Loop(numUnionPlanes, ({\n        i\n      }) => {\n        const plane = clippingPlanes.element(i);\n        const distance = positionView.dot(plane.xyz).sub(plane.w).negate();\n        hw_clip_distances.element(i).assign(distance);\n      });\n    })();\n  }\n}\nClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';\nClippingNode.DEFAULT = 'default';\nClippingNode.HARDWARE = 'hardware';\nconst clipping = () => nodeObject(new ClippingNode());\nconst clippingAlpha = () => nodeObject(new ClippingNode(ClippingNode.ALPHA_TO_COVERAGE));\nconst hardwareClipping = () => nodeObject(new ClippingNode(ClippingNode.HARDWARE));\n\n/**\n * See: https://casual-effects.com/research/Wyman2017Hashed/index.html\n */\n\nconst ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.\n\nconst hash2D = /*@__PURE__*/Fn(([value]) => {\n  return fract(mul(1.0e4, sin(mul(17.0, value.x).add(mul(0.1, value.y)))).mul(add(0.1, abs(sin(mul(13.0, value.y).add(value.x))))));\n});\nconst hash3D = /*@__PURE__*/Fn(([value]) => {\n  return hash2D(vec2(hash2D(value.xy), value.z));\n});\nconst getAlphaHashThreshold = /*@__PURE__*/Fn(([position]) => {\n  // Find the discretized derivatives of our coordinates\n  const maxDeriv = max$1(length(dFdx(position.xyz)), length(dFdy(position.xyz)));\n  const pixScale = float(1).div(float(ALPHA_HASH_SCALE).mul(maxDeriv)).toVar('pixScale');\n\n  // Find two nearest log-discretized noise scales\n  const pixScales = vec2(exp2(floor(log2(pixScale))), exp2(ceil(log2(pixScale))));\n\n  // Compute alpha thresholds at our two noise scales\n  const alpha = vec2(hash3D(floor(pixScales.x.mul(position.xyz))), hash3D(floor(pixScales.y.mul(position.xyz))));\n\n  // Factor to interpolate lerp with\n  const lerpFactor = fract(log2(pixScale));\n\n  // Interpolate alpha threshold from noise at two scales\n  const x = add(mul(lerpFactor.oneMinus(), alpha.x), mul(lerpFactor, alpha.y));\n\n  // Pass into CDF to compute uniformly distrib threshold\n  const a = min$1(lerpFactor, lerpFactor.oneMinus());\n  const cases = vec3(x.mul(x).div(mul(2.0, a).mul(sub(1.0, a))), x.sub(mul(0.5, a)).div(sub(1.0, a)), sub(1.0, sub(1.0, x).mul(sub(1.0, x)).div(mul(2.0, a).mul(sub(1.0, a)))));\n\n  // Find our final, uniformly distributed alpha threshold (ατ)\n  const threshold = x.lessThan(a.oneMinus()).select(x.lessThan(a).select(cases.x, cases.y), cases.z);\n\n  // Avoids ατ == 0. Could also do ατ =1-ατ\n  return clamp(threshold, 1.0e-6, 1.0);\n}).setLayout({\n  name: 'getAlphaHashThreshold',\n  type: 'float',\n  inputs: [{\n    name: 'position',\n    type: 'vec3'\n  }]\n});\nclass NodeMaterial extends Material {\n  static get type() {\n    return 'NodeMaterial';\n  }\n  get type() {\n    return this.constructor.type;\n  }\n  set type(_value) {/* */}\n  constructor() {\n    super();\n    this.isNodeMaterial = true;\n    this.forceSinglePass = false;\n    this.fog = true;\n    this.lights = false;\n    this.hardwareClipping = false;\n    this.lightsNode = null;\n    this.envNode = null;\n    this.aoNode = null;\n    this.colorNode = null;\n    this.normalNode = null;\n    this.opacityNode = null;\n    this.backdropNode = null;\n    this.backdropAlphaNode = null;\n    this.alphaTestNode = null;\n    this.positionNode = null;\n    this.geometryNode = null;\n    this.depthNode = null;\n    this.shadowPositionNode = null;\n    this.receivedShadowNode = null;\n    this.castShadowNode = null;\n    this.outputNode = null;\n    this.mrtNode = null;\n    this.fragmentNode = null;\n    this.vertexNode = null;\n  }\n  customProgramCacheKey() {\n    return this.type + getCacheKey$1(this);\n  }\n  build(builder) {\n    this.setup(builder);\n  }\n  setupObserver(builder) {\n    return new NodeMaterialObserver(builder);\n  }\n  setup(builder) {\n    builder.context.setupNormal = () => this.setupNormal(builder);\n    const renderer = builder.renderer;\n    const renderTarget = renderer.getRenderTarget();\n\n    // < VERTEX STAGE >\n\n    builder.addStack();\n    builder.stack.outputNode = this.vertexNode || this.setupPosition(builder);\n    if (this.geometryNode !== null) {\n      builder.stack.outputNode = builder.stack.outputNode.bypass(this.geometryNode);\n    }\n    builder.addFlow('vertex', builder.removeStack());\n\n    // < FRAGMENT STAGE >\n\n    builder.addStack();\n    let resultNode;\n    const clippingNode = this.setupClipping(builder);\n    if (this.depthWrite === true) {\n      // only write depth if depth buffer is configured\n\n      if (renderTarget !== null) {\n        if (renderTarget.depthBuffer === true) this.setupDepth(builder);\n      } else {\n        if (renderer.depth === true) this.setupDepth(builder);\n      }\n    }\n    if (this.fragmentNode === null) {\n      this.setupDiffuseColor(builder);\n      this.setupVariants(builder);\n      const outgoingLightNode = this.setupLighting(builder);\n      if (clippingNode !== null) builder.stack.add(clippingNode);\n\n      // force unsigned floats - useful for RenderTargets\n\n      const basicOutput = vec4(outgoingLightNode, diffuseColor.a).max(0);\n      resultNode = this.setupOutput(builder, basicOutput);\n\n      // OUTPUT NODE\n\n      output.assign(resultNode);\n\n      //\n\n      if (this.outputNode !== null) resultNode = this.outputNode;\n\n      // MRT\n\n      if (renderTarget !== null) {\n        const mrt = renderer.getMRT();\n        const materialMRT = this.mrtNode;\n        if (mrt !== null) {\n          resultNode = mrt;\n          if (materialMRT !== null) {\n            resultNode = mrt.merge(materialMRT);\n          }\n        } else if (materialMRT !== null) {\n          resultNode = materialMRT;\n        }\n      }\n    } else {\n      let fragmentNode = this.fragmentNode;\n      if (fragmentNode.isOutputStructNode !== true) {\n        fragmentNode = vec4(fragmentNode);\n      }\n      resultNode = this.setupOutput(builder, fragmentNode);\n    }\n    builder.stack.outputNode = resultNode;\n    builder.addFlow('fragment', builder.removeStack());\n\n    // < MONITOR >\n\n    builder.monitor = this.setupObserver(builder);\n  }\n  setupClipping(builder) {\n    if (builder.clippingContext === null) return null;\n    const {\n      unionPlanes,\n      intersectionPlanes\n    } = builder.clippingContext;\n    let result = null;\n    if (unionPlanes.length > 0 || intersectionPlanes.length > 0) {\n      const samples = builder.renderer.samples;\n      if (this.alphaToCoverage && samples > 1) {\n        // to be added to flow when the color/alpha value has been determined\n        result = clippingAlpha();\n      } else {\n        builder.stack.add(clipping());\n      }\n    }\n    return result;\n  }\n  setupHardwareClipping(builder) {\n    this.hardwareClipping = false;\n    if (builder.clippingContext === null) return;\n    const candidateCount = builder.clippingContext.unionPlanes.length;\n\n    // 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances\n\n    if (candidateCount > 0 && candidateCount <= 8 && builder.isAvailable('clipDistance')) {\n      builder.stack.add(hardwareClipping());\n      this.hardwareClipping = true;\n    }\n    return;\n  }\n  setupDepth(builder) {\n    const {\n      renderer,\n      camera\n    } = builder;\n\n    // Depth\n\n    let depthNode = this.depthNode;\n    if (depthNode === null) {\n      const mrt = renderer.getMRT();\n      if (mrt && mrt.has('depth')) {\n        depthNode = mrt.get('depth');\n      } else if (renderer.logarithmicDepthBuffer === true) {\n        if (camera.isPerspectiveCamera) {\n          depthNode = viewZToLogarithmicDepth(positionView.z, cameraNear, cameraFar);\n        } else {\n          depthNode = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);\n        }\n      }\n    }\n    if (depthNode !== null) {\n      depth.assign(depthNode).append();\n    }\n  }\n  setupPosition(builder) {\n    const {\n      object\n    } = builder;\n    const geometry = object.geometry;\n    builder.addStack();\n\n    // Vertex\n\n    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {\n      morphReference(object).append();\n    }\n    if (object.isSkinnedMesh === true) {\n      skinningReference(object).append();\n    }\n    if (this.displacementMap) {\n      const displacementMap = materialReference('displacementMap', 'texture');\n      const displacementScale = materialReference('displacementScale', 'float');\n      const displacementBias = materialReference('displacementBias', 'float');\n      positionLocal.addAssign(normalLocal.normalize().mul(displacementMap.x.mul(displacementScale).add(displacementBias)));\n    }\n    if (object.isBatchedMesh) {\n      batch(object).append();\n    }\n    if (object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true) {\n      instancedMesh(object).append();\n    }\n    if (this.positionNode !== null) {\n      positionLocal.assign(this.positionNode);\n    }\n    this.setupHardwareClipping(builder);\n    const mvp = modelViewProjection();\n    builder.context.vertex = builder.removeStack();\n    builder.context.mvp = mvp;\n    return mvp;\n  }\n  setupDiffuseColor({\n    object,\n    geometry\n  }) {\n    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;\n\n    // VERTEX COLORS\n\n    if (this.vertexColors === true && geometry.hasAttribute('color')) {\n      colorNode = vec4(colorNode.xyz.mul(attribute('color', 'vec3')), colorNode.a);\n    }\n\n    // Instanced colors\n\n    if (object.instanceColor) {\n      const instanceColor = varyingProperty('vec3', 'vInstanceColor');\n      colorNode = instanceColor.mul(colorNode);\n    }\n    if (object.isBatchedMesh && object._colorsTexture) {\n      const batchColor = varyingProperty('vec3', 'vBatchColor');\n      colorNode = batchColor.mul(colorNode);\n    }\n\n    // COLOR\n\n    diffuseColor.assign(colorNode);\n\n    // OPACITY\n\n    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n    diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));\n\n    // ALPHA TEST\n\n    if (this.alphaTestNode !== null || this.alphaTest > 0) {\n      const alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;\n      diffuseColor.a.lessThanEqual(alphaTestNode).discard();\n    }\n\n    // ALPHA HASH\n\n    if (this.alphaHash === true) {\n      diffuseColor.a.lessThan(getAlphaHashThreshold(positionLocal)).discard();\n    }\n    if (this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false) {\n      diffuseColor.a.assign(1.0);\n    }\n  }\n  setupVariants(/*builder*/\n  ) {\n\n    // Interface function.\n  }\n  setupOutgoingLight() {\n    return this.lights === true ? vec3(0) : diffuseColor.rgb;\n  }\n  setupNormal() {\n    return this.normalNode ? vec3(this.normalNode) : materialNormal;\n  }\n  setupEnvironment(/*builder*/\n  ) {\n    let node = null;\n    if (this.envNode) {\n      node = this.envNode;\n    } else if (this.envMap) {\n      node = this.envMap.isCubeTexture ? materialReference('envMap', 'cubeTexture') : materialReference('envMap', 'texture');\n    }\n    return node;\n  }\n  setupLightMap(builder) {\n    let node = null;\n    if (builder.material.lightMap) {\n      node = new IrradianceNode(materialLightMap);\n    }\n    return node;\n  }\n  setupLights(builder) {\n    const materialLightsNode = [];\n\n    //\n\n    const envNode = this.setupEnvironment(builder);\n    if (envNode && envNode.isLightingNode) {\n      materialLightsNode.push(envNode);\n    }\n    const lightMapNode = this.setupLightMap(builder);\n    if (lightMapNode && lightMapNode.isLightingNode) {\n      materialLightsNode.push(lightMapNode);\n    }\n    if (this.aoNode !== null || builder.material.aoMap) {\n      const aoNode = this.aoNode !== null ? this.aoNode : materialAOMap;\n      materialLightsNode.push(new AONode(aoNode));\n    }\n    let lightsN = this.lightsNode || builder.lightsNode;\n    if (materialLightsNode.length > 0) {\n      lightsN = builder.renderer.lighting.createNode([...lightsN.getLights(), ...materialLightsNode]);\n    }\n    return lightsN;\n  }\n  setupLightingModel(/*builder*/\n  ) {\n\n    // Interface function.\n  }\n  setupLighting(builder) {\n    const {\n      material\n    } = builder;\n    const {\n      backdropNode,\n      backdropAlphaNode,\n      emissiveNode\n    } = this;\n\n    // OUTGOING LIGHT\n\n    const lights = this.lights === true || this.lightsNode !== null;\n    const lightsNode = lights ? this.setupLights(builder) : null;\n    let outgoingLightNode = this.setupOutgoingLight(builder);\n    if (lightsNode && lightsNode.getScope().hasLights) {\n      const lightingModel = this.setupLightingModel(builder);\n      outgoingLightNode = lightingContext(lightsNode, lightingModel, backdropNode, backdropAlphaNode);\n    } else if (backdropNode !== null) {\n      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);\n    }\n\n    // EMISSIVE\n\n    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {\n      emissive.assign(vec3(emissiveNode ? emissiveNode : materialEmissive));\n      outgoingLightNode = outgoingLightNode.add(emissive);\n    }\n    return outgoingLightNode;\n  }\n  setupOutput(builder, outputNode) {\n    // FOG\n\n    if (this.fog === true) {\n      const fogNode = builder.fogNode;\n      if (fogNode) outputNode = vec4(fogNode.mix(outputNode.rgb, fogNode.colorNode), outputNode.a);\n    }\n    return outputNode;\n  }\n  setDefaultValues(material) {\n    // This approach is to reuse the native refreshUniforms*\n    // and turn available the use of features like transmission and environment in core\n\n    for (const property in material) {\n      const value = material[property];\n      if (this[property] === undefined) {\n        this[property] = value;\n        if (value && value.clone) this[property] = value.clone();\n      }\n    }\n    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);\n    for (const key in descriptors) {\n      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === undefined && descriptors[key].get !== undefined) {\n        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRoot = meta === undefined || typeof meta === 'string';\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n    const data = Material.prototype.toJSON.call(this, meta);\n    const nodeChildren = getNodeChildren(this);\n    data.inputNodes = {};\n    for (const {\n      property,\n      childNode\n    } of nodeChildren) {\n      data.inputNodes[property] = childNode.toJSON(meta).uuid;\n    }\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n  copy(source) {\n    this.lightsNode = source.lightsNode;\n    this.envNode = source.envNode;\n    this.colorNode = source.colorNode;\n    this.normalNode = source.normalNode;\n    this.opacityNode = source.opacityNode;\n    this.backdropNode = source.backdropNode;\n    this.backdropAlphaNode = source.backdropAlphaNode;\n    this.alphaTestNode = source.alphaTestNode;\n    this.positionNode = source.positionNode;\n    this.geometryNode = source.geometryNode;\n    this.depthNode = source.depthNode;\n    this.shadowPositionNode = source.shadowPositionNode;\n    this.receivedShadowNode = source.receivedShadowNode;\n    this.castShadowNode = source.castShadowNode;\n    this.outputNode = source.outputNode;\n    this.mrtNode = source.mrtNode;\n    this.fragmentNode = source.fragmentNode;\n    this.vertexNode = source.vertexNode;\n    return super.copy(source);\n  }\n}\nconst _defaultValues$e = /*@__PURE__*/new PointsMaterial();\nclass InstancedPointsNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'InstancedPointsNodeMaterial';\n  }\n  constructor(params = {}) {\n    super();\n    this.lights = false;\n    this.useAlphaToCoverage = true;\n    this.useColor = params.vertexColors;\n    this.pointWidth = 1;\n    this.pointColorNode = null;\n    this.pointWidthNode = null;\n    this.setDefaultValues(_defaultValues$e);\n    this.setValues(params);\n  }\n  setup(builder) {\n    this.setupShaders(builder);\n    super.setup(builder);\n  }\n  setupShaders({\n    renderer\n  }) {\n    const useAlphaToCoverage = this.alphaToCoverage;\n    const useColor = this.useColor;\n    this.vertexNode = Fn(() => {\n      const instancePosition = attribute('instancePosition').xyz;\n\n      // camera space\n      const mvPos = vec4(modelViewMatrix.mul(vec4(instancePosition, 1.0)));\n      const aspect = viewport.z.div(viewport.w);\n\n      // clip space\n      const clipPos = cameraProjectionMatrix.mul(mvPos);\n\n      // offset in ndc space\n      const offset = positionGeometry.xy.toVar();\n      offset.mulAssign(this.pointWidthNode ? this.pointWidthNode : materialPointWidth);\n      offset.assign(offset.div(viewport.z));\n      offset.y.assign(offset.y.mul(aspect));\n\n      // back to clip space\n      offset.assign(offset.mul(clipPos.w));\n\n      //clipPos.xy += offset;\n      clipPos.addAssign(vec4(offset, 0, 0));\n      return clipPos;\n    })();\n    this.fragmentNode = Fn(() => {\n      const alpha = float(1).toVar();\n      const len2 = lengthSq(uv().mul(2).sub(1));\n      if (useAlphaToCoverage && renderer.samples > 1) {\n        const dlen = float(len2.fwidth()).toVar();\n        alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());\n      } else {\n        len2.greaterThan(1.0).discard();\n      }\n      let pointColorNode;\n      if (this.pointColorNode) {\n        pointColorNode = this.pointColorNode;\n      } else {\n        if (useColor) {\n          const instanceColor = attribute('instanceColor');\n          pointColorNode = instanceColor.mul(materialColor);\n        } else {\n          pointColorNode = materialColor;\n        }\n      }\n      alpha.mulAssign(materialOpacity);\n      return vec4(pointColorNode, alpha);\n    })();\n  }\n  get alphaToCoverage() {\n    return this.useAlphaToCoverage;\n  }\n  set alphaToCoverage(value) {\n    if (this.useAlphaToCoverage !== value) {\n      this.useAlphaToCoverage = value;\n      this.needsUpdate = true;\n    }\n  }\n}\nconst _defaultValues$d = /*@__PURE__*/new LineBasicMaterial();\nclass LineBasicNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'LineBasicNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isLineBasicNodeMaterial = true;\n    this.lights = false;\n    this.setDefaultValues(_defaultValues$d);\n    this.setValues(parameters);\n  }\n}\nconst _defaultValues$c = /*@__PURE__*/new LineDashedMaterial();\nclass LineDashedNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'LineDashedNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isLineDashedNodeMaterial = true;\n    this.lights = false;\n    this.setDefaultValues(_defaultValues$c);\n    this.dashOffset = 0;\n    this.offsetNode = null;\n    this.dashScaleNode = null;\n    this.dashSizeNode = null;\n    this.gapSizeNode = null;\n    this.setValues(parameters);\n  }\n  setupVariants() {\n    const offsetNode = this.offsetNode ? float(this.offsetNodeNode) : materialLineDashOffset;\n    const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;\n    const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;\n    const gapSizeNode = this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;\n    dashSize.assign(dashSizeNode);\n    gapSize.assign(gapSizeNode);\n    const vLineDistance = varying(attribute('lineDistance').mul(dashScaleNode));\n    const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;\n    vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard();\n  }\n}\nlet _sharedFramebuffer = null;\nclass ViewportSharedTextureNode extends ViewportTextureNode {\n  static get type() {\n    return 'ViewportSharedTextureNode';\n  }\n  constructor(uvNode = screenUV, levelNode = null) {\n    if (_sharedFramebuffer === null) {\n      _sharedFramebuffer = new FramebufferTexture();\n    }\n    super(uvNode, levelNode, _sharedFramebuffer);\n  }\n  updateReference() {\n    return this;\n  }\n}\nconst viewportSharedTexture = /*@__PURE__*/nodeProxy(ViewportSharedTextureNode);\nconst _defaultValues$b = /*@__PURE__*/new LineDashedMaterial();\nclass Line2NodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'Line2NodeMaterial';\n  }\n  constructor(params = {}) {\n    super();\n    this.lights = false;\n    this.setDefaultValues(_defaultValues$b);\n    this.useAlphaToCoverage = true;\n    this.useColor = params.vertexColors;\n    this.useDash = params.dashed;\n    this.useWorldUnits = false;\n    this.dashOffset = 0;\n    this.lineWidth = 1;\n    this.lineColorNode = null;\n    this.offsetNode = null;\n    this.dashScaleNode = null;\n    this.dashSizeNode = null;\n    this.gapSizeNode = null;\n    this.blending = NoBlending;\n    this.setValues(params);\n  }\n  setup(builder) {\n    this.setupShaders(builder);\n    super.setup(builder);\n  }\n  setupShaders({\n    renderer\n  }) {\n    const useAlphaToCoverage = this.alphaToCoverage;\n    const useColor = this.useColor;\n    const useDash = this.dashed;\n    const useWorldUnits = this.worldUnits;\n    const trimSegment = Fn(({\n      start,\n      end\n    }) => {\n      const a = cameraProjectionMatrix.element(2).element(2); // 3nd entry in 3th column\n      const b = cameraProjectionMatrix.element(3).element(2); // 3nd entry in 4th column\n      const nearEstimate = b.mul(-0.5).div(a);\n      const alpha = nearEstimate.sub(start.z).div(end.z.sub(start.z));\n      return vec4(mix(start.xyz, end.xyz, alpha), end.w);\n    }).setLayout({\n      name: 'trimSegment',\n      type: 'vec4',\n      inputs: [{\n        name: 'start',\n        type: 'vec4'\n      }, {\n        name: 'end',\n        type: 'vec4'\n      }]\n    });\n    this.vertexNode = Fn(() => {\n      const instanceStart = attribute('instanceStart');\n      const instanceEnd = attribute('instanceEnd');\n\n      // camera space\n\n      const start = vec4(modelViewMatrix.mul(vec4(instanceStart, 1.0))).toVar('start');\n      const end = vec4(modelViewMatrix.mul(vec4(instanceEnd, 1.0))).toVar('end');\n      if (useDash) {\n        const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;\n        const offsetNode = this.offsetNode ? float(this.offsetNodeNode) : materialLineDashOffset;\n        const instanceDistanceStart = attribute('instanceDistanceStart');\n        const instanceDistanceEnd = attribute('instanceDistanceEnd');\n        let lineDistance = positionGeometry.y.lessThan(0.5).select(dashScaleNode.mul(instanceDistanceStart), dashScaleNode.mul(instanceDistanceEnd));\n        lineDistance = lineDistance.add(offsetNode);\n        varyingProperty('float', 'lineDistance').assign(lineDistance);\n      }\n      if (useWorldUnits) {\n        varyingProperty('vec3', 'worldStart').assign(start.xyz);\n        varyingProperty('vec3', 'worldEnd').assign(end.xyz);\n      }\n      const aspect = viewport.z.div(viewport.w);\n\n      // special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n      // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n      // but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n      // perhaps there is a more elegant solution -- WestLangley\n\n      const perspective = cameraProjectionMatrix.element(2).element(3).equal(-1.0); // 4th entry in the 3rd column\n\n      If(perspective, () => {\n        If(start.z.lessThan(0.0).and(end.z.greaterThan(0.0)), () => {\n          end.assign(trimSegment({\n            start: start,\n            end: end\n          }));\n        }).ElseIf(end.z.lessThan(0.0).and(start.z.greaterThanEqual(0.0)), () => {\n          start.assign(trimSegment({\n            start: end,\n            end: start\n          }));\n        });\n      });\n\n      // clip space\n      const clipStart = cameraProjectionMatrix.mul(start);\n      const clipEnd = cameraProjectionMatrix.mul(end);\n\n      // ndc space\n      const ndcStart = clipStart.xyz.div(clipStart.w);\n      const ndcEnd = clipEnd.xyz.div(clipEnd.w);\n\n      // direction\n      const dir = ndcEnd.xy.sub(ndcStart.xy).toVar();\n\n      // account for clip-space aspect ratio\n      dir.x.assign(dir.x.mul(aspect));\n      dir.assign(dir.normalize());\n      const clip = vec4().toVar();\n      if (useWorldUnits) {\n        // get the offset direction as perpendicular to the view vector\n\n        const worldDir = end.xyz.sub(start.xyz).normalize();\n        const tmpFwd = mix(start.xyz, end.xyz, 0.5).normalize();\n        const worldUp = worldDir.cross(tmpFwd).normalize();\n        const worldFwd = worldDir.cross(worldUp);\n        const worldPos = varyingProperty('vec4', 'worldPos');\n        worldPos.assign(positionGeometry.y.lessThan(0.5).select(start, end));\n\n        // height offset\n        const hw = materialLineWidth.mul(0.5);\n        worldPos.addAssign(vec4(positionGeometry.x.lessThan(0.0).select(worldUp.mul(hw), worldUp.mul(hw).negate()), 0));\n\n        // don't extend the line if we're rendering dashes because we\n        // won't be rendering the endcaps\n        if (!useDash) {\n          // cap extension\n          worldPos.addAssign(vec4(positionGeometry.y.lessThan(0.5).select(worldDir.mul(hw).negate(), worldDir.mul(hw)), 0));\n\n          // add width to the box\n          worldPos.addAssign(vec4(worldFwd.mul(hw), 0));\n\n          // endcaps\n          If(positionGeometry.y.greaterThan(1.0).or(positionGeometry.y.lessThan(0.0)), () => {\n            worldPos.subAssign(vec4(worldFwd.mul(2.0).mul(hw), 0));\n          });\n        }\n\n        // project the worldpos\n        clip.assign(cameraProjectionMatrix.mul(worldPos));\n\n        // shift the depth of the projected points so the line\n        // segments overlap neatly\n        const clipPose = vec3().toVar();\n        clipPose.assign(positionGeometry.y.lessThan(0.5).select(ndcStart, ndcEnd));\n        clip.z.assign(clipPose.z.mul(clip.w));\n      } else {\n        const offset = vec2(dir.y, dir.x.negate()).toVar('offset');\n\n        // undo aspect ratio adjustment\n        dir.x.assign(dir.x.div(aspect));\n        offset.x.assign(offset.x.div(aspect));\n\n        // sign flip\n        offset.assign(positionGeometry.x.lessThan(0.0).select(offset.negate(), offset));\n\n        // endcaps\n        If(positionGeometry.y.lessThan(0.0), () => {\n          offset.assign(offset.sub(dir));\n        }).ElseIf(positionGeometry.y.greaterThan(1.0), () => {\n          offset.assign(offset.add(dir));\n        });\n\n        // adjust for linewidth\n        offset.assign(offset.mul(materialLineWidth));\n\n        // adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n        offset.assign(offset.div(viewport.w));\n\n        // select end\n        clip.assign(positionGeometry.y.lessThan(0.5).select(clipStart, clipEnd));\n\n        // back to clip space\n        offset.assign(offset.mul(clip.w));\n        clip.assign(clip.add(vec4(offset, 0, 0)));\n      }\n      return clip;\n    })();\n    const closestLineToLine = Fn(({\n      p1,\n      p2,\n      p3,\n      p4\n    }) => {\n      const p13 = p1.sub(p3);\n      const p43 = p4.sub(p3);\n      const p21 = p2.sub(p1);\n      const d1343 = p13.dot(p43);\n      const d4321 = p43.dot(p21);\n      const d1321 = p13.dot(p21);\n      const d4343 = p43.dot(p43);\n      const d2121 = p21.dot(p21);\n      const denom = d2121.mul(d4343).sub(d4321.mul(d4321));\n      const numer = d1343.mul(d4321).sub(d1321.mul(d4343));\n      const mua = numer.div(denom).clamp();\n      const mub = d1343.add(d4321.mul(mua)).div(d4343).clamp();\n      return vec2(mua, mub);\n    });\n    this.colorNode = Fn(() => {\n      const vUv = uv();\n      if (useDash) {\n        const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;\n        const gapSizeNode = this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;\n        dashSize.assign(dashSizeNode);\n        gapSize.assign(gapSizeNode);\n        const vLineDistance = varyingProperty('float', 'lineDistance');\n        vUv.y.lessThan(-1.0).or(vUv.y.greaterThan(1.0)).discard(); // discard endcaps\n        vLineDistance.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard(); // todo - FIX\n      }\n      const alpha = float(1).toVar('alpha');\n      if (useWorldUnits) {\n        const worldStart = varyingProperty('vec3', 'worldStart');\n        const worldEnd = varyingProperty('vec3', 'worldEnd');\n\n        // Find the closest points on the view ray and the line segment\n        const rayEnd = varyingProperty('vec4', 'worldPos').xyz.normalize().mul(1e5);\n        const lineDir = worldEnd.sub(worldStart);\n        const params = closestLineToLine({\n          p1: worldStart,\n          p2: worldEnd,\n          p3: vec3(0.0, 0.0, 0.0),\n          p4: rayEnd\n        });\n        const p1 = worldStart.add(lineDir.mul(params.x));\n        const p2 = rayEnd.mul(params.y);\n        const delta = p1.sub(p2);\n        const len = delta.length();\n        const norm = len.div(materialLineWidth);\n        if (!useDash) {\n          if (useAlphaToCoverage && renderer.samples > 1) {\n            const dnorm = norm.fwidth();\n            alpha.assign(smoothstep(dnorm.negate().add(0.5), dnorm.add(0.5), norm).oneMinus());\n          } else {\n            norm.greaterThan(0.5).discard();\n          }\n        }\n      } else {\n        // round endcaps\n\n        if (useAlphaToCoverage && renderer.samples > 1) {\n          const a = vUv.x;\n          const b = vUv.y.greaterThan(0.0).select(vUv.y.sub(1.0), vUv.y.add(1.0));\n          const len2 = a.mul(a).add(b.mul(b));\n          const dlen = float(len2.fwidth()).toVar('dlen');\n          If(vUv.y.abs().greaterThan(1.0), () => {\n            alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());\n          });\n        } else {\n          If(vUv.y.abs().greaterThan(1.0), () => {\n            const a = vUv.x;\n            const b = vUv.y.greaterThan(0.0).select(vUv.y.sub(1.0), vUv.y.add(1.0));\n            const len2 = a.mul(a).add(b.mul(b));\n            len2.greaterThan(1.0).discard();\n          });\n        }\n      }\n      let lineColorNode;\n      if (this.lineColorNode) {\n        lineColorNode = this.lineColorNode;\n      } else {\n        if (useColor) {\n          const instanceColorStart = attribute('instanceColorStart');\n          const instanceColorEnd = attribute('instanceColorEnd');\n          const instanceColor = positionGeometry.y.lessThan(0.5).select(instanceColorStart, instanceColorEnd);\n          lineColorNode = instanceColor.mul(materialColor);\n        } else {\n          lineColorNode = materialColor;\n        }\n      }\n      return vec4(lineColorNode, alpha);\n    })();\n    if (this.transparent) {\n      const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n      this.outputNode = vec4(this.colorNode.rgb.mul(opacityNode).add(viewportSharedTexture().rgb.mul(opacityNode.oneMinus())), this.colorNode.a);\n    }\n  }\n  get worldUnits() {\n    return this.useWorldUnits;\n  }\n  set worldUnits(value) {\n    if (this.useWorldUnits !== value) {\n      this.useWorldUnits = value;\n      this.needsUpdate = true;\n    }\n  }\n  get dashed() {\n    return this.useDash;\n  }\n  set dashed(value) {\n    if (this.useDash !== value) {\n      this.useDash = value;\n      this.needsUpdate = true;\n    }\n  }\n  get alphaToCoverage() {\n    return this.useAlphaToCoverage;\n  }\n  set alphaToCoverage(value) {\n    if (this.useAlphaToCoverage !== value) {\n      this.useAlphaToCoverage = value;\n      this.needsUpdate = true;\n    }\n  }\n}\nconst directionToColor = node => nodeObject(node).mul(0.5).add(0.5);\nconst colorToDirection = node => nodeObject(node).mul(2.0).sub(1);\nconst _defaultValues$a = /*@__PURE__*/new MeshNormalMaterial();\nclass MeshNormalNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshNormalNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.lights = false;\n    this.isMeshNormalNodeMaterial = true;\n    this.setDefaultValues(_defaultValues$a);\n    this.setValues(parameters);\n  }\n  setupDiffuseColor() {\n    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n    diffuseColor.assign(vec4(directionToColor(transformedNormalView), opacityNode));\n  }\n}\nclass EquirectUVNode extends TempNode {\n  static get type() {\n    return 'EquirectUVNode';\n  }\n  constructor(dirNode = positionWorldDirection) {\n    super('vec2');\n    this.dirNode = dirNode;\n  }\n  setup() {\n    const dir = this.dirNode;\n    const u = dir.z.atan2(dir.x).mul(1 / (Math.PI * 2)).add(0.5);\n    const v = dir.y.clamp(-1.0, 1.0).asin().mul(1 / Math.PI).add(0.5);\n    return vec2(u, v);\n  }\n}\nconst equirectUV = /*@__PURE__*/nodeProxy(EquirectUVNode);\n\n// @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget\n\nclass CubeRenderTarget extends WebGLCubeRenderTarget {\n  constructor(size = 1, options = {}) {\n    super(size, options);\n    this.isCubeRenderTarget = true;\n  }\n  fromEquirectangularTexture(renderer, texture$1) {\n    const currentMinFilter = texture$1.minFilter;\n    const currentGenerateMipmaps = texture$1.generateMipmaps;\n    texture$1.generateMipmaps = true;\n    this.texture.type = texture$1.type;\n    this.texture.colorSpace = texture$1.colorSpace;\n    this.texture.generateMipmaps = texture$1.generateMipmaps;\n    this.texture.minFilter = texture$1.minFilter;\n    this.texture.magFilter = texture$1.magFilter;\n    const geometry = new BoxGeometry(5, 5, 5);\n    const uvNode = equirectUV(positionWorldDirection);\n    const material = new NodeMaterial();\n    material.colorNode = texture(texture$1, uvNode, 0);\n    material.side = BackSide;\n    material.blending = NoBlending;\n    const mesh = new Mesh(geometry, material);\n    const scene = new Scene();\n    scene.add(mesh);\n\n    // Avoid blurred poles\n    if (texture$1.minFilter === LinearMipmapLinearFilter) texture$1.minFilter = LinearFilter;\n    const camera = new CubeCamera(1, 10, this);\n    const currentMRT = renderer.getMRT();\n    renderer.setMRT(null);\n    camera.update(renderer, scene);\n    renderer.setMRT(currentMRT);\n    texture$1.minFilter = currentMinFilter;\n    texture$1.currentGenerateMipmaps = currentGenerateMipmaps;\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    return this;\n  }\n}\nconst _cache$1 = new WeakMap();\nclass CubeMapNode extends TempNode {\n  static get type() {\n    return 'CubeMapNode';\n  }\n  constructor(envNode) {\n    super('vec3');\n    this.envNode = envNode;\n    this._cubeTexture = null;\n    this._cubeTextureNode = cubeTexture();\n    const defaultTexture = new CubeTexture();\n    defaultTexture.isRenderTargetTexture = true;\n    this._defaultTexture = defaultTexture;\n    this.updateBeforeType = NodeUpdateType.RENDER;\n  }\n  updateBefore(frame) {\n    const {\n      renderer,\n      material\n    } = frame;\n    const envNode = this.envNode;\n    if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {\n      const texture = envNode.isTextureNode ? envNode.value : material[envNode.property];\n      if (texture && texture.isTexture) {\n        const mapping = texture.mapping;\n        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {\n          // check for converted cubemap map\n\n          if (_cache$1.has(texture)) {\n            const cubeMap = _cache$1.get(texture);\n            mapTextureMapping(cubeMap, texture.mapping);\n            this._cubeTexture = cubeMap;\n          } else {\n            // create cube map from equirectangular map\n\n            const image = texture.image;\n            if (isEquirectangularMapReady$1(image)) {\n              const renderTarget = new CubeRenderTarget(image.height);\n              renderTarget.fromEquirectangularTexture(renderer, texture);\n              mapTextureMapping(renderTarget.texture, texture.mapping);\n              this._cubeTexture = renderTarget.texture;\n              _cache$1.set(texture, renderTarget.texture);\n              texture.addEventListener('dispose', onTextureDispose);\n            } else {\n              // default cube texture as fallback when equirectangular texture is not yet loaded\n\n              this._cubeTexture = this._defaultTexture;\n            }\n          }\n\n          //\n\n          this._cubeTextureNode.value = this._cubeTexture;\n        } else {\n          // envNode already refers to a cube map\n\n          this._cubeTextureNode = this.envNode;\n        }\n      }\n    }\n  }\n  setup(builder) {\n    this.updateBefore(builder);\n    return this._cubeTextureNode;\n  }\n}\nfunction isEquirectangularMapReady$1(image) {\n  if (image === null || image === undefined) return false;\n  return image.height > 0;\n}\nfunction onTextureDispose(event) {\n  const texture = event.target;\n  texture.removeEventListener('dispose', onTextureDispose);\n  const renderTarget = _cache$1.get(texture);\n  if (renderTarget !== undefined) {\n    _cache$1.delete(texture);\n    renderTarget.dispose();\n  }\n}\nfunction mapTextureMapping(texture, mapping) {\n  if (mapping === EquirectangularReflectionMapping) {\n    texture.mapping = CubeReflectionMapping;\n  } else if (mapping === EquirectangularRefractionMapping) {\n    texture.mapping = CubeRefractionMapping;\n  }\n}\nconst cubeMapNode = /*@__PURE__*/nodeProxy(CubeMapNode);\nclass BasicEnvironmentNode extends LightingNode {\n  static get type() {\n    return 'BasicEnvironmentNode';\n  }\n  constructor(envNode = null) {\n    super();\n    this.envNode = envNode;\n  }\n  setup(builder) {\n    // environment property is used in the finish() method of BasicLightingModel\n\n    builder.context.environment = cubeMapNode(this.envNode);\n  }\n}\nclass BasicLightMapNode extends LightingNode {\n  static get type() {\n    return 'BasicLightMapNode';\n  }\n  constructor(lightMapNode = null) {\n    super();\n    this.lightMapNode = lightMapNode;\n  }\n  setup(builder) {\n    // irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel\n\n    const RECIPROCAL_PI = float(1 / Math.PI);\n    builder.context.irradianceLightMap = this.lightMapNode.mul(RECIPROCAL_PI);\n  }\n}\nclass LightingModel {\n  start(/*input, stack, builder*/) {}\n  finish(/*input, stack, builder*/) {}\n  direct(/*input, stack, builder*/) {}\n  directRectArea(/*input, stack, builder*/) {}\n  indirect(/*input, stack, builder*/) {}\n  ambientOcclusion(/*input, stack, builder*/) {}\n}\nclass BasicLightingModel extends LightingModel {\n  constructor() {\n    super();\n  }\n  indirect(context, stack, builder) {\n    const ambientOcclusion = context.ambientOcclusion;\n    const reflectedLight = context.reflectedLight;\n    const irradianceLightMap = builder.context.irradianceLightMap;\n    reflectedLight.indirectDiffuse.assign(vec4(0.0));\n\n    // accumulation (baked indirect lighting only)\n\n    if (irradianceLightMap) {\n      reflectedLight.indirectDiffuse.addAssign(irradianceLightMap);\n    } else {\n      reflectedLight.indirectDiffuse.addAssign(vec4(1.0, 1.0, 1.0, 0.0));\n    }\n\n    // modulation\n\n    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n    reflectedLight.indirectDiffuse.mulAssign(diffuseColor.rgb);\n  }\n  finish(context, stack, builder) {\n    const material = builder.material;\n    const outgoingLight = context.outgoingLight;\n    const envNode = builder.context.environment;\n    if (envNode) {\n      switch (material.combine) {\n        case MultiplyOperation:\n          outgoingLight.rgb.assign(mix(outgoingLight.rgb, outgoingLight.rgb.mul(envNode.rgb), materialSpecularStrength.mul(materialReflectivity)));\n          break;\n        case MixOperation:\n          outgoingLight.rgb.assign(mix(outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul(materialReflectivity)));\n          break;\n        case AddOperation:\n          outgoingLight.rgb.addAssign(envNode.rgb.mul(materialSpecularStrength.mul(materialReflectivity)));\n          break;\n        default:\n          console.warn('THREE.BasicLightingModel: Unsupported .combine value:', material.combine);\n          break;\n      }\n    }\n  }\n}\nconst _defaultValues$9 = /*@__PURE__*/new MeshBasicMaterial();\nclass MeshBasicNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshBasicNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshBasicNodeMaterial = true;\n    this.lights = true;\n    this.setDefaultValues(_defaultValues$9);\n    this.setValues(parameters);\n  }\n  setupNormal() {\n    return normalView; // see #28839\n  }\n  setupEnvironment(builder) {\n    const envNode = super.setupEnvironment(builder);\n    return envNode ? new BasicEnvironmentNode(envNode) : null;\n  }\n  setupLightMap(builder) {\n    let node = null;\n    if (builder.material.lightMap) {\n      node = new BasicLightMapNode(materialLightMap);\n    }\n    return node;\n  }\n  setupOutgoingLight() {\n    return diffuseColor.rgb;\n  }\n  setupLightingModel() {\n    return new BasicLightingModel();\n  }\n}\nconst F_Schlick = /*@__PURE__*/Fn(({\n  f0,\n  f90,\n  dotVH\n}) => {\n  // Original approximation by Christophe Schlick '94\n  // float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n  // Optimized variant (presented by Epic at SIGGRAPH '13)\n  // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n  const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();\n  return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));\n}); // validated\n\nconst BRDF_Lambert = /*@__PURE__*/Fn(inputs => {\n  return inputs.diffuseColor.mul(1 / Math.PI); // punctual light\n}); // validated\n\nconst G_BlinnPhong_Implicit = () => float(0.25);\nconst D_BlinnPhong = /*@__PURE__*/Fn(({\n  dotNH\n}) => {\n  return shininess.mul(float(0.5)).add(1.0).mul(float(1 / Math.PI)).mul(dotNH.pow(shininess));\n});\nconst BRDF_BlinnPhong = /*@__PURE__*/Fn(({\n  lightDirection\n}) => {\n  const halfDir = lightDirection.add(positionViewDirection).normalize();\n  const dotNH = transformedNormalView.dot(halfDir).clamp();\n  const dotVH = positionViewDirection.dot(halfDir).clamp();\n  const F = F_Schlick({\n    f0: specularColor,\n    f90: 1.0,\n    dotVH\n  });\n  const G = G_BlinnPhong_Implicit();\n  const D = D_BlinnPhong({\n    dotNH\n  });\n  return F.mul(G).mul(D);\n});\nclass PhongLightingModel extends BasicLightingModel {\n  constructor(specular = true) {\n    super();\n    this.specular = specular;\n  }\n  direct({\n    lightDirection,\n    lightColor,\n    reflectedLight\n  }) {\n    const dotNL = transformedNormalView.dot(lightDirection).clamp();\n    const irradiance = dotNL.mul(lightColor);\n    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor: diffuseColor.rgb\n    })));\n    if (this.specular === true) {\n      reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong({\n        lightDirection\n      })).mul(materialSpecularStrength));\n    }\n  }\n  indirect({\n    ambientOcclusion,\n    irradiance,\n    reflectedLight\n  }) {\n    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor\n    })));\n    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n  }\n}\nconst _defaultValues$8 = /*@__PURE__*/new MeshLambertMaterial();\nclass MeshLambertNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshLambertNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshLambertNodeMaterial = true;\n    this.lights = true;\n    this.setDefaultValues(_defaultValues$8);\n    this.setValues(parameters);\n  }\n  setupEnvironment(builder) {\n    const envNode = super.setupEnvironment(builder);\n    return envNode ? new BasicEnvironmentNode(envNode) : null;\n  }\n  setupLightingModel(/*builder*/\n  ) {\n    return new PhongLightingModel(false); // ( specular ) -> force lambert\n  }\n}\nconst _defaultValues$7 = /*@__PURE__*/new MeshPhongMaterial();\nclass MeshPhongNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshPhongNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshPhongNodeMaterial = true;\n    this.lights = true;\n    this.shininessNode = null;\n    this.specularNode = null;\n    this.setDefaultValues(_defaultValues$7);\n    this.setValues(parameters);\n  }\n  setupEnvironment(builder) {\n    const envNode = super.setupEnvironment(builder);\n    return envNode ? new BasicEnvironmentNode(envNode) : null;\n  }\n  setupLightingModel(/*builder*/\n  ) {\n    return new PhongLightingModel();\n  }\n  setupVariants() {\n    // SHININESS\n\n    const shininessNode = (this.shininessNode ? float(this.shininessNode) : materialShininess).max(1e-4); // to prevent pow( 0.0, 0.0 )\n\n    shininess.assign(shininessNode);\n\n    // SPECULAR COLOR\n\n    const specularNode = this.specularNode || materialSpecular;\n    specularColor.assign(specularNode);\n  }\n  copy(source) {\n    this.shininessNode = source.shininessNode;\n    this.specularNode = source.specularNode;\n    return super.copy(source);\n  }\n}\nconst getGeometryRoughness = /*@__PURE__*/Fn(builder => {\n  if (builder.geometry.hasAttribute('normal') === false) {\n    return float(0);\n  }\n  const dxy = normalView.dFdx().abs().max(normalView.dFdy().abs());\n  const geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);\n  return geometryRoughness;\n});\nconst getRoughness = /*@__PURE__*/Fn(inputs => {\n  const {\n    roughness\n  } = inputs;\n  const geometryRoughness = getGeometryRoughness();\n  let roughnessFactor = roughness.max(0.0525); // 0.0525 corresponds to the base mip of a 256 cubemap.\n  roughnessFactor = roughnessFactor.add(geometryRoughness);\n  roughnessFactor = roughnessFactor.min(1.0);\n  return roughnessFactor;\n});\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nconst V_GGX_SmithCorrelated = /*@__PURE__*/Fn(({\n  alpha,\n  dotNL,\n  dotNV\n}) => {\n  const a2 = alpha.pow2();\n  const gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());\n  const gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());\n  return div(0.5, gv.add(gl).max(EPSILON));\n}).setLayout({\n  name: 'V_GGX_SmithCorrelated',\n  type: 'float',\n  inputs: [{\n    name: 'alpha',\n    type: 'float'\n  }, {\n    name: 'dotNL',\n    type: 'float'\n  }, {\n    name: 'dotNV',\n    type: 'float'\n  }]\n}); // validated\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/Fn(({\n  alphaT,\n  alphaB,\n  dotTV,\n  dotBV,\n  dotTL,\n  dotBL,\n  dotNV,\n  dotNL\n}) => {\n  const gv = dotNL.mul(vec3(alphaT.mul(dotTV), alphaB.mul(dotBV), dotNV).length());\n  const gl = dotNV.mul(vec3(alphaT.mul(dotTL), alphaB.mul(dotBL), dotNL).length());\n  const v = div(0.5, gv.add(gl));\n  return v.saturate();\n}).setLayout({\n  name: 'V_GGX_SmithCorrelated_Anisotropic',\n  type: 'float',\n  inputs: [{\n    name: 'alphaT',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'alphaB',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotTV',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotBV',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotTL',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotBL',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotNV',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotNL',\n    type: 'float',\n    qualifier: 'in'\n  }]\n});\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nconst D_GGX = /*@__PURE__*/Fn(({\n  alpha,\n  dotNH\n}) => {\n  const a2 = alpha.pow2();\n  const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus(); // avoid alpha = 0 with dotNH = 1\n\n  return a2.div(denom.pow2()).mul(1 / Math.PI);\n}).setLayout({\n  name: 'D_GGX',\n  type: 'float',\n  inputs: [{\n    name: 'alpha',\n    type: 'float'\n  }, {\n    name: 'dotNH',\n    type: 'float'\n  }]\n}); // validated\n\nconst RECIPROCAL_PI = /*@__PURE__*/float(1 / Math.PI);\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst D_GGX_Anisotropic = /*@__PURE__*/Fn(({\n  alphaT,\n  alphaB,\n  dotNH,\n  dotTH,\n  dotBH\n}) => {\n  const a2 = alphaT.mul(alphaB);\n  const v = vec3(alphaB.mul(dotTH), alphaT.mul(dotBH), a2.mul(dotNH));\n  const v2 = v.dot(v);\n  const w2 = a2.div(v2);\n  return RECIPROCAL_PI.mul(a2.mul(w2.pow2()));\n}).setLayout({\n  name: 'D_GGX_Anisotropic',\n  type: 'float',\n  inputs: [{\n    name: 'alphaT',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'alphaB',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotNH',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotTH',\n    type: 'float',\n    qualifier: 'in'\n  }, {\n    name: 'dotBH',\n    type: 'float',\n    qualifier: 'in'\n  }]\n});\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nconst BRDF_GGX = /*@__PURE__*/Fn(inputs => {\n  const {\n    lightDirection,\n    f0,\n    f90,\n    roughness,\n    f,\n    USE_IRIDESCENCE,\n    USE_ANISOTROPY\n  } = inputs;\n  const normalView = inputs.normalView || transformedNormalView;\n  const alpha = roughness.pow2(); // UE4's roughness\n\n  const halfDir = lightDirection.add(positionViewDirection).normalize();\n  const dotNL = normalView.dot(lightDirection).clamp();\n  const dotNV = normalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV\n  const dotNH = normalView.dot(halfDir).clamp();\n  const dotVH = positionViewDirection.dot(halfDir).clamp();\n  let F = F_Schlick({\n    f0,\n    f90,\n    dotVH\n  });\n  let V, D;\n  if (defined(USE_IRIDESCENCE)) {\n    F = iridescence.mix(F, f);\n  }\n  if (defined(USE_ANISOTROPY)) {\n    const dotTL = anisotropyT.dot(lightDirection);\n    const dotTV = anisotropyT.dot(positionViewDirection);\n    const dotTH = anisotropyT.dot(halfDir);\n    const dotBL = anisotropyB.dot(lightDirection);\n    const dotBV = anisotropyB.dot(positionViewDirection);\n    const dotBH = anisotropyB.dot(halfDir);\n    V = V_GGX_SmithCorrelated_Anisotropic({\n      alphaT,\n      alphaB: alpha,\n      dotTV,\n      dotBV,\n      dotTL,\n      dotBL,\n      dotNV,\n      dotNL\n    });\n    D = D_GGX_Anisotropic({\n      alphaT,\n      alphaB: alpha,\n      dotNH,\n      dotTH,\n      dotBH\n    });\n  } else {\n    V = V_GGX_SmithCorrelated({\n      alpha,\n      dotNL,\n      dotNV\n    });\n    D = D_GGX({\n      alpha,\n      dotNH\n    });\n  }\n  return F.mul(V).mul(D);\n}); // validated\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from \"Physically Based Shading on Mobile\"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nconst DFGApprox = /*@__PURE__*/Fn(({\n  roughness,\n  dotNV\n}) => {\n  const c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const c1 = vec4(1, 0.0425, 1.04, -0.04);\n  const r = roughness.mul(c0).add(c1);\n  const a004 = r.x.mul(r.x).min(dotNV.mul(-9.28).exp2()).mul(r.x).add(r.y);\n  const fab = vec2(-1.04, 1.04).mul(a004).add(r.zw);\n  return fab;\n}).setLayout({\n  name: 'DFGApprox',\n  type: 'vec2',\n  inputs: [{\n    name: 'roughness',\n    type: 'float'\n  }, {\n    name: 'dotNV',\n    type: 'vec3'\n  }]\n});\nconst EnvironmentBRDF = /*@__PURE__*/Fn(inputs => {\n  const {\n    dotNV,\n    specularColor,\n    specularF90,\n    roughness\n  } = inputs;\n  const fab = DFGApprox({\n    dotNV,\n    roughness\n  });\n  return specularColor.mul(fab.x).add(specularF90.mul(fab.y));\n});\nconst Schlick_to_F0 = /*@__PURE__*/Fn(({\n  f,\n  f90,\n  dotVH\n}) => {\n  const x = dotVH.oneMinus().saturate();\n  const x2 = x.mul(x);\n  const x5 = x.mul(x2, x2).clamp(0, .9999);\n  return f.sub(vec3(f90).mul(x5)).div(x5.oneMinus());\n}).setLayout({\n  name: 'Schlick_to_F0',\n  type: 'vec3',\n  inputs: [{\n    name: 'f',\n    type: 'vec3'\n  }, {\n    name: 'f90',\n    type: 'float'\n  }, {\n    name: 'dotVH',\n    type: 'float'\n  }]\n});\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst D_Charlie = /*@__PURE__*/Fn(({\n  roughness,\n  dotNH\n}) => {\n  const alpha = roughness.pow2();\n\n  // Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n  const invAlpha = float(1.0).div(alpha);\n  const cos2h = dotNH.pow2();\n  const sin2h = cos2h.oneMinus().max(0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\n  return float(2.0).add(invAlpha).mul(sin2h.pow(invAlpha.mul(0.5))).div(2.0 * Math.PI);\n}).setLayout({\n  name: 'D_Charlie',\n  type: 'float',\n  inputs: [{\n    name: 'roughness',\n    type: 'float'\n  }, {\n    name: 'dotNH',\n    type: 'float'\n  }]\n});\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst V_Neubelt = /*@__PURE__*/Fn(({\n  dotNV,\n  dotNL\n}) => {\n  // Neubelt and Pettineo 2013, \"Crafting a Next-gen Material Pipeline for The Order: 1886\"\n  return float(1.0).div(float(4.0).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));\n}).setLayout({\n  name: 'V_Neubelt',\n  type: 'float',\n  inputs: [{\n    name: 'dotNV',\n    type: 'float'\n  }, {\n    name: 'dotNL',\n    type: 'float'\n  }]\n});\nconst BRDF_Sheen = /*@__PURE__*/Fn(({\n  lightDirection\n}) => {\n  const halfDir = lightDirection.add(positionViewDirection).normalize();\n  const dotNL = transformedNormalView.dot(lightDirection).clamp();\n  const dotNV = transformedNormalView.dot(positionViewDirection).clamp();\n  const dotNH = transformedNormalView.dot(halfDir).clamp();\n  const D = D_Charlie({\n    roughness: sheenRoughness,\n    dotNH\n  });\n  const V = V_Neubelt({\n    dotNV,\n    dotNL\n  });\n  return sheen.mul(D).mul(V);\n});\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nconst LTC_Uv = /*@__PURE__*/Fn(({\n  N,\n  V,\n  roughness\n}) => {\n  const LUT_SIZE = 64.0;\n  const LUT_SCALE = (LUT_SIZE - 1.0) / LUT_SIZE;\n  const LUT_BIAS = 0.5 / LUT_SIZE;\n  const dotNV = N.dot(V).saturate();\n\n  // texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n  const uv = vec2(roughness, dotNV.oneMinus().sqrt());\n  uv.assign(uv.mul(LUT_SCALE).add(LUT_BIAS));\n  return uv;\n}).setLayout({\n  name: 'LTC_Uv',\n  type: 'vec2',\n  inputs: [{\n    name: 'N',\n    type: 'vec3'\n  }, {\n    name: 'V',\n    type: 'vec3'\n  }, {\n    name: 'roughness',\n    type: 'float'\n  }]\n});\nconst LTC_ClippedSphereFormFactor = /*@__PURE__*/Fn(({\n  f\n}) => {\n  // Real-Time Area Lighting: a Journey from Research to Production (p.102)\n  // An approximation of the form factor of a horizon-clipped rectangle.\n\n  const l = f.length();\n  return max$1(l.mul(l).add(f.z).div(l.add(1.0)), 0);\n}).setLayout({\n  name: 'LTC_ClippedSphereFormFactor',\n  type: 'float',\n  inputs: [{\n    name: 'f',\n    type: 'vec3'\n  }]\n});\nconst LTC_EdgeVectorFormFactor = /*@__PURE__*/Fn(({\n  v1,\n  v2\n}) => {\n  const x = v1.dot(v2);\n  const y = x.abs().toVar();\n\n  // rational polynomial approximation to theta / sin( theta ) / 2PI\n  const a = y.mul(0.0145206).add(0.4965155).mul(y).add(0.8543985).toVar();\n  const b = y.add(4.1616724).mul(y).add(3.4175940).toVar();\n  const v = a.div(b);\n  const theta_sintheta = x.greaterThan(0.0).select(v, max$1(x.mul(x).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(v));\n  return v1.cross(v2).mul(theta_sintheta);\n}).setLayout({\n  name: 'LTC_EdgeVectorFormFactor',\n  type: 'vec3',\n  inputs: [{\n    name: 'v1',\n    type: 'vec3'\n  }, {\n    name: 'v2',\n    type: 'vec3'\n  }]\n});\nconst LTC_Evaluate = /*@__PURE__*/Fn(({\n  N,\n  V,\n  P,\n  mInv,\n  p0,\n  p1,\n  p2,\n  p3\n}) => {\n  // bail if point is on back side of plane of light\n  // assumes ccw winding order of light vertices\n  const v1 = p1.sub(p0).toVar();\n  const v2 = p3.sub(p0).toVar();\n  const lightNormal = v1.cross(v2);\n  const result = vec3().toVar();\n  If(lightNormal.dot(P.sub(p0)).greaterThanEqual(0.0), () => {\n    // construct orthonormal basis around N\n    const T1 = V.sub(N.mul(V.dot(N))).normalize();\n    const T2 = N.cross(T1).negate(); // negated from paper; possibly due to a different handedness of world coordinate system\n\n    // compute transform\n    const mat = mInv.mul(mat3(T1, T2, N).transpose()).toVar();\n\n    // transform rect\n    // & project rect onto sphere\n    const coords0 = mat.mul(p0.sub(P)).normalize().toVar();\n    const coords1 = mat.mul(p1.sub(P)).normalize().toVar();\n    const coords2 = mat.mul(p2.sub(P)).normalize().toVar();\n    const coords3 = mat.mul(p3.sub(P)).normalize().toVar();\n\n    // calculate vector form factor\n    const vectorFormFactor = vec3(0).toVar();\n    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({\n      v1: coords0,\n      v2: coords1\n    }));\n    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({\n      v1: coords1,\n      v2: coords2\n    }));\n    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({\n      v1: coords2,\n      v2: coords3\n    }));\n    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({\n      v1: coords3,\n      v2: coords0\n    }));\n\n    // adjust for horizon clipping\n    result.assign(vec3(LTC_ClippedSphereFormFactor({\n      f: vectorFormFactor\n    })));\n  });\n  return result;\n}).setLayout({\n  name: 'LTC_Evaluate',\n  type: 'vec3',\n  inputs: [{\n    name: 'N',\n    type: 'vec3'\n  }, {\n    name: 'V',\n    type: 'vec3'\n  }, {\n    name: 'P',\n    type: 'vec3'\n  }, {\n    name: 'mInv',\n    type: 'mat3'\n  }, {\n    name: 'p0',\n    type: 'vec3'\n  }, {\n    name: 'p1',\n    type: 'vec3'\n  }, {\n    name: 'p2',\n    type: 'vec3'\n  }, {\n    name: 'p3',\n    type: 'vec3'\n  }]\n});\n\n// Mipped Bicubic Texture Filtering by N8\n// https://www.shadertoy.com/view/Dl2SDW\n\nconst bC = 1.0 / 6.0;\nconst w0 = a => mul(bC, mul(a, mul(a, a.negate().add(3.0)).sub(3.0)).add(1.0));\nconst w1 = a => mul(bC, mul(a, mul(a, mul(3.0, a).sub(6.0))).add(4.0));\nconst w2 = a => mul(bC, mul(a, mul(a, mul(-3.0, a).add(3.0)).add(3.0)).add(1.0));\nconst w3 = a => mul(bC, pow(a, 3));\nconst g0 = a => w0(a).add(w1(a));\nconst g1 = a => w2(a).add(w3(a));\n\n// h0 and h1 are the two offset functions\nconst h0 = a => add(-1.0, w1(a).div(w0(a).add(w1(a))));\nconst h1 = a => add(1.0, w3(a).div(w2(a).add(w3(a))));\nconst bicubic = (textureNode, texelSize, lod) => {\n  const uv = textureNode.uvNode;\n  const uvScaled = mul(uv, texelSize.zw).add(0.5);\n  const iuv = floor(uvScaled);\n  const fuv = fract(uvScaled);\n  const g0x = g0(fuv.x);\n  const g1x = g1(fuv.x);\n  const h0x = h0(fuv.x);\n  const h1x = h1(fuv.x);\n  const h0y = h0(fuv.y);\n  const h1y = h1(fuv.y);\n  const p0 = vec2(iuv.x.add(h0x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);\n  const p1 = vec2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);\n  const p2 = vec2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);\n  const p3 = vec2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);\n  const a = g0(fuv.y).mul(add(g0x.mul(textureNode.uv(p0).level(lod)), g1x.mul(textureNode.uv(p1).level(lod))));\n  const b = g1(fuv.y).mul(add(g0x.mul(textureNode.uv(p2).level(lod)), g1x.mul(textureNode.uv(p3).level(lod))));\n  return a.add(b);\n};\nconst textureBicubic = /*@__PURE__*/Fn(([textureNode, lodNode = float(3)]) => {\n  const fLodSize = vec2(textureNode.size(int(lodNode)));\n  const cLodSize = vec2(textureNode.size(int(lodNode.add(1.0))));\n  const fLodSizeInv = div(1.0, fLodSize);\n  const cLodSizeInv = div(1.0, cLodSize);\n  const fSample = bicubic(textureNode, vec4(fLodSizeInv, fLodSize), floor(lodNode));\n  const cSample = bicubic(textureNode, vec4(cLodSizeInv, cLodSize), ceil(lodNode));\n  return fract(lodNode).mix(fSample, cSample);\n});\n\n//\n// Transmission\n//\n\nconst getVolumeTransmissionRay = /*@__PURE__*/Fn(([n, v, thickness, ior, modelMatrix]) => {\n  // Direction of refracted light.\n  const refractionVector = vec3(refract(v.negate(), normalize(n), div(1.0, ior)));\n\n  // Compute rotation-independant scaling of the model matrix.\n  const modelScale = vec3(length(modelMatrix[0].xyz), length(modelMatrix[1].xyz), length(modelMatrix[2].xyz));\n\n  // The thickness is specified in local space.\n  return normalize(refractionVector).mul(thickness.mul(modelScale));\n}).setLayout({\n  name: 'getVolumeTransmissionRay',\n  type: 'vec3',\n  inputs: [{\n    name: 'n',\n    type: 'vec3'\n  }, {\n    name: 'v',\n    type: 'vec3'\n  }, {\n    name: 'thickness',\n    type: 'float'\n  }, {\n    name: 'ior',\n    type: 'float'\n  }, {\n    name: 'modelMatrix',\n    type: 'mat4'\n  }]\n});\nconst applyIorToRoughness = /*@__PURE__*/Fn(([roughness, ior]) => {\n  // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n  // an IOR of 1.5 results in the default amount of microfacet refraction.\n  return roughness.mul(clamp(ior.mul(2.0).sub(2.0), 0.0, 1.0));\n}).setLayout({\n  name: 'applyIorToRoughness',\n  type: 'float',\n  inputs: [{\n    name: 'roughness',\n    type: 'float'\n  }, {\n    name: 'ior',\n    type: 'float'\n  }]\n});\nconst viewportBackSideTexture = /*@__PURE__*/viewportMipTexture();\nconst viewportFrontSideTexture = /*@__PURE__*/viewportMipTexture();\nconst getTransmissionSample = /*@__PURE__*/Fn(([fragCoord, roughness, ior], {\n  material\n}) => {\n  const vTexture = material.side == BackSide ? viewportBackSideTexture : viewportFrontSideTexture;\n  const transmissionSample = vTexture.uv(fragCoord);\n  //const transmissionSample = viewportMipTexture( fragCoord );\n\n  const lod = log2(screenSize.x).mul(applyIorToRoughness(roughness, ior));\n  return textureBicubic(transmissionSample, lod);\n});\nconst volumeAttenuation = /*@__PURE__*/Fn(([transmissionDistance, attenuationColor, attenuationDistance]) => {\n  If(attenuationDistance.notEqual(0), () => {\n    // Compute light attenuation using Beer's law.\n    const attenuationCoefficient = log(attenuationColor).negate().div(attenuationDistance);\n    const transmittance = exp(attenuationCoefficient.negate().mul(transmissionDistance));\n    return transmittance;\n  });\n\n  // Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.\n  return vec3(1.0);\n}).setLayout({\n  name: 'volumeAttenuation',\n  type: 'vec3',\n  inputs: [{\n    name: 'transmissionDistance',\n    type: 'float'\n  }, {\n    name: 'attenuationColor',\n    type: 'vec3'\n  }, {\n    name: 'attenuationDistance',\n    type: 'float'\n  }]\n});\nconst getIBLVolumeRefraction = /*@__PURE__*/Fn(([n, v, roughness, diffuseColor, specularColor, specularF90, position, modelMatrix, viewMatrix, projMatrix, ior, thickness, attenuationColor, attenuationDistance, dispersion]) => {\n  let transmittedLight, transmittance;\n  if (dispersion) {\n    transmittedLight = vec4().toVar();\n    transmittance = vec3().toVar();\n    const halfSpread = ior.sub(1.0).mul(dispersion.mul(0.025));\n    const iors = vec3(ior.sub(halfSpread), ior, ior.add(halfSpread));\n    Loop({\n      start: 0,\n      end: 3\n    }, ({\n      i\n    }) => {\n      const ior = iors.element(i);\n      const transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n      const refractedRayExit = position.add(transmissionRay);\n\n      // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n      const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1.0)));\n      const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();\n      refractionCoords.addAssign(1.0);\n      refractionCoords.divAssign(2.0);\n      refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus())); // webgpu\n\n      // Sample framebuffer to get pixel the refracted ray hits.\n      const transmissionSample = getTransmissionSample(refractionCoords, roughness, ior);\n      transmittedLight.element(i).assign(transmissionSample.element(i));\n      transmittedLight.a.addAssign(transmissionSample.a);\n      transmittance.element(i).assign(diffuseColor.element(i).mul(volumeAttenuation(length(transmissionRay), attenuationColor, attenuationDistance).element(i)));\n    });\n    transmittedLight.a.divAssign(3.0);\n  } else {\n    const transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n    const refractedRayExit = position.add(transmissionRay);\n\n    // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n    const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1.0)));\n    const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();\n    refractionCoords.addAssign(1.0);\n    refractionCoords.divAssign(2.0);\n    refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus())); // webgpu\n\n    // Sample framebuffer to get pixel the refracted ray hits.\n    transmittedLight = getTransmissionSample(refractionCoords, roughness, ior);\n    transmittance = diffuseColor.mul(volumeAttenuation(length(transmissionRay), attenuationColor, attenuationDistance));\n  }\n  const attenuatedColor = transmittance.rgb.mul(transmittedLight.rgb);\n  const dotNV = n.dot(v).clamp();\n\n  // Get the specular component.\n  const F = vec3(EnvironmentBRDF({\n    // n, v, specularColor, specularF90, roughness\n    dotNV,\n    specularColor,\n    specularF90,\n    roughness\n  }));\n\n  // As less light is transmitted, the opacity should be increased. This simple approximation does a decent job\n  // of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.\n  const transmittanceFactor = transmittance.r.add(transmittance.g, transmittance.b).div(3.0);\n  return vec4(F.oneMinus().mul(attenuatedColor), transmittedLight.a.oneMinus().mul(transmittanceFactor).oneMinus());\n});\n\n//\n// Iridescence\n//\n\n// XYZ to linear-sRGB color space\nconst XYZ_TO_REC709 = /*@__PURE__*/mat3(3.2404542, -0.9692660, 0.0556434, -1.5371385, 1.8760108, -0.2040259, -0.4985314, 0.0415560, 1.0572252);\n\n// Assume air interface for top\n// Note: We don't handle the case fresnel0 == 1\nconst Fresnel0ToIor = fresnel0 => {\n  const sqrtF0 = fresnel0.sqrt();\n  return vec3(1.0).add(sqrtF0).div(vec3(1.0).sub(sqrtF0));\n};\n\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nconst IorToFresnel0 = (transmittedIor, incidentIor) => {\n  return transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();\n};\n\n// Fresnel equations for dielectric/dielectric interfaces.\n// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n// Evaluation XYZ sensitivity curves in Fourier space\nconst evalSensitivity = (OPD, shift) => {\n  const phase = OPD.mul(2.0 * Math.PI * 1.0e-9);\n  const val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n  const pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n  const VAR = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n  const x = float(9.7470e-14 * Math.sqrt(2.0 * Math.PI * 4.5282e+09)).mul(phase.mul(2.2399e+06).add(shift.x).cos()).mul(phase.pow2().mul(-4.5282e+09).exp());\n  let xyz = val.mul(VAR.mul(2.0 * Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());\n  xyz = vec3(xyz.x.add(x), xyz.y, xyz.z).div(1.0685e-7);\n  const rgb = XYZ_TO_REC709.mul(xyz);\n  return rgb;\n};\nconst evalIridescence = /*@__PURE__*/Fn(({\n  outsideIOR,\n  eta2,\n  cosTheta1,\n  thinFilmThickness,\n  baseF0\n}) => {\n  // Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\n  const iridescenceIOR = mix(outsideIOR, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\n  // Evaluate the cosTheta on the base layer (Snell law)\n  const sinTheta2Sq = outsideIOR.div(iridescenceIOR).pow2().mul(cosTheta1.pow2().oneMinus());\n\n  // Handle TIR:\n  const cosTheta2Sq = sinTheta2Sq.oneMinus();\n  If(cosTheta2Sq.lessThan(0), () => {\n    return vec3(1.0);\n  });\n  const cosTheta2 = cosTheta2Sq.sqrt();\n\n  // First interface\n  const R0 = IorToFresnel0(iridescenceIOR, outsideIOR);\n  const R12 = F_Schlick({\n    f0: R0,\n    f90: 1.0,\n    dotVH: cosTheta1\n  });\n  //const R21 = R12;\n  const T121 = R12.oneMinus();\n  const phi12 = iridescenceIOR.lessThan(outsideIOR).select(Math.PI, 0.0);\n  const phi21 = float(Math.PI).sub(phi12);\n\n  // Second interface\n  const baseIOR = Fresnel0ToIor(baseF0.clamp(0.0, 0.9999)); // guard against 1.0\n  const R1 = IorToFresnel0(baseIOR, iridescenceIOR.toVec3());\n  const R23 = F_Schlick({\n    f0: R1,\n    f90: 1.0,\n    dotVH: cosTheta2\n  });\n  const phi23 = vec3(baseIOR.x.lessThan(iridescenceIOR).select(Math.PI, 0.0), baseIOR.y.lessThan(iridescenceIOR).select(Math.PI, 0.0), baseIOR.z.lessThan(iridescenceIOR).select(Math.PI, 0.0));\n\n  // Phase shift\n  const OPD = iridescenceIOR.mul(thinFilmThickness, cosTheta2, 2.0);\n  const phi = vec3(phi21).add(phi23);\n\n  // Compound terms\n  const R123 = R12.mul(R23).clamp(1e-5, 0.9999);\n  const r123 = R123.sqrt();\n  const Rs = T121.pow2().mul(R23).div(vec3(1.0).sub(R123));\n\n  // Reflectance term for m = 0 (DC term amplitude)\n  const C0 = R12.add(Rs);\n  const I = C0.toVar();\n\n  // Reflectance term for m > 0 (pairs of diracs)\n  const Cm = Rs.sub(T121).toVar();\n  Loop({\n    start: 1,\n    end: 2,\n    condition: '<=',\n    name: 'm'\n  }, ({\n    m\n  }) => {\n    Cm.mulAssign(r123);\n    const Sm = evalSensitivity(float(m).mul(OPD), float(m).mul(phi)).mul(2.0);\n    I.addAssign(Cm.mul(Sm));\n  });\n\n  // Since out of gamut colors might be produced, negative color values are clamped to 0.\n  return I.max(vec3(0.0));\n}).setLayout({\n  name: 'evalIridescence',\n  type: 'vec3',\n  inputs: [{\n    name: 'outsideIOR',\n    type: 'float'\n  }, {\n    name: 'eta2',\n    type: 'float'\n  }, {\n    name: 'cosTheta1',\n    type: 'float'\n  }, {\n    name: 'thinFilmThickness',\n    type: 'float'\n  }, {\n    name: 'baseF0',\n    type: 'vec3'\n  }]\n});\n\n//\n//\tSheen\n//\n\n// This is a curve-fit approxmation to the \"Charlie sheen\" BRDF integrated over the hemisphere from\n// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\". The analysis can be found\n// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nconst IBLSheenBRDF = /*@__PURE__*/Fn(({\n  normal,\n  viewDir,\n  roughness\n}) => {\n  const dotNV = normal.dot(viewDir).saturate();\n  const r2 = roughness.pow2();\n  const a = select(roughness.lessThan(0.25), float(-339.2).mul(r2).add(float(161.4).mul(roughness)).sub(25.9), float(-8.48).mul(r2).add(float(14.3).mul(roughness)).sub(9.95));\n  const b = select(roughness.lessThan(0.25), float(44.0).mul(r2).sub(float(23.7).mul(roughness)).add(3.26), float(1.97).mul(r2).sub(float(3.27).mul(roughness)).add(0.72));\n  const DG = select(roughness.lessThan(0.25), 0.0, float(0.1).mul(roughness).sub(0.025)).add(a.mul(dotNV).add(b).exp());\n  return DG.mul(1.0 / Math.PI).saturate();\n});\nconst clearcoatF0 = vec3(0.04);\nconst clearcoatF90 = float(1);\n\n//\n\nclass PhysicalLightingModel extends LightingModel {\n  constructor(clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false) {\n    super();\n    this.clearcoat = clearcoat;\n    this.sheen = sheen;\n    this.iridescence = iridescence;\n    this.anisotropy = anisotropy;\n    this.transmission = transmission;\n    this.dispersion = dispersion;\n    this.clearcoatRadiance = null;\n    this.clearcoatSpecularDirect = null;\n    this.clearcoatSpecularIndirect = null;\n    this.sheenSpecularDirect = null;\n    this.sheenSpecularIndirect = null;\n    this.iridescenceFresnel = null;\n    this.iridescenceF0 = null;\n  }\n  start(context) {\n    if (this.clearcoat === true) {\n      this.clearcoatRadiance = vec3().toVar('clearcoatRadiance');\n      this.clearcoatSpecularDirect = vec3().toVar('clearcoatSpecularDirect');\n      this.clearcoatSpecularIndirect = vec3().toVar('clearcoatSpecularIndirect');\n    }\n    if (this.sheen === true) {\n      this.sheenSpecularDirect = vec3().toVar('sheenSpecularDirect');\n      this.sheenSpecularIndirect = vec3().toVar('sheenSpecularIndirect');\n    }\n    if (this.iridescence === true) {\n      const dotNVi = transformedNormalView.dot(positionViewDirection).clamp();\n      this.iridescenceFresnel = evalIridescence({\n        outsideIOR: float(1.0),\n        eta2: iridescenceIOR,\n        cosTheta1: dotNVi,\n        thinFilmThickness: iridescenceThickness,\n        baseF0: specularColor\n      });\n      this.iridescenceF0 = Schlick_to_F0({\n        f: this.iridescenceFresnel,\n        f90: 1.0,\n        dotVH: dotNVi\n      });\n    }\n    if (this.transmission === true) {\n      const position = positionWorld;\n      const v = cameraPosition.sub(positionWorld).normalize(); // TODO: Create Node for this, same issue in MaterialX\n      const n = transformedNormalWorld;\n      context.backdrop = getIBLVolumeRefraction(n, v, roughness, diffuseColor, specularColor, specularF90,\n      // specularF90\n      position,\n      // positionWorld\n      modelWorldMatrix,\n      // modelMatrix\n      cameraViewMatrix,\n      // viewMatrix\n      cameraProjectionMatrix,\n      // projMatrix\n      ior, thickness, attenuationColor, attenuationDistance, this.dispersion ? dispersion : null);\n      context.backdropAlpha = transmission;\n      diffuseColor.a.mulAssign(mix(1, context.backdrop.a, transmission));\n    }\n  }\n\n  // Fdez-Agüera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n  // Approximates multiscattering in order to preserve energy.\n  // http://www.jcgt.org/published/0008/01/03/\n\n  computeMultiscattering(singleScatter, multiScatter, specularF90) {\n    const dotNV = transformedNormalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV\n\n    const fab = DFGApprox({\n      roughness,\n      dotNV\n    });\n    const Fr = this.iridescenceF0 ? iridescence.mix(specularColor, this.iridescenceF0) : specularColor;\n    const FssEss = Fr.mul(fab.x).add(specularF90.mul(fab.y));\n    const Ess = fab.x.add(fab.y);\n    const Ems = Ess.oneMinus();\n    const Favg = specularColor.add(specularColor.oneMinus().mul(0.047619)); // 1/21\n    const Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());\n    singleScatter.addAssign(FssEss);\n    multiScatter.addAssign(Fms.mul(Ems));\n  }\n  direct({\n    lightDirection,\n    lightColor,\n    reflectedLight\n  }) {\n    const dotNL = transformedNormalView.dot(lightDirection).clamp();\n    const irradiance = dotNL.mul(lightColor);\n    if (this.sheen === true) {\n      this.sheenSpecularDirect.addAssign(irradiance.mul(BRDF_Sheen({\n        lightDirection\n      })));\n    }\n    if (this.clearcoat === true) {\n      const dotNLcc = transformedClearcoatNormalView.dot(lightDirection).clamp();\n      const ccIrradiance = dotNLcc.mul(lightColor);\n      this.clearcoatSpecularDirect.addAssign(ccIrradiance.mul(BRDF_GGX({\n        lightDirection,\n        f0: clearcoatF0,\n        f90: clearcoatF90,\n        roughness: clearcoatRoughness,\n        normalView: transformedClearcoatNormalView\n      })));\n    }\n    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor: diffuseColor.rgb\n    })));\n    reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX({\n      lightDirection,\n      f0: specularColor,\n      f90: 1,\n      roughness,\n      iridescence: this.iridescence,\n      f: this.iridescenceFresnel,\n      USE_IRIDESCENCE: this.iridescence,\n      USE_ANISOTROPY: this.anisotropy\n    })));\n  }\n  directRectArea({\n    lightColor,\n    lightPosition,\n    halfWidth,\n    halfHeight,\n    reflectedLight,\n    ltc_1,\n    ltc_2\n  }) {\n    const p0 = lightPosition.add(halfWidth).sub(halfHeight); // counterclockwise; light shines in local neg z direction\n    const p1 = lightPosition.sub(halfWidth).sub(halfHeight);\n    const p2 = lightPosition.sub(halfWidth).add(halfHeight);\n    const p3 = lightPosition.add(halfWidth).add(halfHeight);\n    const N = transformedNormalView;\n    const V = positionViewDirection;\n    const P = positionView.toVar();\n    const uv = LTC_Uv({\n      N,\n      V,\n      roughness\n    });\n    const t1 = ltc_1.uv(uv).toVar();\n    const t2 = ltc_2.uv(uv).toVar();\n    const mInv = mat3(vec3(t1.x, 0, t1.y), vec3(0, 1, 0), vec3(t1.z, 0, t1.w)).toVar();\n\n    // LTC Fresnel Approximation by Stephen Hill\n    // http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n    const fresnel = specularColor.mul(t2.x).add(specularColor.oneMinus().mul(t2.y)).toVar();\n    reflectedLight.directSpecular.addAssign(lightColor.mul(fresnel).mul(LTC_Evaluate({\n      N,\n      V,\n      P,\n      mInv,\n      p0,\n      p1,\n      p2,\n      p3\n    })));\n    reflectedLight.directDiffuse.addAssign(lightColor.mul(diffuseColor).mul(LTC_Evaluate({\n      N,\n      V,\n      P,\n      mInv: mat3(1, 0, 0, 0, 1, 0, 0, 0, 1),\n      p0,\n      p1,\n      p2,\n      p3\n    })));\n  }\n  indirect(context, stack, builder) {\n    this.indirectDiffuse(context, stack, builder);\n    this.indirectSpecular(context, stack, builder);\n    this.ambientOcclusion(context, stack, builder);\n  }\n  indirectDiffuse({\n    irradiance,\n    reflectedLight\n  }) {\n    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor\n    })));\n  }\n  indirectSpecular({\n    radiance,\n    iblIrradiance,\n    reflectedLight\n  }) {\n    if (this.sheen === true) {\n      this.sheenSpecularIndirect.addAssign(iblIrradiance.mul(sheen, IBLSheenBRDF({\n        normal: transformedNormalView,\n        viewDir: positionViewDirection,\n        roughness: sheenRoughness\n      })));\n    }\n    if (this.clearcoat === true) {\n      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();\n      const clearcoatEnv = EnvironmentBRDF({\n        dotNV: dotNVcc,\n        specularColor: clearcoatF0,\n        specularF90: clearcoatF90,\n        roughness: clearcoatRoughness\n      });\n      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(clearcoatEnv));\n    }\n\n    // Both indirect specular and indirect diffuse light accumulate here\n\n    const singleScattering = vec3().toVar('singleScattering');\n    const multiScattering = vec3().toVar('multiScattering');\n    const cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);\n    this.computeMultiscattering(singleScattering, multiScattering, specularF90);\n    const totalScattering = singleScattering.add(multiScattering);\n    const diffuse = diffuseColor.mul(totalScattering.r.max(totalScattering.g).max(totalScattering.b).oneMinus());\n    reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));\n    reflectedLight.indirectSpecular.addAssign(multiScattering.mul(cosineWeightedIrradiance));\n    reflectedLight.indirectDiffuse.addAssign(diffuse.mul(cosineWeightedIrradiance));\n  }\n  ambientOcclusion({\n    ambientOcclusion,\n    reflectedLight\n  }) {\n    const dotNV = transformedNormalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV\n\n    const aoNV = dotNV.add(ambientOcclusion);\n    const aoExp = roughness.mul(-16.0).oneMinus().negate().exp2();\n    const aoNode = ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();\n    if (this.clearcoat === true) {\n      this.clearcoatSpecularIndirect.mulAssign(ambientOcclusion);\n    }\n    if (this.sheen === true) {\n      this.sheenSpecularIndirect.mulAssign(ambientOcclusion);\n    }\n    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n    reflectedLight.indirectSpecular.mulAssign(aoNode);\n  }\n  finish(context) {\n    const {\n      outgoingLight\n    } = context;\n    if (this.clearcoat === true) {\n      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();\n      const Fcc = F_Schlick({\n        dotVH: dotNVcc,\n        f0: clearcoatF0,\n        f90: clearcoatF90\n      });\n      const clearcoatLight = outgoingLight.mul(clearcoat.mul(Fcc).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(clearcoat));\n      outgoingLight.assign(clearcoatLight);\n    }\n    if (this.sheen === true) {\n      const sheenEnergyComp = sheen.r.max(sheen.g).max(sheen.b).mul(0.157).oneMinus();\n      const sheenLight = outgoingLight.mul(sheenEnergyComp).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);\n      outgoingLight.assign(sheenLight);\n    }\n  }\n}\n\n// These defines must match with PMREMGenerator\n\nconst cubeUV_r0 = /*@__PURE__*/float(1.0);\nconst cubeUV_m0 = /*@__PURE__*/float(-2.0);\nconst cubeUV_r1 = /*@__PURE__*/float(0.8);\nconst cubeUV_m1 = /*@__PURE__*/float(-1.0);\nconst cubeUV_r4 = /*@__PURE__*/float(0.4);\nconst cubeUV_m4 = /*@__PURE__*/float(2.0);\nconst cubeUV_r5 = /*@__PURE__*/float(0.305);\nconst cubeUV_m5 = /*@__PURE__*/float(3.0);\nconst cubeUV_r6 = /*@__PURE__*/float(0.21);\nconst cubeUV_m6 = /*@__PURE__*/float(4.0);\nconst cubeUV_minMipLevel = /*@__PURE__*/float(4.0);\nconst cubeUV_minTileSize = /*@__PURE__*/float(16.0);\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized ).\n\nconst getFace = /*@__PURE__*/Fn(([direction]) => {\n  const absDirection = vec3(abs(direction)).toVar();\n  const face = float(-1.0).toVar();\n  If(absDirection.x.greaterThan(absDirection.z), () => {\n    If(absDirection.x.greaterThan(absDirection.y), () => {\n      face.assign(select(direction.x.greaterThan(0.0), 0.0, 3.0));\n    }).Else(() => {\n      face.assign(select(direction.y.greaterThan(0.0), 1.0, 4.0));\n    });\n  }).Else(() => {\n    If(absDirection.z.greaterThan(absDirection.y), () => {\n      face.assign(select(direction.z.greaterThan(0.0), 2.0, 5.0));\n    }).Else(() => {\n      face.assign(select(direction.y.greaterThan(0.0), 1.0, 4.0));\n    });\n  });\n  return face;\n}).setLayout({\n  name: 'getFace',\n  type: 'float',\n  inputs: [{\n    name: 'direction',\n    type: 'vec3'\n  }]\n});\n\n// RH coordinate system; PMREM face-indexing convention\nconst getUV = /*@__PURE__*/Fn(([direction, face]) => {\n  const uv = vec2().toVar();\n  If(face.equal(0.0), () => {\n    uv.assign(vec2(direction.z, direction.y).div(abs(direction.x))); // pos x\n  }).ElseIf(face.equal(1.0), () => {\n    uv.assign(vec2(direction.x.negate(), direction.z.negate()).div(abs(direction.y))); // pos y\n  }).ElseIf(face.equal(2.0), () => {\n    uv.assign(vec2(direction.x.negate(), direction.y).div(abs(direction.z))); // pos z\n  }).ElseIf(face.equal(3.0), () => {\n    uv.assign(vec2(direction.z.negate(), direction.y).div(abs(direction.x))); // neg x\n  }).ElseIf(face.equal(4.0), () => {\n    uv.assign(vec2(direction.x.negate(), direction.z).div(abs(direction.y))); // neg y\n  }).Else(() => {\n    uv.assign(vec2(direction.x, direction.y).div(abs(direction.z))); // neg z\n  });\n  return mul(0.5, uv.add(1.0));\n}).setLayout({\n  name: 'getUV',\n  type: 'vec2',\n  inputs: [{\n    name: 'direction',\n    type: 'vec3'\n  }, {\n    name: 'face',\n    type: 'float'\n  }]\n});\nconst roughnessToMip = /*@__PURE__*/Fn(([roughness]) => {\n  const mip = float(0.0).toVar();\n  If(roughness.greaterThanEqual(cubeUV_r1), () => {\n    mip.assign(cubeUV_r0.sub(roughness).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0));\n  }).ElseIf(roughness.greaterThanEqual(cubeUV_r4), () => {\n    mip.assign(cubeUV_r1.sub(roughness).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1));\n  }).ElseIf(roughness.greaterThanEqual(cubeUV_r5), () => {\n    mip.assign(cubeUV_r4.sub(roughness).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4));\n  }).ElseIf(roughness.greaterThanEqual(cubeUV_r6), () => {\n    mip.assign(cubeUV_r5.sub(roughness).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5));\n  }).Else(() => {\n    mip.assign(float(-2.0).mul(log2(mul(1.16, roughness)))); // 1.16 = 1.79^0.25\n  });\n  return mip;\n}).setLayout({\n  name: 'roughnessToMip',\n  type: 'float',\n  inputs: [{\n    name: 'roughness',\n    type: 'float'\n  }]\n});\n\n// RH coordinate system; PMREM face-indexing convention\nconst getDirection = /*@__PURE__*/Fn(([uv_immutable, face]) => {\n  const uv = uv_immutable.toVar();\n  uv.assign(mul(2.0, uv).sub(1.0));\n  const direction = vec3(uv, 1.0).toVar();\n  If(face.equal(0.0), () => {\n    direction.assign(direction.zyx); // ( 1, v, u ) pos x\n  }).ElseIf(face.equal(1.0), () => {\n    direction.assign(direction.xzy);\n    direction.xz.mulAssign(-1.0); // ( -u, 1, -v ) pos y\n  }).ElseIf(face.equal(2.0), () => {\n    direction.x.mulAssign(-1.0); // ( -u, v, 1 ) pos z\n  }).ElseIf(face.equal(3.0), () => {\n    direction.assign(direction.zyx);\n    direction.xz.mulAssign(-1.0); // ( -1, v, -u ) neg x\n  }).ElseIf(face.equal(4.0), () => {\n    direction.assign(direction.xzy);\n    direction.xy.mulAssign(-1.0); // ( -u, -1, v ) neg y\n  }).ElseIf(face.equal(5.0), () => {\n    direction.z.mulAssign(-1.0); // ( u, v, -1 ) neg zS\n  });\n  return direction;\n}).setLayout({\n  name: 'getDirection',\n  type: 'vec3',\n  inputs: [{\n    name: 'uv',\n    type: 'vec2'\n  }, {\n    name: 'face',\n    type: 'float'\n  }]\n});\n\n//\n\nconst textureCubeUV = /*@__PURE__*/Fn(([envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {\n  const roughness = float(roughness_immutable);\n  const sampleDir = vec3(sampleDir_immutable);\n  const mip = clamp(roughnessToMip(roughness), cubeUV_m0, CUBEUV_MAX_MIP);\n  const mipF = fract(mip);\n  const mipInt = floor(mip);\n  const color0 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();\n  If(mipF.notEqual(0.0), () => {\n    const color1 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt.add(1.0), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();\n    color0.assign(mix(color0, color1, mipF));\n  });\n  return color0;\n});\nconst bilinearCubeUV = /*@__PURE__*/Fn(([envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {\n  const mipInt = float(mipInt_immutable).toVar();\n  const direction = vec3(direction_immutable);\n  const face = float(getFace(direction)).toVar();\n  const filterInt = float(max$1(cubeUV_minMipLevel.sub(mipInt), 0.0)).toVar();\n  mipInt.assign(max$1(mipInt, cubeUV_minMipLevel));\n  const faceSize = float(exp2(mipInt)).toVar();\n  const uv = vec2(getUV(direction, face).mul(faceSize.sub(2.0)).add(1.0)).toVar();\n  If(face.greaterThan(2.0), () => {\n    uv.y.addAssign(faceSize);\n    face.subAssign(3.0);\n  });\n  uv.x.addAssign(face.mul(faceSize));\n  uv.x.addAssign(filterInt.mul(mul(3.0, cubeUV_minTileSize)));\n  uv.y.addAssign(mul(4.0, exp2(CUBEUV_MAX_MIP).sub(faceSize)));\n  uv.x.mulAssign(CUBEUV_TEXEL_WIDTH);\n  uv.y.mulAssign(CUBEUV_TEXEL_HEIGHT);\n  return envMap.uv(uv).grad(vec2(), vec2()); // disable anisotropic filtering\n});\nconst getSample = /*@__PURE__*/Fn(({\n  envMap,\n  mipInt,\n  outputDirection,\n  theta,\n  axis,\n  CUBEUV_TEXEL_WIDTH,\n  CUBEUV_TEXEL_HEIGHT,\n  CUBEUV_MAX_MIP\n}) => {\n  const cosTheta = cos(theta);\n\n  // Rodrigues' axis-angle rotation\n  const sampleDirection = outputDirection.mul(cosTheta).add(axis.cross(outputDirection).mul(sin(theta))).add(axis.mul(axis.dot(outputDirection).mul(cosTheta.oneMinus())));\n  return bilinearCubeUV(envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);\n});\nconst blur = /*@__PURE__*/Fn(({\n  n,\n  latitudinal,\n  poleAxis,\n  outputDirection,\n  weights,\n  samples,\n  dTheta,\n  mipInt,\n  envMap,\n  CUBEUV_TEXEL_WIDTH,\n  CUBEUV_TEXEL_HEIGHT,\n  CUBEUV_MAX_MIP\n}) => {\n  const axis = vec3(select(latitudinal, poleAxis, cross(poleAxis, outputDirection))).toVar();\n  If(all(axis.equals(vec3(0.0))), () => {\n    axis.assign(vec3(outputDirection.z, 0.0, outputDirection.x.negate()));\n  });\n  axis.assign(normalize(axis));\n  const gl_FragColor = vec3().toVar();\n  gl_FragColor.addAssign(weights.element(int(0)).mul(getSample({\n    theta: 0.0,\n    axis,\n    outputDirection,\n    mipInt,\n    envMap,\n    CUBEUV_TEXEL_WIDTH,\n    CUBEUV_TEXEL_HEIGHT,\n    CUBEUV_MAX_MIP\n  })));\n  Loop({\n    start: int(1),\n    end: n\n  }, ({\n    i\n  }) => {\n    If(i.greaterThanEqual(samples), () => {\n      Break();\n    });\n    const theta = float(dTheta.mul(float(i))).toVar();\n    gl_FragColor.addAssign(weights.element(i).mul(getSample({\n      theta: theta.mul(-1.0),\n      axis,\n      outputDirection,\n      mipInt,\n      envMap,\n      CUBEUV_TEXEL_WIDTH,\n      CUBEUV_TEXEL_HEIGHT,\n      CUBEUV_MAX_MIP\n    })));\n    gl_FragColor.addAssign(weights.element(i).mul(getSample({\n      theta,\n      axis,\n      outputDirection,\n      mipInt,\n      envMap,\n      CUBEUV_TEXEL_WIDTH,\n      CUBEUV_TEXEL_HEIGHT,\n      CUBEUV_MAX_MIP\n    })));\n  });\n  return vec4(gl_FragColor, 1);\n});\nlet _generator = null;\nconst _cache = new WeakMap();\nfunction _generateCubeUVSize(imageHeight) {\n  const maxMip = Math.log2(imageHeight) - 2;\n  const texelHeight = 1.0 / imageHeight;\n  const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));\n  return {\n    texelWidth,\n    texelHeight,\n    maxMip\n  };\n}\nfunction _getPMREMFromTexture(texture) {\n  let cacheTexture = _cache.get(texture);\n  const pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : -1;\n  if (pmremVersion !== texture.pmremVersion) {\n    const image = texture.image;\n    if (texture.isCubeTexture) {\n      if (isCubeMapReady(image)) {\n        cacheTexture = _generator.fromCubemap(texture, cacheTexture);\n      } else {\n        return null;\n      }\n    } else {\n      if (isEquirectangularMapReady(image)) {\n        cacheTexture = _generator.fromEquirectangular(texture, cacheTexture);\n      } else {\n        return null;\n      }\n    }\n    cacheTexture.pmremVersion = texture.pmremVersion;\n    _cache.set(texture, cacheTexture);\n  }\n  return cacheTexture.texture;\n}\nclass PMREMNode extends TempNode {\n  static get type() {\n    return 'PMREMNode';\n  }\n  constructor(value, uvNode = null, levelNode = null) {\n    super('vec3');\n    this._value = value;\n    this._pmrem = null;\n    this.uvNode = uvNode;\n    this.levelNode = levelNode;\n    this._generator = null;\n    const defaultTexture = new Texture();\n    defaultTexture.isRenderTargetTexture = true;\n    this._texture = texture(defaultTexture);\n    this._width = uniform(0);\n    this._height = uniform(0);\n    this._maxMip = uniform(0);\n    this.updateBeforeType = NodeUpdateType.RENDER;\n  }\n  set value(value) {\n    this._value = value;\n    this._pmrem = null;\n  }\n  get value() {\n    return this._value;\n  }\n  updateFromTexture(texture) {\n    const cubeUVSize = _generateCubeUVSize(texture.image.height);\n    this._texture.value = texture;\n    this._width.value = cubeUVSize.texelWidth;\n    this._height.value = cubeUVSize.texelHeight;\n    this._maxMip.value = cubeUVSize.maxMip;\n  }\n  updateBefore() {\n    let pmrem = this._pmrem;\n    const pmremVersion = pmrem ? pmrem.pmremVersion : -1;\n    const texture = this._value;\n    if (pmremVersion !== texture.pmremVersion) {\n      if (texture.isPMREMTexture === true) {\n        pmrem = texture;\n      } else {\n        pmrem = _getPMREMFromTexture(texture);\n      }\n      if (pmrem !== null) {\n        this._pmrem = pmrem;\n        this.updateFromTexture(pmrem);\n      }\n    }\n  }\n  setup(builder) {\n    if (_generator === null) {\n      _generator = builder.createPMREMGenerator();\n    }\n\n    //\n\n    this.updateBefore(builder);\n\n    //\n\n    let uvNode = this.uvNode;\n    if (uvNode === null && builder.context.getUV) {\n      uvNode = builder.context.getUV(this);\n    }\n\n    //\n\n    const texture = this.value;\n    if (builder.renderer.coordinateSystem === WebGLCoordinateSystem && texture.isPMREMTexture !== true && texture.isRenderTargetTexture === true) {\n      uvNode = vec3(uvNode.x.negate(), uvNode.yz);\n    }\n\n    //\n\n    let levelNode = this.levelNode;\n    if (levelNode === null && builder.context.getTextureLevel) {\n      levelNode = builder.context.getTextureLevel(this);\n    }\n\n    //\n\n    return textureCubeUV(this._texture, uvNode, levelNode, this._width, this._height, this._maxMip);\n  }\n}\nfunction isCubeMapReady(image) {\n  if (image === null || image === undefined) return false;\n  let count = 0;\n  const length = 6;\n  for (let i = 0; i < length; i++) {\n    if (image[i] !== undefined) count++;\n  }\n  return count === length;\n}\nfunction isEquirectangularMapReady(image) {\n  if (image === null || image === undefined) return false;\n  return image.height > 0;\n}\nconst pmremTexture = /*@__PURE__*/nodeProxy(PMREMNode);\nconst _envNodeCache = new WeakMap();\nclass EnvironmentNode extends LightingNode {\n  static get type() {\n    return 'EnvironmentNode';\n  }\n  constructor(envNode = null) {\n    super();\n    this.envNode = envNode;\n  }\n  setup(builder) {\n    const {\n      material\n    } = builder;\n    let envNode = this.envNode;\n    if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {\n      const value = envNode.isTextureNode ? envNode.value : material[envNode.property];\n      let cacheEnvNode = _envNodeCache.get(value);\n      if (cacheEnvNode === undefined) {\n        cacheEnvNode = pmremTexture(value);\n        _envNodeCache.set(value, cacheEnvNode);\n      }\n      envNode = cacheEnvNode;\n    }\n\n    //\n\n    const envMap = material.envMap;\n    const intensity = envMap ? reference('envMapIntensity', 'float', builder.material) : reference('environmentIntensity', 'float', builder.scene); // @TODO: Add materialEnvIntensity in MaterialNode\n\n    const useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;\n    const radianceNormalView = useAnisotropy ? transformedBentNormalView : transformedNormalView;\n    const radiance = envNode.context(createRadianceContext(roughness, radianceNormalView)).mul(intensity);\n    const irradiance = envNode.context(createIrradianceContext(transformedNormalWorld)).mul(Math.PI).mul(intensity);\n    const isolateRadiance = cache(radiance);\n    const isolateIrradiance = cache(irradiance);\n\n    //\n\n    builder.context.radiance.addAssign(isolateRadiance);\n    builder.context.iblIrradiance.addAssign(isolateIrradiance);\n\n    //\n\n    const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;\n    if (clearcoatRadiance) {\n      const clearcoatRadianceContext = envNode.context(createRadianceContext(clearcoatRoughness, transformedClearcoatNormalView)).mul(intensity);\n      const isolateClearcoatRadiance = cache(clearcoatRadianceContext);\n      clearcoatRadiance.addAssign(isolateClearcoatRadiance);\n    }\n  }\n}\nconst createRadianceContext = (roughnessNode, normalViewNode) => {\n  let reflectVec = null;\n  return {\n    getUV: () => {\n      if (reflectVec === null) {\n        reflectVec = positionViewDirection.negate().reflect(normalViewNode);\n\n        // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n        reflectVec = roughnessNode.mul(roughnessNode).mix(reflectVec, normalViewNode).normalize();\n        reflectVec = reflectVec.transformDirection(cameraViewMatrix);\n      }\n      return reflectVec;\n    },\n    getTextureLevel: () => {\n      return roughnessNode;\n    }\n  };\n};\nconst createIrradianceContext = normalWorldNode => {\n  return {\n    getUV: () => {\n      return normalWorldNode;\n    },\n    getTextureLevel: () => {\n      return float(1.0);\n    }\n  };\n};\nconst _defaultValues$6 = /*@__PURE__*/new MeshStandardMaterial();\nclass MeshStandardNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshStandardNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshStandardNodeMaterial = true;\n    this.lights = true;\n    this.emissiveNode = null;\n    this.metalnessNode = null;\n    this.roughnessNode = null;\n    this.setDefaultValues(_defaultValues$6);\n    this.setValues(parameters);\n  }\n  setupEnvironment(builder) {\n    let envNode = super.setupEnvironment(builder);\n    if (envNode === null && builder.environmentNode) {\n      envNode = builder.environmentNode;\n    }\n    return envNode ? new EnvironmentNode(envNode) : null;\n  }\n  setupLightingModel(/*builder*/\n  ) {\n    return new PhysicalLightingModel();\n  }\n  setupSpecular() {\n    const specularColorNode = mix(vec3(0.04), diffuseColor.rgb, metalness);\n    specularColor.assign(specularColorNode);\n    specularF90.assign(1.0);\n  }\n  setupVariants() {\n    // METALNESS\n\n    const metalnessNode = this.metalnessNode ? float(this.metalnessNode) : materialMetalness;\n    metalness.assign(metalnessNode);\n\n    // ROUGHNESS\n\n    let roughnessNode = this.roughnessNode ? float(this.roughnessNode) : materialRoughness;\n    roughnessNode = getRoughness({\n      roughness: roughnessNode\n    });\n    roughness.assign(roughnessNode);\n\n    // SPECULAR COLOR\n\n    this.setupSpecular();\n\n    // DIFFUSE COLOR\n\n    diffuseColor.assign(vec4(diffuseColor.rgb.mul(metalnessNode.oneMinus()), diffuseColor.a));\n  }\n  copy(source) {\n    this.emissiveNode = source.emissiveNode;\n    this.metalnessNode = source.metalnessNode;\n    this.roughnessNode = source.roughnessNode;\n    return super.copy(source);\n  }\n}\nconst _defaultValues$5 = /*@__PURE__*/new MeshPhysicalMaterial();\nclass MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {\n  static get type() {\n    return 'MeshPhysicalNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshPhysicalNodeMaterial = true;\n    this.clearcoatNode = null;\n    this.clearcoatRoughnessNode = null;\n    this.clearcoatNormalNode = null;\n    this.sheenNode = null;\n    this.sheenRoughnessNode = null;\n    this.iridescenceNode = null;\n    this.iridescenceIORNode = null;\n    this.iridescenceThicknessNode = null;\n    this.specularIntensityNode = null;\n    this.specularColorNode = null;\n    this.iorNode = null;\n    this.transmissionNode = null;\n    this.thicknessNode = null;\n    this.attenuationDistanceNode = null;\n    this.attenuationColorNode = null;\n    this.dispersionNode = null;\n    this.anisotropyNode = null;\n    this.setDefaultValues(_defaultValues$5);\n    this.setValues(parameters);\n  }\n  get useClearcoat() {\n    return this.clearcoat > 0 || this.clearcoatNode !== null;\n  }\n  get useIridescence() {\n    return this.iridescence > 0 || this.iridescenceNode !== null;\n  }\n  get useSheen() {\n    return this.sheen > 0 || this.sheenNode !== null;\n  }\n  get useAnisotropy() {\n    return this.anisotropy > 0 || this.anisotropyNode !== null;\n  }\n  get useTransmission() {\n    return this.transmission > 0 || this.transmissionNode !== null;\n  }\n  get useDispersion() {\n    return this.dispersion > 0 || this.dispersionNode !== null;\n  }\n  setupSpecular() {\n    const iorNode = this.iorNode ? float(this.iorNode) : materialIOR;\n    ior.assign(iorNode);\n    specularColor.assign(mix(min$1(pow2(ior.sub(1.0).div(ior.add(1.0))).mul(materialSpecularColor), vec3(1.0)).mul(materialSpecularIntensity), diffuseColor.rgb, metalness));\n    specularF90.assign(mix(materialSpecularIntensity, 1.0, metalness));\n  }\n  setupLightingModel(/*builder*/\n  ) {\n    return new PhysicalLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);\n  }\n  setupVariants(builder) {\n    super.setupVariants(builder);\n\n    // CLEARCOAT\n\n    if (this.useClearcoat) {\n      const clearcoatNode = this.clearcoatNode ? float(this.clearcoatNode) : materialClearcoat;\n      const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float(this.clearcoatRoughnessNode) : materialClearcoatRoughness;\n      clearcoat.assign(clearcoatNode);\n      clearcoatRoughness.assign(getRoughness({\n        roughness: clearcoatRoughnessNode\n      }));\n    }\n\n    // SHEEN\n\n    if (this.useSheen) {\n      const sheenNode = this.sheenNode ? vec3(this.sheenNode) : materialSheen;\n      const sheenRoughnessNode = this.sheenRoughnessNode ? float(this.sheenRoughnessNode) : materialSheenRoughness;\n      sheen.assign(sheenNode);\n      sheenRoughness.assign(sheenRoughnessNode);\n    }\n\n    // IRIDESCENCE\n\n    if (this.useIridescence) {\n      const iridescenceNode = this.iridescenceNode ? float(this.iridescenceNode) : materialIridescence;\n      const iridescenceIORNode = this.iridescenceIORNode ? float(this.iridescenceIORNode) : materialIridescenceIOR;\n      const iridescenceThicknessNode = this.iridescenceThicknessNode ? float(this.iridescenceThicknessNode) : materialIridescenceThickness;\n      iridescence.assign(iridescenceNode);\n      iridescenceIOR.assign(iridescenceIORNode);\n      iridescenceThickness.assign(iridescenceThicknessNode);\n    }\n\n    // ANISOTROPY\n\n    if (this.useAnisotropy) {\n      const anisotropyV = (this.anisotropyNode ? vec2(this.anisotropyNode) : materialAnisotropy).toVar();\n      anisotropy.assign(anisotropyV.length());\n      If(anisotropy.equal(0.0), () => {\n        anisotropyV.assign(vec2(1.0, 0.0));\n      }).Else(() => {\n        anisotropyV.divAssign(vec2(anisotropy));\n        anisotropy.assign(anisotropy.saturate());\n      });\n\n      // Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.\n      alphaT.assign(anisotropy.pow2().mix(roughness.pow2(), 1.0));\n      anisotropyT.assign(TBNViewMatrix[0].mul(anisotropyV.x).add(TBNViewMatrix[1].mul(anisotropyV.y)));\n      anisotropyB.assign(TBNViewMatrix[1].mul(anisotropyV.x).sub(TBNViewMatrix[0].mul(anisotropyV.y)));\n    }\n\n    // TRANSMISSION\n\n    if (this.useTransmission) {\n      const transmissionNode = this.transmissionNode ? float(this.transmissionNode) : materialTransmission;\n      const thicknessNode = this.thicknessNode ? float(this.thicknessNode) : materialThickness;\n      const attenuationDistanceNode = this.attenuationDistanceNode ? float(this.attenuationDistanceNode) : materialAttenuationDistance;\n      const attenuationColorNode = this.attenuationColorNode ? vec3(this.attenuationColorNode) : materialAttenuationColor;\n      transmission.assign(transmissionNode);\n      thickness.assign(thicknessNode);\n      attenuationDistance.assign(attenuationDistanceNode);\n      attenuationColor.assign(attenuationColorNode);\n      if (this.useDispersion) {\n        const dispersionNode = this.dispersionNode ? float(this.dispersionNode) : materialDispersion;\n        dispersion.assign(dispersionNode);\n      }\n    }\n  }\n  setupClearcoatNormal() {\n    return this.clearcoatNormalNode ? vec3(this.clearcoatNormalNode) : materialClearcoatNormal;\n  }\n  setup(builder) {\n    builder.context.setupClearcoatNormal = () => this.setupClearcoatNormal(builder);\n    super.setup(builder);\n  }\n  copy(source) {\n    this.clearcoatNode = source.clearcoatNode;\n    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;\n    this.clearcoatNormalNode = source.clearcoatNormalNode;\n    this.sheenNode = source.sheenNode;\n    this.sheenRoughnessNode = source.sheenRoughnessNode;\n    this.iridescenceNode = source.iridescenceNode;\n    this.iridescenceIORNode = source.iridescenceIORNode;\n    this.iridescenceThicknessNode = source.iridescenceThicknessNode;\n    this.specularIntensityNode = source.specularIntensityNode;\n    this.specularColorNode = source.specularColorNode;\n    this.transmissionNode = source.transmissionNode;\n    this.thicknessNode = source.thicknessNode;\n    this.attenuationDistanceNode = source.attenuationDistanceNode;\n    this.attenuationColorNode = source.attenuationColorNode;\n    this.dispersionNode = source.dispersionNode;\n    this.anisotropyNode = source.anisotropyNode;\n    return super.copy(source);\n  }\n}\nclass SSSLightingModel extends PhysicalLightingModel {\n  constructor(useClearcoat, useSheen, useIridescence, useSSS) {\n    super(useClearcoat, useSheen, useIridescence);\n    this.useSSS = useSSS;\n  }\n  direct({\n    lightDirection,\n    lightColor,\n    reflectedLight\n  }, stack, builder) {\n    if (this.useSSS === true) {\n      const material = builder.material;\n      const {\n        thicknessColorNode,\n        thicknessDistortionNode,\n        thicknessAmbientNode,\n        thicknessAttenuationNode,\n        thicknessPowerNode,\n        thicknessScaleNode\n      } = material;\n      const scatteringHalf = lightDirection.add(transformedNormalView.mul(thicknessDistortionNode)).normalize();\n      const scatteringDot = float(positionViewDirection.dot(scatteringHalf.negate()).saturate().pow(thicknessPowerNode).mul(thicknessScaleNode));\n      const scatteringIllu = vec3(scatteringDot.add(thicknessAmbientNode).mul(thicknessColorNode));\n      reflectedLight.directDiffuse.addAssign(scatteringIllu.mul(thicknessAttenuationNode.mul(lightColor)));\n    }\n    super.direct({\n      lightDirection,\n      lightColor,\n      reflectedLight\n    }, stack, builder);\n  }\n}\nclass MeshSSSNodeMaterial extends MeshPhysicalNodeMaterial {\n  static get type() {\n    return 'MeshSSSNodeMaterial';\n  }\n  constructor(parameters) {\n    super(parameters);\n    this.thicknessColorNode = null;\n    this.thicknessDistortionNode = float(0.1);\n    this.thicknessAmbientNode = float(0.0);\n    this.thicknessAttenuationNode = float(.1);\n    this.thicknessPowerNode = float(2.0);\n    this.thicknessScaleNode = float(10.0);\n  }\n  get useSSS() {\n    return this.thicknessColorNode !== null;\n  }\n  setupLightingModel(/*builder*/\n  ) {\n    return new SSSLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useSSS);\n  }\n  copy(source) {\n    this.thicknessColorNode = source.thicknessColorNode;\n    this.thicknessDistortionNode = source.thicknessDistortionNode;\n    this.thicknessAmbientNode = source.thicknessAmbientNode;\n    this.thicknessAttenuationNode = source.thicknessAttenuationNode;\n    this.thicknessPowerNode = source.thicknessPowerNode;\n    this.thicknessScaleNode = source.thicknessScaleNode;\n    return super.copy(source);\n  }\n}\nconst getGradientIrradiance = /*@__PURE__*/Fn(({\n  normal,\n  lightDirection,\n  builder\n}) => {\n  // dotNL will be from -1.0 to 1.0\n  const dotNL = normal.dot(lightDirection);\n  const coord = vec2(dotNL.mul(0.5).add(0.5), 0.0);\n  if (builder.material.gradientMap) {\n    const gradientMap = materialReference('gradientMap', 'texture').context({\n      getUV: () => coord\n    });\n    return vec3(gradientMap.r);\n  } else {\n    const fw = coord.fwidth().mul(0.5);\n    return mix(vec3(0.7), vec3(1.0), smoothstep(float(0.7).sub(fw.x), float(0.7).add(fw.x), coord.x));\n  }\n});\nclass ToonLightingModel extends LightingModel {\n  direct({\n    lightDirection,\n    lightColor,\n    reflectedLight\n  }, stack, builder) {\n    const irradiance = getGradientIrradiance({\n      normal: normalGeometry,\n      lightDirection,\n      builder\n    }).mul(lightColor);\n    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor: diffuseColor.rgb\n    })));\n  }\n  indirect({\n    ambientOcclusion,\n    irradiance,\n    reflectedLight\n  }) {\n    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor\n    })));\n    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n  }\n}\nconst _defaultValues$4 = /*@__PURE__*/new MeshToonMaterial();\nclass MeshToonNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshToonNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshToonNodeMaterial = true;\n    this.lights = true;\n    this.setDefaultValues(_defaultValues$4);\n    this.setValues(parameters);\n  }\n  setupLightingModel(/*builder*/\n  ) {\n    return new ToonLightingModel();\n  }\n}\nclass MatcapUVNode extends TempNode {\n  static get type() {\n    return 'MatcapUVNode';\n  }\n  constructor() {\n    super('vec2');\n  }\n  setup() {\n    const x = vec3(positionViewDirection.z, 0, positionViewDirection.x.negate()).normalize();\n    const y = positionViewDirection.cross(x);\n    return vec2(x.dot(transformedNormalView), y.dot(transformedNormalView)).mul(0.495).add(0.5); // 0.495 to remove artifacts caused by undersized matcap disks\n  }\n}\nconst matcapUV = /*@__PURE__*/nodeImmutable(MatcapUVNode);\nconst _defaultValues$3 = /*@__PURE__*/new MeshMatcapMaterial();\nclass MeshMatcapNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'MeshMatcapNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.lights = false;\n    this.isMeshMatcapNodeMaterial = true;\n    this.setDefaultValues(_defaultValues$3);\n    this.setValues(parameters);\n  }\n  setupVariants(builder) {\n    const uv = matcapUV;\n    let matcapColor;\n    if (builder.material.matcap) {\n      matcapColor = materialReference('matcap', 'texture').context({\n        getUV: () => uv\n      });\n    } else {\n      matcapColor = vec3(mix(0.2, 0.8, uv.y)); // default if matcap is missing\n    }\n    diffuseColor.rgb.mulAssign(matcapColor.rgb);\n  }\n}\nconst _defaultValues$2 = /*@__PURE__*/new PointsMaterial();\nclass PointsNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'PointsNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isPointsNodeMaterial = true;\n    this.lights = false;\n    this.transparent = true;\n    this.sizeNode = null;\n    this.setDefaultValues(_defaultValues$2);\n    this.setValues(parameters);\n  }\n  copy(source) {\n    this.sizeNode = source.sizeNode;\n    return super.copy(source);\n  }\n}\nclass RotateNode extends TempNode {\n  static get type() {\n    return 'RotateNode';\n  }\n  constructor(positionNode, rotationNode) {\n    super();\n    this.positionNode = positionNode;\n    this.rotationNode = rotationNode;\n  }\n  getNodeType(builder) {\n    return this.positionNode.getNodeType(builder);\n  }\n  setup(builder) {\n    const {\n      rotationNode,\n      positionNode\n    } = this;\n    const nodeType = this.getNodeType(builder);\n    if (nodeType === 'vec2') {\n      const cosAngle = rotationNode.cos();\n      const sinAngle = rotationNode.sin();\n      const rotationMatrix = mat2(cosAngle, sinAngle, sinAngle.negate(), cosAngle);\n      return rotationMatrix.mul(positionNode);\n    } else {\n      const rotation = rotationNode;\n      const rotationXMatrix = mat4(vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, cos(rotation.x), sin(rotation.x).negate(), 0.0), vec4(0.0, sin(rotation.x), cos(rotation.x), 0.0), vec4(0.0, 0.0, 0.0, 1.0));\n      const rotationYMatrix = mat4(vec4(cos(rotation.y), 0.0, sin(rotation.y), 0.0), vec4(0.0, 1.0, 0.0, 0.0), vec4(sin(rotation.y).negate(), 0.0, cos(rotation.y), 0.0), vec4(0.0, 0.0, 0.0, 1.0));\n      const rotationZMatrix = mat4(vec4(cos(rotation.z), sin(rotation.z).negate(), 0.0, 0.0), vec4(sin(rotation.z), cos(rotation.z), 0.0, 0.0), vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0));\n      return rotationXMatrix.mul(rotationYMatrix).mul(rotationZMatrix).mul(vec4(positionNode, 1.0)).xyz;\n    }\n  }\n}\nconst rotate = /*@__PURE__*/nodeProxy(RotateNode);\nconst _defaultValues$1 = /*@__PURE__*/new SpriteMaterial();\nclass SpriteNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'SpriteNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isSpriteNodeMaterial = true;\n    this.lights = false;\n    this._useSizeAttenuation = true;\n    this.positionNode = null;\n    this.rotationNode = null;\n    this.scaleNode = null;\n    this.setDefaultValues(_defaultValues$1);\n    this.setValues(parameters);\n  }\n  setupPosition({\n    object,\n    camera,\n    context\n  }) {\n    const sizeAttenuation = this.sizeAttenuation;\n\n    // < VERTEX STAGE >\n\n    const {\n      positionNode,\n      rotationNode,\n      scaleNode\n    } = this;\n    const vertex = positionLocal;\n    let mvPosition = modelViewMatrix.mul(vec3(positionNode || 0));\n    let scale = vec2(modelWorldMatrix[0].xyz.length(), modelWorldMatrix[1].xyz.length());\n    if (scaleNode !== null) {\n      scale = scale.mul(scaleNode);\n    }\n    if (!sizeAttenuation) {\n      if (camera.isPerspectiveCamera) {\n        scale = scale.mul(mvPosition.z.negate());\n      } else {\n        const orthoScale = float(2.0).div(cameraProjectionMatrix.element(1).element(1));\n        scale = scale.mul(orthoScale.mul(2));\n      }\n    }\n    let alignedPosition = vertex.xy;\n    if (object.center && object.center.isVector2 === true) {\n      const center = reference$1('center', 'vec2');\n      alignedPosition = alignedPosition.sub(center.sub(0.5));\n    }\n    alignedPosition = alignedPosition.mul(scale);\n    const rotation = float(rotationNode || materialRotation);\n    const rotatedPosition = rotate(alignedPosition, rotation);\n    mvPosition = vec4(mvPosition.xy.add(rotatedPosition), mvPosition.zw);\n    const modelViewProjection = cameraProjectionMatrix.mul(mvPosition);\n    context.vertex = vertex;\n    return modelViewProjection;\n  }\n  copy(source) {\n    this.positionNode = source.positionNode;\n    this.rotationNode = source.rotationNode;\n    this.scaleNode = source.scaleNode;\n    return super.copy(source);\n  }\n  get sizeAttenuation() {\n    return this._useSizeAttenuation;\n  }\n  set sizeAttenuation(value) {\n    if (this._useSizeAttenuation !== value) {\n      this._useSizeAttenuation = value;\n      this.needsUpdate = true;\n    }\n  }\n}\nclass ShadowMaskModel extends LightingModel {\n  constructor() {\n    super();\n    this.shadowNode = float(1).toVar('shadowMask');\n  }\n  direct({\n    shadowMask\n  }) {\n    this.shadowNode.mulAssign(shadowMask);\n  }\n  finish(context) {\n    diffuseColor.a.mulAssign(this.shadowNode.oneMinus());\n    context.outgoingLight.rgb.assign(diffuseColor.rgb); // TODO: Optimize LightsNode to avoid this assignment\n  }\n}\nconst _defaultValues = /*@__PURE__*/new ShadowMaterial();\nclass ShadowNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'ShadowNodeMaterial';\n  }\n  constructor(parameters) {\n    super();\n    this.isShadowNodeMaterial = true;\n    this.lights = true;\n    this.setDefaultValues(_defaultValues);\n    this.setValues(parameters);\n  }\n  setupLightingModel(/*builder*/\n  ) {\n    return new ShadowMaskModel();\n  }\n}\nconst normal = Fn(({\n  texture,\n  uv\n}) => {\n  const epsilon = 0.0001;\n  const ret = vec3().toVar();\n  If(uv.x.lessThan(epsilon), () => {\n    ret.assign(vec3(1, 0, 0));\n  }).ElseIf(uv.y.lessThan(epsilon), () => {\n    ret.assign(vec3(0, 1, 0));\n  }).ElseIf(uv.z.lessThan(epsilon), () => {\n    ret.assign(vec3(0, 0, 1));\n  }).ElseIf(uv.x.greaterThan(1 - epsilon), () => {\n    ret.assign(vec3(-1, 0, 0));\n  }).ElseIf(uv.y.greaterThan(1 - epsilon), () => {\n    ret.assign(vec3(0, -1, 0));\n  }).ElseIf(uv.z.greaterThan(1 - epsilon), () => {\n    ret.assign(vec3(0, 0, -1));\n  }).Else(() => {\n    const step = 0.01;\n    const x = texture.uv(uv.add(vec3(-step, 0.0, 0.0))).r.sub(texture.uv(uv.add(vec3(step, 0.0, 0.0))).r);\n    const y = texture.uv(uv.add(vec3(0.0, -step, 0.0))).r.sub(texture.uv(uv.add(vec3(0.0, step, 0.0))).r);\n    const z = texture.uv(uv.add(vec3(0.0, 0.0, -step))).r.sub(texture.uv(uv.add(vec3(0.0, 0.0, step))).r);\n    ret.assign(vec3(x, y, z));\n  });\n  return ret.normalize();\n});\nclass Texture3DNode extends TextureNode {\n  static get type() {\n    return 'Texture3DNode';\n  }\n  constructor(value, uvNode = null, levelNode = null) {\n    super(value, uvNode, levelNode);\n    this.isTexture3DNode = true;\n  }\n  getInputType(/*builder*/\n  ) {\n    return 'texture3D';\n  }\n  getDefaultUV() {\n    return vec3(0.5, 0.5, 0.5);\n  }\n  setUpdateMatrix(/*updateMatrix*/) {} // Ignore .updateMatrix for 3d TextureNode\n\n  setupUV(builder, uvNode) {\n    return uvNode;\n  }\n  generateUV(builder, uvNode) {\n    return uvNode.build(builder, 'vec3');\n  }\n  normal(uvNode) {\n    return normal({\n      texture: this,\n      uv: uvNode\n    });\n  }\n}\nconst texture3D = /*@__PURE__*/nodeProxy(Texture3DNode);\nclass VolumeNodeMaterial extends NodeMaterial {\n  static get type() {\n    return 'VolumeNodeMaterial';\n  }\n  constructor(params = {}) {\n    super();\n    this.lights = false;\n    this.isVolumeNodeMaterial = true;\n    this.testNode = null;\n    this.setValues(params);\n  }\n  setup(builder) {\n    const map = texture3D(this.map, null, 0);\n    const hitBox = Fn(({\n      orig,\n      dir\n    }) => {\n      const box_min = vec3(-0.5);\n      const box_max = vec3(0.5);\n      const inv_dir = dir.reciprocal();\n      const tmin_tmp = box_min.sub(orig).mul(inv_dir);\n      const tmax_tmp = box_max.sub(orig).mul(inv_dir);\n      const tmin = min$1(tmin_tmp, tmax_tmp);\n      const tmax = max$1(tmin_tmp, tmax_tmp);\n      const t0 = max$1(tmin.x, max$1(tmin.y, tmin.z));\n      const t1 = min$1(tmax.x, min$1(tmax.y, tmax.z));\n      return vec2(t0, t1);\n    });\n    this.fragmentNode = Fn(() => {\n      const vOrigin = varying(vec3(modelWorldMatrixInverse.mul(vec4(cameraPosition, 1.0))));\n      const vDirection = varying(positionGeometry.sub(vOrigin));\n      const rayDir = vDirection.normalize();\n      const bounds = vec2(hitBox({\n        orig: vOrigin,\n        dir: rayDir\n      })).toVar();\n      bounds.x.greaterThan(bounds.y).discard();\n      bounds.assign(vec2(max$1(bounds.x, 0.0), bounds.y));\n      const p = vec3(vOrigin.add(bounds.x.mul(rayDir))).toVar();\n      const inc = vec3(rayDir.abs().reciprocal()).toVar();\n      const delta = float(min$1(inc.x, min$1(inc.y, inc.z))).toVar('delta'); // used 'delta' name in loop\n\n      delta.divAssign(materialReference('steps', 'float'));\n      const ac = vec4(materialReference('base', 'color'), 0.0).toVar();\n      Loop({\n        type: 'float',\n        start: bounds.x,\n        end: bounds.y,\n        update: '+= delta'\n      }, () => {\n        const d = property('float', 'd').assign(map.uv(p.add(0.5)).r);\n        if (this.testNode !== null) {\n          this.testNode({\n            map: map,\n            mapValue: d,\n            probe: p,\n            finalColor: ac\n          }).append();\n        } else {\n          // default to show surface of mesh\n          ac.a.assign(1);\n          Break();\n        }\n        p.addAssign(rayDir.mul(delta));\n      });\n      ac.a.equal(0).discard();\n      return vec4(ac);\n    })();\n    super.setup(builder);\n  }\n}\nclass Animation {\n  constructor(nodes, info) {\n    this.nodes = nodes;\n    this.info = info;\n    this._context = self;\n    this._animationLoop = null;\n    this._requestId = null;\n  }\n  start() {\n    const update = (time, frame) => {\n      this._requestId = this._context.requestAnimationFrame(update);\n      if (this.info.autoReset === true) this.info.reset();\n      this.nodes.nodeFrame.update();\n      this.info.frame = this.nodes.nodeFrame.frameId;\n      if (this._animationLoop !== null) this._animationLoop(time, frame);\n    };\n    update();\n  }\n  stop() {\n    this._context.cancelAnimationFrame(this._requestId);\n    this._requestId = null;\n  }\n  setAnimationLoop(callback) {\n    this._animationLoop = callback;\n  }\n  setContext(context) {\n    this._context = context;\n  }\n  dispose() {\n    this.stop();\n  }\n}\nclass ChainMap {\n  constructor() {\n    this.weakMap = new WeakMap();\n  }\n  get(keys) {\n    let map = this.weakMap;\n    for (let i = 0; i < keys.length; i++) {\n      map = map.get(keys[i]);\n      if (map === undefined) return undefined;\n    }\n    return map.get(keys[keys.length - 1]);\n  }\n  set(keys, value) {\n    let map = this.weakMap;\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (map.has(key) === false) map.set(key, new WeakMap());\n      map = map.get(key);\n    }\n    return map.set(keys[keys.length - 1], value);\n  }\n  delete(keys) {\n    let map = this.weakMap;\n    for (let i = 0; i < keys.length; i++) {\n      map = map.get(keys[i]);\n      if (map === undefined) return false;\n    }\n    return map.delete(keys[keys.length - 1]);\n  }\n}\nlet _id$7 = 0;\nfunction getKeys(obj) {\n  const keys = Object.keys(obj);\n  let proto = Object.getPrototypeOf(obj);\n  while (proto) {\n    const descriptors = Object.getOwnPropertyDescriptors(proto);\n    for (const key in descriptors) {\n      if (descriptors[key] !== undefined) {\n        const descriptor = descriptors[key];\n        if (descriptor && typeof descriptor.get === 'function') {\n          keys.push(key);\n        }\n      }\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n  return keys;\n}\nclass RenderObject {\n  constructor(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext) {\n    this._nodes = nodes;\n    this._geometries = geometries;\n    this.id = _id$7++;\n    this.renderer = renderer;\n    this.object = object;\n    this.material = material;\n    this.scene = scene;\n    this.camera = camera;\n    this.lightsNode = lightsNode;\n    this.context = renderContext;\n    this.geometry = object.geometry;\n    this.version = material.version;\n    this.drawRange = null;\n    this.attributes = null;\n    this.pipeline = null;\n    this.vertexBuffers = null;\n    this.drawParams = null;\n    this.bundle = null;\n    this.clippingContext = clippingContext;\n    this.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';\n    this.initialNodesCacheKey = this.getDynamicCacheKey();\n    this.initialCacheKey = this.getCacheKey();\n    this._nodeBuilderState = null;\n    this._bindings = null;\n    this._monitor = null;\n    this.onDispose = null;\n    this.isRenderObject = true;\n    this.onMaterialDispose = () => {\n      this.dispose();\n    };\n    this.material.addEventListener('dispose', this.onMaterialDispose);\n  }\n  updateClipping(parent) {\n    this.clippingContext = parent;\n  }\n  get clippingNeedsUpdate() {\n    if (this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey) return false;\n    this.clippingContextCacheKey = this.clippingContext.cacheKey;\n    return true;\n  }\n  get hardwareClippingPlanes() {\n    return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;\n  }\n  getNodeBuilderState() {\n    return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));\n  }\n  getMonitor() {\n    return this._monitor || (this._monitor = this.getNodeBuilderState().monitor);\n  }\n  getBindings() {\n    return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());\n  }\n  getIndex() {\n    return this._geometries.getIndex(this);\n  }\n  getIndirect() {\n    return this._geometries.getIndirect(this);\n  }\n  getChainArray() {\n    return [this.object, this.material, this.context, this.lightsNode];\n  }\n  setGeometry(geometry) {\n    this.geometry = geometry;\n    this.attributes = null;\n  }\n  getAttributes() {\n    if (this.attributes !== null) return this.attributes;\n    const nodeAttributes = this.getNodeBuilderState().nodeAttributes;\n    const geometry = this.geometry;\n    const attributes = [];\n    const vertexBuffers = new Set();\n    for (const nodeAttribute of nodeAttributes) {\n      const attribute = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute(nodeAttribute.name);\n      if (attribute === undefined) continue;\n      attributes.push(attribute);\n      const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n      vertexBuffers.add(bufferAttribute);\n    }\n    this.attributes = attributes;\n    this.vertexBuffers = Array.from(vertexBuffers.values());\n    return attributes;\n  }\n  getVertexBuffers() {\n    if (this.vertexBuffers === null) this.getAttributes();\n    return this.vertexBuffers;\n  }\n  getDrawParameters() {\n    const {\n      object,\n      material,\n      geometry,\n      group,\n      drawRange\n    } = this;\n    const drawParams = this.drawParams || (this.drawParams = {\n      vertexCount: 0,\n      firstVertex: 0,\n      instanceCount: 0,\n      firstInstance: 0\n    });\n    const index = this.getIndex();\n    const hasIndex = index !== null;\n    const instanceCount = geometry.isInstancedBufferGeometry ? geometry.instanceCount : object.count > 1 ? object.count : 1;\n    if (instanceCount === 0) return null;\n    drawParams.instanceCount = instanceCount;\n    if (object.isBatchedMesh === true) return drawParams;\n    let rangeFactor = 1;\n    if (material.wireframe === true && !object.isPoints && !object.isLineSegments && !object.isLine && !object.isLineLoop) {\n      rangeFactor = 2;\n    }\n    let firstVertex = drawRange.start * rangeFactor;\n    let lastVertex = (drawRange.start + drawRange.count) * rangeFactor;\n    if (group !== null) {\n      firstVertex = Math.max(firstVertex, group.start * rangeFactor);\n      lastVertex = Math.min(lastVertex, (group.start + group.count) * rangeFactor);\n    }\n    const position = geometry.attributes.position;\n    let itemCount = Infinity;\n    if (hasIndex) {\n      itemCount = index.count;\n    } else if (position !== undefined && position !== null) {\n      itemCount = position.count;\n    }\n    firstVertex = Math.max(firstVertex, 0);\n    lastVertex = Math.min(lastVertex, itemCount);\n    const count = lastVertex - firstVertex;\n    if (count < 0 || count === Infinity) return null;\n    drawParams.vertexCount = count;\n    drawParams.firstVertex = firstVertex;\n    return drawParams;\n  }\n  getGeometryCacheKey() {\n    const {\n      geometry\n    } = this;\n    let cacheKey = '';\n    for (const name of Object.keys(geometry.attributes).sort()) {\n      const attribute = geometry.attributes[name];\n      cacheKey += name + ',';\n      if (attribute.data) cacheKey += attribute.data.stride + ',';\n      if (attribute.offset) cacheKey += attribute.offset + ',';\n      if (attribute.itemSize) cacheKey += attribute.itemSize + ',';\n      if (attribute.normalized) cacheKey += 'n,';\n    }\n    if (geometry.index) {\n      cacheKey += 'index,';\n    }\n    return cacheKey;\n  }\n  getMaterialCacheKey() {\n    const {\n      object,\n      material\n    } = this;\n    let cacheKey = material.customProgramCacheKey();\n    for (const property of getKeys(material)) {\n      if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(property)) continue;\n      const value = material[property];\n      let valueKey;\n      if (value !== null) {\n        // some material values require a formatting\n\n        const type = typeof value;\n        if (type === 'number') {\n          valueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc\n        } else if (type === 'object') {\n          valueKey = '{';\n          if (value.isTexture) {\n            valueKey += value.mapping;\n          }\n          valueKey += '}';\n        } else {\n          valueKey = String(value);\n        }\n      } else {\n        valueKey = String(value);\n      }\n      cacheKey += /*property + ':' +*/valueKey + ',';\n    }\n    cacheKey += this.clippingContextCacheKey + ',';\n    if (object.geometry) {\n      cacheKey += this.getGeometryCacheKey();\n    }\n    if (object.skeleton) {\n      cacheKey += object.skeleton.bones.length + ',';\n    }\n    if (object.morphTargetInfluences) {\n      cacheKey += object.morphTargetInfluences.length + ',';\n    }\n    if (object.isBatchedMesh) {\n      cacheKey += object._matricesTexture.uuid + ',';\n      if (object._colorsTexture !== null) {\n        cacheKey += object._colorsTexture.uuid + ',';\n      }\n    }\n    if (object.count > 1) {\n      // TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850\n\n      cacheKey += object.uuid + ',';\n    }\n    cacheKey += object.receiveShadow + ',';\n    return hashString(cacheKey);\n  }\n  get needsGeometryUpdate() {\n    return this.geometry.id !== this.object.geometry.id;\n  }\n  get needsUpdate() {\n    return /*this.object.static !== true &&*/this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate;\n  }\n  getDynamicCacheKey() {\n    // Environment Nodes Cache Key\n\n    let cacheKey = this._nodes.getCacheKey(this.scene, this.lightsNode);\n    if (this.object.receiveShadow) {\n      cacheKey += 1;\n    }\n    return cacheKey;\n  }\n  getCacheKey() {\n    return this.getMaterialCacheKey() + this.getDynamicCacheKey();\n  }\n  dispose() {\n    this.material.removeEventListener('dispose', this.onMaterialDispose);\n    this.onDispose();\n  }\n}\nconst chainArray = [];\nclass RenderObjects {\n  constructor(renderer, nodes, geometries, pipelines, bindings, info) {\n    this.renderer = renderer;\n    this.nodes = nodes;\n    this.geometries = geometries;\n    this.pipelines = pipelines;\n    this.bindings = bindings;\n    this.info = info;\n    this.chainMaps = {};\n  }\n  get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {\n    const chainMap = this.getChainMap(passId);\n\n    // reuse chainArray\n    chainArray[0] = object;\n    chainArray[1] = material;\n    chainArray[2] = renderContext;\n    chainArray[3] = lightsNode;\n    let renderObject = chainMap.get(chainArray);\n    if (renderObject === undefined) {\n      renderObject = this.createRenderObject(this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId);\n      chainMap.set(chainArray, renderObject);\n    } else {\n      renderObject.updateClipping(clippingContext);\n      if (renderObject.needsGeometryUpdate) {\n        renderObject.setGeometry(object.geometry);\n      }\n      if (renderObject.version !== material.version || renderObject.needsUpdate) {\n        if (renderObject.initialCacheKey !== renderObject.getCacheKey()) {\n          renderObject.dispose();\n          renderObject = this.get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId);\n        } else {\n          renderObject.version = material.version;\n        }\n      }\n    }\n    return renderObject;\n  }\n  getChainMap(passId = 'default') {\n    return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());\n  }\n  dispose() {\n    this.chainMaps = {};\n  }\n  createRenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {\n    const chainMap = this.getChainMap(passId);\n    const renderObject = new RenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext);\n    renderObject.onDispose = () => {\n      this.pipelines.delete(renderObject);\n      this.bindings.delete(renderObject);\n      this.nodes.delete(renderObject);\n      chainMap.delete(renderObject.getChainArray());\n    };\n    return renderObject;\n  }\n}\nclass DataMap {\n  constructor() {\n    this.data = new WeakMap();\n  }\n  get(object) {\n    let map = this.data.get(object);\n    if (map === undefined) {\n      map = {};\n      this.data.set(object, map);\n    }\n    return map;\n  }\n  delete(object) {\n    let map;\n    if (this.data.has(object)) {\n      map = this.data.get(object);\n      this.data.delete(object);\n    }\n    return map;\n  }\n  has(object) {\n    return this.data.has(object);\n  }\n  dispose() {\n    this.data = new WeakMap();\n  }\n}\nconst AttributeType = {\n  VERTEX: 1,\n  INDEX: 2,\n  STORAGE: 3,\n  INDIRECT: 4\n};\n\n// size of a chunk in bytes (STD140 layout)\n\nconst GPU_CHUNK_BYTES = 16;\n\n// @TODO: Move to src/constants.js\n\nconst BlendColorFactor = 211;\nconst OneMinusBlendColorFactor = 212;\nclass Attributes extends DataMap {\n  constructor(backend) {\n    super();\n    this.backend = backend;\n  }\n  delete(attribute) {\n    const attributeData = super.delete(attribute);\n    if (attributeData !== undefined) {\n      this.backend.destroyAttribute(attribute);\n    }\n    return attributeData;\n  }\n  update(attribute, type) {\n    const data = this.get(attribute);\n    if (data.version === undefined) {\n      if (type === AttributeType.VERTEX) {\n        this.backend.createAttribute(attribute);\n      } else if (type === AttributeType.INDEX) {\n        this.backend.createIndexAttribute(attribute);\n      } else if (type === AttributeType.STORAGE) {\n        this.backend.createStorageAttribute(attribute);\n      } else if (type === AttributeType.INDIRECT) {\n        this.backend.createIndirectStorageAttribute(attribute);\n      }\n      data.version = this._getBufferAttribute(attribute).version;\n    } else {\n      const bufferAttribute = this._getBufferAttribute(attribute);\n      if (data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage) {\n        this.backend.updateAttribute(attribute);\n        data.version = bufferAttribute.version;\n      }\n    }\n  }\n  _getBufferAttribute(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    return attribute;\n  }\n}\nfunction arrayNeedsUint32(array) {\n  // assumes larger values usually on last\n\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n  }\n  return false;\n}\nfunction getWireframeVersion(geometry) {\n  return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;\n}\nfunction getWireframeIndex(geometry) {\n  const indices = [];\n  const geometryIndex = geometry.index;\n  const geometryPosition = geometry.attributes.position;\n  if (geometryIndex !== null) {\n    const array = geometryIndex.array;\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      const a = array[i + 0];\n      const b = array[i + 1];\n      const c = array[i + 2];\n      indices.push(a, b, b, c, c, a);\n    }\n  } else {\n    const array = geometryPosition.array;\n    for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {\n      const a = i + 0;\n      const b = i + 1;\n      const c = i + 2;\n      indices.push(a, b, b, c, c, a);\n    }\n  }\n  const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);\n  attribute.version = getWireframeVersion(geometry);\n  return attribute;\n}\nclass Geometries extends DataMap {\n  constructor(attributes, info) {\n    super();\n    this.attributes = attributes;\n    this.info = info;\n    this.wireframes = new WeakMap();\n    this.attributeCall = new WeakMap();\n  }\n  has(renderObject) {\n    const geometry = renderObject.geometry;\n    return super.has(geometry) && this.get(geometry).initialized === true;\n  }\n  updateForRender(renderObject) {\n    if (this.has(renderObject) === false) this.initGeometry(renderObject);\n    this.updateAttributes(renderObject);\n  }\n  initGeometry(renderObject) {\n    const geometry = renderObject.geometry;\n    const geometryData = this.get(geometry);\n    geometryData.initialized = true;\n    this.info.memory.geometries++;\n    const onDispose = () => {\n      this.info.memory.geometries--;\n      const index = geometry.index;\n      const geometryAttributes = renderObject.getAttributes();\n      if (index !== null) {\n        this.attributes.delete(index);\n      }\n      for (const geometryAttribute of geometryAttributes) {\n        this.attributes.delete(geometryAttribute);\n      }\n      const wireframeAttribute = this.wireframes.get(geometry);\n      if (wireframeAttribute !== undefined) {\n        this.attributes.delete(wireframeAttribute);\n      }\n      geometry.removeEventListener('dispose', onDispose);\n    };\n    geometry.addEventListener('dispose', onDispose);\n  }\n  updateAttributes(renderObject) {\n    // attributes\n\n    const attributes = renderObject.getAttributes();\n    for (const attribute of attributes) {\n      if (attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute) {\n        this.updateAttribute(attribute, AttributeType.STORAGE);\n      } else {\n        this.updateAttribute(attribute, AttributeType.VERTEX);\n      }\n    }\n\n    // indexes\n\n    const index = this.getIndex(renderObject);\n    if (index !== null) {\n      this.updateAttribute(index, AttributeType.INDEX);\n    }\n\n    // indirect\n\n    const indirect = renderObject.geometry.indirect;\n    if (indirect !== null) {\n      this.updateAttribute(indirect, AttributeType.INDIRECT);\n    }\n  }\n  updateAttribute(attribute, type) {\n    const callId = this.info.render.calls;\n    if (!attribute.isInterleavedBufferAttribute) {\n      if (this.attributeCall.get(attribute) !== callId) {\n        this.attributes.update(attribute, type);\n        this.attributeCall.set(attribute, callId);\n      }\n    } else {\n      if (this.attributeCall.get(attribute) === undefined) {\n        this.attributes.update(attribute, type);\n        this.attributeCall.set(attribute, callId);\n      } else if (this.attributeCall.get(attribute.data) !== callId) {\n        this.attributes.update(attribute, type);\n        this.attributeCall.set(attribute.data, callId);\n        this.attributeCall.set(attribute, callId);\n      }\n    }\n  }\n  getIndirect(renderObject) {\n    return renderObject.geometry.indirect;\n  }\n  getIndex(renderObject) {\n    const {\n      geometry,\n      material\n    } = renderObject;\n    let index = geometry.index;\n    if (material.wireframe === true) {\n      const wireframes = this.wireframes;\n      let wireframeAttribute = wireframes.get(geometry);\n      if (wireframeAttribute === undefined) {\n        wireframeAttribute = getWireframeIndex(geometry);\n        wireframes.set(geometry, wireframeAttribute);\n      } else if (wireframeAttribute.version !== getWireframeVersion(geometry)) {\n        this.attributes.delete(wireframeAttribute);\n        wireframeAttribute = getWireframeIndex(geometry);\n        wireframes.set(geometry, wireframeAttribute);\n      }\n      index = wireframeAttribute;\n    }\n    return index;\n  }\n}\nclass Info {\n  constructor() {\n    this.autoReset = true;\n    this.frame = 0;\n    this.calls = 0;\n    this.render = {\n      calls: 0,\n      frameCalls: 0,\n      drawCalls: 0,\n      triangles: 0,\n      points: 0,\n      lines: 0,\n      timestamp: 0,\n      previousFrameCalls: 0,\n      timestampCalls: 0\n    };\n    this.compute = {\n      calls: 0,\n      frameCalls: 0,\n      timestamp: 0,\n      previousFrameCalls: 0,\n      timestampCalls: 0\n    };\n    this.memory = {\n      geometries: 0,\n      textures: 0\n    };\n  }\n  update(object, count, instanceCount) {\n    this.render.drawCalls++;\n    if (object.isMesh || object.isSprite) {\n      this.render.triangles += instanceCount * (count / 3);\n    } else if (object.isPoints) {\n      this.render.points += instanceCount * count;\n    } else if (object.isLineSegments) {\n      this.render.lines += instanceCount * (count / 2);\n    } else if (object.isLine) {\n      this.render.lines += instanceCount * (count - 1);\n    } else {\n      console.error('THREE.WebGPUInfo: Unknown object type.');\n    }\n  }\n  updateTimestamp(type, time) {\n    if (this[type].timestampCalls === 0) {\n      this[type].timestamp = 0;\n    }\n    this[type].timestamp += time;\n    this[type].timestampCalls++;\n    if (this[type].timestampCalls >= this[type].previousFrameCalls) {\n      this[type].timestampCalls = 0;\n    }\n  }\n  reset() {\n    const previousRenderFrameCalls = this.render.frameCalls;\n    this.render.previousFrameCalls = previousRenderFrameCalls;\n    const previousComputeFrameCalls = this.compute.frameCalls;\n    this.compute.previousFrameCalls = previousComputeFrameCalls;\n    this.render.drawCalls = 0;\n    this.render.frameCalls = 0;\n    this.compute.frameCalls = 0;\n    this.render.triangles = 0;\n    this.render.points = 0;\n    this.render.lines = 0;\n  }\n  dispose() {\n    this.reset();\n    this.calls = 0;\n    this.render.calls = 0;\n    this.compute.calls = 0;\n    this.render.timestamp = 0;\n    this.compute.timestamp = 0;\n    this.memory.geometries = 0;\n    this.memory.textures = 0;\n  }\n}\nclass Pipeline {\n  constructor(cacheKey) {\n    this.cacheKey = cacheKey;\n    this.usedTimes = 0;\n  }\n}\nclass RenderPipeline extends Pipeline {\n  constructor(cacheKey, vertexProgram, fragmentProgram) {\n    super(cacheKey);\n    this.vertexProgram = vertexProgram;\n    this.fragmentProgram = fragmentProgram;\n  }\n}\nclass ComputePipeline extends Pipeline {\n  constructor(cacheKey, computeProgram) {\n    super(cacheKey);\n    this.computeProgram = computeProgram;\n    this.isComputePipeline = true;\n  }\n}\nlet _id$6 = 0;\nclass ProgrammableStage {\n  constructor(code, type, transforms = null, attributes = null) {\n    this.id = _id$6++;\n    this.code = code;\n    this.stage = type;\n    this.transforms = transforms;\n    this.attributes = attributes;\n    this.usedTimes = 0;\n  }\n}\nclass Pipelines extends DataMap {\n  constructor(backend, nodes) {\n    super();\n    this.backend = backend;\n    this.nodes = nodes;\n    this.bindings = null; // set by the bindings\n\n    this.caches = new Map();\n    this.programs = {\n      vertex: new Map(),\n      fragment: new Map(),\n      compute: new Map()\n    };\n  }\n  getForCompute(computeNode, bindings) {\n    const {\n      backend\n    } = this;\n    const data = this.get(computeNode);\n    if (this._needsComputeUpdate(computeNode)) {\n      const previousPipeline = data.pipeline;\n      if (previousPipeline) {\n        previousPipeline.usedTimes--;\n        previousPipeline.computeProgram.usedTimes--;\n      }\n\n      // get shader\n\n      const nodeBuilderState = this.nodes.getForCompute(computeNode);\n\n      // programmable stage\n\n      let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);\n      if (stageCompute === undefined) {\n        if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0) this._releaseProgram(previousPipeline.computeProgram);\n        stageCompute = new ProgrammableStage(nodeBuilderState.computeShader, 'compute', nodeBuilderState.transforms, nodeBuilderState.nodeAttributes);\n        this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);\n        backend.createProgram(stageCompute);\n      }\n\n      // determine compute pipeline\n\n      const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);\n      let pipeline = this.caches.get(cacheKey);\n      if (pipeline === undefined) {\n        if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);\n        pipeline = this._getComputePipeline(computeNode, stageCompute, cacheKey, bindings);\n      }\n\n      // keep track of all used times\n\n      pipeline.usedTimes++;\n      stageCompute.usedTimes++;\n\n      //\n\n      data.version = computeNode.version;\n      data.pipeline = pipeline;\n    }\n    return data.pipeline;\n  }\n  getForRender(renderObject, promises = null) {\n    const {\n      backend\n    } = this;\n    const data = this.get(renderObject);\n    if (this._needsRenderUpdate(renderObject)) {\n      const previousPipeline = data.pipeline;\n      if (previousPipeline) {\n        previousPipeline.usedTimes--;\n        previousPipeline.vertexProgram.usedTimes--;\n        previousPipeline.fragmentProgram.usedTimes--;\n      }\n\n      // get shader\n\n      const nodeBuilderState = renderObject.getNodeBuilderState();\n\n      // programmable stages\n\n      let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);\n      if (stageVertex === undefined) {\n        if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0) this._releaseProgram(previousPipeline.vertexProgram);\n        stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader, 'vertex');\n        this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);\n        backend.createProgram(stageVertex);\n      }\n      let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);\n      if (stageFragment === undefined) {\n        if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(previousPipeline.fragmentProgram);\n        stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, 'fragment');\n        this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);\n        backend.createProgram(stageFragment);\n      }\n\n      // determine render pipeline\n\n      const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);\n      let pipeline = this.caches.get(cacheKey);\n      if (pipeline === undefined) {\n        if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);\n        pipeline = this._getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises);\n      } else {\n        renderObject.pipeline = pipeline;\n      }\n\n      // keep track of all used times\n\n      pipeline.usedTimes++;\n      stageVertex.usedTimes++;\n      stageFragment.usedTimes++;\n\n      //\n\n      data.pipeline = pipeline;\n    }\n    return data.pipeline;\n  }\n  delete(object) {\n    const pipeline = this.get(object).pipeline;\n    if (pipeline) {\n      // pipeline\n\n      pipeline.usedTimes--;\n      if (pipeline.usedTimes === 0) this._releasePipeline(pipeline);\n\n      // programs\n\n      if (pipeline.isComputePipeline) {\n        pipeline.computeProgram.usedTimes--;\n        if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);\n      } else {\n        pipeline.fragmentProgram.usedTimes--;\n        pipeline.vertexProgram.usedTimes--;\n        if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);\n        if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);\n      }\n    }\n    return super.delete(object);\n  }\n  dispose() {\n    super.dispose();\n    this.caches = new Map();\n    this.programs = {\n      vertex: new Map(),\n      fragment: new Map(),\n      compute: new Map()\n    };\n  }\n  updateForRender(renderObject) {\n    this.getForRender(renderObject);\n  }\n  _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {\n    // check for existing pipeline\n\n    cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);\n    let pipeline = this.caches.get(cacheKey);\n    if (pipeline === undefined) {\n      pipeline = new ComputePipeline(cacheKey, stageCompute);\n      this.caches.set(cacheKey, pipeline);\n      this.backend.createComputePipeline(pipeline, bindings);\n    }\n    return pipeline;\n  }\n  _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises) {\n    // check for existing pipeline\n\n    cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);\n    let pipeline = this.caches.get(cacheKey);\n    if (pipeline === undefined) {\n      pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);\n      this.caches.set(cacheKey, pipeline);\n      renderObject.pipeline = pipeline;\n      this.backend.createRenderPipeline(renderObject, promises);\n    }\n    return pipeline;\n  }\n  _getComputeCacheKey(computeNode, stageCompute) {\n    return computeNode.id + ',' + stageCompute.id;\n  }\n  _getRenderCacheKey(renderObject, stageVertex, stageFragment) {\n    return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey(renderObject);\n  }\n  _releasePipeline(pipeline) {\n    this.caches.delete(pipeline.cacheKey);\n  }\n  _releaseProgram(program) {\n    const code = program.code;\n    const stage = program.stage;\n    this.programs[stage].delete(code);\n  }\n  _needsComputeUpdate(computeNode) {\n    const data = this.get(computeNode);\n    return data.pipeline === undefined || data.version !== computeNode.version;\n  }\n  _needsRenderUpdate(renderObject) {\n    const data = this.get(renderObject);\n    return data.pipeline === undefined || this.backend.needsRenderUpdate(renderObject);\n  }\n}\nclass Bindings extends DataMap {\n  constructor(backend, nodes, textures, attributes, pipelines, info) {\n    super();\n    this.backend = backend;\n    this.textures = textures;\n    this.pipelines = pipelines;\n    this.attributes = attributes;\n    this.nodes = nodes;\n    this.info = info;\n    this.pipelines.bindings = this; // assign bindings to pipelines\n  }\n  getForRender(renderObject) {\n    const bindings = renderObject.getBindings();\n    for (const bindGroup of bindings) {\n      const groupData = this.get(bindGroup);\n      if (groupData.bindGroup === undefined) {\n        // each object defines an array of bindings (ubos, textures, samplers etc.)\n\n        this._init(bindGroup);\n        this.backend.createBindings(bindGroup, bindings, 0);\n        groupData.bindGroup = bindGroup;\n      }\n    }\n    return bindings;\n  }\n  getForCompute(computeNode) {\n    const bindings = this.nodes.getForCompute(computeNode).bindings;\n    for (const bindGroup of bindings) {\n      const groupData = this.get(bindGroup);\n      if (groupData.bindGroup === undefined) {\n        this._init(bindGroup);\n        this.backend.createBindings(bindGroup, bindings, 0);\n        groupData.bindGroup = bindGroup;\n      }\n    }\n    return bindings;\n  }\n  updateForCompute(computeNode) {\n    this._updateBindings(this.getForCompute(computeNode));\n  }\n  updateForRender(renderObject) {\n    this._updateBindings(this.getForRender(renderObject));\n  }\n  _updateBindings(bindings) {\n    for (const bindGroup of bindings) {\n      this._update(bindGroup, bindings);\n    }\n  }\n  _init(bindGroup) {\n    for (const binding of bindGroup.bindings) {\n      if (binding.isSampledTexture) {\n        this.textures.updateTexture(binding.texture);\n      } else if (binding.isStorageBuffer) {\n        const attribute = binding.attribute;\n        const attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;\n        this.attributes.update(attribute, attributeType);\n      }\n    }\n  }\n  _update(bindGroup, bindings) {\n    const {\n      backend\n    } = this;\n    let needsBindingsUpdate = false;\n    let cacheBindings = true;\n    let cacheIndex = 0;\n    let version = 0;\n\n    // iterate over all bindings and check if buffer updates or a new binding group is required\n\n    for (const binding of bindGroup.bindings) {\n      if (binding.isNodeUniformsGroup) {\n        const updated = this.nodes.updateGroup(binding);\n        if (!updated) continue;\n      }\n      if (binding.isUniformBuffer) {\n        const updated = binding.update();\n        if (updated) {\n          backend.updateBinding(binding);\n        }\n      } else if (binding.isSampler) {\n        binding.update();\n      } else if (binding.isSampledTexture) {\n        const texturesTextureData = this.textures.get(binding.texture);\n        if (binding.needsBindingsUpdate(texturesTextureData.generation)) needsBindingsUpdate = true;\n        const updated = binding.update();\n        const texture = binding.texture;\n        if (updated) {\n          this.textures.updateTexture(texture);\n        }\n        const textureData = backend.get(texture);\n        if (textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture) {\n          cacheBindings = false;\n        } else {\n          cacheIndex = cacheIndex * 10 + texture.id;\n          version += texture.version;\n        }\n        if (backend.isWebGPUBackend === true && textureData.texture === undefined && textureData.externalTexture === undefined) {\n          // TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend\n          console.error('Bindings._update: binding should be available:', binding, updated, texture, binding.textureNode.value, needsBindingsUpdate);\n          this.textures.updateTexture(texture);\n          needsBindingsUpdate = true;\n        }\n        if (texture.isStorageTexture === true) {\n          const textureData = this.get(texture);\n          if (binding.store === true) {\n            textureData.needsMipmap = true;\n          } else if (this.textures.needsMipmaps(texture) && textureData.needsMipmap === true) {\n            this.backend.generateMipmaps(texture);\n            textureData.needsMipmap = false;\n          }\n        }\n      }\n    }\n    if (needsBindingsUpdate === true) {\n      this.backend.updateBindings(bindGroup, bindings, cacheBindings ? cacheIndex : 0, version);\n    }\n  }\n}\nfunction painterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.material.id !== b.material.id) {\n    return a.material.id - b.material.id;\n  } else if (a.z !== b.z) {\n    return a.z - b.z;\n  } else {\n    return a.id - b.id;\n  }\n}\nfunction reversePainterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.z !== b.z) {\n    return b.z - a.z;\n  } else {\n    return a.id - b.id;\n  }\n}\nfunction needsDoublePass(material) {\n  const hasTransmission = material.transmission > 0 || material.transmissionNode;\n  return hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;\n}\nclass RenderList {\n  constructor(lighting, scene, camera) {\n    this.renderItems = [];\n    this.renderItemsIndex = 0;\n    this.opaque = [];\n    this.transparentDoublePass = [];\n    this.transparent = [];\n    this.bundles = [];\n    this.lightsNode = lighting.getNode(scene, camera);\n    this.lightsArray = [];\n    this.scene = scene;\n    this.camera = camera;\n    this.occlusionQueryCount = 0;\n  }\n  begin() {\n    this.renderItemsIndex = 0;\n    this.opaque.length = 0;\n    this.transparentDoublePass.length = 0;\n    this.transparent.length = 0;\n    this.bundles.length = 0;\n    this.lightsArray.length = 0;\n    this.occlusionQueryCount = 0;\n    return this;\n  }\n  getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext) {\n    let renderItem = this.renderItems[this.renderItemsIndex];\n    if (renderItem === undefined) {\n      renderItem = {\n        id: object.id,\n        object: object,\n        geometry: geometry,\n        material: material,\n        groupOrder: groupOrder,\n        renderOrder: object.renderOrder,\n        z: z,\n        group: group,\n        clippingContext: clippingContext\n      };\n      this.renderItems[this.renderItemsIndex] = renderItem;\n    } else {\n      renderItem.id = object.id;\n      renderItem.object = object;\n      renderItem.geometry = geometry;\n      renderItem.material = material;\n      renderItem.groupOrder = groupOrder;\n      renderItem.renderOrder = object.renderOrder;\n      renderItem.z = z;\n      renderItem.group = group;\n      renderItem.clippingContext = clippingContext;\n    }\n    this.renderItemsIndex++;\n    return renderItem;\n  }\n  push(object, geometry, material, groupOrder, z, group, clippingContext) {\n    const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);\n    if (object.occlusionTest === true) this.occlusionQueryCount++;\n    if (material.transparent === true || material.transmission > 0) {\n      if (needsDoublePass(material)) this.transparentDoublePass.push(renderItem);\n      this.transparent.push(renderItem);\n    } else {\n      this.opaque.push(renderItem);\n    }\n  }\n  unshift(object, geometry, material, groupOrder, z, group, clippingContext) {\n    const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);\n    if (material.transparent === true || material.transmission > 0) {\n      if (needsDoublePass(material)) this.transparentDoublePass.unshift(renderItem);\n      this.transparent.unshift(renderItem);\n    } else {\n      this.opaque.unshift(renderItem);\n    }\n  }\n  pushBundle(group) {\n    this.bundles.push(group);\n  }\n  pushLight(light) {\n    this.lightsArray.push(light);\n  }\n  sort(customOpaqueSort, customTransparentSort) {\n    if (this.opaque.length > 1) this.opaque.sort(customOpaqueSort || painterSortStable);\n    if (this.transparentDoublePass.length > 1) this.transparentDoublePass.sort(customTransparentSort || reversePainterSortStable);\n    if (this.transparent.length > 1) this.transparent.sort(customTransparentSort || reversePainterSortStable);\n  }\n  finish() {\n    // update lights\n\n    this.lightsNode.setLights(this.lightsArray);\n\n    // Clear references from inactive renderItems in the list\n\n    for (let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i++) {\n      const renderItem = this.renderItems[i];\n      if (renderItem.id === null) break;\n      renderItem.id = null;\n      renderItem.object = null;\n      renderItem.geometry = null;\n      renderItem.material = null;\n      renderItem.groupOrder = null;\n      renderItem.renderOrder = null;\n      renderItem.z = null;\n      renderItem.group = null;\n      renderItem.clippingContext = null;\n    }\n  }\n}\nclass RenderLists {\n  constructor(lighting) {\n    this.lighting = lighting;\n    this.lists = new ChainMap();\n  }\n  get(scene, camera) {\n    const lists = this.lists;\n    const keys = [scene, camera];\n    let list = lists.get(keys);\n    if (list === undefined) {\n      list = new RenderList(this.lighting, scene, camera);\n      lists.set(keys, list);\n    }\n    return list;\n  }\n  dispose() {\n    this.lists = new ChainMap();\n  }\n}\nlet id$1 = 0;\nclass RenderContext {\n  constructor() {\n    this.id = id$1++;\n    this.color = true;\n    this.clearColor = true;\n    this.clearColorValue = {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 1\n    };\n    this.depth = true;\n    this.clearDepth = true;\n    this.clearDepthValue = 1;\n    this.stencil = false;\n    this.clearStencil = true;\n    this.clearStencilValue = 1;\n    this.viewport = false;\n    this.viewportValue = new Vector4();\n    this.scissor = false;\n    this.scissorValue = new Vector4();\n    this.textures = null;\n    this.depthTexture = null;\n    this.activeCubeFace = 0;\n    this.sampleCount = 1;\n    this.width = 0;\n    this.height = 0;\n    this.isRenderContext = true;\n  }\n  getCacheKey() {\n    return getCacheKey(this);\n  }\n}\nfunction getCacheKey(renderContext) {\n  const {\n    textures,\n    activeCubeFace\n  } = renderContext;\n  const values = [activeCubeFace];\n  for (const texture of textures) {\n    values.push(texture.id);\n  }\n  return hashArray(values);\n}\nclass RenderContexts {\n  constructor() {\n    this.chainMaps = {};\n  }\n  get(scene, camera, renderTarget = null) {\n    const chainKey = [scene, camera];\n    let attachmentState;\n    if (renderTarget === null) {\n      attachmentState = 'default';\n    } else {\n      const format = renderTarget.texture.format;\n      const count = renderTarget.textures.length;\n      attachmentState = `${count}:${format}:${renderTarget.samples}:${renderTarget.depthBuffer}:${renderTarget.stencilBuffer}`;\n    }\n    const chainMap = this.getChainMap(attachmentState);\n    let renderState = chainMap.get(chainKey);\n    if (renderState === undefined) {\n      renderState = new RenderContext();\n      chainMap.set(chainKey, renderState);\n    }\n    if (renderTarget !== null) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n    return renderState;\n  }\n  getChainMap(attachmentState) {\n    return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());\n  }\n  dispose() {\n    this.chainMaps = {};\n  }\n}\nconst _size$3 = /*@__PURE__*/new Vector3();\nclass Textures extends DataMap {\n  constructor(renderer, backend, info) {\n    super();\n    this.renderer = renderer;\n    this.backend = backend;\n    this.info = info;\n  }\n  updateRenderTarget(renderTarget, activeMipmapLevel = 0) {\n    const renderTargetData = this.get(renderTarget);\n    const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n    const depthTextureMips = renderTargetData.depthTextureMips || (renderTargetData.depthTextureMips = {});\n    const textures = renderTarget.textures;\n    const size = this.getSize(textures[0]);\n    const mipWidth = size.width >> activeMipmapLevel;\n    const mipHeight = size.height >> activeMipmapLevel;\n    let depthTexture = renderTarget.depthTexture || depthTextureMips[activeMipmapLevel];\n    const useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;\n    let textureNeedsUpdate = false;\n    if (depthTexture === undefined && useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;\n      depthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType\n      depthTexture.image.width = mipWidth;\n      depthTexture.image.height = mipHeight;\n      depthTextureMips[activeMipmapLevel] = depthTexture;\n    }\n    if (renderTargetData.width !== size.width || size.height !== renderTargetData.height) {\n      textureNeedsUpdate = true;\n      if (depthTexture) {\n        depthTexture.needsUpdate = true;\n        depthTexture.image.width = mipWidth;\n        depthTexture.image.height = mipHeight;\n      }\n    }\n    renderTargetData.width = size.width;\n    renderTargetData.height = size.height;\n    renderTargetData.textures = textures;\n    renderTargetData.depthTexture = depthTexture || null;\n    renderTargetData.depth = renderTarget.depthBuffer;\n    renderTargetData.stencil = renderTarget.stencilBuffer;\n    renderTargetData.renderTarget = renderTarget;\n    if (renderTargetData.sampleCount !== sampleCount) {\n      textureNeedsUpdate = true;\n      if (depthTexture) {\n        depthTexture.needsUpdate = true;\n      }\n      renderTargetData.sampleCount = sampleCount;\n    }\n\n    //\n\n    const options = {\n      sampleCount\n    };\n    for (let i = 0; i < textures.length; i++) {\n      const texture = textures[i];\n      if (textureNeedsUpdate) texture.needsUpdate = true;\n      this.updateTexture(texture, options);\n    }\n    if (depthTexture) {\n      this.updateTexture(depthTexture, options);\n    }\n\n    // dispose handler\n\n    if (renderTargetData.initialized !== true) {\n      renderTargetData.initialized = true;\n\n      // dispose\n\n      const onDispose = () => {\n        renderTarget.removeEventListener('dispose', onDispose);\n        for (let i = 0; i < textures.length; i++) {\n          this._destroyTexture(textures[i]);\n        }\n        if (depthTexture) {\n          this._destroyTexture(depthTexture);\n        }\n        this.delete(renderTarget);\n      };\n      renderTarget.addEventListener('dispose', onDispose);\n    }\n  }\n  updateTexture(texture, options = {}) {\n    const textureData = this.get(texture);\n    if (textureData.initialized === true && textureData.version === texture.version) return;\n    const isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;\n    const backend = this.backend;\n    if (isRenderTarget && textureData.initialized === true) {\n      // it's an update\n\n      backend.destroySampler(texture);\n      backend.destroyTexture(texture);\n    }\n\n    //\n\n    if (texture.isFramebufferTexture) {\n      const renderTarget = this.renderer.getRenderTarget();\n      if (renderTarget) {\n        texture.type = renderTarget.texture.type;\n      } else {\n        texture.type = UnsignedByteType;\n      }\n    }\n\n    //\n\n    const {\n      width,\n      height,\n      depth\n    } = this.getSize(texture);\n    options.width = width;\n    options.height = height;\n    options.depth = depth;\n    options.needsMipmaps = this.needsMipmaps(texture);\n    options.levels = options.needsMipmaps ? this.getMipLevels(texture, width, height) : 1;\n\n    //\n\n    if (isRenderTarget || texture.isStorageTexture === true) {\n      backend.createSampler(texture);\n      backend.createTexture(texture, options);\n      textureData.generation = texture.version;\n    } else {\n      const needsCreate = textureData.initialized !== true;\n      if (needsCreate) backend.createSampler(texture);\n      if (texture.version > 0) {\n        const image = texture.image;\n        if (image === undefined) {\n          console.warn('THREE.Renderer: Texture marked for update but image is undefined.');\n        } else if (image.complete === false) {\n          console.warn('THREE.Renderer: Texture marked for update but image is incomplete.');\n        } else {\n          if (texture.images) {\n            const images = [];\n            for (const image of texture.images) {\n              images.push(image);\n            }\n            options.images = images;\n          } else {\n            options.image = image;\n          }\n          if (textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true) {\n            backend.createTexture(texture, options);\n            textureData.isDefaultTexture = false;\n            textureData.generation = texture.version;\n          }\n          if (texture.source.dataReady === true) backend.updateTexture(texture, options);\n          if (options.needsMipmaps && texture.mipmaps.length === 0) backend.generateMipmaps(texture);\n        }\n      } else {\n        // async update\n\n        backend.createDefaultTexture(texture);\n        textureData.isDefaultTexture = true;\n        textureData.generation = texture.version;\n      }\n    }\n\n    // dispose handler\n\n    if (textureData.initialized !== true) {\n      textureData.initialized = true;\n      textureData.generation = texture.version;\n\n      //\n\n      this.info.memory.textures++;\n\n      // dispose\n\n      const onDispose = () => {\n        texture.removeEventListener('dispose', onDispose);\n        this._destroyTexture(texture);\n        this.info.memory.textures--;\n      };\n      texture.addEventListener('dispose', onDispose);\n    }\n\n    //\n\n    textureData.version = texture.version;\n  }\n  getSize(texture, target = _size$3) {\n    let image = texture.images ? texture.images[0] : texture.image;\n    if (image) {\n      if (image.image !== undefined) image = image.image;\n      target.width = image.width || 1;\n      target.height = image.height || 1;\n      target.depth = texture.isCubeTexture ? 6 : image.depth || 1;\n    } else {\n      target.width = target.height = target.depth = 1;\n    }\n    return target;\n  }\n  getMipLevels(texture, width, height) {\n    let mipLevelCount;\n    if (texture.isCompressedTexture) {\n      if (texture.mipmaps) {\n        mipLevelCount = texture.mipmaps.length;\n      } else {\n        mipLevelCount = 1;\n      }\n    } else {\n      mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;\n    }\n    return mipLevelCount;\n  }\n  needsMipmaps(texture) {\n    return this.isEnvironmentTexture(texture) || texture.isCompressedTexture === true || texture.generateMipmaps;\n  }\n  isEnvironmentTexture(texture) {\n    const mapping = texture.mapping;\n    return mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping || mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;\n  }\n  _destroyTexture(texture) {\n    this.backend.destroySampler(texture);\n    this.backend.destroyTexture(texture);\n    this.delete(texture);\n  }\n}\nclass Color4 extends Color {\n  constructor(r, g, b, a = 1) {\n    super(r, g, b);\n    this.a = a;\n  }\n  set(r, g, b, a = 1) {\n    this.a = a;\n    return super.set(r, g, b);\n  }\n  copy(color) {\n    if (color.a !== undefined) this.a = color.a;\n    return super.copy(color);\n  }\n  clone() {\n    return new this.constructor(this.r, this.g, this.b, this.a);\n  }\n}\nclass ParameterNode extends PropertyNode {\n  static get type() {\n    return 'ParameterNode';\n  }\n  constructor(nodeType, name = null) {\n    super(nodeType, name);\n    this.isParameterNode = true;\n  }\n  getHash() {\n    return this.uuid;\n  }\n  generate() {\n    return this.name;\n  }\n}\nconst parameter = (type, name) => nodeObject(new ParameterNode(type, name));\nclass StackNode extends Node {\n  static get type() {\n    return 'StackNode';\n  }\n  constructor(parent = null) {\n    super();\n    this.nodes = [];\n    this.outputNode = null;\n    this.parent = parent;\n    this._currentCond = null;\n    this.isStackNode = true;\n  }\n  getNodeType(builder) {\n    return this.outputNode ? this.outputNode.getNodeType(builder) : 'void';\n  }\n  add(node) {\n    this.nodes.push(node);\n    return this;\n  }\n  If(boolNode, method) {\n    const methodNode = new ShaderNode(method);\n    this._currentCond = select(boolNode, methodNode);\n    return this.add(this._currentCond);\n  }\n  ElseIf(boolNode, method) {\n    const methodNode = new ShaderNode(method);\n    const ifNode = select(boolNode, methodNode);\n    this._currentCond.elseNode = ifNode;\n    this._currentCond = ifNode;\n    return this;\n  }\n  Else(method) {\n    this._currentCond.elseNode = new ShaderNode(method);\n    return this;\n  }\n  build(builder, ...params) {\n    const previousStack = getCurrentStack();\n    setCurrentStack(this);\n    for (const node of this.nodes) {\n      node.build(builder, 'void');\n    }\n    setCurrentStack(previousStack);\n    return this.outputNode ? this.outputNode.build(builder, ...params) : super.build(builder, ...params);\n  }\n\n  //\n\n  else(...params) {\n    // @deprecated, r168\n\n    console.warn('TSL.StackNode: .else() has been renamed to .Else().');\n    return this.Else(...params);\n  }\n  elseif(...params) {\n    // @deprecated, r168\n\n    console.warn('TSL.StackNode: .elseif() has been renamed to .ElseIf().');\n    return this.ElseIf(...params);\n  }\n}\nconst stack = /*@__PURE__*/nodeProxy(StackNode);\nclass StructTypeNode extends Node {\n  static get type() {\n    return 'StructTypeNode';\n  }\n  constructor(types) {\n    super();\n    this.types = types;\n    this.isStructTypeNode = true;\n  }\n  getMemberTypes() {\n    return this.types;\n  }\n}\nclass OutputStructNode extends Node {\n  static get type() {\n    return 'OutputStructNode';\n  }\n  constructor(...members) {\n    super();\n    this.members = members;\n    this.isOutputStructNode = true;\n  }\n  setup(builder) {\n    super.setup(builder);\n    const members = this.members;\n    const types = [];\n    for (let i = 0; i < members.length; i++) {\n      types.push(members[i].getNodeType(builder));\n    }\n    this.nodeType = builder.getStructTypeFromNode(new StructTypeNode(types)).name;\n  }\n  generate(builder, output) {\n    const propertyName = builder.getOutputStructName();\n    const members = this.members;\n    const structPrefix = propertyName !== '' ? propertyName + '.' : '';\n    for (let i = 0; i < members.length; i++) {\n      const snippet = members[i].build(builder, output);\n      builder.addLineFlowCode(`${structPrefix}m${i} = ${snippet}`, this);\n    }\n    return propertyName;\n  }\n}\nconst outputStruct = /*@__PURE__*/nodeProxy(OutputStructNode);\nfunction getTextureIndex(textures, name) {\n  for (let i = 0; i < textures.length; i++) {\n    if (textures[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\nclass MRTNode extends OutputStructNode {\n  static get type() {\n    return 'MRTNode';\n  }\n  constructor(outputNodes) {\n    super();\n    this.outputNodes = outputNodes;\n    this.isMRTNode = true;\n  }\n  has(name) {\n    return this.outputNodes[name] !== undefined;\n  }\n  get(name) {\n    return this.outputNodes[name];\n  }\n  merge(mrtNode) {\n    const outputs = {\n      ...this.outputNodes,\n      ...mrtNode.outputNodes\n    };\n    return mrt(outputs);\n  }\n  setup(builder) {\n    const outputNodes = this.outputNodes;\n    const mrt = builder.renderer.getRenderTarget();\n    const members = [];\n    const textures = mrt.textures;\n    for (const name in outputNodes) {\n      const index = getTextureIndex(textures, name);\n      members[index] = vec4(outputNodes[name]);\n    }\n    this.members = members;\n    return super.setup(builder);\n  }\n}\nconst mrt = /*@__PURE__*/nodeProxy(MRTNode);\nconst hash = /*@__PURE__*/Fn(([seed]) => {\n  // Taken from https://www.shadertoy.com/view/XlGcRh, originally from pcg-random.org\n\n  const state = seed.toUint().mul(747796405).add(2891336453);\n  const word = state.shiftRight(state.shiftRight(28).add(4)).bitXor(state).mul(277803737);\n  const result = word.shiftRight(22).bitXor(word);\n  return result.toFloat().mul(1 / 2 ** 32); // Convert to range [0, 1)\n});\n\n// remapping functions https://iquilezles.org/articles/functions/\nconst parabola = (x, k) => pow(mul(4.0, x.mul(sub(1.0, x))), k);\nconst gain = (x, k) => x.lessThan(0.5) ? parabola(x.mul(2.0), k).div(2.0) : sub(1.0, parabola(mul(sub(1.0, x), 2.0), k).div(2.0));\nconst pcurve = (x, a, b) => pow(div(pow(x, a), add(pow(x, a), pow(sub(1.0, x), b))), 1.0 / a);\nconst sinc = (x, k) => sin(PI.mul(k.mul(x).sub(1.0))).div(PI.mul(k.mul(x).sub(1.0)));\n\n// https://github.com/cabbibo/glsl-tri-noise-3d\n\nconst tri = /*@__PURE__*/Fn(([x]) => {\n  return x.fract().sub(.5).abs();\n}).setLayout({\n  name: 'tri',\n  type: 'float',\n  inputs: [{\n    name: 'x',\n    type: 'float'\n  }]\n});\nconst tri3 = /*@__PURE__*/Fn(([p]) => {\n  return vec3(tri(p.z.add(tri(p.y.mul(1.)))), tri(p.z.add(tri(p.x.mul(1.)))), tri(p.y.add(tri(p.x.mul(1.)))));\n}).setLayout({\n  name: 'tri3',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\nconst triNoise3D = /*@__PURE__*/Fn(([p_immutable, spd, time]) => {\n  const p = vec3(p_immutable).toVar();\n  const z = float(1.4).toVar();\n  const rz = float(0.0).toVar();\n  const bp = vec3(p).toVar();\n  Loop({\n    start: float(0.0),\n    end: float(3.0),\n    type: 'float',\n    condition: '<='\n  }, () => {\n    const dg = vec3(tri3(bp.mul(2.0))).toVar();\n    p.addAssign(dg.add(time.mul(float(0.1).mul(spd))));\n    bp.mulAssign(1.8);\n    z.mulAssign(1.5);\n    p.mulAssign(1.2);\n    const t = float(tri(p.z.add(tri(p.x.add(tri(p.y)))))).toVar();\n    rz.addAssign(t.div(z));\n    bp.addAssign(0.14);\n  });\n  return rz;\n}).setLayout({\n  name: 'triNoise3D',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'spd',\n    type: 'float'\n  }, {\n    name: 'time',\n    type: 'float'\n  }]\n});\nclass FunctionOverloadingNode extends Node {\n  static get type() {\n    return 'FunctionOverloadingNode';\n  }\n  constructor(functionNodes = [], ...parametersNodes) {\n    super();\n    this.functionNodes = functionNodes;\n    this.parametersNodes = parametersNodes;\n    this._candidateFnCall = null;\n    this.global = true;\n  }\n  getNodeType() {\n    return this.functionNodes[0].shaderNode.layout.type;\n  }\n  setup(builder) {\n    const params = this.parametersNodes;\n    let candidateFnCall = this._candidateFnCall;\n    if (candidateFnCall === null) {\n      let candidateFn = null;\n      let candidateScore = -1;\n      for (const functionNode of this.functionNodes) {\n        const shaderNode = functionNode.shaderNode;\n        const layout = shaderNode.layout;\n        if (layout === null) {\n          throw new Error('FunctionOverloadingNode: FunctionNode must be a layout.');\n        }\n        const inputs = layout.inputs;\n        if (params.length === inputs.length) {\n          let score = 0;\n          for (let i = 0; i < params.length; i++) {\n            const param = params[i];\n            const input = inputs[i];\n            if (param.getNodeType(builder) === input.type) {\n              score++;\n            } else {\n              score = 0;\n            }\n          }\n          if (score > candidateScore) {\n            candidateFn = functionNode;\n            candidateScore = score;\n          }\n        }\n      }\n      this._candidateFnCall = candidateFnCall = candidateFn(...params);\n    }\n    return candidateFnCall;\n  }\n}\nconst overloadingBaseFn = /*@__PURE__*/nodeProxy(FunctionOverloadingNode);\nconst overloadingFn = functionNodes => (...params) => overloadingBaseFn(functionNodes, ...params);\nconst time = /*@__PURE__*/uniform(0).setGroup(renderGroup).onRenderUpdate(frame => frame.time);\nconst deltaTime = /*@__PURE__*/uniform(0).setGroup(renderGroup).onRenderUpdate(frame => frame.deltaTime);\nconst frameId = /*@__PURE__*/uniform(0, 'uint').setGroup(renderGroup).onRenderUpdate(frame => frame.frameId);\n\n// Deprecated\n\nconst timerLocal = (timeScale = 1) => {\n  // @deprecated, r170\n\n  console.warn('TSL: timerLocal() is deprecated. Use \"time\" instead.');\n  return time.mul(timeScale);\n};\nconst timerGlobal = (timeScale = 1) => {\n  // @deprecated, r170\n\n  console.warn('TSL: timerGlobal() is deprecated. Use \"time\" instead.');\n  return time.mul(timeScale);\n};\nconst timerDelta = (timeScale = 1) => {\n  // @deprecated, r170\n\n  console.warn('TSL: timerDelta() is deprecated. Use \"deltaTime\" instead.');\n  return deltaTime.mul(timeScale);\n};\nconst oscSine = (t = time) => t.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5);\nconst oscSquare = (t = time) => t.fract().round();\nconst oscTriangle = (t = time) => t.add(0.5).fract().mul(2).sub(1).abs();\nconst oscSawtooth = (t = time) => t.fract();\nconst rotateUV = /*@__PURE__*/Fn(([uv, rotation, center = vec2(0.5)]) => {\n  return rotate(uv.sub(center), rotation).add(center);\n});\nconst spherizeUV = /*@__PURE__*/Fn(([uv, strength, center = vec2(0.5)]) => {\n  const delta = uv.sub(center);\n  const delta2 = delta.dot(delta);\n  const delta4 = delta2.mul(delta2);\n  const deltaOffset = delta4.mul(strength);\n  return uv.add(delta.mul(deltaOffset));\n});\nconst billboarding = /*@__PURE__*/Fn(({\n  position = null,\n  horizontal = true,\n  vertical = false\n}) => {\n  let worldMatrix;\n  if (position !== null) {\n    worldMatrix = modelWorldMatrix.toVar();\n    worldMatrix[3][0] = position.x;\n    worldMatrix[3][1] = position.y;\n    worldMatrix[3][2] = position.z;\n  } else {\n    worldMatrix = modelWorldMatrix;\n  }\n  const modelViewMatrix = cameraViewMatrix.mul(worldMatrix);\n  if (defined(horizontal)) {\n    modelViewMatrix[0][0] = modelWorldMatrix[0].length();\n    modelViewMatrix[0][1] = 0;\n    modelViewMatrix[0][2] = 0;\n  }\n  if (defined(vertical)) {\n    modelViewMatrix[1][0] = 0;\n    modelViewMatrix[1][1] = modelWorldMatrix[1].length();\n    modelViewMatrix[1][2] = 0;\n  }\n  modelViewMatrix[2][0] = 0;\n  modelViewMatrix[2][1] = 0;\n  modelViewMatrix[2][2] = 1;\n  return cameraProjectionMatrix.mul(modelViewMatrix).mul(positionLocal);\n});\nconst viewportSafeUV = /*@__PURE__*/Fn(([uv = null]) => {\n  const depth = linearDepth();\n  const depthDiff = linearDepth(viewportDepthTexture(uv)).sub(depth);\n  const finalUV = depthDiff.lessThan(0).select(screenUV, uv);\n  return finalUV;\n});\nclass SpriteSheetUVNode extends Node {\n  static get type() {\n    return 'SpriteSheetUVNode';\n  }\n  constructor(countNode, uvNode = uv(), frameNode = float(0)) {\n    super('vec2');\n    this.countNode = countNode;\n    this.uvNode = uvNode;\n    this.frameNode = frameNode;\n  }\n  setup() {\n    const {\n      frameNode,\n      uvNode,\n      countNode\n    } = this;\n    const {\n      width,\n      height\n    } = countNode;\n    const frameNum = frameNode.mod(width.mul(height)).floor();\n    const column = frameNum.mod(width);\n    const row = height.sub(frameNum.add(1).div(width).ceil());\n    const scale = countNode.reciprocal();\n    const uvFrameOffset = vec2(column, row);\n    return uvNode.add(uvFrameOffset).mul(scale);\n  }\n}\nconst spritesheetUV = /*@__PURE__*/nodeProxy(SpriteSheetUVNode);\nclass TriplanarTexturesNode extends Node {\n  static get type() {\n    return 'TriplanarTexturesNode';\n  }\n  constructor(textureXNode, textureYNode = null, textureZNode = null, scaleNode = float(1), positionNode = positionLocal, normalNode = normalLocal) {\n    super('vec4');\n    this.textureXNode = textureXNode;\n    this.textureYNode = textureYNode;\n    this.textureZNode = textureZNode;\n    this.scaleNode = scaleNode;\n    this.positionNode = positionNode;\n    this.normalNode = normalNode;\n  }\n  setup() {\n    const {\n      textureXNode,\n      textureYNode,\n      textureZNode,\n      scaleNode,\n      positionNode,\n      normalNode\n    } = this;\n\n    // Ref: https://github.com/keijiro/StandardTriplanar\n\n    // Blending factor of triplanar mapping\n    let bf = normalNode.abs().normalize();\n    bf = bf.div(bf.dot(vec3(1.0)));\n\n    // Triplanar mapping\n    const tx = positionNode.yz.mul(scaleNode);\n    const ty = positionNode.zx.mul(scaleNode);\n    const tz = positionNode.xy.mul(scaleNode);\n\n    // Base color\n    const textureX = textureXNode.value;\n    const textureY = textureYNode !== null ? textureYNode.value : textureX;\n    const textureZ = textureZNode !== null ? textureZNode.value : textureX;\n    const cx = texture(textureX, tx).mul(bf.x);\n    const cy = texture(textureY, ty).mul(bf.y);\n    const cz = texture(textureZ, tz).mul(bf.z);\n    return add(cx, cy, cz);\n  }\n}\nconst triplanarTextures = /*@__PURE__*/nodeProxy(TriplanarTexturesNode);\nconst triplanarTexture = (...params) => triplanarTextures(...params);\nconst _reflectorPlane = new Plane();\nconst _normal = new Vector3();\nconst _reflectorWorldPosition = new Vector3();\nconst _cameraWorldPosition = new Vector3();\nconst _rotationMatrix = new Matrix4();\nconst _lookAtPosition = new Vector3(0, 0, -1);\nconst clipPlane = new Vector4();\nconst _view = new Vector3();\nconst _target = new Vector3();\nconst _q = new Vector4();\nconst _size$2 = new Vector2();\nconst _defaultRT = new RenderTarget();\nconst _defaultUV = screenUV.flipX();\n_defaultRT.depthTexture = new DepthTexture(1, 1);\nlet _inReflector = false;\nclass ReflectorNode extends TextureNode {\n  static get type() {\n    return 'ReflectorNode';\n  }\n  constructor(parameters = {}) {\n    super(parameters.defaultTexture || _defaultRT.texture, _defaultUV);\n    this._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode(this, parameters);\n    this._depthNode = null;\n    this.setUpdateMatrix(false);\n  }\n  get reflector() {\n    return this._reflectorBaseNode;\n  }\n  get target() {\n    return this._reflectorBaseNode.target;\n  }\n  getDepthNode() {\n    if (this._depthNode === null) {\n      if (this._reflectorBaseNode.depth !== true) {\n        throw new Error('THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ');\n      }\n      this._depthNode = nodeObject(new ReflectorNode({\n        defaultTexture: _defaultRT.depthTexture,\n        reflector: this._reflectorBaseNode\n      }));\n    }\n    return this._depthNode;\n  }\n  setup(builder) {\n    // ignore if used in post-processing\n    if (!builder.object.isQuadMesh) this._reflectorBaseNode.build(builder);\n    return super.setup(builder);\n  }\n  clone() {\n    const texture = new this.constructor(this.reflectorNode);\n    texture._reflectorBaseNode = this._reflectorBaseNode;\n    return texture;\n  }\n}\nclass ReflectorBaseNode extends Node {\n  static get type() {\n    return 'ReflectorBaseNode';\n  }\n  constructor(textureNode, parameters = {}) {\n    super();\n    const {\n      target = new Object3D(),\n      resolution = 1,\n      generateMipmaps = false,\n      bounces = true,\n      depth = false\n    } = parameters;\n\n    //\n\n    this.textureNode = textureNode;\n    this.target = target;\n    this.resolution = resolution;\n    this.generateMipmaps = generateMipmaps;\n    this.bounces = bounces;\n    this.depth = depth;\n    this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n    this.virtualCameras = new WeakMap();\n    this.renderTargets = new WeakMap();\n  }\n  _updateResolution(renderTarget, renderer) {\n    const resolution = this.resolution;\n    renderer.getDrawingBufferSize(_size$2);\n    renderTarget.setSize(Math.round(_size$2.width * resolution), Math.round(_size$2.height * resolution));\n  }\n  setup(builder) {\n    this._updateResolution(_defaultRT, builder.renderer);\n    return super.setup(builder);\n  }\n  getVirtualCamera(camera) {\n    let virtualCamera = this.virtualCameras.get(camera);\n    if (virtualCamera === undefined) {\n      virtualCamera = camera.clone();\n      this.virtualCameras.set(camera, virtualCamera);\n    }\n    return virtualCamera;\n  }\n  getRenderTarget(camera) {\n    let renderTarget = this.renderTargets.get(camera);\n    if (renderTarget === undefined) {\n      renderTarget = new RenderTarget(0, 0, {\n        type: HalfFloatType\n      });\n      if (this.generateMipmaps === true) {\n        renderTarget.texture.minFilter = LinearMipMapLinearFilter;\n        renderTarget.texture.generateMipmaps = true;\n      }\n      if (this.depth === true) {\n        renderTarget.depthTexture = new DepthTexture();\n      }\n      this.renderTargets.set(camera, renderTarget);\n    }\n    return renderTarget;\n  }\n  updateBefore(frame) {\n    if (this.bounces === false && _inReflector) return;\n    _inReflector = true;\n    const {\n      scene,\n      camera,\n      renderer,\n      material\n    } = frame;\n    const {\n      target\n    } = this;\n    const virtualCamera = this.getVirtualCamera(camera);\n    const renderTarget = this.getRenderTarget(virtualCamera);\n    renderer.getDrawingBufferSize(_size$2);\n    this._updateResolution(renderTarget, renderer);\n\n    //\n\n    _reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);\n    _cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    _rotationMatrix.extractRotation(target.matrixWorld);\n    _normal.set(0, 0, 1);\n    _normal.applyMatrix4(_rotationMatrix);\n    _view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);\n\n    // Avoid rendering when reflector is facing away\n\n    if (_view.dot(_normal) > 0) return;\n    _view.reflect(_normal).negate();\n    _view.add(_reflectorWorldPosition);\n    _rotationMatrix.extractRotation(camera.matrixWorld);\n    _lookAtPosition.set(0, 0, -1);\n    _lookAtPosition.applyMatrix4(_rotationMatrix);\n    _lookAtPosition.add(_cameraWorldPosition);\n    _target.subVectors(_reflectorWorldPosition, _lookAtPosition);\n    _target.reflect(_normal).negate();\n    _target.add(_reflectorWorldPosition);\n\n    //\n\n    virtualCamera.coordinateSystem = camera.coordinateSystem;\n    virtualCamera.position.copy(_view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(_rotationMatrix);\n    virtualCamera.up.reflect(_normal);\n    virtualCamera.lookAt(_target);\n    virtualCamera.near = camera.near;\n    virtualCamera.far = camera.far;\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n\n    // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n    _reflectorPlane.setFromNormalAndCoplanarPoint(_normal, _reflectorWorldPosition);\n    _reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(_reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant);\n    const projectionMatrix = virtualCamera.projectionMatrix;\n    _q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    _q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    _q.z = -1.0;\n    _q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n    // Calculate the scaled plane vector\n    clipPlane.multiplyScalar(1.0 / clipPlane.dot(_q));\n    const clipBias = 0;\n\n    // Replacing the third row of the projection matrix\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = renderer.coordinateSystem === WebGPUCoordinateSystem ? clipPlane.z - clipBias : clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w;\n\n    //\n\n    this.textureNode.value = renderTarget.texture;\n    if (this.depth === true) {\n      this.textureNode.getDepthNode().value = renderTarget.depthTexture;\n    }\n    material.visible = false;\n    const currentRenderTarget = renderer.getRenderTarget();\n    const currentMRT = renderer.getMRT();\n    renderer.setMRT(null);\n    renderer.setRenderTarget(renderTarget);\n    renderer.render(scene, virtualCamera);\n    renderer.setMRT(currentMRT);\n    renderer.setRenderTarget(currentRenderTarget);\n    material.visible = true;\n    _inReflector = false;\n  }\n}\nconst reflector = parameters => nodeObject(new ReflectorNode(parameters));\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = /*@__PURE__*/new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nclass QuadGeometry extends BufferGeometry {\n  constructor(flipY = false) {\n    super();\n    const uv = flipY === false ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];\n    this.setAttribute('position', new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uv, 2));\n  }\n}\nconst _geometry = /*@__PURE__*/new QuadGeometry();\nclass QuadMesh extends Mesh {\n  constructor(material = null) {\n    super(_geometry, material);\n    this.camera = _camera;\n    this.isQuadMesh = true;\n  }\n  renderAsync(renderer) {\n    return renderer.renderAsync(this, _camera);\n  }\n  render(renderer) {\n    renderer.render(this, _camera);\n  }\n}\nconst _size$1 = /*@__PURE__*/new Vector2();\nclass RTTNode extends TextureNode {\n  static get type() {\n    return 'RTTNode';\n  }\n  constructor(node, width = null, height = null, options = {\n    type: HalfFloatType\n  }) {\n    const renderTarget = new RenderTarget(width, height, options);\n    super(renderTarget.texture, uv());\n    this.node = node;\n    this.width = width;\n    this.height = height;\n    this.renderTarget = renderTarget;\n    this.textureNeedsUpdate = true;\n    this.autoUpdate = true;\n    this.updateMap = new WeakMap();\n    this._rttNode = null;\n    this._quadMesh = new QuadMesh(new NodeMaterial());\n    this.updateBeforeType = NodeUpdateType.RENDER;\n  }\n  get autoSize() {\n    return this.width === null;\n  }\n  setup(builder) {\n    this._rttNode = this.node.context(builder.getSharedContext());\n    this._quadMesh.material.name = 'RTT';\n    this._quadMesh.material.needsUpdate = true;\n    return super.setup(builder);\n  }\n  setSize(width, height) {\n    this.width = width;\n    this.height = height;\n    const effectiveWidth = width * this.pixelRatio;\n    const effectiveHeight = height * this.pixelRatio;\n    this.renderTarget.setSize(effectiveWidth, effectiveHeight);\n    this.textureNeedsUpdate = true;\n  }\n  setPixelRatio(pixelRatio) {\n    this.pixelRatio = pixelRatio;\n    this.setSize(this.width, this.height);\n  }\n  updateBefore({\n    renderer\n  }) {\n    if (this.textureNeedsUpdate === false && this.autoUpdate === false) return;\n    this.textureNeedsUpdate = false;\n\n    //\n\n    if (this.autoSize === true) {\n      this.pixelRatio = renderer.getPixelRatio();\n      const size = renderer.getSize(_size$1);\n      this.setSize(size.width, size.height);\n    }\n\n    //\n\n    this._quadMesh.material.fragmentNode = this._rttNode;\n\n    //\n\n    const currentRenderTarget = renderer.getRenderTarget();\n    renderer.setRenderTarget(this.renderTarget);\n    this._quadMesh.render(renderer);\n    renderer.setRenderTarget(currentRenderTarget);\n  }\n  clone() {\n    const newNode = new TextureNode(this.value, this.uvNode, this.levelNode);\n    newNode.sampler = this.sampler;\n    newNode.referenceNode = this;\n    return newNode;\n  }\n}\nconst rtt = (node, ...params) => nodeObject(new RTTNode(nodeObject(node), ...params));\nconst convertToTexture = (node, ...params) => {\n  if (node.isTextureNode) return node;\n  if (node.isPassNode) return node.getTextureNode();\n  return rtt(node, ...params);\n};\n\n/**\n* Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments\n* depth value and the camera's inverse projection matrix.\n*\n* @param {vec2} screenPosition - The fragment's screen position expressed as uv coordinates.\n* @param {float} depth - The fragment's depth value.\n* @param {mat4} projectionMatrixInverse - The camera's inverse projection matrix.\n* @return {vec3} The fragments position in view space.\n*/\nconst getViewPosition = /*@__PURE__*/Fn(([screenPosition, depth, projectionMatrixInverse], builder) => {\n  let clipSpacePosition;\n  if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {\n    screenPosition = vec2(screenPosition.x, screenPosition.y.oneMinus()).mul(2.0).sub(1.0);\n    clipSpacePosition = vec4(vec3(screenPosition, depth), 1.0);\n  } else {\n    clipSpacePosition = vec4(vec3(screenPosition.x, screenPosition.y.oneMinus(), depth).mul(2.0).sub(1.0), 1.0);\n  }\n  const viewSpacePosition = vec4(projectionMatrixInverse.mul(clipSpacePosition));\n  return viewSpacePosition.xyz.div(viewSpacePosition.w);\n});\n\n/**\n* Computes a screen position expressed as uv coordinates based on a fragment's position in view space\n* and the camera's projection matrix\n*\n* @param {vec3} viewPosition - The fragments position in view space.\n* @param {mat4} projectionMatrix - The camera's projection matrix.\n* @return {vec2} The fragment's screen position expressed as uv coordinates.\n*/\nconst getScreenPosition = /*@__PURE__*/Fn(([viewPosition, projectionMatrix]) => {\n  const sampleClipPos = projectionMatrix.mul(vec4(viewPosition, 1.0));\n  const sampleUv = sampleClipPos.xy.div(sampleClipPos.w).mul(0.5).add(0.5).toVar();\n  return vec2(sampleUv.x, sampleUv.y.oneMinus());\n});\n\n/**\n* Computes a normal vector based on depth data. Can be used as a fallback when no normal render\n* target is available or if flat surface normals are required.\n*\n* @param {vec2} uv - The texture coordinate.\n* @param {DepthTexture} depthTexture - The depth texture.\n* @param {mat4} projectionMatrixInverse - The camera's inverse projection matrix.\n* @return {vec3} The computed normal vector.\n*/\nconst getNormalFromDepth = /*@__PURE__*/Fn(([uv, depthTexture, projectionMatrixInverse]) => {\n  const size = textureSize(textureLoad(depthTexture));\n  const p = ivec2(uv.mul(size)).toVar();\n  const c0 = textureLoad(depthTexture, p).toVar();\n  const l2 = textureLoad(depthTexture, p.sub(ivec2(2, 0))).toVar();\n  const l1 = textureLoad(depthTexture, p.sub(ivec2(1, 0))).toVar();\n  const r1 = textureLoad(depthTexture, p.add(ivec2(1, 0))).toVar();\n  const r2 = textureLoad(depthTexture, p.add(ivec2(2, 0))).toVar();\n  const b2 = textureLoad(depthTexture, p.add(ivec2(0, 2))).toVar();\n  const b1 = textureLoad(depthTexture, p.add(ivec2(0, 1))).toVar();\n  const t1 = textureLoad(depthTexture, p.sub(ivec2(0, 1))).toVar();\n  const t2 = textureLoad(depthTexture, p.sub(ivec2(0, 2))).toVar();\n  const dl = abs(sub(float(2).mul(l1).sub(l2), c0)).toVar();\n  const dr = abs(sub(float(2).mul(r1).sub(r2), c0)).toVar();\n  const db = abs(sub(float(2).mul(b1).sub(b2), c0)).toVar();\n  const dt = abs(sub(float(2).mul(t1).sub(t2), c0)).toVar();\n  const ce = getViewPosition(uv, c0, projectionMatrixInverse).toVar();\n  const dpdx = dl.lessThan(dr).select(ce.sub(getViewPosition(uv.sub(vec2(float(1).div(size.x), 0)), l1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv.add(vec2(float(1).div(size.x), 0)), r1, projectionMatrixInverse)));\n  const dpdy = db.lessThan(dt).select(ce.sub(getViewPosition(uv.add(vec2(0, float(1).div(size.y))), b1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv.sub(vec2(0, float(1).div(size.y))), t1, projectionMatrixInverse)));\n  return normalize(cross(dpdx, dpdy));\n});\nclass StorageInstancedBufferAttribute extends InstancedBufferAttribute {\n  constructor(array, itemSize, typeClass = Float32Array) {\n    if (ArrayBuffer.isView(array) === false) array = new typeClass(array * itemSize);\n    super(array, itemSize);\n    this.isStorageInstancedBufferAttribute = true;\n  }\n}\nclass StorageBufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, typeClass = Float32Array) {\n    if (ArrayBuffer.isView(array) === false) array = new typeClass(array * itemSize);\n    super(array, itemSize);\n    this.isStorageBufferAttribute = true;\n  }\n}\nclass StorageArrayElementNode extends ArrayElementNode {\n  static get type() {\n    return 'StorageArrayElementNode';\n  }\n  constructor(storageBufferNode, indexNode) {\n    super(storageBufferNode, indexNode);\n    this.isStorageArrayElementNode = true;\n  }\n  set storageBufferNode(value) {\n    this.node = value;\n  }\n  get storageBufferNode() {\n    return this.node;\n  }\n  setup(builder) {\n    if (builder.isAvailable('storageBuffer') === false) {\n      if (this.node.isPBO === true) {\n        builder.setupPBO(this.node);\n      }\n    }\n    return super.setup(builder);\n  }\n  generate(builder, output) {\n    let snippet;\n    const isAssignContext = builder.context.assign;\n\n    //\n\n    if (builder.isAvailable('storageBuffer') === false) {\n      if (this.node.isPBO === true && isAssignContext !== true && (this.node.value.isInstancedBufferAttribute || builder.shaderStage !== 'compute')) {\n        snippet = builder.generatePBO(this);\n      } else {\n        snippet = this.node.build(builder);\n      }\n    } else {\n      snippet = super.generate(builder);\n    }\n    if (isAssignContext !== true) {\n      const type = this.getNodeType(builder);\n      snippet = builder.format(snippet, type, output);\n    }\n    return snippet;\n  }\n}\nconst storageElement = /*@__PURE__*/nodeProxy(StorageArrayElementNode);\nclass StorageBufferNode extends BufferNode {\n  static get type() {\n    return 'StorageBufferNode';\n  }\n  constructor(value, bufferType = null, bufferCount = 0) {\n    if (bufferType === null && (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute)) {\n      bufferType = getTypeFromLength(value.itemSize);\n      bufferCount = value.count;\n    }\n    super(value, bufferType, bufferCount);\n    this.isStorageBufferNode = true;\n    this.access = NodeAccess.READ_WRITE;\n    this.isAtomic = false;\n    this.isPBO = false;\n    this.bufferCount = bufferCount;\n    this._attribute = null;\n    this._varying = null;\n    this.global = true;\n    if (value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true) {\n      // TOOD: Improve it, possibly adding a new property to the BufferAttribute to identify it as a storage buffer read-only attribute in Renderer\n\n      if (value.isInstancedBufferAttribute) value.isStorageInstancedBufferAttribute = true;else value.isStorageBufferAttribute = true;\n    }\n  }\n  getHash(builder) {\n    if (this.bufferCount === 0) {\n      let bufferData = builder.globalCache.getData(this.value);\n      if (bufferData === undefined) {\n        bufferData = {\n          node: this\n        };\n        builder.globalCache.setData(this.value, bufferData);\n      }\n      return bufferData.node.uuid;\n    }\n    return this.uuid;\n  }\n  getInputType(/*builder*/\n  ) {\n    return this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer';\n  }\n  element(indexNode) {\n    return storageElement(this, indexNode);\n  }\n  setPBO(value) {\n    this.isPBO = value;\n    return this;\n  }\n  getPBO() {\n    return this.isPBO;\n  }\n  setAccess(value) {\n    this.access = value;\n    return this;\n  }\n  toReadOnly() {\n    return this.setAccess(NodeAccess.READ_ONLY);\n  }\n  setAtomic(value) {\n    this.isAtomic = value;\n    return this;\n  }\n  toAtomic() {\n    return this.setAtomic(true);\n  }\n  getAttributeData() {\n    if (this._attribute === null) {\n      this._attribute = bufferAttribute(this.value);\n      this._varying = varying(this._attribute);\n    }\n    return {\n      attribute: this._attribute,\n      varying: this._varying\n    };\n  }\n  getNodeType(builder) {\n    if (builder.isAvailable('storageBuffer') || builder.isAvailable('indirectStorageBuffer')) {\n      return super.getNodeType(builder);\n    }\n    const {\n      attribute\n    } = this.getAttributeData();\n    return attribute.getNodeType(builder);\n  }\n  generate(builder) {\n    if (builder.isAvailable('storageBuffer') || builder.isAvailable('indirectStorageBuffer')) {\n      return super.generate(builder);\n    }\n    const {\n      attribute,\n      varying\n    } = this.getAttributeData();\n    const output = varying.build(builder);\n    builder.registerTransform(output, attribute);\n    return output;\n  }\n}\nconst storage = (value, type, count) => nodeObject(new StorageBufferNode(value, type, count));\nconst storageObject = (value, type, count) => {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"storageObject()\" is deprecated. Use \"storage().setPBO( true )\" instead.');\n  return storage(value, type, count).setPBO(true);\n};\nconst attributeArray = (count, type = 'float') => {\n  const itemSize = getLengthFromType(type);\n  const buffer = new StorageBufferAttribute(count, itemSize);\n  const node = storage(buffer, type, count);\n  return node;\n};\nconst instancedArray = (count, type = 'float') => {\n  const itemSize = getLengthFromType(type);\n  const buffer = new StorageInstancedBufferAttribute(count, itemSize);\n  const node = storage(buffer, type, count);\n  return node;\n};\nclass VertexColorNode extends AttributeNode {\n  static get type() {\n    return 'VertexColorNode';\n  }\n  constructor(index = 0) {\n    super(null, 'vec4');\n    this.isVertexColorNode = true;\n    this.index = index;\n  }\n  getAttributeName(/*builder*/\n  ) {\n    const index = this.index;\n    return 'color' + (index > 0 ? index : '');\n  }\n  generate(builder) {\n    const attributeName = this.getAttributeName(builder);\n    const geometryAttribute = builder.hasGeometryAttribute(attributeName);\n    let result;\n    if (geometryAttribute === true) {\n      result = super.generate(builder);\n    } else {\n      // Vertex color fallback should be white\n      result = builder.generateConst(this.nodeType, new Vector4(1, 1, 1, 1));\n    }\n    return result;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.index = this.index;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.index = data.index;\n  }\n}\nconst vertexColor = (...params) => nodeObject(new VertexColorNode(...params));\nclass PointUVNode extends Node {\n  static get type() {\n    return 'PointUVNode';\n  }\n  constructor() {\n    super('vec2');\n    this.isPointUVNode = true;\n  }\n  generate(/*builder*/\n  ) {\n    return 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';\n  }\n}\nconst pointUV = /*@__PURE__*/nodeImmutable(PointUVNode);\nconst _e1 = /*@__PURE__*/new Euler();\nconst _m1 = /*@__PURE__*/new Matrix4();\nclass SceneNode extends Node {\n  static get type() {\n    return 'SceneNode';\n  }\n  constructor(scope = SceneNode.BACKGROUND_BLURRINESS, scene = null) {\n    super();\n    this.scope = scope;\n    this.scene = scene;\n  }\n  setup(builder) {\n    const scope = this.scope;\n    const scene = this.scene !== null ? this.scene : builder.scene;\n    let output;\n    if (scope === SceneNode.BACKGROUND_BLURRINESS) {\n      output = reference('backgroundBlurriness', 'float', scene);\n    } else if (scope === SceneNode.BACKGROUND_INTENSITY) {\n      output = reference('backgroundIntensity', 'float', scene);\n    } else if (scope === SceneNode.BACKGROUND_ROTATION) {\n      output = uniform('mat4').label('backgroundRotation').setGroup(renderGroup).onRenderUpdate(() => {\n        const background = scene.background;\n        if (background !== null && background.isTexture && background.mapping !== UVMapping) {\n          _e1.copy(scene.backgroundRotation);\n\n          // accommodate left-handed frame\n          _e1.x *= -1;\n          _e1.y *= -1;\n          _e1.z *= -1;\n          _m1.makeRotationFromEuler(_e1);\n        } else {\n          _m1.identity();\n        }\n        return _m1;\n      });\n    } else {\n      console.error('THREE.SceneNode: Unknown scope:', scope);\n    }\n    return output;\n  }\n}\nSceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';\nSceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';\nSceneNode.BACKGROUND_ROTATION = 'backgroundRotation';\nconst backgroundBlurriness = /*@__PURE__*/nodeImmutable(SceneNode, SceneNode.BACKGROUND_BLURRINESS);\nconst backgroundIntensity = /*@__PURE__*/nodeImmutable(SceneNode, SceneNode.BACKGROUND_INTENSITY);\nconst backgroundRotation = /*@__PURE__*/nodeImmutable(SceneNode, SceneNode.BACKGROUND_ROTATION);\nclass StorageTextureNode extends TextureNode {\n  static get type() {\n    return 'StorageTextureNode';\n  }\n  constructor(value, uvNode, storeNode = null) {\n    super(value, uvNode);\n    this.storeNode = storeNode;\n    this.isStorageTextureNode = true;\n    this.access = NodeAccess.WRITE_ONLY;\n  }\n  getInputType(/*builder*/\n  ) {\n    return 'storageTexture';\n  }\n  setup(builder) {\n    super.setup(builder);\n    const properties = builder.getNodeProperties(this);\n    properties.storeNode = this.storeNode;\n  }\n  setAccess(value) {\n    this.access = value;\n    return this;\n  }\n  generate(builder, output) {\n    let snippet;\n    if (this.storeNode !== null) {\n      snippet = this.generateStore(builder);\n    } else {\n      snippet = super.generate(builder, output);\n    }\n    return snippet;\n  }\n  toReadWrite() {\n    return this.setAccess(NodeAccess.READ_WRITE);\n  }\n  toReadOnly() {\n    return this.setAccess(NodeAccess.READ_ONLY);\n  }\n  toWriteOnly() {\n    return this.setAccess(NodeAccess.WRITE_ONLY);\n  }\n  generateStore(builder) {\n    const properties = builder.getNodeProperties(this);\n    const {\n      uvNode,\n      storeNode\n    } = properties;\n    const textureProperty = super.generate(builder, 'property');\n    const uvSnippet = uvNode.build(builder, 'uvec2');\n    const storeSnippet = storeNode.build(builder, 'vec4');\n    const snippet = builder.generateTextureStore(builder, textureProperty, uvSnippet, storeSnippet);\n    builder.addLineFlowCode(snippet, this);\n  }\n}\nconst storageTexture = /*@__PURE__*/nodeProxy(StorageTextureNode);\nconst textureStore = (value, uvNode, storeNode) => {\n  const node = storageTexture(value, uvNode, storeNode);\n  if (storeNode !== null) node.append();\n  return node;\n};\nclass UserDataNode extends ReferenceNode {\n  static get type() {\n    return 'UserDataNode';\n  }\n  constructor(property, inputType, userData = null) {\n    super(property, inputType, userData);\n    this.userData = userData;\n  }\n  updateReference(state) {\n    this.reference = this.userData !== null ? this.userData : state.object.userData;\n    return this.reference;\n  }\n}\nconst userData = (name, inputType, userData) => nodeObject(new UserDataNode(name, inputType, userData));\nconst _objectData = new WeakMap();\nclass VelocityNode extends TempNode {\n  static get type() {\n    return 'VelocityNode';\n  }\n  constructor() {\n    super('vec2');\n    this.projectionMatrix = null;\n    this.updateType = NodeUpdateType.OBJECT;\n    this.updateAfterType = NodeUpdateType.OBJECT;\n    this.previousModelWorldMatrix = uniform(new Matrix4());\n    this.previousProjectionMatrix = uniform(new Matrix4()).setGroup(renderGroup);\n    this.previousCameraViewMatrix = uniform(new Matrix4());\n  }\n  setProjectionMatrix(projectionMatrix) {\n    this.projectionMatrix = projectionMatrix;\n  }\n  update({\n    frameId,\n    camera,\n    object\n  }) {\n    const previousModelMatrix = getPreviousMatrix(object);\n    this.previousModelWorldMatrix.value.copy(previousModelMatrix);\n\n    //\n\n    const cameraData = getData(camera);\n    if (cameraData.frameId !== frameId) {\n      cameraData.frameId = frameId;\n      if (cameraData.previousProjectionMatrix === undefined) {\n        cameraData.previousProjectionMatrix = new Matrix4();\n        cameraData.previousCameraViewMatrix = new Matrix4();\n        cameraData.currentProjectionMatrix = new Matrix4();\n        cameraData.currentCameraViewMatrix = new Matrix4();\n        cameraData.previousProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);\n        cameraData.previousCameraViewMatrix.copy(camera.matrixWorldInverse);\n      } else {\n        cameraData.previousProjectionMatrix.copy(cameraData.currentProjectionMatrix);\n        cameraData.previousCameraViewMatrix.copy(cameraData.currentCameraViewMatrix);\n      }\n      cameraData.currentProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);\n      cameraData.currentCameraViewMatrix.copy(camera.matrixWorldInverse);\n      this.previousProjectionMatrix.value.copy(cameraData.previousProjectionMatrix);\n      this.previousCameraViewMatrix.value.copy(cameraData.previousCameraViewMatrix);\n    }\n  }\n  updateAfter({\n    object\n  }) {\n    getPreviousMatrix(object).copy(object.matrixWorld);\n  }\n  setup(/*builder*/\n  ) {\n    const projectionMatrix = this.projectionMatrix === null ? cameraProjectionMatrix : uniform(this.projectionMatrix);\n    const previousModelViewMatrix = this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix);\n    const clipPositionCurrent = projectionMatrix.mul(modelViewMatrix).mul(positionLocal);\n    const clipPositionPrevious = this.previousProjectionMatrix.mul(previousModelViewMatrix).mul(positionPrevious);\n    const ndcPositionCurrent = clipPositionCurrent.xy.div(clipPositionCurrent.w);\n    const ndcPositionPrevious = clipPositionPrevious.xy.div(clipPositionPrevious.w);\n    const velocity = sub(ndcPositionCurrent, ndcPositionPrevious);\n    return velocity;\n  }\n}\nfunction getData(object) {\n  let objectData = _objectData.get(object);\n  if (objectData === undefined) {\n    objectData = {};\n    _objectData.set(object, objectData);\n  }\n  return objectData;\n}\nfunction getPreviousMatrix(object, index = 0) {\n  const objectData = getData(object);\n  let matrix = objectData[index];\n  if (matrix === undefined) {\n    objectData[index] = matrix = new Matrix4();\n  }\n  return matrix;\n}\nconst velocity = /*@__PURE__*/nodeImmutable(VelocityNode);\nconst blendBurn = /*@__PURE__*/Fn(([base, blend]) => {\n  return min$1(1.0, base.oneMinus().div(blend)).oneMinus();\n}).setLayout({\n  name: 'blendBurn',\n  type: 'vec3',\n  inputs: [{\n    name: 'base',\n    type: 'vec3'\n  }, {\n    name: 'blend',\n    type: 'vec3'\n  }]\n});\nconst blendDodge = /*@__PURE__*/Fn(([base, blend]) => {\n  return min$1(base.div(blend.oneMinus()), 1.0);\n}).setLayout({\n  name: 'blendDodge',\n  type: 'vec3',\n  inputs: [{\n    name: 'base',\n    type: 'vec3'\n  }, {\n    name: 'blend',\n    type: 'vec3'\n  }]\n});\nconst blendScreen = /*@__PURE__*/Fn(([base, blend]) => {\n  return base.oneMinus().mul(blend.oneMinus()).oneMinus();\n}).setLayout({\n  name: 'blendScreen',\n  type: 'vec3',\n  inputs: [{\n    name: 'base',\n    type: 'vec3'\n  }, {\n    name: 'blend',\n    type: 'vec3'\n  }]\n});\nconst blendOverlay = /*@__PURE__*/Fn(([base, blend]) => {\n  return mix(base.mul(2.0).mul(blend), base.oneMinus().mul(2.0).mul(blend.oneMinus()).oneMinus(), step(0.5, base));\n}).setLayout({\n  name: 'blendOverlay',\n  type: 'vec3',\n  inputs: [{\n    name: 'base',\n    type: 'vec3'\n  }, {\n    name: 'blend',\n    type: 'vec3'\n  }]\n});\nconst blendColor = /*@__PURE__*/Fn(([base, blend]) => {\n  const outAlpha = blend.a.add(base.a.mul(blend.a.oneMinus()));\n  return vec4(blend.rgb.mul(blend.a).add(base.rgb.mul(base.a).mul(blend.a.oneMinus())).div(outAlpha), outAlpha);\n}).setLayout({\n  name: 'blendColor',\n  type: 'vec4',\n  inputs: [{\n    name: 'base',\n    type: 'vec4'\n  }, {\n    name: 'blend',\n    type: 'vec4'\n  }]\n});\n\n// deprecated\n\nconst burn = (...params) => {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"burn\" has been renamed. Use \"blendBurn\" instead.');\n  return blendBurn(params);\n};\nconst dodge = (...params) => {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"dodge\" has been renamed. Use \"blendDodge\" instead.');\n  return blendDodge(params);\n};\nconst screen = (...params) => {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"screen\" has been renamed. Use \"blendScreen\" instead.');\n  return blendScreen(params);\n};\nconst overlay = (...params) => {\n  // @deprecated, r171\n\n  console.warn('THREE.TSL: \"overlay\" has been renamed. Use \"blendOverlay\" instead.');\n  return blendOverlay(params);\n};\nconst grayscale = /*@__PURE__*/Fn(([color]) => {\n  return luminance(color.rgb);\n});\nconst saturation = /*@__PURE__*/Fn(([color, adjustment = float(1)]) => {\n  return adjustment.mix(luminance(color.rgb), color.rgb);\n});\nconst vibrance = /*@__PURE__*/Fn(([color, adjustment = float(1)]) => {\n  const average = add(color.r, color.g, color.b).div(3.0);\n  const mx = color.r.max(color.g.max(color.b));\n  const amt = mx.sub(average).mul(adjustment).mul(-3.0);\n  return mix(color.rgb, mx, amt);\n});\nconst hue = /*@__PURE__*/Fn(([color, adjustment = float(1)]) => {\n  const k = vec3(0.57735, 0.57735, 0.57735);\n  const cosAngle = adjustment.cos();\n  return vec3(color.rgb.mul(cosAngle).add(k.cross(color.rgb).mul(adjustment.sin()).add(k.mul(dot(k, color.rgb).mul(cosAngle.oneMinus())))));\n});\nconst luminance = (color, luminanceCoefficients = vec3(ColorManagement.getLuminanceCoefficients(new Vector3()))) => dot(color, luminanceCoefficients);\nconst threshold = (color, threshold) => mix(vec3(0.0), color, luminance(color).sub(threshold).max(0));\n\n/**\n * Color Decision List (CDL) v1.2\n *\n * Compact representation of color grading information, defined by slope, offset, power, and\n * saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,\n * or AgX Log), and will return output in the same space. Output may require clamping >=0.\n *\n * @param {vec4} color Input (-Infinity < input < +Infinity)\n * @param {number | vec3} slope Slope (0 ≤ slope < +Infinity)\n * @param {number | vec3} offset Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1)\n * @param {number | vec3} power Power (0 < power < +Infinity)\n * @param {number} saturation Saturation (0 ≤ saturation < +Infinity; typically 0 ≤ saturation < 4)\n * @param {vec3} luminanceCoefficients Luminance coefficients for saturation term, typically Rec. 709\n * @return Output, -Infinity < output < +Infinity\n *\n * References:\n * - ASC CDL v1.2\n * - https://blender.stackexchange.com/a/55239/43930\n * - https://docs.acescentral.com/specifications/acescc/\n */\nconst cdl = /*@__PURE__*/Fn(([color, slope = vec3(1), offset = vec3(0), power = vec3(1), saturation = float(1),\n// ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.\nluminanceCoefficients = vec3(ColorManagement.getLuminanceCoefficients(new Vector3(), LinearSRGBColorSpace))]) => {\n  // NOTE: The ASC CDL v1.2 defines a [0, 1] clamp on the slope+offset term, and another on the\n  // saturation term. Per the ACEScc specification and Filament, limits may be omitted to support\n  // values outside [0, 1], requiring a workaround for negative values in the power expression.\n\n  const luma = color.rgb.dot(vec3(luminanceCoefficients));\n  const v = max$1(color.rgb.mul(slope).add(offset), 0.0).toVar();\n  const pv = v.pow(power).toVar();\n  If(v.r.greaterThan(0.0), () => {\n    v.r.assign(pv.r);\n  }); // eslint-disable-line\n  If(v.g.greaterThan(0.0), () => {\n    v.g.assign(pv.g);\n  }); // eslint-disable-line\n  If(v.b.greaterThan(0.0), () => {\n    v.b.assign(pv.b);\n  }); // eslint-disable-line\n\n  v.assign(luma.add(v.sub(luma).mul(saturation)));\n  return vec4(v.rgb, color.a);\n});\nclass PosterizeNode extends TempNode {\n  static get type() {\n    return 'PosterizeNode';\n  }\n  constructor(sourceNode, stepsNode) {\n    super();\n    this.sourceNode = sourceNode;\n    this.stepsNode = stepsNode;\n  }\n  setup() {\n    const {\n      sourceNode,\n      stepsNode\n    } = this;\n    return sourceNode.mul(stepsNode).floor().div(stepsNode);\n  }\n}\nconst posterize = /*@__PURE__*/nodeProxy(PosterizeNode);\nconst _size = /*@__PURE__*/new Vector2();\nclass PassTextureNode extends TextureNode {\n  static get type() {\n    return 'PassTextureNode';\n  }\n  constructor(passNode, texture) {\n    super(texture);\n    this.passNode = passNode;\n    this.setUpdateMatrix(false);\n  }\n  setup(builder) {\n    if (builder.object.isQuadMesh) this.passNode.build(builder);\n    return super.setup(builder);\n  }\n  clone() {\n    return new this.constructor(this.passNode, this.value);\n  }\n}\nclass PassMultipleTextureNode extends PassTextureNode {\n  static get type() {\n    return 'PassMultipleTextureNode';\n  }\n  constructor(passNode, textureName, previousTexture = false) {\n    super(passNode, null);\n    this.textureName = textureName;\n    this.previousTexture = previousTexture;\n  }\n  updateTexture() {\n    this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);\n  }\n  setup(builder) {\n    this.updateTexture();\n    return super.setup(builder);\n  }\n  clone() {\n    return new this.constructor(this.passNode, this.textureName, this.previousTexture);\n  }\n}\nclass PassNode extends TempNode {\n  static get type() {\n    return 'PassNode';\n  }\n  constructor(scope, scene, camera, options = {}) {\n    super('vec4');\n    this.scope = scope;\n    this.scene = scene;\n    this.camera = camera;\n    this.options = options;\n    this._pixelRatio = 1;\n    this._width = 1;\n    this._height = 1;\n    const depthTexture = new DepthTexture();\n    depthTexture.isRenderTargetTexture = true;\n    //depthTexture.type = FloatType;\n    depthTexture.name = 'depth';\n    const renderTarget = new RenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, {\n      type: HalfFloatType,\n      ...options\n    });\n    renderTarget.texture.name = 'output';\n    renderTarget.depthTexture = depthTexture;\n    this.renderTarget = renderTarget;\n    this.updateBeforeType = NodeUpdateType.FRAME;\n    this._textures = {\n      output: renderTarget.texture,\n      depth: depthTexture\n    };\n    this._textureNodes = {};\n    this._linearDepthNodes = {};\n    this._viewZNodes = {};\n    this._previousTextures = {};\n    this._previousTextureNodes = {};\n    this._cameraNear = uniform(0);\n    this._cameraFar = uniform(0);\n    this._mrt = null;\n    this.isPassNode = true;\n  }\n  setMRT(mrt) {\n    this._mrt = mrt;\n    return this;\n  }\n  getMRT() {\n    return this._mrt;\n  }\n  isGlobal() {\n    return true;\n  }\n  getTexture(name) {\n    let texture = this._textures[name];\n    if (texture === undefined) {\n      const refTexture = this.renderTarget.texture;\n      texture = refTexture.clone();\n      texture.isRenderTargetTexture = true;\n      texture.name = name;\n      this._textures[name] = texture;\n      this.renderTarget.textures.push(texture);\n    }\n    return texture;\n  }\n  getPreviousTexture(name) {\n    let texture = this._previousTextures[name];\n    if (texture === undefined) {\n      texture = this.getTexture(name).clone();\n      texture.isRenderTargetTexture = true;\n      this._previousTextures[name] = texture;\n    }\n    return texture;\n  }\n  toggleTexture(name) {\n    const prevTexture = this._previousTextures[name];\n    if (prevTexture !== undefined) {\n      const texture = this._textures[name];\n      const index = this.renderTarget.textures.indexOf(texture);\n      this.renderTarget.textures[index] = prevTexture;\n      this._textures[name] = prevTexture;\n      this._previousTextures[name] = texture;\n      this._textureNodes[name].updateTexture();\n      this._previousTextureNodes[name].updateTexture();\n    }\n  }\n  getTextureNode(name = 'output') {\n    let textureNode = this._textureNodes[name];\n    if (textureNode === undefined) {\n      textureNode = nodeObject(new PassMultipleTextureNode(this, name));\n      textureNode.updateTexture();\n      this._textureNodes[name] = textureNode;\n    }\n    return textureNode;\n  }\n  getPreviousTextureNode(name = 'output') {\n    let textureNode = this._previousTextureNodes[name];\n    if (textureNode === undefined) {\n      if (this._textureNodes[name] === undefined) this.getTextureNode(name);\n      textureNode = nodeObject(new PassMultipleTextureNode(this, name, true));\n      textureNode.updateTexture();\n      this._previousTextureNodes[name] = textureNode;\n    }\n    return textureNode;\n  }\n  getViewZNode(name = 'depth') {\n    let viewZNode = this._viewZNodes[name];\n    if (viewZNode === undefined) {\n      const cameraNear = this._cameraNear;\n      const cameraFar = this._cameraFar;\n      this._viewZNodes[name] = viewZNode = perspectiveDepthToViewZ(this.getTextureNode(name), cameraNear, cameraFar);\n    }\n    return viewZNode;\n  }\n  getLinearDepthNode(name = 'depth') {\n    let linearDepthNode = this._linearDepthNodes[name];\n    if (linearDepthNode === undefined) {\n      const cameraNear = this._cameraNear;\n      const cameraFar = this._cameraFar;\n      const viewZNode = this.getViewZNode(name);\n\n      // TODO: just if ( builder.camera.isPerspectiveCamera )\n\n      this._linearDepthNodes[name] = linearDepthNode = viewZToOrthographicDepth(viewZNode, cameraNear, cameraFar);\n    }\n    return linearDepthNode;\n  }\n  setup({\n    renderer\n  }) {\n    this.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;\n\n    // Disable MSAA for WebGL backend for now\n    if (renderer.backend.isWebGLBackend === true) {\n      this.renderTarget.samples = 0;\n    }\n    this.renderTarget.depthTexture.isMultisampleRenderTargetTexture = this.renderTarget.samples > 1;\n    return this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();\n  }\n  updateBefore(frame) {\n    const {\n      renderer\n    } = frame;\n    const {\n      scene,\n      camera\n    } = this;\n    this._pixelRatio = renderer.getPixelRatio();\n    const size = renderer.getSize(_size);\n    this.setSize(size.width, size.height);\n    const currentRenderTarget = renderer.getRenderTarget();\n    const currentMRT = renderer.getMRT();\n    this._cameraNear.value = camera.near;\n    this._cameraFar.value = camera.far;\n    for (const name in this._previousTextures) {\n      this.toggleTexture(name);\n    }\n    renderer.setRenderTarget(this.renderTarget);\n    renderer.setMRT(this._mrt);\n    renderer.render(scene, camera);\n    renderer.setRenderTarget(currentRenderTarget);\n    renderer.setMRT(currentMRT);\n  }\n  setSize(width, height) {\n    this._width = width;\n    this._height = height;\n    const effectiveWidth = this._width * this._pixelRatio;\n    const effectiveHeight = this._height * this._pixelRatio;\n    this.renderTarget.setSize(effectiveWidth, effectiveHeight);\n  }\n  setPixelRatio(pixelRatio) {\n    this._pixelRatio = pixelRatio;\n    this.setSize(this._width, this._height);\n  }\n  dispose() {\n    this.renderTarget.dispose();\n  }\n}\nPassNode.COLOR = 'color';\nPassNode.DEPTH = 'depth';\nconst pass = (scene, camera, options) => nodeObject(new PassNode(PassNode.COLOR, scene, camera, options));\nconst passTexture = (pass, texture) => nodeObject(new PassTextureNode(pass, texture));\nconst depthPass = (scene, camera) => nodeObject(new PassNode(PassNode.DEPTH, scene, camera));\nclass ToonOutlinePassNode extends PassNode {\n  static get type() {\n    return 'ToonOutlinePassNode';\n  }\n  constructor(scene, camera, colorNode, thicknessNode, alphaNode) {\n    super(PassNode.COLOR, scene, camera);\n    this.colorNode = colorNode;\n    this.thicknessNode = thicknessNode;\n    this.alphaNode = alphaNode;\n    this._materialCache = new WeakMap();\n  }\n  updateBefore(frame) {\n    const {\n      renderer\n    } = frame;\n    const currentRenderObjectFunction = renderer.getRenderObjectFunction();\n    renderer.setRenderObjectFunction((object, scene, camera, geometry, material, group, lightsNode, clippingContext) => {\n      // only render outline for supported materials\n\n      if (material.isMeshToonMaterial || material.isMeshToonNodeMaterial) {\n        if (material.wireframe === false) {\n          const outlineMaterial = this._getOutlineMaterial(material);\n          renderer.renderObject(object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext);\n        }\n      }\n\n      // default\n\n      renderer.renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext);\n    });\n    super.updateBefore(frame);\n    renderer.setRenderObjectFunction(currentRenderObjectFunction);\n  }\n  _createMaterial() {\n    const material = new NodeMaterial();\n    material.isMeshToonOutlineMaterial = true;\n    material.name = 'Toon_Outline';\n    material.side = BackSide;\n\n    // vertex node\n\n    const outlineNormal = normalLocal.negate();\n    const mvp = cameraProjectionMatrix.mul(modelViewMatrix);\n    const ratio = float(1.0); // TODO: support outline thickness ratio for each vertex\n    const pos = mvp.mul(vec4(positionLocal, 1.0));\n    const pos2 = mvp.mul(vec4(positionLocal.add(outlineNormal), 1.0));\n    const norm = normalize(pos.sub(pos2)); // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\n    material.vertexNode = pos.add(norm.mul(this.thicknessNode).mul(pos.w).mul(ratio));\n\n    // color node\n\n    material.colorNode = vec4(this.colorNode, this.alphaNode);\n    return material;\n  }\n  _getOutlineMaterial(originalMaterial) {\n    let outlineMaterial = this._materialCache.get(originalMaterial);\n    if (outlineMaterial === undefined) {\n      outlineMaterial = this._createMaterial();\n      this._materialCache.set(originalMaterial, outlineMaterial);\n    }\n    return outlineMaterial;\n  }\n}\nconst toonOutlinePass = (scene, camera, color = new Color(0, 0, 0), thickness = 0.003, alpha = 1) => nodeObject(new ToonOutlinePassNode(scene, camera, nodeObject(color), nodeObject(thickness), nodeObject(alpha)));\n\n// exposure only\n\nconst linearToneMapping = /*@__PURE__*/Fn(([color, exposure]) => {\n  return color.mul(exposure).clamp();\n}).setLayout({\n  name: 'linearToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\n\n// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf\n\nconst reinhardToneMapping = /*@__PURE__*/Fn(([color, exposure]) => {\n  color = color.mul(exposure);\n  return color.div(color.add(1.0)).clamp();\n}).setLayout({\n  name: 'reinhardToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n\nconst cineonToneMapping = /*@__PURE__*/Fn(([color, exposure]) => {\n  // filmic operator by Jim Hejl and Richard Burgess-Dawson\n  color = color.mul(exposure);\n  color = color.sub(0.004).max(0.0);\n  const a = color.mul(color.mul(6.2).add(0.5));\n  const b = color.mul(color.mul(6.2).add(1.7)).add(0.06);\n  return a.div(b).pow(2.2);\n}).setLayout({\n  name: 'cineonToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n\nconst RRTAndODTFit = /*@__PURE__*/Fn(([color]) => {\n  const a = color.mul(color.add(0.0245786)).sub(0.000090537);\n  const b = color.mul(color.add(0.4329510).mul(0.983729)).add(0.238081);\n  return a.div(b);\n});\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n\nconst acesFilmicToneMapping = /*@__PURE__*/Fn(([color, exposure]) => {\n  // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n  const ACESInputMat = mat3(0.59719, 0.35458, 0.04823, 0.07600, 0.90834, 0.01566, 0.02840, 0.13383, 0.83777);\n\n  // ODT_SAT => XYZ => D60_2_D65 => sRGB\n  const ACESOutputMat = mat3(1.60475, -0.53108, -0.07367, -0.10208, 1.10813, -0.00605, -0.00327, -0.07276, 1.07602);\n  color = color.mul(exposure).div(0.6);\n  color = ACESInputMat.mul(color);\n\n  // Apply RRT and ODT\n  color = RRTAndODTFit(color);\n  color = ACESOutputMat.mul(color);\n\n  // Clamp to [0, 1]\n  return color.clamp();\n}).setLayout({\n  name: 'acesFilmicToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\nconst LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/mat3(vec3(1.6605, -0.1246, -0.0182), vec3(-0.5876, 1.1329, -0.1006), vec3(-0.0728, -0.0083, 1.1187));\nconst LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/mat3(vec3(0.6274, 0.0691, 0.0164), vec3(0.3293, 0.9195, 0.0880), vec3(0.0433, 0.0113, 0.8956));\nconst agxDefaultContrastApprox = /*@__PURE__*/Fn(([x_immutable]) => {\n  const x = vec3(x_immutable).toVar();\n  const x2 = vec3(x.mul(x)).toVar();\n  const x4 = vec3(x2.mul(x2)).toVar();\n  return float(15.5).mul(x4.mul(x2)).sub(mul(40.14, x4.mul(x))).add(mul(31.96, x4).sub(mul(6.868, x2.mul(x))).add(mul(0.4298, x2).add(mul(0.1191, x).sub(0.00232))));\n});\nconst agxToneMapping = /*@__PURE__*/Fn(([color, exposure]) => {\n  const colortone = vec3(color).toVar();\n  const AgXInsetMatrix = mat3(vec3(0.856627153315983, 0.137318972929847, 0.11189821299995), vec3(0.0951212405381588, 0.761241990602591, 0.0767994186031903), vec3(0.0482516061458583, 0.101439036467562, 0.811302368396859));\n  const AgXOutsetMatrix = mat3(vec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), vec3(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), vec3(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405));\n  const AgxMinEv = float(-12.47393);\n  const AgxMaxEv = float(4.026069);\n  colortone.mulAssign(exposure);\n  colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone));\n  colortone.assign(AgXInsetMatrix.mul(colortone));\n  colortone.assign(max$1(colortone, 1e-10));\n  colortone.assign(log2(colortone));\n  colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv)));\n  colortone.assign(clamp(colortone, 0.0, 1.0));\n  colortone.assign(agxDefaultContrastApprox(colortone));\n  colortone.assign(AgXOutsetMatrix.mul(colortone));\n  colortone.assign(pow(max$1(vec3(0.0), colortone), vec3(2.2)));\n  colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone));\n  colortone.assign(clamp(colortone, 0.0, 1.0));\n  return colortone;\n}).setLayout({\n  name: 'agxToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\n\n// https://modelviewer.dev/examples/tone-mapping\n\nconst neutralToneMapping = /*@__PURE__*/Fn(([color, exposure]) => {\n  const StartCompression = float(0.8 - 0.04);\n  const Desaturation = float(0.15);\n  color = color.mul(exposure);\n  const x = min$1(color.r, min$1(color.g, color.b));\n  const offset = select(x.lessThan(0.08), x.sub(mul(6.25, x.mul(x))), 0.04);\n  color.subAssign(offset);\n  const peak = max$1(color.r, max$1(color.g, color.b));\n  If(peak.lessThan(StartCompression), () => {\n    return color;\n  });\n  const d = sub(1, StartCompression);\n  const newPeak = sub(1, d.mul(d).div(peak.add(d.sub(StartCompression))));\n  color.mulAssign(newPeak.div(peak));\n  const g = sub(1, div(1, Desaturation.mul(peak.sub(newPeak)).add(1)));\n  return mix(color, vec3(newPeak), g);\n}).setLayout({\n  name: 'neutralToneMapping',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }, {\n    name: 'exposure',\n    type: 'float'\n  }]\n});\nclass CodeNode extends Node {\n  static get type() {\n    return 'CodeNode';\n  }\n  constructor(code = '', includes = [], language = '') {\n    super('code');\n    this.isCodeNode = true;\n    this.code = code;\n    this.language = language;\n    this.includes = includes;\n  }\n  isGlobal() {\n    return true;\n  }\n  setIncludes(includes) {\n    this.includes = includes;\n    return this;\n  }\n  getIncludes(/*builder*/\n  ) {\n    return this.includes;\n  }\n  generate(builder) {\n    const includes = this.getIncludes(builder);\n    for (const include of includes) {\n      include.build(builder);\n    }\n    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));\n    nodeCode.code = this.code;\n    return nodeCode.code;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.code = this.code;\n    data.language = this.language;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.code = data.code;\n    this.language = data.language;\n  }\n}\nconst code = /*@__PURE__*/nodeProxy(CodeNode);\nconst js = (src, includes) => code(src, includes, 'js');\nconst wgsl = (src, includes) => code(src, includes, 'wgsl');\nconst glsl = (src, includes) => code(src, includes, 'glsl');\nclass FunctionNode extends CodeNode {\n  static get type() {\n    return 'FunctionNode';\n  }\n  constructor(code = '', includes = [], language = '') {\n    super(code, includes, language);\n  }\n  getNodeType(builder) {\n    return this.getNodeFunction(builder).type;\n  }\n  getInputs(builder) {\n    return this.getNodeFunction(builder).inputs;\n  }\n  getNodeFunction(builder) {\n    const nodeData = builder.getDataFromNode(this);\n    let nodeFunction = nodeData.nodeFunction;\n    if (nodeFunction === undefined) {\n      nodeFunction = builder.parser.parseFunction(this.code);\n      nodeData.nodeFunction = nodeFunction;\n    }\n    return nodeFunction;\n  }\n  generate(builder, output) {\n    super.generate(builder);\n    const nodeFunction = this.getNodeFunction(builder);\n    const name = nodeFunction.name;\n    const type = nodeFunction.type;\n    const nodeCode = builder.getCodeFromNode(this, type);\n    if (name !== '') {\n      // use a custom property name\n\n      nodeCode.name = name;\n    }\n    const propertyName = builder.getPropertyName(nodeCode);\n    const code = this.getNodeFunction(builder).getCode(propertyName);\n    nodeCode.code = code + '\\n';\n    if (output === 'property') {\n      return propertyName;\n    } else {\n      return builder.format(`${propertyName}()`, type, output);\n    }\n  }\n}\nconst nativeFn = (code, includes = [], language = '') => {\n  for (let i = 0; i < includes.length; i++) {\n    const include = includes[i];\n\n    // TSL Function: glslFn, wgslFn\n\n    if (typeof include === 'function') {\n      includes[i] = include.functionNode;\n    }\n  }\n  const functionNode = nodeObject(new FunctionNode(code, includes, language));\n  const fn = (...params) => functionNode.call(...params);\n  fn.functionNode = functionNode;\n  return fn;\n};\nconst glslFn = (code, includes) => nativeFn(code, includes, 'glsl');\nconst wgslFn = (code, includes) => nativeFn(code, includes, 'wgsl');\nclass ScriptableValueNode extends Node {\n  static get type() {\n    return 'ScriptableValueNode';\n  }\n  constructor(value = null) {\n    super();\n    this._value = value;\n    this._cache = null;\n    this.inputType = null;\n    this.outpuType = null;\n    this.events = new EventDispatcher();\n    this.isScriptableValueNode = true;\n  }\n  get isScriptableOutputNode() {\n    return this.outputType !== null;\n  }\n  set value(val) {\n    if (this._value === val) return;\n    if (this._cache && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer) {\n      URL.revokeObjectURL(this._cache);\n      this._cache = null;\n    }\n    this._value = val;\n    this.events.dispatchEvent({\n      type: 'change'\n    });\n    this.refresh();\n  }\n  get value() {\n    return this._value;\n  }\n  refresh() {\n    this.events.dispatchEvent({\n      type: 'refresh'\n    });\n  }\n  getValue() {\n    const value = this.value;\n    if (value && this._cache === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer) {\n      this._cache = URL.createObjectURL(new Blob([value.value]));\n    } else if (value && value.value !== null && value.value !== undefined && ((this.inputType === 'URL' || this.inputType === 'String') && typeof value.value === 'string' || this.inputType === 'Number' && typeof value.value === 'number' || this.inputType === 'Vector2' && value.value.isVector2 || this.inputType === 'Vector3' && value.value.isVector3 || this.inputType === 'Vector4' && value.value.isVector4 || this.inputType === 'Color' && value.value.isColor || this.inputType === 'Matrix3' && value.value.isMatrix3 || this.inputType === 'Matrix4' && value.value.isMatrix4)) {\n      return value.value;\n    }\n    return this._cache || value;\n  }\n  getNodeType(builder) {\n    return this.value && this.value.isNode ? this.value.getNodeType(builder) : 'float';\n  }\n  setup() {\n    return this.value && this.value.isNode ? this.value : float();\n  }\n  serialize(data) {\n    super.serialize(data);\n    if (this.value !== null) {\n      if (this.inputType === 'ArrayBuffer') {\n        data.value = arrayBufferToBase64(this.value);\n      } else {\n        data.value = this.value ? this.value.toJSON(data.meta).uuid : null;\n      }\n    } else {\n      data.value = null;\n    }\n    data.inputType = this.inputType;\n    data.outputType = this.outputType;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    let value = null;\n    if (data.value !== null) {\n      if (data.inputType === 'ArrayBuffer') {\n        value = base64ToArrayBuffer(data.value);\n      } else if (data.inputType === 'Texture') {\n        value = data.meta.textures[data.value];\n      } else {\n        value = data.meta.nodes[data.value] || null;\n      }\n    }\n    this.value = value;\n    this.inputType = data.inputType;\n    this.outputType = data.outputType;\n  }\n}\nconst scriptableValue = /*@__PURE__*/nodeProxy(ScriptableValueNode);\nclass Resources extends Map {\n  get(key, callback = null, ...params) {\n    if (this.has(key)) return super.get(key);\n    if (callback !== null) {\n      const value = callback(...params);\n      this.set(key, value);\n      return value;\n    }\n  }\n}\nclass Parameters {\n  constructor(scriptableNode) {\n    this.scriptableNode = scriptableNode;\n  }\n  get parameters() {\n    return this.scriptableNode.parameters;\n  }\n  get layout() {\n    return this.scriptableNode.getLayout();\n  }\n  getInputLayout(id) {\n    return this.scriptableNode.getInputLayout(id);\n  }\n  get(name) {\n    const param = this.parameters[name];\n    const value = param ? param.getValue() : null;\n    return value;\n  }\n}\nconst ScriptableNodeResources = new Resources();\nclass ScriptableNode extends Node {\n  static get type() {\n    return 'ScriptableNode';\n  }\n  constructor(codeNode = null, parameters = {}) {\n    super();\n    this.codeNode = codeNode;\n    this.parameters = parameters;\n    this._local = new Resources();\n    this._output = scriptableValue();\n    this._outputs = {};\n    this._source = this.source;\n    this._method = null;\n    this._object = null;\n    this._value = null;\n    this._needsOutputUpdate = true;\n    this.onRefresh = this.onRefresh.bind(this);\n    this.isScriptableNode = true;\n  }\n  get source() {\n    return this.codeNode ? this.codeNode.code : '';\n  }\n  setLocal(name, value) {\n    return this._local.set(name, value);\n  }\n  getLocal(name) {\n    return this._local.get(name);\n  }\n  onRefresh() {\n    this._refresh();\n  }\n  getInputLayout(id) {\n    for (const element of this.getLayout()) {\n      if (element.inputType && (element.id === id || element.name === id)) {\n        return element;\n      }\n    }\n  }\n  getOutputLayout(id) {\n    for (const element of this.getLayout()) {\n      if (element.outputType && (element.id === id || element.name === id)) {\n        return element;\n      }\n    }\n  }\n  setOutput(name, value) {\n    const outputs = this._outputs;\n    if (outputs[name] === undefined) {\n      outputs[name] = scriptableValue(value);\n    } else {\n      outputs[name].value = value;\n    }\n    return this;\n  }\n  getOutput(name) {\n    return this._outputs[name];\n  }\n  getParameter(name) {\n    return this.parameters[name];\n  }\n  setParameter(name, value) {\n    const parameters = this.parameters;\n    if (value && value.isScriptableNode) {\n      this.deleteParameter(name);\n      parameters[name] = value;\n      parameters[name].getDefaultOutput().events.addEventListener('refresh', this.onRefresh);\n    } else if (value && value.isScriptableValueNode) {\n      this.deleteParameter(name);\n      parameters[name] = value;\n      parameters[name].events.addEventListener('refresh', this.onRefresh);\n    } else if (parameters[name] === undefined) {\n      parameters[name] = scriptableValue(value);\n      parameters[name].events.addEventListener('refresh', this.onRefresh);\n    } else {\n      parameters[name].value = value;\n    }\n    return this;\n  }\n  getValue() {\n    return this.getDefaultOutput().getValue();\n  }\n  deleteParameter(name) {\n    let valueNode = this.parameters[name];\n    if (valueNode) {\n      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();\n      valueNode.events.removeEventListener('refresh', this.onRefresh);\n    }\n    return this;\n  }\n  clearParameters() {\n    for (const name of Object.keys(this.parameters)) {\n      this.deleteParameter(name);\n    }\n    this.needsUpdate = true;\n    return this;\n  }\n  call(name, ...params) {\n    const object = this.getObject();\n    const method = object[name];\n    if (typeof method === 'function') {\n      return method(...params);\n    }\n  }\n  async callAsync(name, ...params) {\n    const object = this.getObject();\n    const method = object[name];\n    if (typeof method === 'function') {\n      return method.constructor.name === 'AsyncFunction' ? await method(...params) : method(...params);\n    }\n  }\n  getNodeType(builder) {\n    return this.getDefaultOutputNode().getNodeType(builder);\n  }\n  refresh(output = null) {\n    if (output !== null) {\n      this.getOutput(output).refresh();\n    } else {\n      this._refresh();\n    }\n  }\n  getObject() {\n    if (this.needsUpdate) this.dispose();\n    if (this._object !== null) return this._object;\n\n    //\n\n    const refresh = () => this.refresh();\n    const setOutput = (id, value) => this.setOutput(id, value);\n    const parameters = new Parameters(this);\n    const THREE = ScriptableNodeResources.get('THREE');\n    const TSL = ScriptableNodeResources.get('TSL');\n    const method = this.getMethod(this.codeNode);\n    const params = [parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE, TSL];\n    this._object = method(...params);\n    const layout = this._object.layout;\n    if (layout) {\n      if (layout.cache === false) {\n        this._local.clear();\n      }\n\n      // default output\n      this._output.outputType = layout.outputType || null;\n      if (Array.isArray(layout.elements)) {\n        for (const element of layout.elements) {\n          const id = element.id || element.name;\n          if (element.inputType) {\n            if (this.getParameter(id) === undefined) this.setParameter(id, null);\n            this.getParameter(id).inputType = element.inputType;\n          }\n          if (element.outputType) {\n            if (this.getOutput(id) === undefined) this.setOutput(id, null);\n            this.getOutput(id).outputType = element.outputType;\n          }\n        }\n      }\n    }\n    return this._object;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    for (const name in this.parameters) {\n      let valueNode = this.parameters[name];\n      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();\n      valueNode.events.addEventListener('refresh', this.onRefresh);\n    }\n  }\n  getLayout() {\n    return this.getObject().layout;\n  }\n  getDefaultOutputNode() {\n    const output = this.getDefaultOutput().value;\n    if (output && output.isNode) {\n      return output;\n    }\n    return float();\n  }\n  getDefaultOutput() {\n    return this._exec()._output;\n  }\n  getMethod() {\n    if (this.needsUpdate) this.dispose();\n    if (this._method !== null) return this._method;\n\n    //\n\n    const parametersProps = ['parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL'];\n    const interfaceProps = ['layout', 'init', 'main', 'dispose'];\n    const properties = interfaceProps.join(', ');\n    const declarations = 'var ' + properties + '; var output = {};\\n';\n    const returns = '\\nreturn { ...output, ' + properties + ' };';\n    const code = declarations + this.codeNode.code + returns;\n\n    //\n\n    this._method = new Function(...parametersProps, code);\n    return this._method;\n  }\n  dispose() {\n    if (this._method === null) return;\n    if (this._object && typeof this._object.dispose === 'function') {\n      this._object.dispose();\n    }\n    this._method = null;\n    this._object = null;\n    this._source = null;\n    this._value = null;\n    this._needsOutputUpdate = true;\n    this._output.value = null;\n    this._outputs = {};\n  }\n  setup() {\n    return this.getDefaultOutputNode();\n  }\n  getCacheKey(force) {\n    const values = [hashString(this.source), this.getDefaultOutputNode().getCacheKey(force)];\n    for (const param in this.parameters) {\n      values.push(this.parameters[param].getCacheKey(force));\n    }\n    return hashArray(values);\n  }\n  set needsUpdate(value) {\n    if (value === true) this.dispose();\n  }\n  get needsUpdate() {\n    return this.source !== this._source;\n  }\n  _exec() {\n    if (this.codeNode === null) return this;\n    if (this._needsOutputUpdate === true) {\n      this._value = this.call('main');\n      this._needsOutputUpdate = false;\n    }\n    this._output.value = this._value;\n    return this;\n  }\n  _refresh() {\n    this.needsUpdate = true;\n    this._exec();\n    this._output.refresh();\n  }\n}\nconst scriptable = /*@__PURE__*/nodeProxy(ScriptableNode);\nclass FogNode extends Node {\n  static get type() {\n    return 'FogNode';\n  }\n  constructor(colorNode, factorNode) {\n    super('float');\n    this.isFogNode = true;\n    this.colorNode = colorNode;\n    this.factorNode = factorNode;\n  }\n  getViewZNode(builder) {\n    let viewZ;\n    const getViewZ = builder.context.getViewZ;\n    if (getViewZ !== undefined) {\n      viewZ = getViewZ(this);\n    }\n    return (viewZ || positionView.z).negate();\n  }\n  setup() {\n    return this.factorNode;\n  }\n}\nconst fog = /*@__PURE__*/nodeProxy(FogNode);\nclass FogRangeNode extends FogNode {\n  static get type() {\n    return 'FogRangeNode';\n  }\n  constructor(colorNode, nearNode, farNode) {\n    super(colorNode);\n    this.isFogRangeNode = true;\n    this.nearNode = nearNode;\n    this.farNode = farNode;\n  }\n  setup(builder) {\n    const viewZ = this.getViewZNode(builder);\n    return smoothstep(this.nearNode, this.farNode, viewZ);\n  }\n}\nconst rangeFog = /*@__PURE__*/nodeProxy(FogRangeNode);\nclass FogExp2Node extends FogNode {\n  static get type() {\n    return 'FogExp2Node';\n  }\n  constructor(colorNode, densityNode) {\n    super(colorNode);\n    this.isFogExp2Node = true;\n    this.densityNode = densityNode;\n  }\n  setup(builder) {\n    const viewZ = this.getViewZNode(builder);\n    const density = this.densityNode;\n    return density.mul(density, viewZ, viewZ).negate().exp().oneMinus();\n  }\n}\nconst densityFog = /*@__PURE__*/nodeProxy(FogExp2Node);\nlet min = null;\nlet max = null;\nclass RangeNode extends Node {\n  static get type() {\n    return 'RangeNode';\n  }\n  constructor(minNode = float(), maxNode = float()) {\n    super();\n    this.minNode = minNode;\n    this.maxNode = maxNode;\n  }\n  getVectorLength(builder) {\n    const minLength = builder.getTypeLength(getValueType(this.minNode.value));\n    const maxLength = builder.getTypeLength(getValueType(this.maxNode.value));\n    return minLength > maxLength ? minLength : maxLength;\n  }\n  getNodeType(builder) {\n    return builder.object.count > 1 ? builder.getTypeFromLength(this.getVectorLength(builder)) : 'float';\n  }\n  setup(builder) {\n    const object = builder.object;\n    let output = null;\n    if (object.count > 1) {\n      const minValue = this.minNode.value;\n      const maxValue = this.maxNode.value;\n      const minLength = builder.getTypeLength(getValueType(minValue));\n      const maxLength = builder.getTypeLength(getValueType(maxValue));\n      min = min || new Vector4();\n      max = max || new Vector4();\n      min.setScalar(0);\n      max.setScalar(0);\n      if (minLength === 1) min.setScalar(minValue);else if (minValue.isColor) min.set(minValue.r, minValue.g, minValue.b);else min.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);\n      if (maxLength === 1) max.setScalar(maxValue);else if (maxValue.isColor) max.set(maxValue.r, maxValue.g, maxValue.b);else max.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);\n      const stride = 4;\n      const length = stride * object.count;\n      const array = new Float32Array(length);\n      for (let i = 0; i < length; i++) {\n        const index = i % stride;\n        const minElementValue = min.getComponent(index);\n        const maxElementValue = max.getComponent(index);\n        array[i] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());\n      }\n      const nodeType = this.getNodeType(builder);\n      if (object.count <= 4096) {\n        output = buffer(array, 'vec4', object.count).element(instanceIndex).convert(nodeType);\n      } else {\n        // TODO: Improve anonymous buffer attribute creation removing this part\n        const bufferAttribute = new InstancedBufferAttribute(array, 4);\n        builder.geometry.setAttribute('__range' + this.id, bufferAttribute);\n        output = instancedBufferAttribute(bufferAttribute).convert(nodeType);\n      }\n    } else {\n      output = float(0);\n    }\n    return output;\n  }\n}\nconst range = /*@__PURE__*/nodeProxy(RangeNode);\nclass ComputeBuiltinNode extends Node {\n  static get type() {\n    return 'ComputeBuiltinNode';\n  }\n  constructor(builtinName, nodeType) {\n    super(nodeType);\n    this._builtinName = builtinName;\n  }\n  getHash(builder) {\n    return this.getBuiltinName(builder);\n  }\n  getNodeType(/*builder*/\n  ) {\n    return this.nodeType;\n  }\n  setBuiltinName(builtinName) {\n    this._builtinName = builtinName;\n    return this;\n  }\n  getBuiltinName(/*builder*/\n  ) {\n    return this._builtinName;\n  }\n  hasBuiltin(builder) {\n    builder.hasBuiltin(this._builtinName);\n  }\n  generate(builder, output) {\n    const builtinName = this.getBuiltinName(builder);\n    const nodeType = this.getNodeType(builder);\n    if (builder.shaderStage === 'compute') {\n      return builder.format(builtinName, nodeType, output);\n    } else {\n      console.warn(`ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage`);\n      return builder.generateConst(nodeType);\n    }\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.global = this.global;\n    data._builtinName = this._builtinName;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.global = data.global;\n    this._builtinName = data._builtinName;\n  }\n}\nconst computeBuiltin = (name, nodeType) => nodeObject(new ComputeBuiltinNode(name, nodeType));\nconst numWorkgroups = /*@__PURE__*/computeBuiltin('numWorkgroups', 'uvec3');\nconst workgroupId = /*@__PURE__*/computeBuiltin('workgroupId', 'uvec3');\nconst localId = /*@__PURE__*/computeBuiltin('localId', 'uvec3');\nconst subgroupSize = /*@__PURE__*/computeBuiltin('subgroupSize', 'uint');\nclass BarrierNode extends Node {\n  constructor(scope) {\n    super();\n    this.scope = scope;\n  }\n  generate(builder) {\n    const {\n      scope\n    } = this;\n    const {\n      renderer\n    } = builder;\n    if (renderer.backend.isWebGLBackend === true) {\n      builder.addFlowCode(`\\t// ${scope}Barrier \\n`);\n    } else {\n      builder.addLineFlowCode(`${scope}Barrier()`, this);\n    }\n  }\n}\nconst barrier = nodeProxy(BarrierNode);\nconst workgroupBarrier = () => barrier('workgroup').append();\nconst storageBarrier = () => barrier('storage').append();\nconst textureBarrier = () => barrier('texture').append();\nclass WorkgroupInfoElementNode extends ArrayElementNode {\n  constructor(workgroupInfoNode, indexNode) {\n    super(workgroupInfoNode, indexNode);\n    this.isWorkgroupInfoElementNode = true;\n  }\n  generate(builder, output) {\n    let snippet;\n    const isAssignContext = builder.context.assign;\n    snippet = super.generate(builder);\n    if (isAssignContext !== true) {\n      const type = this.getNodeType(builder);\n      snippet = builder.format(snippet, type, output);\n    }\n\n    // TODO: Possibly activate clip distance index on index access rather than from clipping context\n\n    return snippet;\n  }\n}\nclass WorkgroupInfoNode extends Node {\n  constructor(scope, bufferType, bufferCount = 0) {\n    super(bufferType);\n    this.bufferType = bufferType;\n    this.bufferCount = bufferCount;\n    this.isWorkgroupInfoNode = true;\n    this.scope = scope;\n  }\n  label(name) {\n    this.name = name;\n    return this;\n  }\n  getHash() {\n    return this.uuid;\n  }\n  setScope(scope) {\n    this.scope = scope;\n    return this;\n  }\n  getInputType(/*builder*/\n  ) {\n    return `${this.scope}Array`;\n  }\n  element(indexNode) {\n    return nodeObject(new WorkgroupInfoElementNode(this, indexNode));\n  }\n  generate(builder) {\n    return builder.getScopedArray(this.name || `${this.scope}Array_${this.id}`, this.scope.toLowerCase(), this.bufferType, this.bufferCount);\n  }\n}\nconst workgroupArray = (type, count) => nodeObject(new WorkgroupInfoNode('Workgroup', type, count));\nclass AtomicFunctionNode extends TempNode {\n  static get type() {\n    return 'AtomicFunctionNode';\n  }\n  constructor(method, pointerNode, valueNode, storeNode = null) {\n    super('uint');\n    this.method = method;\n    this.pointerNode = pointerNode;\n    this.valueNode = valueNode;\n    this.storeNode = storeNode;\n  }\n  getInputType(builder) {\n    return this.pointerNode.getNodeType(builder);\n  }\n  getNodeType(builder) {\n    return this.getInputType(builder);\n  }\n  generate(builder) {\n    const method = this.method;\n    const type = this.getNodeType(builder);\n    const inputType = this.getInputType(builder);\n    const a = this.pointerNode;\n    const b = this.valueNode;\n    const params = [];\n    params.push(`&${a.build(builder, inputType)}`);\n    params.push(b.build(builder, inputType));\n    const methodSnippet = `${builder.getMethod(method, type)}( ${params.join(', ')} )`;\n    if (this.storeNode !== null) {\n      const varSnippet = this.storeNode.build(builder, inputType);\n      builder.addLineFlowCode(`${varSnippet} = ${methodSnippet}`, this);\n    } else {\n      builder.addLineFlowCode(methodSnippet, this);\n    }\n  }\n}\nAtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';\nAtomicFunctionNode.ATOMIC_STORE = 'atomicStore';\nAtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';\nAtomicFunctionNode.ATOMIC_SUB = 'atomicSub';\nAtomicFunctionNode.ATOMIC_MAX = 'atomicMax';\nAtomicFunctionNode.ATOMIC_MIN = 'atomicMin';\nAtomicFunctionNode.ATOMIC_AND = 'atomicAnd';\nAtomicFunctionNode.ATOMIC_OR = 'atomicOr';\nAtomicFunctionNode.ATOMIC_XOR = 'atomicXor';\nconst atomicNode = nodeProxy(AtomicFunctionNode);\nconst atomicFunc = (method, pointerNode, valueNode, storeNode) => {\n  const node = atomicNode(method, pointerNode, valueNode, storeNode);\n  node.append();\n  return node;\n};\nconst atomicStore = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode, storeNode);\nconst atomicAdd = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode, storeNode);\nconst atomicSub = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode, storeNode);\nconst atomicMax = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode, storeNode);\nconst atomicMin = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode, storeNode);\nconst atomicAnd = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode, storeNode);\nconst atomicOr = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode, storeNode);\nconst atomicXor = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode, storeNode);\nlet uniformsLib;\nfunction getLightData(light) {\n  uniformsLib = uniformsLib || new WeakMap();\n  let uniforms = uniformsLib.get(light);\n  if (uniforms === undefined) uniformsLib.set(light, uniforms = {});\n  return uniforms;\n}\nfunction lightShadowMatrix(light) {\n  const data = getLightData(light);\n  return data.shadowMatrix || (data.shadowMatrix = uniform('mat4').setGroup(renderGroup).onRenderUpdate(() => {\n    light.shadow.updateMatrices(light);\n    return light.shadow.matrix;\n  }));\n}\nfunction lightProjectionUV(light) {\n  const data = getLightData(light);\n  if (data.projectionUV === undefined) {\n    const spotLightCoord = lightShadowMatrix(light).mul(positionWorld);\n    data.projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);\n  }\n  return data.projectionUV;\n}\nfunction lightPosition(light) {\n  const data = getLightData(light);\n  return data.position || (data.position = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_, self) => self.value.setFromMatrixPosition(light.matrixWorld)));\n}\nfunction lightTargetPosition(light) {\n  const data = getLightData(light);\n  return data.targetPosition || (data.targetPosition = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_, self) => self.value.setFromMatrixPosition(light.target.matrixWorld)));\n}\nfunction lightViewPosition(light) {\n  const data = getLightData(light);\n  return data.viewPosition || (data.viewPosition = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate(({\n    camera\n  }, self) => {\n    self.value = self.value || new Vector3();\n    self.value.setFromMatrixPosition(light.matrixWorld);\n    self.value.applyMatrix4(camera.matrixWorldInverse);\n  }));\n}\nconst lightTargetDirection = light => cameraViewMatrix.transformDirection(lightPosition(light).sub(lightTargetPosition(light)));\nconst sortLights = lights => {\n  return lights.sort((a, b) => a.id - b.id);\n};\nconst getLightNodeById = (id, lightNodes) => {\n  for (const lightNode of lightNodes) {\n    if (lightNode.isAnalyticLightNode && lightNode.light.id === id) {\n      return lightNode;\n    }\n  }\n  return null;\n};\nconst _lightsNodeRef = /*@__PURE__*/new WeakMap();\nclass LightsNode extends Node {\n  static get type() {\n    return 'LightsNode';\n  }\n  constructor() {\n    super('vec3');\n    this.totalDiffuseNode = vec3().toVar('totalDiffuse');\n    this.totalSpecularNode = vec3().toVar('totalSpecular');\n    this.outgoingLightNode = vec3().toVar('outgoingLight');\n    this._lights = [];\n    this._lightNodes = null;\n    this._lightNodesHash = null;\n    this.global = true;\n  }\n  getHash(builder) {\n    if (this._lightNodesHash === null) {\n      if (this._lightNodes === null) this.setupLightsNode(builder);\n      const hash = [];\n      for (const lightNode of this._lightNodes) {\n        hash.push(lightNode.getSelf().getHash());\n      }\n      this._lightNodesHash = 'lights-' + hash.join(',');\n    }\n    return this._lightNodesHash;\n  }\n  analyze(builder) {\n    const properties = builder.getDataFromNode(this);\n    for (const node of properties.nodes) {\n      node.build(builder);\n    }\n  }\n  setupLightsNode(builder) {\n    const lightNodes = [];\n    const previousLightNodes = this._lightNodes;\n    const lights = sortLights(this._lights);\n    const nodeLibrary = builder.renderer.library;\n    for (const light of lights) {\n      if (light.isNode) {\n        lightNodes.push(nodeObject(light));\n      } else {\n        let lightNode = null;\n        if (previousLightNodes !== null) {\n          lightNode = getLightNodeById(light.id, previousLightNodes); // resuse existing light node\n        }\n        if (lightNode === null) {\n          const lightNodeClass = nodeLibrary.getLightNodeClass(light.constructor);\n          if (lightNodeClass === null) {\n            console.warn(`LightsNode.setupNodeLights: Light node not found for ${light.constructor.name}`);\n            continue;\n          }\n          let lightNode = null;\n          if (!_lightsNodeRef.has(light)) {\n            lightNode = nodeObject(new lightNodeClass(light));\n            _lightsNodeRef.set(light, lightNode);\n          } else {\n            lightNode = _lightsNodeRef.get(light);\n          }\n          lightNodes.push(lightNode);\n        }\n      }\n    }\n    this._lightNodes = lightNodes;\n  }\n  setupLights(builder, lightNodes) {\n    for (const lightNode of lightNodes) {\n      lightNode.build(builder);\n    }\n  }\n  setup(builder) {\n    if (this._lightNodes === null) this.setupLightsNode(builder);\n    const context = builder.context;\n    const lightingModel = context.lightingModel;\n    let outgoingLightNode = this.outgoingLightNode;\n    if (lightingModel) {\n      const {\n        _lightNodes,\n        totalDiffuseNode,\n        totalSpecularNode\n      } = this;\n      context.outgoingLight = outgoingLightNode;\n      const stack = builder.addStack();\n\n      //\n\n      const properties = builder.getDataFromNode(this);\n      properties.nodes = stack.nodes;\n\n      //\n\n      lightingModel.start(context, stack, builder);\n\n      // lights\n\n      this.setupLights(builder, _lightNodes);\n\n      //\n\n      lightingModel.indirect(context, stack, builder);\n\n      //\n\n      const {\n        backdrop,\n        backdropAlpha\n      } = context;\n      const {\n        directDiffuse,\n        directSpecular,\n        indirectDiffuse,\n        indirectSpecular\n      } = context.reflectedLight;\n      let totalDiffuse = directDiffuse.add(indirectDiffuse);\n      if (backdrop !== null) {\n        if (backdropAlpha !== null) {\n          totalDiffuse = vec3(backdropAlpha.mix(totalDiffuse, backdrop));\n        } else {\n          totalDiffuse = vec3(backdrop);\n        }\n        context.material.transparent = true;\n      }\n      totalDiffuseNode.assign(totalDiffuse);\n      totalSpecularNode.assign(directSpecular.add(indirectSpecular));\n      outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));\n\n      //\n\n      lightingModel.finish(context, stack, builder);\n\n      //\n\n      outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());\n    }\n    return outgoingLightNode;\n  }\n  setLights(lights) {\n    this._lights = lights;\n    this._lightNodes = null;\n    this._lightNodesHash = null;\n    return this;\n  }\n  getLights() {\n    return this._lights;\n  }\n  get hasLights() {\n    return this._lights.length > 0;\n  }\n}\nconst lights = (lights = []) => nodeObject(new LightsNode()).setLights(lights);\nconst shadowMaterialLib = /*@__PURE__*/new WeakMap();\nconst shadowWorldPosition = /*@__PURE__*/vec3().toVar('shadowWorldPosition');\nconst linearDistance = /*@__PURE__*/Fn(([position, cameraNear, cameraFar]) => {\n  let dist = positionWorld.sub(position).length();\n  dist = dist.sub(cameraNear).div(cameraFar.sub(cameraNear));\n  dist = dist.saturate(); // clamp to [ 0, 1 ]\n\n  return dist;\n});\nconst linearShadowDistance = light => {\n  const camera = light.shadow.camera;\n  const nearDistance = reference('near', 'float', camera).setGroup(renderGroup);\n  const farDistance = reference('far', 'float', camera).setGroup(renderGroup);\n  const referencePosition = objectPosition(light);\n  return linearDistance(referencePosition, nearDistance, farDistance);\n};\nconst getShadowMaterial = light => {\n  let material = shadowMaterialLib.get(light);\n  if (material === undefined) {\n    const depthNode = light.isPointLight ? linearShadowDistance(light) : null;\n    material = new NodeMaterial();\n    material.colorNode = vec4(0, 0, 0, 1);\n    material.depthNode = depthNode;\n    material.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode\n    material.blending = NoBlending;\n    material.name = 'ShadowMaterial';\n    shadowMaterialLib.set(light, material);\n  }\n  return material;\n};\nconst BasicShadowFilter = /*@__PURE__*/Fn(({\n  depthTexture,\n  shadowCoord\n}) => {\n  return texture(depthTexture, shadowCoord.xy).compare(shadowCoord.z);\n});\nconst PCFShadowFilter = /*@__PURE__*/Fn(({\n  depthTexture,\n  shadowCoord,\n  shadow\n}) => {\n  const depthCompare = (uv, compare) => texture(depthTexture, uv).compare(compare);\n  const mapSize = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);\n  const radius = reference('radius', 'float', shadow).setGroup(renderGroup);\n  const texelSize = vec2(1).div(mapSize);\n  const dx0 = texelSize.x.negate().mul(radius);\n  const dy0 = texelSize.y.negate().mul(radius);\n  const dx1 = texelSize.x.mul(radius);\n  const dy1 = texelSize.y.mul(radius);\n  const dx2 = dx0.div(2);\n  const dy2 = dy0.div(2);\n  const dx3 = dx1.div(2);\n  const dy3 = dy1.div(2);\n  return add(depthCompare(shadowCoord.xy.add(vec2(dx0, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx1, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx2, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx3, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx0, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx2, 0)), shadowCoord.z), depthCompare(shadowCoord.xy, shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx3, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx1, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx2, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx3, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx0, dy1)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy1)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx1, dy1)), shadowCoord.z)).mul(1 / 17);\n});\nconst PCFSoftShadowFilter = /*@__PURE__*/Fn(({\n  depthTexture,\n  shadowCoord,\n  shadow\n}) => {\n  const depthCompare = (uv, compare) => texture(depthTexture, uv).compare(compare);\n  const mapSize = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);\n  const texelSize = vec2(1).div(mapSize);\n  const dx = texelSize.x;\n  const dy = texelSize.y;\n  const uv = shadowCoord.xy;\n  const f = fract(uv.mul(mapSize).add(0.5));\n  uv.subAssign(f.mul(texelSize));\n  return add(depthCompare(uv, shadowCoord.z), depthCompare(uv.add(vec2(dx, 0)), shadowCoord.z), depthCompare(uv.add(vec2(0, dy)), shadowCoord.z), depthCompare(uv.add(texelSize), shadowCoord.z), mix(depthCompare(uv.add(vec2(dx.negate(), 0)), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), 0)), shadowCoord.z), f.x), mix(depthCompare(uv.add(vec2(dx.negate(), dy)), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), dy)), shadowCoord.z), f.x), mix(depthCompare(uv.add(vec2(0, dy.negate())), shadowCoord.z), depthCompare(uv.add(vec2(0, dy.mul(2))), shadowCoord.z), f.y), mix(depthCompare(uv.add(vec2(dx, dy.negate())), shadowCoord.z), depthCompare(uv.add(vec2(dx, dy.mul(2))), shadowCoord.z), f.y), mix(mix(depthCompare(uv.add(vec2(dx.negate(), dy.negate())), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), dy.negate())), shadowCoord.z), f.x), mix(depthCompare(uv.add(vec2(dx.negate(), dy.mul(2))), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), dy.mul(2))), shadowCoord.z), f.x), f.y)).mul(1 / 9);\n});\n\n// VSM\n\nconst VSMShadowFilter = /*@__PURE__*/Fn(({\n  depthTexture,\n  shadowCoord\n}) => {\n  const occlusion = float(1).toVar();\n  const distribution = texture(depthTexture).uv(shadowCoord.xy).rg;\n  const hardShadow = step(shadowCoord.z, distribution.x);\n  If(hardShadow.notEqual(float(1.0)), () => {\n    const distance = shadowCoord.z.sub(distribution.x);\n    const variance = max$1(0, distribution.y.mul(distribution.y));\n    let softnessProbability = variance.div(variance.add(distance.mul(distance))); // Chebeyshevs inequality\n    softnessProbability = clamp(sub(softnessProbability, 0.3).div(0.95 - 0.3));\n    occlusion.assign(clamp(max$1(hardShadow, softnessProbability)));\n  });\n  return occlusion;\n});\nconst VSMPassVertical = /*@__PURE__*/Fn(({\n  samples,\n  radius,\n  size,\n  shadowPass\n}) => {\n  const mean = float(0).toVar();\n  const squaredMean = float(0).toVar();\n  const uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));\n  const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));\n  Loop({\n    start: int(0),\n    end: int(samples),\n    type: 'int',\n    condition: '<'\n  }, ({\n    i\n  }) => {\n    const uvOffset = uvStart.add(float(i).mul(uvStride));\n    const depth = shadowPass.uv(add(screenCoordinate.xy, vec2(0, uvOffset).mul(radius)).div(size)).x;\n    mean.addAssign(depth);\n    squaredMean.addAssign(depth.mul(depth));\n  });\n  mean.divAssign(samples);\n  squaredMean.divAssign(samples);\n  const std_dev = sqrt(squaredMean.sub(mean.mul(mean)));\n  return vec2(mean, std_dev);\n});\nconst VSMPassHorizontal = /*@__PURE__*/Fn(({\n  samples,\n  radius,\n  size,\n  shadowPass\n}) => {\n  const mean = float(0).toVar();\n  const squaredMean = float(0).toVar();\n  const uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));\n  const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));\n  Loop({\n    start: int(0),\n    end: int(samples),\n    type: 'int',\n    condition: '<'\n  }, ({\n    i\n  }) => {\n    const uvOffset = uvStart.add(float(i).mul(uvStride));\n    const distribution = shadowPass.uv(add(screenCoordinate.xy, vec2(uvOffset, 0).mul(radius)).div(size));\n    mean.addAssign(distribution.x);\n    squaredMean.addAssign(add(distribution.y.mul(distribution.y), distribution.x.mul(distribution.x)));\n  });\n  mean.divAssign(samples);\n  squaredMean.divAssign(samples);\n  const std_dev = sqrt(squaredMean.sub(mean.mul(mean)));\n  return vec2(mean, std_dev);\n});\nconst _shadowFilterLib = [BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter];\n\n//\n\nconst _quadMesh$1 = /*@__PURE__*/new QuadMesh();\nclass ShadowNode extends Node {\n  static get type() {\n    return 'ShadowNode';\n  }\n  constructor(light, shadow = null) {\n    super();\n    this.light = light;\n    this.shadow = shadow || light.shadow;\n    this.shadowMap = null;\n    this.vsmShadowMapVertical = null;\n    this.vsmShadowMapHorizontal = null;\n    this.vsmMaterialVertical = null;\n    this.vsmMaterialHorizontal = null;\n    this.updateBeforeType = NodeUpdateType.RENDER;\n    this._node = null;\n    this.isShadowNode = true;\n  }\n  setupShadowFilter(builder, {\n    filterFn,\n    depthTexture,\n    shadowCoord,\n    shadow\n  }) {\n    const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));\n    const shadowNode = filterFn({\n      depthTexture,\n      shadowCoord,\n      shadow\n    });\n    return frustumTest.select(shadowNode, float(1));\n  }\n  setupShadowCoord(builder, shadowPosition) {\n    const {\n      shadow\n    } = this;\n    const {\n      renderer\n    } = builder;\n    const bias = reference('bias', 'float', shadow).setGroup(renderGroup);\n    let shadowCoord = shadowPosition;\n    let coordZ;\n    if (shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true) {\n      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);\n      coordZ = shadowCoord.z;\n      if (renderer.coordinateSystem === WebGPUCoordinateSystem) {\n        coordZ = coordZ.mul(2).sub(1); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]\n      }\n    } else {\n      const w = shadowCoord.w;\n      shadowCoord = shadowCoord.xy.div(w); // <-- Only divide X/Y coords since we don't need Z\n\n      // The normally available \"cameraNear\" and \"cameraFar\" nodes cannot be used here because they do not get\n      // updated to use the shadow camera. So, we have to declare our own \"local\" ones here.\n      // TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?\n      const cameraNearLocal = reference('near', 'float', shadow.camera).setGroup(renderGroup);\n      const cameraFarLocal = reference('far', 'float', shadow.camera).setGroup(renderGroup);\n      coordZ = viewZToLogarithmicDepth(w.negate(), cameraNearLocal, cameraFarLocal);\n    }\n    shadowCoord = vec3(shadowCoord.x, shadowCoord.y.oneMinus(),\n    // follow webgpu standards\n    coordZ.add(bias));\n    return shadowCoord;\n  }\n  getShadowFilterFn(type) {\n    return _shadowFilterLib[type];\n  }\n  setupShadow(builder) {\n    const {\n      renderer\n    } = builder;\n    const {\n      light,\n      shadow\n    } = this;\n    const shadowMapType = renderer.shadowMap.type;\n    const depthTexture = new DepthTexture(shadow.mapSize.width, shadow.mapSize.height);\n    depthTexture.compareFunction = LessCompare;\n    const shadowMap = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height);\n    shadowMap.depthTexture = depthTexture;\n    shadow.camera.updateProjectionMatrix();\n\n    // VSM\n\n    if (shadowMapType === VSMShadowMap) {\n      depthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()\n\n      this.vsmShadowMapVertical = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height, {\n        format: RGFormat,\n        type: HalfFloatType\n      });\n      this.vsmShadowMapHorizontal = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height, {\n        format: RGFormat,\n        type: HalfFloatType\n      });\n      const shadowPassVertical = texture(depthTexture);\n      const shadowPassHorizontal = texture(this.vsmShadowMapVertical.texture);\n      const samples = reference('blurSamples', 'float', shadow).setGroup(renderGroup);\n      const radius = reference('radius', 'float', shadow).setGroup(renderGroup);\n      const size = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);\n      let material = this.vsmMaterialVertical || (this.vsmMaterialVertical = new NodeMaterial());\n      material.fragmentNode = VSMPassVertical({\n        samples,\n        radius,\n        size,\n        shadowPass: shadowPassVertical\n      }).context(builder.getSharedContext());\n      material.name = 'VSMVertical';\n      material = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new NodeMaterial());\n      material.fragmentNode = VSMPassHorizontal({\n        samples,\n        radius,\n        size,\n        shadowPass: shadowPassHorizontal\n      }).context(builder.getSharedContext());\n      material.name = 'VSMHorizontal';\n    }\n\n    //\n\n    const shadowIntensity = reference('intensity', 'float', shadow).setGroup(renderGroup);\n    const normalBias = reference('normalBias', 'float', shadow).setGroup(renderGroup);\n    const shadowPosition = lightShadowMatrix(light).mul(shadowWorldPosition.add(transformedNormalWorld.mul(normalBias)));\n    const shadowCoord = this.setupShadowCoord(builder, shadowPosition);\n\n    //\n\n    const filterFn = shadow.filterNode || this.getShadowFilterFn(renderer.shadowMap.type) || null;\n    if (filterFn === null) {\n      throw new Error('THREE.WebGPURenderer: Shadow map type not supported yet.');\n    }\n    const shadowDepthTexture = shadowMapType === VSMShadowMap ? this.vsmShadowMapHorizontal.texture : depthTexture;\n    const shadowNode = this.setupShadowFilter(builder, {\n      filterFn,\n      shadowTexture: shadowMap.texture,\n      depthTexture: shadowDepthTexture,\n      shadowCoord,\n      shadow\n    });\n    const shadowColor = texture(shadowMap.texture, shadowCoord);\n    const shadowOutput = mix(1, shadowNode.rgb.mix(shadowColor, 1), shadowIntensity.mul(shadowColor.a)).toVar();\n    this.shadowMap = shadowMap;\n    this.shadow.map = shadowMap;\n    return shadowOutput;\n  }\n  setup(builder) {\n    if (builder.renderer.shadowMap.enabled === false) return;\n    return Fn(({\n      material\n    }) => {\n      shadowWorldPosition.assign(material.shadowPositionNode || positionWorld);\n      let node = this._node;\n      if (node === null) {\n        this._node = node = this.setupShadow(builder);\n      }\n      if (builder.material.shadowNode) {\n        // @deprecated, r171\n\n        console.warn('THREE.NodeMaterial: \".shadowNode\" is deprecated. Use \".castShadowNode\" instead.');\n      }\n      if (builder.material.receivedShadowNode) {\n        node = builder.material.receivedShadowNode(node);\n      }\n      return node;\n    })();\n  }\n  renderShadow(frame) {\n    const {\n      shadow,\n      shadowMap\n    } = this;\n    const {\n      renderer,\n      scene\n    } = frame;\n    shadowMap.setSize(shadow.mapSize.width, shadow.mapSize.height);\n    renderer.render(scene, shadow.camera);\n  }\n  updateShadow(frame) {\n    const {\n      shadowMap,\n      light,\n      shadow\n    } = this;\n    const {\n      renderer,\n      scene,\n      camera\n    } = frame;\n    const shadowType = renderer.shadowMap.type;\n    const depthVersion = shadowMap.depthTexture.version;\n    this._depthVersionCached = depthVersion;\n    const currentOverrideMaterial = scene.overrideMaterial;\n    scene.overrideMaterial = getShadowMaterial(light);\n    shadow.camera.layers.mask = camera.layers.mask;\n    const currentRenderTarget = renderer.getRenderTarget();\n    const currentRenderObjectFunction = renderer.getRenderObjectFunction();\n    const currentMRT = renderer.getMRT();\n    renderer.setMRT(null);\n    renderer.setRenderObjectFunction((object, ...params) => {\n      if (object.castShadow === true || object.receiveShadow && shadowType === VSMShadowMap) {\n        renderer.renderObject(object, ...params);\n      }\n    });\n    renderer.setRenderTarget(shadowMap);\n    this.renderShadow(frame);\n    renderer.setRenderObjectFunction(currentRenderObjectFunction);\n\n    // vsm blur pass\n\n    if (light.isPointLight !== true && shadowType === VSMShadowMap) {\n      this.vsmPass(renderer);\n    }\n    renderer.setRenderTarget(currentRenderTarget);\n    renderer.setMRT(currentMRT);\n    scene.overrideMaterial = currentOverrideMaterial;\n  }\n  vsmPass(renderer) {\n    const {\n      shadow\n    } = this;\n    this.vsmShadowMapVertical.setSize(shadow.mapSize.width, shadow.mapSize.height);\n    this.vsmShadowMapHorizontal.setSize(shadow.mapSize.width, shadow.mapSize.height);\n    renderer.setRenderTarget(this.vsmShadowMapVertical);\n    _quadMesh$1.material = this.vsmMaterialVertical;\n    _quadMesh$1.render(renderer);\n    renderer.setRenderTarget(this.vsmShadowMapHorizontal);\n    _quadMesh$1.material = this.vsmMaterialHorizontal;\n    _quadMesh$1.render(renderer);\n  }\n  dispose() {\n    this.shadowMap.dispose();\n    this.shadowMap = null;\n    if (this.vsmShadowMapVertical !== null) {\n      this.vsmShadowMapVertical.dispose();\n      this.vsmShadowMapVertical = null;\n      this.vsmMaterialVertical.dispose();\n      this.vsmMaterialVertical = null;\n    }\n    if (this.vsmShadowMapHorizontal !== null) {\n      this.vsmShadowMapHorizontal.dispose();\n      this.vsmShadowMapHorizontal = null;\n      this.vsmMaterialHorizontal.dispose();\n      this.vsmMaterialHorizontal = null;\n    }\n    this.updateBeforeType = NodeUpdateType.NONE;\n  }\n  updateBefore(frame) {\n    const {\n      shadow\n    } = this;\n    const needsUpdate = shadow.needsUpdate || shadow.autoUpdate;\n    if (needsUpdate) {\n      this.updateShadow(frame);\n      if (this.shadowMap.depthTexture.version === this._depthVersionCached) {\n        shadow.needsUpdate = false;\n      }\n    }\n  }\n}\nconst shadow = (light, shadow) => nodeObject(new ShadowNode(light, shadow));\nclass AnalyticLightNode extends LightingNode {\n  static get type() {\n    return 'AnalyticLightNode';\n  }\n  constructor(light = null) {\n    super();\n    this.light = light;\n    this.color = new Color();\n    this.colorNode = light && light.colorNode || uniform(this.color).setGroup(renderGroup);\n    this.baseColorNode = null;\n    this.shadowNode = null;\n    this.shadowColorNode = null;\n    this.isAnalyticLightNode = true;\n    this.updateType = NodeUpdateType.FRAME;\n  }\n  getCacheKey() {\n    return hash$1(super.getCacheKey(), this.light.id, this.light.castShadow ? 1 : 0);\n  }\n  getHash() {\n    return this.light.uuid;\n  }\n  setupShadowNode() {\n    return shadow(this.light);\n  }\n  setupShadow(builder) {\n    const {\n      renderer\n    } = builder;\n    if (renderer.shadowMap.enabled === false) return;\n    let shadowColorNode = this.shadowColorNode;\n    if (shadowColorNode === null) {\n      const customShadowNode = this.light.shadow.shadowNode;\n      let shadowNode;\n      if (customShadowNode !== undefined) {\n        shadowNode = nodeObject(customShadowNode);\n      } else {\n        shadowNode = this.setupShadowNode(builder);\n      }\n      this.shadowNode = shadowNode;\n      this.shadowColorNode = shadowColorNode = this.colorNode.mul(shadowNode);\n      this.baseColorNode = this.colorNode;\n    }\n\n    //\n\n    this.colorNode = shadowColorNode;\n  }\n  setup(builder) {\n    this.colorNode = this.baseColorNode || this.colorNode;\n    if (this.light.castShadow) {\n      if (builder.object.receiveShadow) {\n        this.setupShadow(builder);\n      }\n    } else if (this.shadowNode !== null) {\n      this.shadowNode.dispose();\n      this.shadowNode = null;\n      this.shadowColorNode = null;\n    }\n  }\n  update(/*frame*/\n  ) {\n    const {\n      light\n    } = this;\n    this.color.copy(light.color).multiplyScalar(light.intensity);\n  }\n}\nconst getDistanceAttenuation = /*@__PURE__*/Fn(inputs => {\n  const {\n    lightDistance,\n    cutoffDistance,\n    decayExponent\n  } = inputs;\n\n  // based upon Frostbite 3 Moving to Physically-based Rendering\n  // page 32, equation 26: E[window1]\n  // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n  const distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();\n  return cutoffDistance.greaterThan(0).select(distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()), distanceFalloff);\n}); // validated\n\nconst _clearColor$2 = /*@__PURE__*/new Color();\n\n// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n// vector suitable for 2D texture mapping. This code uses the following layout for the\n// 2D texture:\n//\n// xzXZ\n//  y Y\n//\n// Y - Positive y direction\n// y - Negative y direction\n// X - Positive x direction\n// x - Negative x direction\n// Z - Positive z direction\n// z - Negative z direction\n//\n// Source and test bed:\n// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\nconst cubeToUV = /*@__PURE__*/Fn(([pos, texelSizeY]) => {\n  const v = pos.toVar();\n\n  // Number of texels to avoid at the edge of each square\n\n  const absV = abs(v);\n\n  // Intersect unit cube\n\n  const scaleToCube = div(1.0, max$1(absV.x, max$1(absV.y, absV.z)));\n  absV.mulAssign(scaleToCube);\n\n  // Apply scale to avoid seams\n\n  // two texels less per square (one texel will do for NEAREST)\n  v.mulAssign(scaleToCube.mul(texelSizeY.mul(2).oneMinus()));\n\n  // Unwrap\n\n  // space: -1 ... 1 range for each square\n  //\n  // #X##\t\tdim    := ( 4 , 2 )\n  //  # #\t\tcenter := ( 1 , 1 )\n\n  const planar = vec2(v.xy).toVar();\n  const almostATexel = texelSizeY.mul(1.5);\n  const almostOne = almostATexel.oneMinus();\n  If(absV.z.greaterThanEqual(almostOne), () => {\n    If(v.z.greaterThan(0.0), () => {\n      planar.x.assign(sub(4.0, v.x));\n    });\n  }).ElseIf(absV.x.greaterThanEqual(almostOne), () => {\n    const signX = sign(v.x);\n    planar.x.assign(v.z.mul(signX).add(signX.mul(2.0)));\n  }).ElseIf(absV.y.greaterThanEqual(almostOne), () => {\n    const signY = sign(v.y);\n    planar.x.assign(v.x.add(signY.mul(2.0)).add(2.0));\n    planar.y.assign(v.z.mul(signY).sub(2.0));\n  });\n\n  // Transform to UV space\n\n  // scale := 0.5 / dim\n  // translate := ( center + 0.5 ) / dim\n  return vec2(0.125, 0.25).mul(planar).add(vec2(0.375, 0.75)).flipY();\n}).setLayout({\n  name: 'cubeToUV',\n  type: 'vec2',\n  inputs: [{\n    name: 'pos',\n    type: 'vec3'\n  }, {\n    name: 'texelSizeY',\n    type: 'float'\n  }]\n});\nconst BasicPointShadowFilter = /*@__PURE__*/Fn(({\n  depthTexture,\n  bd3D,\n  dp,\n  texelSize\n}) => {\n  return texture(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp);\n});\nconst PointShadowFilter = /*@__PURE__*/Fn(({\n  depthTexture,\n  bd3D,\n  dp,\n  texelSize,\n  shadow\n}) => {\n  const radius = reference('radius', 'float', shadow).setGroup(renderGroup);\n  const offset = vec2(-1.0, 1.0).mul(radius).mul(texelSize.y);\n  return texture(depthTexture, cubeToUV(bd3D.add(offset.xyy), texelSize.y)).compare(dp).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yyy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xyx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yyx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xxy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yxy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xxx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yxx), texelSize.y)).compare(dp)).mul(1.0 / 9.0);\n});\nconst pointShadowFilter = /*@__PURE__*/Fn(({\n  filterFn,\n  depthTexture,\n  shadowCoord,\n  shadow\n}) => {\n  // for point lights, the uniform @vShadowCoord is re-purposed to hold\n  // the vector from the light to the world-space position of the fragment.\n  const lightToPosition = shadowCoord.xyz.toVar();\n  const lightToPositionLength = lightToPosition.length();\n  const cameraNearLocal = uniform('float').setGroup(renderGroup).onRenderUpdate(() => shadow.camera.near);\n  const cameraFarLocal = uniform('float').setGroup(renderGroup).onRenderUpdate(() => shadow.camera.far);\n  const bias = reference('bias', 'float', shadow).setGroup(renderGroup);\n  const mapSize = uniform(shadow.mapSize).setGroup(renderGroup);\n  const result = float(1.0).toVar();\n  If(lightToPositionLength.sub(cameraFarLocal).lessThanEqual(0.0).and(lightToPositionLength.sub(cameraNearLocal).greaterThanEqual(0.0)), () => {\n    // dp = normalized distance from light to fragment position\n    const dp = lightToPositionLength.sub(cameraNearLocal).div(cameraFarLocal.sub(cameraNearLocal)).toVar(); // need to clamp?\n    dp.addAssign(bias);\n\n    // bd3D = base direction 3D\n    const bd3D = lightToPosition.normalize();\n    const texelSize = vec2(1.0).div(mapSize.mul(vec2(4.0, 2.0)));\n\n    // percentage-closer filtering\n    result.assign(filterFn({\n      depthTexture,\n      bd3D,\n      dp,\n      texelSize,\n      shadow\n    }));\n  });\n  return result;\n});\nconst _viewport = /*@__PURE__*/new Vector4();\nconst _viewportSize = /*@__PURE__*/new Vector2();\nconst _shadowMapSize = /*@__PURE__*/new Vector2();\n\n//\n\nclass PointShadowNode extends ShadowNode {\n  static get type() {\n    return 'PointShadowNode';\n  }\n  constructor(light, shadow = null) {\n    super(light, shadow);\n  }\n  getShadowFilterFn(type) {\n    return type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;\n  }\n  setupShadowCoord(builder, shadowPosition) {\n    return shadowPosition;\n  }\n  setupShadowFilter(builder, {\n    filterFn,\n    shadowTexture,\n    depthTexture,\n    shadowCoord,\n    shadow\n  }) {\n    return pointShadowFilter({\n      filterFn,\n      shadowTexture,\n      depthTexture,\n      shadowCoord,\n      shadow\n    });\n  }\n  renderShadow(frame) {\n    const {\n      shadow,\n      shadowMap,\n      light\n    } = this;\n    const {\n      renderer,\n      scene\n    } = frame;\n    const shadowFrameExtents = shadow.getFrameExtents();\n    _shadowMapSize.copy(shadow.mapSize);\n    _shadowMapSize.multiply(shadowFrameExtents);\n    shadowMap.setSize(_shadowMapSize.width, _shadowMapSize.height);\n    _viewportSize.copy(shadow.mapSize);\n\n    //\n\n    const previousAutoClear = renderer.autoClear;\n    const previousClearColor = renderer.getClearColor(_clearColor$2);\n    const previousClearAlpha = renderer.getClearAlpha();\n    renderer.autoClear = false;\n    renderer.setClearColor(shadow.clearColor, shadow.clearAlpha);\n    renderer.clear();\n    const viewportCount = shadow.getViewportCount();\n    for (let vp = 0; vp < viewportCount; vp++) {\n      const viewport = shadow.getViewport(vp);\n      const x = _viewportSize.x * viewport.x;\n      const y = _shadowMapSize.y - _viewportSize.y - _viewportSize.y * viewport.y;\n      _viewport.set(x, y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);\n      shadowMap.viewport.copy(_viewport);\n      shadow.updateMatrices(light, vp);\n      renderer.render(scene, shadow.camera);\n    }\n\n    //\n\n    renderer.autoClear = previousAutoClear;\n    renderer.setClearColor(previousClearColor, previousClearAlpha);\n  }\n}\nconst pointShadow = (light, shadow) => nodeObject(new PointShadowNode(light, shadow));\nconst directPointLight = Fn(({\n  color,\n  lightViewPosition,\n  cutoffDistance,\n  decayExponent\n}, builder) => {\n  const lightingModel = builder.context.lightingModel;\n  const lVector = lightViewPosition.sub(positionView); // @TODO: Add it into LightNode\n\n  const lightDirection = lVector.normalize();\n  const lightDistance = lVector.length();\n  const lightAttenuation = getDistanceAttenuation({\n    lightDistance,\n    cutoffDistance,\n    decayExponent\n  });\n  const lightColor = color.mul(lightAttenuation);\n  const reflectedLight = builder.context.reflectedLight;\n  lightingModel.direct({\n    lightDirection,\n    lightColor,\n    reflectedLight\n  }, builder.stack, builder);\n});\nclass PointLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'PointLightNode';\n  }\n  constructor(light = null) {\n    super(light);\n    this.cutoffDistanceNode = uniform(0).setGroup(renderGroup);\n    this.decayExponentNode = uniform(0).setGroup(renderGroup);\n  }\n  update(frame) {\n    const {\n      light\n    } = this;\n    super.update(frame);\n    this.cutoffDistanceNode.value = light.distance;\n    this.decayExponentNode.value = light.decay;\n  }\n  setupShadowNode() {\n    return pointShadow(this.light);\n  }\n  setup(builder) {\n    super.setup(builder);\n    directPointLight({\n      color: this.colorNode,\n      lightViewPosition: lightViewPosition(this.light),\n      cutoffDistance: this.cutoffDistanceNode,\n      decayExponent: this.decayExponentNode\n    }).append();\n  }\n}\nconst checker = /*@__PURE__*/Fn(([coord = uv()]) => {\n  const uv = coord.mul(2.0);\n  const cx = uv.x.floor();\n  const cy = uv.y.floor();\n  const result = cx.add(cy).mod(2.0);\n  return result.sign();\n});\n\n// Three.js Transpiler\n// https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/libraries/stdlib/genglsl/lib/mx_noise.glsl\n\nconst mx_select = /*@__PURE__*/Fn(([b_immutable, t_immutable, f_immutable]) => {\n  const f = float(f_immutable).toVar();\n  const t = float(t_immutable).toVar();\n  const b = bool(b_immutable).toVar();\n  return select(b, t, f);\n}).setLayout({\n  name: 'mx_select',\n  type: 'float',\n  inputs: [{\n    name: 'b',\n    type: 'bool'\n  }, {\n    name: 't',\n    type: 'float'\n  }, {\n    name: 'f',\n    type: 'float'\n  }]\n});\nconst mx_negate_if = /*@__PURE__*/Fn(([val_immutable, b_immutable]) => {\n  const b = bool(b_immutable).toVar();\n  const val = float(val_immutable).toVar();\n  return select(b, val.negate(), val);\n}).setLayout({\n  name: 'mx_negate_if',\n  type: 'float',\n  inputs: [{\n    name: 'val',\n    type: 'float'\n  }, {\n    name: 'b',\n    type: 'bool'\n  }]\n});\nconst mx_floor = /*@__PURE__*/Fn(([x_immutable]) => {\n  const x = float(x_immutable).toVar();\n  return int(floor(x));\n}).setLayout({\n  name: 'mx_floor',\n  type: 'int',\n  inputs: [{\n    name: 'x',\n    type: 'float'\n  }]\n});\nconst mx_floorfrac = /*@__PURE__*/Fn(([x_immutable, i]) => {\n  const x = float(x_immutable).toVar();\n  i.assign(mx_floor(x));\n  return x.sub(float(i));\n});\nconst mx_bilerp_0 = /*@__PURE__*/Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {\n  const t = float(t_immutable).toVar();\n  const s = float(s_immutable).toVar();\n  const v3 = float(v3_immutable).toVar();\n  const v2 = float(v2_immutable).toVar();\n  const v1 = float(v1_immutable).toVar();\n  const v0 = float(v0_immutable).toVar();\n  const s1 = float(sub(1.0, s)).toVar();\n  return sub(1.0, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));\n}).setLayout({\n  name: 'mx_bilerp_0',\n  type: 'float',\n  inputs: [{\n    name: 'v0',\n    type: 'float'\n  }, {\n    name: 'v1',\n    type: 'float'\n  }, {\n    name: 'v2',\n    type: 'float'\n  }, {\n    name: 'v3',\n    type: 'float'\n  }, {\n    name: 's',\n    type: 'float'\n  }, {\n    name: 't',\n    type: 'float'\n  }]\n});\nconst mx_bilerp_1 = /*@__PURE__*/Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {\n  const t = float(t_immutable).toVar();\n  const s = float(s_immutable).toVar();\n  const v3 = vec3(v3_immutable).toVar();\n  const v2 = vec3(v2_immutable).toVar();\n  const v1 = vec3(v1_immutable).toVar();\n  const v0 = vec3(v0_immutable).toVar();\n  const s1 = float(sub(1.0, s)).toVar();\n  return sub(1.0, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));\n}).setLayout({\n  name: 'mx_bilerp_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'v0',\n    type: 'vec3'\n  }, {\n    name: 'v1',\n    type: 'vec3'\n  }, {\n    name: 'v2',\n    type: 'vec3'\n  }, {\n    name: 'v3',\n    type: 'vec3'\n  }, {\n    name: 's',\n    type: 'float'\n  }, {\n    name: 't',\n    type: 'float'\n  }]\n});\nconst mx_bilerp = /*@__PURE__*/overloadingFn([mx_bilerp_0, mx_bilerp_1]);\nconst mx_trilerp_0 = /*@__PURE__*/Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {\n  const r = float(r_immutable).toVar();\n  const t = float(t_immutable).toVar();\n  const s = float(s_immutable).toVar();\n  const v7 = float(v7_immutable).toVar();\n  const v6 = float(v6_immutable).toVar();\n  const v5 = float(v5_immutable).toVar();\n  const v4 = float(v4_immutable).toVar();\n  const v3 = float(v3_immutable).toVar();\n  const v2 = float(v2_immutable).toVar();\n  const v1 = float(v1_immutable).toVar();\n  const v0 = float(v0_immutable).toVar();\n  const s1 = float(sub(1.0, s)).toVar();\n  const t1 = float(sub(1.0, t)).toVar();\n  const r1 = float(sub(1.0, r)).toVar();\n  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));\n}).setLayout({\n  name: 'mx_trilerp_0',\n  type: 'float',\n  inputs: [{\n    name: 'v0',\n    type: 'float'\n  }, {\n    name: 'v1',\n    type: 'float'\n  }, {\n    name: 'v2',\n    type: 'float'\n  }, {\n    name: 'v3',\n    type: 'float'\n  }, {\n    name: 'v4',\n    type: 'float'\n  }, {\n    name: 'v5',\n    type: 'float'\n  }, {\n    name: 'v6',\n    type: 'float'\n  }, {\n    name: 'v7',\n    type: 'float'\n  }, {\n    name: 's',\n    type: 'float'\n  }, {\n    name: 't',\n    type: 'float'\n  }, {\n    name: 'r',\n    type: 'float'\n  }]\n});\nconst mx_trilerp_1 = /*@__PURE__*/Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {\n  const r = float(r_immutable).toVar();\n  const t = float(t_immutable).toVar();\n  const s = float(s_immutable).toVar();\n  const v7 = vec3(v7_immutable).toVar();\n  const v6 = vec3(v6_immutable).toVar();\n  const v5 = vec3(v5_immutable).toVar();\n  const v4 = vec3(v4_immutable).toVar();\n  const v3 = vec3(v3_immutable).toVar();\n  const v2 = vec3(v2_immutable).toVar();\n  const v1 = vec3(v1_immutable).toVar();\n  const v0 = vec3(v0_immutable).toVar();\n  const s1 = float(sub(1.0, s)).toVar();\n  const t1 = float(sub(1.0, t)).toVar();\n  const r1 = float(sub(1.0, r)).toVar();\n  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));\n}).setLayout({\n  name: 'mx_trilerp_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'v0',\n    type: 'vec3'\n  }, {\n    name: 'v1',\n    type: 'vec3'\n  }, {\n    name: 'v2',\n    type: 'vec3'\n  }, {\n    name: 'v3',\n    type: 'vec3'\n  }, {\n    name: 'v4',\n    type: 'vec3'\n  }, {\n    name: 'v5',\n    type: 'vec3'\n  }, {\n    name: 'v6',\n    type: 'vec3'\n  }, {\n    name: 'v7',\n    type: 'vec3'\n  }, {\n    name: 's',\n    type: 'float'\n  }, {\n    name: 't',\n    type: 'float'\n  }, {\n    name: 'r',\n    type: 'float'\n  }]\n});\nconst mx_trilerp = /*@__PURE__*/overloadingFn([mx_trilerp_0, mx_trilerp_1]);\nconst mx_gradient_float_0 = /*@__PURE__*/Fn(([hash_immutable, x_immutable, y_immutable]) => {\n  const y = float(y_immutable).toVar();\n  const x = float(x_immutable).toVar();\n  const hash = uint(hash_immutable).toVar();\n  const h = uint(hash.bitAnd(uint(7))).toVar();\n  const u = float(mx_select(h.lessThan(uint(4)), x, y)).toVar();\n  const v = float(mul(2.0, mx_select(h.lessThan(uint(4)), y, x))).toVar();\n  return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));\n}).setLayout({\n  name: 'mx_gradient_float_0',\n  type: 'float',\n  inputs: [{\n    name: 'hash',\n    type: 'uint'\n  }, {\n    name: 'x',\n    type: 'float'\n  }, {\n    name: 'y',\n    type: 'float'\n  }]\n});\nconst mx_gradient_float_1 = /*@__PURE__*/Fn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {\n  const z = float(z_immutable).toVar();\n  const y = float(y_immutable).toVar();\n  const x = float(x_immutable).toVar();\n  const hash = uint(hash_immutable).toVar();\n  const h = uint(hash.bitAnd(uint(15))).toVar();\n  const u = float(mx_select(h.lessThan(uint(8)), x, y)).toVar();\n  const v = float(mx_select(h.lessThan(uint(4)), y, mx_select(h.equal(uint(12)).or(h.equal(uint(14))), x, z))).toVar();\n  return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));\n}).setLayout({\n  name: 'mx_gradient_float_1',\n  type: 'float',\n  inputs: [{\n    name: 'hash',\n    type: 'uint'\n  }, {\n    name: 'x',\n    type: 'float'\n  }, {\n    name: 'y',\n    type: 'float'\n  }, {\n    name: 'z',\n    type: 'float'\n  }]\n});\nconst mx_gradient_float = /*@__PURE__*/overloadingFn([mx_gradient_float_0, mx_gradient_float_1]);\nconst mx_gradient_vec3_0 = /*@__PURE__*/Fn(([hash_immutable, x_immutable, y_immutable]) => {\n  const y = float(y_immutable).toVar();\n  const x = float(x_immutable).toVar();\n  const hash = uvec3(hash_immutable).toVar();\n  return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));\n}).setLayout({\n  name: 'mx_gradient_vec3_0',\n  type: 'vec3',\n  inputs: [{\n    name: 'hash',\n    type: 'uvec3'\n  }, {\n    name: 'x',\n    type: 'float'\n  }, {\n    name: 'y',\n    type: 'float'\n  }]\n});\nconst mx_gradient_vec3_1 = /*@__PURE__*/Fn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {\n  const z = float(z_immutable).toVar();\n  const y = float(y_immutable).toVar();\n  const x = float(x_immutable).toVar();\n  const hash = uvec3(hash_immutable).toVar();\n  return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));\n}).setLayout({\n  name: 'mx_gradient_vec3_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'hash',\n    type: 'uvec3'\n  }, {\n    name: 'x',\n    type: 'float'\n  }, {\n    name: 'y',\n    type: 'float'\n  }, {\n    name: 'z',\n    type: 'float'\n  }]\n});\nconst mx_gradient_vec3 = /*@__PURE__*/overloadingFn([mx_gradient_vec3_0, mx_gradient_vec3_1]);\nconst mx_gradient_scale2d_0 = /*@__PURE__*/Fn(([v_immutable]) => {\n  const v = float(v_immutable).toVar();\n  return mul(0.6616, v);\n}).setLayout({\n  name: 'mx_gradient_scale2d_0',\n  type: 'float',\n  inputs: [{\n    name: 'v',\n    type: 'float'\n  }]\n});\nconst mx_gradient_scale3d_0 = /*@__PURE__*/Fn(([v_immutable]) => {\n  const v = float(v_immutable).toVar();\n  return mul(0.9820, v);\n}).setLayout({\n  name: 'mx_gradient_scale3d_0',\n  type: 'float',\n  inputs: [{\n    name: 'v',\n    type: 'float'\n  }]\n});\nconst mx_gradient_scale2d_1 = /*@__PURE__*/Fn(([v_immutable]) => {\n  const v = vec3(v_immutable).toVar();\n  return mul(0.6616, v);\n}).setLayout({\n  name: 'mx_gradient_scale2d_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'v',\n    type: 'vec3'\n  }]\n});\nconst mx_gradient_scale2d = /*@__PURE__*/overloadingFn([mx_gradient_scale2d_0, mx_gradient_scale2d_1]);\nconst mx_gradient_scale3d_1 = /*@__PURE__*/Fn(([v_immutable]) => {\n  const v = vec3(v_immutable).toVar();\n  return mul(0.9820, v);\n}).setLayout({\n  name: 'mx_gradient_scale3d_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'v',\n    type: 'vec3'\n  }]\n});\nconst mx_gradient_scale3d = /*@__PURE__*/overloadingFn([mx_gradient_scale3d_0, mx_gradient_scale3d_1]);\nconst mx_rotl32 = /*@__PURE__*/Fn(([x_immutable, k_immutable]) => {\n  const k = int(k_immutable).toVar();\n  const x = uint(x_immutable).toVar();\n  return x.shiftLeft(k).bitOr(x.shiftRight(int(32).sub(k)));\n}).setLayout({\n  name: 'mx_rotl32',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'uint'\n  }, {\n    name: 'k',\n    type: 'int'\n  }]\n});\nconst mx_bjmix = /*@__PURE__*/Fn(([a, b, c]) => {\n  a.subAssign(c);\n  a.bitXorAssign(mx_rotl32(c, int(4)));\n  c.addAssign(b);\n  b.subAssign(a);\n  b.bitXorAssign(mx_rotl32(a, int(6)));\n  a.addAssign(c);\n  c.subAssign(b);\n  c.bitXorAssign(mx_rotl32(b, int(8)));\n  b.addAssign(a);\n  a.subAssign(c);\n  a.bitXorAssign(mx_rotl32(c, int(16)));\n  c.addAssign(b);\n  b.subAssign(a);\n  b.bitXorAssign(mx_rotl32(a, int(19)));\n  a.addAssign(c);\n  c.subAssign(b);\n  c.bitXorAssign(mx_rotl32(b, int(4)));\n  b.addAssign(a);\n});\nconst mx_bjfinal = /*@__PURE__*/Fn(([a_immutable, b_immutable, c_immutable]) => {\n  const c = uint(c_immutable).toVar();\n  const b = uint(b_immutable).toVar();\n  const a = uint(a_immutable).toVar();\n  c.bitXorAssign(b);\n  c.subAssign(mx_rotl32(b, int(14)));\n  a.bitXorAssign(c);\n  a.subAssign(mx_rotl32(c, int(11)));\n  b.bitXorAssign(a);\n  b.subAssign(mx_rotl32(a, int(25)));\n  c.bitXorAssign(b);\n  c.subAssign(mx_rotl32(b, int(16)));\n  a.bitXorAssign(c);\n  a.subAssign(mx_rotl32(c, int(4)));\n  b.bitXorAssign(a);\n  b.subAssign(mx_rotl32(a, int(14)));\n  c.bitXorAssign(b);\n  c.subAssign(mx_rotl32(b, int(24)));\n  return c;\n}).setLayout({\n  name: 'mx_bjfinal',\n  type: 'uint',\n  inputs: [{\n    name: 'a',\n    type: 'uint'\n  }, {\n    name: 'b',\n    type: 'uint'\n  }, {\n    name: 'c',\n    type: 'uint'\n  }]\n});\nconst mx_bits_to_01 = /*@__PURE__*/Fn(([bits_immutable]) => {\n  const bits = uint(bits_immutable).toVar();\n  return float(bits).div(float(uint(int(0xffffffff))));\n}).setLayout({\n  name: 'mx_bits_to_01',\n  type: 'float',\n  inputs: [{\n    name: 'bits',\n    type: 'uint'\n  }]\n});\nconst mx_fade = /*@__PURE__*/Fn(([t_immutable]) => {\n  const t = float(t_immutable).toVar();\n  return t.mul(t).mul(t).mul(t.mul(t.mul(6.0).sub(15.0)).add(10.0));\n}).setLayout({\n  name: 'mx_fade',\n  type: 'float',\n  inputs: [{\n    name: 't',\n    type: 'float'\n  }]\n});\nconst mx_hash_int_0 = /*@__PURE__*/Fn(([x_immutable]) => {\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(1)).toVar();\n  const seed = uint(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13))).toVar();\n  return mx_bjfinal(seed.add(uint(x)), seed, seed);\n}).setLayout({\n  name: 'mx_hash_int_0',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }]\n});\nconst mx_hash_int_1 = /*@__PURE__*/Fn(([x_immutable, y_immutable]) => {\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(2)).toVar();\n  const a = uint().toVar(),\n    b = uint().toVar(),\n    c = uint().toVar();\n  a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));\n  a.addAssign(uint(x));\n  b.addAssign(uint(y));\n  return mx_bjfinal(a, b, c);\n}).setLayout({\n  name: 'mx_hash_int_1',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }]\n});\nconst mx_hash_int_2 = /*@__PURE__*/Fn(([x_immutable, y_immutable, z_immutable]) => {\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(3)).toVar();\n  const a = uint().toVar(),\n    b = uint().toVar(),\n    c = uint().toVar();\n  a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));\n  a.addAssign(uint(x));\n  b.addAssign(uint(y));\n  c.addAssign(uint(z));\n  return mx_bjfinal(a, b, c);\n}).setLayout({\n  name: 'mx_hash_int_2',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }]\n});\nconst mx_hash_int_3 = /*@__PURE__*/Fn(([x_immutable, y_immutable, z_immutable, xx_immutable]) => {\n  const xx = int(xx_immutable).toVar();\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(4)).toVar();\n  const a = uint().toVar(),\n    b = uint().toVar(),\n    c = uint().toVar();\n  a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));\n  a.addAssign(uint(x));\n  b.addAssign(uint(y));\n  c.addAssign(uint(z));\n  mx_bjmix(a, b, c);\n  a.addAssign(uint(xx));\n  return mx_bjfinal(a, b, c);\n}).setLayout({\n  name: 'mx_hash_int_3',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }, {\n    name: 'xx',\n    type: 'int'\n  }]\n});\nconst mx_hash_int_4 = /*@__PURE__*/Fn(([x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable]) => {\n  const yy = int(yy_immutable).toVar();\n  const xx = int(xx_immutable).toVar();\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const len = uint(uint(5)).toVar();\n  const a = uint().toVar(),\n    b = uint().toVar(),\n    c = uint().toVar();\n  a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));\n  a.addAssign(uint(x));\n  b.addAssign(uint(y));\n  c.addAssign(uint(z));\n  mx_bjmix(a, b, c);\n  a.addAssign(uint(xx));\n  b.addAssign(uint(yy));\n  return mx_bjfinal(a, b, c);\n}).setLayout({\n  name: 'mx_hash_int_4',\n  type: 'uint',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }, {\n    name: 'xx',\n    type: 'int'\n  }, {\n    name: 'yy',\n    type: 'int'\n  }]\n});\nconst mx_hash_int = /*@__PURE__*/overloadingFn([mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4]);\nconst mx_hash_vec3_0 = /*@__PURE__*/Fn(([x_immutable, y_immutable]) => {\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const h = uint(mx_hash_int(x, y)).toVar();\n  const result = uvec3().toVar();\n  result.x.assign(h.bitAnd(int(0xFF)));\n  result.y.assign(h.shiftRight(int(8)).bitAnd(int(0xFF)));\n  result.z.assign(h.shiftRight(int(16)).bitAnd(int(0xFF)));\n  return result;\n}).setLayout({\n  name: 'mx_hash_vec3_0',\n  type: 'uvec3',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }]\n});\nconst mx_hash_vec3_1 = /*@__PURE__*/Fn(([x_immutable, y_immutable, z_immutable]) => {\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const h = uint(mx_hash_int(x, y, z)).toVar();\n  const result = uvec3().toVar();\n  result.x.assign(h.bitAnd(int(0xFF)));\n  result.y.assign(h.shiftRight(int(8)).bitAnd(int(0xFF)));\n  result.z.assign(h.shiftRight(int(16)).bitAnd(int(0xFF)));\n  return result;\n}).setLayout({\n  name: 'mx_hash_vec3_1',\n  type: 'uvec3',\n  inputs: [{\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }]\n});\nconst mx_hash_vec3 = /*@__PURE__*/overloadingFn([mx_hash_vec3_0, mx_hash_vec3_1]);\nconst mx_perlin_noise_float_0 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const fx = float(mx_floorfrac(p.x, X)).toVar();\n  const fy = float(mx_floorfrac(p.y, Y)).toVar();\n  const u = float(mx_fade(fx)).toVar();\n  const v = float(mx_fade(fy)).toVar();\n  const result = float(mx_bilerp(mx_gradient_float(mx_hash_int(X, Y), fx, fy), mx_gradient_float(mx_hash_int(X.add(int(1)), Y), fx.sub(1.0), fy), mx_gradient_float(mx_hash_int(X, Y.add(int(1))), fx, fy.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1))), fx.sub(1.0), fy.sub(1.0)), u, v)).toVar();\n  return mx_gradient_scale2d(result);\n}).setLayout({\n  name: 'mx_perlin_noise_float_0',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }]\n});\nconst mx_perlin_noise_float_1 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const fx = float(mx_floorfrac(p.x, X)).toVar();\n  const fy = float(mx_floorfrac(p.y, Y)).toVar();\n  const fz = float(mx_floorfrac(p.z, Z)).toVar();\n  const u = float(mx_fade(fx)).toVar();\n  const v = float(mx_fade(fy)).toVar();\n  const w = float(mx_fade(fz)).toVar();\n  const result = float(mx_trilerp(mx_gradient_float(mx_hash_int(X, Y, Z), fx, fy, fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z), fx.sub(1.0), fy, fz), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z), fx, fy.sub(1.0), fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1.0), fy.sub(1.0), fz), mx_gradient_float(mx_hash_int(X, Y, Z.add(int(1))), fx, fy, fz.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1.0), fy, fz.sub(1.0)), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1.0), fz.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1.0), fy.sub(1.0), fz.sub(1.0)), u, v, w)).toVar();\n  return mx_gradient_scale3d(result);\n}).setLayout({\n  name: 'mx_perlin_noise_float_1',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\nconst mx_perlin_noise_float = /*@__PURE__*/overloadingFn([mx_perlin_noise_float_0, mx_perlin_noise_float_1]);\nconst mx_perlin_noise_vec3_0 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const fx = float(mx_floorfrac(p.x, X)).toVar();\n  const fy = float(mx_floorfrac(p.y, Y)).toVar();\n  const u = float(mx_fade(fx)).toVar();\n  const v = float(mx_fade(fy)).toVar();\n  const result = vec3(mx_bilerp(mx_gradient_vec3(mx_hash_vec3(X, Y), fx, fy), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y), fx.sub(1.0), fy), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1))), fx, fy.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1))), fx.sub(1.0), fy.sub(1.0)), u, v)).toVar();\n  return mx_gradient_scale2d(result);\n}).setLayout({\n  name: 'mx_perlin_noise_vec3_0',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }]\n});\nconst mx_perlin_noise_vec3_1 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const fx = float(mx_floorfrac(p.x, X)).toVar();\n  const fy = float(mx_floorfrac(p.y, Y)).toVar();\n  const fz = float(mx_floorfrac(p.z, Z)).toVar();\n  const u = float(mx_fade(fx)).toVar();\n  const v = float(mx_fade(fy)).toVar();\n  const w = float(mx_fade(fz)).toVar();\n  const result = vec3(mx_trilerp(mx_gradient_vec3(mx_hash_vec3(X, Y, Z), fx, fy, fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z), fx.sub(1.0), fy, fz), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z), fx, fy.sub(1.0), fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1.0), fy.sub(1.0), fz), mx_gradient_vec3(mx_hash_vec3(X, Y, Z.add(int(1))), fx, fy, fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1.0), fy, fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1.0), fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1.0), fy.sub(1.0), fz.sub(1.0)), u, v, w)).toVar();\n  return mx_gradient_scale3d(result);\n}).setLayout({\n  name: 'mx_perlin_noise_vec3_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\nconst mx_perlin_noise_vec3 = /*@__PURE__*/overloadingFn([mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1]);\nconst mx_cell_noise_float_0 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = float(p_immutable).toVar();\n  const ix = int(mx_floor(p)).toVar();\n  return mx_bits_to_01(mx_hash_int(ix));\n}).setLayout({\n  name: 'mx_cell_noise_float_0',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'float'\n  }]\n});\nconst mx_cell_noise_float_1 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec2(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  return mx_bits_to_01(mx_hash_int(ix, iy));\n}).setLayout({\n  name: 'mx_cell_noise_float_1',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }]\n});\nconst mx_cell_noise_float_2 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec3(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  const iz = int(mx_floor(p.z)).toVar();\n  return mx_bits_to_01(mx_hash_int(ix, iy, iz));\n}).setLayout({\n  name: 'mx_cell_noise_float_2',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\nconst mx_cell_noise_float_3 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec4(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  const iz = int(mx_floor(p.z)).toVar();\n  const iw = int(mx_floor(p.w)).toVar();\n  return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));\n}).setLayout({\n  name: 'mx_cell_noise_float_3',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec4'\n  }]\n});\nconst mx_cell_noise_float$1 = /*@__PURE__*/overloadingFn([mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3]);\nconst mx_cell_noise_vec3_0 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = float(p_immutable).toVar();\n  const ix = int(mx_floor(p)).toVar();\n  return vec3(mx_bits_to_01(mx_hash_int(ix, int(0))), mx_bits_to_01(mx_hash_int(ix, int(1))), mx_bits_to_01(mx_hash_int(ix, int(2))));\n}).setLayout({\n  name: 'mx_cell_noise_vec3_0',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'float'\n  }]\n});\nconst mx_cell_noise_vec3_1 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec2(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, int(2))));\n}).setLayout({\n  name: 'mx_cell_noise_vec3_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }]\n});\nconst mx_cell_noise_vec3_2 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec3(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  const iz = int(mx_floor(p.z)).toVar();\n  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(2))));\n}).setLayout({\n  name: 'mx_cell_noise_vec3_2',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }]\n});\nconst mx_cell_noise_vec3_3 = /*@__PURE__*/Fn(([p_immutable]) => {\n  const p = vec4(p_immutable).toVar();\n  const ix = int(mx_floor(p.x)).toVar();\n  const iy = int(mx_floor(p.y)).toVar();\n  const iz = int(mx_floor(p.z)).toVar();\n  const iw = int(mx_floor(p.w)).toVar();\n  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(2))));\n}).setLayout({\n  name: 'mx_cell_noise_vec3_3',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec4'\n  }]\n});\nconst mx_cell_noise_vec3 = /*@__PURE__*/overloadingFn([mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3]);\nconst mx_fractal_noise_float$1 = /*@__PURE__*/Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {\n  const diminish = float(diminish_immutable).toVar();\n  const lacunarity = float(lacunarity_immutable).toVar();\n  const octaves = int(octaves_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const result = float(0.0).toVar();\n  const amplitude = float(1.0).toVar();\n  Loop(octaves, () => {\n    result.addAssign(amplitude.mul(mx_perlin_noise_float(p)));\n    amplitude.mulAssign(diminish);\n    p.mulAssign(lacunarity);\n  });\n  return result;\n}).setLayout({\n  name: 'mx_fractal_noise_float',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'octaves',\n    type: 'int'\n  }, {\n    name: 'lacunarity',\n    type: 'float'\n  }, {\n    name: 'diminish',\n    type: 'float'\n  }]\n});\nconst mx_fractal_noise_vec3$1 = /*@__PURE__*/Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {\n  const diminish = float(diminish_immutable).toVar();\n  const lacunarity = float(lacunarity_immutable).toVar();\n  const octaves = int(octaves_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const result = vec3(0.0).toVar();\n  const amplitude = float(1.0).toVar();\n  Loop(octaves, () => {\n    result.addAssign(amplitude.mul(mx_perlin_noise_vec3(p)));\n    amplitude.mulAssign(diminish);\n    p.mulAssign(lacunarity);\n  });\n  return result;\n}).setLayout({\n  name: 'mx_fractal_noise_vec3',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'octaves',\n    type: 'int'\n  }, {\n    name: 'lacunarity',\n    type: 'float'\n  }, {\n    name: 'diminish',\n    type: 'float'\n  }]\n});\nconst mx_fractal_noise_vec2$1 = /*@__PURE__*/Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {\n  const diminish = float(diminish_immutable).toVar();\n  const lacunarity = float(lacunarity_immutable).toVar();\n  const octaves = int(octaves_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  return vec2(mx_fractal_noise_float$1(p, octaves, lacunarity, diminish), mx_fractal_noise_float$1(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish));\n}).setLayout({\n  name: 'mx_fractal_noise_vec2',\n  type: 'vec2',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'octaves',\n    type: 'int'\n  }, {\n    name: 'lacunarity',\n    type: 'float'\n  }, {\n    name: 'diminish',\n    type: 'float'\n  }]\n});\nconst mx_fractal_noise_vec4$1 = /*@__PURE__*/Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {\n  const diminish = float(diminish_immutable).toVar();\n  const lacunarity = float(lacunarity_immutable).toVar();\n  const octaves = int(octaves_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const c = vec3(mx_fractal_noise_vec3$1(p, octaves, lacunarity, diminish)).toVar();\n  const f = float(mx_fractal_noise_float$1(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish)).toVar();\n  return vec4(c, f);\n}).setLayout({\n  name: 'mx_fractal_noise_vec4',\n  type: 'vec4',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'octaves',\n    type: 'int'\n  }, {\n    name: 'lacunarity',\n    type: 'float'\n  }, {\n    name: 'diminish',\n    type: 'float'\n  }]\n});\nconst mx_worley_distance_0 = /*@__PURE__*/Fn(([p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const yoff = int(yoff_immutable).toVar();\n  const xoff = int(xoff_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const p = vec2(p_immutable).toVar();\n  const tmp = vec3(mx_cell_noise_vec3(vec2(x.add(xoff), y.add(yoff)))).toVar();\n  const off = vec2(tmp.x, tmp.y).toVar();\n  off.subAssign(0.5);\n  off.mulAssign(jitter);\n  off.addAssign(0.5);\n  const cellpos = vec2(vec2(float(x), float(y)).add(off)).toVar();\n  const diff = vec2(cellpos.sub(p)).toVar();\n  If(metric.equal(int(2)), () => {\n    return abs(diff.x).add(abs(diff.y));\n  });\n  If(metric.equal(int(3)), () => {\n    return max$1(abs(diff.x), abs(diff.y));\n  });\n  return dot(diff, diff);\n}).setLayout({\n  name: 'mx_worley_distance_0',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }, {\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'xoff',\n    type: 'int'\n  }, {\n    name: 'yoff',\n    type: 'int'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_distance_1 = /*@__PURE__*/Fn(([p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const zoff = int(zoff_immutable).toVar();\n  const yoff = int(yoff_immutable).toVar();\n  const xoff = int(xoff_immutable).toVar();\n  const z = int(z_immutable).toVar();\n  const y = int(y_immutable).toVar();\n  const x = int(x_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const off = vec3(mx_cell_noise_vec3(vec3(x.add(xoff), y.add(yoff), z.add(zoff)))).toVar();\n  off.subAssign(0.5);\n  off.mulAssign(jitter);\n  off.addAssign(0.5);\n  const cellpos = vec3(vec3(float(x), float(y), float(z)).add(off)).toVar();\n  const diff = vec3(cellpos.sub(p)).toVar();\n  If(metric.equal(int(2)), () => {\n    return abs(diff.x).add(abs(diff.y)).add(abs(diff.z));\n  });\n  If(metric.equal(int(3)), () => {\n    return max$1(max$1(abs(diff.x), abs(diff.y)), abs(diff.z));\n  });\n  return dot(diff, diff);\n}).setLayout({\n  name: 'mx_worley_distance_1',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'x',\n    type: 'int'\n  }, {\n    name: 'y',\n    type: 'int'\n  }, {\n    name: 'z',\n    type: 'int'\n  }, {\n    name: 'xoff',\n    type: 'int'\n  }, {\n    name: 'yoff',\n    type: 'int'\n  }, {\n    name: 'zoff',\n    type: 'int'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_distance = /*@__PURE__*/overloadingFn([mx_worley_distance_0, mx_worley_distance_1]);\nconst mx_worley_noise_float_0 = /*@__PURE__*/Fn(([p_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();\n  const sqdist = float(1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, ({\n    x\n  }) => {\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, ({\n      y\n    }) => {\n      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();\n      sqdist.assign(min$1(sqdist, dist));\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_float_0',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_vec2_0 = /*@__PURE__*/Fn(([p_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();\n  const sqdist = vec2(1e6, 1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, ({\n    x\n  }) => {\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, ({\n      y\n    }) => {\n      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();\n      If(dist.lessThan(sqdist.x), () => {\n        sqdist.y.assign(sqdist.x);\n        sqdist.x.assign(dist);\n      }).ElseIf(dist.lessThan(sqdist.y), () => {\n        sqdist.y.assign(dist);\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_vec2_0',\n  type: 'vec2',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_vec3_0 = /*@__PURE__*/Fn(([p_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec2(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar();\n  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();\n  const sqdist = vec3(1e6, 1e6, 1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, ({\n    x\n  }) => {\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, ({\n      y\n    }) => {\n      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();\n      If(dist.lessThan(sqdist.x), () => {\n        sqdist.z.assign(sqdist.y);\n        sqdist.y.assign(sqdist.x);\n        sqdist.x.assign(dist);\n      }).ElseIf(dist.lessThan(sqdist.y), () => {\n        sqdist.z.assign(sqdist.y);\n        sqdist.y.assign(dist);\n      }).ElseIf(dist.lessThan(sqdist.z), () => {\n        sqdist.z.assign(dist);\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_vec3_0',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec2'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_float_1 = /*@__PURE__*/Fn(([p_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();\n  const sqdist = float(1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, ({\n    x\n  }) => {\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, ({\n      y\n    }) => {\n      Loop({\n        start: -1,\n        end: int(1),\n        name: 'z',\n        condition: '<='\n      }, ({\n        z\n      }) => {\n        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();\n        sqdist.assign(min$1(sqdist, dist));\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_float_1',\n  type: 'float',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_float$1 = /*@__PURE__*/overloadingFn([mx_worley_noise_float_0, mx_worley_noise_float_1]);\nconst mx_worley_noise_vec2_1 = /*@__PURE__*/Fn(([p_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();\n  const sqdist = vec2(1e6, 1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, ({\n    x\n  }) => {\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, ({\n      y\n    }) => {\n      Loop({\n        start: -1,\n        end: int(1),\n        name: 'z',\n        condition: '<='\n      }, ({\n        z\n      }) => {\n        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();\n        If(dist.lessThan(sqdist.x), () => {\n          sqdist.y.assign(sqdist.x);\n          sqdist.x.assign(dist);\n        }).ElseIf(dist.lessThan(sqdist.y), () => {\n          sqdist.y.assign(dist);\n        });\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_vec2_1',\n  type: 'vec2',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_vec2$1 = /*@__PURE__*/overloadingFn([mx_worley_noise_vec2_0, mx_worley_noise_vec2_1]);\nconst mx_worley_noise_vec3_1 = /*@__PURE__*/Fn(([p_immutable, jitter_immutable, metric_immutable]) => {\n  const metric = int(metric_immutable).toVar();\n  const jitter = float(jitter_immutable).toVar();\n  const p = vec3(p_immutable).toVar();\n  const X = int().toVar(),\n    Y = int().toVar(),\n    Z = int().toVar();\n  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();\n  const sqdist = vec3(1e6, 1e6, 1e6).toVar();\n  Loop({\n    start: -1,\n    end: int(1),\n    name: 'x',\n    condition: '<='\n  }, ({\n    x\n  }) => {\n    Loop({\n      start: -1,\n      end: int(1),\n      name: 'y',\n      condition: '<='\n    }, ({\n      y\n    }) => {\n      Loop({\n        start: -1,\n        end: int(1),\n        name: 'z',\n        condition: '<='\n      }, ({\n        z\n      }) => {\n        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();\n        If(dist.lessThan(sqdist.x), () => {\n          sqdist.z.assign(sqdist.y);\n          sqdist.y.assign(sqdist.x);\n          sqdist.x.assign(dist);\n        }).ElseIf(dist.lessThan(sqdist.y), () => {\n          sqdist.z.assign(sqdist.y);\n          sqdist.y.assign(dist);\n        }).ElseIf(dist.lessThan(sqdist.z), () => {\n          sqdist.z.assign(dist);\n        });\n      });\n    });\n  });\n  If(metric.equal(int(0)), () => {\n    sqdist.assign(sqrt(sqdist));\n  });\n  return sqdist;\n}).setLayout({\n  name: 'mx_worley_noise_vec3_1',\n  type: 'vec3',\n  inputs: [{\n    name: 'p',\n    type: 'vec3'\n  }, {\n    name: 'jitter',\n    type: 'float'\n  }, {\n    name: 'metric',\n    type: 'int'\n  }]\n});\nconst mx_worley_noise_vec3$1 = /*@__PURE__*/overloadingFn([mx_worley_noise_vec3_0, mx_worley_noise_vec3_1]);\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl\n\nconst mx_hsvtorgb = /*@__PURE__*/Fn(([hsv]) => {\n  const s = hsv.y;\n  const v = hsv.z;\n  const result = vec3().toVar();\n  If(s.lessThan(0.0001), () => {\n    result.assign(vec3(v, v, v));\n  }).Else(() => {\n    let h = hsv.x;\n    h = h.sub(floor(h)).mul(6.0).toVar(); // TODO: check what .toVar() is needed in node system cache\n    const hi = int(trunc(h));\n    const f = h.sub(float(hi));\n    const p = v.mul(s.oneMinus());\n    const q = v.mul(s.mul(f).oneMinus());\n    const t = v.mul(s.mul(f.oneMinus()).oneMinus());\n    If(hi.equal(int(0)), () => {\n      result.assign(vec3(v, t, p));\n    }).ElseIf(hi.equal(int(1)), () => {\n      result.assign(vec3(q, v, p));\n    }).ElseIf(hi.equal(int(2)), () => {\n      result.assign(vec3(p, v, t));\n    }).ElseIf(hi.equal(int(3)), () => {\n      result.assign(vec3(p, q, v));\n    }).ElseIf(hi.equal(int(4)), () => {\n      result.assign(vec3(t, p, v));\n    }).Else(() => {\n      result.assign(vec3(v, p, q));\n    });\n  });\n  return result;\n}).setLayout({\n  name: 'mx_hsvtorgb',\n  type: 'vec3',\n  inputs: [{\n    name: 'hsv',\n    type: 'vec3'\n  }]\n});\nconst mx_rgbtohsv = /*@__PURE__*/Fn(([c_immutable]) => {\n  const c = vec3(c_immutable).toVar();\n  const r = float(c.x).toVar();\n  const g = float(c.y).toVar();\n  const b = float(c.z).toVar();\n  const mincomp = float(min$1(r, min$1(g, b))).toVar();\n  const maxcomp = float(max$1(r, max$1(g, b))).toVar();\n  const delta = float(maxcomp.sub(mincomp)).toVar();\n  const h = float().toVar(),\n    s = float().toVar(),\n    v = float().toVar();\n  v.assign(maxcomp);\n  If(maxcomp.greaterThan(0.0), () => {\n    s.assign(delta.div(maxcomp));\n  }).Else(() => {\n    s.assign(0.0);\n  });\n  If(s.lessThanEqual(0.0), () => {\n    h.assign(0.0);\n  }).Else(() => {\n    If(r.greaterThanEqual(maxcomp), () => {\n      h.assign(g.sub(b).div(delta));\n    }).ElseIf(g.greaterThanEqual(maxcomp), () => {\n      h.assign(add(2.0, b.sub(r).div(delta)));\n    }).Else(() => {\n      h.assign(add(4.0, r.sub(g).div(delta)));\n    });\n    h.mulAssign(1.0 / 6.0);\n    If(h.lessThan(0.0), () => {\n      h.addAssign(1.0);\n    });\n  });\n  return vec3(h, s, v);\n}).setLayout({\n  name: 'mx_rgbtohsv',\n  type: 'vec3',\n  inputs: [{\n    name: 'c',\n    type: 'vec3'\n  }]\n});\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl\n\nconst mx_srgb_texture_to_lin_rec709 = /*@__PURE__*/Fn(([color_immutable]) => {\n  const color = vec3(color_immutable).toVar();\n  const isAbove = bvec3(greaterThan(color, vec3(0.04045))).toVar();\n  const linSeg = vec3(color.div(12.92)).toVar();\n  const powSeg = vec3(pow(max$1(color.add(vec3(0.055)), vec3(0.0)).div(1.055), vec3(2.4))).toVar();\n  return mix(linSeg, powSeg, isAbove);\n}).setLayout({\n  name: 'mx_srgb_texture_to_lin_rec709',\n  type: 'vec3',\n  inputs: [{\n    name: 'color',\n    type: 'vec3'\n  }]\n});\nconst mx_aastep = (threshold, value) => {\n  threshold = float(threshold);\n  value = float(value);\n  const afwidth = vec2(value.dFdx(), value.dFdy()).length().mul(0.70710678118654757);\n  return smoothstep(threshold.sub(afwidth), threshold.add(afwidth), value);\n};\nconst _ramp = (a, b, uv, p) => mix(a, b, uv[p].clamp());\nconst mx_ramplr = (valuel, valuer, texcoord = uv()) => _ramp(valuel, valuer, texcoord, 'x');\nconst mx_ramptb = (valuet, valueb, texcoord = uv()) => _ramp(valuet, valueb, texcoord, 'y');\nconst _split = (a, b, center, uv, p) => mix(a, b, mx_aastep(center, uv[p]));\nconst mx_splitlr = (valuel, valuer, center, texcoord = uv()) => _split(valuel, valuer, center, texcoord, 'x');\nconst mx_splittb = (valuet, valueb, center, texcoord = uv()) => _split(valuet, valueb, center, texcoord, 'y');\nconst mx_transform_uv = (uv_scale = 1, uv_offset = 0, uv_geo = uv()) => uv_geo.mul(uv_scale).add(uv_offset);\nconst mx_safepower = (in1, in2 = 1) => {\n  in1 = float(in1);\n  return in1.abs().pow(in2).mul(in1.sign());\n};\nconst mx_contrast = (input, amount = 1, pivot = .5) => float(input).sub(pivot).mul(amount).add(pivot);\nconst mx_noise_float = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_float(texcoord.convert('vec2|vec3')).mul(amplitude).add(pivot);\n//export const mx_noise_vec2 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\nconst mx_noise_vec3 = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_vec3(texcoord.convert('vec2|vec3')).mul(amplitude).add(pivot);\nconst mx_noise_vec4 = (texcoord = uv(), amplitude = 1, pivot = 0) => {\n  texcoord = texcoord.convert('vec2|vec3'); // overloading type\n\n  const noise_vec4 = vec4(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(texcoord.add(vec2(19, 73))));\n  return noise_vec4.mul(amplitude).add(pivot);\n};\nconst mx_worley_noise_float = (texcoord = uv(), jitter = 1) => mx_worley_noise_float$1(texcoord.convert('vec2|vec3'), jitter, int(1));\nconst mx_worley_noise_vec2 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec2$1(texcoord.convert('vec2|vec3'), jitter, int(1));\nconst mx_worley_noise_vec3 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec3$1(texcoord.convert('vec2|vec3'), jitter, int(1));\nconst mx_cell_noise_float = (texcoord = uv()) => mx_cell_noise_float$1(texcoord.convert('vec2|vec3'));\nconst mx_fractal_noise_float = (position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_float$1(position, int(octaves), lacunarity, diminish).mul(amplitude);\nconst mx_fractal_noise_vec2 = (position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_vec2$1(position, int(octaves), lacunarity, diminish).mul(amplitude);\nconst mx_fractal_noise_vec3 = (position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_vec3$1(position, int(octaves), lacunarity, diminish).mul(amplitude);\nconst mx_fractal_noise_vec4 = (position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1) => mx_fractal_noise_vec4$1(position, int(octaves), lacunarity, diminish).mul(amplitude);\n\n// https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html\n\nconst getParallaxCorrectNormal = /*@__PURE__*/Fn(([normal, cubeSize, cubePos]) => {\n  const nDir = normalize(normal).toVar('nDir');\n  const rbmax = sub(float(0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar('rbmax');\n  const rbmin = sub(float(-0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar('rbmin');\n  const rbminmax = vec3().toVar('rbminmax');\n  rbminmax.x = nDir.x.greaterThan(float(0)).select(rbmax.x, rbmin.x);\n  rbminmax.y = nDir.y.greaterThan(float(0)).select(rbmax.y, rbmin.y);\n  rbminmax.z = nDir.z.greaterThan(float(0)).select(rbmax.z, rbmin.z);\n  const correction = min$1(min$1(rbminmax.x, rbminmax.y), rbminmax.z).toVar('correction');\n  const boxIntersection = positionWorld.add(nDir.mul(correction)).toVar('boxIntersection');\n  return boxIntersection.sub(cubePos);\n});\nconst getShIrradianceAt = /*@__PURE__*/Fn(([normal, shCoefficients]) => {\n  // normal is assumed to have unit length\n\n  const x = normal.x,\n    y = normal.y,\n    z = normal.z;\n\n  // band 0\n  let result = shCoefficients.element(0).mul(0.886227);\n\n  // band 1\n  result = result.add(shCoefficients.element(1).mul(2.0 * 0.511664).mul(y));\n  result = result.add(shCoefficients.element(2).mul(2.0 * 0.511664).mul(z));\n  result = result.add(shCoefficients.element(3).mul(2.0 * 0.511664).mul(x));\n\n  // band 2\n  result = result.add(shCoefficients.element(4).mul(2.0 * 0.429043).mul(x).mul(y));\n  result = result.add(shCoefficients.element(5).mul(2.0 * 0.429043).mul(y).mul(z));\n  result = result.add(shCoefficients.element(6).mul(z.mul(z).mul(0.743125).sub(0.247708)));\n  result = result.add(shCoefficients.element(7).mul(2.0 * 0.429043).mul(x).mul(z));\n  result = result.add(shCoefficients.element(8).mul(0.429043).mul(mul(x, x).sub(mul(y, y))));\n  return result;\n});\n\n// constants\n\nvar TSL = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  BRDF_GGX: BRDF_GGX,\n  BRDF_Lambert: BRDF_Lambert,\n  BasicShadowFilter: BasicShadowFilter,\n  Break: Break,\n  Continue: Continue,\n  DFGApprox: DFGApprox,\n  D_GGX: D_GGX,\n  Discard: Discard,\n  EPSILON: EPSILON,\n  F_Schlick: F_Schlick,\n  Fn: Fn,\n  INFINITY: INFINITY,\n  If: If,\n  Loop: Loop,\n  NodeAccess: NodeAccess,\n  NodeShaderStage: NodeShaderStage,\n  NodeType: NodeType,\n  NodeUpdateType: NodeUpdateType,\n  PCFShadowFilter: PCFShadowFilter,\n  PCFSoftShadowFilter: PCFSoftShadowFilter,\n  PI: PI,\n  PI2: PI2,\n  Return: Return,\n  Schlick_to_F0: Schlick_to_F0,\n  ScriptableNodeResources: ScriptableNodeResources,\n  ShaderNode: ShaderNode,\n  TBNViewMatrix: TBNViewMatrix,\n  VSMShadowFilter: VSMShadowFilter,\n  V_GGX_SmithCorrelated: V_GGX_SmithCorrelated,\n  abs: abs,\n  acesFilmicToneMapping: acesFilmicToneMapping,\n  acos: acos,\n  add: add,\n  addMethodChaining: addMethodChaining,\n  addNodeElement: addNodeElement,\n  agxToneMapping: agxToneMapping,\n  all: all,\n  alphaT: alphaT,\n  and: and,\n  anisotropy: anisotropy,\n  anisotropyB: anisotropyB,\n  anisotropyT: anisotropyT,\n  any: any,\n  append: append,\n  arrayBuffer: arrayBuffer,\n  asin: asin,\n  assign: assign,\n  atan: atan,\n  atan2: atan2,\n  atomicAdd: atomicAdd,\n  atomicAnd: atomicAnd,\n  atomicFunc: atomicFunc,\n  atomicMax: atomicMax,\n  atomicMin: atomicMin,\n  atomicOr: atomicOr,\n  atomicStore: atomicStore,\n  atomicSub: atomicSub,\n  atomicXor: atomicXor,\n  attenuationColor: attenuationColor,\n  attenuationDistance: attenuationDistance,\n  attribute: attribute,\n  attributeArray: attributeArray,\n  backgroundBlurriness: backgroundBlurriness,\n  backgroundIntensity: backgroundIntensity,\n  backgroundRotation: backgroundRotation,\n  batch: batch,\n  billboarding: billboarding,\n  bitAnd: bitAnd,\n  bitNot: bitNot,\n  bitOr: bitOr,\n  bitXor: bitXor,\n  bitangentGeometry: bitangentGeometry,\n  bitangentLocal: bitangentLocal,\n  bitangentView: bitangentView,\n  bitangentWorld: bitangentWorld,\n  bitcast: bitcast,\n  blendBurn: blendBurn,\n  blendColor: blendColor,\n  blendDodge: blendDodge,\n  blendOverlay: blendOverlay,\n  blendScreen: blendScreen,\n  blur: blur,\n  bool: bool,\n  buffer: buffer,\n  bufferAttribute: bufferAttribute,\n  bumpMap: bumpMap,\n  burn: burn,\n  bvec2: bvec2,\n  bvec3: bvec3,\n  bvec4: bvec4,\n  bypass: bypass,\n  cache: cache,\n  call: call,\n  cameraFar: cameraFar,\n  cameraNear: cameraNear,\n  cameraNormalMatrix: cameraNormalMatrix,\n  cameraPosition: cameraPosition,\n  cameraProjectionMatrix: cameraProjectionMatrix,\n  cameraProjectionMatrixInverse: cameraProjectionMatrixInverse,\n  cameraViewMatrix: cameraViewMatrix,\n  cameraWorldMatrix: cameraWorldMatrix,\n  cbrt: cbrt,\n  cdl: cdl,\n  ceil: ceil,\n  checker: checker,\n  cineonToneMapping: cineonToneMapping,\n  clamp: clamp,\n  clearcoat: clearcoat,\n  clearcoatRoughness: clearcoatRoughness,\n  code: code,\n  color: color,\n  colorSpaceToWorking: colorSpaceToWorking,\n  colorToDirection: colorToDirection,\n  compute: compute,\n  cond: cond,\n  context: context,\n  convert: convert,\n  convertColorSpace: convertColorSpace,\n  convertToTexture: convertToTexture,\n  cos: cos,\n  cross: cross,\n  cubeTexture: cubeTexture,\n  dFdx: dFdx,\n  dFdy: dFdy,\n  dashSize: dashSize,\n  defaultBuildStages: defaultBuildStages,\n  defaultShaderStages: defaultShaderStages,\n  defined: defined,\n  degrees: degrees,\n  deltaTime: deltaTime,\n  densityFog: densityFog,\n  depth: depth,\n  depthPass: depthPass,\n  difference: difference,\n  diffuseColor: diffuseColor,\n  directPointLight: directPointLight,\n  directionToColor: directionToColor,\n  dispersion: dispersion,\n  distance: distance,\n  div: div,\n  dodge: dodge,\n  dot: dot,\n  drawIndex: drawIndex,\n  dynamicBufferAttribute: dynamicBufferAttribute,\n  element: element,\n  emissive: emissive,\n  equal: equal,\n  equals: equals,\n  equirectUV: equirectUV,\n  exp: exp,\n  exp2: exp2,\n  expression: expression,\n  faceDirection: faceDirection,\n  faceForward: faceForward,\n  float: float,\n  floor: floor,\n  fog: fog,\n  fract: fract,\n  frameGroup: frameGroup,\n  frameId: frameId,\n  frontFacing: frontFacing,\n  fwidth: fwidth,\n  gain: gain,\n  gapSize: gapSize,\n  getConstNodeType: getConstNodeType,\n  getCurrentStack: getCurrentStack,\n  getDirection: getDirection,\n  getDistanceAttenuation: getDistanceAttenuation,\n  getGeometryRoughness: getGeometryRoughness,\n  getNormalFromDepth: getNormalFromDepth,\n  getParallaxCorrectNormal: getParallaxCorrectNormal,\n  getRoughness: getRoughness,\n  getScreenPosition: getScreenPosition,\n  getShIrradianceAt: getShIrradianceAt,\n  getTextureIndex: getTextureIndex,\n  getViewPosition: getViewPosition,\n  glsl: glsl,\n  glslFn: glslFn,\n  grayscale: grayscale,\n  greaterThan: greaterThan,\n  greaterThanEqual: greaterThanEqual,\n  hash: hash,\n  highPrecisionModelNormalViewMatrix: highPrecisionModelNormalViewMatrix,\n  highPrecisionModelViewMatrix: highPrecisionModelViewMatrix,\n  hue: hue,\n  instance: instance,\n  instanceIndex: instanceIndex,\n  instancedArray: instancedArray,\n  instancedBufferAttribute: instancedBufferAttribute,\n  instancedDynamicBufferAttribute: instancedDynamicBufferAttribute,\n  instancedMesh: instancedMesh,\n  int: int,\n  inverseSqrt: inverseSqrt,\n  invocationLocalIndex: invocationLocalIndex,\n  invocationSubgroupIndex: invocationSubgroupIndex,\n  ior: ior,\n  iridescence: iridescence,\n  iridescenceIOR: iridescenceIOR,\n  iridescenceThickness: iridescenceThickness,\n  ivec2: ivec2,\n  ivec3: ivec3,\n  ivec4: ivec4,\n  js: js,\n  label: label,\n  length: length,\n  lengthSq: lengthSq,\n  lessThan: lessThan,\n  lessThanEqual: lessThanEqual,\n  lightPosition: lightPosition,\n  lightProjectionUV: lightProjectionUV,\n  lightShadowMatrix: lightShadowMatrix,\n  lightTargetDirection: lightTargetDirection,\n  lightTargetPosition: lightTargetPosition,\n  lightViewPosition: lightViewPosition,\n  lightingContext: lightingContext,\n  lights: lights,\n  linearDepth: linearDepth,\n  linearToneMapping: linearToneMapping,\n  localId: localId,\n  log: log,\n  log2: log2,\n  logarithmicDepthToViewZ: logarithmicDepthToViewZ,\n  loop: loop,\n  luminance: luminance,\n  mat2: mat2,\n  mat3: mat3,\n  mat4: mat4,\n  matcapUV: matcapUV,\n  materialAOMap: materialAOMap,\n  materialAlphaTest: materialAlphaTest,\n  materialAnisotropy: materialAnisotropy,\n  materialAnisotropyVector: materialAnisotropyVector,\n  materialAttenuationColor: materialAttenuationColor,\n  materialAttenuationDistance: materialAttenuationDistance,\n  materialClearcoat: materialClearcoat,\n  materialClearcoatNormal: materialClearcoatNormal,\n  materialClearcoatRoughness: materialClearcoatRoughness,\n  materialColor: materialColor,\n  materialDispersion: materialDispersion,\n  materialEmissive: materialEmissive,\n  materialIOR: materialIOR,\n  materialIridescence: materialIridescence,\n  materialIridescenceIOR: materialIridescenceIOR,\n  materialIridescenceThickness: materialIridescenceThickness,\n  materialLightMap: materialLightMap,\n  materialLineDashOffset: materialLineDashOffset,\n  materialLineDashSize: materialLineDashSize,\n  materialLineGapSize: materialLineGapSize,\n  materialLineScale: materialLineScale,\n  materialLineWidth: materialLineWidth,\n  materialMetalness: materialMetalness,\n  materialNormal: materialNormal,\n  materialOpacity: materialOpacity,\n  materialPointWidth: materialPointWidth,\n  materialReference: materialReference,\n  materialReflectivity: materialReflectivity,\n  materialRefractionRatio: materialRefractionRatio,\n  materialRotation: materialRotation,\n  materialRoughness: materialRoughness,\n  materialSheen: materialSheen,\n  materialSheenRoughness: materialSheenRoughness,\n  materialShininess: materialShininess,\n  materialSpecular: materialSpecular,\n  materialSpecularColor: materialSpecularColor,\n  materialSpecularIntensity: materialSpecularIntensity,\n  materialSpecularStrength: materialSpecularStrength,\n  materialThickness: materialThickness,\n  materialTransmission: materialTransmission,\n  max: max$1,\n  maxMipLevel: maxMipLevel,\n  metalness: metalness,\n  min: min$1,\n  mix: mix,\n  mixElement: mixElement,\n  mod: mod,\n  modInt: modInt,\n  modelDirection: modelDirection,\n  modelNormalMatrix: modelNormalMatrix,\n  modelPosition: modelPosition,\n  modelScale: modelScale,\n  modelViewMatrix: modelViewMatrix,\n  modelViewPosition: modelViewPosition,\n  modelViewProjection: modelViewProjection,\n  modelWorldMatrix: modelWorldMatrix,\n  modelWorldMatrixInverse: modelWorldMatrixInverse,\n  morphReference: morphReference,\n  mrt: mrt,\n  mul: mul,\n  mx_aastep: mx_aastep,\n  mx_cell_noise_float: mx_cell_noise_float,\n  mx_contrast: mx_contrast,\n  mx_fractal_noise_float: mx_fractal_noise_float,\n  mx_fractal_noise_vec2: mx_fractal_noise_vec2,\n  mx_fractal_noise_vec3: mx_fractal_noise_vec3,\n  mx_fractal_noise_vec4: mx_fractal_noise_vec4,\n  mx_hsvtorgb: mx_hsvtorgb,\n  mx_noise_float: mx_noise_float,\n  mx_noise_vec3: mx_noise_vec3,\n  mx_noise_vec4: mx_noise_vec4,\n  mx_ramplr: mx_ramplr,\n  mx_ramptb: mx_ramptb,\n  mx_rgbtohsv: mx_rgbtohsv,\n  mx_safepower: mx_safepower,\n  mx_splitlr: mx_splitlr,\n  mx_splittb: mx_splittb,\n  mx_srgb_texture_to_lin_rec709: mx_srgb_texture_to_lin_rec709,\n  mx_transform_uv: mx_transform_uv,\n  mx_worley_noise_float: mx_worley_noise_float,\n  mx_worley_noise_vec2: mx_worley_noise_vec2,\n  mx_worley_noise_vec3: mx_worley_noise_vec3,\n  negate: negate,\n  neutralToneMapping: neutralToneMapping,\n  nodeArray: nodeArray,\n  nodeImmutable: nodeImmutable,\n  nodeObject: nodeObject,\n  nodeObjects: nodeObjects,\n  nodeProxy: nodeProxy,\n  normalFlat: normalFlat,\n  normalGeometry: normalGeometry,\n  normalLocal: normalLocal,\n  normalMap: normalMap,\n  normalView: normalView,\n  normalWorld: normalWorld,\n  normalize: normalize,\n  not: not,\n  notEqual: notEqual,\n  numWorkgroups: numWorkgroups,\n  objectDirection: objectDirection,\n  objectGroup: objectGroup,\n  objectPosition: objectPosition,\n  objectScale: objectScale,\n  objectViewPosition: objectViewPosition,\n  objectWorldMatrix: objectWorldMatrix,\n  oneMinus: oneMinus,\n  or: or,\n  orthographicDepthToViewZ: orthographicDepthToViewZ,\n  oscSawtooth: oscSawtooth,\n  oscSine: oscSine,\n  oscSquare: oscSquare,\n  oscTriangle: oscTriangle,\n  output: output,\n  outputStruct: outputStruct,\n  overlay: overlay,\n  overloadingFn: overloadingFn,\n  parabola: parabola,\n  parallaxDirection: parallaxDirection,\n  parallaxUV: parallaxUV,\n  parameter: parameter,\n  pass: pass,\n  passTexture: passTexture,\n  pcurve: pcurve,\n  perspectiveDepthToViewZ: perspectiveDepthToViewZ,\n  pmremTexture: pmremTexture,\n  pointUV: pointUV,\n  pointWidth: pointWidth,\n  positionGeometry: positionGeometry,\n  positionLocal: positionLocal,\n  positionPrevious: positionPrevious,\n  positionView: positionView,\n  positionViewDirection: positionViewDirection,\n  positionWorld: positionWorld,\n  positionWorldDirection: positionWorldDirection,\n  posterize: posterize,\n  pow: pow,\n  pow2: pow2,\n  pow3: pow3,\n  pow4: pow4,\n  property: property,\n  radians: radians,\n  rand: rand,\n  range: range,\n  rangeFog: rangeFog,\n  reciprocal: reciprocal,\n  reference: reference,\n  referenceBuffer: referenceBuffer,\n  reflect: reflect,\n  reflectVector: reflectVector,\n  reflectView: reflectView,\n  reflector: reflector,\n  refract: refract,\n  refractVector: refractVector,\n  refractView: refractView,\n  reinhardToneMapping: reinhardToneMapping,\n  remainder: remainder,\n  remap: remap,\n  remapClamp: remapClamp,\n  renderGroup: renderGroup,\n  renderOutput: renderOutput,\n  rendererReference: rendererReference,\n  rotate: rotate,\n  rotateUV: rotateUV,\n  roughness: roughness,\n  round: round,\n  rtt: rtt,\n  sRGBTransferEOTF: sRGBTransferEOTF,\n  sRGBTransferOETF: sRGBTransferOETF,\n  sampler: sampler,\n  saturate: saturate,\n  saturation: saturation,\n  screen: screen,\n  screenCoordinate: screenCoordinate,\n  screenSize: screenSize,\n  screenUV: screenUV,\n  scriptable: scriptable,\n  scriptableValue: scriptableValue,\n  select: select,\n  setCurrentStack: setCurrentStack,\n  shaderStages: shaderStages,\n  shadow: shadow,\n  sharedUniformGroup: sharedUniformGroup,\n  sheen: sheen,\n  sheenRoughness: sheenRoughness,\n  shiftLeft: shiftLeft,\n  shiftRight: shiftRight,\n  shininess: shininess,\n  sign: sign,\n  sin: sin,\n  sinc: sinc,\n  skinning: skinning,\n  skinningReference: skinningReference,\n  smoothstep: smoothstep,\n  smoothstepElement: smoothstepElement,\n  specularColor: specularColor,\n  specularF90: specularF90,\n  spherizeUV: spherizeUV,\n  split: split,\n  spritesheetUV: spritesheetUV,\n  sqrt: sqrt,\n  stack: stack,\n  step: step,\n  storage: storage,\n  storageBarrier: storageBarrier,\n  storageObject: storageObject,\n  storageTexture: storageTexture,\n  string: string,\n  sub: sub,\n  subgroupIndex: subgroupIndex,\n  subgroupSize: subgroupSize,\n  tan: tan,\n  tangentGeometry: tangentGeometry,\n  tangentLocal: tangentLocal,\n  tangentView: tangentView,\n  tangentWorld: tangentWorld,\n  temp: temp,\n  texture: texture,\n  texture3D: texture3D,\n  textureBarrier: textureBarrier,\n  textureBicubic: textureBicubic,\n  textureCubeUV: textureCubeUV,\n  textureLoad: textureLoad,\n  textureSize: textureSize,\n  textureStore: textureStore,\n  thickness: thickness,\n  threshold: threshold,\n  time: time,\n  timerDelta: timerDelta,\n  timerGlobal: timerGlobal,\n  timerLocal: timerLocal,\n  toOutputColorSpace: toOutputColorSpace,\n  toWorkingColorSpace: toWorkingColorSpace,\n  toneMapping: toneMapping,\n  toneMappingExposure: toneMappingExposure,\n  toonOutlinePass: toonOutlinePass,\n  transformDirection: transformDirection,\n  transformNormal: transformNormal,\n  transformNormalToView: transformNormalToView,\n  transformedBentNormalView: transformedBentNormalView,\n  transformedBitangentView: transformedBitangentView,\n  transformedBitangentWorld: transformedBitangentWorld,\n  transformedClearcoatNormalView: transformedClearcoatNormalView,\n  transformedNormalView: transformedNormalView,\n  transformedNormalWorld: transformedNormalWorld,\n  transformedTangentView: transformedTangentView,\n  transformedTangentWorld: transformedTangentWorld,\n  transmission: transmission,\n  transpose: transpose,\n  tri: tri,\n  tri3: tri3,\n  triNoise3D: triNoise3D,\n  triplanarTexture: triplanarTexture,\n  triplanarTextures: triplanarTextures,\n  trunc: trunc,\n  tslFn: tslFn,\n  uint: uint,\n  uniform: uniform,\n  uniformArray: uniformArray,\n  uniformGroup: uniformGroup,\n  uniforms: uniforms,\n  userData: userData,\n  uv: uv,\n  uvec2: uvec2,\n  uvec3: uvec3,\n  uvec4: uvec4,\n  varying: varying,\n  varyingProperty: varyingProperty,\n  vec2: vec2,\n  vec3: vec3,\n  vec4: vec4,\n  vectorComponents: vectorComponents,\n  velocity: velocity,\n  vertexColor: vertexColor,\n  vertexIndex: vertexIndex,\n  vibrance: vibrance,\n  viewZToLogarithmicDepth: viewZToLogarithmicDepth,\n  viewZToOrthographicDepth: viewZToOrthographicDepth,\n  viewZToPerspectiveDepth: viewZToPerspectiveDepth,\n  viewport: viewport,\n  viewportBottomLeft: viewportBottomLeft,\n  viewportCoordinate: viewportCoordinate,\n  viewportDepthTexture: viewportDepthTexture,\n  viewportLinearDepth: viewportLinearDepth,\n  viewportMipTexture: viewportMipTexture,\n  viewportResolution: viewportResolution,\n  viewportSafeUV: viewportSafeUV,\n  viewportSharedTexture: viewportSharedTexture,\n  viewportSize: viewportSize,\n  viewportTexture: viewportTexture,\n  viewportTopLeft: viewportTopLeft,\n  viewportUV: viewportUV,\n  wgsl: wgsl,\n  wgslFn: wgslFn,\n  workgroupArray: workgroupArray,\n  workgroupBarrier: workgroupBarrier,\n  workgroupId: workgroupId,\n  workingToColorSpace: workingToColorSpace,\n  xor: xor\n});\nconst _clearColor$1 = /*@__PURE__*/new Color4();\nclass Background extends DataMap {\n  constructor(renderer, nodes) {\n    super();\n    this.renderer = renderer;\n    this.nodes = nodes;\n  }\n  update(scene, renderList, renderContext) {\n    const renderer = this.renderer;\n    const background = this.nodes.getBackgroundNode(scene) || scene.background;\n    let forceClear = false;\n    if (background === null) {\n      // no background settings, use clear color configuration from the renderer\n\n      renderer._clearColor.getRGB(_clearColor$1, LinearSRGBColorSpace);\n      _clearColor$1.a = renderer._clearColor.a;\n    } else if (background.isColor === true) {\n      // background is an opaque color\n\n      background.getRGB(_clearColor$1, LinearSRGBColorSpace);\n      _clearColor$1.a = 1;\n      forceClear = true;\n    } else if (background.isNode === true) {\n      const sceneData = this.get(scene);\n      const backgroundNode = background;\n      _clearColor$1.copy(renderer._clearColor);\n      let backgroundMesh = sceneData.backgroundMesh;\n      if (backgroundMesh === undefined) {\n        const backgroundMeshNode = context(vec4(backgroundNode).mul(backgroundIntensity), {\n          // @TODO: Add Texture2D support using node context\n          getUV: () => backgroundRotation.mul(normalWorld),\n          getTextureLevel: () => backgroundBlurriness\n        });\n        let viewProj = modelViewProjection();\n        viewProj = viewProj.setZ(viewProj.w);\n        const nodeMaterial = new NodeMaterial();\n        nodeMaterial.name = 'Background.material';\n        nodeMaterial.side = BackSide;\n        nodeMaterial.depthTest = false;\n        nodeMaterial.depthWrite = false;\n        nodeMaterial.fog = false;\n        nodeMaterial.lights = false;\n        nodeMaterial.vertexNode = viewProj;\n        nodeMaterial.colorNode = backgroundMeshNode;\n        sceneData.backgroundMeshNode = backgroundMeshNode;\n        sceneData.backgroundMesh = backgroundMesh = new Mesh(new SphereGeometry(1, 32, 32), nodeMaterial);\n        backgroundMesh.frustumCulled = false;\n        backgroundMesh.name = 'Background.mesh';\n        backgroundMesh.onBeforeRender = function (renderer, scene, camera) {\n          this.matrixWorld.copyPosition(camera.matrixWorld);\n        };\n      }\n      const backgroundCacheKey = backgroundNode.getCacheKey();\n      if (sceneData.backgroundCacheKey !== backgroundCacheKey) {\n        sceneData.backgroundMeshNode.node = vec4(backgroundNode).mul(backgroundIntensity);\n        sceneData.backgroundMeshNode.needsUpdate = true;\n        backgroundMesh.material.needsUpdate = true;\n        sceneData.backgroundCacheKey = backgroundCacheKey;\n      }\n      renderList.unshift(backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null);\n    } else {\n      console.error('THREE.Renderer: Unsupported background configuration.', background);\n    }\n\n    //\n\n    if (renderer.autoClear === true || forceClear === true) {\n      const clearColorValue = renderContext.clearColorValue;\n      clearColorValue.r = _clearColor$1.r;\n      clearColorValue.g = _clearColor$1.g;\n      clearColorValue.b = _clearColor$1.b;\n      clearColorValue.a = _clearColor$1.a;\n\n      // premultiply alpha\n\n      if (renderer.backend.isWebGLBackend === true || renderer.alpha === true) {\n        clearColorValue.r *= clearColorValue.a;\n        clearColorValue.g *= clearColorValue.a;\n        clearColorValue.b *= clearColorValue.a;\n      }\n\n      //\n\n      renderContext.depthClearValue = renderer._clearDepth;\n      renderContext.stencilClearValue = renderer._clearStencil;\n      renderContext.clearColor = renderer.autoClearColor === true;\n      renderContext.clearDepth = renderer.autoClearDepth === true;\n      renderContext.clearStencil = renderer.autoClearStencil === true;\n    } else {\n      renderContext.clearColor = false;\n      renderContext.clearDepth = false;\n      renderContext.clearStencil = false;\n    }\n  }\n}\nlet _id$5 = 0;\nclass BindGroup {\n  constructor(name = '', bindings = [], index = 0, bindingsReference = []) {\n    this.name = name;\n    this.bindings = bindings;\n    this.index = index;\n    this.bindingsReference = bindingsReference;\n    this.id = _id$5++;\n  }\n}\nclass NodeBuilderState {\n  constructor(vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, monitor, transforms = []) {\n    this.vertexShader = vertexShader;\n    this.fragmentShader = fragmentShader;\n    this.computeShader = computeShader;\n    this.transforms = transforms;\n    this.nodeAttributes = nodeAttributes;\n    this.bindings = bindings;\n    this.updateNodes = updateNodes;\n    this.updateBeforeNodes = updateBeforeNodes;\n    this.updateAfterNodes = updateAfterNodes;\n    this.monitor = monitor;\n    this.usedTimes = 0;\n  }\n  createBindings() {\n    const bindings = [];\n    for (const instanceGroup of this.bindings) {\n      const shared = instanceGroup.bindings[0].groupNode.shared;\n      if (shared !== true) {\n        const bindingsGroup = new BindGroup(instanceGroup.name, [], instanceGroup.index, instanceGroup);\n        bindings.push(bindingsGroup);\n        for (const instanceBinding of instanceGroup.bindings) {\n          bindingsGroup.bindings.push(instanceBinding.clone());\n        }\n      } else {\n        bindings.push(instanceGroup);\n      }\n    }\n    return bindings;\n  }\n}\nclass NodeAttribute {\n  constructor(name, type, node = null) {\n    this.isNodeAttribute = true;\n    this.name = name;\n    this.type = type;\n    this.node = node;\n  }\n}\nclass NodeUniform {\n  constructor(name, type, node) {\n    this.isNodeUniform = true;\n    this.name = name;\n    this.type = type;\n    this.node = node.getSelf();\n  }\n  get value() {\n    return this.node.value;\n  }\n  set value(val) {\n    this.node.value = val;\n  }\n  get id() {\n    return this.node.id;\n  }\n  get groupNode() {\n    return this.node.groupNode;\n  }\n}\nclass NodeVar {\n  constructor(name, type) {\n    this.isNodeVar = true;\n    this.name = name;\n    this.type = type;\n  }\n}\nclass NodeVarying extends NodeVar {\n  constructor(name, type) {\n    super(name, type);\n    this.needsInterpolation = false;\n    this.isNodeVarying = true;\n  }\n}\nclass NodeCode {\n  constructor(name, type, code = '') {\n    this.name = name;\n    this.type = type;\n    this.code = code;\n    Object.defineProperty(this, 'isNodeCode', {\n      value: true\n    });\n  }\n}\nlet id = 0;\nclass NodeCache {\n  constructor(parent = null) {\n    this.id = id++;\n    this.nodesData = new WeakMap();\n    this.parent = parent;\n  }\n  getData(node) {\n    let data = this.nodesData.get(node);\n    if (data === undefined && this.parent !== null) {\n      data = this.parent.getData(node);\n    }\n    return data;\n  }\n  setData(node, data) {\n    this.nodesData.set(node, data);\n  }\n}\nclass Uniform {\n  constructor(name, value) {\n    this.name = name;\n    this.value = value;\n    this.boundary = 0; // used to build the uniform buffer according to the STD140 layout\n    this.itemSize = 0;\n    this.offset = 0; // this property is set by WebGPUUniformsGroup and marks the start position in the uniform buffer\n  }\n  setValue(value) {\n    this.value = value;\n  }\n  getValue() {\n    return this.value;\n  }\n}\nclass NumberUniform extends Uniform {\n  constructor(name, value = 0) {\n    super(name, value);\n    this.isNumberUniform = true;\n    this.boundary = 4;\n    this.itemSize = 1;\n  }\n}\nclass Vector2Uniform extends Uniform {\n  constructor(name, value = new Vector2()) {\n    super(name, value);\n    this.isVector2Uniform = true;\n    this.boundary = 8;\n    this.itemSize = 2;\n  }\n}\nclass Vector3Uniform extends Uniform {\n  constructor(name, value = new Vector3()) {\n    super(name, value);\n    this.isVector3Uniform = true;\n    this.boundary = 16;\n    this.itemSize = 3;\n  }\n}\nclass Vector4Uniform extends Uniform {\n  constructor(name, value = new Vector4()) {\n    super(name, value);\n    this.isVector4Uniform = true;\n    this.boundary = 16;\n    this.itemSize = 4;\n  }\n}\nclass ColorUniform extends Uniform {\n  constructor(name, value = new Color()) {\n    super(name, value);\n    this.isColorUniform = true;\n    this.boundary = 16;\n    this.itemSize = 3;\n  }\n}\nclass Matrix3Uniform extends Uniform {\n  constructor(name, value = new Matrix3()) {\n    super(name, value);\n    this.isMatrix3Uniform = true;\n    this.boundary = 48;\n    this.itemSize = 12;\n  }\n}\nclass Matrix4Uniform extends Uniform {\n  constructor(name, value = new Matrix4()) {\n    super(name, value);\n    this.isMatrix4Uniform = true;\n    this.boundary = 64;\n    this.itemSize = 16;\n  }\n}\nclass NumberNodeUniform extends NumberUniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  }\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nclass Vector2NodeUniform extends Vector2Uniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  }\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nclass Vector3NodeUniform extends Vector3Uniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  }\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nclass Vector4NodeUniform extends Vector4Uniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  }\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nclass ColorNodeUniform extends ColorUniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  }\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nclass Matrix3NodeUniform extends Matrix3Uniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  }\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nclass Matrix4NodeUniform extends Matrix4Uniform {\n  constructor(nodeUniform) {\n    super(nodeUniform.name, nodeUniform.value);\n    this.nodeUniform = nodeUniform;\n  }\n  getValue() {\n    return this.nodeUniform.value;\n  }\n  getType() {\n    return this.nodeUniform.type;\n  }\n}\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\nconst _flatCamera = /*@__PURE__*/new OrthographicCamera(-1, 1, 1, -1, 0, 1);\nconst _cubeCamera = /*@__PURE__*/new PerspectiveCamera(90, 1);\nconst _clearColor = /*@__PURE__*/new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\n\n// Golden Ratio\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [/*@__PURE__*/new Vector3(-PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, 1)];\n\n//\n\n// WebGPU Face indices\nconst _faceLib = [3, 1, 5, 0, 4, 2];\nconst direction = getDirection(uv(), attribute('faceIndex')).normalize();\nconst outputDirection = vec3(direction.x, direction.y.negate(), direction.z);\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n    this._lodMax = 0;\n    this._cubeSize = 0;\n    this._lodPlanes = [];\n    this._sizeLods = [];\n    this._sigmas = [];\n    this._lodMeshes = [];\n    this._blurMaterial = null;\n    this._cubemapMaterial = null;\n    this._equirectMaterial = null;\n    this._backgroundBox = null;\n  }\n  get _hasInitialized() {\n    return this._renderer.hasInitialized();\n  }\n\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   */\n  fromScene(scene, sigma = 0, near = 0.1, far = 100, renderTarget = null) {\n    this._setSize(256);\n    if (this._hasInitialized === false) {\n      console.warn('THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.');\n      const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n      this.fromSceneAsync(scene, sigma, near, far, cubeUVRenderTarget);\n      return cubeUVRenderTarget;\n    }\n    _oldTarget = this._renderer.getRenderTarget();\n    _oldActiveCubeFace = this._renderer.getActiveCubeFace();\n    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n    const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n    cubeUVRenderTarget.depthBuffer = true;\n    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n    if (sigma > 0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  async fromSceneAsync(scene, sigma = 0, near = 0.1, far = 100, renderTarget = null) {\n    if (this._hasInitialized === false) await this._renderer.init();\n    return this.fromScene(scene, sigma, near, far, renderTarget);\n  }\n\n  /**\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\n   * or HDR. The ideal input image size is 1k (1024 x 512),\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n  fromEquirectangular(equirectangular, renderTarget = null) {\n    if (this._hasInitialized === false) {\n      console.warn('THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.');\n      this._setSizeFromTexture(equirectangular);\n      const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n      this.fromEquirectangularAsync(equirectangular, cubeUVRenderTarget);\n      return cubeUVRenderTarget;\n    }\n    return this._fromTexture(equirectangular, renderTarget);\n  }\n  async fromEquirectangularAsync(equirectangular, renderTarget = null) {\n    if (this._hasInitialized === false) await this._renderer.init();\n    return this._fromTexture(equirectangular, renderTarget);\n  }\n\n  /**\n   * Generates a PMREM from an cubemap texture, which can be either LDR\n   * or HDR. The ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n  fromCubemap(cubemap, renderTarget = null) {\n    if (this._hasInitialized === false) {\n      console.warn('THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.');\n      this._setSizeFromTexture(cubemap);\n      const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n      this.fromCubemapAsync(cubemap, renderTarget);\n      return cubeUVRenderTarget;\n    }\n    return this._fromTexture(cubemap, renderTarget);\n  }\n  async fromCubemapAsync(cubemap, renderTarget = null) {\n    if (this._hasInitialized === false) await this._renderer.init();\n    return this._fromTexture(cubemap, renderTarget);\n  }\n\n  /**\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  async compileCubemapShader() {\n    if (this._cubemapMaterial === null) {\n      this._cubemapMaterial = _getCubemapMaterial();\n      await this._compileMaterial(this._cubemapMaterial);\n    }\n  }\n\n  /**\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  async compileEquirectangularShader() {\n    if (this._equirectMaterial === null) {\n      this._equirectMaterial = _getEquirectMaterial();\n      await this._compileMaterial(this._equirectMaterial);\n    }\n  }\n\n  /**\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n   * one of them will cause any others to also become unusable.\n   */\n  dispose() {\n    this._dispose();\n    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();\n    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();\n    if (this._backgroundBox !== null) {\n      this._backgroundBox.geometry.dispose();\n      this._backgroundBox.material.dispose();\n    }\n  }\n\n  // private interface\n\n  _setSizeFromTexture(texture) {\n    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {\n      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);\n    } else {\n      // Equirectangular\n\n      this._setSize(texture.image.width / 4);\n    }\n  }\n  _setSize(cubeSize) {\n    this._lodMax = Math.floor(Math.log2(cubeSize));\n    this._cubeSize = Math.pow(2, this._lodMax);\n  }\n  _dispose() {\n    if (this._blurMaterial !== null) this._blurMaterial.dispose();\n    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();\n    for (let i = 0; i < this._lodPlanes.length; i++) {\n      this._lodPlanes[i].dispose();\n    }\n  }\n  _cleanup(outputTarget) {\n    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);\n    outputTarget.scissorTest = false;\n    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  }\n  _fromTexture(texture, renderTarget) {\n    this._setSizeFromTexture(texture);\n    _oldTarget = this._renderer.getRenderTarget();\n    _oldActiveCubeFace = this._renderer.getActiveCubeFace();\n    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n    const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n    this._textureToCubeUV(texture, cubeUVRenderTarget);\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  _allocateTargets() {\n    const width = 3 * Math.max(this._cubeSize, 16 * 7);\n    const height = 4 * this._cubeSize;\n    const params = {\n      magFilter: LinearFilter,\n      minFilter: LinearFilter,\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      colorSpace: LinearSRGBColorSpace\n      //depthBuffer: false\n    };\n    const cubeUVRenderTarget = _createRenderTarget(width, height, params);\n    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {\n      if (this._pingPongRenderTarget !== null) {\n        this._dispose();\n      }\n      this._pingPongRenderTarget = _createRenderTarget(width, height, params);\n      const {\n        _lodMax\n      } = this;\n      ({\n        sizeLods: this._sizeLods,\n        lodPlanes: this._lodPlanes,\n        sigmas: this._sigmas,\n        lodMeshes: this._lodMeshes\n      } = _createPlanes(_lodMax));\n      this._blurMaterial = _getBlurShader(_lodMax, width, height);\n    }\n    return cubeUVRenderTarget;\n  }\n  async _compileMaterial(material) {\n    const tmpMesh = new Mesh(this._lodPlanes[0], material);\n    await this._renderer.compile(tmpMesh, _flatCamera);\n  }\n  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n    const cubeCamera = _cubeCamera;\n    cubeCamera.near = near;\n    cubeCamera.far = far;\n\n    // px, py, pz, nx, ny, nz\n    const upSign = [-1, 1, -1, -1, -1, -1];\n    const forwardSign = [1, 1, 1, -1, -1, -1];\n    const renderer = this._renderer;\n    const originalAutoClear = renderer.autoClear;\n    renderer.getClearColor(_clearColor);\n    renderer.autoClear = false;\n    let backgroundBox = this._backgroundBox;\n    if (backgroundBox === null) {\n      const backgroundMaterial = new MeshBasicMaterial({\n        name: 'PMREM.Background',\n        side: BackSide,\n        depthWrite: false,\n        depthTest: false\n      });\n      backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);\n    }\n    let useSolidColor = false;\n    const background = scene.background;\n    if (background) {\n      if (background.isColor) {\n        backgroundBox.material.color.copy(background);\n        scene.background = null;\n        useSolidColor = true;\n      }\n    } else {\n      backgroundBox.material.color.copy(_clearColor);\n      useSolidColor = true;\n    }\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.clear();\n    if (useSolidColor) {\n      renderer.render(backgroundBox, cubeCamera);\n    }\n    for (let i = 0; i < 6; i++) {\n      const col = i % 3;\n      if (col === 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col === 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n      const size = this._cubeSize;\n      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);\n      renderer.render(scene, cubeCamera);\n    }\n    renderer.autoClear = originalAutoClear;\n    scene.background = background;\n  }\n  _textureToCubeUV(texture, cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;\n    if (isCubeTexture) {\n      if (this._cubemapMaterial === null) {\n        this._cubemapMaterial = _getCubemapMaterial(texture);\n      }\n    } else {\n      if (this._equirectMaterial === null) {\n        this._equirectMaterial = _getEquirectMaterial(texture);\n      }\n    }\n    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n    material.fragmentNode.value = texture;\n    const mesh = this._lodMeshes[0];\n    mesh.material = material;\n    const size = this._cubeSize;\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.render(mesh, _flatCamera);\n  }\n  _applyPMREM(cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    const n = this._lodPlanes.length;\n    for (let i = 1; i < n; i++) {\n      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);\n      const poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];\n      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n    }\n    renderer.autoClear = autoClear;\n  }\n\n  /**\n   * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n   * vertically and horizontally, but this breaks down on a cube. Here we apply\n   * the blur latitudinally (around the poles), and then longitudinally (towards\n   * the poles) to approximate the orthogonally-separable blur. It is least\n   * accurate at the poles, but still does a decent job.\n   */\n  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n    const pingPongRenderTarget = this._pingPongRenderTarget;\n    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n  }\n  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n    const renderer = this._renderer;\n    const blurMaterial = this._blurMaterial;\n    if (direction !== 'latitudinal' && direction !== 'longitudinal') {\n      console.error('blur direction must be either latitudinal or longitudinal!');\n    }\n\n    // Number of standard deviations at which to cut off the discrete approximation.\n    const STANDARD_DEVIATIONS = 3;\n    const blurMesh = this._lodMeshes[lodOut];\n    blurMesh.material = blurMaterial;\n    const blurUniforms = blurMaterial.uniforms;\n    const pixels = this._sizeLods[lodIn] - 1;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n    const weights = [];\n    let sum = 0;\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n      if (i === 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n    targetIn.texture.frame = (targetIn.texture.frame || 0) + 1;\n    blurUniforms.envMap.value = targetIn.texture;\n    blurUniforms.samples.value = samples;\n    blurUniforms.weights.array = weights;\n    blurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;\n    if (poleAxis) {\n      blurUniforms.poleAxis.value = poleAxis;\n    }\n    const {\n      _lodMax\n    } = this;\n    blurUniforms.dTheta.value = radiansPerPixel;\n    blurUniforms.mipInt.value = _lodMax - lodIn;\n    const outputSize = this._sizeLods[lodOut];\n    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);\n    const y = 4 * (this._cubeSize - outputSize);\n    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n    renderer.setRenderTarget(targetOut);\n    renderer.render(blurMesh, _flatCamera);\n  }\n}\nfunction _createPlanes(lodMax) {\n  const lodPlanes = [];\n  const sizeLods = [];\n  const sigmas = [];\n  const lodMeshes = [];\n  let lod = lodMax;\n  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n  for (let i = 0; i < totalLods; i++) {\n    const sizeLod = Math.pow(2, lod);\n    sizeLods.push(sizeLod);\n    let sigma = 1.0 / sizeLod;\n    if (i > lodMax - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];\n    } else if (i === 0) {\n      sigma = 0;\n    }\n    sigmas.push(sigma);\n    const texelSize = 1.0 / (sizeLod - 2);\n    const min = -texelSize;\n    const max = 1 + texelSize;\n    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    const cubeFaces = 6;\n    const vertices = 6;\n    const positionSize = 3;\n    const uvSize = 2;\n    const faceIndexSize = 1;\n    const position = new Float32Array(positionSize * vertices * cubeFaces);\n    const uv = new Float32Array(uvSize * vertices * cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n    for (let face = 0; face < cubeFaces; face++) {\n      const x = face % 3 * 2 / 3 - 1;\n      const y = face > 2 ? 0 : -1;\n      const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n      const faceIdx = _faceLib[face];\n      position.set(coordinates, positionSize * vertices * faceIdx);\n      uv.set(uv1, uvSize * vertices * faceIdx);\n      const fill = [faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx];\n      faceIndex.set(fill, faceIndexSize * vertices * faceIdx);\n    }\n    const planes = new BufferGeometry();\n    planes.setAttribute('position', new BufferAttribute(position, positionSize));\n    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));\n    lodPlanes.push(planes);\n    lodMeshes.push(new Mesh(planes, null));\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n  return {\n    lodPlanes,\n    sizeLods,\n    sigmas,\n    lodMeshes\n  };\n}\nfunction _createRenderTarget(width, height, params) {\n  const cubeUVRenderTarget = new RenderTarget(width, height, params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n  cubeUVRenderTarget.texture.isPMREMTexture = true;\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\nfunction _getMaterial(type) {\n  const material = new NodeMaterial();\n  material.depthTest = false;\n  material.depthWrite = false;\n  material.blending = NoBlending;\n  material.name = `PMREM_${type}`;\n  return material;\n}\nfunction _getBlurShader(lodMax, width, height) {\n  const weights = uniformArray(new Array(MAX_SAMPLES).fill(0));\n  const poleAxis = uniform(new Vector3(0, 1, 0));\n  const dTheta = uniform(0);\n  const n = float(MAX_SAMPLES);\n  const latitudinal = uniform(0); // false, bool\n  const samples = uniform(1); // int\n  const envMap = texture(null);\n  const mipInt = uniform(0); // int\n  const CUBEUV_TEXEL_WIDTH = float(1 / width);\n  const CUBEUV_TEXEL_HEIGHT = float(1 / height);\n  const CUBEUV_MAX_MIP = float(lodMax);\n  const materialUniforms = {\n    n,\n    latitudinal,\n    weights,\n    poleAxis,\n    outputDirection,\n    dTheta,\n    samples,\n    envMap,\n    mipInt,\n    CUBEUV_TEXEL_WIDTH,\n    CUBEUV_TEXEL_HEIGHT,\n    CUBEUV_MAX_MIP\n  };\n  const material = _getMaterial('blur');\n  material.uniforms = materialUniforms; // TODO: Move to outside of the material\n  material.fragmentNode = blur({\n    ...materialUniforms,\n    latitudinal: latitudinal.equal(1)\n  });\n  return material;\n}\nfunction _getCubemapMaterial(envTexture) {\n  const material = _getMaterial('cubemap');\n  material.fragmentNode = cubeTexture(envTexture, outputDirection);\n  return material;\n}\nfunction _getEquirectMaterial(envTexture) {\n  const material = _getMaterial('equirect');\n  material.fragmentNode = texture(envTexture, equirectUV(outputDirection), 0);\n  return material;\n}\nconst rendererCache = new WeakMap();\nconst typeFromArray = new Map([[Int8Array, 'int'], [Int16Array, 'int'], [Int32Array, 'int'], [Uint8Array, 'uint'], [Uint16Array, 'uint'], [Uint32Array, 'uint'], [Float32Array, 'float']]);\nconst toFloat = value => {\n  if (/e/g.test(value)) {\n    return String(value).replace(/\\+/g, '');\n  } else {\n    value = Number(value);\n    return value + (value % 1 ? '' : '.0');\n  }\n};\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object && object.material || null;\n    this.geometry = object && object.geometry || null;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.scene = null;\n    this.camera = null;\n    this.nodes = [];\n    this.sequentialNodes = [];\n    this.updateNodes = [];\n    this.updateBeforeNodes = [];\n    this.updateAfterNodes = [];\n    this.hashNodes = {};\n    this.monitor = null;\n    this.lightsNode = null;\n    this.environmentNode = null;\n    this.fogNode = null;\n    this.clippingContext = null;\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.computeShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: '',\n      compute: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.structs = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.bindings = {\n      vertex: {},\n      fragment: {},\n      compute: {}\n    };\n    this.bindingsIndexes = {};\n    this.bindGroups = null;\n    this.attributes = [];\n    this.bufferAttributes = [];\n    this.varyings = [];\n    this.codes = {};\n    this.vars = {};\n    this.flow = {\n      code: ''\n    };\n    this.chaining = [];\n    this.stack = stack();\n    this.stacks = [];\n    this.tab = '\\t';\n    this.currentFunctionNode = null;\n    this.context = {\n      material: this.material\n    };\n    this.cache = new NodeCache();\n    this.globalCache = this.cache;\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.buildStage = null;\n    this.useComparisonMethod = false;\n  }\n  getBindGroupsCache() {\n    let bindGroupsCache = rendererCache.get(this.renderer);\n    if (bindGroupsCache === undefined) {\n      bindGroupsCache = new ChainMap();\n      rendererCache.set(this.renderer, bindGroupsCache);\n    }\n    return bindGroupsCache;\n  }\n  createRenderTarget(width, height, options) {\n    return new RenderTarget(width, height, options);\n  }\n  createCubeRenderTarget(size, options) {\n    return new CubeRenderTarget(size, options);\n  }\n  createPMREMGenerator() {\n    // TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support\n\n    return new PMREMGenerator(this.renderer);\n  }\n  includes(node) {\n    return this.nodes.includes(node);\n  }\n  _getBindGroup(groupName, bindings) {\n    const bindGroupsCache = this.getBindGroupsCache();\n\n    //\n\n    const bindingsArray = [];\n    let sharedGroup = true;\n    for (const binding of bindings) {\n      bindingsArray.push(binding);\n      sharedGroup = sharedGroup && binding.groupNode.shared !== true;\n    }\n\n    //\n\n    let bindGroup;\n    if (sharedGroup) {\n      bindGroup = bindGroupsCache.get(bindingsArray);\n      if (bindGroup === undefined) {\n        bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);\n        bindGroupsCache.set(bindingsArray, bindGroup);\n      }\n    } else {\n      bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);\n    }\n    return bindGroup;\n  }\n  getBindGroupArray(groupName, shaderStage) {\n    const bindings = this.bindings[shaderStage];\n    let bindGroup = bindings[groupName];\n    if (bindGroup === undefined) {\n      if (this.bindingsIndexes[groupName] === undefined) {\n        this.bindingsIndexes[groupName] = {\n          binding: 0,\n          group: Object.keys(this.bindingsIndexes).length\n        };\n      }\n      bindings[groupName] = bindGroup = [];\n    }\n    return bindGroup;\n  }\n  getBindings() {\n    let bindingsGroups = this.bindGroups;\n    if (bindingsGroups === null) {\n      const groups = {};\n      const bindings = this.bindings;\n      for (const shaderStage of shaderStages) {\n        for (const groupName in bindings[shaderStage]) {\n          const uniforms = bindings[shaderStage][groupName];\n          const groupUniforms = groups[groupName] || (groups[groupName] = []);\n          groupUniforms.push(...uniforms);\n        }\n      }\n      bindingsGroups = [];\n      for (const groupName in groups) {\n        const group = groups[groupName];\n        const bindingsGroup = this._getBindGroup(groupName, group);\n        bindingsGroups.push(bindingsGroup);\n      }\n      this.bindGroups = bindingsGroups;\n    }\n    return bindingsGroups;\n  }\n  sortBindingGroups() {\n    const bindingsGroups = this.getBindings();\n    bindingsGroups.sort((a, b) => a.bindings[0].groupNode.order - b.bindings[0].groupNode.order);\n    for (let i = 0; i < bindingsGroups.length; i++) {\n      const bindingGroup = bindingsGroups[i];\n      this.bindingsIndexes[bindingGroup.name].group = i;\n      bindingGroup.index = i;\n    }\n  }\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n  addNode(node) {\n    if (this.nodes.includes(node) === false) {\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n  addSequentialNode(node) {\n    if (this.sequentialNodes.includes(node) === false) {\n      this.sequentialNodes.push(node);\n    }\n  }\n  buildUpdateNodes() {\n    for (const node of this.nodes) {\n      const updateType = node.getUpdateType();\n      if (updateType !== NodeUpdateType.NONE) {\n        this.updateNodes.push(node.getSelf());\n      }\n    }\n    for (const node of this.sequentialNodes) {\n      const updateBeforeType = node.getUpdateBeforeType();\n      const updateAfterType = node.getUpdateAfterType();\n      if (updateBeforeType !== NodeUpdateType.NONE) {\n        this.updateBeforeNodes.push(node.getSelf());\n      }\n      if (updateAfterType !== NodeUpdateType.NONE) {\n        this.updateAfterNodes.push(node.getSelf());\n      }\n    }\n  }\n  get currentNode() {\n    return this.chaining[this.chaining.length - 1];\n  }\n  isFilteredTexture(texture) {\n    return texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter;\n  }\n  addChain(node) {\n    /*\n    if ( this.chaining.indexOf( node ) !== - 1 ) {\n    \t\tconsole.warn( 'Recursive node: ', node );\n    \t}\n    */\n\n    this.chaining.push(node);\n  }\n  removeChain(node) {\n    const lastChain = this.chaining.pop();\n    if (lastChain !== node) {\n      throw new Error('NodeBuilder: Invalid node chaining!');\n    }\n  }\n  getMethod(method) {\n    return method;\n  }\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n  setContext(context) {\n    this.context = context;\n  }\n  getContext() {\n    return this.context;\n  }\n  getSharedContext() {\n    ({\n      ...this.context\n    });\n    return this.context;\n  }\n  setCache(cache) {\n    this.cache = cache;\n  }\n  getCache() {\n    return this.cache;\n  }\n  getCacheFromNode(node, parent = true) {\n    const data = this.getDataFromNode(node);\n    if (data.cache === undefined) data.cache = new NodeCache(parent ? this.getCache() : null);\n    return data.cache;\n  }\n  isAvailable(/*name*/\n  ) {\n    return false;\n  }\n  getVertexIndex() {\n    console.warn('Abstract function.');\n  }\n  getInstanceIndex() {\n    console.warn('Abstract function.');\n  }\n  getDrawIndex() {\n    console.warn('Abstract function.');\n  }\n  getFrontFacing() {\n    console.warn('Abstract function.');\n  }\n  getFragCoord() {\n    console.warn('Abstract function.');\n  }\n  isFlipY() {\n    return false;\n  }\n  increaseUsage(node) {\n    const nodeData = this.getDataFromNode(node);\n    nodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;\n    return nodeData.usageCount;\n  }\n  generateTexture(/* texture, textureProperty, uvSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n  generateTextureLod(/* texture, textureProperty, uvSnippet, levelSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n  generateConst(type, value = null) {\n    if (value === null) {\n      if (type === 'float' || type === 'int' || type === 'uint') value = 0;else if (type === 'bool') value = false;else if (type === 'color') value = new Color();else if (type === 'vec2') value = new Vector2();else if (type === 'vec3') value = new Vector3();else if (type === 'vec4') value = new Vector4();\n    }\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n    if (type === 'color') return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n    const generateConst = value => this.generateConst(componentType, value);\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;\n    } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {\n      return `${this.getType(type)}( ${value.elements.map(generateConst).join(', ')} )`;\n    } else if (typeLength > 4) {\n      return `${this.getType(type)}()`;\n    }\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n  getType(type) {\n    if (type === 'color') return 'vec3';\n    return type;\n  }\n  hasGeometryAttribute(name) {\n    return this.geometry && this.geometry.getAttribute(name) !== undefined;\n  }\n  getAttribute(name, type) {\n    const attributes = this.attributes;\n\n    // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    }\n\n    // create a new if no exist\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n  getPropertyName(node /*, shaderStage*/) {\n    return node.name;\n  }\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';\n  }\n  needsToWorkingColorSpace(/*texture*/\n  ) {\n    return false;\n  }\n  getComponentTypeFromTexture(texture) {\n    const type = texture.type;\n    if (texture.isDataTexture) {\n      if (type === IntType) return 'int';\n      if (type === UnsignedIntType) return 'uint';\n    }\n    return 'float';\n  }\n  getElementType(type) {\n    if (type === 'mat2') return 'vec2';\n    if (type === 'mat3') return 'vec3';\n    if (type === 'mat4') return 'vec4';\n    return this.getComponentType(type);\n  }\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') return 'vec4';\n    return type;\n  }\n  getTypeFromLength(length, componentType = 'float') {\n    if (length === 1) return componentType;\n    const baseType = getTypeFromLength(length);\n    const prefix = componentType === 'float' ? '' : componentType[0];\n    return prefix + baseType;\n  }\n  getTypeFromArray(array) {\n    return typeFromArray.get(array.constructor);\n  }\n  getTypeFromAttribute(attribute) {\n    let dataAttribute = attribute;\n    if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;\n    const array = dataAttribute.array;\n    const itemSize = attribute.itemSize;\n    const normalized = attribute.normalized;\n    let arrayType;\n    if (!(attribute instanceof Float16BufferAttribute) && normalized !== true) {\n      arrayType = this.getTypeFromArray(array);\n    }\n    return this.getTypeFromLength(itemSize, arrayType);\n  }\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    if (/mat2/.test(type) === true) return 4;\n    if (/mat3/.test(type) === true) return 9;\n    if (/mat4/.test(type) === true) return 16;\n    return 0;\n  }\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n  changeComponentType(type, newComponentType) {\n    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);\n  }\n  getIntegerType(type) {\n    const componentType = this.getComponentType(type);\n    if (componentType === 'int' || componentType === 'uint') return type;\n    return this.changeComponentType(type, 'int');\n  }\n  addStack() {\n    this.stack = stack(this.stack);\n    this.stacks.push(getCurrentStack() || this.stack);\n    setCurrentStack(this.stack);\n    return this.stack;\n  }\n  removeStack() {\n    const lastStack = this.stack;\n    this.stack = lastStack.parent;\n    setCurrentStack(this.stacks.pop());\n    return lastStack;\n  }\n  getDataFromNode(node, shaderStage = this.shaderStage, cache = null) {\n    cache = cache === null ? node.isGlobal(this) ? this.globalCache : this.cache : cache;\n    let nodeData = cache.getData(node);\n    if (nodeData === undefined) {\n      nodeData = {};\n      cache.setData(node, nodeData);\n    }\n    if (nodeData[shaderStage] === undefined) nodeData[shaderStage] = {};\n    return nodeData[shaderStage];\n  }\n  getNodeProperties(node, shaderStage = 'any') {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    return nodeData.properties || (nodeData.properties = {\n      outputNode: null\n    });\n  }\n  getBufferAttributeFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node);\n    let bufferAttribute = nodeData.bufferAttribute;\n    if (bufferAttribute === undefined) {\n      const index = this.uniforms.index++;\n      bufferAttribute = new NodeAttribute('nodeAttribute' + index, type, node);\n      this.bufferAttributes.push(bufferAttribute);\n      nodeData.bufferAttribute = bufferAttribute;\n    }\n    return bufferAttribute;\n  }\n  getStructTypeFromNode(node, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    if (nodeData.structType === undefined) {\n      const index = this.structs.index++;\n      node.name = `StructType${index}`;\n      this.structs[shaderStage].push(node);\n      nodeData.structType = node;\n    }\n    return node;\n  }\n  getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {\n    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);\n    let nodeUniform = nodeData.uniform;\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform(name || 'nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n    return nodeUniform;\n  }\n  getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);\n      if (name === null) name = 'nodeVar' + vars.length;\n      nodeVar = new NodeVar(name, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n    return nodeVar;\n  }\n  getVaryingFromNode(node, name = null, type = node.getNodeType(this)) {\n    const nodeData = this.getDataFromNode(node, 'any');\n    let nodeVarying = nodeData.varying;\n    if (nodeVarying === undefined) {\n      const varyings = this.varyings;\n      const index = varyings.length;\n      if (name === null) name = 'nodeVarying' + index;\n      nodeVarying = new NodeVarying(name, type);\n      varyings.push(nodeVarying);\n      nodeData.varying = nodeVarying;\n    }\n    return nodeVarying;\n  }\n  getCodeFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n    return nodeCode;\n  }\n  addFlowCodeHierarchy(node, nodeBlock) {\n    const {\n      flowCodes,\n      flowCodeBlock\n    } = this.getDataFromNode(node);\n    let needsFlowCode = true;\n    let nodeBlockHierarchy = nodeBlock;\n    while (nodeBlockHierarchy) {\n      if (flowCodeBlock.get(nodeBlockHierarchy) === true) {\n        needsFlowCode = false;\n        break;\n      }\n      nodeBlockHierarchy = this.getDataFromNode(nodeBlockHierarchy).parentNodeBlock;\n    }\n    if (needsFlowCode) {\n      for (const flowCode of flowCodes) {\n        this.addLineFlowCode(flowCode);\n      }\n    }\n  }\n  addLineFlowCodeBlock(node, code, nodeBlock) {\n    const nodeData = this.getDataFromNode(node);\n    const flowCodes = nodeData.flowCodes || (nodeData.flowCodes = []);\n    const codeBlock = nodeData.flowCodeBlock || (nodeData.flowCodeBlock = new WeakMap());\n    flowCodes.push(code);\n    codeBlock.set(nodeBlock, true);\n  }\n  addLineFlowCode(code, node = null) {\n    if (code === '') return this;\n    if (node !== null && this.context.nodeBlock) {\n      this.addLineFlowCodeBlock(node, code, this.context.nodeBlock);\n    }\n    code = this.tab + code;\n    if (!/;\\s*$/.test(code)) {\n      code = code + ';\\n';\n    }\n    this.flow.code += code;\n    return this;\n  }\n  addFlowCode(code) {\n    this.flow.code += code;\n    return this;\n  }\n  addFlowTab() {\n    this.tab += '\\t';\n    return this;\n  }\n  removeFlowTab() {\n    this.tab = this.tab.slice(0, -1);\n    return this;\n  }\n  getFlowData(node /*, shaderStage*/) {\n    return this.flowsData.get(node);\n  }\n  flowNode(node) {\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    return flowData;\n  }\n  buildFunctionNode(shaderNode) {\n    const fn = new FunctionNode();\n    const previous = this.currentFunctionNode;\n    this.currentFunctionNode = fn;\n    fn.code = this.buildFunctionCode(shaderNode);\n    this.currentFunctionNode = previous;\n    return fn;\n  }\n  flowShaderNode(shaderNode) {\n    const layout = shaderNode.layout;\n    const inputs = {\n      [Symbol.iterator]() {\n        let index = 0;\n        const values = Object.values(this);\n        return {\n          next: () => ({\n            value: values[index],\n            done: index++ >= values.length\n          })\n        };\n      }\n    };\n    for (const input of layout.inputs) {\n      inputs[input.name] = new ParameterNode(input.type, input.name);\n    }\n\n    //\n\n    shaderNode.layout = null;\n    const callNode = shaderNode.call(inputs);\n    const flowData = this.flowStagesNode(callNode, layout.type);\n    shaderNode.layout = layout;\n    return flowData;\n  }\n  flowStagesNode(node, output = null) {\n    const previousFlow = this.flow;\n    const previousVars = this.vars;\n    const previousCache = this.cache;\n    const previousBuildStage = this.buildStage;\n    const previousStack = this.stack;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    this.vars = {};\n    this.cache = new NodeCache();\n    this.stack = stack();\n    for (const buildStage of defaultBuildStages) {\n      this.setBuildStage(buildStage);\n      flow.result = node.build(this, output);\n    }\n    flow.vars = this.getVars(this.shaderStage);\n    this.flow = previousFlow;\n    this.vars = previousVars;\n    this.cache = previousCache;\n    this.stack = previousStack;\n    this.setBuildStage(previousBuildStage);\n    return flow;\n  }\n  getFunctionOperator() {\n    return null;\n  }\n  flowChildNode(node, output = null) {\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n    if (propertyName !== null) {\n      flowData.code += `${this.tab + propertyName} = ${flowData.result};\\n`;\n    }\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n  getAttributesArray() {\n    return this.attributes.concat(this.bufferAttributes);\n  }\n  getAttributes(/*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getVaryings(/*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getVar(type, name) {\n    return `${this.getType(type)} ${name}`;\n  }\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n    if (vars !== undefined) {\n      for (const variable of vars) {\n        snippet += `${this.getVar(variable.type, variable.name)}; `;\n      }\n    }\n    return snippet;\n  }\n  getUniforms(/*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n    if (codes !== undefined) {\n      for (const nodeCode of codes) {\n        code += nodeCode.code + '\\n';\n      }\n    }\n    return code;\n  }\n  getHash() {\n    return this.vertexShader + this.fragmentShader + this.computeShader;\n  }\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n  getShaderStage() {\n    return this.shaderStage;\n  }\n  setBuildStage(buildStage) {\n    this.buildStage = buildStage;\n  }\n  getBuildStage() {\n    return this.buildStage;\n  }\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n  build() {\n    const {\n      object,\n      material,\n      renderer\n    } = this;\n    if (material !== null) {\n      let nodeMaterial = renderer.library.fromMaterial(material);\n      if (nodeMaterial === null) {\n        console.error(`NodeMaterial: Material \"${material.type}\" is not compatible.`);\n        nodeMaterial = new NodeMaterial();\n      }\n      nodeMaterial.build(this);\n    } else {\n      this.addFlow('compute', object);\n    }\n\n    // setup() -> stage 1: create possible new nodes and returns an output reference node\n    // analyze()   -> stage 2: analyze nodes to possible optimization and validation\n    // generate()  -> stage 3: generate shader\n\n    for (const buildStage of defaultBuildStages) {\n      this.setBuildStage(buildStage);\n      if (this.context.vertex && this.context.vertex.isNode) {\n        this.flowNodeFromShaderStage('vertex', this.context.vertex);\n      }\n      for (const shaderStage of shaderStages) {\n        this.setShaderStage(shaderStage);\n        const flowNodes = this.flowNodes[shaderStage];\n        for (const node of flowNodes) {\n          if (buildStage === 'generate') {\n            this.flowNode(node);\n          } else {\n            node.build(this);\n          }\n        }\n      }\n    }\n    this.setBuildStage(null);\n    this.setShaderStage(null);\n\n    // stage 4: build code for a specific output\n\n    this.buildCode();\n    this.buildUpdateNodes();\n    return this;\n  }\n  getNodeUniform(uniformNode, type) {\n    if (type === 'float' || type === 'int' || type === 'uint') return new NumberNodeUniform(uniformNode);\n    if (type === 'vec2' || type === 'ivec2' || type === 'uvec2') return new Vector2NodeUniform(uniformNode);\n    if (type === 'vec3' || type === 'ivec3' || type === 'uvec3') return new Vector3NodeUniform(uniformNode);\n    if (type === 'vec4' || type === 'ivec4' || type === 'uvec4') return new Vector4NodeUniform(uniformNode);\n    if (type === 'color') return new ColorNodeUniform(uniformNode);\n    if (type === 'mat3') return new Matrix3NodeUniform(uniformNode);\n    if (type === 'mat4') return new Matrix4NodeUniform(uniformNode);\n    throw new Error(`Uniform \"${type}\" not declared.`);\n  }\n  createNodeMaterial(type = 'NodeMaterial') {\n    // @deprecated, r168\n\n    throw new Error(`THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${type}() instead.`);\n  }\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n    if (fromTypeLength === 16 && toTypeLength === 9) {\n      return `${this.getType(toType)}(${snippet}[0].xyz, ${snippet}[1].xyz, ${snippet}[2].xyz)`;\n    }\n    if (fromTypeLength === 9 && toTypeLength === 4) {\n      return `${this.getType(toType)}(${snippet}[0].xy, ${snippet}[1].xy)`;\n    }\n    if (fromTypeLength > 4) {\n      // fromType is matrix-like\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (toTypeLength > 4 || toTypeLength === 0) {\n      // toType is matrix-like or unknown\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);\n    }\n    if (toTypeLength === 4 && fromTypeLength > 1) {\n      // toType is vec4-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n    if (fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType(toType)) {\n      // fromType is float-like\n\n      // convert a number value to vector type, e.g:\n      // vec3( 1u ) -> vec3( float( 1u ) )\n\n      snippet = `${this.getType(this.getComponentType(toType))}( ${snippet} )`;\n    }\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n  getSignature() {\n    return `// Three.js r${REVISION} - Node System\\n`;\n  }\n}\nclass NodeFrame {\n  constructor() {\n    this.time = 0;\n    this.deltaTime = 0;\n    this.frameId = 0;\n    this.renderId = 0;\n    this.startTime = null;\n    this.updateMap = new WeakMap();\n    this.updateBeforeMap = new WeakMap();\n    this.updateAfterMap = new WeakMap();\n    this.renderer = null;\n    this.material = null;\n    this.camera = null;\n    this.object = null;\n    this.scene = null;\n  }\n  _getMaps(referenceMap, nodeRef) {\n    let maps = referenceMap.get(nodeRef);\n    if (maps === undefined) {\n      maps = {\n        renderMap: new WeakMap(),\n        frameMap: new WeakMap()\n      };\n      referenceMap.set(nodeRef, maps);\n    }\n    return maps;\n  }\n  updateBeforeNode(node) {\n    const updateType = node.getUpdateBeforeType();\n    const reference = node.updateReference(this);\n    if (updateType === NodeUpdateType.FRAME) {\n      const {\n        frameMap\n      } = this._getMaps(this.updateBeforeMap, reference);\n      if (frameMap.get(reference) !== this.frameId) {\n        if (node.updateBefore(this) !== false) {\n          frameMap.set(reference, this.frameId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.RENDER) {\n      const {\n        renderMap\n      } = this._getMaps(this.updateBeforeMap, reference);\n      if (renderMap.get(reference) !== this.renderId) {\n        if (node.updateBefore(this) !== false) {\n          renderMap.set(reference, this.renderId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.OBJECT) {\n      node.updateBefore(this);\n    }\n  }\n  updateAfterNode(node) {\n    const updateType = node.getUpdateAfterType();\n    const reference = node.updateReference(this);\n    if (updateType === NodeUpdateType.FRAME) {\n      const {\n        frameMap\n      } = this._getMaps(this.updateAfterMap, reference);\n      if (frameMap.get(reference) !== this.frameId) {\n        if (node.updateAfter(this) !== false) {\n          frameMap.set(reference, this.frameId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.RENDER) {\n      const {\n        renderMap\n      } = this._getMaps(this.updateAfterMap, reference);\n      if (renderMap.get(reference) !== this.renderId) {\n        if (node.updateAfter(this) !== false) {\n          renderMap.set(reference, this.renderId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.OBJECT) {\n      node.updateAfter(this);\n    }\n  }\n  updateNode(node) {\n    const updateType = node.getUpdateType();\n    const reference = node.updateReference(this);\n    if (updateType === NodeUpdateType.FRAME) {\n      const {\n        frameMap\n      } = this._getMaps(this.updateMap, reference);\n      if (frameMap.get(reference) !== this.frameId) {\n        if (node.update(this) !== false) {\n          frameMap.set(reference, this.frameId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.RENDER) {\n      const {\n        renderMap\n      } = this._getMaps(this.updateMap, reference);\n      if (renderMap.get(reference) !== this.renderId) {\n        if (node.update(this) !== false) {\n          renderMap.set(reference, this.renderId);\n        }\n      }\n    } else if (updateType === NodeUpdateType.OBJECT) {\n      node.update(this);\n    }\n  }\n  update() {\n    this.frameId++;\n    if (this.lastTime === undefined) this.lastTime = performance.now();\n    this.deltaTime = (performance.now() - this.lastTime) / 1000;\n    this.lastTime = performance.now();\n    this.time += this.deltaTime;\n  }\n}\nclass NodeFunctionInput {\n  constructor(type, name, count = null, qualifier = '', isConst = false) {\n    this.type = type;\n    this.name = name;\n    this.count = count;\n    this.qualifier = qualifier;\n    this.isConst = isConst;\n  }\n}\nNodeFunctionInput.isNodeFunctionInput = true;\nclass DirectionalLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'DirectionalLightNode';\n  }\n  constructor(light = null) {\n    super(light);\n  }\n  setup(builder) {\n    super.setup(builder);\n    const lightingModel = builder.context.lightingModel;\n    const lightColor = this.colorNode;\n    const lightDirection = lightTargetDirection(this.light);\n    const reflectedLight = builder.context.reflectedLight;\n    lightingModel.direct({\n      lightDirection,\n      lightColor,\n      reflectedLight\n    }, builder.stack, builder);\n  }\n}\nconst _matrix41 = /*@__PURE__*/new Matrix4();\nconst _matrix42 = /*@__PURE__*/new Matrix4();\nlet ltcLib = null;\nclass RectAreaLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'RectAreaLightNode';\n  }\n  constructor(light = null) {\n    super(light);\n    this.halfHeight = uniform(new Vector3()).setGroup(renderGroup);\n    this.halfWidth = uniform(new Vector3()).setGroup(renderGroup);\n    this.updateType = NodeUpdateType.RENDER;\n  }\n  update(frame) {\n    super.update(frame);\n    const {\n      light\n    } = this;\n    const viewMatrix = frame.camera.matrixWorldInverse;\n    _matrix42.identity();\n    _matrix41.copy(light.matrixWorld);\n    _matrix41.premultiply(viewMatrix);\n    _matrix42.extractRotation(_matrix41);\n    this.halfWidth.value.set(light.width * 0.5, 0.0, 0.0);\n    this.halfHeight.value.set(0.0, light.height * 0.5, 0.0);\n    this.halfWidth.value.applyMatrix4(_matrix42);\n    this.halfHeight.value.applyMatrix4(_matrix42);\n  }\n  setup(builder) {\n    super.setup(builder);\n    let ltc_1, ltc_2;\n    if (builder.isAvailable('float32Filterable')) {\n      ltc_1 = texture(ltcLib.LTC_FLOAT_1);\n      ltc_2 = texture(ltcLib.LTC_FLOAT_2);\n    } else {\n      ltc_1 = texture(ltcLib.LTC_HALF_1);\n      ltc_2 = texture(ltcLib.LTC_HALF_2);\n    }\n    const {\n      colorNode,\n      light\n    } = this;\n    const lightingModel = builder.context.lightingModel;\n    const lightPosition = lightViewPosition(light);\n    const reflectedLight = builder.context.reflectedLight;\n    lightingModel.directRectArea({\n      lightColor: colorNode,\n      lightPosition,\n      halfWidth: this.halfWidth,\n      halfHeight: this.halfHeight,\n      reflectedLight,\n      ltc_1,\n      ltc_2\n    }, builder.stack, builder);\n  }\n  static setLTC(ltc) {\n    ltcLib = ltc;\n  }\n}\nclass SpotLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'SpotLightNode';\n  }\n  constructor(light = null) {\n    super(light);\n    this.coneCosNode = uniform(0).setGroup(renderGroup);\n    this.penumbraCosNode = uniform(0).setGroup(renderGroup);\n    this.cutoffDistanceNode = uniform(0).setGroup(renderGroup);\n    this.decayExponentNode = uniform(0).setGroup(renderGroup);\n  }\n  update(frame) {\n    super.update(frame);\n    const {\n      light\n    } = this;\n    this.coneCosNode.value = Math.cos(light.angle);\n    this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));\n    this.cutoffDistanceNode.value = light.distance;\n    this.decayExponentNode.value = light.decay;\n  }\n  getSpotAttenuation(angleCosine) {\n    const {\n      coneCosNode,\n      penumbraCosNode\n    } = this;\n    return smoothstep(coneCosNode, penumbraCosNode, angleCosine);\n  }\n  setup(builder) {\n    super.setup(builder);\n    const lightingModel = builder.context.lightingModel;\n    const {\n      colorNode,\n      cutoffDistanceNode,\n      decayExponentNode,\n      light\n    } = this;\n    const lVector = lightViewPosition(light).sub(positionView); // @TODO: Add it into LightNode\n\n    const lightDirection = lVector.normalize();\n    const angleCos = lightDirection.dot(lightTargetDirection(light));\n    const spotAttenuation = this.getSpotAttenuation(angleCos);\n    const lightDistance = lVector.length();\n    const lightAttenuation = getDistanceAttenuation({\n      lightDistance,\n      cutoffDistance: cutoffDistanceNode,\n      decayExponent: decayExponentNode\n    });\n    let lightColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);\n    if (light.map) {\n      const spotLightCoord = lightProjectionUV(light);\n      const projectedTexture = texture(light.map, spotLightCoord.xy).onRenderUpdate(() => light.map);\n      const inSpotLightMap = spotLightCoord.mul(2.).sub(1.).abs().lessThan(1.).all();\n      lightColor = inSpotLightMap.select(lightColor.mul(projectedTexture), lightColor);\n    }\n    const reflectedLight = builder.context.reflectedLight;\n    lightingModel.direct({\n      lightDirection,\n      lightColor,\n      reflectedLight\n    }, builder.stack, builder);\n  }\n}\nclass IESSpotLightNode extends SpotLightNode {\n  static get type() {\n    return 'IESSpotLightNode';\n  }\n  getSpotAttenuation(angleCosine) {\n    const iesMap = this.light.iesMap;\n    let spotAttenuation = null;\n    if (iesMap && iesMap.isTexture === true) {\n      const angle = angleCosine.acos().mul(1.0 / Math.PI);\n      spotAttenuation = texture(iesMap, vec2(angle, 0), 0).r;\n    } else {\n      spotAttenuation = super.getSpotAttenuation(angleCosine);\n    }\n    return spotAttenuation;\n  }\n}\nclass AmbientLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'AmbientLightNode';\n  }\n  constructor(light = null) {\n    super(light);\n  }\n  setup({\n    context\n  }) {\n    context.irradiance.addAssign(this.colorNode);\n  }\n}\nclass HemisphereLightNode extends AnalyticLightNode {\n  static get type() {\n    return 'HemisphereLightNode';\n  }\n  constructor(light = null) {\n    super(light);\n    this.lightPositionNode = lightPosition(light);\n    this.lightDirectionNode = this.lightPositionNode.normalize();\n    this.groundColorNode = uniform(new Color()).setGroup(renderGroup);\n  }\n  update(frame) {\n    const {\n      light\n    } = this;\n    super.update(frame);\n    this.lightPositionNode.object3d = light;\n    this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);\n  }\n  setup(builder) {\n    const {\n      colorNode,\n      groundColorNode,\n      lightDirectionNode\n    } = this;\n    const dotNL = normalView.dot(lightDirectionNode);\n    const hemiDiffuseWeight = dotNL.mul(0.5).add(0.5);\n    const irradiance = mix(groundColorNode, colorNode, hemiDiffuseWeight);\n    builder.context.irradiance.addAssign(irradiance);\n  }\n}\nclass LightProbeNode extends AnalyticLightNode {\n  static get type() {\n    return 'LightProbeNode';\n  }\n  constructor(light = null) {\n    super(light);\n    const array = [];\n    for (let i = 0; i < 9; i++) array.push(new Vector3());\n    this.lightProbe = uniformArray(array);\n  }\n  update(frame) {\n    const {\n      light\n    } = this;\n    super.update(frame);\n\n    //\n\n    for (let i = 0; i < 9; i++) {\n      this.lightProbe.array[i].copy(light.sh.coefficients[i]).multiplyScalar(light.intensity);\n    }\n  }\n  setup(builder) {\n    const irradiance = getShIrradianceAt(normalWorld, this.lightProbe);\n    builder.context.irradiance.addAssign(irradiance);\n  }\n}\nclass NodeParser {\n  parseFunction(/*source*/\n  ) {\n    console.warn('Abstract function.');\n  }\n}\nclass NodeFunction {\n  constructor(type, inputs, name = '', precision = '') {\n    this.type = type;\n    this.inputs = inputs;\n    this.name = name;\n    this.precision = precision;\n  }\n  getCode(/*name = this.name*/\n  ) {\n    console.warn('Abstract function.');\n  }\n}\nNodeFunction.isNodeFunction = true;\nconst declarationRegexp$1 = /^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)/i;\nconst propertiesRegexp$1 = /[a-z_0-9]+/ig;\nconst pragmaMain = '#pragma main';\nconst parse$1 = source => {\n  source = source.trim();\n  const pragmaMainIndex = source.indexOf(pragmaMain);\n  const mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;\n  const declaration = mainCode.match(declarationRegexp$1);\n  if (declaration !== null && declaration.length === 5) {\n    // tokenizer\n\n    const inputsCode = declaration[4];\n    const propsMatches = [];\n    let nameMatch = null;\n    while ((nameMatch = propertiesRegexp$1.exec(inputsCode)) !== null) {\n      propsMatches.push(nameMatch);\n    }\n\n    // parser\n\n    const inputs = [];\n    let i = 0;\n    while (i < propsMatches.length) {\n      const isConst = propsMatches[i][0] === 'const';\n      if (isConst === true) {\n        i++;\n      }\n      let qualifier = propsMatches[i][0];\n      if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {\n        i++;\n      } else {\n        qualifier = '';\n      }\n      const type = propsMatches[i++][0];\n      let count = Number.parseInt(propsMatches[i][0]);\n      if (Number.isNaN(count) === false) i++;else count = null;\n      const name = propsMatches[i++][0];\n      inputs.push(new NodeFunctionInput(type, name, count, qualifier, isConst));\n    }\n\n    //\n\n    const blockCode = mainCode.substring(declaration[0].length);\n    const name = declaration[3] !== undefined ? declaration[3] : '';\n    const type = declaration[2];\n    const precision = declaration[1] !== undefined ? declaration[1] : '';\n    const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : '';\n    return {\n      type,\n      inputs,\n      name,\n      precision,\n      inputsCode,\n      blockCode,\n      headerCode\n    };\n  } else {\n    throw new Error('FunctionNode: Function is not a GLSL code.');\n  }\n};\nclass GLSLNodeFunction extends NodeFunction {\n  constructor(source) {\n    const {\n      type,\n      inputs,\n      name,\n      precision,\n      inputsCode,\n      blockCode,\n      headerCode\n    } = parse$1(source);\n    super(type, inputs, name, precision);\n    this.inputsCode = inputsCode;\n    this.blockCode = blockCode;\n    this.headerCode = headerCode;\n  }\n  getCode(name = this.name) {\n    let code;\n    const blockCode = this.blockCode;\n    if (blockCode !== '') {\n      const {\n        type,\n        inputsCode,\n        headerCode,\n        precision\n      } = this;\n      let declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;\n      if (precision !== '') {\n        declarationCode = `${precision} ${declarationCode}`;\n      }\n      code = headerCode + declarationCode + blockCode;\n    } else {\n      // interface function\n\n      code = '';\n    }\n    return code;\n  }\n}\nclass GLSLNodeParser extends NodeParser {\n  parseFunction(source) {\n    return new GLSLNodeFunction(source);\n  }\n}\nconst outputNodeMap = new WeakMap();\nclass Nodes extends DataMap {\n  constructor(renderer, backend) {\n    super();\n    this.renderer = renderer;\n    this.backend = backend;\n    this.nodeFrame = new NodeFrame();\n    this.nodeBuilderCache = new Map();\n    this.callHashCache = new ChainMap();\n    this.groupsData = new ChainMap();\n  }\n  updateGroup(nodeUniformsGroup) {\n    const groupNode = nodeUniformsGroup.groupNode;\n    const name = groupNode.name;\n\n    // objectGroup is every updated\n\n    if (name === objectGroup.name) return true;\n\n    // renderGroup is updated once per render/compute call\n\n    if (name === renderGroup.name) {\n      const uniformsGroupData = this.get(nodeUniformsGroup);\n      const renderId = this.nodeFrame.renderId;\n      if (uniformsGroupData.renderId !== renderId) {\n        uniformsGroupData.renderId = renderId;\n        return true;\n      }\n      return false;\n    }\n\n    // frameGroup is updated once per frame\n\n    if (name === frameGroup.name) {\n      const uniformsGroupData = this.get(nodeUniformsGroup);\n      const frameId = this.nodeFrame.frameId;\n      if (uniformsGroupData.frameId !== frameId) {\n        uniformsGroupData.frameId = frameId;\n        return true;\n      }\n      return false;\n    }\n\n    // other groups are updated just when groupNode.needsUpdate is true\n\n    const groupChain = [groupNode, nodeUniformsGroup];\n    let groupData = this.groupsData.get(groupChain);\n    if (groupData === undefined) this.groupsData.set(groupChain, groupData = {});\n    if (groupData.version !== groupNode.version) {\n      groupData.version = groupNode.version;\n      return true;\n    }\n    return false;\n  }\n  getForRenderCacheKey(renderObject) {\n    return renderObject.initialCacheKey;\n  }\n  getForRender(renderObject) {\n    const renderObjectData = this.get(renderObject);\n    let nodeBuilderState = renderObjectData.nodeBuilderState;\n    if (nodeBuilderState === undefined) {\n      const {\n        nodeBuilderCache\n      } = this;\n      const cacheKey = this.getForRenderCacheKey(renderObject);\n      nodeBuilderState = nodeBuilderCache.get(cacheKey);\n      if (nodeBuilderState === undefined) {\n        const nodeBuilder = this.backend.createNodeBuilder(renderObject.object, this.renderer);\n        nodeBuilder.scene = renderObject.scene;\n        nodeBuilder.material = renderObject.material;\n        nodeBuilder.camera = renderObject.camera;\n        nodeBuilder.context.material = renderObject.material;\n        nodeBuilder.lightsNode = renderObject.lightsNode;\n        nodeBuilder.environmentNode = this.getEnvironmentNode(renderObject.scene);\n        nodeBuilder.fogNode = this.getFogNode(renderObject.scene);\n        nodeBuilder.clippingContext = renderObject.clippingContext;\n        nodeBuilder.build();\n        nodeBuilderState = this._createNodeBuilderState(nodeBuilder);\n        nodeBuilderCache.set(cacheKey, nodeBuilderState);\n      }\n      nodeBuilderState.usedTimes++;\n      renderObjectData.nodeBuilderState = nodeBuilderState;\n    }\n    return nodeBuilderState;\n  }\n  delete(object) {\n    if (object.isRenderObject) {\n      const nodeBuilderState = this.get(object).nodeBuilderState;\n      nodeBuilderState.usedTimes--;\n      if (nodeBuilderState.usedTimes === 0) {\n        this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));\n      }\n    }\n    return super.delete(object);\n  }\n  getForCompute(computeNode) {\n    const computeData = this.get(computeNode);\n    let nodeBuilderState = computeData.nodeBuilderState;\n    if (nodeBuilderState === undefined) {\n      const nodeBuilder = this.backend.createNodeBuilder(computeNode, this.renderer);\n      nodeBuilder.build();\n      nodeBuilderState = this._createNodeBuilderState(nodeBuilder);\n      computeData.nodeBuilderState = nodeBuilderState;\n    }\n    return nodeBuilderState;\n  }\n  _createNodeBuilderState(nodeBuilder) {\n    return new NodeBuilderState(nodeBuilder.vertexShader, nodeBuilder.fragmentShader, nodeBuilder.computeShader, nodeBuilder.getAttributesArray(), nodeBuilder.getBindings(), nodeBuilder.updateNodes, nodeBuilder.updateBeforeNodes, nodeBuilder.updateAfterNodes, nodeBuilder.monitor, nodeBuilder.transforms);\n  }\n  getEnvironmentNode(scene) {\n    return scene.environmentNode || this.get(scene).environmentNode || null;\n  }\n  getBackgroundNode(scene) {\n    return scene.backgroundNode || this.get(scene).backgroundNode || null;\n  }\n  getFogNode(scene) {\n    return scene.fogNode || this.get(scene).fogNode || null;\n  }\n  getCacheKey(scene, lightsNode) {\n    const chain = [scene, lightsNode];\n    const callId = this.renderer.info.calls;\n    let cacheKeyData = this.callHashCache.get(chain);\n    if (cacheKeyData === undefined || cacheKeyData.callId !== callId) {\n      const environmentNode = this.getEnvironmentNode(scene);\n      const fogNode = this.getFogNode(scene);\n      const values = [];\n      if (lightsNode) values.push(lightsNode.getCacheKey(true));\n      if (environmentNode) values.push(environmentNode.getCacheKey());\n      if (fogNode) values.push(fogNode.getCacheKey());\n      values.push(this.renderer.shadowMap.enabled ? 1 : 0);\n      cacheKeyData = {\n        callId,\n        cacheKey: hashArray(values)\n      };\n      this.callHashCache.set(chain, cacheKeyData);\n    }\n    return cacheKeyData.cacheKey;\n  }\n  updateScene(scene) {\n    this.updateEnvironment(scene);\n    this.updateFog(scene);\n    this.updateBackground(scene);\n  }\n  get isToneMappingState() {\n    return this.renderer.getRenderTarget() ? false : true;\n  }\n  updateBackground(scene) {\n    const sceneData = this.get(scene);\n    const background = scene.background;\n    if (background) {\n      const forceUpdate = scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 || scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0;\n      if (sceneData.background !== background || forceUpdate) {\n        let backgroundNode = null;\n        if (background.isCubeTexture === true || background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping) {\n          if (scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping) {\n            backgroundNode = pmremTexture(background);\n          } else {\n            let envMap;\n            if (background.isCubeTexture === true) {\n              envMap = cubeTexture(background);\n            } else {\n              envMap = texture(background);\n            }\n            backgroundNode = cubeMapNode(envMap);\n          }\n        } else if (background.isTexture === true) {\n          backgroundNode = texture(background, screenUV.flipY()).setUpdateMatrix(true);\n        } else if (background.isColor !== true) {\n          console.error('WebGPUNodes: Unsupported background configuration.', background);\n        }\n        sceneData.backgroundNode = backgroundNode;\n        sceneData.background = background;\n        sceneData.backgroundBlurriness = scene.backgroundBlurriness;\n      }\n    } else if (sceneData.backgroundNode) {\n      delete sceneData.backgroundNode;\n      delete sceneData.background;\n    }\n  }\n  updateFog(scene) {\n    const sceneData = this.get(scene);\n    const fog = scene.fog;\n    if (fog) {\n      if (sceneData.fog !== fog) {\n        let fogNode = null;\n        if (fog.isFogExp2) {\n          const color = reference('color', 'color', fog).setGroup(renderGroup);\n          const density = reference('density', 'float', fog).setGroup(renderGroup);\n          fogNode = densityFog(color, density);\n        } else if (fog.isFog) {\n          const color = reference('color', 'color', fog).setGroup(renderGroup);\n          const near = reference('near', 'float', fog).setGroup(renderGroup);\n          const far = reference('far', 'float', fog).setGroup(renderGroup);\n          fogNode = rangeFog(color, near, far);\n        } else {\n          console.error('WebGPUNodes: Unsupported fog configuration.', fog);\n        }\n        sceneData.fogNode = fogNode;\n        sceneData.fog = fog;\n      }\n    } else {\n      delete sceneData.fogNode;\n      delete sceneData.fog;\n    }\n  }\n  updateEnvironment(scene) {\n    const sceneData = this.get(scene);\n    const environment = scene.environment;\n    if (environment) {\n      if (sceneData.environment !== environment) {\n        let environmentNode = null;\n        if (environment.isCubeTexture === true) {\n          environmentNode = cubeTexture(environment);\n        } else if (environment.isTexture === true) {\n          environmentNode = texture(environment);\n        } else {\n          console.error('Nodes: Unsupported environment configuration.', environment);\n        }\n        sceneData.environmentNode = environmentNode;\n        sceneData.environment = environment;\n      }\n    } else if (sceneData.environmentNode) {\n      delete sceneData.environmentNode;\n      delete sceneData.environment;\n    }\n  }\n  getNodeFrame(renderer = this.renderer, scene = null, object = null, camera = null, material = null) {\n    const nodeFrame = this.nodeFrame;\n    nodeFrame.renderer = renderer;\n    nodeFrame.scene = scene;\n    nodeFrame.object = object;\n    nodeFrame.camera = camera;\n    nodeFrame.material = material;\n    return nodeFrame;\n  }\n  getNodeFrameForRender(renderObject) {\n    return this.getNodeFrame(renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material);\n  }\n  getOutputCacheKey() {\n    const renderer = this.renderer;\n    return renderer.toneMapping + ',' + renderer.currentColorSpace;\n  }\n  hasOutputChange(outputTarget) {\n    const cacheKey = outputNodeMap.get(outputTarget);\n    return cacheKey !== this.getOutputCacheKey();\n  }\n  getOutputNode(outputTexture) {\n    const renderer = this.renderer;\n    const cacheKey = this.getOutputCacheKey();\n    const output = texture(outputTexture, screenUV).renderOutput(renderer.toneMapping, renderer.currentColorSpace);\n    outputNodeMap.set(outputTexture, cacheKey);\n    return output;\n  }\n  updateBefore(renderObject) {\n    const nodeBuilder = renderObject.getNodeBuilderState();\n    for (const node of nodeBuilder.updateBeforeNodes) {\n      // update frame state for each node\n\n      this.getNodeFrameForRender(renderObject).updateBeforeNode(node);\n    }\n  }\n  updateAfter(renderObject) {\n    const nodeBuilder = renderObject.getNodeBuilderState();\n    for (const node of nodeBuilder.updateAfterNodes) {\n      // update frame state for each node\n\n      this.getNodeFrameForRender(renderObject).updateAfterNode(node);\n    }\n  }\n  updateForCompute(computeNode) {\n    const nodeFrame = this.getNodeFrame();\n    const nodeBuilder = this.getForCompute(computeNode);\n    for (const node of nodeBuilder.updateNodes) {\n      nodeFrame.updateNode(node);\n    }\n  }\n  updateForRender(renderObject) {\n    const nodeFrame = this.getNodeFrameForRender(renderObject);\n    const nodeBuilder = renderObject.getNodeBuilderState();\n    for (const node of nodeBuilder.updateNodes) {\n      nodeFrame.updateNode(node);\n    }\n  }\n  needsRefresh(renderObject) {\n    const nodeFrame = this.getNodeFrameForRender(renderObject);\n    const monitor = renderObject.getMonitor();\n    return monitor.needsRefresh(renderObject, nodeFrame);\n  }\n  dispose() {\n    super.dispose();\n    this.nodeFrame = new NodeFrame();\n    this.nodeBuilderCache = new Map();\n  }\n}\nconst _plane = /*@__PURE__*/new Plane();\nclass ClippingContext {\n  constructor(parentContext = null) {\n    this.version = 0;\n    this.clipIntersection = null;\n    this.cacheKey = '';\n    if (parentContext === null) {\n      this.intersectionPlanes = [];\n      this.unionPlanes = [];\n      this.viewNormalMatrix = new Matrix3();\n      this.clippingGroupContexts = new WeakMap();\n      this.shadowPass = false;\n    } else {\n      this.viewNormalMatrix = parentContext.viewNormalMatrix;\n      this.clippingGroupContexts = parentContext.clippingGroupContexts;\n      this.shadowPass = parentContext.shadowPass;\n      this.viewMatrix = parentContext.viewMatrix;\n    }\n    this.parentVersion = null;\n  }\n  projectPlanes(source, destination, offset) {\n    const l = source.length;\n    for (let i = 0; i < l; i++) {\n      _plane.copy(source[i]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);\n      const v = destination[offset + i];\n      const normal = _plane.normal;\n      v.x = -normal.x;\n      v.y = -normal.y;\n      v.z = -normal.z;\n      v.w = _plane.constant;\n    }\n  }\n  updateGlobal(scene, camera) {\n    this.shadowPass = scene.overrideMaterial !== null && scene.overrideMaterial.isShadowNodeMaterial;\n    this.viewMatrix = camera.matrixWorldInverse;\n    this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);\n  }\n  update(parentContext, clippingGroup) {\n    let update = false;\n    if (parentContext.version !== this.parentVersion) {\n      this.intersectionPlanes = Array.from(parentContext.intersectionPlanes);\n      this.unionPlanes = Array.from(parentContext.unionPlanes);\n      this.parentVersion = parentContext.version;\n    }\n    if (this.clipIntersection !== clippingGroup.clipIntersection) {\n      this.clipIntersection = clippingGroup.clipIntersection;\n      if (this.clipIntersection) {\n        this.unionPlanes.length = parentContext.unionPlanes.length;\n      } else {\n        this.intersectionPlanes.length = parentContext.intersectionPlanes.length;\n      }\n    }\n    const srcClippingPlanes = clippingGroup.clippingPlanes;\n    const l = srcClippingPlanes.length;\n    let dstClippingPlanes;\n    let offset;\n    if (this.clipIntersection) {\n      dstClippingPlanes = this.intersectionPlanes;\n      offset = parentContext.intersectionPlanes.length;\n    } else {\n      dstClippingPlanes = this.unionPlanes;\n      offset = parentContext.unionPlanes.length;\n    }\n    if (dstClippingPlanes.length !== offset + l) {\n      dstClippingPlanes.length = offset + l;\n      for (let i = 0; i < l; i++) {\n        dstClippingPlanes[offset + i] = new Vector4();\n      }\n      update = true;\n    }\n    this.projectPlanes(srcClippingPlanes, dstClippingPlanes, offset);\n    if (update) {\n      this.version++;\n      this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`;\n    }\n  }\n  getGroupContext(clippingGroup) {\n    if (this.shadowPass && !clippingGroup.clipShadows) return this;\n    let context = this.clippingGroupContexts.get(clippingGroup);\n    if (context === undefined) {\n      context = new ClippingContext(this);\n      this.clippingGroupContexts.set(clippingGroup, context);\n    }\n    context.update(this, clippingGroup);\n    return context;\n  }\n  get unionClippingCount() {\n    return this.unionPlanes.length;\n  }\n}\nclass RenderBundle {\n  constructor(scene, camera) {\n    this.scene = scene;\n    this.camera = camera;\n  }\n  clone() {\n    return Object.assign(new this.constructor(), this);\n  }\n}\nclass RenderBundles {\n  constructor() {\n    this.lists = new ChainMap();\n  }\n  get(scene, camera) {\n    const lists = this.lists;\n    const keys = [scene, camera];\n    let list = lists.get(keys);\n    if (list === undefined) {\n      list = new RenderBundle(scene, camera);\n      lists.set(keys, list);\n    }\n    return list;\n  }\n  dispose() {\n    this.lists = new ChainMap();\n  }\n}\nclass NodeLibrary {\n  constructor() {\n    this.lightNodes = new WeakMap();\n    this.materialNodes = new Map();\n    this.toneMappingNodes = new Map();\n  }\n  fromMaterial(material) {\n    if (material.isNodeMaterial) return material;\n    let nodeMaterial = null;\n    const nodeMaterialClass = this.getMaterialNodeClass(material.type);\n    if (nodeMaterialClass !== null) {\n      nodeMaterial = new nodeMaterialClass();\n      for (const key in material) {\n        nodeMaterial[key] = material[key];\n      }\n    }\n    return nodeMaterial;\n  }\n  addToneMapping(toneMappingNode, toneMapping) {\n    this.addType(toneMappingNode, toneMapping, this.toneMappingNodes);\n  }\n  getToneMappingFunction(toneMapping) {\n    return this.toneMappingNodes.get(toneMapping) || null;\n  }\n  getMaterialNodeClass(materialType) {\n    return this.materialNodes.get(materialType) || null;\n  }\n  addMaterial(materialNodeClass, materialClassType) {\n    this.addType(materialNodeClass, materialClassType, this.materialNodes);\n  }\n  getLightNodeClass(light) {\n    return this.lightNodes.get(light) || null;\n  }\n  addLight(lightNodeClass, lightClass) {\n    this.addClass(lightNodeClass, lightClass, this.lightNodes);\n  }\n  addType(nodeClass, type, library) {\n    if (library.has(type)) {\n      console.warn(`Redefinition of node ${type}`);\n      return;\n    }\n    if (typeof nodeClass !== 'function') throw new Error(`Node class ${nodeClass.name} is not a class.`);\n    if (typeof type === 'function' || typeof type === 'object') throw new Error(`Base class ${type} is not a class.`);\n    library.set(type, nodeClass);\n  }\n  addClass(nodeClass, baseClass, library) {\n    if (library.has(baseClass)) {\n      console.warn(`Redefinition of node ${baseClass.name}`);\n      return;\n    }\n    if (typeof nodeClass !== 'function') throw new Error(`Node class ${nodeClass.name} is not a class.`);\n    if (typeof baseClass !== 'function') throw new Error(`Base class ${baseClass.name} is not a class.`);\n    library.set(baseClass, nodeClass);\n  }\n}\nconst _defaultLights = /*@__PURE__*/new LightsNode();\nclass Lighting extends ChainMap {\n  constructor() {\n    super();\n  }\n  createNode(lights = []) {\n    return new LightsNode().setLights(lights);\n  }\n  getNode(scene, camera) {\n    // ignore post-processing\n\n    if (scene.isQuadMesh) return _defaultLights;\n\n    // tiled lighting\n\n    const keys = [scene, camera];\n    let node = this.get(keys);\n    if (node === undefined) {\n      node = this.createNode();\n      this.set(keys, node);\n    }\n    return node;\n  }\n}\nconst _scene = /*@__PURE__*/new Scene();\nconst _drawingBufferSize = /*@__PURE__*/new Vector2();\nconst _screen = /*@__PURE__*/new Vector4();\nconst _frustum = /*@__PURE__*/new Frustum();\nconst _projScreenMatrix = /*@__PURE__*/new Matrix4();\nconst _vector4 = /*@__PURE__*/new Vector4();\nclass Renderer {\n  constructor(backend, parameters = {}) {\n    this.isRenderer = true;\n\n    //\n\n    const {\n      logarithmicDepthBuffer = false,\n      alpha = true,\n      depth = true,\n      stencil = false,\n      antialias = false,\n      samples = 0,\n      getFallback = null\n    } = parameters;\n\n    // public\n    this.domElement = backend.getDomElement();\n    this.backend = backend;\n    this.samples = samples || antialias === true ? 4 : 0;\n    this.autoClear = true;\n    this.autoClearColor = true;\n    this.autoClearDepth = true;\n    this.autoClearStencil = true;\n    this.alpha = alpha;\n    this.logarithmicDepthBuffer = logarithmicDepthBuffer;\n    this.outputColorSpace = SRGBColorSpace;\n    this.toneMapping = NoToneMapping;\n    this.toneMappingExposure = 1.0;\n    this.sortObjects = true;\n    this.depth = depth;\n    this.stencil = stencil;\n    this.info = new Info();\n    this.nodes = {\n      modelViewMatrix: null,\n      modelNormalViewMatrix: null\n    };\n    this.library = new NodeLibrary();\n    this.lighting = new Lighting();\n\n    // internals\n\n    this._getFallback = getFallback;\n    this._pixelRatio = 1;\n    this._width = this.domElement.width;\n    this._height = this.domElement.height;\n    this._viewport = new Vector4(0, 0, this._width, this._height);\n    this._scissor = new Vector4(0, 0, this._width, this._height);\n    this._scissorTest = false;\n    this._attributes = null;\n    this._geometries = null;\n    this._nodes = null;\n    this._animation = null;\n    this._bindings = null;\n    this._objects = null;\n    this._pipelines = null;\n    this._bundles = null;\n    this._renderLists = null;\n    this._renderContexts = null;\n    this._textures = null;\n    this._background = null;\n    this._quad = new QuadMesh(new NodeMaterial());\n    this._quad.material.type = 'Renderer_output';\n    this._currentRenderContext = null;\n    this._opaqueSort = null;\n    this._transparentSort = null;\n    this._frameBufferTarget = null;\n    const alphaClear = this.alpha === true ? 0 : 1;\n    this._clearColor = new Color4(0, 0, 0, alphaClear);\n    this._clearDepth = 1;\n    this._clearStencil = 0;\n    this._renderTarget = null;\n    this._activeCubeFace = 0;\n    this._activeMipmapLevel = 0;\n    this._mrt = null;\n    this._renderObjectFunction = null;\n    this._currentRenderObjectFunction = null;\n    this._currentRenderBundle = null;\n    this._handleObjectFunction = this._renderObjectDirect;\n    this._isDeviceLost = false;\n    this.onDeviceLost = this._onDeviceLost;\n    this._initialized = false;\n    this._initPromise = null;\n    this._compilationPromises = null;\n    this.transparent = true;\n    this.opaque = true;\n    this.shadowMap = {\n      enabled: false,\n      type: PCFShadowMap\n    };\n    this.xr = {\n      enabled: false\n    };\n    this.debug = {\n      checkShaderErrors: true,\n      onShaderError: null,\n      getShaderAsync: async (scene, camera, object) => {\n        await this.compileAsync(scene, camera);\n        const renderList = this._renderLists.get(scene, camera);\n        const renderContext = this._renderContexts.get(scene, camera, this._renderTarget);\n        const material = scene.overrideMaterial || object.material;\n        const renderObject = this._objects.get(object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext);\n        const {\n          fragmentShader,\n          vertexShader\n        } = renderObject.getNodeBuilderState();\n        return {\n          fragmentShader,\n          vertexShader\n        };\n      }\n    };\n  }\n  async init() {\n    if (this._initialized) {\n      throw new Error('Renderer: Backend has already been initialized.');\n    }\n    if (this._initPromise !== null) {\n      return this._initPromise;\n    }\n    this._initPromise = new Promise(async (resolve, reject) => {\n      let backend = this.backend;\n      try {\n        await backend.init(this);\n      } catch (error) {\n        if (this._getFallback !== null) {\n          // try the fallback\n\n          try {\n            this.backend = backend = this._getFallback(error);\n            await backend.init(this);\n          } catch (error) {\n            reject(error);\n            return;\n          }\n        } else {\n          reject(error);\n          return;\n        }\n      }\n      this._nodes = new Nodes(this, backend);\n      this._animation = new Animation(this._nodes, this.info);\n      this._attributes = new Attributes(backend);\n      this._background = new Background(this, this._nodes);\n      this._geometries = new Geometries(this._attributes, this.info);\n      this._textures = new Textures(this, backend, this.info);\n      this._pipelines = new Pipelines(backend, this._nodes);\n      this._bindings = new Bindings(backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info);\n      this._objects = new RenderObjects(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info);\n      this._renderLists = new RenderLists(this.lighting);\n      this._bundles = new RenderBundles();\n      this._renderContexts = new RenderContexts();\n\n      //\n\n      this._animation.start();\n      this._initialized = true;\n      resolve();\n    });\n    return this._initPromise;\n  }\n  get coordinateSystem() {\n    return this.backend.coordinateSystem;\n  }\n  async compileAsync(scene, camera, targetScene = null) {\n    if (this._isDeviceLost === true) return;\n    if (this._initialized === false) await this.init();\n\n    // preserve render tree\n\n    const nodeFrame = this._nodes.nodeFrame;\n    const previousRenderId = nodeFrame.renderId;\n    const previousRenderContext = this._currentRenderContext;\n    const previousRenderObjectFunction = this._currentRenderObjectFunction;\n    const previousCompilationPromises = this._compilationPromises;\n\n    //\n\n    const sceneRef = scene.isScene === true ? scene : _scene;\n    if (targetScene === null) targetScene = scene;\n    const renderTarget = this._renderTarget;\n    const renderContext = this._renderContexts.get(targetScene, camera, renderTarget);\n    const activeMipmapLevel = this._activeMipmapLevel;\n    const compilationPromises = [];\n    this._currentRenderContext = renderContext;\n    this._currentRenderObjectFunction = this.renderObject;\n    this._handleObjectFunction = this._createObjectPipeline;\n    this._compilationPromises = compilationPromises;\n    nodeFrame.renderId++;\n\n    //\n\n    nodeFrame.update();\n\n    //\n\n    renderContext.depth = this.depth;\n    renderContext.stencil = this.stencil;\n    if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();\n    renderContext.clippingContext.updateGlobal(sceneRef, camera);\n\n    //\n\n    sceneRef.onBeforeRender(this, scene, camera, renderTarget);\n\n    //\n\n    const renderList = this._renderLists.get(scene, camera);\n    renderList.begin();\n    this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);\n\n    // include lights from target scene\n    if (targetScene !== scene) {\n      targetScene.traverseVisible(function (object) {\n        if (object.isLight && object.layers.test(camera.layers)) {\n          renderList.pushLight(object);\n        }\n      });\n    }\n    renderList.finish();\n\n    //\n\n    if (renderTarget !== null) {\n      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);\n      const renderTargetData = this._textures.get(renderTarget);\n      renderContext.textures = renderTargetData.textures;\n      renderContext.depthTexture = renderTargetData.depthTexture;\n    } else {\n      renderContext.textures = null;\n      renderContext.depthTexture = null;\n    }\n\n    //\n\n    this._nodes.updateScene(sceneRef);\n\n    //\n\n    this._background.update(sceneRef, renderList, renderContext);\n\n    // process render lists\n\n    const opaqueObjects = renderList.opaque;\n    const transparentObjects = renderList.transparent;\n    const transparentDoublePassObjects = renderList.transparentDoublePass;\n    const lightsNode = renderList.lightsNode;\n    if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);\n    if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);\n\n    // restore render tree\n\n    nodeFrame.renderId = previousRenderId;\n    this._currentRenderContext = previousRenderContext;\n    this._currentRenderObjectFunction = previousRenderObjectFunction;\n    this._compilationPromises = previousCompilationPromises;\n    this._handleObjectFunction = this._renderObjectDirect;\n\n    // wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete\n\n    await Promise.all(compilationPromises);\n  }\n  async renderAsync(scene, camera) {\n    if (this._initialized === false) await this.init();\n    const renderContext = this._renderScene(scene, camera);\n    await this.backend.resolveTimestampAsync(renderContext, 'render');\n  }\n  async waitForGPU() {\n    await this.backend.waitForGPU();\n  }\n  setMRT(mrt) {\n    this._mrt = mrt;\n    return this;\n  }\n  getMRT() {\n    return this._mrt;\n  }\n  _onDeviceLost(info) {\n    let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\\n\\nMessage: ${info.message}`;\n    if (info.reason) {\n      errorMessage += `\\nReason: ${info.reason}`;\n    }\n    console.error(errorMessage);\n    this._isDeviceLost = true;\n  }\n  _renderBundle(bundle, sceneRef, lightsNode) {\n    const {\n      bundleGroup,\n      camera,\n      renderList\n    } = bundle;\n    const renderContext = this._currentRenderContext;\n\n    //\n\n    const renderBundle = this._bundles.get(bundleGroup, camera);\n    const renderBundleData = this.backend.get(renderBundle);\n    if (renderBundleData.renderContexts === undefined) renderBundleData.renderContexts = new Set();\n\n    //\n\n    const needsUpdate = bundleGroup.version !== renderBundleData.version;\n    const renderBundleNeedsUpdate = renderBundleData.renderContexts.has(renderContext) === false || needsUpdate;\n    renderBundleData.renderContexts.add(renderContext);\n    if (renderBundleNeedsUpdate) {\n      this.backend.beginBundle(renderContext);\n      if (renderBundleData.renderObjects === undefined || needsUpdate) {\n        renderBundleData.renderObjects = [];\n      }\n      this._currentRenderBundle = renderBundle;\n      const opaqueObjects = renderList.opaque;\n      if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);\n      this._currentRenderBundle = null;\n\n      //\n\n      this.backend.finishBundle(renderContext, renderBundle);\n      renderBundleData.version = bundleGroup.version;\n    } else {\n      const {\n        renderObjects\n      } = renderBundleData;\n      for (let i = 0, l = renderObjects.length; i < l; i++) {\n        const renderObject = renderObjects[i];\n        if (this._nodes.needsRefresh(renderObject)) {\n          this._nodes.updateBefore(renderObject);\n          this._nodes.updateForRender(renderObject);\n          this._bindings.updateForRender(renderObject);\n          this._nodes.updateAfter(renderObject);\n        }\n      }\n    }\n    this.backend.addBundle(renderContext, renderBundle);\n  }\n  render(scene, camera) {\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.');\n      return this.renderAsync(scene, camera);\n    }\n    this._renderScene(scene, camera);\n  }\n  _getFrameBufferTarget() {\n    const {\n      currentToneMapping,\n      currentColorSpace\n    } = this;\n    const useToneMapping = currentToneMapping !== NoToneMapping;\n    const useColorSpace = currentColorSpace !== LinearSRGBColorSpace;\n    if (useToneMapping === false && useColorSpace === false) return null;\n    const {\n      width,\n      height\n    } = this.getDrawingBufferSize(_drawingBufferSize);\n    const {\n      depth,\n      stencil\n    } = this;\n    let frameBufferTarget = this._frameBufferTarget;\n    if (frameBufferTarget === null) {\n      frameBufferTarget = new RenderTarget(width, height, {\n        depthBuffer: depth,\n        stencilBuffer: stencil,\n        type: HalfFloatType,\n        // FloatType\n        format: RGBAFormat,\n        colorSpace: LinearSRGBColorSpace,\n        generateMipmaps: false,\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n        samples: this.samples\n      });\n      frameBufferTarget.isPostProcessingRenderTarget = true;\n      this._frameBufferTarget = frameBufferTarget;\n    }\n    frameBufferTarget.depthBuffer = depth;\n    frameBufferTarget.stencilBuffer = stencil;\n    frameBufferTarget.setSize(width, height);\n    frameBufferTarget.viewport.copy(this._viewport);\n    frameBufferTarget.scissor.copy(this._scissor);\n    frameBufferTarget.viewport.multiplyScalar(this._pixelRatio);\n    frameBufferTarget.scissor.multiplyScalar(this._pixelRatio);\n    frameBufferTarget.scissorTest = this._scissorTest;\n    return frameBufferTarget;\n  }\n  _renderScene(scene, camera, useFrameBufferTarget = true) {\n    if (this._isDeviceLost === true) return;\n    const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;\n\n    // preserve render tree\n\n    const nodeFrame = this._nodes.nodeFrame;\n    const previousRenderId = nodeFrame.renderId;\n    const previousRenderContext = this._currentRenderContext;\n    const previousRenderObjectFunction = this._currentRenderObjectFunction;\n\n    //\n\n    const sceneRef = scene.isScene === true ? scene : _scene;\n    const outputRenderTarget = this._renderTarget;\n    const activeCubeFace = this._activeCubeFace;\n    const activeMipmapLevel = this._activeMipmapLevel;\n\n    //\n\n    let renderTarget;\n    if (frameBufferTarget !== null) {\n      renderTarget = frameBufferTarget;\n      this.setRenderTarget(renderTarget);\n    } else {\n      renderTarget = outputRenderTarget;\n    }\n\n    //\n\n    const renderContext = this._renderContexts.get(scene, camera, renderTarget);\n    this._currentRenderContext = renderContext;\n    this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;\n\n    //\n\n    this.info.calls++;\n    this.info.render.calls++;\n    this.info.render.frameCalls++;\n    nodeFrame.renderId = this.info.calls;\n\n    //\n\n    const coordinateSystem = this.coordinateSystem;\n    if (camera.coordinateSystem !== coordinateSystem) {\n      camera.coordinateSystem = coordinateSystem;\n      camera.updateProjectionMatrix();\n    }\n\n    //\n\n    if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();\n    if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();\n\n    //\n\n    let viewport = this._viewport;\n    let scissor = this._scissor;\n    let pixelRatio = this._pixelRatio;\n    if (renderTarget !== null) {\n      viewport = renderTarget.viewport;\n      scissor = renderTarget.scissor;\n      pixelRatio = 1;\n    }\n    this.getDrawingBufferSize(_drawingBufferSize);\n    _screen.set(0, 0, _drawingBufferSize.width, _drawingBufferSize.height);\n    const minDepth = viewport.minDepth === undefined ? 0 : viewport.minDepth;\n    const maxDepth = viewport.maxDepth === undefined ? 1 : viewport.maxDepth;\n    renderContext.viewportValue.copy(viewport).multiplyScalar(pixelRatio).floor();\n    renderContext.viewportValue.width >>= activeMipmapLevel;\n    renderContext.viewportValue.height >>= activeMipmapLevel;\n    renderContext.viewportValue.minDepth = minDepth;\n    renderContext.viewportValue.maxDepth = maxDepth;\n    renderContext.viewport = renderContext.viewportValue.equals(_screen) === false;\n    renderContext.scissorValue.copy(scissor).multiplyScalar(pixelRatio).floor();\n    renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals(_screen) === false;\n    renderContext.scissorValue.width >>= activeMipmapLevel;\n    renderContext.scissorValue.height >>= activeMipmapLevel;\n    if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();\n    renderContext.clippingContext.updateGlobal(sceneRef, camera);\n\n    //\n\n    sceneRef.onBeforeRender(this, scene, camera, renderTarget);\n\n    //\n\n    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n    _frustum.setFromProjectionMatrix(_projScreenMatrix, coordinateSystem);\n    const renderList = this._renderLists.get(scene, camera);\n    renderList.begin();\n    this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);\n    renderList.finish();\n    if (this.sortObjects === true) {\n      renderList.sort(this._opaqueSort, this._transparentSort);\n    }\n\n    //\n\n    if (renderTarget !== null) {\n      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);\n      const renderTargetData = this._textures.get(renderTarget);\n      renderContext.textures = renderTargetData.textures;\n      renderContext.depthTexture = renderTargetData.depthTexture;\n      renderContext.width = renderTargetData.width;\n      renderContext.height = renderTargetData.height;\n      renderContext.renderTarget = renderTarget;\n      renderContext.depth = renderTarget.depthBuffer;\n      renderContext.stencil = renderTarget.stencilBuffer;\n    } else {\n      renderContext.textures = null;\n      renderContext.depthTexture = null;\n      renderContext.width = this.domElement.width;\n      renderContext.height = this.domElement.height;\n      renderContext.depth = this.depth;\n      renderContext.stencil = this.stencil;\n    }\n    renderContext.width >>= activeMipmapLevel;\n    renderContext.height >>= activeMipmapLevel;\n    renderContext.activeCubeFace = activeCubeFace;\n    renderContext.activeMipmapLevel = activeMipmapLevel;\n    renderContext.occlusionQueryCount = renderList.occlusionQueryCount;\n\n    //\n\n    this._nodes.updateScene(sceneRef);\n\n    //\n\n    this._background.update(sceneRef, renderList, renderContext);\n\n    //\n\n    this.backend.beginRender(renderContext);\n\n    // process render lists\n\n    const {\n      bundles,\n      lightsNode,\n      transparentDoublePass: transparentDoublePassObjects,\n      transparent: transparentObjects,\n      opaque: opaqueObjects\n    } = renderList;\n    if (bundles.length > 0) this._renderBundles(bundles, sceneRef, lightsNode);\n    if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);\n    if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);\n\n    // finish render pass\n\n    this.backend.finishRender(renderContext);\n\n    // restore render tree\n\n    nodeFrame.renderId = previousRenderId;\n    this._currentRenderContext = previousRenderContext;\n    this._currentRenderObjectFunction = previousRenderObjectFunction;\n\n    //\n\n    if (frameBufferTarget !== null) {\n      this.setRenderTarget(outputRenderTarget, activeCubeFace, activeMipmapLevel);\n      const quad = this._quad;\n      if (this._nodes.hasOutputChange(renderTarget.texture)) {\n        quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);\n        quad.material.needsUpdate = true;\n      }\n      this._renderScene(quad, quad.camera, false);\n    }\n\n    //\n\n    sceneRef.onAfterRender(this, scene, camera, renderTarget);\n\n    //\n\n    return renderContext;\n  }\n  getMaxAnisotropy() {\n    return this.backend.getMaxAnisotropy();\n  }\n  getActiveCubeFace() {\n    return this._activeCubeFace;\n  }\n  getActiveMipmapLevel() {\n    return this._activeMipmapLevel;\n  }\n  async setAnimationLoop(callback) {\n    if (this._initialized === false) await this.init();\n    this._animation.setAnimationLoop(callback);\n  }\n  async getArrayBufferAsync(attribute) {\n    return await this.backend.getArrayBufferAsync(attribute);\n  }\n  getContext() {\n    return this.backend.getContext();\n  }\n  getPixelRatio() {\n    return this._pixelRatio;\n  }\n  getDrawingBufferSize(target) {\n    return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();\n  }\n  getSize(target) {\n    return target.set(this._width, this._height);\n  }\n  setPixelRatio(value = 1) {\n    if (this._pixelRatio === value) return;\n    this._pixelRatio = value;\n    this.setSize(this._width, this._height, false);\n  }\n  setDrawingBufferSize(width, height, pixelRatio) {\n    this._width = width;\n    this._height = height;\n    this._pixelRatio = pixelRatio;\n    this.domElement.width = Math.floor(width * pixelRatio);\n    this.domElement.height = Math.floor(height * pixelRatio);\n    this.setViewport(0, 0, width, height);\n    if (this._initialized) this.backend.updateSize();\n  }\n  setSize(width, height, updateStyle = true) {\n    this._width = width;\n    this._height = height;\n    this.domElement.width = Math.floor(width * this._pixelRatio);\n    this.domElement.height = Math.floor(height * this._pixelRatio);\n    if (updateStyle === true) {\n      this.domElement.style.width = width + 'px';\n      this.domElement.style.height = height + 'px';\n    }\n    this.setViewport(0, 0, width, height);\n    if (this._initialized) this.backend.updateSize();\n  }\n  setOpaqueSort(method) {\n    this._opaqueSort = method;\n  }\n  setTransparentSort(method) {\n    this._transparentSort = method;\n  }\n  getScissor(target) {\n    const scissor = this._scissor;\n    target.x = scissor.x;\n    target.y = scissor.y;\n    target.width = scissor.width;\n    target.height = scissor.height;\n    return target;\n  }\n  setScissor(x, y, width, height) {\n    const scissor = this._scissor;\n    if (x.isVector4) {\n      scissor.copy(x);\n    } else {\n      scissor.set(x, y, width, height);\n    }\n  }\n  getScissorTest() {\n    return this._scissorTest;\n  }\n  setScissorTest(boolean) {\n    this._scissorTest = boolean;\n    this.backend.setScissorTest(boolean);\n  }\n  getViewport(target) {\n    return target.copy(this._viewport);\n  }\n  setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {\n    const viewport = this._viewport;\n    if (x.isVector4) {\n      viewport.copy(x);\n    } else {\n      viewport.set(x, y, width, height);\n    }\n    viewport.minDepth = minDepth;\n    viewport.maxDepth = maxDepth;\n  }\n  getClearColor(target) {\n    return target.copy(this._clearColor);\n  }\n  setClearColor(color, alpha = 1) {\n    this._clearColor.set(color);\n    this._clearColor.a = alpha;\n  }\n  getClearAlpha() {\n    return this._clearColor.a;\n  }\n  setClearAlpha(alpha) {\n    this._clearColor.a = alpha;\n  }\n  getClearDepth() {\n    return this._clearDepth;\n  }\n  setClearDepth(depth) {\n    this._clearDepth = depth;\n  }\n  getClearStencil() {\n    return this._clearStencil;\n  }\n  setClearStencil(stencil) {\n    this._clearStencil = stencil;\n  }\n  isOccluded(object) {\n    const renderContext = this._currentRenderContext;\n    return renderContext && this.backend.isOccluded(renderContext, object);\n  }\n  clear(color = true, depth = true, stencil = true) {\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.');\n      return this.clearAsync(color, depth, stencil);\n    }\n    const renderTarget = this._renderTarget || this._getFrameBufferTarget();\n    let renderTargetData = null;\n    if (renderTarget !== null) {\n      this._textures.updateRenderTarget(renderTarget);\n      renderTargetData = this._textures.get(renderTarget);\n    }\n    this.backend.clear(color, depth, stencil, renderTargetData);\n    if (renderTarget !== null && this._renderTarget === null) {\n      // If a color space transform or tone mapping is required,\n      // the clear operation clears the intermediate renderTarget texture, but does not update the screen canvas.\n\n      const quad = this._quad;\n      if (this._nodes.hasOutputChange(renderTarget.texture)) {\n        quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);\n        quad.material.needsUpdate = true;\n      }\n      this._renderScene(quad, quad.camera, false);\n    }\n  }\n  clearColor() {\n    return this.clear(true, false, false);\n  }\n  clearDepth() {\n    return this.clear(false, true, false);\n  }\n  clearStencil() {\n    return this.clear(false, false, true);\n  }\n  async clearAsync(color = true, depth = true, stencil = true) {\n    if (this._initialized === false) await this.init();\n    this.clear(color, depth, stencil);\n  }\n  clearColorAsync() {\n    return this.clearAsync(true, false, false);\n  }\n  clearDepthAsync() {\n    return this.clearAsync(false, true, false);\n  }\n  clearStencilAsync() {\n    return this.clearAsync(false, false, true);\n  }\n  get currentToneMapping() {\n    return this._renderTarget !== null ? NoToneMapping : this.toneMapping;\n  }\n  get currentColorSpace() {\n    return this._renderTarget !== null ? LinearSRGBColorSpace : this.outputColorSpace;\n  }\n  dispose() {\n    this.info.dispose();\n    this.backend.dispose();\n    this._animation.dispose();\n    this._objects.dispose();\n    this._pipelines.dispose();\n    this._nodes.dispose();\n    this._bindings.dispose();\n    this._renderLists.dispose();\n    this._renderContexts.dispose();\n    this._textures.dispose();\n    this.setRenderTarget(null);\n    this.setAnimationLoop(null);\n  }\n  setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {\n    this._renderTarget = renderTarget;\n    this._activeCubeFace = activeCubeFace;\n    this._activeMipmapLevel = activeMipmapLevel;\n  }\n  getRenderTarget() {\n    return this._renderTarget;\n  }\n  setRenderObjectFunction(renderObjectFunction) {\n    this._renderObjectFunction = renderObjectFunction;\n  }\n  getRenderObjectFunction() {\n    return this._renderObjectFunction;\n  }\n  compute(computeNodes) {\n    if (this.isDeviceLost === true) return;\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.');\n      return this.computeAsync(computeNodes);\n    }\n\n    //\n\n    const nodeFrame = this._nodes.nodeFrame;\n    const previousRenderId = nodeFrame.renderId;\n\n    //\n\n    this.info.calls++;\n    this.info.compute.calls++;\n    this.info.compute.frameCalls++;\n    nodeFrame.renderId = this.info.calls;\n\n    //\n\n    const backend = this.backend;\n    const pipelines = this._pipelines;\n    const bindings = this._bindings;\n    const nodes = this._nodes;\n    const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];\n    if (computeList[0] === undefined || computeList[0].isComputeNode !== true) {\n      throw new Error('THREE.Renderer: .compute() expects a ComputeNode.');\n    }\n    backend.beginCompute(computeNodes);\n    for (const computeNode of computeList) {\n      // onInit\n\n      if (pipelines.has(computeNode) === false) {\n        const dispose = () => {\n          computeNode.removeEventListener('dispose', dispose);\n          pipelines.delete(computeNode);\n          bindings.delete(computeNode);\n          nodes.delete(computeNode);\n        };\n        computeNode.addEventListener('dispose', dispose);\n\n        //\n\n        const onInitFn = computeNode.onInitFunction;\n        if (onInitFn !== null) {\n          onInitFn.call(computeNode, {\n            renderer: this\n          });\n        }\n      }\n      nodes.updateForCompute(computeNode);\n      bindings.updateForCompute(computeNode);\n      const computeBindings = bindings.getForCompute(computeNode);\n      const computePipeline = pipelines.getForCompute(computeNode, computeBindings);\n      backend.compute(computeNodes, computeNode, computeBindings, computePipeline);\n    }\n    backend.finishCompute(computeNodes);\n\n    //\n\n    nodeFrame.renderId = previousRenderId;\n  }\n  async computeAsync(computeNodes) {\n    if (this._initialized === false) await this.init();\n    this.compute(computeNodes);\n    await this.backend.resolveTimestampAsync(computeNodes, 'compute');\n  }\n  async hasFeatureAsync(name) {\n    if (this._initialized === false) await this.init();\n    return this.backend.hasFeature(name);\n  }\n  hasFeature(name) {\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.');\n      return false;\n    }\n    return this.backend.hasFeature(name);\n  }\n  hasInitialized() {\n    return this._initialized;\n  }\n  async initTextureAsync(texture) {\n    if (this._initialized === false) await this.init();\n    this._textures.updateTexture(texture);\n  }\n  initTexture(texture) {\n    if (this._initialized === false) {\n      console.warn('THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.');\n      return false;\n    }\n    this._textures.updateTexture(texture);\n  }\n  copyFramebufferToTexture(framebufferTexture, rectangle = null) {\n    if (rectangle !== null) {\n      if (rectangle.isVector2) {\n        rectangle = _vector4.set(rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height).floor();\n      } else if (rectangle.isVector4) {\n        rectangle = _vector4.copy(rectangle).floor();\n      } else {\n        console.error('THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.');\n        return;\n      }\n    } else {\n      rectangle = _vector4.set(0, 0, framebufferTexture.image.width, framebufferTexture.image.height);\n    }\n\n    //\n\n    let renderContext = this._currentRenderContext;\n    let renderTarget;\n    if (renderContext !== null) {\n      renderTarget = renderContext.renderTarget;\n    } else {\n      renderTarget = this._renderTarget || this._getFrameBufferTarget();\n      if (renderTarget !== null) {\n        this._textures.updateRenderTarget(renderTarget);\n        renderContext = this._textures.get(renderTarget);\n      }\n    }\n\n    //\n\n    this._textures.updateTexture(framebufferTexture, {\n      renderTarget\n    });\n    this.backend.copyFramebufferToTexture(framebufferTexture, renderContext, rectangle);\n  }\n  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {\n    this._textures.updateTexture(srcTexture);\n    this._textures.updateTexture(dstTexture);\n    this.backend.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);\n  }\n  readRenderTargetPixelsAsync(renderTarget, x, y, width, height, index = 0, faceIndex = 0) {\n    return this.backend.copyTextureToBuffer(renderTarget.textures[index], x, y, width, height, faceIndex);\n  }\n  _projectObject(object, camera, groupOrder, renderList, clippingContext) {\n    if (object.visible === false) return;\n    const visible = object.layers.test(camera.layers);\n    if (visible) {\n      if (object.isGroup) {\n        groupOrder = object.renderOrder;\n        if (object.isClippingGroup && object.enabled) clippingContext = clippingContext.getGroupContext(object);\n      } else if (object.isLOD) {\n        if (object.autoUpdate === true) object.update(camera);\n      } else if (object.isLight) {\n        renderList.pushLight(object);\n      } else if (object.isSprite) {\n        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n          if (this.sortObjects === true) {\n            _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n          const {\n            geometry,\n            material\n          } = object;\n          if (material.visible) {\n            renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);\n          }\n        }\n      } else if (object.isLineLoop) {\n        console.error('THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.');\n      } else if (object.isMesh || object.isLine || object.isPoints) {\n        if (!object.frustumCulled || _frustum.intersectsObject(object)) {\n          const {\n            geometry,\n            material\n          } = object;\n          if (this.sortObjects === true) {\n            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n            _vector4.copy(geometry.boundingSphere.center).applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n          if (Array.isArray(material)) {\n            const groups = geometry.groups;\n            for (let i = 0, l = groups.length; i < l; i++) {\n              const group = groups[i];\n              const groupMaterial = material[group.materialIndex];\n              if (groupMaterial && groupMaterial.visible) {\n                renderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext);\n              }\n            }\n          } else if (material.visible) {\n            renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);\n          }\n        }\n      }\n    }\n    if (object.isBundleGroup === true && this.backend.beginBundle !== undefined) {\n      const baseRenderList = renderList;\n\n      // replace render list\n      renderList = this._renderLists.get(object, camera);\n      renderList.begin();\n      baseRenderList.pushBundle({\n        bundleGroup: object,\n        camera,\n        renderList\n      });\n      renderList.finish();\n    }\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      this._projectObject(children[i], camera, groupOrder, renderList, clippingContext);\n    }\n  }\n  _renderBundles(bundles, sceneRef, lightsNode) {\n    for (const bundle of bundles) {\n      this._renderBundle(bundle, sceneRef, lightsNode);\n    }\n  }\n  _renderTransparents(renderList, doublePassList, camera, scene, lightsNode) {\n    if (doublePassList.length > 0) {\n      // render back side\n\n      for (const {\n        material\n      } of doublePassList) {\n        material.side = BackSide;\n      }\n      this._renderObjects(doublePassList, camera, scene, lightsNode, 'backSide');\n\n      // render front side\n\n      for (const {\n        material\n      } of doublePassList) {\n        material.side = FrontSide;\n      }\n      this._renderObjects(renderList, camera, scene, lightsNode);\n\n      // restore\n\n      for (const {\n        material\n      } of doublePassList) {\n        material.side = DoubleSide;\n      }\n    } else {\n      this._renderObjects(renderList, camera, scene, lightsNode);\n    }\n  }\n  _renderObjects(renderList, camera, scene, lightsNode, passId = null) {\n    // process renderable objects\n\n    for (let i = 0, il = renderList.length; i < il; i++) {\n      const renderItem = renderList[i];\n\n      // @TODO: Add support for multiple materials per object. This will require to extract\n      // the material from the renderItem object and pass it with its group data to renderObject().\n\n      const {\n        object,\n        geometry,\n        material,\n        group,\n        clippingContext\n      } = renderItem;\n      if (camera.isArrayCamera) {\n        const cameras = camera.cameras;\n        for (let j = 0, jl = cameras.length; j < jl; j++) {\n          const camera2 = cameras[j];\n          if (object.layers.test(camera2.layers)) {\n            const vp = camera2.viewport;\n            const minDepth = vp.minDepth === undefined ? 0 : vp.minDepth;\n            const maxDepth = vp.maxDepth === undefined ? 1 : vp.maxDepth;\n            const viewportValue = this._currentRenderContext.viewportValue;\n            viewportValue.copy(vp).multiplyScalar(this._pixelRatio).floor();\n            viewportValue.minDepth = minDepth;\n            viewportValue.maxDepth = maxDepth;\n            this.backend.updateViewport(this._currentRenderContext);\n            this._currentRenderObjectFunction(object, scene, camera2, geometry, material, group, lightsNode, clippingContext, passId);\n          }\n        }\n      } else {\n        this._currentRenderObjectFunction(object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId);\n      }\n    }\n  }\n  renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null) {\n    let overridePositionNode;\n    let overrideColorNode;\n    let overrideDepthNode;\n\n    //\n\n    object.onBeforeRender(this, scene, camera, geometry, material, group);\n\n    //\n\n    if (scene.overrideMaterial !== null) {\n      const overrideMaterial = scene.overrideMaterial;\n      if (material.positionNode && material.positionNode.isNode) {\n        overridePositionNode = overrideMaterial.positionNode;\n        overrideMaterial.positionNode = material.positionNode;\n      }\n      overrideMaterial.alphaTest = material.alphaTest;\n      overrideMaterial.alphaMap = material.alphaMap;\n      if (overrideMaterial.isShadowNodeMaterial) {\n        overrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;\n        if (material.depthNode && material.depthNode.isNode) {\n          overrideDepthNode = overrideMaterial.depthNode;\n          overrideMaterial.depthNode = material.depthNode;\n        }\n        if (material.castShadowNode && material.castShadowNode.isNode) {\n          overrideColorNode = overrideMaterial.colorNode;\n          overrideMaterial.colorNode = material.castShadowNode;\n        }\n      }\n      material = overrideMaterial;\n    }\n\n    //\n\n    if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {\n      material.side = BackSide;\n      this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, 'backSide'); // create backSide pass id\n\n      material.side = FrontSide;\n      this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, passId); // use default pass id\n\n      material.side = DoubleSide;\n    } else {\n      this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, passId);\n    }\n\n    //\n\n    if (overridePositionNode !== undefined) {\n      scene.overrideMaterial.positionNode = overridePositionNode;\n    }\n    if (overrideDepthNode !== undefined) {\n      scene.overrideMaterial.depthNode = overrideDepthNode;\n    }\n    if (overrideColorNode !== undefined) {\n      scene.overrideMaterial.colorNode = overrideColorNode;\n    }\n\n    //\n\n    object.onAfterRender(this, scene, camera, geometry, material, group);\n  }\n  _renderObjectDirect(object, material, scene, camera, lightsNode, group, clippingContext, passId) {\n    const renderObject = this._objects.get(object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId);\n    renderObject.drawRange = object.geometry.drawRange;\n    renderObject.group = group;\n\n    //\n\n    const needsRefresh = this._nodes.needsRefresh(renderObject);\n    if (needsRefresh) {\n      this._nodes.updateBefore(renderObject);\n      this._geometries.updateForRender(renderObject);\n      this._nodes.updateForRender(renderObject);\n      this._bindings.updateForRender(renderObject);\n    }\n    this._pipelines.updateForRender(renderObject);\n\n    //\n\n    if (this._currentRenderBundle !== null) {\n      const renderBundleData = this.backend.get(this._currentRenderBundle);\n      renderBundleData.renderObjects.push(renderObject);\n      renderObject.bundle = this._currentRenderBundle.scene;\n    }\n    this.backend.draw(renderObject, this.info);\n    if (needsRefresh) this._nodes.updateAfter(renderObject);\n  }\n  _createObjectPipeline(object, material, scene, camera, lightsNode, clippingContext, passId) {\n    const renderObject = this._objects.get(object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId);\n\n    //\n\n    this._nodes.updateBefore(renderObject);\n    this._geometries.updateForRender(renderObject);\n    this._nodes.updateForRender(renderObject);\n    this._bindings.updateForRender(renderObject);\n    this._pipelines.getForRender(renderObject, this._compilationPromises);\n    this._nodes.updateAfter(renderObject);\n  }\n  get compile() {\n    return this.compileAsync;\n  }\n}\nclass Binding {\n  constructor(name = '') {\n    this.name = name;\n    this.visibility = 0;\n  }\n  setVisibility(visibility) {\n    this.visibility |= visibility;\n  }\n  clone() {\n    return Object.assign(new this.constructor(), this);\n  }\n}\nfunction getFloatLength(floatLength) {\n  // ensure chunk size alignment (STD140 layout)\n\n  return floatLength + (GPU_CHUNK_BYTES - floatLength % GPU_CHUNK_BYTES) % GPU_CHUNK_BYTES;\n}\nclass Buffer extends Binding {\n  constructor(name, buffer = null) {\n    super(name);\n    this.isBuffer = true;\n    this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;\n    this._buffer = buffer;\n  }\n  get byteLength() {\n    return getFloatLength(this._buffer.byteLength);\n  }\n  get buffer() {\n    return this._buffer;\n  }\n  update() {\n    return true;\n  }\n}\nclass UniformBuffer extends Buffer {\n  constructor(name, buffer = null) {\n    super(name, buffer);\n    this.isUniformBuffer = true;\n  }\n}\nlet _id$4 = 0;\nclass NodeUniformBuffer extends UniformBuffer {\n  constructor(nodeUniform, groupNode) {\n    super('UniformBuffer_' + _id$4++, nodeUniform ? nodeUniform.value : null);\n    this.nodeUniform = nodeUniform;\n    this.groupNode = groupNode;\n  }\n  get buffer() {\n    return this.nodeUniform.value;\n  }\n}\nclass UniformsGroup extends UniformBuffer {\n  constructor(name) {\n    super(name);\n    this.isUniformsGroup = true;\n    this._values = null;\n\n    // the order of uniforms in this array must match the order of uniforms in the shader\n\n    this.uniforms = [];\n  }\n  addUniform(uniform) {\n    this.uniforms.push(uniform);\n    return this;\n  }\n  removeUniform(uniform) {\n    const index = this.uniforms.indexOf(uniform);\n    if (index !== -1) {\n      this.uniforms.splice(index, 1);\n    }\n    return this;\n  }\n  get values() {\n    if (this._values === null) {\n      this._values = Array.from(this.buffer);\n    }\n    return this._values;\n  }\n  get buffer() {\n    let buffer = this._buffer;\n    if (buffer === null) {\n      const byteLength = this.byteLength;\n      buffer = new Float32Array(new ArrayBuffer(byteLength));\n      this._buffer = buffer;\n    }\n    return buffer;\n  }\n  get byteLength() {\n    let offset = 0; // global buffer offset in bytes\n\n    for (let i = 0, l = this.uniforms.length; i < l; i++) {\n      const uniform = this.uniforms[i];\n      const {\n        boundary,\n        itemSize\n      } = uniform;\n\n      // offset within a single chunk in bytes\n\n      const chunkOffset = offset % GPU_CHUNK_BYTES;\n      const remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;\n\n      // conformance tests\n\n      if (chunkOffset !== 0 && remainingSizeInChunk - boundary < 0) {\n        // check for chunk overflow\n\n        offset += GPU_CHUNK_BYTES - chunkOffset;\n      } else if (chunkOffset % boundary !== 0) {\n        // check for correct alignment\n\n        offset += chunkOffset % boundary;\n      }\n      uniform.offset = offset / this.bytesPerElement;\n      offset += itemSize * this.bytesPerElement;\n    }\n    return Math.ceil(offset / GPU_CHUNK_BYTES) * GPU_CHUNK_BYTES;\n  }\n  update() {\n    let updated = false;\n    for (const uniform of this.uniforms) {\n      if (this.updateByType(uniform) === true) {\n        updated = true;\n      }\n    }\n    return updated;\n  }\n  updateByType(uniform) {\n    if (uniform.isNumberUniform) return this.updateNumber(uniform);\n    if (uniform.isVector2Uniform) return this.updateVector2(uniform);\n    if (uniform.isVector3Uniform) return this.updateVector3(uniform);\n    if (uniform.isVector4Uniform) return this.updateVector4(uniform);\n    if (uniform.isColorUniform) return this.updateColor(uniform);\n    if (uniform.isMatrix3Uniform) return this.updateMatrix3(uniform);\n    if (uniform.isMatrix4Uniform) return this.updateMatrix4(uniform);\n    console.error('THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform);\n  }\n  updateNumber(uniform) {\n    let updated = false;\n    const a = this.values;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    const type = uniform.getType();\n    if (a[offset] !== v) {\n      const b = this._getBufferForType(type);\n      b[offset] = a[offset] = v;\n      updated = true;\n    }\n    return updated;\n  }\n  updateVector2(uniform) {\n    let updated = false;\n    const a = this.values;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    const type = uniform.getType();\n    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y) {\n      const b = this._getBufferForType(type);\n      b[offset + 0] = a[offset + 0] = v.x;\n      b[offset + 1] = a[offset + 1] = v.y;\n      updated = true;\n    }\n    return updated;\n  }\n  updateVector3(uniform) {\n    let updated = false;\n    const a = this.values;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    const type = uniform.getType();\n    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z) {\n      const b = this._getBufferForType(type);\n      b[offset + 0] = a[offset + 0] = v.x;\n      b[offset + 1] = a[offset + 1] = v.y;\n      b[offset + 2] = a[offset + 2] = v.z;\n      updated = true;\n    }\n    return updated;\n  }\n  updateVector4(uniform) {\n    let updated = false;\n    const a = this.values;\n    const v = uniform.getValue();\n    const offset = uniform.offset;\n    const type = uniform.getType();\n    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z || a[offset + 4] !== v.w) {\n      const b = this._getBufferForType(type);\n      b[offset + 0] = a[offset + 0] = v.x;\n      b[offset + 1] = a[offset + 1] = v.y;\n      b[offset + 2] = a[offset + 2] = v.z;\n      b[offset + 3] = a[offset + 3] = v.w;\n      updated = true;\n    }\n    return updated;\n  }\n  updateColor(uniform) {\n    let updated = false;\n    const a = this.values;\n    const c = uniform.getValue();\n    const offset = uniform.offset;\n    if (a[offset + 0] !== c.r || a[offset + 1] !== c.g || a[offset + 2] !== c.b) {\n      const b = this.buffer;\n      b[offset + 0] = a[offset + 0] = c.r;\n      b[offset + 1] = a[offset + 1] = c.g;\n      b[offset + 2] = a[offset + 2] = c.b;\n      updated = true;\n    }\n    return updated;\n  }\n  updateMatrix3(uniform) {\n    let updated = false;\n    const a = this.values;\n    const e = uniform.getValue().elements;\n    const offset = uniform.offset;\n    if (a[offset + 0] !== e[0] || a[offset + 1] !== e[1] || a[offset + 2] !== e[2] || a[offset + 4] !== e[3] || a[offset + 5] !== e[4] || a[offset + 6] !== e[5] || a[offset + 8] !== e[6] || a[offset + 9] !== e[7] || a[offset + 10] !== e[8]) {\n      const b = this.buffer;\n      b[offset + 0] = a[offset + 0] = e[0];\n      b[offset + 1] = a[offset + 1] = e[1];\n      b[offset + 2] = a[offset + 2] = e[2];\n      b[offset + 4] = a[offset + 4] = e[3];\n      b[offset + 5] = a[offset + 5] = e[4];\n      b[offset + 6] = a[offset + 6] = e[5];\n      b[offset + 8] = a[offset + 8] = e[6];\n      b[offset + 9] = a[offset + 9] = e[7];\n      b[offset + 10] = a[offset + 10] = e[8];\n      updated = true;\n    }\n    return updated;\n  }\n  updateMatrix4(uniform) {\n    let updated = false;\n    const a = this.values;\n    const e = uniform.getValue().elements;\n    const offset = uniform.offset;\n    if (arraysEqual(a, e, offset) === false) {\n      const b = this.buffer;\n      b.set(e, offset);\n      setArray(a, e, offset);\n      updated = true;\n    }\n    return updated;\n  }\n  _getBufferForType(type) {\n    if (type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4') return new Int32Array(this.buffer.buffer);\n    if (type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4') return new Uint32Array(this.buffer.buffer);\n    return this.buffer;\n  }\n}\nfunction setArray(a, b, offset) {\n  for (let i = 0, l = b.length; i < l; i++) {\n    a[offset + i] = b[i];\n  }\n}\nfunction arraysEqual(a, b, offset) {\n  for (let i = 0, l = b.length; i < l; i++) {\n    if (a[offset + i] !== b[i]) return false;\n  }\n  return true;\n}\nlet _id$3 = 0;\nclass NodeUniformsGroup extends UniformsGroup {\n  constructor(name, groupNode) {\n    super(name);\n    this.id = _id$3++;\n    this.groupNode = groupNode;\n    this.isNodeUniformsGroup = true;\n  }\n  getNodes() {\n    const nodes = [];\n    for (const uniform of this.uniforms) {\n      const node = uniform.nodeUniform.node;\n      if (!node) throw new Error('NodeUniformsGroup: Uniform has no node.');\n      nodes.push(node);\n    }\n    return nodes;\n  }\n}\nlet _id$2 = 0;\nclass SampledTexture extends Binding {\n  constructor(name, texture) {\n    super(name);\n    this.id = _id$2++;\n    this.texture = texture;\n    this.version = texture ? texture.version : 0;\n    this.store = false;\n    this.generation = null;\n    this.isSampledTexture = true;\n  }\n  needsBindingsUpdate(generation) {\n    const {\n      texture\n    } = this;\n    if (generation !== this.generation) {\n      this.generation = generation;\n      return true;\n    }\n    return texture.isVideoTexture;\n  }\n  update() {\n    const {\n      texture,\n      version\n    } = this;\n    if (version !== texture.version) {\n      this.version = texture.version;\n      return true;\n    }\n    return false;\n  }\n}\nclass NodeSampledTexture extends SampledTexture {\n  constructor(name, textureNode, groupNode, access = null) {\n    super(name, textureNode ? textureNode.value : null);\n    this.textureNode = textureNode;\n    this.groupNode = groupNode;\n    this.access = access;\n  }\n  needsBindingsUpdate(generation) {\n    return this.textureNode.value !== this.texture || super.needsBindingsUpdate(generation);\n  }\n  update() {\n    const {\n      textureNode\n    } = this;\n    if (this.texture !== textureNode.value) {\n      this.texture = textureNode.value;\n      return true;\n    }\n    return super.update();\n  }\n}\nclass NodeSampledCubeTexture extends NodeSampledTexture {\n  constructor(name, textureNode, groupNode, access) {\n    super(name, textureNode, groupNode, access);\n    this.isSampledCubeTexture = true;\n  }\n}\nclass NodeSampledTexture3D extends NodeSampledTexture {\n  constructor(name, textureNode, groupNode, access) {\n    super(name, textureNode, groupNode, access);\n    this.isSampledTexture3D = true;\n  }\n}\nconst glslMethods = {\n  atan2: 'atan',\n  textureDimensions: 'textureSize',\n  equals: 'equal'\n};\nconst precisionLib = {\n  low: 'lowp',\n  medium: 'mediump',\n  high: 'highp'\n};\nconst supports$1 = {\n  swizzleAssign: true,\n  storageBuffer: false\n};\nconst defaultPrecisions = `\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler3D;\nprecision highp samplerCube;\nprecision highp sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp usampler3D;\nprecision highp usamplerCube;\nprecision highp usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp isampler3D;\nprecision highp isamplerCube;\nprecision highp isampler2DArray;\n\nprecision lowp sampler2DShadow;\n`;\nclass GLSLNodeBuilder extends NodeBuilder {\n  constructor(object, renderer) {\n    super(object, renderer, new GLSLNodeParser());\n    this.uniformGroups = {};\n    this.transforms = [];\n    this.extensions = {};\n    this.builtins = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.useComparisonMethod = true;\n  }\n  needsToWorkingColorSpace(texture) {\n    return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n  }\n  getMethod(method) {\n    return glslMethods[method] || method;\n  }\n  getOutputStructName() {\n    return '';\n  }\n  buildFunctionCode(shaderNode) {\n    const layout = shaderNode.layout;\n    const flowData = this.flowShaderNode(shaderNode);\n    const parameters = [];\n    for (const input of layout.inputs) {\n      parameters.push(this.getType(input.type) + ' ' + input.name);\n    }\n\n    //\n\n    const code = `${this.getType(layout.type)} ${layout.name}( ${parameters.join(', ')} ) {\n\n\t${flowData.vars}\n\n${flowData.code}\n\treturn ${flowData.result};\n\n}`;\n\n    //\n\n    return code;\n  }\n  setupPBO(storageBufferNode) {\n    const attribute = storageBufferNode.value;\n    if (attribute.pbo === undefined) {\n      const originalArray = attribute.array;\n      const numElements = attribute.count * attribute.itemSize;\n      const {\n        itemSize\n      } = attribute;\n      const isInteger = attribute.array.constructor.name.toLowerCase().includes('int');\n      let format = isInteger ? RedIntegerFormat : RedFormat;\n      if (itemSize === 2) {\n        format = isInteger ? RGIntegerFormat : RGFormat;\n      } else if (itemSize === 3) {\n        format = isInteger ? RGBIntegerFormat : RGBFormat;\n      } else if (itemSize === 4) {\n        format = isInteger ? RGBAIntegerFormat : RGBAFormat;\n      }\n      const typeMap = {\n        Float32Array: FloatType,\n        Uint8Array: UnsignedByteType,\n        Uint16Array: UnsignedShortType,\n        Uint32Array: UnsignedIntType,\n        Int8Array: ByteType,\n        Int16Array: ShortType,\n        Int32Array: IntType,\n        Uint8ClampedArray: UnsignedByteType\n      };\n      const width = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(numElements / itemSize))));\n      let height = Math.ceil(numElements / itemSize / width);\n      if (width * height * itemSize < numElements) height++; // Ensure enough space\n\n      const newSize = width * height * itemSize;\n      const newArray = new originalArray.constructor(newSize);\n      newArray.set(originalArray, 0);\n      attribute.array = newArray;\n      const pboTexture = new DataTexture(attribute.array, width, height, format, typeMap[attribute.array.constructor.name] || FloatType);\n      pboTexture.needsUpdate = true;\n      pboTexture.isPBOTexture = true;\n      const pbo = new TextureNode(pboTexture, null, null);\n      pbo.setPrecision('high');\n      attribute.pboNode = pbo;\n      attribute.pbo = pbo.value;\n      this.getUniformFromNode(attribute.pboNode, 'texture', this.shaderStage, this.context.label);\n    }\n  }\n  getPropertyName(node, shaderStage = this.shaderStage) {\n    if (node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true) {\n      return shaderStage.charAt(0) + '_' + node.name;\n    }\n    return super.getPropertyName(node, shaderStage);\n  }\n  generatePBO(storageArrayElementNode) {\n    const {\n      node,\n      indexNode\n    } = storageArrayElementNode;\n    const attribute = node.value;\n    if (this.renderer.backend.has(attribute)) {\n      const attributeData = this.renderer.backend.get(attribute);\n      attributeData.pbo = attribute.pbo;\n    }\n    const nodeUniform = this.getUniformFromNode(attribute.pboNode, 'texture', this.shaderStage, this.context.label);\n    const textureName = this.getPropertyName(nodeUniform);\n    this.increaseUsage(indexNode); // force cache generate to be used as index in x,y\n    const indexSnippet = indexNode.build(this, 'uint');\n    const elementNodeData = this.getDataFromNode(storageArrayElementNode);\n    let propertyName = elementNodeData.propertyName;\n    if (propertyName === undefined) {\n      // property element\n\n      const nodeVar = this.getVarFromNode(storageArrayElementNode);\n      propertyName = this.getPropertyName(nodeVar);\n\n      // property size\n\n      const bufferNodeData = this.getDataFromNode(node);\n      let propertySizeName = bufferNodeData.propertySizeName;\n      if (propertySizeName === undefined) {\n        propertySizeName = propertyName + 'Size';\n        this.getVarFromNode(node, propertySizeName, 'uint');\n        this.addLineFlowCode(`${propertySizeName} = uint( textureSize( ${textureName}, 0 ).x )`, storageArrayElementNode);\n        bufferNodeData.propertySizeName = propertySizeName;\n      }\n\n      //\n\n      const {\n        itemSize\n      } = attribute;\n      const channel = '.' + vectorComponents.join('').slice(0, itemSize);\n      const uvSnippet = `ivec2(${indexSnippet} % ${propertySizeName}, ${indexSnippet} / ${propertySizeName})`;\n      const snippet = this.generateTextureLoad(null, textureName, uvSnippet, null, '0');\n\n      //\n\n      let prefix = 'vec4';\n      if (attribute.pbo.type === UnsignedIntType) {\n        prefix = 'uvec4';\n      } else if (attribute.pbo.type === IntType) {\n        prefix = 'ivec4';\n      }\n      this.addLineFlowCode(`${propertyName} = ${prefix}(${snippet})${channel}`, storageArrayElementNode);\n      elementNodeData.propertyName = propertyName;\n    }\n    return propertyName;\n  }\n  generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0') {\n    if (depthSnippet) {\n      return `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`;\n    } else {\n      return `texelFetch( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;\n    }\n  }\n  generateTexture(texture, textureProperty, uvSnippet, depthSnippet) {\n    if (texture.isDepthTexture) {\n      return `texture( ${textureProperty}, ${uvSnippet} ).x`;\n    } else {\n      if (depthSnippet) uvSnippet = `vec3( ${uvSnippet}, ${depthSnippet} )`;\n      return `texture( ${textureProperty}, ${uvSnippet} )`;\n    }\n  }\n  generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet) {\n    return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;\n  }\n  generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet) {\n    return `texture( ${textureProperty}, ${uvSnippet}, ${biasSnippet} )`;\n  }\n  generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet) {\n    return `textureGrad( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]} )`;\n  }\n  generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      return `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);\n    }\n  }\n  getVars(shaderStage) {\n    const snippets = [];\n    const vars = this.vars[shaderStage];\n    if (vars !== undefined) {\n      for (const variable of vars) {\n        snippets.push(`${this.getVar(variable.type, variable.name)};`);\n      }\n    }\n    return snippets.join('\\n\\t');\n  }\n  getUniforms(shaderStage) {\n    const uniforms = this.uniforms[shaderStage];\n    const bindingSnippets = [];\n    const uniformGroups = {};\n    for (const uniform of uniforms) {\n      let snippet = null;\n      let group = false;\n      if (uniform.type === 'texture') {\n        const texture = uniform.node.value;\n        let typePrefix = '';\n        if (texture.isDataTexture === true) {\n          if (texture.type === UnsignedIntType) {\n            typePrefix = 'u';\n          } else if (texture.type === IntType) {\n            typePrefix = 'i';\n          }\n        }\n        if (texture.compareFunction) {\n          snippet = `sampler2DShadow ${uniform.name};`;\n        } else if (texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true) {\n          snippet = `${typePrefix}sampler2DArray ${uniform.name};`;\n        } else {\n          snippet = `${typePrefix}sampler2D ${uniform.name};`;\n        }\n      } else if (uniform.type === 'cubeTexture') {\n        snippet = `samplerCube ${uniform.name};`;\n      } else if (uniform.type === 'texture3D') {\n        snippet = `sampler3D ${uniform.name};`;\n      } else if (uniform.type === 'buffer') {\n        const bufferNode = uniform.node;\n        const bufferType = this.getType(bufferNode.bufferType);\n        const bufferCount = bufferNode.bufferCount;\n        const bufferCountSnippet = bufferCount > 0 ? bufferCount : '';\n        snippet = `${bufferNode.name} {\\n\\t${bufferType} ${uniform.name}[${bufferCountSnippet}];\\n};\\n`;\n      } else {\n        const vectorType = this.getVectorType(uniform.type);\n        snippet = `${vectorType} ${this.getPropertyName(uniform, shaderStage)};`;\n        group = true;\n      }\n      const precision = uniform.node.precision;\n      if (precision !== null) {\n        snippet = precisionLib[precision] + ' ' + snippet;\n      }\n      if (group) {\n        snippet = '\\t' + snippet;\n        const groupName = uniform.groupNode.name;\n        const groupSnippets = uniformGroups[groupName] || (uniformGroups[groupName] = []);\n        groupSnippets.push(snippet);\n      } else {\n        snippet = 'uniform ' + snippet;\n        bindingSnippets.push(snippet);\n      }\n    }\n    let output = '';\n    for (const name in uniformGroups) {\n      const groupSnippets = uniformGroups[name];\n      output += this._getGLSLUniformStruct(shaderStage + '_' + name, groupSnippets.join('\\n')) + '\\n';\n    }\n    output += bindingSnippets.join('\\n');\n    return output;\n  }\n  getTypeFromAttribute(attribute) {\n    let nodeType = super.getTypeFromAttribute(attribute);\n    if (/^[iu]/.test(nodeType) && attribute.gpuType !== IntType) {\n      let dataAttribute = attribute;\n      if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;\n      const array = dataAttribute.array;\n      if ((array instanceof Uint32Array || array instanceof Int32Array) === false) {\n        nodeType = nodeType.slice(1);\n      }\n    }\n    return nodeType;\n  }\n  getAttributes(shaderStage) {\n    let snippet = '';\n    if (shaderStage === 'vertex' || shaderStage === 'compute') {\n      const attributes = this.getAttributesArray();\n      let location = 0;\n      for (const attribute of attributes) {\n        snippet += `layout( location = ${location++} ) in ${attribute.type} ${attribute.name};\\n`;\n      }\n    }\n    return snippet;\n  }\n  getStructMembers(struct) {\n    const snippets = [];\n    const members = struct.getMemberTypes();\n    for (let i = 0; i < members.length; i++) {\n      const member = members[i];\n      snippets.push(`layout( location = ${i} ) out ${member} m${i};`);\n    }\n    return snippets.join('\\n');\n  }\n  getStructs(shaderStage) {\n    const snippets = [];\n    const structs = this.structs[shaderStage];\n    if (structs.length === 0) {\n      return 'layout( location = 0 ) out vec4 fragColor;\\n';\n    }\n    for (let index = 0, length = structs.length; index < length; index++) {\n      const struct = structs[index];\n      let snippet = '\\n';\n      snippet += this.getStructMembers(struct);\n      snippet += '\\n';\n      snippets.push(snippet);\n    }\n    return snippets.join('\\n\\n');\n  }\n  getVaryings(shaderStage) {\n    let snippet = '';\n    const varyings = this.varyings;\n    if (shaderStage === 'vertex' || shaderStage === 'compute') {\n      for (const varying of varyings) {\n        if (shaderStage === 'compute') varying.needsInterpolation = true;\n        const type = this.getType(varying.type);\n        const flat = type.includes('int') || type.includes('uv') || type.includes('iv') ? 'flat ' : '';\n        snippet += `${flat}${varying.needsInterpolation ? 'out' : '/*out*/'} ${type} ${varying.name};\\n`;\n      }\n    } else if (shaderStage === 'fragment') {\n      for (const varying of varyings) {\n        if (varying.needsInterpolation) {\n          const type = this.getType(varying.type);\n          const flat = type.includes('int') || type.includes('uv') || type.includes('iv') ? 'flat ' : '';\n          snippet += `${flat}in ${type} ${varying.name};\\n`;\n        }\n      }\n    }\n    for (const builtin of this.builtins[shaderStage]) {\n      snippet += `${builtin};\\n`;\n    }\n    return snippet;\n  }\n  getVertexIndex() {\n    return 'uint( gl_VertexID )';\n  }\n  getInstanceIndex() {\n    return 'uint( gl_InstanceID )';\n  }\n  getInvocationLocalIndex() {\n    const workgroupSize = this.object.workgroupSize;\n    const size = workgroupSize.reduce((acc, curr) => acc * curr, 1);\n    return `uint( gl_InstanceID ) % ${size}u`;\n  }\n  getDrawIndex() {\n    const extensions = this.renderer.backend.extensions;\n    if (extensions.has('WEBGL_multi_draw')) {\n      return 'uint( gl_DrawID )';\n    }\n    return null;\n  }\n  getFrontFacing() {\n    return 'gl_FrontFacing';\n  }\n  getFragCoord() {\n    return 'gl_FragCoord.xy';\n  }\n  getFragDepth() {\n    return 'gl_FragDepth';\n  }\n  enableExtension(name, behavior, shaderStage = this.shaderStage) {\n    const map = this.extensions[shaderStage] || (this.extensions[shaderStage] = new Map());\n    if (map.has(name) === false) {\n      map.set(name, {\n        name,\n        behavior\n      });\n    }\n  }\n  getExtensions(shaderStage) {\n    const snippets = [];\n    if (shaderStage === 'vertex') {\n      const ext = this.renderer.backend.extensions;\n      const isBatchedMesh = this.object.isBatchedMesh;\n      if (isBatchedMesh && ext.has('WEBGL_multi_draw')) {\n        this.enableExtension('GL_ANGLE_multi_draw', 'require', shaderStage);\n      }\n    }\n    const extensions = this.extensions[shaderStage];\n    if (extensions !== undefined) {\n      for (const {\n        name,\n        behavior\n      } of extensions.values()) {\n        snippets.push(`#extension ${name} : ${behavior}`);\n      }\n    }\n    return snippets.join('\\n');\n  }\n  getClipDistance() {\n    return 'gl_ClipDistance';\n  }\n  isAvailable(name) {\n    let result = supports$1[name];\n    if (result === undefined) {\n      let extensionName;\n      result = false;\n      switch (name) {\n        case 'float32Filterable':\n          extensionName = 'OES_texture_float_linear';\n          break;\n        case 'clipDistance':\n          extensionName = 'WEBGL_clip_cull_distance';\n          break;\n      }\n      if (extensionName !== undefined) {\n        const extensions = this.renderer.backend.extensions;\n        if (extensions.has(extensionName)) {\n          extensions.get(extensionName);\n          result = true;\n        }\n      }\n      supports$1[name] = result;\n    }\n    return result;\n  }\n  isFlipY() {\n    return true;\n  }\n  enableHardwareClipping(planeCount) {\n    this.enableExtension('GL_ANGLE_clip_cull_distance', 'require');\n    this.builtins['vertex'].push(`out float gl_ClipDistance[ ${planeCount} ]`);\n  }\n  registerTransform(varyingName, attributeNode) {\n    this.transforms.push({\n      varyingName,\n      attributeNode\n    });\n  }\n  getTransforms(/* shaderStage  */\n  ) {\n    const transforms = this.transforms;\n    let snippet = '';\n    for (let i = 0; i < transforms.length; i++) {\n      const transform = transforms[i];\n      const attributeName = this.getPropertyName(transform.attributeNode);\n      snippet += `${transform.varyingName} = ${attributeName};\\n\\t`;\n    }\n    return snippet;\n  }\n  _getGLSLUniformStruct(name, vars) {\n    return `\nlayout( std140 ) uniform ${name} {\n${vars}\n};`;\n  }\n  _getGLSLVertexCode(shaderData) {\n    return `#version 300 es\n\n${this.getSignature()}\n\n// extensions \n${shaderData.extensions}\n\n// precision\n${defaultPrecisions}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// attributes\n${shaderData.attributes}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// transforms\n\t${shaderData.transforms}\n\n\t// flow\n\t${shaderData.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`;\n  }\n  _getGLSLFragmentCode(shaderData) {\n    return `#version 300 es\n\n${this.getSignature()}\n\n// precision\n${defaultPrecisions}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\n${shaderData.structs}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  buildCode() {\n    const shadersData = this.material !== null ? {\n      fragment: {},\n      vertex: {}\n    } : {\n      compute: {}\n    };\n    this.sortBindingGroups();\n    for (const shaderStage in shadersData) {\n      let flow = '// code\\n\\n';\n      flow += this.flowCode[shaderStage];\n      const flowNodes = this.flowNodes[shaderStage];\n      const mainNode = flowNodes[flowNodes.length - 1];\n      for (const node of flowNodes) {\n        const flowSlotData = this.getFlowData(node /*, shaderStage*/);\n        const slotName = node.name;\n        if (slotName) {\n          if (flow.length > 0) flow += '\\n';\n          flow += `\\t// flow -> ${slotName}\\n\\t`;\n        }\n        flow += `${flowSlotData.code}\\n\\t`;\n        if (node === mainNode && shaderStage !== 'compute') {\n          flow += '// result\\n\\t';\n          if (shaderStage === 'vertex') {\n            flow += 'gl_Position = ';\n            flow += `${flowSlotData.result};`;\n          } else if (shaderStage === 'fragment') {\n            if (!node.outputNode.isOutputStructNode) {\n              flow += 'fragColor = ';\n              flow += `${flowSlotData.result};`;\n            }\n          }\n        }\n      }\n      const stageData = shadersData[shaderStage];\n      stageData.extensions = this.getExtensions(shaderStage);\n      stageData.uniforms = this.getUniforms(shaderStage);\n      stageData.attributes = this.getAttributes(shaderStage);\n      stageData.varyings = this.getVaryings(shaderStage);\n      stageData.vars = this.getVars(shaderStage);\n      stageData.structs = this.getStructs(shaderStage);\n      stageData.codes = this.getCodes(shaderStage);\n      stageData.transforms = this.getTransforms(shaderStage);\n      stageData.flow = flow;\n    }\n    if (this.material !== null) {\n      this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);\n      this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);\n    } else {\n      this.computeShader = this._getGLSLVertexCode(shadersData.compute);\n    }\n  }\n  getUniformFromNode(node, type, shaderStage, name = null) {\n    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);\n    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);\n    let uniformGPU = nodeData.uniformGPU;\n    if (uniformGPU === undefined) {\n      const group = node.groupNode;\n      const groupName = group.name;\n      const bindings = this.getBindGroupArray(groupName, shaderStage);\n      if (type === 'texture') {\n        uniformGPU = new NodeSampledTexture(uniformNode.name, uniformNode.node, group);\n        bindings.push(uniformGPU);\n      } else if (type === 'cubeTexture') {\n        uniformGPU = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group);\n        bindings.push(uniformGPU);\n      } else if (type === 'texture3D') {\n        uniformGPU = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group);\n        bindings.push(uniformGPU);\n      } else if (type === 'buffer') {\n        node.name = `NodeBuffer_${node.id}`;\n        uniformNode.name = `buffer${node.id}`;\n        const buffer = new NodeUniformBuffer(node, group);\n        buffer.name = node.name;\n        bindings.push(buffer);\n        uniformGPU = buffer;\n      } else {\n        const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});\n        let uniformsGroup = uniformsStage[groupName];\n        if (uniformsGroup === undefined) {\n          uniformsGroup = new NodeUniformsGroup(shaderStage + '_' + groupName, group);\n          //uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n          uniformsStage[groupName] = uniformsGroup;\n          bindings.push(uniformsGroup);\n        }\n        uniformGPU = this.getNodeUniform(uniformNode, type);\n        uniformsGroup.addUniform(uniformGPU);\n      }\n      nodeData.uniformGPU = uniformGPU;\n    }\n    return uniformNode;\n  }\n}\nlet vector2 = null;\nlet vector4 = null;\nlet color4 = null;\nclass Backend {\n  constructor(parameters = {}) {\n    this.parameters = Object.assign({}, parameters);\n    this.data = new WeakMap();\n    this.renderer = null;\n    this.domElement = null;\n  }\n  async init(renderer) {\n    this.renderer = renderer;\n  }\n\n  // render context\n\n  begin(/*renderContext*/) {}\n  finish(/*renderContext*/) {}\n\n  // render object\n\n  draw(/*renderObject, info*/) {}\n\n  // program\n\n  createProgram(/*program*/) {}\n  destroyProgram(/*program*/) {}\n\n  // bindings\n\n  createBindings(/*bingGroup, bindings*/) {}\n  updateBindings(/*bingGroup, bindings*/) {}\n\n  // pipeline\n\n  createRenderPipeline(/*renderObject*/) {}\n  createComputePipeline(/*computeNode, pipeline*/) {}\n  destroyPipeline(/*pipeline*/) {}\n\n  // cache key\n\n  needsRenderUpdate(/*renderObject*/) {} // return Boolean ( fast test )\n\n  getRenderCacheKey(/*renderObject*/) {} // return String\n\n  // node builder\n\n  createNodeBuilder(/*renderObject*/) {} // return NodeBuilder (ADD IT)\n\n  // textures\n\n  createSampler(/*texture*/) {}\n  createDefaultTexture(/*texture*/) {}\n  createTexture(/*texture*/) {}\n  copyTextureToBuffer(/*texture, x, y, width, height*/) {}\n\n  // attributes\n\n  createAttribute(/*attribute*/) {}\n  createIndexAttribute(/*attribute*/) {}\n  updateAttribute(/*attribute*/) {}\n  destroyAttribute(/*attribute*/) {}\n\n  // canvas\n\n  getContext() {}\n  updateSize() {}\n\n  // utils\n\n  resolveTimestampAsync(/*renderContext, type*/) {}\n  hasFeatureAsync(/*name*/) {} // return Boolean\n\n  hasFeature(/*name*/) {} // return Boolean\n\n  getInstanceCount(renderObject) {\n    const {\n      object,\n      geometry\n    } = renderObject;\n    return geometry.isInstancedBufferGeometry ? geometry.instanceCount : object.count > 1 ? object.count : 1;\n  }\n  getDrawingBufferSize() {\n    vector2 = vector2 || new Vector2();\n    return this.renderer.getDrawingBufferSize(vector2);\n  }\n  getScissor() {\n    vector4 = vector4 || new Vector4();\n    return this.renderer.getScissor(vector4);\n  }\n  setScissorTest(/*boolean*/) {}\n  getClearColor() {\n    const renderer = this.renderer;\n    color4 = color4 || new Color4();\n    renderer.getClearColor(color4);\n    color4.getRGB(color4, this.renderer.currentColorSpace);\n    return color4;\n  }\n  getDomElement() {\n    let domElement = this.domElement;\n    if (domElement === null) {\n      domElement = this.parameters.canvas !== undefined ? this.parameters.canvas : createCanvasElement();\n\n      // OffscreenCanvas does not have setAttribute, see #22811\n      if ('setAttribute' in domElement) domElement.setAttribute('data-engine', `three.js r${REVISION} webgpu`);\n      this.domElement = domElement;\n    }\n    return domElement;\n  }\n\n  // resource properties\n\n  set(object, value) {\n    this.data.set(object, value);\n  }\n  get(object) {\n    let map = this.data.get(object);\n    if (map === undefined) {\n      map = {};\n      this.data.set(object, map);\n    }\n    return map;\n  }\n  has(object) {\n    return this.data.has(object);\n  }\n  delete(object) {\n    this.data.delete(object);\n  }\n  dispose() {}\n}\nlet _id$1 = 0;\nclass DualAttributeData {\n  constructor(attributeData, dualBuffer) {\n    this.buffers = [attributeData.bufferGPU, dualBuffer];\n    this.type = attributeData.type;\n    this.bufferType = attributeData.bufferType;\n    this.pbo = attributeData.pbo;\n    this.byteLength = attributeData.byteLength;\n    this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;\n    this.version = attributeData.version;\n    this.isInteger = attributeData.isInteger;\n    this.activeBufferIndex = 0;\n    this.baseId = attributeData.id;\n  }\n  get id() {\n    return `${this.baseId}|${this.activeBufferIndex}`;\n  }\n  get bufferGPU() {\n    return this.buffers[this.activeBufferIndex];\n  }\n  get transformBuffer() {\n    return this.buffers[this.activeBufferIndex ^ 1];\n  }\n  switchBuffers() {\n    this.activeBufferIndex ^= 1;\n  }\n}\nclass WebGLAttributeUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  createAttribute(attribute, bufferType) {\n    const backend = this.backend;\n    const {\n      gl\n    } = backend;\n    const array = attribute.array;\n    const usage = attribute.usage || gl.STATIC_DRAW;\n    const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n    const bufferData = backend.get(bufferAttribute);\n    let bufferGPU = bufferData.bufferGPU;\n    if (bufferGPU === undefined) {\n      bufferGPU = this._createBuffer(gl, bufferType, array, usage);\n      bufferData.bufferGPU = bufferGPU;\n      bufferData.bufferType = bufferType;\n      bufferData.version = bufferAttribute.version;\n    }\n\n    //attribute.onUploadCallback();\n\n    let type;\n    if (array instanceof Float32Array) {\n      type = gl.FLOAT;\n    } else if (array instanceof Uint16Array) {\n      if (attribute.isFloat16BufferAttribute) {\n        type = gl.HALF_FLOAT;\n      } else {\n        type = gl.UNSIGNED_SHORT;\n      }\n    } else if (array instanceof Int16Array) {\n      type = gl.SHORT;\n    } else if (array instanceof Uint32Array) {\n      type = gl.UNSIGNED_INT;\n    } else if (array instanceof Int32Array) {\n      type = gl.INT;\n    } else if (array instanceof Int8Array) {\n      type = gl.BYTE;\n    } else if (array instanceof Uint8Array) {\n      type = gl.UNSIGNED_BYTE;\n    } else if (array instanceof Uint8ClampedArray) {\n      type = gl.UNSIGNED_BYTE;\n    } else {\n      throw new Error('THREE.WebGLBackend: Unsupported buffer data format: ' + array);\n    }\n    let attributeData = {\n      bufferGPU,\n      bufferType,\n      type,\n      byteLength: array.byteLength,\n      bytesPerElement: array.BYTES_PER_ELEMENT,\n      version: attribute.version,\n      pbo: attribute.pbo,\n      isInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,\n      id: _id$1++\n    };\n    if (attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute) {\n      // create buffer for tranform feedback use\n      const bufferGPUDual = this._createBuffer(gl, bufferType, array, usage);\n      attributeData = new DualAttributeData(attributeData, bufferGPUDual);\n    }\n    backend.set(attribute, attributeData);\n  }\n  updateAttribute(attribute) {\n    const backend = this.backend;\n    const {\n      gl\n    } = backend;\n    const array = attribute.array;\n    const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n    const bufferData = backend.get(bufferAttribute);\n    const bufferType = bufferData.bufferType;\n    const updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;\n    gl.bindBuffer(bufferType, bufferData.bufferGPU);\n    if (updateRanges.length === 0) {\n      // Not using update ranges\n\n      gl.bufferSubData(bufferType, 0, array);\n    } else {\n      for (let i = 0, l = updateRanges.length; i < l; i++) {\n        const range = updateRanges[i];\n        gl.bufferSubData(bufferType, range.start * array.BYTES_PER_ELEMENT, array, range.start, range.count);\n      }\n      bufferAttribute.clearUpdateRanges();\n    }\n    gl.bindBuffer(bufferType, null);\n    bufferData.version = bufferAttribute.version;\n  }\n  destroyAttribute(attribute) {\n    const backend = this.backend;\n    const {\n      gl\n    } = backend;\n    if (attribute.isInterleavedBufferAttribute) {\n      backend.delete(attribute.data);\n    }\n    const attributeData = backend.get(attribute);\n    gl.deleteBuffer(attributeData.bufferGPU);\n    backend.delete(attribute);\n  }\n  async getArrayBufferAsync(attribute) {\n    const backend = this.backend;\n    const {\n      gl\n    } = backend;\n    const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n    const {\n      bufferGPU\n    } = backend.get(bufferAttribute);\n    const array = attribute.array;\n    const byteLength = array.byteLength;\n    gl.bindBuffer(gl.COPY_READ_BUFFER, bufferGPU);\n    const writeBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);\n    gl.bufferData(gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ);\n    gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength);\n    await backend.utils._clientWaitAsync();\n    const dstBuffer = new attribute.array.constructor(array.length);\n\n    // Ensure the buffer is bound before reading\n    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);\n    gl.getBufferSubData(gl.COPY_WRITE_BUFFER, 0, dstBuffer);\n    gl.deleteBuffer(writeBuffer);\n    gl.bindBuffer(gl.COPY_READ_BUFFER, null);\n    gl.bindBuffer(gl.COPY_WRITE_BUFFER, null);\n    return dstBuffer.buffer;\n  }\n  _createBuffer(gl, bufferType, array, usage) {\n    const bufferGPU = gl.createBuffer();\n    gl.bindBuffer(bufferType, bufferGPU);\n    gl.bufferData(bufferType, array, usage);\n    gl.bindBuffer(bufferType, null);\n    return bufferGPU;\n  }\n}\nlet initialized$1 = false,\n  equationToGL,\n  factorToGL;\nclass WebGLState {\n  constructor(backend) {\n    this.backend = backend;\n    this.gl = this.backend.gl;\n    this.enabled = {};\n    this.currentFlipSided = null;\n    this.currentCullFace = null;\n    this.currentProgram = null;\n    this.currentBlendingEnabled = false;\n    this.currentBlending = null;\n    this.currentBlendSrc = null;\n    this.currentBlendDst = null;\n    this.currentBlendSrcAlpha = null;\n    this.currentBlendDstAlpha = null;\n    this.currentPremultipledAlpha = null;\n    this.currentPolygonOffsetFactor = null;\n    this.currentPolygonOffsetUnits = null;\n    this.currentColorMask = null;\n    this.currentDepthFunc = null;\n    this.currentDepthMask = null;\n    this.currentStencilFunc = null;\n    this.currentStencilRef = null;\n    this.currentStencilFuncMask = null;\n    this.currentStencilFail = null;\n    this.currentStencilZFail = null;\n    this.currentStencilZPass = null;\n    this.currentStencilMask = null;\n    this.currentLineWidth = null;\n    this.currentClippingPlanes = 0;\n    this.currentBoundFramebuffers = {};\n    this.currentDrawbuffers = new WeakMap();\n    this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.currentTextureSlot = null;\n    this.currentBoundTextures = {};\n    this.currentBoundBufferBases = {};\n    if (initialized$1 === false) {\n      this._init(this.gl);\n      initialized$1 = true;\n    }\n  }\n  _init(gl) {\n    // Store only WebGL constants here.\n\n    equationToGL = {\n      [AddEquation]: gl.FUNC_ADD,\n      [SubtractEquation]: gl.FUNC_SUBTRACT,\n      [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT\n    };\n    factorToGL = {\n      [ZeroFactor]: gl.ZERO,\n      [OneFactor]: gl.ONE,\n      [SrcColorFactor]: gl.SRC_COLOR,\n      [SrcAlphaFactor]: gl.SRC_ALPHA,\n      [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,\n      [DstColorFactor]: gl.DST_COLOR,\n      [DstAlphaFactor]: gl.DST_ALPHA,\n      [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,\n      [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,\n      [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,\n      [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA\n    };\n  }\n  enable(id) {\n    const {\n      enabled\n    } = this;\n    if (enabled[id] !== true) {\n      this.gl.enable(id);\n      enabled[id] = true;\n    }\n  }\n  disable(id) {\n    const {\n      enabled\n    } = this;\n    if (enabled[id] !== false) {\n      this.gl.disable(id);\n      enabled[id] = false;\n    }\n  }\n  setFlipSided(flipSided) {\n    if (this.currentFlipSided !== flipSided) {\n      const {\n        gl\n      } = this;\n      if (flipSided) {\n        gl.frontFace(gl.CW);\n      } else {\n        gl.frontFace(gl.CCW);\n      }\n      this.currentFlipSided = flipSided;\n    }\n  }\n  setCullFace(cullFace) {\n    const {\n      gl\n    } = this;\n    if (cullFace !== CullFaceNone) {\n      this.enable(gl.CULL_FACE);\n      if (cullFace !== this.currentCullFace) {\n        if (cullFace === CullFaceBack) {\n          gl.cullFace(gl.BACK);\n        } else if (cullFace === CullFaceFront) {\n          gl.cullFace(gl.FRONT);\n        } else {\n          gl.cullFace(gl.FRONT_AND_BACK);\n        }\n      }\n    } else {\n      this.disable(gl.CULL_FACE);\n    }\n    this.currentCullFace = cullFace;\n  }\n  setLineWidth(width) {\n    const {\n      currentLineWidth,\n      gl\n    } = this;\n    if (width !== currentLineWidth) {\n      gl.lineWidth(width);\n      this.currentLineWidth = width;\n    }\n  }\n  setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {\n    const {\n      gl\n    } = this;\n    if (blending === NoBlending) {\n      if (this.currentBlendingEnabled === true) {\n        this.disable(gl.BLEND);\n        this.currentBlendingEnabled = false;\n      }\n      return;\n    }\n    if (this.currentBlendingEnabled === false) {\n      this.enable(gl.BLEND);\n      this.currentBlendingEnabled = true;\n    }\n    if (blending !== CustomBlending) {\n      if (blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha) {\n        if (this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation) {\n          gl.blendEquation(gl.FUNC_ADD);\n          this.currentBlendEquation = AddEquation;\n          this.currentBlendEquationAlpha = AddEquation;\n        }\n        if (premultipliedAlpha) {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n              break;\n            case AdditiveBlending:\n              gl.blendFunc(gl.ONE, gl.ONE);\n              break;\n            case SubtractiveBlending:\n              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);\n              break;\n            case MultiplyBlending:\n              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);\n              break;\n            default:\n              console.error('THREE.WebGLState: Invalid blending: ', blending);\n              break;\n          }\n        } else {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n              break;\n            case AdditiveBlending:\n              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n              break;\n            case SubtractiveBlending:\n              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);\n              break;\n            case MultiplyBlending:\n              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);\n              break;\n            default:\n              console.error('THREE.WebGLState: Invalid blending: ', blending);\n              break;\n          }\n        }\n        this.currentBlendSrc = null;\n        this.currentBlendDst = null;\n        this.currentBlendSrcAlpha = null;\n        this.currentBlendDstAlpha = null;\n        this.currentBlending = blending;\n        this.currentPremultipledAlpha = premultipliedAlpha;\n      }\n      return;\n    }\n\n    // custom blending\n\n    blendEquationAlpha = blendEquationAlpha || blendEquation;\n    blendSrcAlpha = blendSrcAlpha || blendSrc;\n    blendDstAlpha = blendDstAlpha || blendDst;\n    if (blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha) {\n      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);\n      this.currentBlendEquation = blendEquation;\n      this.currentBlendEquationAlpha = blendEquationAlpha;\n    }\n    if (blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha) {\n      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);\n      this.currentBlendSrc = blendSrc;\n      this.currentBlendDst = blendDst;\n      this.currentBlendSrcAlpha = blendSrcAlpha;\n      this.currentBlendDstAlpha = blendDstAlpha;\n    }\n    this.currentBlending = blending;\n    this.currentPremultipledAlpha = false;\n  }\n  setColorMask(colorMask) {\n    if (this.currentColorMask !== colorMask) {\n      this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);\n      this.currentColorMask = colorMask;\n    }\n  }\n  setDepthTest(depthTest) {\n    const {\n      gl\n    } = this;\n    if (depthTest) {\n      this.enable(gl.DEPTH_TEST);\n    } else {\n      this.disable(gl.DEPTH_TEST);\n    }\n  }\n  setDepthMask(depthMask) {\n    if (this.currentDepthMask !== depthMask) {\n      this.gl.depthMask(depthMask);\n      this.currentDepthMask = depthMask;\n    }\n  }\n  setDepthFunc(depthFunc) {\n    if (this.currentDepthFunc !== depthFunc) {\n      const {\n        gl\n      } = this;\n      switch (depthFunc) {\n        case NeverDepth:\n          gl.depthFunc(gl.NEVER);\n          break;\n        case AlwaysDepth:\n          gl.depthFunc(gl.ALWAYS);\n          break;\n        case LessDepth:\n          gl.depthFunc(gl.LESS);\n          break;\n        case LessEqualDepth:\n          gl.depthFunc(gl.LEQUAL);\n          break;\n        case EqualDepth:\n          gl.depthFunc(gl.EQUAL);\n          break;\n        case GreaterEqualDepth:\n          gl.depthFunc(gl.GEQUAL);\n          break;\n        case GreaterDepth:\n          gl.depthFunc(gl.GREATER);\n          break;\n        case NotEqualDepth:\n          gl.depthFunc(gl.NOTEQUAL);\n          break;\n        default:\n          gl.depthFunc(gl.LEQUAL);\n      }\n      this.currentDepthFunc = depthFunc;\n    }\n  }\n  setStencilTest(stencilTest) {\n    const {\n      gl\n    } = this;\n    if (stencilTest) {\n      this.enable(gl.STENCIL_TEST);\n    } else {\n      this.disable(gl.STENCIL_TEST);\n    }\n  }\n  setStencilMask(stencilMask) {\n    if (this.currentStencilMask !== stencilMask) {\n      this.gl.stencilMask(stencilMask);\n      this.currentStencilMask = stencilMask;\n    }\n  }\n  setStencilFunc(stencilFunc, stencilRef, stencilMask) {\n    if (this.currentStencilFunc !== stencilFunc || this.currentStencilRef !== stencilRef || this.currentStencilFuncMask !== stencilMask) {\n      this.gl.stencilFunc(stencilFunc, stencilRef, stencilMask);\n      this.currentStencilFunc = stencilFunc;\n      this.currentStencilRef = stencilRef;\n      this.currentStencilFuncMask = stencilMask;\n    }\n  }\n  setStencilOp(stencilFail, stencilZFail, stencilZPass) {\n    if (this.currentStencilFail !== stencilFail || this.currentStencilZFail !== stencilZFail || this.currentStencilZPass !== stencilZPass) {\n      this.gl.stencilOp(stencilFail, stencilZFail, stencilZPass);\n      this.currentStencilFail = stencilFail;\n      this.currentStencilZFail = stencilZFail;\n      this.currentStencilZPass = stencilZPass;\n    }\n  }\n  setMaterial(material, frontFaceCW, hardwareClippingPlanes) {\n    const {\n      gl\n    } = this;\n    material.side === DoubleSide ? this.disable(gl.CULL_FACE) : this.enable(gl.CULL_FACE);\n    let flipSided = material.side === BackSide;\n    if (frontFaceCW) flipSided = !flipSided;\n    this.setFlipSided(flipSided);\n    material.blending === NormalBlending && material.transparent === false ? this.setBlending(NoBlending) : this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);\n    this.setDepthFunc(material.depthFunc);\n    this.setDepthTest(material.depthTest);\n    this.setDepthMask(material.depthWrite);\n    this.setColorMask(material.colorWrite);\n    const stencilWrite = material.stencilWrite;\n    this.setStencilTest(stencilWrite);\n    if (stencilWrite) {\n      this.setStencilMask(material.stencilWriteMask);\n      this.setStencilFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);\n      this.setStencilOp(material.stencilFail, material.stencilZFail, material.stencilZPass);\n    }\n    this.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n    material.alphaToCoverage === true && this.backend.renderer.samples > 1 ? this.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n    if (hardwareClippingPlanes > 0) {\n      if (this.currentClippingPlanes !== hardwareClippingPlanes) {\n        const CLIP_DISTANCE0_WEBGL = 0x3000;\n        for (let i = 0; i < 8; i++) {\n          if (i < hardwareClippingPlanes) {\n            this.enable(CLIP_DISTANCE0_WEBGL + i);\n          } else {\n            this.disable(CLIP_DISTANCE0_WEBGL + i);\n          }\n        }\n      }\n    }\n  }\n  setPolygonOffset(polygonOffset, factor, units) {\n    const {\n      gl\n    } = this;\n    if (polygonOffset) {\n      this.enable(gl.POLYGON_OFFSET_FILL);\n      if (this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units) {\n        gl.polygonOffset(factor, units);\n        this.currentPolygonOffsetFactor = factor;\n        this.currentPolygonOffsetUnits = units;\n      }\n    } else {\n      this.disable(gl.POLYGON_OFFSET_FILL);\n    }\n  }\n  useProgram(program) {\n    if (this.currentProgram !== program) {\n      this.gl.useProgram(program);\n      this.currentProgram = program;\n      return true;\n    }\n    return false;\n  }\n\n  // framebuffer\n\n  bindFramebuffer(target, framebuffer) {\n    const {\n      gl,\n      currentBoundFramebuffers\n    } = this;\n    if (currentBoundFramebuffers[target] !== framebuffer) {\n      gl.bindFramebuffer(target, framebuffer);\n      currentBoundFramebuffers[target] = framebuffer;\n\n      // gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\n      if (target === gl.DRAW_FRAMEBUFFER) {\n        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;\n      }\n      if (target === gl.FRAMEBUFFER) {\n        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;\n      }\n      return true;\n    }\n    return false;\n  }\n  drawBuffers(renderContext, framebuffer) {\n    const {\n      gl\n    } = this;\n    let drawBuffers = [];\n    let needsUpdate = false;\n    if (renderContext.textures !== null) {\n      drawBuffers = this.currentDrawbuffers.get(framebuffer);\n      if (drawBuffers === undefined) {\n        drawBuffers = [];\n        this.currentDrawbuffers.set(framebuffer, drawBuffers);\n      }\n      const textures = renderContext.textures;\n      if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {\n        for (let i = 0, il = textures.length; i < il; i++) {\n          drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;\n        }\n        drawBuffers.length = textures.length;\n        needsUpdate = true;\n      }\n    } else {\n      if (drawBuffers[0] !== gl.BACK) {\n        drawBuffers[0] = gl.BACK;\n        needsUpdate = true;\n      }\n    }\n    if (needsUpdate) {\n      gl.drawBuffers(drawBuffers);\n    }\n  }\n\n  // texture\n\n  activeTexture(webglSlot) {\n    const {\n      gl,\n      currentTextureSlot,\n      maxTextures\n    } = this;\n    if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n    if (currentTextureSlot !== webglSlot) {\n      gl.activeTexture(webglSlot);\n      this.currentTextureSlot = webglSlot;\n    }\n  }\n  bindTexture(webglType, webglTexture, webglSlot) {\n    const {\n      gl,\n      currentTextureSlot,\n      currentBoundTextures,\n      maxTextures\n    } = this;\n    if (webglSlot === undefined) {\n      if (currentTextureSlot === null) {\n        webglSlot = gl.TEXTURE0 + maxTextures - 1;\n      } else {\n        webglSlot = currentTextureSlot;\n      }\n    }\n    let boundTexture = currentBoundTextures[webglSlot];\n    if (boundTexture === undefined) {\n      boundTexture = {\n        type: undefined,\n        texture: undefined\n      };\n      currentBoundTextures[webglSlot] = boundTexture;\n    }\n    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {\n      if (currentTextureSlot !== webglSlot) {\n        gl.activeTexture(webglSlot);\n        this.currentTextureSlot = webglSlot;\n      }\n      gl.bindTexture(webglType, webglTexture);\n      boundTexture.type = webglType;\n      boundTexture.texture = webglTexture;\n    }\n  }\n  bindBufferBase(target, index, buffer) {\n    const {\n      gl\n    } = this;\n    const key = `${target}-${index}`;\n    if (this.currentBoundBufferBases[key] !== buffer) {\n      gl.bindBufferBase(target, index, buffer);\n      this.currentBoundBufferBases[key] = buffer;\n      return true;\n    }\n    return false;\n  }\n  unbindTexture() {\n    const {\n      gl,\n      currentTextureSlot,\n      currentBoundTextures\n    } = this;\n    const boundTexture = currentBoundTextures[currentTextureSlot];\n    if (boundTexture !== undefined && boundTexture.type !== undefined) {\n      gl.bindTexture(boundTexture.type, null);\n      boundTexture.type = undefined;\n      boundTexture.texture = undefined;\n    }\n  }\n}\nclass WebGLUtils {\n  constructor(backend) {\n    this.backend = backend;\n    this.gl = this.backend.gl;\n    this.extensions = backend.extensions;\n  }\n  convert(p, colorSpace = NoColorSpace) {\n    const {\n      gl,\n      extensions\n    } = this;\n    let extension;\n    if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;\n    if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;\n    if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;\n    if (p === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;\n    if (p === ByteType) return gl.BYTE;\n    if (p === ShortType) return gl.SHORT;\n    if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;\n    if (p === IntType) return gl.INT;\n    if (p === UnsignedIntType) return gl.UNSIGNED_INT;\n    if (p === FloatType) return gl.FLOAT;\n    if (p === HalfFloatType) {\n      return gl.HALF_FLOAT;\n    }\n    if (p === AlphaFormat) return gl.ALPHA;\n    if (p === RGBFormat) return gl.RGB;\n    if (p === RGBAFormat) return gl.RGBA;\n    if (p === LuminanceFormat) return gl.LUMINANCE;\n    if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;\n    if (p === DepthFormat) return gl.DEPTH_COMPONENT;\n    if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;\n\n    // WebGL2 formats.\n\n    if (p === RedFormat) return gl.RED;\n    if (p === RedIntegerFormat) return gl.RED_INTEGER;\n    if (p === RGFormat) return gl.RG;\n    if (p === RGIntegerFormat) return gl.RG_INTEGER;\n    if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;\n\n    // S3TC\n\n    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {\n      if (colorSpace === SRGBColorSpace) {\n        extension = extensions.get('WEBGL_compressed_texture_s3tc_srgb');\n        if (extension !== null) {\n          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n        } else {\n          return null;\n        }\n      } else {\n        extension = extensions.get('WEBGL_compressed_texture_s3tc');\n        if (extension !== null) {\n          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n        } else {\n          return null;\n        }\n      }\n    }\n\n    // PVRTC\n\n    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_pvrtc');\n      if (extension !== null) {\n        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n      } else {\n        return null;\n      }\n    }\n\n    // ETC\n\n    if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_etc');\n      if (extension !== null) {\n        if (p === RGB_ETC1_Format || p === RGB_ETC2_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;\n        if (p === RGBA_ETC2_EAC_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;\n      } else {\n        return null;\n      }\n    }\n\n    // ASTC\n\n    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_astc');\n      if (extension !== null) {\n        if (p === RGBA_ASTC_4x4_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n        if (p === RGBA_ASTC_5x4_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n        if (p === RGBA_ASTC_5x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n        if (p === RGBA_ASTC_6x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n        if (p === RGBA_ASTC_6x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n        if (p === RGBA_ASTC_8x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n        if (p === RGBA_ASTC_8x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n        if (p === RGBA_ASTC_8x8_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n        if (p === RGBA_ASTC_10x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n        if (p === RGBA_ASTC_10x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n        if (p === RGBA_ASTC_10x8_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n        if (p === RGBA_ASTC_10x10_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n        if (p === RGBA_ASTC_12x10_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n        if (p === RGBA_ASTC_12x12_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n      } else {\n        return null;\n      }\n    }\n\n    // BPTC\n\n    if (p === RGBA_BPTC_Format) {\n      extension = extensions.get('EXT_texture_compression_bptc');\n      if (extension !== null) {\n        if (p === RGBA_BPTC_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n      } else {\n        return null;\n      }\n    }\n\n    // RGTC\n\n    if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {\n      extension = extensions.get('EXT_texture_compression_rgtc');\n      if (extension !== null) {\n        if (p === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;\n        if (p === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n        if (p === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n        if (p === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n      } else {\n        return null;\n      }\n    }\n\n    //\n\n    if (p === UnsignedInt248Type) {\n      return gl.UNSIGNED_INT_24_8;\n    }\n\n    // if \"p\" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)\n\n    return gl[p] !== undefined ? gl[p] : null;\n  }\n  _clientWaitAsync() {\n    const {\n      gl\n    } = this;\n    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n    gl.flush();\n    return new Promise((resolve, reject) => {\n      function test() {\n        const res = gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0);\n        if (res === gl.WAIT_FAILED) {\n          gl.deleteSync(sync);\n          reject();\n          return;\n        }\n        if (res === gl.TIMEOUT_EXPIRED) {\n          requestAnimationFrame(test);\n          return;\n        }\n        gl.deleteSync(sync);\n        resolve();\n      }\n      test();\n    });\n  }\n}\nlet initialized = false,\n  wrappingToGL,\n  filterToGL,\n  compareToGL;\nclass WebGLTextureUtils {\n  constructor(backend) {\n    this.backend = backend;\n    this.gl = backend.gl;\n    this.extensions = backend.extensions;\n    this.defaultTextures = {};\n    if (initialized === false) {\n      this._init(this.gl);\n      initialized = true;\n    }\n  }\n  _init(gl) {\n    // Store only WebGL constants here.\n\n    wrappingToGL = {\n      [RepeatWrapping]: gl.REPEAT,\n      [ClampToEdgeWrapping]: gl.CLAMP_TO_EDGE,\n      [MirroredRepeatWrapping]: gl.MIRRORED_REPEAT\n    };\n    filterToGL = {\n      [NearestFilter]: gl.NEAREST,\n      [NearestMipmapNearestFilter]: gl.NEAREST_MIPMAP_NEAREST,\n      [NearestMipmapLinearFilter]: gl.NEAREST_MIPMAP_LINEAR,\n      [LinearFilter]: gl.LINEAR,\n      [LinearMipmapNearestFilter]: gl.LINEAR_MIPMAP_NEAREST,\n      [LinearMipmapLinearFilter]: gl.LINEAR_MIPMAP_LINEAR\n    };\n    compareToGL = {\n      [NeverCompare]: gl.NEVER,\n      [AlwaysCompare]: gl.ALWAYS,\n      [LessCompare]: gl.LESS,\n      [LessEqualCompare]: gl.LEQUAL,\n      [EqualCompare]: gl.EQUAL,\n      [GreaterEqualCompare]: gl.GEQUAL,\n      [GreaterCompare]: gl.GREATER,\n      [NotEqualCompare]: gl.NOTEQUAL\n    };\n  }\n  filterFallback(f) {\n    const {\n      gl\n    } = this;\n    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {\n      return gl.NEAREST;\n    }\n    return gl.LINEAR;\n  }\n  getGLTextureType(texture) {\n    const {\n      gl\n    } = this;\n    let glTextureType;\n    if (texture.isCubeTexture === true) {\n      glTextureType = gl.TEXTURE_CUBE_MAP;\n    } else if (texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true) {\n      glTextureType = gl.TEXTURE_2D_ARRAY;\n    } else if (texture.isData3DTexture === true) {\n      // TODO: isCompressed3DTexture, wait for #26642\n\n      glTextureType = gl.TEXTURE_3D;\n    } else {\n      glTextureType = gl.TEXTURE_2D;\n    }\n    return glTextureType;\n  }\n  getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {\n    const {\n      gl,\n      extensions\n    } = this;\n    if (internalFormatName !== null) {\n      if (gl[internalFormatName] !== undefined) return gl[internalFormatName];\n      console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'');\n    }\n    let internalFormat = glFormat;\n    if (glFormat === gl.RED) {\n      if (glType === gl.FLOAT) internalFormat = gl.R32F;\n      if (glType === gl.HALF_FLOAT) internalFormat = gl.R16F;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;\n      if (glType === gl.BYTE) internalFormat = gl.R8I;\n      if (glType === gl.SHORT) internalFormat = gl.R16I;\n      if (glType === gl.INT) internalFormat = gl.R32I;\n    }\n    if (glFormat === gl.RED_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8UI;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16UI;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;\n      if (glType === gl.BYTE) internalFormat = gl.R8I;\n      if (glType === gl.SHORT) internalFormat = gl.R16I;\n      if (glType === gl.INT) internalFormat = gl.R32I;\n    }\n    if (glFormat === gl.RG) {\n      if (glType === gl.FLOAT) internalFormat = gl.RG32F;\n      if (glType === gl.HALF_FLOAT) internalFormat = gl.RG16F;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RG8I;\n      if (glType === gl.SHORT) internalFormat = gl.RG16I;\n      if (glType === gl.INT) internalFormat = gl.RG32I;\n    }\n    if (glFormat === gl.RG_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8UI;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16UI;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RG8I;\n      if (glType === gl.SHORT) internalFormat = gl.RG16I;\n      if (glType === gl.INT) internalFormat = gl.RG32I;\n    }\n    if (glFormat === gl.RGB) {\n      if (glType === gl.FLOAT) internalFormat = gl.RGB32F;\n      if (glType === gl.HALF_FLOAT) internalFormat = gl.RGB16F;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RGB8I;\n      if (glType === gl.SHORT) internalFormat = gl.RGB16I;\n      if (glType === gl.INT) internalFormat = gl.RGB32I;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = colorSpace === SRGBColorSpace && forceLinearTransfer === false ? gl.SRGB8 : gl.RGB8;\n      if (glType === gl.UNSIGNED_SHORT_5_6_5) internalFormat = gl.RGB565;\n      if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;\n      if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGB4;\n      if (glType === gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = gl.RGB9_E5;\n    }\n    if (glFormat === gl.RGB_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8UI;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16UI;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RGB8I;\n      if (glType === gl.SHORT) internalFormat = gl.RGB16I;\n      if (glType === gl.INT) internalFormat = gl.RGB32I;\n    }\n    if (glFormat === gl.RGBA) {\n      if (glType === gl.FLOAT) internalFormat = gl.RGBA32F;\n      if (glType === gl.HALF_FLOAT) internalFormat = gl.RGBA16F;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RGBA8I;\n      if (glType === gl.SHORT) internalFormat = gl.RGBA16I;\n      if (glType === gl.INT) internalFormat = gl.RGBA32I;\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = colorSpace === SRGBColorSpace && forceLinearTransfer === false ? gl.SRGB8_ALPHA8 : gl.RGBA8;\n      if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGBA4;\n      if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;\n    }\n    if (glFormat === gl.RGBA_INTEGER) {\n      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8UI;\n      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16UI;\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;\n      if (glType === gl.BYTE) internalFormat = gl.RGBA8I;\n      if (glType === gl.SHORT) internalFormat = gl.RGBA16I;\n      if (glType === gl.INT) internalFormat = gl.RGBA32I;\n    }\n    if (glFormat === gl.DEPTH_COMPONENT) {\n      if (glType === gl.UNSIGNED_INT) internalFormat = gl.DEPTH24_STENCIL8;\n      if (glType === gl.FLOAT) internalFormat = gl.DEPTH_COMPONENT32F;\n    }\n    if (glFormat === gl.DEPTH_STENCIL) {\n      if (glType === gl.UNSIGNED_INT_24_8) internalFormat = gl.DEPTH24_STENCIL8;\n    }\n    if (internalFormat === gl.R16F || internalFormat === gl.R32F || internalFormat === gl.RG16F || internalFormat === gl.RG32F || internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F) {\n      extensions.get('EXT_color_buffer_float');\n    }\n    return internalFormat;\n  }\n  setTextureParameters(textureType, texture) {\n    const {\n      gl,\n      extensions,\n      backend\n    } = this;\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);\n    gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);\n    if (textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY) {\n      gl.texParameteri(textureType, gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);\n    }\n    gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);\n    const hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;\n\n    // follow WebGPU backend mapping for texture filtering\n    const minFilter = texture.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture.minFilter;\n    gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, filterToGL[minFilter]);\n    if (texture.compareFunction) {\n      gl.texParameteri(textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);\n      gl.texParameteri(textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);\n    }\n    if (extensions.has('EXT_texture_filter_anisotropic') === true) {\n      if (texture.magFilter === NearestFilter) return;\n      if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;\n      if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2\n\n      if (texture.anisotropy > 1) {\n        const extension = extensions.get('EXT_texture_filter_anisotropic');\n        gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, backend.getMaxAnisotropy()));\n      }\n    }\n  }\n  createDefaultTexture(texture) {\n    const {\n      gl,\n      backend,\n      defaultTextures\n    } = this;\n    const glTextureType = this.getGLTextureType(texture);\n    let textureGPU = defaultTextures[glTextureType];\n    if (textureGPU === undefined) {\n      textureGPU = gl.createTexture();\n      backend.state.bindTexture(glTextureType, textureGPU);\n      gl.texParameteri(glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n      // gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n      defaultTextures[glTextureType] = textureGPU;\n    }\n    backend.set(texture, {\n      textureGPU,\n      glTextureType,\n      isDefault: true\n    });\n  }\n  createTexture(texture, options) {\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      levels,\n      width,\n      height,\n      depth\n    } = options;\n    const glFormat = backend.utils.convert(texture.format, texture.colorSpace);\n    const glType = backend.utils.convert(texture.type);\n    const glInternalFormat = this.getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);\n    const textureGPU = gl.createTexture();\n    const glTextureType = this.getGLTextureType(texture);\n    backend.state.bindTexture(glTextureType, textureGPU);\n    this.setTextureParameters(glTextureType, texture);\n    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {\n      gl.texStorage3D(gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth);\n    } else if (texture.isData3DTexture) {\n      gl.texStorage3D(gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth);\n    } else if (!texture.isVideoTexture) {\n      gl.texStorage2D(glTextureType, levels, glInternalFormat, width, height);\n    }\n    backend.set(texture, {\n      textureGPU,\n      glTextureType,\n      glFormat,\n      glType,\n      glInternalFormat\n    });\n  }\n  copyBufferToTexture(buffer, texture) {\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      textureGPU,\n      glTextureType,\n      glFormat,\n      glType\n    } = backend.get(texture);\n    const {\n      width,\n      height\n    } = texture.source.data;\n    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, buffer);\n    backend.state.bindTexture(glTextureType, textureGPU);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, 0);\n    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);\n    backend.state.unbindTexture();\n    // debug\n    // const framebuffer = gl.createFramebuffer();\n    // gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );\n    // gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );\n\n    // const readout = new Float32Array( width * height * 4 );\n\n    // const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );\n    // const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );\n\n    // gl.readPixels( 0, 0, width, height, altFormat, altType, readout );\n    // gl.bindFramebuffer( gl.FRAMEBUFFER, null );\n    // console.log( readout );\n  }\n  updateTexture(texture, options) {\n    const {\n      gl\n    } = this;\n    const {\n      width,\n      height\n    } = options;\n    const {\n      textureGPU,\n      glTextureType,\n      glFormat,\n      glType,\n      glInternalFormat\n    } = this.backend.get(texture);\n    if (texture.isRenderTargetTexture || textureGPU === undefined /* unsupported texture format */) return;\n    const getImage = source => {\n      if (source.isDataTexture) {\n        return source.image.data;\n      } else if (typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap || source instanceof OffscreenCanvas) {\n        return source;\n      }\n      return source.data;\n    };\n    this.backend.state.bindTexture(glTextureType, textureGPU);\n    this.setTextureParameters(glTextureType, texture);\n    if (texture.isCompressedTexture) {\n      const mipmaps = texture.mipmaps;\n      const image = options.image;\n      for (let i = 0; i < mipmaps.length; i++) {\n        const mipmap = mipmaps[i];\n        if (texture.isCompressedArrayTexture) {\n          if (texture.format !== gl.RGBA) {\n            if (glFormat !== null) {\n              gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);\n            } else {\n              console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');\n            }\n          } else {\n            gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);\n          }\n        } else {\n          if (glFormat !== null) {\n            gl.compressedTexSubImage2D(gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);\n          } else {\n            console.warn('Unsupported compressed texture format');\n          }\n        }\n      }\n    } else if (texture.isCubeTexture) {\n      const images = options.images;\n      for (let i = 0; i < 6; i++) {\n        const image = getImage(images[i]);\n        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image);\n      }\n    } else if (texture.isDataArrayTexture) {\n      const image = options.image;\n      gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);\n    } else if (texture.isData3DTexture) {\n      const image = options.image;\n      gl.texSubImage3D(gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);\n    } else if (texture.isVideoTexture) {\n      texture.update();\n      gl.texImage2D(glTextureType, 0, glInternalFormat, glFormat, glType, options.image);\n    } else {\n      const image = getImage(options.image);\n      gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, image);\n    }\n  }\n  generateMipmaps(texture) {\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      textureGPU,\n      glTextureType\n    } = backend.get(texture);\n    backend.state.bindTexture(glTextureType, textureGPU);\n    gl.generateMipmap(glTextureType);\n  }\n  deallocateRenderBuffers(renderTarget) {\n    const {\n      gl,\n      backend\n    } = this;\n\n    // remove framebuffer reference\n    if (renderTarget) {\n      const renderContextData = backend.get(renderTarget);\n      renderContextData.renderBufferStorageSetup = undefined;\n      if (renderContextData.framebuffers) {\n        for (const cacheKey in renderContextData.framebuffers) {\n          gl.deleteFramebuffer(renderContextData.framebuffers[cacheKey]);\n        }\n        delete renderContextData.framebuffers;\n      }\n      if (renderContextData.depthRenderbuffer) {\n        gl.deleteRenderbuffer(renderContextData.depthRenderbuffer);\n        delete renderContextData.depthRenderbuffer;\n      }\n      if (renderContextData.stencilRenderbuffer) {\n        gl.deleteRenderbuffer(renderContextData.stencilRenderbuffer);\n        delete renderContextData.stencilRenderbuffer;\n      }\n      if (renderContextData.msaaFrameBuffer) {\n        gl.deleteFramebuffer(renderContextData.msaaFrameBuffer);\n        delete renderContextData.msaaFrameBuffer;\n      }\n      if (renderContextData.msaaRenderbuffers) {\n        for (let i = 0; i < renderContextData.msaaRenderbuffers.length; i++) {\n          gl.deleteRenderbuffer(renderContextData.msaaRenderbuffers[i]);\n        }\n        delete renderContextData.msaaRenderbuffers;\n      }\n    }\n  }\n  destroyTexture(texture) {\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      textureGPU,\n      renderTarget\n    } = backend.get(texture);\n    this.deallocateRenderBuffers(renderTarget);\n    gl.deleteTexture(textureGPU);\n    backend.delete(texture);\n  }\n  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {\n    const {\n      gl,\n      backend\n    } = this;\n    const {\n      state\n    } = this.backend;\n    const {\n      textureGPU: dstTextureGPU,\n      glTextureType,\n      glType,\n      glFormat\n    } = backend.get(dstTexture);\n    let width, height, minX, minY;\n    let dstX, dstY;\n    if (srcRegion !== null) {\n      width = srcRegion.max.x - srcRegion.min.x;\n      height = srcRegion.max.y - srcRegion.min.y;\n      minX = srcRegion.min.x;\n      minY = srcRegion.min.y;\n    } else {\n      width = srcTexture.image.width;\n      height = srcTexture.image.height;\n      minX = 0;\n      minY = 0;\n    }\n    if (dstPosition !== null) {\n      dstX = dstPosition.x;\n      dstY = dstPosition.y;\n    } else {\n      dstX = 0;\n      dstY = 0;\n    }\n    state.bindTexture(glTextureType, dstTextureGPU);\n\n    // As another texture upload may have changed pixelStorei\n    // parameters, make sure they are correct for the dstTexture\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n    const currentUnpackRowLen = gl.getParameter(gl.UNPACK_ROW_LENGTH);\n    const currentUnpackImageHeight = gl.getParameter(gl.UNPACK_IMAGE_HEIGHT);\n    const currentUnpackSkipPixels = gl.getParameter(gl.UNPACK_SKIP_PIXELS);\n    const currentUnpackSkipRows = gl.getParameter(gl.UNPACK_SKIP_ROWS);\n    const currentUnpackSkipImages = gl.getParameter(gl.UNPACK_SKIP_IMAGES);\n    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;\n    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, image.width);\n    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, image.height);\n    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, minX);\n    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, minY);\n    if (srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture) {\n      const srcTextureData = backend.get(srcTexture);\n      const dstTextureData = backend.get(dstTexture);\n      const srcRenderContextData = backend.get(srcTextureData.renderTarget);\n      const dstRenderContextData = backend.get(dstTextureData.renderTarget);\n      const srcFramebuffer = srcRenderContextData.framebuffers[srcTextureData.cacheKey];\n      const dstFramebuffer = dstRenderContextData.framebuffers[dstTextureData.cacheKey];\n      state.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFramebuffer);\n      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFramebuffer);\n      let mask = gl.COLOR_BUFFER_BIT;\n      if (srcTexture.isDepthTexture) mask = gl.DEPTH_BUFFER_BIT;\n      gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, mask, gl.NEAREST);\n      state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n    } else {\n      if (srcTexture.isDataTexture) {\n        gl.texSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data);\n      } else {\n        if (srcTexture.isCompressedTexture) {\n          gl.compressedTexSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data);\n        } else {\n          gl.texSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image);\n        }\n      }\n    }\n    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);\n    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);\n    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);\n    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);\n    gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);\n\n    // Generate mipmaps only when copying level 0\n    if (level === 0 && dstTexture.generateMipmaps) gl.generateMipmap(gl.TEXTURE_2D);\n    state.unbindTexture();\n  }\n  copyFramebufferToTexture(texture, renderContext, rectangle) {\n    const {\n      gl\n    } = this;\n    const {\n      state\n    } = this.backend;\n    const {\n      textureGPU\n    } = this.backend.get(texture);\n    const {\n      x,\n      y,\n      z: width,\n      w: height\n    } = rectangle;\n    const requireDrawFrameBuffer = texture.isDepthTexture === true || renderContext.renderTarget && renderContext.renderTarget.samples > 0;\n    const srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.gerDrawingBufferSize().y;\n    if (requireDrawFrameBuffer) {\n      const partial = x !== 0 || y !== 0;\n      let mask;\n      let attachment;\n      if (texture.isDepthTexture === true) {\n        mask = gl.DEPTH_BUFFER_BIT;\n        attachment = gl.DEPTH_ATTACHMENT;\n        if (renderContext.stencil) {\n          mask |= gl.STENCIL_BUFFER_BIT;\n        }\n      } else {\n        mask = gl.COLOR_BUFFER_BIT;\n        attachment = gl.COLOR_ATTACHMENT0;\n      }\n      if (partial) {\n        const renderTargetContextData = this.backend.get(renderContext.renderTarget);\n        const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];\n        const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);\n        state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);\n        const flippedY = srcHeight - y - height;\n        gl.blitFramebuffer(x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST);\n        state.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);\n        state.bindTexture(gl.TEXTURE_2D, textureGPU);\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height);\n        state.unbindTexture();\n      } else {\n        const fb = gl.createFramebuffer();\n        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);\n        gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0);\n        gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);\n        gl.deleteFramebuffer(fb);\n      }\n    } else {\n      state.bindTexture(gl.TEXTURE_2D, textureGPU);\n      gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height);\n      state.unbindTexture();\n    }\n    if (texture.generateMipmaps) this.generateMipmaps(texture);\n    this.backend._setFramebuffer(renderContext);\n  }\n\n  // Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n  setupRenderBufferStorage(renderbuffer, renderContext) {\n    const {\n      gl\n    } = this;\n    const renderTarget = renderContext.renderTarget;\n    const {\n      samples,\n      depthTexture,\n      depthBuffer,\n      stencilBuffer,\n      width,\n      height\n    } = renderTarget;\n    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n    if (depthBuffer && !stencilBuffer) {\n      let glInternalFormat = gl.DEPTH_COMPONENT24;\n      if (samples > 0) {\n        if (depthTexture && depthTexture.isDepthTexture) {\n          if (depthTexture.type === gl.FLOAT) {\n            glInternalFormat = gl.DEPTH_COMPONENT32F;\n          }\n        }\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, glInternalFormat, width, height);\n      } else {\n        gl.renderbufferStorage(gl.RENDERBUFFER, glInternalFormat, width, height);\n      }\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n    } else if (depthBuffer && stencilBuffer) {\n      if (samples > 0) {\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height);\n      } else {\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\n      }\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n    }\n  }\n  async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {\n    const {\n      backend,\n      gl\n    } = this;\n    const {\n      textureGPU,\n      glFormat,\n      glType\n    } = this.backend.get(texture);\n    const fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);\n    const target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;\n    gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0);\n    const typedArrayType = this._getTypedArrayType(glType);\n    const bytesPerTexel = this._getBytesPerTexel(glType, glFormat);\n    const elementCount = width * height;\n    const byteLength = elementCount * bytesPerTexel;\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);\n    gl.bufferData(gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ);\n    gl.readPixels(x, y, width, height, glFormat, glType, 0);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n    await backend.utils._clientWaitAsync();\n    const dstBuffer = new typedArrayType(byteLength / typedArrayType.BYTES_PER_ELEMENT);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);\n    gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dstBuffer);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n    gl.deleteFramebuffer(fb);\n    return dstBuffer;\n  }\n  _getTypedArrayType(glType) {\n    const {\n      gl\n    } = this;\n    if (glType === gl.UNSIGNED_BYTE) return Uint8Array;\n    if (glType === gl.UNSIGNED_SHORT_4_4_4_4) return Uint16Array;\n    if (glType === gl.UNSIGNED_SHORT_5_5_5_1) return Uint16Array;\n    if (glType === gl.UNSIGNED_SHORT_5_6_5) return Uint16Array;\n    if (glType === gl.UNSIGNED_SHORT) return Uint16Array;\n    if (glType === gl.UNSIGNED_INT) return Uint32Array;\n    if (glType === gl.HALF_FLOAT) return Uint16Array;\n    if (glType === gl.FLOAT) return Float32Array;\n    throw new Error(`Unsupported WebGL type: ${glType}`);\n  }\n  _getBytesPerTexel(glType, glFormat) {\n    const {\n      gl\n    } = this;\n    let bytesPerComponent = 0;\n    if (glType === gl.UNSIGNED_BYTE) bytesPerComponent = 1;\n    if (glType === gl.UNSIGNED_SHORT_4_4_4_4 || glType === gl.UNSIGNED_SHORT_5_5_5_1 || glType === gl.UNSIGNED_SHORT_5_6_5 || glType === gl.UNSIGNED_SHORT || glType === gl.HALF_FLOAT) bytesPerComponent = 2;\n    if (glType === gl.UNSIGNED_INT || glType === gl.FLOAT) bytesPerComponent = 4;\n    if (glFormat === gl.RGBA) return bytesPerComponent * 4;\n    if (glFormat === gl.RGB) return bytesPerComponent * 3;\n    if (glFormat === gl.ALPHA) return bytesPerComponent;\n  }\n}\nclass WebGLExtensions {\n  constructor(backend) {\n    this.backend = backend;\n    this.gl = this.backend.gl;\n    this.availableExtensions = this.gl.getSupportedExtensions();\n    this.extensions = {};\n  }\n  get(name) {\n    let extension = this.extensions[name];\n    if (extension === undefined) {\n      extension = this.gl.getExtension(name);\n      this.extensions[name] = extension;\n    }\n    return extension;\n  }\n  has(name) {\n    return this.availableExtensions.includes(name);\n  }\n}\nclass WebGLCapabilities {\n  constructor(backend) {\n    this.backend = backend;\n    this.maxAnisotropy = null;\n  }\n  getMaxAnisotropy() {\n    if (this.maxAnisotropy !== null) return this.maxAnisotropy;\n    const gl = this.backend.gl;\n    const extensions = this.backend.extensions;\n    if (extensions.has('EXT_texture_filter_anisotropic') === true) {\n      const extension = extensions.get('EXT_texture_filter_anisotropic');\n      this.maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n    } else {\n      this.maxAnisotropy = 0;\n    }\n    return this.maxAnisotropy;\n  }\n}\nconst GLFeatureName = {\n  'WEBGL_multi_draw': 'WEBGL_multi_draw',\n  'WEBGL_compressed_texture_astc': 'texture-compression-astc',\n  'WEBGL_compressed_texture_etc': 'texture-compression-etc2',\n  'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',\n  'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n  'WEBKIT_WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n  'WEBGL_compressed_texture_s3tc': 'texture-compression-bc',\n  'EXT_texture_compression_bptc': 'texture-compression-bptc',\n  'EXT_disjoint_timer_query_webgl2': 'timestamp-query'\n};\nclass WebGLBufferRenderer {\n  constructor(backend) {\n    this.gl = backend.gl;\n    this.extensions = backend.extensions;\n    this.info = backend.renderer.info;\n    this.mode = null;\n    this.index = 0;\n    this.type = null;\n    this.object = null;\n  }\n  render(start, count) {\n    const {\n      gl,\n      mode,\n      object,\n      type,\n      info,\n      index\n    } = this;\n    if (index !== 0) {\n      gl.drawElements(mode, count, type, start);\n    } else {\n      gl.drawArrays(mode, start, count);\n    }\n    info.update(object, count, mode, 1);\n  }\n  renderInstances(start, count, primcount) {\n    const {\n      gl,\n      mode,\n      type,\n      index,\n      object,\n      info\n    } = this;\n    if (primcount === 0) return;\n    if (index !== 0) {\n      gl.drawElementsInstanced(mode, count, type, start, primcount);\n    } else {\n      gl.drawArraysInstanced(mode, start, count, primcount);\n    }\n    info.update(object, count, mode, primcount);\n  }\n  renderMultiDraw(starts, counts, drawCount) {\n    const {\n      extensions,\n      mode,\n      object,\n      info\n    } = this;\n    if (drawCount === 0) return;\n    const extension = extensions.get('WEBGL_multi_draw');\n    if (extension === null) {\n      for (let i = 0; i < drawCount; i++) {\n        this.render(starts[i], counts[i]);\n      }\n    } else {\n      if (this.index !== 0) {\n        extension.multiDrawElementsWEBGL(mode, counts, 0, this.type, starts, 0, drawCount);\n      } else {\n        extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);\n      }\n      let elementCount = 0;\n      for (let i = 0; i < drawCount; i++) {\n        elementCount += counts[i];\n      }\n      info.update(object, elementCount, mode, 1);\n    }\n  }\n  renderMultiDrawInstances(starts, counts, drawCount, primcount) {\n    const {\n      extensions,\n      mode,\n      object,\n      info\n    } = this;\n    if (drawCount === 0) return;\n    const extension = extensions.get('WEBGL_multi_draw');\n    if (extension === null) {\n      for (let i = 0; i < drawCount; i++) {\n        this.renderInstances(starts[i], counts[i], primcount[i]);\n      }\n    } else {\n      if (this.index !== 0) {\n        extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount);\n      } else {\n        extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);\n      }\n      let elementCount = 0;\n      for (let i = 0; i < drawCount; i++) {\n        elementCount += counts[i] * primcount[i];\n      }\n      info.update(object, elementCount, mode, 1);\n    }\n  }\n\n  //\n}\n\n//\n\nclass WebGLBackend extends Backend {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.isWebGLBackend = true;\n  }\n  init(renderer) {\n    super.init(renderer);\n\n    //\n\n    const parameters = this.parameters;\n    const glContext = parameters.context !== undefined ? parameters.context : renderer.domElement.getContext('webgl2');\n    function onContextLost(event) {\n      event.preventDefault();\n      const contextLossInfo = {\n        api: 'WebGL',\n        message: event.statusMessage || 'Unknown reason',\n        reason: null,\n        originalEvent: event\n      };\n      renderer.onDeviceLost(contextLossInfo);\n    }\n    this._onContextLost = onContextLost;\n    renderer.domElement.addEventListener('webglcontextlost', onContextLost, false);\n    this.gl = glContext;\n    this.extensions = new WebGLExtensions(this);\n    this.capabilities = new WebGLCapabilities(this);\n    this.attributeUtils = new WebGLAttributeUtils(this);\n    this.textureUtils = new WebGLTextureUtils(this);\n    this.bufferRenderer = new WebGLBufferRenderer(this);\n    this.state = new WebGLState(this);\n    this.utils = new WebGLUtils(this);\n    this.vaoCache = {};\n    this.transformFeedbackCache = {};\n    this.discard = false;\n    this.trackTimestamp = parameters.trackTimestamp === true;\n    this.extensions.get('EXT_color_buffer_float');\n    this.extensions.get('WEBGL_clip_cull_distance');\n    this.extensions.get('OES_texture_float_linear');\n    this.extensions.get('EXT_color_buffer_half_float');\n    this.extensions.get('WEBGL_multisampled_render_to_texture');\n    this.extensions.get('WEBGL_render_shared_exponent');\n    this.extensions.get('WEBGL_multi_draw');\n    this.disjoint = this.extensions.get('EXT_disjoint_timer_query_webgl2');\n    this.parallel = this.extensions.get('KHR_parallel_shader_compile');\n    this._knownBindings = new WeakSet();\n    this._currentContext = null;\n  }\n  get coordinateSystem() {\n    return WebGLCoordinateSystem;\n  }\n  async getArrayBufferAsync(attribute) {\n    return await this.attributeUtils.getArrayBufferAsync(attribute);\n  }\n  async waitForGPU() {\n    await this.utils._clientWaitAsync();\n  }\n  initTimestampQuery(renderContext) {\n    if (!this.disjoint || !this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (this.queryRunning) {\n      if (!renderContextData.queryQueue) renderContextData.queryQueue = [];\n      renderContextData.queryQueue.push(renderContext);\n      return;\n    }\n    if (renderContextData.activeQuery) {\n      this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT);\n      renderContextData.activeQuery = null;\n    }\n    renderContextData.activeQuery = this.gl.createQuery();\n    if (renderContextData.activeQuery !== null) {\n      this.gl.beginQuery(this.disjoint.TIME_ELAPSED_EXT, renderContextData.activeQuery);\n      this.queryRunning = true;\n    }\n  }\n\n  // timestamp utils\n\n  prepareTimestampBuffer(renderContext) {\n    if (!this.disjoint || !this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (renderContextData.activeQuery) {\n      this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT);\n      if (!renderContextData.gpuQueries) renderContextData.gpuQueries = [];\n      renderContextData.gpuQueries.push({\n        query: renderContextData.activeQuery\n      });\n      renderContextData.activeQuery = null;\n      this.queryRunning = false;\n      if (renderContextData.queryQueue && renderContextData.queryQueue.length > 0) {\n        const nextRenderContext = renderContextData.queryQueue.shift();\n        this.initTimestampQuery(nextRenderContext);\n      }\n    }\n  }\n  async resolveTimestampAsync(renderContext, type = 'render') {\n    if (!this.disjoint || !this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (!renderContextData.gpuQueries) renderContextData.gpuQueries = [];\n    for (let i = 0; i < renderContextData.gpuQueries.length; i++) {\n      const queryInfo = renderContextData.gpuQueries[i];\n      const available = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE);\n      const disjoint = this.gl.getParameter(this.disjoint.GPU_DISJOINT_EXT);\n      if (available && !disjoint) {\n        const elapsed = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT);\n        const duration = Number(elapsed) / 1000000; // Convert nanoseconds to milliseconds\n        this.gl.deleteQuery(queryInfo.query);\n        renderContextData.gpuQueries.splice(i, 1); // Remove the processed query\n        i--;\n        this.renderer.info.updateTimestamp(type, duration);\n      }\n    }\n  }\n  getContext() {\n    return this.gl;\n  }\n  beginRender(renderContext) {\n    const {\n      gl\n    } = this;\n    const renderContextData = this.get(renderContext);\n\n    //\n\n    //\n\n    this.initTimestampQuery(renderContext);\n    renderContextData.previousContext = this._currentContext;\n    this._currentContext = renderContext;\n    this._setFramebuffer(renderContext);\n    this.clear(renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false);\n\n    //\n    if (renderContext.viewport) {\n      this.updateViewport(renderContext);\n    } else {\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    }\n    if (renderContext.scissor) {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = renderContext.scissorValue;\n      gl.scissor(x, renderContext.height - height - y, width, height);\n    }\n    const occlusionQueryCount = renderContext.occlusionQueryCount;\n    if (occlusionQueryCount > 0) {\n      // Get a reference to the array of objects with queries. The renderContextData property\n      // can be changed by another render pass before the async reading of all previous queries complete\n      renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;\n      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n      renderContextData.lastOcclusionObject = null;\n      renderContextData.occlusionQueries = new Array(occlusionQueryCount);\n      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);\n      renderContextData.occlusionQueryIndex = 0;\n    }\n  }\n  finishRender(renderContext) {\n    const {\n      gl,\n      state\n    } = this;\n    const renderContextData = this.get(renderContext);\n    const previousContext = renderContextData.previousContext;\n    const occlusionQueryCount = renderContext.occlusionQueryCount;\n    if (occlusionQueryCount > 0) {\n      if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {\n        gl.endQuery(gl.ANY_SAMPLES_PASSED);\n      }\n      this.resolveOccludedAsync(renderContext);\n    }\n    const textures = renderContext.textures;\n    if (textures !== null) {\n      for (let i = 0; i < textures.length; i++) {\n        const texture = textures[i];\n        if (texture.generateMipmaps) {\n          this.generateMipmaps(texture);\n        }\n      }\n    }\n    this._currentContext = previousContext;\n    if (renderContext.textures !== null && renderContext.renderTarget) {\n      const renderTargetContextData = this.get(renderContext.renderTarget);\n      const {\n        samples\n      } = renderContext.renderTarget;\n      if (samples > 0) {\n        const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];\n        const mask = gl.COLOR_BUFFER_BIT;\n        const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n        const textures = renderContext.textures;\n        state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);\n        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);\n        for (let i = 0; i < textures.length; i++) {\n          // TODO Add support for MRT\n\n          if (renderContext.scissor) {\n            const {\n              x,\n              y,\n              width,\n              height\n            } = renderContext.scissorValue;\n            const viewY = renderContext.height - height - y;\n            gl.blitFramebuffer(x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST);\n            gl.invalidateSubFramebuffer(gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray, x, viewY, width, height);\n          } else {\n            gl.blitFramebuffer(0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST);\n            gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray);\n          }\n        }\n      }\n    }\n    if (previousContext !== null) {\n      this._setFramebuffer(previousContext);\n      if (previousContext.viewport) {\n        this.updateViewport(previousContext);\n      } else {\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n      }\n    }\n    this.prepareTimestampBuffer(renderContext);\n  }\n  resolveOccludedAsync(renderContext) {\n    const renderContextData = this.get(renderContext);\n\n    // handle occlusion query results\n\n    const {\n      currentOcclusionQueries,\n      currentOcclusionQueryObjects\n    } = renderContextData;\n    if (currentOcclusionQueries && currentOcclusionQueryObjects) {\n      const occluded = new WeakSet();\n      const {\n        gl\n      } = this;\n      renderContextData.currentOcclusionQueryObjects = null;\n      renderContextData.currentOcclusionQueries = null;\n      const check = () => {\n        let completed = 0;\n\n        // check all queries and requeue as appropriate\n        for (let i = 0; i < currentOcclusionQueries.length; i++) {\n          const query = currentOcclusionQueries[i];\n          if (query === null) continue;\n          if (gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {\n            if (gl.getQueryParameter(query, gl.QUERY_RESULT) > 0) occluded.add(currentOcclusionQueryObjects[i]);\n            currentOcclusionQueries[i] = null;\n            gl.deleteQuery(query);\n            completed++;\n          }\n        }\n        if (completed < currentOcclusionQueries.length) {\n          requestAnimationFrame(check);\n        } else {\n          renderContextData.occluded = occluded;\n        }\n      };\n      check();\n    }\n  }\n  isOccluded(renderContext, object) {\n    const renderContextData = this.get(renderContext);\n    return renderContextData.occluded && renderContextData.occluded.has(object);\n  }\n  updateViewport(renderContext) {\n    const gl = this.gl;\n    const {\n      x,\n      y,\n      width,\n      height\n    } = renderContext.viewportValue;\n    gl.viewport(x, renderContext.height - height - y, width, height);\n  }\n  setScissorTest(boolean) {\n    const gl = this.gl;\n    if (boolean) {\n      gl.enable(gl.SCISSOR_TEST);\n    } else {\n      gl.disable(gl.SCISSOR_TEST);\n    }\n  }\n  clear(color, depth, stencil, descriptor = null, setFrameBuffer = true) {\n    const {\n      gl\n    } = this;\n    if (descriptor === null) {\n      const clearColor = this.getClearColor();\n\n      // premultiply alpha\n\n      clearColor.r *= clearColor.a;\n      clearColor.g *= clearColor.a;\n      clearColor.b *= clearColor.a;\n      descriptor = {\n        textures: null,\n        clearColorValue: clearColor\n      };\n    }\n\n    //\n\n    let clear = 0;\n    if (color) clear |= gl.COLOR_BUFFER_BIT;\n    if (depth) clear |= gl.DEPTH_BUFFER_BIT;\n    if (stencil) clear |= gl.STENCIL_BUFFER_BIT;\n    if (clear !== 0) {\n      let clearColor;\n      if (descriptor.clearColorValue) {\n        clearColor = descriptor.clearColorValue;\n      } else {\n        clearColor = this.getClearColor();\n\n        // premultiply alpha\n\n        clearColor.r *= clearColor.a;\n        clearColor.g *= clearColor.a;\n        clearColor.b *= clearColor.a;\n      }\n      if (depth) this.state.setDepthMask(true);\n      if (descriptor.textures === null) {\n        gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);\n        gl.clear(clear);\n      } else {\n        if (setFrameBuffer) this._setFramebuffer(descriptor);\n        if (color) {\n          for (let i = 0; i < descriptor.textures.length; i++) {\n            gl.clearBufferfv(gl.COLOR, i, [clearColor.r, clearColor.g, clearColor.b, clearColor.a]);\n          }\n        }\n        if (depth && stencil) {\n          gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1, 0);\n        } else if (depth) {\n          gl.clearBufferfv(gl.DEPTH, 0, [1.0]);\n        } else if (stencil) {\n          gl.clearBufferiv(gl.STENCIL, 0, [0]);\n        }\n      }\n    }\n  }\n  beginCompute(computeGroup) {\n    const {\n      state,\n      gl\n    } = this;\n    state.bindFramebuffer(gl.FRAMEBUFFER, null);\n    this.initTimestampQuery(computeGroup);\n  }\n  compute(computeGroup, computeNode, bindings, pipeline) {\n    const {\n      state,\n      gl\n    } = this;\n    if (!this.discard) {\n      // required here to handle async behaviour of render.compute()\n      gl.enable(gl.RASTERIZER_DISCARD);\n      this.discard = true;\n    }\n    const {\n      programGPU,\n      transformBuffers,\n      attributes\n    } = this.get(pipeline);\n    const vaoKey = this._getVaoKey(null, attributes);\n    const vaoGPU = this.vaoCache[vaoKey];\n    if (vaoGPU === undefined) {\n      this._createVao(null, attributes);\n    } else {\n      gl.bindVertexArray(vaoGPU);\n    }\n    state.useProgram(programGPU);\n    this._bindUniforms(bindings);\n    const transformFeedbackGPU = this._getTransformFeedback(transformBuffers);\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);\n    gl.beginTransformFeedback(gl.POINTS);\n    if (attributes[0].isStorageInstancedBufferAttribute) {\n      gl.drawArraysInstanced(gl.POINTS, 0, 1, computeNode.count);\n    } else {\n      gl.drawArrays(gl.POINTS, 0, computeNode.count);\n    }\n    gl.endTransformFeedback();\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n\n    // switch active buffers\n\n    for (let i = 0; i < transformBuffers.length; i++) {\n      const dualAttributeData = transformBuffers[i];\n      if (dualAttributeData.pbo) {\n        this.textureUtils.copyBufferToTexture(dualAttributeData.transformBuffer, dualAttributeData.pbo);\n      }\n      dualAttributeData.switchBuffers();\n    }\n  }\n  finishCompute(computeGroup) {\n    const gl = this.gl;\n    this.discard = false;\n    gl.disable(gl.RASTERIZER_DISCARD);\n    this.prepareTimestampBuffer(computeGroup);\n    if (this._currentContext) {\n      this._setFramebuffer(this._currentContext);\n    }\n  }\n  draw(renderObject /*, info*/) {\n    const {\n      object,\n      pipeline,\n      material,\n      context,\n      hardwareClippingPlanes\n    } = renderObject;\n    const {\n      programGPU\n    } = this.get(pipeline);\n    const {\n      gl,\n      state\n    } = this;\n    const contextData = this.get(context);\n    const drawParams = renderObject.getDrawParameters();\n    if (drawParams === null) return;\n\n    //\n\n    this._bindUniforms(renderObject.getBindings());\n    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n    state.setMaterial(material, frontFaceCW, hardwareClippingPlanes);\n    state.useProgram(programGPU);\n\n    //\n\n    const renderObjectData = this.get(renderObject);\n    let vaoGPU = renderObjectData.staticVao;\n    if (vaoGPU === undefined || renderObjectData.geometryId !== renderObject.geometry.id) {\n      const vaoKey = this._getVaoKey(renderObject.getIndex(), renderObject.getAttributes());\n      vaoGPU = this.vaoCache[vaoKey];\n      if (vaoGPU === undefined) {\n        let staticVao;\n        ({\n          vaoGPU,\n          staticVao\n        } = this._createVao(renderObject.getIndex(), renderObject.getAttributes()));\n        if (staticVao) {\n          renderObjectData.staticVao = vaoGPU;\n          renderObjectData.geometryId = renderObject.geometry.id;\n        }\n      }\n    }\n    gl.bindVertexArray(vaoGPU);\n\n    //\n\n    const index = renderObject.getIndex();\n\n    //\n\n    const lastObject = contextData.lastOcclusionObject;\n    if (lastObject !== object && lastObject !== undefined) {\n      if (lastObject !== null && lastObject.occlusionTest === true) {\n        gl.endQuery(gl.ANY_SAMPLES_PASSED);\n        contextData.occlusionQueryIndex++;\n      }\n      if (object.occlusionTest === true) {\n        const query = gl.createQuery();\n        gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);\n        contextData.occlusionQueries[contextData.occlusionQueryIndex] = query;\n        contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] = object;\n      }\n      contextData.lastOcclusionObject = object;\n    }\n\n    //\n    const renderer = this.bufferRenderer;\n    if (object.isPoints) renderer.mode = gl.POINTS;else if (object.isLineSegments) renderer.mode = gl.LINES;else if (object.isLine) renderer.mode = gl.LINE_STRIP;else if (object.isLineLoop) renderer.mode = gl.LINE_LOOP;else {\n      if (material.wireframe === true) {\n        state.setLineWidth(material.wireframeLinewidth * this.renderer.getPixelRatio());\n        renderer.mode = gl.LINES;\n      } else {\n        renderer.mode = gl.TRIANGLES;\n      }\n    }\n\n    //\n\n    const {\n      vertexCount,\n      instanceCount\n    } = drawParams;\n    let {\n      firstVertex\n    } = drawParams;\n    renderer.object = object;\n    if (index !== null) {\n      firstVertex *= index.array.BYTES_PER_ELEMENT;\n      const indexData = this.get(index);\n      renderer.index = index.count;\n      renderer.type = indexData.type;\n    } else {\n      renderer.index = 0;\n    }\n    if (object.isBatchedMesh) {\n      if (object._multiDrawInstances !== null) {\n        renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);\n      } else if (!this.hasFeature('WEBGL_multi_draw')) {\n        warnOnce('THREE.WebGLRenderer: WEBGL_multi_draw not supported.');\n      } else {\n        renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);\n      }\n    } else if (instanceCount > 1) {\n      renderer.renderInstances(firstVertex, vertexCount, instanceCount);\n    } else {\n      renderer.render(firstVertex, vertexCount);\n    }\n    //\n\n    gl.bindVertexArray(null);\n  }\n  needsRenderUpdate(/*renderObject*/\n  ) {\n    return false;\n  }\n  getRenderCacheKey(/*renderObject*/\n  ) {\n    return '';\n  }\n\n  // textures\n\n  createDefaultTexture(texture) {\n    this.textureUtils.createDefaultTexture(texture);\n  }\n  createTexture(texture, options) {\n    this.textureUtils.createTexture(texture, options);\n  }\n  updateTexture(texture, options) {\n    this.textureUtils.updateTexture(texture, options);\n  }\n  generateMipmaps(texture) {\n    this.textureUtils.generateMipmaps(texture);\n  }\n  destroyTexture(texture) {\n    this.textureUtils.destroyTexture(texture);\n  }\n  copyTextureToBuffer(texture, x, y, width, height, faceIndex) {\n    return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);\n  }\n  createSampler(/*texture*/\n  ) {\n\n    //console.warn( 'Abstract class.' );\n  }\n  destroySampler() {}\n\n  // node builder\n\n  createNodeBuilder(object, renderer) {\n    return new GLSLNodeBuilder(object, renderer);\n  }\n\n  // program\n\n  createProgram(program) {\n    const gl = this.gl;\n    const {\n      stage,\n      code\n    } = program;\n    const shader = stage === 'fragment' ? gl.createShader(gl.FRAGMENT_SHADER) : gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(shader, code);\n    gl.compileShader(shader);\n    this.set(program, {\n      shaderGPU: shader\n    });\n  }\n  destroyProgram(/*program*/\n  ) {\n    console.warn('Abstract class.');\n  }\n  createRenderPipeline(renderObject, promises) {\n    const gl = this.gl;\n    const pipeline = renderObject.pipeline;\n\n    // Program\n\n    const {\n      fragmentProgram,\n      vertexProgram\n    } = pipeline;\n    const programGPU = gl.createProgram();\n    const fragmentShader = this.get(fragmentProgram).shaderGPU;\n    const vertexShader = this.get(vertexProgram).shaderGPU;\n    gl.attachShader(programGPU, fragmentShader);\n    gl.attachShader(programGPU, vertexShader);\n    gl.linkProgram(programGPU);\n    this.set(pipeline, {\n      programGPU,\n      fragmentShader,\n      vertexShader\n    });\n    if (promises !== null && this.parallel) {\n      const p = new Promise((resolve /*, reject*/) => {\n        const parallel = this.parallel;\n        const checkStatus = () => {\n          if (gl.getProgramParameter(programGPU, parallel.COMPLETION_STATUS_KHR)) {\n            this._completeCompile(renderObject, pipeline);\n            resolve();\n          } else {\n            requestAnimationFrame(checkStatus);\n          }\n        };\n        checkStatus();\n      });\n      promises.push(p);\n      return;\n    }\n    this._completeCompile(renderObject, pipeline);\n  }\n  _handleSource(string, errorLine) {\n    const lines = string.split('\\n');\n    const lines2 = [];\n    const from = Math.max(errorLine - 6, 0);\n    const to = Math.min(errorLine + 6, lines.length);\n    for (let i = from; i < to; i++) {\n      const line = i + 1;\n      lines2.push(`${line === errorLine ? '>' : ' '} ${line}: ${lines[i]}`);\n    }\n    return lines2.join('\\n');\n  }\n  _getShaderErrors(gl, shader, type) {\n    const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    const errors = gl.getShaderInfoLog(shader).trim();\n    if (status && errors === '') return '';\n    const errorMatches = /ERROR: 0:(\\d+)/.exec(errors);\n    if (errorMatches) {\n      const errorLine = parseInt(errorMatches[1]);\n      return type.toUpperCase() + '\\n\\n' + errors + '\\n\\n' + this._handleSource(gl.getShaderSource(shader), errorLine);\n    } else {\n      return errors;\n    }\n  }\n  _logProgramError(programGPU, glFragmentShader, glVertexShader) {\n    if (this.renderer.debug.checkShaderErrors) {\n      const gl = this.gl;\n      const programLog = gl.getProgramInfoLog(programGPU).trim();\n      if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {\n        if (typeof this.renderer.debug.onShaderError === 'function') {\n          this.renderer.debug.onShaderError(gl, programGPU, glVertexShader, glFragmentShader);\n        } else {\n          // default error reporting\n\n          const vertexErrors = this._getShaderErrors(gl, glVertexShader, 'vertex');\n          const fragmentErrors = this._getShaderErrors(gl, glFragmentShader, 'fragment');\n          console.error('THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' + 'VALIDATE_STATUS ' + gl.getProgramParameter(programGPU, gl.VALIDATE_STATUS) + '\\n\\n' + 'Program Info Log: ' + programLog + '\\n' + vertexErrors + '\\n' + fragmentErrors);\n        }\n      } else if (programLog !== '') {\n        console.warn('THREE.WebGLProgram: Program Info Log:', programLog);\n      }\n    }\n  }\n  _completeCompile(renderObject, pipeline) {\n    const {\n      state,\n      gl\n    } = this;\n    const pipelineData = this.get(pipeline);\n    const {\n      programGPU,\n      fragmentShader,\n      vertexShader\n    } = pipelineData;\n    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {\n      this._logProgramError(programGPU, fragmentShader, vertexShader);\n    }\n    state.useProgram(programGPU);\n\n    // Bindings\n\n    const bindings = renderObject.getBindings();\n    this._setupBindings(bindings, programGPU);\n\n    //\n\n    this.set(pipeline, {\n      programGPU\n    });\n  }\n  createComputePipeline(computePipeline, bindings) {\n    const {\n      state,\n      gl\n    } = this;\n\n    // Program\n\n    const fragmentProgram = {\n      stage: 'fragment',\n      code: '#version 300 es\\nprecision highp float;\\nvoid main() {}'\n    };\n    this.createProgram(fragmentProgram);\n    const {\n      computeProgram\n    } = computePipeline;\n    const programGPU = gl.createProgram();\n    const fragmentShader = this.get(fragmentProgram).shaderGPU;\n    const vertexShader = this.get(computeProgram).shaderGPU;\n    const transforms = computeProgram.transforms;\n    const transformVaryingNames = [];\n    const transformAttributeNodes = [];\n    for (let i = 0; i < transforms.length; i++) {\n      const transform = transforms[i];\n      transformVaryingNames.push(transform.varyingName);\n      transformAttributeNodes.push(transform.attributeNode);\n    }\n    gl.attachShader(programGPU, fragmentShader);\n    gl.attachShader(programGPU, vertexShader);\n    gl.transformFeedbackVaryings(programGPU, transformVaryingNames, gl.SEPARATE_ATTRIBS);\n    gl.linkProgram(programGPU);\n    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {\n      this._logProgramError(programGPU, fragmentShader, vertexShader);\n    }\n    state.useProgram(programGPU);\n\n    // Bindings\n\n    this._setupBindings(bindings, programGPU);\n    const attributeNodes = computeProgram.attributes;\n    const attributes = [];\n    const transformBuffers = [];\n    for (let i = 0; i < attributeNodes.length; i++) {\n      const attribute = attributeNodes[i].node.attribute;\n      attributes.push(attribute);\n      if (!this.has(attribute)) this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);\n    }\n    for (let i = 0; i < transformAttributeNodes.length; i++) {\n      const attribute = transformAttributeNodes[i].attribute;\n      if (!this.has(attribute)) this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);\n      const attributeData = this.get(attribute);\n      transformBuffers.push(attributeData);\n    }\n\n    //\n\n    this.set(computePipeline, {\n      programGPU,\n      transformBuffers,\n      attributes\n    });\n  }\n  createBindings(bindGroup, bindings) {\n    if (this._knownBindings.has(bindings) === false) {\n      this._knownBindings.add(bindings);\n      let uniformBuffers = 0;\n      let textures = 0;\n      for (const bindGroup of bindings) {\n        this.set(bindGroup, {\n          textures: textures,\n          uniformBuffers: uniformBuffers\n        });\n        for (const binding of bindGroup.bindings) {\n          if (binding.isUniformBuffer) uniformBuffers++;\n          if (binding.isSampledTexture) textures++;\n        }\n      }\n    }\n    this.updateBindings(bindGroup, bindings);\n  }\n  updateBindings(bindGroup /*, bindings*/) {\n    const {\n      gl\n    } = this;\n    const bindGroupData = this.get(bindGroup);\n    let i = bindGroupData.uniformBuffers;\n    let t = bindGroupData.textures;\n    for (const binding of bindGroup.bindings) {\n      if (binding.isUniformsGroup || binding.isUniformBuffer) {\n        const data = binding.buffer;\n        const bufferGPU = gl.createBuffer();\n        gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);\n        gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);\n        this.set(binding, {\n          index: i++,\n          bufferGPU\n        });\n      } else if (binding.isSampledTexture) {\n        const {\n          textureGPU,\n          glTextureType\n        } = this.get(binding.texture);\n        this.set(binding, {\n          index: t++,\n          textureGPU,\n          glTextureType\n        });\n      }\n    }\n  }\n  updateBinding(binding) {\n    const gl = this.gl;\n    if (binding.isUniformsGroup || binding.isUniformBuffer) {\n      const bindingData = this.get(binding);\n      const bufferGPU = bindingData.bufferGPU;\n      const data = binding.buffer;\n      gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);\n      gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);\n    }\n  }\n\n  // attributes\n\n  createIndexAttribute(attribute) {\n    const gl = this.gl;\n    this.attributeUtils.createAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);\n  }\n  createAttribute(attribute) {\n    if (this.has(attribute)) return;\n    const gl = this.gl;\n    this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);\n  }\n  createStorageAttribute(attribute) {\n    if (this.has(attribute)) return;\n    const gl = this.gl;\n    this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);\n  }\n  updateAttribute(attribute) {\n    this.attributeUtils.updateAttribute(attribute);\n  }\n  destroyAttribute(attribute) {\n    this.attributeUtils.destroyAttribute(attribute);\n  }\n  updateSize() {\n\n    //console.warn( 'Abstract class.' );\n  }\n  hasFeature(name) {\n    const keysMatching = Object.keys(GLFeatureName).filter(key => GLFeatureName[key] === name);\n    const extensions = this.extensions;\n    for (let i = 0; i < keysMatching.length; i++) {\n      if (extensions.has(keysMatching[i])) return true;\n    }\n    return false;\n  }\n  getMaxAnisotropy() {\n    return this.capabilities.getMaxAnisotropy();\n  }\n  copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level) {\n    this.textureUtils.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);\n  }\n  copyFramebufferToTexture(texture, renderContext, rectangle) {\n    this.textureUtils.copyFramebufferToTexture(texture, renderContext, rectangle);\n  }\n  _setFramebuffer(descriptor) {\n    const {\n      gl,\n      state\n    } = this;\n    let currentFrameBuffer = null;\n    if (descriptor.textures !== null) {\n      const renderTarget = descriptor.renderTarget;\n      const renderTargetContextData = this.get(renderTarget);\n      const {\n        samples,\n        depthBuffer,\n        stencilBuffer\n      } = renderTarget;\n      const isCube = renderTarget.isWebGLCubeRenderTarget === true;\n      let msaaFb = renderTargetContextData.msaaFrameBuffer;\n      let depthRenderbuffer = renderTargetContextData.depthRenderbuffer;\n      const cacheKey = getCacheKey(descriptor);\n      let fb;\n      if (isCube) {\n        renderTargetContextData.cubeFramebuffers || (renderTargetContextData.cubeFramebuffers = {});\n        fb = renderTargetContextData.cubeFramebuffers[cacheKey];\n      } else {\n        renderTargetContextData.framebuffers || (renderTargetContextData.framebuffers = {});\n        fb = renderTargetContextData.framebuffers[cacheKey];\n      }\n      if (fb === undefined) {\n        fb = gl.createFramebuffer();\n        state.bindFramebuffer(gl.FRAMEBUFFER, fb);\n        const textures = descriptor.textures;\n        if (isCube) {\n          renderTargetContextData.cubeFramebuffers[cacheKey] = fb;\n          const {\n            textureGPU\n          } = this.get(textures[0]);\n          const cubeFace = this.renderer._activeCubeFace;\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0);\n        } else {\n          renderTargetContextData.framebuffers[cacheKey] = fb;\n          for (let i = 0; i < textures.length; i++) {\n            const texture = textures[i];\n            const textureData = this.get(texture);\n            textureData.renderTarget = descriptor.renderTarget;\n            textureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n            const attachment = gl.COLOR_ATTACHMENT0 + i;\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0);\n          }\n          state.drawBuffers(descriptor, fb);\n        }\n        if (descriptor.depthTexture !== null) {\n          const textureData = this.get(descriptor.depthTexture);\n          const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n          textureData.renderTarget = descriptor.renderTarget;\n          textureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0);\n        }\n      }\n      if (samples > 0) {\n        if (msaaFb === undefined) {\n          const invalidationArray = [];\n          msaaFb = gl.createFramebuffer();\n          state.bindFramebuffer(gl.FRAMEBUFFER, msaaFb);\n          const msaaRenderbuffers = [];\n          const textures = descriptor.textures;\n          for (let i = 0; i < textures.length; i++) {\n            msaaRenderbuffers[i] = gl.createRenderbuffer();\n            gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderbuffers[i]);\n            invalidationArray.push(gl.COLOR_ATTACHMENT0 + i);\n            if (depthBuffer) {\n              const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n              invalidationArray.push(depthStyle);\n            }\n            const texture = descriptor.textures[i];\n            const textureData = this.get(texture);\n            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height);\n            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[i]);\n          }\n          renderTargetContextData.msaaFrameBuffer = msaaFb;\n          renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;\n          if (depthRenderbuffer === undefined) {\n            depthRenderbuffer = gl.createRenderbuffer();\n            this.textureUtils.setupRenderBufferStorage(depthRenderbuffer, descriptor);\n            renderTargetContextData.depthRenderbuffer = depthRenderbuffer;\n            const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n            invalidationArray.push(depthStyle);\n          }\n          renderTargetContextData.invalidationArray = invalidationArray;\n        }\n        currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n      } else {\n        currentFrameBuffer = fb;\n      }\n    }\n    state.bindFramebuffer(gl.FRAMEBUFFER, currentFrameBuffer);\n  }\n  _getVaoKey(index, attributes) {\n    let key = [];\n    if (index !== null) {\n      const indexData = this.get(index);\n      key += ':' + indexData.id;\n    }\n    for (let i = 0; i < attributes.length; i++) {\n      const attributeData = this.get(attributes[i]);\n      key += ':' + attributeData.id;\n    }\n    return key;\n  }\n  _createVao(index, attributes) {\n    const {\n      gl\n    } = this;\n    const vaoGPU = gl.createVertexArray();\n    let key = '';\n    let staticVao = true;\n    gl.bindVertexArray(vaoGPU);\n    if (index !== null) {\n      const indexData = this.get(index);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexData.bufferGPU);\n      key += ':' + indexData.id;\n    }\n    for (let i = 0; i < attributes.length; i++) {\n      const attribute = attributes[i];\n      const attributeData = this.get(attribute);\n      key += ':' + attributeData.id;\n      gl.bindBuffer(gl.ARRAY_BUFFER, attributeData.bufferGPU);\n      gl.enableVertexAttribArray(i);\n      if (attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute) staticVao = false;\n      let stride, offset;\n      if (attribute.isInterleavedBufferAttribute === true) {\n        stride = attribute.data.stride * attributeData.bytesPerElement;\n        offset = attribute.offset * attributeData.bytesPerElement;\n      } else {\n        stride = 0;\n        offset = 0;\n      }\n      if (attributeData.isInteger) {\n        gl.vertexAttribIPointer(i, attribute.itemSize, attributeData.type, stride, offset);\n      } else {\n        gl.vertexAttribPointer(i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset);\n      }\n      if (attribute.isInstancedBufferAttribute && !attribute.isInterleavedBufferAttribute) {\n        gl.vertexAttribDivisor(i, attribute.meshPerAttribute);\n      } else if (attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer) {\n        gl.vertexAttribDivisor(i, attribute.data.meshPerAttribute);\n      }\n    }\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    this.vaoCache[key] = vaoGPU;\n    return {\n      vaoGPU,\n      staticVao\n    };\n  }\n  _getTransformFeedback(transformBuffers) {\n    let key = '';\n    for (let i = 0; i < transformBuffers.length; i++) {\n      key += ':' + transformBuffers[i].id;\n    }\n    let transformFeedbackGPU = this.transformFeedbackCache[key];\n    if (transformFeedbackGPU !== undefined) {\n      return transformFeedbackGPU;\n    }\n    const {\n      gl\n    } = this;\n    transformFeedbackGPU = gl.createTransformFeedback();\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);\n    for (let i = 0; i < transformBuffers.length; i++) {\n      const attributeData = transformBuffers[i];\n      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer);\n    }\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n    this.transformFeedbackCache[key] = transformFeedbackGPU;\n    return transformFeedbackGPU;\n  }\n  _setupBindings(bindings, programGPU) {\n    const gl = this.gl;\n    for (const bindGroup of bindings) {\n      for (const binding of bindGroup.bindings) {\n        const bindingData = this.get(binding);\n        const index = bindingData.index;\n        if (binding.isUniformsGroup || binding.isUniformBuffer) {\n          const location = gl.getUniformBlockIndex(programGPU, binding.name);\n          gl.uniformBlockBinding(programGPU, location, index);\n        } else if (binding.isSampledTexture) {\n          const location = gl.getUniformLocation(programGPU, binding.name);\n          gl.uniform1i(location, index);\n        }\n      }\n    }\n  }\n  _bindUniforms(bindings) {\n    const {\n      gl,\n      state\n    } = this;\n    for (const bindGroup of bindings) {\n      for (const binding of bindGroup.bindings) {\n        const bindingData = this.get(binding);\n        const index = bindingData.index;\n        if (binding.isUniformsGroup || binding.isUniformBuffer) {\n          // TODO USE bindBufferRange to group multiple uniform buffers\n          state.bindBufferBase(gl.UNIFORM_BUFFER, index, bindingData.bufferGPU);\n        } else if (binding.isSampledTexture) {\n          state.bindTexture(bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index);\n        }\n      }\n    }\n  }\n  dispose() {\n    this.renderer.domElement.removeEventListener('webglcontextlost', this._onContextLost);\n  }\n}\nconst GPUPrimitiveTopology = {\n  PointList: 'point-list',\n  LineList: 'line-list',\n  LineStrip: 'line-strip',\n  TriangleList: 'triangle-list',\n  TriangleStrip: 'triangle-strip'\n};\nconst GPUCompareFunction = {\n  Never: 'never',\n  Less: 'less',\n  Equal: 'equal',\n  LessEqual: 'less-equal',\n  Greater: 'greater',\n  NotEqual: 'not-equal',\n  GreaterEqual: 'greater-equal',\n  Always: 'always'\n};\nconst GPUStoreOp = {\n  Store: 'store',\n  Discard: 'discard'\n};\nconst GPULoadOp = {\n  Load: 'load',\n  Clear: 'clear'\n};\nconst GPUFrontFace = {\n  CCW: 'ccw',\n  CW: 'cw'\n};\nconst GPUCullMode = {\n  None: 'none',\n  Front: 'front',\n  Back: 'back'\n};\nconst GPUIndexFormat = {\n  Uint16: 'uint16',\n  Uint32: 'uint32'\n};\nconst GPUTextureFormat = {\n  // 8-bit formats\n\n  R8Unorm: 'r8unorm',\n  R8Snorm: 'r8snorm',\n  R8Uint: 'r8uint',\n  R8Sint: 'r8sint',\n  // 16-bit formats\n\n  R16Uint: 'r16uint',\n  R16Sint: 'r16sint',\n  R16Float: 'r16float',\n  RG8Unorm: 'rg8unorm',\n  RG8Snorm: 'rg8snorm',\n  RG8Uint: 'rg8uint',\n  RG8Sint: 'rg8sint',\n  // 32-bit formats\n\n  R32Uint: 'r32uint',\n  R32Sint: 'r32sint',\n  R32Float: 'r32float',\n  RG16Uint: 'rg16uint',\n  RG16Sint: 'rg16sint',\n  RG16Float: 'rg16float',\n  RGBA8Unorm: 'rgba8unorm',\n  RGBA8UnormSRGB: 'rgba8unorm-srgb',\n  RGBA8Snorm: 'rgba8snorm',\n  RGBA8Uint: 'rgba8uint',\n  RGBA8Sint: 'rgba8sint',\n  BGRA8Unorm: 'bgra8unorm',\n  BGRA8UnormSRGB: 'bgra8unorm-srgb',\n  // Packed 32-bit formats\n  RGB9E5UFloat: 'rgb9e5ufloat',\n  RGB10A2Unorm: 'rgb10a2unorm',\n  RG11B10uFloat: 'rgb10a2unorm',\n  // 64-bit formats\n\n  RG32Uint: 'rg32uint',\n  RG32Sint: 'rg32sint',\n  RG32Float: 'rg32float',\n  RGBA16Uint: 'rgba16uint',\n  RGBA16Sint: 'rgba16sint',\n  RGBA16Float: 'rgba16float',\n  // 128-bit formats\n\n  RGBA32Uint: 'rgba32uint',\n  RGBA32Sint: 'rgba32sint',\n  RGBA32Float: 'rgba32float',\n  // Depth and stencil formats\n\n  Stencil8: 'stencil8',\n  Depth16Unorm: 'depth16unorm',\n  Depth24Plus: 'depth24plus',\n  Depth24PlusStencil8: 'depth24plus-stencil8',\n  Depth32Float: 'depth32float',\n  // 'depth32float-stencil8' extension\n\n  Depth32FloatStencil8: 'depth32float-stencil8',\n  // BC compressed formats usable if 'texture-compression-bc' is both\n  // supported by the device/user agent and enabled in requestDevice.\n\n  BC1RGBAUnorm: 'bc1-rgba-unorm',\n  BC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',\n  BC2RGBAUnorm: 'bc2-rgba-unorm',\n  BC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',\n  BC3RGBAUnorm: 'bc3-rgba-unorm',\n  BC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',\n  BC4RUnorm: 'bc4-r-unorm',\n  BC4RSnorm: 'bc4-r-snorm',\n  BC5RGUnorm: 'bc5-rg-unorm',\n  BC5RGSnorm: 'bc5-rg-snorm',\n  BC6HRGBUFloat: 'bc6h-rgb-ufloat',\n  BC6HRGBFloat: 'bc6h-rgb-float',\n  BC7RGBAUnorm: 'bc7-rgba-unorm',\n  BC7RGBAUnormSRGB: 'bc7-rgba-srgb',\n  // ETC2 compressed formats usable if 'texture-compression-etc2' is both\n  // supported by the device/user agent and enabled in requestDevice.\n\n  ETC2RGB8Unorm: 'etc2-rgb8unorm',\n  ETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',\n  ETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',\n  ETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',\n  ETC2RGBA8Unorm: 'etc2-rgba8unorm',\n  ETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',\n  EACR11Unorm: 'eac-r11unorm',\n  EACR11Snorm: 'eac-r11snorm',\n  EACRG11Unorm: 'eac-rg11unorm',\n  EACRG11Snorm: 'eac-rg11snorm',\n  // ASTC compressed formats usable if 'texture-compression-astc' is both\n  // supported by the device/user agent and enabled in requestDevice.\n\n  ASTC4x4Unorm: 'astc-4x4-unorm',\n  ASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',\n  ASTC5x4Unorm: 'astc-5x4-unorm',\n  ASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',\n  ASTC5x5Unorm: 'astc-5x5-unorm',\n  ASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',\n  ASTC6x5Unorm: 'astc-6x5-unorm',\n  ASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',\n  ASTC6x6Unorm: 'astc-6x6-unorm',\n  ASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',\n  ASTC8x5Unorm: 'astc-8x5-unorm',\n  ASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',\n  ASTC8x6Unorm: 'astc-8x6-unorm',\n  ASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',\n  ASTC8x8Unorm: 'astc-8x8-unorm',\n  ASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',\n  ASTC10x5Unorm: 'astc-10x5-unorm',\n  ASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',\n  ASTC10x6Unorm: 'astc-10x6-unorm',\n  ASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',\n  ASTC10x8Unorm: 'astc-10x8-unorm',\n  ASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',\n  ASTC10x10Unorm: 'astc-10x10-unorm',\n  ASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',\n  ASTC12x10Unorm: 'astc-12x10-unorm',\n  ASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',\n  ASTC12x12Unorm: 'astc-12x12-unorm',\n  ASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb'\n};\nconst GPUAddressMode = {\n  ClampToEdge: 'clamp-to-edge',\n  Repeat: 'repeat',\n  MirrorRepeat: 'mirror-repeat'\n};\nconst GPUFilterMode = {\n  Linear: 'linear',\n  Nearest: 'nearest'\n};\nconst GPUBlendFactor = {\n  Zero: 'zero',\n  One: 'one',\n  Src: 'src',\n  OneMinusSrc: 'one-minus-src',\n  SrcAlpha: 'src-alpha',\n  OneMinusSrcAlpha: 'one-minus-src-alpha',\n  Dst: 'dst',\n  OneMinusDstColor: 'one-minus-dst',\n  DstAlpha: 'dst-alpha',\n  OneMinusDstAlpha: 'one-minus-dst-alpha',\n  SrcAlphaSaturated: 'src-alpha-saturated',\n  Constant: 'constant',\n  OneMinusConstant: 'one-minus-constant'\n};\nconst GPUBlendOperation = {\n  Add: 'add',\n  Subtract: 'subtract',\n  ReverseSubtract: 'reverse-subtract',\n  Min: 'min',\n  Max: 'max'\n};\nconst GPUColorWriteFlags = {\n  None: 0,\n  Red: 0x1,\n  Green: 0x2,\n  Blue: 0x4,\n  Alpha: 0x8,\n  All: 0xF\n};\nconst GPUStencilOperation = {\n  Keep: 'keep',\n  Zero: 'zero',\n  Replace: 'replace',\n  Invert: 'invert',\n  IncrementClamp: 'increment-clamp',\n  DecrementClamp: 'decrement-clamp',\n  IncrementWrap: 'increment-wrap',\n  DecrementWrap: 'decrement-wrap'\n};\nconst GPUBufferBindingType = {\n  Uniform: 'uniform',\n  Storage: 'storage',\n  ReadOnlyStorage: 'read-only-storage'\n};\nconst GPUStorageTextureAccess = {\n  WriteOnly: 'write-only',\n  ReadOnly: 'read-only',\n  ReadWrite: 'read-write'\n};\nconst GPUTextureSampleType = {\n  Float: 'float',\n  UnfilterableFloat: 'unfilterable-float',\n  Depth: 'depth',\n  SInt: 'sint',\n  UInt: 'uint'\n};\nconst GPUTextureDimension = {\n  OneD: '1d',\n  TwoD: '2d',\n  ThreeD: '3d'\n};\nconst GPUTextureViewDimension = {\n  OneD: '1d',\n  TwoD: '2d',\n  TwoDArray: '2d-array',\n  Cube: 'cube',\n  CubeArray: 'cube-array',\n  ThreeD: '3d'\n};\nconst GPUTextureAspect = {\n  All: 'all',\n  StencilOnly: 'stencil-only',\n  DepthOnly: 'depth-only'\n};\nconst GPUInputStepMode = {\n  Vertex: 'vertex',\n  Instance: 'instance'\n};\nconst GPUFeatureName = {\n  DepthClipControl: 'depth-clip-control',\n  Depth32FloatStencil8: 'depth32float-stencil8',\n  TextureCompressionBC: 'texture-compression-bc',\n  TextureCompressionETC2: 'texture-compression-etc2',\n  TextureCompressionASTC: 'texture-compression-astc',\n  TimestampQuery: 'timestamp-query',\n  IndirectFirstInstance: 'indirect-first-instance',\n  ShaderF16: 'shader-f16',\n  RG11B10UFloat: 'rg11b10ufloat-renderable',\n  BGRA8UNormStorage: 'bgra8unorm-storage',\n  Float32Filterable: 'float32-filterable',\n  ClipDistances: 'clip-distances',\n  DualSourceBlending: 'dual-source-blending',\n  Subgroups: 'subgroups'\n};\nclass Sampler extends Binding {\n  constructor(name, texture) {\n    super(name);\n    this.texture = texture;\n    this.version = texture ? texture.version : 0;\n    this.isSampler = true;\n  }\n}\nclass NodeSampler extends Sampler {\n  constructor(name, textureNode, groupNode) {\n    super(name, textureNode ? textureNode.value : null);\n    this.textureNode = textureNode;\n    this.groupNode = groupNode;\n  }\n  update() {\n    this.texture = this.textureNode.value;\n  }\n}\nclass StorageBuffer extends Buffer {\n  constructor(name, attribute) {\n    super(name, attribute ? attribute.array : null);\n    this.attribute = attribute;\n    this.isStorageBuffer = true;\n  }\n}\nlet _id = 0;\nclass NodeStorageBuffer extends StorageBuffer {\n  constructor(nodeUniform, groupNode) {\n    super('StorageBuffer_' + _id++, nodeUniform ? nodeUniform.value : null);\n    this.nodeUniform = nodeUniform;\n    this.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;\n    this.groupNode = groupNode;\n  }\n  get buffer() {\n    return this.nodeUniform.value;\n  }\n}\nclass WebGPUTexturePassUtils extends DataMap {\n  constructor(device) {\n    super();\n    this.device = device;\n    const mipmapVertexSource = `\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n`;\n    const mipmapFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n`;\n    const flipYFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );\n\n}\n`;\n    this.mipmapSampler = device.createSampler({\n      minFilter: GPUFilterMode.Linear\n    });\n    this.flipYSampler = device.createSampler({\n      minFilter: GPUFilterMode.Nearest\n    }); //@TODO?: Consider using textureLoad()\n\n    // We'll need a new pipeline for every texture format used.\n    this.transferPipelines = {};\n    this.flipYPipelines = {};\n    this.mipmapVertexShaderModule = device.createShaderModule({\n      label: 'mipmapVertex',\n      code: mipmapVertexSource\n    });\n    this.mipmapFragmentShaderModule = device.createShaderModule({\n      label: 'mipmapFragment',\n      code: mipmapFragmentSource\n    });\n    this.flipYFragmentShaderModule = device.createShaderModule({\n      label: 'flipYFragment',\n      code: flipYFragmentSource\n    });\n  }\n  getTransferPipeline(format) {\n    let pipeline = this.transferPipelines[format];\n    if (pipeline === undefined) {\n      pipeline = this.device.createRenderPipeline({\n        label: `mipmap-${format}`,\n        vertex: {\n          module: this.mipmapVertexShaderModule,\n          entryPoint: 'main'\n        },\n        fragment: {\n          module: this.mipmapFragmentShaderModule,\n          entryPoint: 'main',\n          targets: [{\n            format\n          }]\n        },\n        primitive: {\n          topology: GPUPrimitiveTopology.TriangleStrip,\n          stripIndexFormat: GPUIndexFormat.Uint32\n        },\n        layout: 'auto'\n      });\n      this.transferPipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  getFlipYPipeline(format) {\n    let pipeline = this.flipYPipelines[format];\n    if (pipeline === undefined) {\n      pipeline = this.device.createRenderPipeline({\n        label: `flipY-${format}`,\n        vertex: {\n          module: this.mipmapVertexShaderModule,\n          entryPoint: 'main'\n        },\n        fragment: {\n          module: this.flipYFragmentShaderModule,\n          entryPoint: 'main',\n          targets: [{\n            format\n          }]\n        },\n        primitive: {\n          topology: GPUPrimitiveTopology.TriangleStrip,\n          stripIndexFormat: GPUIndexFormat.Uint32\n        },\n        layout: 'auto'\n      });\n      this.flipYPipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  flipY(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {\n    const format = textureGPUDescriptor.format;\n    const {\n      width,\n      height\n    } = textureGPUDescriptor.size;\n    const transferPipeline = this.getTransferPipeline(format);\n    const flipYPipeline = this.getFlipYPipeline(format);\n    const tempTexture = this.device.createTexture({\n      size: {\n        width,\n        height,\n        depthOrArrayLayers: 1\n      },\n      format,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n    });\n    const srcView = textureGPU.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n      dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer\n    });\n    const dstView = tempTexture.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n      dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer: 0\n    });\n    const commandEncoder = this.device.createCommandEncoder({});\n    const pass = (pipeline, sourceView, destinationView) => {\n      const bindGroupLayout = pipeline.getBindGroupLayout(0); // @TODO: Consider making this static.\n\n      const bindGroup = this.device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [{\n          binding: 0,\n          resource: this.flipYSampler\n        }, {\n          binding: 1,\n          resource: sourceView\n        }]\n      });\n      const passEncoder = commandEncoder.beginRenderPass({\n        colorAttachments: [{\n          view: destinationView,\n          loadOp: GPULoadOp.Clear,\n          storeOp: GPUStoreOp.Store,\n          clearValue: [0, 0, 0, 0]\n        }]\n      });\n      passEncoder.setPipeline(pipeline);\n      passEncoder.setBindGroup(0, bindGroup);\n      passEncoder.draw(4, 1, 0, 0);\n      passEncoder.end();\n    };\n    pass(transferPipeline, srcView, dstView);\n    pass(flipYPipeline, dstView, srcView);\n    this.device.queue.submit([commandEncoder.finish()]);\n    tempTexture.destroy();\n  }\n  generateMipmaps(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {\n    const textureData = this.get(textureGPU);\n    if (textureData.useCount === undefined) {\n      textureData.useCount = 0;\n      textureData.layers = [];\n    }\n    const passes = textureData.layers[baseArrayLayer] || this._mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer);\n    const commandEncoder = this.device.createCommandEncoder({});\n    this._mipmapRunBundles(commandEncoder, passes);\n    this.device.queue.submit([commandEncoder.finish()]);\n    if (textureData.useCount !== 0) textureData.layers[baseArrayLayer] = passes;\n    textureData.useCount++;\n  }\n  _mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer) {\n    const pipeline = this.getTransferPipeline(textureGPUDescriptor.format);\n    const bindGroupLayout = pipeline.getBindGroupLayout(0); // @TODO: Consider making this static.\n\n    let srcView = textureGPU.createView({\n      baseMipLevel: 0,\n      mipLevelCount: 1,\n      dimension: GPUTextureViewDimension.TwoD,\n      baseArrayLayer\n    });\n    const passes = [];\n    for (let i = 1; i < textureGPUDescriptor.mipLevelCount; i++) {\n      const bindGroup = this.device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [{\n          binding: 0,\n          resource: this.mipmapSampler\n        }, {\n          binding: 1,\n          resource: srcView\n        }]\n      });\n      const dstView = textureGPU.createView({\n        baseMipLevel: i,\n        mipLevelCount: 1,\n        dimension: GPUTextureViewDimension.TwoD,\n        baseArrayLayer\n      });\n      const passDescriptor = {\n        colorAttachments: [{\n          view: dstView,\n          loadOp: GPULoadOp.Clear,\n          storeOp: GPUStoreOp.Store,\n          clearValue: [0, 0, 0, 0]\n        }]\n      };\n      const passEncoder = this.device.createRenderBundleEncoder({\n        colorFormats: [textureGPUDescriptor.format]\n      });\n      passEncoder.setPipeline(pipeline);\n      passEncoder.setBindGroup(0, bindGroup);\n      passEncoder.draw(4, 1, 0, 0);\n      passes.push({\n        renderBundles: [passEncoder.finish()],\n        passDescriptor\n      });\n      srcView = dstView;\n    }\n    return passes;\n  }\n  _mipmapRunBundles(commandEncoder, passes) {\n    const levels = passes.length;\n    for (let i = 0; i < levels; i++) {\n      const pass = passes[i];\n      const passEncoder = commandEncoder.beginRenderPass(pass.passDescriptor);\n      passEncoder.executeBundles(pass.renderBundles);\n      passEncoder.end();\n    }\n  }\n}\nconst _compareToWebGPU = {\n  [NeverCompare]: 'never',\n  [LessCompare]: 'less',\n  [EqualCompare]: 'equal',\n  [LessEqualCompare]: 'less-equal',\n  [GreaterCompare]: 'greater',\n  [GreaterEqualCompare]: 'greater-equal',\n  [AlwaysCompare]: 'always',\n  [NotEqualCompare]: 'not-equal'\n};\nconst _flipMap = [0, 1, 3, 2, 4, 5];\nclass WebGPUTextureUtils {\n  constructor(backend) {\n    this.backend = backend;\n    this._passUtils = null;\n    this.defaultTexture = {};\n    this.defaultCubeTexture = {};\n    this.defaultVideoFrame = null;\n    this.colorBuffer = null;\n    this.depthTexture = new DepthTexture();\n    this.depthTexture.name = 'depthBuffer';\n  }\n  createSampler(texture) {\n    const backend = this.backend;\n    const device = backend.device;\n    const textureGPU = backend.get(texture);\n    const samplerDescriptorGPU = {\n      addressModeU: this._convertAddressMode(texture.wrapS),\n      addressModeV: this._convertAddressMode(texture.wrapT),\n      addressModeW: this._convertAddressMode(texture.wrapR),\n      magFilter: this._convertFilterMode(texture.magFilter),\n      minFilter: this._convertFilterMode(texture.minFilter),\n      mipmapFilter: this._convertFilterMode(texture.minFilter),\n      maxAnisotropy: 1\n    };\n\n    // anisotropy can only be used when all filter modes are set to linear.\n\n    if (samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear) {\n      samplerDescriptorGPU.maxAnisotropy = texture.anisotropy;\n    }\n    if (texture.isDepthTexture && texture.compareFunction !== null) {\n      samplerDescriptorGPU.compare = _compareToWebGPU[texture.compareFunction];\n    }\n    textureGPU.sampler = device.createSampler(samplerDescriptorGPU);\n  }\n  createDefaultTexture(texture) {\n    let textureGPU;\n    const format = getFormat(texture);\n    if (texture.isCubeTexture) {\n      textureGPU = this._getDefaultCubeTextureGPU(format);\n    } else if (texture.isVideoTexture) {\n      this.backend.get(texture).externalTexture = this._getDefaultVideoFrame();\n    } else {\n      textureGPU = this._getDefaultTextureGPU(format);\n    }\n    this.backend.get(texture).texture = textureGPU;\n  }\n  createTexture(texture, options = {}) {\n    const backend = this.backend;\n    const textureData = backend.get(texture);\n    if (textureData.initialized) {\n      throw new Error('WebGPUTextureUtils: Texture already initialized.');\n    }\n    if (options.needsMipmaps === undefined) options.needsMipmaps = false;\n    if (options.levels === undefined) options.levels = 1;\n    if (options.depth === undefined) options.depth = 1;\n    const {\n      width,\n      height,\n      depth,\n      levels\n    } = options;\n    if (texture.isFramebufferTexture) {\n      if (options.renderTarget) {\n        options.format = this.backend.utils.getCurrentColorFormat(options.renderTarget);\n      } else {\n        options.format = this.backend.utils.getPreferredCanvasFormat();\n      }\n    }\n    const dimension = this._getDimension(texture);\n    const format = texture.internalFormat || options.format || getFormat(texture, backend.device);\n    textureData.format = format;\n    let sampleCount = options.sampleCount !== undefined ? options.sampleCount : 1;\n    sampleCount = backend.utils.getSampleCount(sampleCount);\n    const primarySampleCount = texture.isRenderTargetTexture && !texture.isMultisampleRenderTargetTexture ? 1 : sampleCount;\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n    if (texture.isStorageTexture === true) {\n      usage |= GPUTextureUsage.STORAGE_BINDING;\n    }\n    if (texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true) {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    }\n    const textureDescriptorGPU = {\n      label: texture.name,\n      size: {\n        width: width,\n        height: height,\n        depthOrArrayLayers: depth\n      },\n      mipLevelCount: levels,\n      sampleCount: primarySampleCount,\n      dimension: dimension,\n      format: format,\n      usage: usage\n    };\n\n    // texture creation\n\n    if (texture.isVideoTexture) {\n      const video = texture.source.data;\n      const videoFrame = new VideoFrame(video);\n      textureDescriptorGPU.size.width = videoFrame.displayWidth;\n      textureDescriptorGPU.size.height = videoFrame.displayHeight;\n      videoFrame.close();\n      textureData.externalTexture = video;\n    } else {\n      if (format === undefined) {\n        console.warn('WebGPURenderer: Texture format not supported.');\n        return this.createDefaultTexture(texture);\n      }\n      textureData.texture = backend.device.createTexture(textureDescriptorGPU);\n    }\n    if (texture.isRenderTargetTexture && sampleCount > 1 && !texture.isMultisampleRenderTargetTexture) {\n      const msaaTextureDescriptorGPU = Object.assign({}, textureDescriptorGPU);\n      msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';\n      msaaTextureDescriptorGPU.sampleCount = sampleCount;\n      textureData.msaaTexture = backend.device.createTexture(msaaTextureDescriptorGPU);\n    }\n    textureData.initialized = true;\n    textureData.textureDescriptorGPU = textureDescriptorGPU;\n  }\n  destroyTexture(texture) {\n    const backend = this.backend;\n    const textureData = backend.get(texture);\n    if (textureData.texture !== undefined) textureData.texture.destroy();\n    if (textureData.msaaTexture !== undefined) textureData.msaaTexture.destroy();\n    backend.delete(texture);\n  }\n  destroySampler(texture) {\n    const backend = this.backend;\n    const textureData = backend.get(texture);\n    delete textureData.sampler;\n  }\n  generateMipmaps(texture) {\n    const textureData = this.backend.get(texture);\n    if (texture.isCubeTexture) {\n      for (let i = 0; i < 6; i++) {\n        this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i);\n      }\n    } else {\n      const depth = texture.image.depth || 1;\n      for (let i = 0; i < depth; i++) {\n        this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i);\n      }\n    }\n  }\n  getColorBuffer() {\n    if (this.colorBuffer) this.colorBuffer.destroy();\n    const backend = this.backend;\n    const {\n      width,\n      height\n    } = backend.getDrawingBufferSize();\n    this.colorBuffer = backend.device.createTexture({\n      label: 'colorBuffer',\n      size: {\n        width: width,\n        height: height,\n        depthOrArrayLayers: 1\n      },\n      sampleCount: backend.utils.getSampleCount(backend.renderer.samples),\n      format: backend.utils.getPreferredCanvasFormat(),\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n    });\n    return this.colorBuffer;\n  }\n  getDepthBuffer(depth = true, stencil = false) {\n    const backend = this.backend;\n    const {\n      width,\n      height\n    } = backend.getDrawingBufferSize();\n    const depthTexture = this.depthTexture;\n    const depthTextureGPU = backend.get(depthTexture).texture;\n    let format, type;\n    if (stencil) {\n      format = DepthStencilFormat;\n      type = UnsignedInt248Type;\n    } else if (depth) {\n      format = DepthFormat;\n      type = UnsignedIntType;\n    }\n    if (depthTextureGPU !== undefined) {\n      if (depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type) {\n        return depthTextureGPU;\n      }\n      this.destroyTexture(depthTexture);\n    }\n    depthTexture.name = 'depthBuffer';\n    depthTexture.format = format;\n    depthTexture.type = type;\n    depthTexture.image.width = width;\n    depthTexture.image.height = height;\n    this.createTexture(depthTexture, {\n      sampleCount: backend.utils.getSampleCount(backend.renderer.samples),\n      width,\n      height\n    });\n    return backend.get(depthTexture).texture;\n  }\n  updateTexture(texture, options) {\n    const textureData = this.backend.get(texture);\n    const {\n      textureDescriptorGPU\n    } = textureData;\n    if (texture.isRenderTargetTexture || textureDescriptorGPU === undefined /* unsupported texture format */) return;\n\n    // transfer texture data\n\n    if (texture.isDataTexture) {\n      this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY);\n    } else if (texture.isDataArrayTexture || texture.isData3DTexture) {\n      for (let i = 0; i < options.image.depth; i++) {\n        this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i);\n      }\n    } else if (texture.isCompressedTexture || texture.isCompressedArrayTexture) {\n      this._copyCompressedBufferToTexture(texture.mipmaps, textureData.texture, textureDescriptorGPU);\n    } else if (texture.isCubeTexture) {\n      this._copyCubeMapToTexture(options.images, textureData.texture, textureDescriptorGPU, texture.flipY);\n    } else if (texture.isVideoTexture) {\n      const video = texture.source.data;\n      textureData.externalTexture = video;\n    } else {\n      this._copyImageToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY);\n    }\n\n    //\n\n    textureData.version = texture.version;\n    if (texture.onUpdate) texture.onUpdate(texture);\n  }\n  async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {\n    const device = this.backend.device;\n    const textureData = this.backend.get(texture);\n    const textureGPU = textureData.texture;\n    const format = textureData.textureDescriptorGPU.format;\n    const bytesPerTexel = this._getBytesPerTexel(format);\n    let bytesPerRow = width * bytesPerTexel;\n    bytesPerRow = Math.ceil(bytesPerRow / 256) * 256; // Align to 256 bytes\n\n    const readBuffer = device.createBuffer({\n      size: width * height * bytesPerTexel,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n    });\n    const encoder = device.createCommandEncoder();\n    encoder.copyTextureToBuffer({\n      texture: textureGPU,\n      origin: {\n        x,\n        y,\n        z: faceIndex\n      }\n    }, {\n      buffer: readBuffer,\n      bytesPerRow: bytesPerRow\n    }, {\n      width: width,\n      height: height\n    });\n    const typedArrayType = this._getTypedArrayType(format);\n    device.queue.submit([encoder.finish()]);\n    await readBuffer.mapAsync(GPUMapMode.READ);\n    const buffer = readBuffer.getMappedRange();\n    return new typedArrayType(buffer);\n  }\n  _isEnvironmentTexture(texture) {\n    const mapping = texture.mapping;\n    return mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping || mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;\n  }\n  _getDefaultTextureGPU(format) {\n    let defaultTexture = this.defaultTexture[format];\n    if (defaultTexture === undefined) {\n      const texture = new Texture();\n      texture.minFilter = NearestFilter;\n      texture.magFilter = NearestFilter;\n      this.createTexture(texture, {\n        width: 1,\n        height: 1,\n        format\n      });\n      this.defaultTexture[format] = defaultTexture = texture;\n    }\n    return this.backend.get(defaultTexture).texture;\n  }\n  _getDefaultCubeTextureGPU(format) {\n    let defaultCubeTexture = this.defaultTexture[format];\n    if (defaultCubeTexture === undefined) {\n      const texture = new CubeTexture();\n      texture.minFilter = NearestFilter;\n      texture.magFilter = NearestFilter;\n      this.createTexture(texture, {\n        width: 1,\n        height: 1,\n        depth: 6\n      });\n      this.defaultCubeTexture[format] = defaultCubeTexture = texture;\n    }\n    return this.backend.get(defaultCubeTexture).texture;\n  }\n  _getDefaultVideoFrame() {\n    let defaultVideoFrame = this.defaultVideoFrame;\n    if (defaultVideoFrame === null) {\n      const init = {\n        timestamp: 0,\n        codedWidth: 1,\n        codedHeight: 1,\n        format: 'RGBA'\n      };\n      this.defaultVideoFrame = defaultVideoFrame = new VideoFrame(new Uint8Array([0, 0, 0, 0xff]), init);\n    }\n    return defaultVideoFrame;\n  }\n  _copyCubeMapToTexture(images, textureGPU, textureDescriptorGPU, flipY) {\n    for (let i = 0; i < 6; i++) {\n      const image = images[i];\n      const flipIndex = flipY === true ? _flipMap[i] : i;\n      if (image.isDataTexture) {\n        this._copyBufferToTexture(image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY);\n      } else {\n        this._copyImageToTexture(image, textureGPU, textureDescriptorGPU, flipIndex, flipY);\n      }\n    }\n  }\n  _copyImageToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY) {\n    const device = this.backend.device;\n    device.queue.copyExternalImageToTexture({\n      source: image\n    }, {\n      texture: textureGPU,\n      mipLevel: 0,\n      origin: {\n        x: 0,\n        y: 0,\n        z: originDepth\n      }\n    }, {\n      width: image.width,\n      height: image.height,\n      depthOrArrayLayers: 1\n    });\n    if (flipY === true) {\n      this._flipY(textureGPU, textureDescriptorGPU, originDepth);\n    }\n  }\n  _getPassUtils() {\n    let passUtils = this._passUtils;\n    if (passUtils === null) {\n      this._passUtils = passUtils = new WebGPUTexturePassUtils(this.backend.device);\n    }\n    return passUtils;\n  }\n  _generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer = 0) {\n    this._getPassUtils().generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer);\n  }\n  _flipY(textureGPU, textureDescriptorGPU, originDepth = 0) {\n    this._getPassUtils().flipY(textureGPU, textureDescriptorGPU, originDepth);\n  }\n  _copyBufferToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0) {\n    // @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n    // @TODO: Consider to support valid buffer layouts with other formats like RGB\n\n    const device = this.backend.device;\n    const data = image.data;\n    const bytesPerTexel = this._getBytesPerTexel(textureDescriptorGPU.format);\n    const bytesPerRow = image.width * bytesPerTexel;\n    device.queue.writeTexture({\n      texture: textureGPU,\n      mipLevel: 0,\n      origin: {\n        x: 0,\n        y: 0,\n        z: originDepth\n      }\n    }, data, {\n      offset: image.width * image.height * bytesPerTexel * depth,\n      bytesPerRow\n    }, {\n      width: image.width,\n      height: image.height,\n      depthOrArrayLayers: 1\n    });\n    if (flipY === true) {\n      this._flipY(textureGPU, textureDescriptorGPU, originDepth);\n    }\n  }\n  _copyCompressedBufferToTexture(mipmaps, textureGPU, textureDescriptorGPU) {\n    // @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\n    const device = this.backend.device;\n    const blockData = this._getBlockData(textureDescriptorGPU.format);\n    const isTextureArray = textureDescriptorGPU.size.depthOrArrayLayers > 1;\n    for (let i = 0; i < mipmaps.length; i++) {\n      const mipmap = mipmaps[i];\n      const width = mipmap.width;\n      const height = mipmap.height;\n      const depth = isTextureArray ? textureDescriptorGPU.size.depthOrArrayLayers : 1;\n      const bytesPerRow = Math.ceil(width / blockData.width) * blockData.byteLength;\n      const bytesPerImage = bytesPerRow * Math.ceil(height / blockData.height);\n      for (let j = 0; j < depth; j++) {\n        device.queue.writeTexture({\n          texture: textureGPU,\n          mipLevel: i,\n          origin: {\n            x: 0,\n            y: 0,\n            z: j\n          }\n        }, mipmap.data, {\n          offset: j * bytesPerImage,\n          bytesPerRow,\n          rowsPerImage: Math.ceil(height / blockData.height)\n        }, {\n          width: Math.ceil(width / blockData.width) * blockData.width,\n          height: Math.ceil(height / blockData.height) * blockData.height,\n          depthOrArrayLayers: 1\n        });\n      }\n    }\n  }\n  _getBlockData(format) {\n    // this method is only relevant for compressed texture formats\n\n    if (format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    }; // DXT1\n    if (format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // DXT3\n    if (format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // DXT5\n    if (format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    }; // RGTC1\n    if (format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // RGTC2\n    if (format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // BPTC (float)\n    if (format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    }; // BPTC (unorm)\n\n    if (format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACR11Unorm) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACR11Snorm) return {\n      byteLength: 8,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACRG11Unorm) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.EACRG11Snorm) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB) return {\n      byteLength: 16,\n      width: 4,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB) return {\n      byteLength: 16,\n      width: 5,\n      height: 4\n    };\n    if (format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB) return {\n      byteLength: 16,\n      width: 5,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB) return {\n      byteLength: 16,\n      width: 6,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB) return {\n      byteLength: 16,\n      width: 6,\n      height: 6\n    };\n    if (format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB) return {\n      byteLength: 16,\n      width: 8,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB) return {\n      byteLength: 16,\n      width: 8,\n      height: 6\n    };\n    if (format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB) return {\n      byteLength: 16,\n      width: 8,\n      height: 8\n    };\n    if (format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 5\n    };\n    if (format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 6\n    };\n    if (format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 8\n    };\n    if (format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB) return {\n      byteLength: 16,\n      width: 10,\n      height: 10\n    };\n    if (format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB) return {\n      byteLength: 16,\n      width: 12,\n      height: 10\n    };\n    if (format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB) return {\n      byteLength: 16,\n      width: 12,\n      height: 12\n    };\n  }\n  _convertAddressMode(value) {\n    let addressMode = GPUAddressMode.ClampToEdge;\n    if (value === RepeatWrapping) {\n      addressMode = GPUAddressMode.Repeat;\n    } else if (value === MirroredRepeatWrapping) {\n      addressMode = GPUAddressMode.MirrorRepeat;\n    }\n    return addressMode;\n  }\n  _convertFilterMode(value) {\n    let filterMode = GPUFilterMode.Linear;\n    if (value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter) {\n      filterMode = GPUFilterMode.Nearest;\n    }\n    return filterMode;\n  }\n  _getBytesPerTexel(format) {\n    // 8-bit formats\n    if (format === GPUTextureFormat.R8Unorm || format === GPUTextureFormat.R8Snorm || format === GPUTextureFormat.R8Uint || format === GPUTextureFormat.R8Sint) return 1;\n\n    // 16-bit formats\n    if (format === GPUTextureFormat.R16Uint || format === GPUTextureFormat.R16Sint || format === GPUTextureFormat.R16Float || format === GPUTextureFormat.RG8Unorm || format === GPUTextureFormat.RG8Snorm || format === GPUTextureFormat.RG8Uint || format === GPUTextureFormat.RG8Sint) return 2;\n\n    // 32-bit formats\n    if (format === GPUTextureFormat.R32Uint || format === GPUTextureFormat.R32Sint || format === GPUTextureFormat.R32Float || format === GPUTextureFormat.RG16Uint || format === GPUTextureFormat.RG16Sint || format === GPUTextureFormat.RG16Float || format === GPUTextureFormat.RGBA8Unorm || format === GPUTextureFormat.RGBA8UnormSRGB || format === GPUTextureFormat.RGBA8Snorm || format === GPUTextureFormat.RGBA8Uint || format === GPUTextureFormat.RGBA8Sint || format === GPUTextureFormat.BGRA8Unorm || format === GPUTextureFormat.BGRA8UnormSRGB ||\n    // Packed 32-bit formats\n    format === GPUTextureFormat.RGB9E5UFloat || format === GPUTextureFormat.RGB10A2Unorm || format === GPUTextureFormat.RG11B10UFloat || format === GPUTextureFormat.Depth32Float || format === GPUTextureFormat.Depth24Plus || format === GPUTextureFormat.Depth24PlusStencil8 || format === GPUTextureFormat.Depth32FloatStencil8) return 4;\n\n    // 64-bit formats\n    if (format === GPUTextureFormat.RG32Uint || format === GPUTextureFormat.RG32Sint || format === GPUTextureFormat.RG32Float || format === GPUTextureFormat.RGBA16Uint || format === GPUTextureFormat.RGBA16Sint || format === GPUTextureFormat.RGBA16Float) return 8;\n\n    // 128-bit formats\n    if (format === GPUTextureFormat.RGBA32Uint || format === GPUTextureFormat.RGBA32Sint || format === GPUTextureFormat.RGBA32Float) return 16;\n  }\n  _getTypedArrayType(format) {\n    if (format === GPUTextureFormat.R8Uint) return Uint8Array;\n    if (format === GPUTextureFormat.R8Sint) return Int8Array;\n    if (format === GPUTextureFormat.R8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.R8Snorm) return Int8Array;\n    if (format === GPUTextureFormat.RG8Uint) return Uint8Array;\n    if (format === GPUTextureFormat.RG8Sint) return Int8Array;\n    if (format === GPUTextureFormat.RG8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.RG8Snorm) return Int8Array;\n    if (format === GPUTextureFormat.RGBA8Uint) return Uint8Array;\n    if (format === GPUTextureFormat.RGBA8Sint) return Int8Array;\n    if (format === GPUTextureFormat.RGBA8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.RGBA8Snorm) return Int8Array;\n    if (format === GPUTextureFormat.R16Uint) return Uint16Array;\n    if (format === GPUTextureFormat.R16Sint) return Int16Array;\n    if (format === GPUTextureFormat.RG16Uint) return Uint16Array;\n    if (format === GPUTextureFormat.RG16Sint) return Int16Array;\n    if (format === GPUTextureFormat.RGBA16Uint) return Uint16Array;\n    if (format === GPUTextureFormat.RGBA16Sint) return Int16Array;\n    if (format === GPUTextureFormat.R16Float) return Uint16Array;\n    if (format === GPUTextureFormat.RG16Float) return Uint16Array;\n    if (format === GPUTextureFormat.RGBA16Float) return Uint16Array;\n    if (format === GPUTextureFormat.R32Uint) return Uint32Array;\n    if (format === GPUTextureFormat.R32Sint) return Int32Array;\n    if (format === GPUTextureFormat.R32Float) return Float32Array;\n    if (format === GPUTextureFormat.RG32Uint) return Uint32Array;\n    if (format === GPUTextureFormat.RG32Sint) return Int32Array;\n    if (format === GPUTextureFormat.RG32Float) return Float32Array;\n    if (format === GPUTextureFormat.RGBA32Uint) return Uint32Array;\n    if (format === GPUTextureFormat.RGBA32Sint) return Int32Array;\n    if (format === GPUTextureFormat.RGBA32Float) return Float32Array;\n    if (format === GPUTextureFormat.BGRA8Unorm) return Uint8Array;\n    if (format === GPUTextureFormat.BGRA8UnormSRGB) return Uint8Array;\n    if (format === GPUTextureFormat.RGB10A2Unorm) return Uint32Array;\n    if (format === GPUTextureFormat.RGB9E5UFloat) return Uint32Array;\n    if (format === GPUTextureFormat.RG11B10UFloat) return Uint32Array;\n    if (format === GPUTextureFormat.Depth32Float) return Float32Array;\n    if (format === GPUTextureFormat.Depth24Plus) return Uint32Array;\n    if (format === GPUTextureFormat.Depth24PlusStencil8) return Uint32Array;\n    if (format === GPUTextureFormat.Depth32FloatStencil8) return Float32Array;\n  }\n  _getDimension(texture) {\n    let dimension;\n    if (texture.isData3DTexture) {\n      dimension = GPUTextureDimension.ThreeD;\n    } else {\n      dimension = GPUTextureDimension.TwoD;\n    }\n    return dimension;\n  }\n}\nfunction getFormat(texture, device = null) {\n  const format = texture.format;\n  const type = texture.type;\n  const colorSpace = texture.colorSpace;\n  let formatGPU;\n  if (texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true) {\n    switch (format) {\n      case RGBA_S3TC_DXT1_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;\n        break;\n      case RGBA_S3TC_DXT3_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;\n        break;\n      case RGBA_S3TC_DXT5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;\n        break;\n      case RGB_ETC2_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;\n        break;\n      case RGBA_ETC2_EAC_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;\n        break;\n      case RGBA_ASTC_4x4_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;\n        break;\n      case RGBA_ASTC_5x4_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;\n        break;\n      case RGBA_ASTC_5x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;\n        break;\n      case RGBA_ASTC_6x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;\n        break;\n      case RGBA_ASTC_6x6_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;\n        break;\n      case RGBA_ASTC_8x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;\n        break;\n      case RGBA_ASTC_8x6_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;\n        break;\n      case RGBA_ASTC_8x8_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;\n        break;\n      case RGBA_ASTC_10x5_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;\n        break;\n      case RGBA_ASTC_10x6_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;\n        break;\n      case RGBA_ASTC_10x8_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;\n        break;\n      case RGBA_ASTC_10x10_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;\n        break;\n      case RGBA_ASTC_12x10_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;\n        break;\n      case RGBA_ASTC_12x12_Format:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;\n        break;\n      case RGBAFormat:\n        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n        break;\n      default:\n        console.error('WebGPURenderer: Unsupported texture format.', format);\n    }\n  } else {\n    switch (format) {\n      case RGBAFormat:\n        switch (type) {\n          case ByteType:\n            formatGPU = GPUTextureFormat.RGBA8Snorm;\n            break;\n          case ShortType:\n            formatGPU = GPUTextureFormat.RGBA16Sint;\n            break;\n          case UnsignedShortType:\n            formatGPU = GPUTextureFormat.RGBA16Uint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.RGBA32Uint;\n            break;\n          case IntType:\n            formatGPU = GPUTextureFormat.RGBA32Sint;\n            break;\n          case UnsignedByteType:\n            formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n            break;\n          case HalfFloatType:\n            formatGPU = GPUTextureFormat.RGBA16Float;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.RGBA32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGBAFormat.', type);\n        }\n        break;\n      case RGBFormat:\n        switch (type) {\n          case UnsignedInt5999Type:\n            formatGPU = GPUTextureFormat.RGB9E5UFloat;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGBFormat.', type);\n        }\n        break;\n      case RedFormat:\n        switch (type) {\n          case ByteType:\n            formatGPU = GPUTextureFormat.R8Snorm;\n            break;\n          case ShortType:\n            formatGPU = GPUTextureFormat.R16Sint;\n            break;\n          case UnsignedShortType:\n            formatGPU = GPUTextureFormat.R16Uint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.R32Uint;\n            break;\n          case IntType:\n            formatGPU = GPUTextureFormat.R32Sint;\n            break;\n          case UnsignedByteType:\n            formatGPU = GPUTextureFormat.R8Unorm;\n            break;\n          case HalfFloatType:\n            formatGPU = GPUTextureFormat.R16Float;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.R32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RedFormat.', type);\n        }\n        break;\n      case RGFormat:\n        switch (type) {\n          case ByteType:\n            formatGPU = GPUTextureFormat.RG8Snorm;\n            break;\n          case ShortType:\n            formatGPU = GPUTextureFormat.RG16Sint;\n            break;\n          case UnsignedShortType:\n            formatGPU = GPUTextureFormat.RG16Uint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.RG32Uint;\n            break;\n          case IntType:\n            formatGPU = GPUTextureFormat.RG32Sint;\n            break;\n          case UnsignedByteType:\n            formatGPU = GPUTextureFormat.RG8Unorm;\n            break;\n          case HalfFloatType:\n            formatGPU = GPUTextureFormat.RG16Float;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.RG32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGFormat.', type);\n        }\n        break;\n      case DepthFormat:\n        switch (type) {\n          case UnsignedShortType:\n            formatGPU = GPUTextureFormat.Depth16Unorm;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.Depth24Plus;\n            break;\n          case FloatType:\n            formatGPU = GPUTextureFormat.Depth32Float;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with DepthFormat.', type);\n        }\n        break;\n      case DepthStencilFormat:\n        switch (type) {\n          case UnsignedInt248Type:\n            formatGPU = GPUTextureFormat.Depth24PlusStencil8;\n            break;\n          case FloatType:\n            if (device && device.features.has(GPUFeatureName.Depth32FloatStencil8) === false) {\n              console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the \"depth32float-stencil8\" GPU feature.');\n            }\n            formatGPU = GPUTextureFormat.Depth32FloatStencil8;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type);\n        }\n        break;\n      case RedIntegerFormat:\n        switch (type) {\n          case IntType:\n            formatGPU = GPUTextureFormat.R32Sint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.R32Uint;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type);\n        }\n        break;\n      case RGIntegerFormat:\n        switch (type) {\n          case IntType:\n            formatGPU = GPUTextureFormat.RG32Sint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.RG32Uint;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type);\n        }\n        break;\n      case RGBAIntegerFormat:\n        switch (type) {\n          case IntType:\n            formatGPU = GPUTextureFormat.RGBA32Sint;\n            break;\n          case UnsignedIntType:\n            formatGPU = GPUTextureFormat.RGBA32Uint;\n            break;\n          default:\n            console.error('WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type);\n        }\n        break;\n      default:\n        console.error('WebGPURenderer: Unsupported texture format.', format);\n    }\n  }\n  return formatGPU;\n}\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/i;\nconst propertiesRegexp = /([a-z_0-9]+)\\s*:\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/ig;\nconst wgslTypeLib$1 = {\n  'f32': 'float',\n  'i32': 'int',\n  'u32': 'uint',\n  'bool': 'bool',\n  'vec2<f32>': 'vec2',\n  'vec2<i32>': 'ivec2',\n  'vec2<u32>': 'uvec2',\n  'vec2<bool>': 'bvec2',\n  'vec2f': 'vec2',\n  'vec2i': 'ivec2',\n  'vec2u': 'uvec2',\n  'vec2b': 'bvec2',\n  'vec3<f32>': 'vec3',\n  'vec3<i32>': 'ivec3',\n  'vec3<u32>': 'uvec3',\n  'vec3<bool>': 'bvec3',\n  'vec3f': 'vec3',\n  'vec3i': 'ivec3',\n  'vec3u': 'uvec3',\n  'vec3b': 'bvec3',\n  'vec4<f32>': 'vec4',\n  'vec4<i32>': 'ivec4',\n  'vec4<u32>': 'uvec4',\n  'vec4<bool>': 'bvec4',\n  'vec4f': 'vec4',\n  'vec4i': 'ivec4',\n  'vec4u': 'uvec4',\n  'vec4b': 'bvec4',\n  'mat2x2<f32>': 'mat2',\n  'mat2x2f': 'mat2',\n  'mat3x3<f32>': 'mat3',\n  'mat3x3f': 'mat3',\n  'mat4x4<f32>': 'mat4',\n  'mat4x4f': 'mat4',\n  'sampler': 'sampler',\n  'texture_1d': 'texture',\n  'texture_2d': 'texture',\n  'texture_2d_array': 'texture',\n  'texture_multisampled_2d': 'cubeTexture',\n  'texture_depth_2d': 'depthTexture',\n  'texture_3d': 'texture3D',\n  'texture_cube': 'cubeTexture',\n  'texture_cube_array': 'cubeTexture',\n  'texture_storage_1d': 'storageTexture',\n  'texture_storage_2d': 'storageTexture',\n  'texture_storage_2d_array': 'storageTexture',\n  'texture_storage_3d': 'storageTexture'\n};\nconst parse = source => {\n  source = source.trim();\n  const declaration = source.match(declarationRegexp);\n  if (declaration !== null && declaration.length === 4) {\n    const inputsCode = declaration[2];\n    const propsMatches = [];\n    let match = null;\n    while ((match = propertiesRegexp.exec(inputsCode)) !== null) {\n      propsMatches.push({\n        name: match[1],\n        type: match[2]\n      });\n    }\n\n    // Process matches to correctly pair names and types\n    const inputs = [];\n    for (let i = 0; i < propsMatches.length; i++) {\n      const {\n        name,\n        type\n      } = propsMatches[i];\n      let resolvedType = type;\n      if (resolvedType.startsWith('ptr')) {\n        resolvedType = 'pointer';\n      } else {\n        if (resolvedType.startsWith('texture')) {\n          resolvedType = type.split('<')[0];\n        }\n        resolvedType = wgslTypeLib$1[resolvedType];\n      }\n      inputs.push(new NodeFunctionInput(resolvedType, name));\n    }\n    const blockCode = source.substring(declaration[0].length);\n    const outputType = declaration[3] || 'void';\n    const name = declaration[1] !== undefined ? declaration[1] : '';\n    const type = wgslTypeLib$1[outputType] || outputType;\n    return {\n      type,\n      inputs,\n      name,\n      inputsCode,\n      blockCode,\n      outputType\n    };\n  } else {\n    throw new Error('FunctionNode: Function is not a WGSL code.');\n  }\n};\nclass WGSLNodeFunction extends NodeFunction {\n  constructor(source) {\n    const {\n      type,\n      inputs,\n      name,\n      inputsCode,\n      blockCode,\n      outputType\n    } = parse(source);\n    super(type, inputs, name);\n    this.inputsCode = inputsCode;\n    this.blockCode = blockCode;\n    this.outputType = outputType;\n  }\n  getCode(name = this.name) {\n    const outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';\n    return `fn ${name} ( ${this.inputsCode.trim()} ) ${outputType}` + this.blockCode;\n  }\n}\nclass WGSLNodeParser extends NodeParser {\n  parseFunction(source) {\n    return new WGSLNodeFunction(source);\n  }\n}\n\n// GPUShaderStage is not defined in browsers not supporting WebGPU\nconst GPUShaderStage = typeof self !== 'undefined' ? self.GPUShaderStage : {\n  VERTEX: 1,\n  FRAGMENT: 2,\n  COMPUTE: 4\n};\nconst accessNames = {\n  [NodeAccess.READ_ONLY]: 'read',\n  [NodeAccess.WRITE_ONLY]: 'write',\n  [NodeAccess.READ_WRITE]: 'read_write'\n};\nconst wrapNames = {\n  [RepeatWrapping]: 'repeat',\n  [ClampToEdgeWrapping]: 'clamp',\n  [MirroredRepeatWrapping]: 'mirror'\n};\nconst gpuShaderStageLib = {\n  'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,\n  'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,\n  'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4\n};\nconst supports = {\n  instance: true,\n  swizzleAssign: false,\n  storageBuffer: true\n};\nconst wgslFnOpLib = {\n  '^^': 'tsl_xor'\n};\nconst wgslTypeLib = {\n  float: 'f32',\n  int: 'i32',\n  uint: 'u32',\n  bool: 'bool',\n  color: 'vec3<f32>',\n  vec2: 'vec2<f32>',\n  ivec2: 'vec2<i32>',\n  uvec2: 'vec2<u32>',\n  bvec2: 'vec2<bool>',\n  vec3: 'vec3<f32>',\n  ivec3: 'vec3<i32>',\n  uvec3: 'vec3<u32>',\n  bvec3: 'vec3<bool>',\n  vec4: 'vec4<f32>',\n  ivec4: 'vec4<i32>',\n  uvec4: 'vec4<u32>',\n  bvec4: 'vec4<bool>',\n  mat2: 'mat2x2<f32>',\n  mat3: 'mat3x3<f32>',\n  mat4: 'mat4x4<f32>'\n};\nconst wgslCodeCache = {};\nconst wgslPolyfill = {\n  tsl_xor: new CodeNode('fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }'),\n  mod_float: new CodeNode('fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }'),\n  mod_vec2: new CodeNode('fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }'),\n  mod_vec3: new CodeNode('fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }'),\n  mod_vec4: new CodeNode('fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }'),\n  equals_bool: new CodeNode('fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }'),\n  equals_bvec2: new CodeNode('fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }'),\n  equals_bvec3: new CodeNode('fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }'),\n  equals_bvec4: new CodeNode('fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }'),\n  repeatWrapping_float: new CodeNode('fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }'),\n  mirrorWrapping_float: new CodeNode('fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }'),\n  clampWrapping_float: new CodeNode('fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }'),\n  biquadraticTexture: new CodeNode(/* wgsl */`\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {\n\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n`)\n};\nconst wgslMethods = {\n  dFdx: 'dpdx',\n  dFdy: '- dpdy',\n  mod_float: 'tsl_mod_float',\n  mod_vec2: 'tsl_mod_vec2',\n  mod_vec3: 'tsl_mod_vec3',\n  mod_vec4: 'tsl_mod_vec4',\n  equals_bool: 'tsl_equals_bool',\n  equals_bvec2: 'tsl_equals_bvec2',\n  equals_bvec3: 'tsl_equals_bvec3',\n  equals_bvec4: 'tsl_equals_bvec4',\n  inversesqrt: 'inverseSqrt',\n  bitcast: 'bitcast<f32>'\n};\n\n// WebGPU issue: does not support pow() with negative base on Windows\n\nif (typeof navigator !== 'undefined' && /Windows/g.test(navigator.userAgent)) {\n  wgslPolyfill.pow_float = new CodeNode('fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }');\n  wgslPolyfill.pow_vec2 = new CodeNode('fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [wgslPolyfill.pow_float]);\n  wgslPolyfill.pow_vec3 = new CodeNode('fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [wgslPolyfill.pow_float]);\n  wgslPolyfill.pow_vec4 = new CodeNode('fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [wgslPolyfill.pow_float]);\n  wgslMethods.pow_float = 'tsl_pow_float';\n  wgslMethods.pow_vec2 = 'tsl_pow_vec2';\n  wgslMethods.pow_vec3 = 'tsl_pow_vec3';\n  wgslMethods.pow_vec4 = 'tsl_pow_vec4';\n}\n\n//\n\nlet diagnostics = '';\nif ((typeof navigator !== 'undefined' && /Firefox|Deno/g.test(navigator.userAgent)) !== true) {\n  diagnostics += 'diagnostic( off, derivative_uniformity );\\n';\n}\n\n//\n\nclass WGSLNodeBuilder extends NodeBuilder {\n  constructor(object, renderer) {\n    super(object, renderer, new WGSLNodeParser());\n    this.uniformGroups = {};\n    this.builtins = {};\n    this.directives = {};\n    this.scopedArrays = new Map();\n  }\n  needsToWorkingColorSpace(texture) {\n    return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n  }\n  _generateTextureSample(texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      if (depthSnippet) {\n        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;\n      } else {\n        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;\n      }\n    } else if (this.isFilteredTexture(texture)) {\n      return this.generateFilteredTexture(texture, textureProperty, uvSnippet);\n    } else {\n      return this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, '0');\n    }\n  }\n  _generateVideoSample(textureProperty, uvSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      return `textureSampleBaseClampToEdge( ${textureProperty}, ${textureProperty}_sampler, vec2<f32>( ${uvSnippet}.x, 1.0 - ${uvSnippet}.y ) )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.VideoTexture does not support ${shaderStage} shader.`);\n    }\n  }\n  _generateTextureSampleLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment' && this.isUnfilterable(texture) === false) {\n      return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;\n    } else if (this.isFilteredTexture(texture)) {\n      return this.generateFilteredTexture(texture, textureProperty, uvSnippet, levelSnippet);\n    } else {\n      return this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, levelSnippet);\n    }\n  }\n  generateWrapFunction(texture) {\n    const functionName = `tsl_coord_${wrapNames[texture.wrapS]}S_${wrapNames[texture.wrapT]}T`;\n    let nodeCode = wgslCodeCache[functionName];\n    if (nodeCode === undefined) {\n      const includes = [];\n      let code = `fn ${functionName}( coord : vec2f ) -> vec2f {\\n\\n\\treturn vec2f(\\n`;\n      const addWrapSnippet = (wrap, axis) => {\n        if (wrap === RepeatWrapping) {\n          includes.push(wgslPolyfill.repeatWrapping_float);\n          code += `\\t\\ttsl_repeatWrapping_float( coord.${axis} )`;\n        } else if (wrap === ClampToEdgeWrapping) {\n          includes.push(wgslPolyfill.clampWrapping_float);\n          code += `\\t\\ttsl_clampWrapping_float( coord.${axis} )`;\n        } else if (wrap === MirroredRepeatWrapping) {\n          includes.push(wgslPolyfill.mirrorWrapping_float);\n          code += `\\t\\ttsl_mirrorWrapping_float( coord.${axis} )`;\n        } else {\n          code += `\\t\\tcoord.${axis}`;\n          console.warn(`WebGPURenderer: Unsupported texture wrap type \"${wrap}\" for vertex shader.`);\n        }\n      };\n      addWrapSnippet(texture.wrapS, 'x');\n      code += ',\\n';\n      addWrapSnippet(texture.wrapT, 'y');\n      code += '\\n\\t);\\n\\n}\\n';\n      wgslCodeCache[functionName] = nodeCode = new CodeNode(code, includes);\n    }\n    nodeCode.build(this);\n    return functionName;\n  }\n  generateTextureDimension(texture, textureProperty, levelSnippet) {\n    const textureData = this.getDataFromNode(texture, this.shaderStage, this.globalCache);\n    if (textureData.dimensionsSnippet === undefined) textureData.dimensionsSnippet = {};\n    let textureDimensionNode = textureData.dimensionsSnippet[levelSnippet];\n    if (textureData.dimensionsSnippet[levelSnippet] === undefined) {\n      let textureDimensionsParams;\n      if (texture.isMultisampleRenderTargetTexture === true) {\n        textureDimensionsParams = textureProperty;\n      } else {\n        textureDimensionsParams = `${textureProperty}, u32( ${levelSnippet} )`;\n      }\n      textureDimensionNode = new VarNode(new ExpressionNode(`textureDimensions( ${textureDimensionsParams} )`, 'uvec2'));\n      textureData.dimensionsSnippet[levelSnippet] = textureDimensionNode;\n    }\n    return textureDimensionNode.build(this);\n  }\n  generateFilteredTexture(texture, textureProperty, uvSnippet, levelSnippet = '0u') {\n    this._include('biquadraticTexture');\n    const wrapFunction = this.generateWrapFunction(texture);\n    const textureDimension = this.generateTextureDimension(texture, textureProperty, levelSnippet);\n    return `tsl_biquadraticTexture( ${textureProperty}, ${wrapFunction}( ${uvSnippet} ), ${textureDimension}, u32( ${levelSnippet} ) )`;\n  }\n  generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, levelSnippet = '0u') {\n    const wrapFunction = this.generateWrapFunction(texture);\n    const textureDimension = this.generateTextureDimension(texture, textureProperty, levelSnippet);\n    const coordSnippet = `vec2u( ${wrapFunction}( ${uvSnippet} ) * vec2f( ${textureDimension} ) )`;\n    return this.generateTextureLoad(texture, textureProperty, coordSnippet, depthSnippet, levelSnippet);\n  }\n  generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u') {\n    if (texture.isVideoTexture === true || texture.isStorageTexture === true) {\n      return `textureLoad( ${textureProperty}, ${uvIndexSnippet} )`;\n    } else if (depthSnippet) {\n      return `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, u32( ${levelSnippet} ) )`;\n    } else {\n      return `textureLoad( ${textureProperty}, ${uvIndexSnippet}, u32( ${levelSnippet} ) )`;\n    }\n  }\n  generateTextureStore(texture, textureProperty, uvIndexSnippet, valueSnippet) {\n    return `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${valueSnippet} )`;\n  }\n  isSampleCompare(texture) {\n    return texture.isDepthTexture === true && texture.compareFunction !== null;\n  }\n  isUnfilterable(texture) {\n    return this.getComponentTypeFromTexture(texture) !== 'float' || !this.isAvailable('float32Filterable') && texture.isDataTexture === true && texture.type === FloatType || this.isSampleCompare(texture) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter || texture.isMultisampleRenderTargetTexture === true;\n  }\n  generateTexture(texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    let snippet = null;\n    if (texture.isVideoTexture === true) {\n      snippet = this._generateVideoSample(textureProperty, uvSnippet, shaderStage);\n    } else if (this.isUnfilterable(texture)) {\n      snippet = this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage);\n    } else {\n      snippet = this._generateTextureSample(texture, textureProperty, uvSnippet, depthSnippet, shaderStage);\n    }\n    return snippet;\n  }\n  generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      // TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy\n      return `textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]} )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${shaderStage} shader.`);\n    }\n  }\n  generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);\n    }\n  }\n  generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    let snippet = null;\n    if (texture.isVideoTexture === true) {\n      snippet = this._generateVideoSample(textureProperty, uvSnippet, shaderStage);\n    } else {\n      snippet = this._generateTextureSampleLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage);\n    }\n    return snippet;\n  }\n  generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, shaderStage = this.shaderStage) {\n    if (shaderStage === 'fragment') {\n      return `textureSampleBias( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;\n    } else {\n      console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${shaderStage} shader.`);\n    }\n  }\n  getPropertyName(node, shaderStage = this.shaderStage) {\n    if (node.isNodeVarying === true && node.needsInterpolation === true) {\n      if (shaderStage === 'vertex') {\n        return `varyings.${node.name}`;\n      }\n    } else if (node.isNodeUniform === true) {\n      const name = node.name;\n      const type = node.type;\n      if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') {\n        return name;\n      } else if (type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer') {\n        return `NodeBuffer_${node.id}.${name}`;\n      } else {\n        return node.groupNode.name + '.' + name;\n      }\n    }\n    return super.getPropertyName(node);\n  }\n  getOutputStructName() {\n    return 'output';\n  }\n  _getUniformGroupCount(shaderStage) {\n    return Object.keys(this.uniforms[shaderStage]).length;\n  }\n  getFunctionOperator(op) {\n    const fnOp = wgslFnOpLib[op];\n    if (fnOp !== undefined) {\n      this._include(fnOp);\n      return fnOp;\n    }\n    return null;\n  }\n  getNodeAccess(node, shaderStage) {\n    if (shaderStage !== 'compute') return NodeAccess.READ_ONLY;\n    return node.access;\n  }\n  getStorageAccess(node, shaderStage) {\n    return accessNames[this.getNodeAccess(node, shaderStage)];\n  }\n  getUniformFromNode(node, type, shaderStage, name = null) {\n    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);\n    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);\n    if (nodeData.uniformGPU === undefined) {\n      let uniformGPU;\n      const group = node.groupNode;\n      const groupName = group.name;\n      const bindings = this.getBindGroupArray(groupName, shaderStage);\n      if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') {\n        let texture = null;\n        const access = this.getNodeAccess(node, shaderStage);\n        if (type === 'texture' || type === 'storageTexture') {\n          texture = new NodeSampledTexture(uniformNode.name, uniformNode.node, group, access);\n        } else if (type === 'cubeTexture') {\n          texture = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group, access);\n        } else if (type === 'texture3D') {\n          texture = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group, access);\n        }\n        texture.store = node.isStorageTextureNode === true;\n        texture.setVisibility(gpuShaderStageLib[shaderStage]);\n        if (shaderStage === 'fragment' && this.isUnfilterable(node.value) === false && texture.store === false) {\n          const sampler = new NodeSampler(`${uniformNode.name}_sampler`, uniformNode.node, group);\n          sampler.setVisibility(gpuShaderStageLib[shaderStage]);\n          bindings.push(sampler, texture);\n          uniformGPU = [sampler, texture];\n        } else {\n          bindings.push(texture);\n          uniformGPU = [texture];\n        }\n      } else if (type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer') {\n        const bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;\n        const buffer = new bufferClass(node, group);\n        buffer.setVisibility(gpuShaderStageLib[shaderStage]);\n        bindings.push(buffer);\n        uniformGPU = buffer;\n      } else {\n        const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});\n        let uniformsGroup = uniformsStage[groupName];\n        if (uniformsGroup === undefined) {\n          uniformsGroup = new NodeUniformsGroup(groupName, group);\n          uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]);\n          uniformsStage[groupName] = uniformsGroup;\n          bindings.push(uniformsGroup);\n        }\n        uniformGPU = this.getNodeUniform(uniformNode, type);\n        uniformsGroup.addUniform(uniformGPU);\n      }\n      nodeData.uniformGPU = uniformGPU;\n    }\n    return uniformNode;\n  }\n  getBuiltin(name, property, type, shaderStage = this.shaderStage) {\n    const map = this.builtins[shaderStage] || (this.builtins[shaderStage] = new Map());\n    if (map.has(name) === false) {\n      map.set(name, {\n        name,\n        property,\n        type\n      });\n    }\n    return property;\n  }\n  hasBuiltin(name, shaderStage = this.shaderStage) {\n    return this.builtins[shaderStage] !== undefined && this.builtins[shaderStage].has(name);\n  }\n  getVertexIndex() {\n    if (this.shaderStage === 'vertex') {\n      return this.getBuiltin('vertex_index', 'vertexIndex', 'u32', 'attribute');\n    }\n    return 'vertexIndex';\n  }\n  buildFunctionCode(shaderNode) {\n    const layout = shaderNode.layout;\n    const flowData = this.flowShaderNode(shaderNode);\n    const parameters = [];\n    for (const input of layout.inputs) {\n      parameters.push(input.name + ' : ' + this.getType(input.type));\n    }\n\n    //\n\n    let code = `fn ${layout.name}( ${parameters.join(', ')} ) -> ${this.getType(layout.type)} {\n${flowData.vars}\n${flowData.code}\n`;\n    if (flowData.result) {\n      code += `\\treturn ${flowData.result};\\n`;\n    }\n    code += '\\n}\\n';\n\n    //\n\n    return code;\n  }\n  getInstanceIndex() {\n    if (this.shaderStage === 'vertex') {\n      return this.getBuiltin('instance_index', 'instanceIndex', 'u32', 'attribute');\n    }\n    return 'instanceIndex';\n  }\n  getInvocationLocalIndex() {\n    return this.getBuiltin('local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute');\n  }\n  getSubgroupSize() {\n    this.enableSubGroups();\n    return this.getBuiltin('subgroup_size', 'subgroupSize', 'u32', 'attribute');\n  }\n  getInvocationSubgroupIndex() {\n    this.enableSubGroups();\n    return this.getBuiltin('subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute');\n  }\n  getSubgroupIndex() {\n    this.enableSubGroups();\n    return this.getBuiltin('subgroup_id', 'subgroupIndex', 'u32', 'attribute');\n  }\n  getDrawIndex() {\n    return null;\n  }\n  getFrontFacing() {\n    return this.getBuiltin('front_facing', 'isFront', 'bool');\n  }\n  getFragCoord() {\n    return this.getBuiltin('position', 'fragCoord', 'vec4<f32>') + '.xy';\n  }\n  getFragDepth() {\n    return 'output.' + this.getBuiltin('frag_depth', 'depth', 'f32', 'output');\n  }\n  getClipDistance() {\n    return 'varyings.hw_clip_distances';\n  }\n  isFlipY() {\n    return false;\n  }\n  enableDirective(name, shaderStage = this.shaderStage) {\n    const stage = this.directives[shaderStage] || (this.directives[shaderStage] = new Set());\n    stage.add(name);\n  }\n  getDirectives(shaderStage) {\n    const snippets = [];\n    const directives = this.directives[shaderStage];\n    if (directives !== undefined) {\n      for (const directive of directives) {\n        snippets.push(`enable ${directive};`);\n      }\n    }\n    return snippets.join('\\n');\n  }\n  enableSubGroups() {\n    this.enableDirective('subgroups');\n  }\n  enableSubgroupsF16() {\n    this.enableDirective('subgroups-f16');\n  }\n  enableClipDistances() {\n    this.enableDirective('clip_distances');\n  }\n  enableShaderF16() {\n    this.enableDirective('f16');\n  }\n  enableDualSourceBlending() {\n    this.enableDirective('dual_source_blending');\n  }\n  enableHardwareClipping(planeCount) {\n    this.enableClipDistances();\n    this.getBuiltin('clip_distances', 'hw_clip_distances', `array<f32, ${planeCount} >`, 'vertex');\n  }\n  getBuiltins(shaderStage) {\n    const snippets = [];\n    const builtins = this.builtins[shaderStage];\n    if (builtins !== undefined) {\n      for (const {\n        name,\n        property,\n        type\n      } of builtins.values()) {\n        snippets.push(`@builtin( ${name} ) ${property} : ${type}`);\n      }\n    }\n    return snippets.join(',\\n\\t');\n  }\n  getScopedArray(name, scope, bufferType, bufferCount) {\n    if (this.scopedArrays.has(name) === false) {\n      this.scopedArrays.set(name, {\n        name,\n        scope,\n        bufferType,\n        bufferCount\n      });\n    }\n    return name;\n  }\n  getScopedArrays(shaderStage) {\n    if (shaderStage !== 'compute') {\n      return;\n    }\n    const snippets = [];\n    for (const {\n      name,\n      scope,\n      bufferType,\n      bufferCount\n    } of this.scopedArrays.values()) {\n      const type = this.getType(bufferType);\n      snippets.push(`var<${scope}> ${name}: array< ${type}, ${bufferCount} >;`);\n    }\n    return snippets.join('\\n');\n  }\n  getAttributes(shaderStage) {\n    const snippets = [];\n    if (shaderStage === 'compute') {\n      this.getBuiltin('global_invocation_id', 'id', 'vec3<u32>', 'attribute');\n      this.getBuiltin('workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute');\n      this.getBuiltin('local_invocation_id', 'localId', 'vec3<u32>', 'attribute');\n      this.getBuiltin('num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute');\n      if (this.renderer.hasFeature('subgroups')) {\n        this.enableDirective('subgroups', shaderStage);\n        this.getBuiltin('subgroup_size', 'subgroupSize', 'u32', 'attribute');\n      }\n    }\n    if (shaderStage === 'vertex' || shaderStage === 'compute') {\n      const builtins = this.getBuiltins('attribute');\n      if (builtins) snippets.push(builtins);\n      const attributes = this.getAttributesArray();\n      for (let index = 0, length = attributes.length; index < length; index++) {\n        const attribute = attributes[index];\n        const name = attribute.name;\n        const type = this.getType(attribute.type);\n        snippets.push(`@location( ${index} ) ${name} : ${type}`);\n      }\n    }\n    return snippets.join(',\\n\\t');\n  }\n  getStructMembers(struct) {\n    const snippets = [];\n    const members = struct.getMemberTypes();\n    for (let i = 0; i < members.length; i++) {\n      const member = members[i];\n      snippets.push(`\\t@location( ${i} ) m${i} : ${member}<f32>`);\n    }\n    const builtins = this.getBuiltins('output');\n    if (builtins) snippets.push('\\t' + builtins);\n    return snippets.join(',\\n');\n  }\n  getStructs(shaderStage) {\n    const snippets = [];\n    const structs = this.structs[shaderStage];\n    for (let index = 0, length = structs.length; index < length; index++) {\n      const struct = structs[index];\n      const name = struct.name;\n      let snippet = `\\struct ${name} {\\n`;\n      snippet += this.getStructMembers(struct);\n      snippet += '\\n}';\n      snippets.push(snippet);\n      snippets.push(`\\nvar<private> output : ${name};\\n\\n`);\n    }\n    return snippets.join('\\n\\n');\n  }\n  getVar(type, name) {\n    return `var ${name} : ${this.getType(type)}`;\n  }\n  getVars(shaderStage) {\n    const snippets = [];\n    const vars = this.vars[shaderStage];\n    if (vars !== undefined) {\n      for (const variable of vars) {\n        snippets.push(`\\t${this.getVar(variable.type, variable.name)};`);\n      }\n    }\n    return `\\n${snippets.join('\\n')}\\n`;\n  }\n  getVaryings(shaderStage) {\n    const snippets = [];\n    if (shaderStage === 'vertex') {\n      this.getBuiltin('position', 'Vertex', 'vec4<f32>', 'vertex');\n    }\n    if (shaderStage === 'vertex' || shaderStage === 'fragment') {\n      const varyings = this.varyings;\n      const vars = this.vars[shaderStage];\n      for (let index = 0; index < varyings.length; index++) {\n        const varying = varyings[index];\n        if (varying.needsInterpolation) {\n          let attributesSnippet = `@location( ${index} )`;\n          if (/^(int|uint|ivec|uvec)/.test(varying.type)) {\n            attributesSnippet += ' @interpolate( flat )';\n          }\n          snippets.push(`${attributesSnippet} ${varying.name} : ${this.getType(varying.type)}`);\n        } else if (shaderStage === 'vertex' && vars.includes(varying) === false) {\n          vars.push(varying);\n        }\n      }\n    }\n    const builtins = this.getBuiltins(shaderStage);\n    if (builtins) snippets.push(builtins);\n    const code = snippets.join(',\\n\\t');\n    return shaderStage === 'vertex' ? this._getWGSLStruct('VaryingsStruct', '\\t' + code) : code;\n  }\n  getUniforms(shaderStage) {\n    const uniforms = this.uniforms[shaderStage];\n    const bindingSnippets = [];\n    const bufferSnippets = [];\n    const structSnippets = [];\n    const uniformGroups = {};\n    for (const uniform of uniforms) {\n      const groupName = uniform.groupNode.name;\n      const uniformIndexes = this.bindingsIndexes[groupName];\n      if (uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D') {\n        const texture = uniform.node.value;\n        if (shaderStage === 'fragment' && this.isUnfilterable(texture) === false && uniform.node.isStorageTextureNode !== true) {\n          if (this.isSampleCompare(texture)) {\n            bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name}_sampler : sampler_comparison;`);\n          } else {\n            bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name}_sampler : sampler;`);\n          }\n        }\n        let textureType;\n        let multisampled = '';\n        if (texture.isMultisampleRenderTargetTexture === true) {\n          multisampled = '_multisampled';\n        }\n        if (texture.isCubeTexture === true) {\n          textureType = 'texture_cube<f32>';\n        } else if (texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true) {\n          textureType = 'texture_2d_array<f32>';\n        } else if (texture.isDepthTexture === true) {\n          textureType = `texture_depth${multisampled}_2d`;\n        } else if (texture.isVideoTexture === true) {\n          textureType = 'texture_external';\n        } else if (texture.isData3DTexture === true) {\n          textureType = 'texture_3d<f32>';\n        } else if (uniform.node.isStorageTextureNode === true) {\n          const format = getFormat(texture);\n          const access = this.getStorageAccess(uniform.node, shaderStage);\n          textureType = `texture_storage_2d<${format}, ${access}>`;\n        } else {\n          const componentPrefix = this.getComponentTypeFromTexture(texture).charAt(0);\n          textureType = `texture${multisampled}_2d<${componentPrefix}32>`;\n        }\n        bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name} : ${textureType};`);\n      } else if (uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer') {\n        const bufferNode = uniform.node;\n        const bufferType = this.getType(bufferNode.bufferType);\n        const bufferCount = bufferNode.bufferCount;\n        const bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';\n        const bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`;\n        const bufferSnippet = `\\t${uniform.name} : array< ${bufferTypeSnippet}${bufferCountSnippet} >\\n`;\n        const bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${this.getStorageAccess(bufferNode, shaderStage)}` : 'uniform';\n        bufferSnippets.push(this._getWGSLStructBinding('NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, uniformIndexes.binding++, uniformIndexes.group));\n      } else {\n        const vectorType = this.getType(this.getVectorType(uniform.type));\n        const groupName = uniform.groupNode.name;\n        const group = uniformGroups[groupName] || (uniformGroups[groupName] = {\n          index: uniformIndexes.binding++,\n          id: uniformIndexes.group,\n          snippets: []\n        });\n        group.snippets.push(`\\t${uniform.name} : ${vectorType}`);\n      }\n    }\n    for (const name in uniformGroups) {\n      const group = uniformGroups[name];\n      structSnippets.push(this._getWGSLStructBinding(name, group.snippets.join(',\\n'), 'uniform', group.index, group.id));\n    }\n    let code = bindingSnippets.join('\\n');\n    code += bufferSnippets.join('\\n');\n    code += structSnippets.join('\\n');\n    return code;\n  }\n  buildCode() {\n    const shadersData = this.material !== null ? {\n      fragment: {},\n      vertex: {}\n    } : {\n      compute: {}\n    };\n    this.sortBindingGroups();\n    for (const shaderStage in shadersData) {\n      const stageData = shadersData[shaderStage];\n      stageData.uniforms = this.getUniforms(shaderStage);\n      stageData.attributes = this.getAttributes(shaderStage);\n      stageData.varyings = this.getVaryings(shaderStage);\n      stageData.structs = this.getStructs(shaderStage);\n      stageData.vars = this.getVars(shaderStage);\n      stageData.codes = this.getCodes(shaderStage);\n      stageData.directives = this.getDirectives(shaderStage);\n      stageData.scopedArrays = this.getScopedArrays(shaderStage);\n\n      //\n\n      let flow = '// code\\n\\n';\n      flow += this.flowCode[shaderStage];\n      const flowNodes = this.flowNodes[shaderStage];\n      const mainNode = flowNodes[flowNodes.length - 1];\n      const outputNode = mainNode.outputNode;\n      const isOutputStruct = outputNode !== undefined && outputNode.isOutputStructNode === true;\n      for (const node of flowNodes) {\n        const flowSlotData = this.getFlowData(node /*, shaderStage*/);\n        const slotName = node.name;\n        if (slotName) {\n          if (flow.length > 0) flow += '\\n';\n          flow += `\\t// flow -> ${slotName}\\n\\t`;\n        }\n        flow += `${flowSlotData.code}\\n\\t`;\n        if (node === mainNode && shaderStage !== 'compute') {\n          flow += '// result\\n\\n\\t';\n          if (shaderStage === 'vertex') {\n            flow += `varyings.Vertex = ${flowSlotData.result};`;\n          } else if (shaderStage === 'fragment') {\n            if (isOutputStruct) {\n              stageData.returnType = outputNode.nodeType;\n              flow += `return ${flowSlotData.result};`;\n            } else {\n              let structSnippet = '\\t@location(0) color: vec4<f32>';\n              const builtins = this.getBuiltins('output');\n              if (builtins) structSnippet += ',\\n\\t' + builtins;\n              stageData.returnType = 'OutputStruct';\n              stageData.structs += this._getWGSLStruct('OutputStruct', structSnippet);\n              stageData.structs += '\\nvar<private> output : OutputStruct;\\n\\n';\n              flow += `output.color = ${flowSlotData.result};\\n\\n\\treturn output;`;\n            }\n          }\n        }\n      }\n      stageData.flow = flow;\n    }\n    if (this.material !== null) {\n      this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);\n      this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);\n    } else {\n      this.computeShader = this._getWGSLComputeCode(shadersData.compute, (this.object.workgroupSize || [64]).join(', '));\n    }\n  }\n  getMethod(method, output = null) {\n    let wgslMethod;\n    if (output !== null) {\n      wgslMethod = this._getWGSLMethod(method + '_' + output);\n    }\n    if (wgslMethod === undefined) {\n      wgslMethod = this._getWGSLMethod(method);\n    }\n    return wgslMethod || method;\n  }\n  getType(type) {\n    return wgslTypeLib[type] || type;\n  }\n  isAvailable(name) {\n    let result = supports[name];\n    if (result === undefined) {\n      if (name === 'float32Filterable') {\n        result = this.renderer.hasFeature('float32-filterable');\n      } else if (name === 'clipDistance') {\n        result = this.renderer.hasFeature('clip-distances');\n      }\n      supports[name] = result;\n    }\n    return result;\n  }\n  _getWGSLMethod(method) {\n    if (wgslPolyfill[method] !== undefined) {\n      this._include(method);\n    }\n    return wgslMethods[method];\n  }\n  _include(name) {\n    const codeNode = wgslPolyfill[name];\n    codeNode.build(this);\n    if (this.currentFunctionNode !== null) {\n      this.currentFunctionNode.includes.push(codeNode);\n    }\n    return codeNode;\n  }\n  _getWGSLVertexCode(shaderData) {\n    return `${this.getSignature()}\n// directives\n${shaderData.directives}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( ${shaderData.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn varyings;\n\n}\n`;\n  }\n  _getWGSLFragmentCode(shaderData) {\n    return `${this.getSignature()}\n// global\n${diagnostics}\n\n// uniforms\n${shaderData.uniforms}\n\n// structs\n${shaderData.structs}\n\n// codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  _getWGSLComputeCode(shaderData, workgroupSize) {\n    return `${this.getSignature()}\n// directives\n${shaderData.directives}\n\n// system\nvar<private> instanceIndex : u32;\n\n// locals\n${shaderData.scopedArrays}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@compute @workgroup_size( ${workgroupSize} )\nfn main( ${shaderData.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x + id.y * numWorkgroups.x * u32(${workgroupSize}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${workgroupSize});\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n  }\n  _getWGSLStruct(name, vars) {\n    return `\nstruct ${name} {\n${vars}\n};`;\n  }\n  _getWGSLStructBinding(name, vars, access, binding = 0, group = 0) {\n    const structName = name + 'Struct';\n    const structSnippet = this._getWGSLStruct(structName, vars);\n    return `${structSnippet}\n@binding( ${binding} ) @group( ${group} )\nvar<${access}> ${name} : ${structName};`;\n  }\n}\nclass WebGPUUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  getCurrentDepthStencilFormat(renderContext) {\n    let format;\n    if (renderContext.depthTexture !== null) {\n      format = this.getTextureFormatGPU(renderContext.depthTexture);\n    } else if (renderContext.depth && renderContext.stencil) {\n      format = GPUTextureFormat.Depth24PlusStencil8;\n    } else if (renderContext.depth) {\n      format = GPUTextureFormat.Depth24Plus;\n    }\n    return format;\n  }\n  getTextureFormatGPU(texture) {\n    return this.backend.get(texture).format;\n  }\n  getCurrentColorFormat(renderContext) {\n    let format;\n    if (renderContext.textures !== null) {\n      format = this.getTextureFormatGPU(renderContext.textures[0]);\n    } else {\n      format = this.getPreferredCanvasFormat(); // default context format\n    }\n    return format;\n  }\n  getCurrentColorSpace(renderContext) {\n    if (renderContext.textures !== null) {\n      return renderContext.textures[0].colorSpace;\n    }\n    return this.backend.renderer.outputColorSpace;\n  }\n  getPrimitiveTopology(object, material) {\n    if (object.isPoints) return GPUPrimitiveTopology.PointList;else if (object.isLineSegments || object.isMesh && material.wireframe === true) return GPUPrimitiveTopology.LineList;else if (object.isLine) return GPUPrimitiveTopology.LineStrip;else if (object.isMesh) return GPUPrimitiveTopology.TriangleList;\n  }\n  getSampleCount(sampleCount) {\n    let count = 1;\n    if (sampleCount > 1) {\n      // WebGPU only supports power-of-two sample counts and 2 is not a valid value\n      count = Math.pow(2, Math.floor(Math.log2(sampleCount)));\n      if (count === 2) {\n        count = 4;\n      }\n    }\n    return count;\n  }\n  getSampleCountRenderContext(renderContext) {\n    if (renderContext.textures !== null) {\n      return this.getSampleCount(renderContext.sampleCount);\n    }\n    return this.getSampleCount(this.backend.renderer.samples);\n  }\n  getPreferredCanvasFormat() {\n    // TODO: Remove this check when Quest 34.5 is out\n    // https://github.com/mrdoob/three.js/pull/29221/files#r1731833949\n\n    if (navigator.userAgent.includes('Quest')) {\n      return GPUTextureFormat.BGRA8Unorm;\n    } else {\n      return navigator.gpu.getPreferredCanvasFormat();\n    }\n  }\n}\nconst typedArraysToVertexFormatPrefix = new Map([[Int8Array, ['sint8', 'snorm8']], [Uint8Array, ['uint8', 'unorm8']], [Int16Array, ['sint16', 'snorm16']], [Uint16Array, ['uint16', 'unorm16']], [Int32Array, ['sint32', 'snorm32']], [Uint32Array, ['uint32', 'unorm32']], [Float32Array, ['float32']]]);\nconst typedAttributeToVertexFormatPrefix = new Map([[Float16BufferAttribute, ['float16']]]);\nconst typeArraysToVertexFormatPrefixForItemSize1 = new Map([[Int32Array, 'sint32'], [Int16Array, 'sint32'],\n// patch for INT16\n[Uint32Array, 'uint32'], [Uint16Array, 'uint32'],\n// patch for UINT16\n[Float32Array, 'float32']]);\nclass WebGPUAttributeUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  createAttribute(attribute, usage) {\n    const bufferAttribute = this._getBufferAttribute(attribute);\n    const backend = this.backend;\n    const bufferData = backend.get(bufferAttribute);\n    let buffer = bufferData.buffer;\n    if (buffer === undefined) {\n      const device = backend.device;\n      let array = bufferAttribute.array;\n\n      // patch for INT16 and UINT16\n      if (attribute.normalized === false && (array.constructor === Int16Array || array.constructor === Uint16Array)) {\n        const tempArray = new Uint32Array(array.length);\n        for (let i = 0; i < array.length; i++) {\n          tempArray[i] = array[i];\n        }\n        array = tempArray;\n      }\n      bufferAttribute.array = array;\n      if ((bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute) && bufferAttribute.itemSize === 3) {\n        array = new array.constructor(bufferAttribute.count * 4);\n        for (let i = 0; i < bufferAttribute.count; i++) {\n          array.set(bufferAttribute.array.subarray(i * 3, i * 3 + 3), i * 4);\n        }\n\n        // Update BufferAttribute\n        bufferAttribute.itemSize = 4;\n        bufferAttribute.array = array;\n      }\n      const size = array.byteLength + (4 - array.byteLength % 4) % 4; // ensure 4 byte alignment, see #20441\n\n      buffer = device.createBuffer({\n        label: bufferAttribute.name,\n        size: size,\n        usage: usage,\n        mappedAtCreation: true\n      });\n      new array.constructor(buffer.getMappedRange()).set(array);\n      buffer.unmap();\n      bufferData.buffer = buffer;\n    }\n  }\n  updateAttribute(attribute) {\n    const bufferAttribute = this._getBufferAttribute(attribute);\n    const backend = this.backend;\n    const device = backend.device;\n    const buffer = backend.get(bufferAttribute).buffer;\n    const array = bufferAttribute.array;\n    const isTypedArray = this._isTypedArray(array);\n    const updateRanges = bufferAttribute.updateRanges;\n    if (updateRanges.length === 0) {\n      // Not using update ranges\n\n      device.queue.writeBuffer(buffer, 0, array, 0);\n    } else {\n      const byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;\n      for (let i = 0, l = updateRanges.length; i < l; i++) {\n        const range = updateRanges[i];\n        const dataOffset = range.start * byteOffsetFactor;\n        const size = range.count * byteOffsetFactor;\n        device.queue.writeBuffer(buffer, 0, array, dataOffset, size);\n      }\n      bufferAttribute.clearUpdateRanges();\n    }\n  }\n  createShaderVertexBuffers(renderObject) {\n    const attributes = renderObject.getAttributes();\n    const vertexBuffers = new Map();\n    for (let slot = 0; slot < attributes.length; slot++) {\n      const geometryAttribute = attributes[slot];\n      const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;\n      const bufferAttribute = this._getBufferAttribute(geometryAttribute);\n      let vertexBufferLayout = vertexBuffers.get(bufferAttribute);\n      if (vertexBufferLayout === undefined) {\n        let arrayStride, stepMode;\n        if (geometryAttribute.isInterleavedBufferAttribute === true) {\n          arrayStride = geometryAttribute.data.stride * bytesPerElement;\n          stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n        } else {\n          arrayStride = geometryAttribute.itemSize * bytesPerElement;\n          stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n        }\n\n        // patch for INT16 and UINT16\n        if (geometryAttribute.normalized === false && (geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array)) {\n          arrayStride = 4;\n        }\n        vertexBufferLayout = {\n          arrayStride,\n          attributes: [],\n          stepMode\n        };\n        vertexBuffers.set(bufferAttribute, vertexBufferLayout);\n      }\n      const format = this._getVertexFormat(geometryAttribute);\n      const offset = geometryAttribute.isInterleavedBufferAttribute === true ? geometryAttribute.offset * bytesPerElement : 0;\n      vertexBufferLayout.attributes.push({\n        shaderLocation: slot,\n        offset,\n        format\n      });\n    }\n    return Array.from(vertexBuffers.values());\n  }\n  destroyAttribute(attribute) {\n    const backend = this.backend;\n    const data = backend.get(this._getBufferAttribute(attribute));\n    data.buffer.destroy();\n    backend.delete(attribute);\n  }\n  async getArrayBufferAsync(attribute) {\n    const backend = this.backend;\n    const device = backend.device;\n    const data = backend.get(this._getBufferAttribute(attribute));\n    const bufferGPU = data.buffer;\n    const size = bufferGPU.size;\n    const readBufferGPU = device.createBuffer({\n      label: attribute.name,\n      size,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n    });\n    const cmdEncoder = device.createCommandEncoder({});\n    cmdEncoder.copyBufferToBuffer(bufferGPU, 0, readBufferGPU, 0, size);\n    readBufferGPU.unmap();\n    const gpuCommands = cmdEncoder.finish();\n    device.queue.submit([gpuCommands]);\n    await readBufferGPU.mapAsync(GPUMapMode.READ);\n    const arrayBuffer = readBufferGPU.getMappedRange();\n    return arrayBuffer;\n  }\n  _getVertexFormat(geometryAttribute) {\n    const {\n      itemSize,\n      normalized\n    } = geometryAttribute;\n    const ArrayType = geometryAttribute.array.constructor;\n    const AttributeType = geometryAttribute.constructor;\n    let format;\n    if (itemSize == 1) {\n      format = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);\n    } else {\n      const prefixOptions = typedAttributeToVertexFormatPrefix.get(AttributeType) || typedArraysToVertexFormatPrefix.get(ArrayType);\n      const prefix = prefixOptions[normalized ? 1 : 0];\n      if (prefix) {\n        const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;\n        const paddedBytesPerUnit = Math.floor((bytesPerUnit + 3) / 4) * 4;\n        const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;\n        if (paddedItemSize % 1) {\n          throw new Error('THREE.WebGPUAttributeUtils: Bad vertex format item size.');\n        }\n        format = `${prefix}x${paddedItemSize}`;\n      }\n    }\n    if (!format) {\n      console.error('THREE.WebGPUAttributeUtils: Vertex format not supported yet.');\n    }\n    return format;\n  }\n  _isTypedArray(array) {\n    return ArrayBuffer.isView(array) && !(array instanceof DataView);\n  }\n  _getBufferAttribute(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    return attribute;\n  }\n}\nclass WebGPUBindingUtils {\n  constructor(backend) {\n    this.backend = backend;\n    this.bindGroupLayoutCache = new WeakMap();\n  }\n  createBindingsLayout(bindGroup) {\n    const backend = this.backend;\n    const device = backend.device;\n    const entries = [];\n    let index = 0;\n    for (const binding of bindGroup.bindings) {\n      const bindingGPU = {\n        binding: index++,\n        visibility: binding.visibility\n      };\n      if (binding.isUniformBuffer || binding.isStorageBuffer) {\n        const buffer = {}; // GPUBufferBindingLayout\n\n        if (binding.isStorageBuffer) {\n          if (binding.visibility & 4) {\n            // compute\n\n            if (binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY) {\n              buffer.type = GPUBufferBindingType.Storage;\n            } else {\n              buffer.type = GPUBufferBindingType.ReadOnlyStorage;\n            }\n          } else {\n            buffer.type = GPUBufferBindingType.ReadOnlyStorage;\n          }\n        }\n        bindingGPU.buffer = buffer;\n      } else if (binding.isSampler) {\n        const sampler = {}; // GPUSamplerBindingLayout\n\n        if (binding.texture.isDepthTexture) {\n          if (binding.texture.compareFunction !== null) {\n            sampler.type = 'comparison';\n          }\n        }\n        bindingGPU.sampler = sampler;\n      } else if (binding.isSampledTexture && binding.texture.isVideoTexture) {\n        bindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout\n      } else if (binding.isSampledTexture && binding.store) {\n        const storageTexture = {}; // GPUStorageTextureBindingLayout\n        storageTexture.format = this.backend.get(binding.texture).texture.format;\n        const access = binding.access;\n        if (access === NodeAccess.READ_WRITE) {\n          storageTexture.access = GPUStorageTextureAccess.ReadWrite;\n        } else if (access === NodeAccess.WRITE_ONLY) {\n          storageTexture.access = GPUStorageTextureAccess.WriteOnly;\n        } else {\n          storageTexture.access = GPUStorageTextureAccess.ReadOnly;\n        }\n        bindingGPU.storageTexture = storageTexture;\n      } else if (binding.isSampledTexture) {\n        const texture = {}; // GPUTextureBindingLayout\n\n        if (binding.texture.isMultisampleRenderTargetTexture === true) {\n          texture.multisampled = true;\n        }\n        if (binding.texture.isDepthTexture) {\n          texture.sampleType = GPUTextureSampleType.Depth;\n        } else if (binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture) {\n          const type = binding.texture.type;\n          if (type === IntType) {\n            texture.sampleType = GPUTextureSampleType.SInt;\n          } else if (type === UnsignedIntType) {\n            texture.sampleType = GPUTextureSampleType.UInt;\n          } else if (type === FloatType) {\n            if (this.backend.hasFeature('float32-filterable')) {\n              texture.sampleType = GPUTextureSampleType.Float;\n            } else {\n              texture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n            }\n          }\n        }\n        if (binding.isSampledCubeTexture) {\n          texture.viewDimension = GPUTextureViewDimension.Cube;\n        } else if (binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) {\n          texture.viewDimension = GPUTextureViewDimension.TwoDArray;\n        } else if (binding.isSampledTexture3D) {\n          texture.viewDimension = GPUTextureViewDimension.ThreeD;\n        }\n        bindingGPU.texture = texture;\n      } else {\n        console.error(`WebGPUBindingUtils: Unsupported binding \"${binding}\".`);\n      }\n      entries.push(bindingGPU);\n    }\n    return device.createBindGroupLayout({\n      entries\n    });\n  }\n  createBindings(bindGroup, bindings, cacheIndex, version = 0) {\n    const {\n      backend,\n      bindGroupLayoutCache\n    } = this;\n    const bindingsData = backend.get(bindGroup);\n\n    // setup (static) binding layout and (dynamic) binding group\n\n    let bindLayoutGPU = bindGroupLayoutCache.get(bindGroup.bindingsReference);\n    if (bindLayoutGPU === undefined) {\n      bindLayoutGPU = this.createBindingsLayout(bindGroup);\n      bindGroupLayoutCache.set(bindGroup.bindingsReference, bindLayoutGPU);\n    }\n    let bindGroupGPU;\n    if (cacheIndex > 0) {\n      if (bindingsData.groups === undefined) {\n        bindingsData.groups = [];\n        bindingsData.versions = [];\n      }\n      if (bindingsData.versions[cacheIndex] === version) {\n        bindGroupGPU = bindingsData.groups[cacheIndex];\n      }\n    }\n    if (bindGroupGPU === undefined) {\n      bindGroupGPU = this.createBindGroup(bindGroup, bindLayoutGPU);\n      if (cacheIndex > 0) {\n        bindingsData.groups[cacheIndex] = bindGroupGPU;\n        bindingsData.versions[cacheIndex] = version;\n      }\n    }\n    bindingsData.group = bindGroupGPU;\n    bindingsData.layout = bindLayoutGPU;\n  }\n  updateBinding(binding) {\n    const backend = this.backend;\n    const device = backend.device;\n    const buffer = binding.buffer;\n    const bufferGPU = backend.get(binding).buffer;\n    device.queue.writeBuffer(bufferGPU, 0, buffer, 0);\n  }\n  createBindGroup(bindGroup, layoutGPU) {\n    const backend = this.backend;\n    const device = backend.device;\n    let bindingPoint = 0;\n    const entriesGPU = [];\n    for (const binding of bindGroup.bindings) {\n      if (binding.isUniformBuffer) {\n        const bindingData = backend.get(binding);\n        if (bindingData.buffer === undefined) {\n          const byteLength = binding.byteLength;\n          const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n          const bufferGPU = device.createBuffer({\n            label: 'bindingBuffer_' + binding.name,\n            size: byteLength,\n            usage: usage\n          });\n          bindingData.buffer = bufferGPU;\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: {\n            buffer: bindingData.buffer\n          }\n        });\n      } else if (binding.isStorageBuffer) {\n        const bindingData = backend.get(binding);\n        if (bindingData.buffer === undefined) {\n          const attribute = binding.attribute;\n          //const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;\n\n          //backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer\n\n          bindingData.buffer = backend.get(attribute).buffer;\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: {\n            buffer: bindingData.buffer\n          }\n        });\n      } else if (binding.isSampler) {\n        const textureGPU = backend.get(binding.texture);\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: textureGPU.sampler\n        });\n      } else if (binding.isSampledTexture) {\n        const textureData = backend.get(binding.texture);\n        let resourceGPU;\n        if (textureData.externalTexture !== undefined) {\n          resourceGPU = device.importExternalTexture({\n            source: textureData.externalTexture\n          });\n        } else {\n          const mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;\n          const propertyName = `view-${textureData.texture.width}-${textureData.texture.height}-${mipLevelCount}`;\n          resourceGPU = textureData[propertyName];\n          if (resourceGPU === undefined) {\n            const aspectGPU = GPUTextureAspect.All;\n            let dimensionViewGPU;\n            if (binding.isSampledCubeTexture) {\n              dimensionViewGPU = GPUTextureViewDimension.Cube;\n            } else if (binding.isSampledTexture3D) {\n              dimensionViewGPU = GPUTextureViewDimension.ThreeD;\n            } else if (binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) {\n              dimensionViewGPU = GPUTextureViewDimension.TwoDArray;\n            } else {\n              dimensionViewGPU = GPUTextureViewDimension.TwoD;\n            }\n            resourceGPU = textureData[propertyName] = textureData.texture.createView({\n              aspect: aspectGPU,\n              dimension: dimensionViewGPU,\n              mipLevelCount\n            });\n          }\n        }\n        entriesGPU.push({\n          binding: bindingPoint,\n          resource: resourceGPU\n        });\n      }\n      bindingPoint++;\n    }\n    return device.createBindGroup({\n      label: 'bindGroup_' + bindGroup.name,\n      layout: layoutGPU,\n      entries: entriesGPU\n    });\n  }\n}\nclass WebGPUPipelineUtils {\n  constructor(backend) {\n    this.backend = backend;\n  }\n  _getSampleCount(renderObjectContext) {\n    return this.backend.utils.getSampleCountRenderContext(renderObjectContext);\n  }\n  createRenderPipeline(renderObject, promises) {\n    const {\n      object,\n      material,\n      geometry,\n      pipeline\n    } = renderObject;\n    const {\n      vertexProgram,\n      fragmentProgram\n    } = pipeline;\n    const backend = this.backend;\n    const device = backend.device;\n    const utils = backend.utils;\n    const pipelineData = backend.get(pipeline);\n\n    // bind group layouts\n\n    const bindGroupLayouts = [];\n    for (const bindGroup of renderObject.getBindings()) {\n      const bindingsData = backend.get(bindGroup);\n      bindGroupLayouts.push(bindingsData.layout);\n    }\n\n    // vertex buffers\n\n    const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers(renderObject);\n\n    // blending\n\n    let blending;\n    if (material.transparent === true && material.blending !== NoBlending) {\n      blending = this._getBlending(material);\n    }\n\n    // stencil\n\n    let stencilFront = {};\n    if (material.stencilWrite === true) {\n      stencilFront = {\n        compare: this._getStencilCompare(material),\n        failOp: this._getStencilOperation(material.stencilFail),\n        depthFailOp: this._getStencilOperation(material.stencilZFail),\n        passOp: this._getStencilOperation(material.stencilZPass)\n      };\n    }\n    const colorWriteMask = this._getColorWriteMask(material);\n    const targets = [];\n    if (renderObject.context.textures !== null) {\n      const textures = renderObject.context.textures;\n      for (let i = 0; i < textures.length; i++) {\n        const colorFormat = utils.getTextureFormatGPU(textures[i]);\n        targets.push({\n          format: colorFormat,\n          blend: blending,\n          writeMask: colorWriteMask\n        });\n      }\n    } else {\n      const colorFormat = utils.getCurrentColorFormat(renderObject.context);\n      targets.push({\n        format: colorFormat,\n        blend: blending,\n        writeMask: colorWriteMask\n      });\n    }\n    const vertexModule = backend.get(vertexProgram).module;\n    const fragmentModule = backend.get(fragmentProgram).module;\n    const primitiveState = this._getPrimitiveState(object, geometry, material);\n    const depthCompare = this._getDepthCompare(material);\n    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);\n    const sampleCount = this._getSampleCount(renderObject.context);\n    const pipelineDescriptor = {\n      label: `renderPipeline_${material.name || material.type}_${material.id}`,\n      vertex: Object.assign({}, vertexModule, {\n        buffers: vertexBuffers\n      }),\n      fragment: Object.assign({}, fragmentModule, {\n        targets\n      }),\n      primitive: primitiveState,\n      multisample: {\n        count: sampleCount,\n        alphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1\n      },\n      layout: device.createPipelineLayout({\n        bindGroupLayouts\n      })\n    };\n    const depthStencil = {};\n    const renderDepth = renderObject.context.depth;\n    const renderStencil = renderObject.context.stencil;\n    if (renderDepth === true || renderStencil === true) {\n      if (renderDepth === true) {\n        depthStencil.format = depthStencilFormat;\n        depthStencil.depthWriteEnabled = material.depthWrite;\n        depthStencil.depthCompare = depthCompare;\n      }\n      if (renderStencil === true) {\n        depthStencil.stencilFront = stencilFront;\n        depthStencil.stencilBack = {}; // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)\n        depthStencil.stencilReadMask = material.stencilFuncMask;\n        depthStencil.stencilWriteMask = material.stencilWriteMask;\n      }\n      pipelineDescriptor.depthStencil = depthStencil;\n    }\n    if (promises === null) {\n      pipelineData.pipeline = device.createRenderPipeline(pipelineDescriptor);\n    } else {\n      const p = new Promise((resolve /*, reject*/) => {\n        device.createRenderPipelineAsync(pipelineDescriptor).then(pipeline => {\n          pipelineData.pipeline = pipeline;\n          resolve();\n        });\n      });\n      promises.push(p);\n    }\n  }\n  createBundleEncoder(renderContext) {\n    const backend = this.backend;\n    const {\n      utils,\n      device\n    } = backend;\n    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderContext);\n    const colorFormat = utils.getCurrentColorFormat(renderContext);\n    const sampleCount = this._getSampleCount(renderContext);\n    const descriptor = {\n      label: 'renderBundleEncoder',\n      colorFormats: [colorFormat],\n      depthStencilFormat,\n      sampleCount\n    };\n    return device.createRenderBundleEncoder(descriptor);\n  }\n  createComputePipeline(pipeline, bindings) {\n    const backend = this.backend;\n    const device = backend.device;\n    const computeProgram = backend.get(pipeline.computeProgram).module;\n    const pipelineGPU = backend.get(pipeline);\n\n    // bind group layouts\n\n    const bindGroupLayouts = [];\n    for (const bindingsGroup of bindings) {\n      const bindingsData = backend.get(bindingsGroup);\n      bindGroupLayouts.push(bindingsData.layout);\n    }\n    pipelineGPU.pipeline = device.createComputePipeline({\n      compute: computeProgram,\n      layout: device.createPipelineLayout({\n        bindGroupLayouts\n      })\n    });\n  }\n  _getBlending(material) {\n    let color, alpha;\n    const blending = material.blending;\n    const blendSrc = material.blendSrc;\n    const blendDst = material.blendDst;\n    const blendEquation = material.blendEquation;\n    if (blending === CustomBlending) {\n      const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;\n      const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;\n      const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;\n      color = {\n        srcFactor: this._getBlendFactor(blendSrc),\n        dstFactor: this._getBlendFactor(blendDst),\n        operation: this._getBlendOperation(blendEquation)\n      };\n      alpha = {\n        srcFactor: this._getBlendFactor(blendSrcAlpha),\n        dstFactor: this._getBlendFactor(blendDstAlpha),\n        operation: this._getBlendOperation(blendEquationAlpha)\n      };\n    } else {\n      const premultipliedAlpha = material.premultipliedAlpha;\n      const setBlend = (srcRGB, dstRGB, srcAlpha, dstAlpha) => {\n        color = {\n          srcFactor: srcRGB,\n          dstFactor: dstRGB,\n          operation: GPUBlendOperation.Add\n        };\n        alpha = {\n          srcFactor: srcAlpha,\n          dstFactor: dstAlpha,\n          operation: GPUBlendOperation.Add\n        };\n      };\n      if (premultipliedAlpha) {\n        switch (blending) {\n          case NormalBlending:\n            setBlend(GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);\n            break;\n          case AdditiveBlending:\n            setBlend(GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);\n            break;\n          case SubtractiveBlending:\n            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);\n            break;\n          case MultiplyBlending:\n            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha);\n            break;\n        }\n      } else {\n        switch (blending) {\n          case NormalBlending:\n            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);\n            break;\n          case AdditiveBlending:\n            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One);\n            break;\n          case SubtractiveBlending:\n            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);\n            break;\n          case MultiplyBlending:\n            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src);\n            break;\n        }\n      }\n    }\n    if (color !== undefined && alpha !== undefined) {\n      return {\n        color,\n        alpha\n      };\n    } else {\n      console.error('THREE.WebGPURenderer: Invalid blending: ', blending);\n    }\n  }\n  _getBlendFactor(blend) {\n    let blendFactor;\n    switch (blend) {\n      case ZeroFactor:\n        blendFactor = GPUBlendFactor.Zero;\n        break;\n      case OneFactor:\n        blendFactor = GPUBlendFactor.One;\n        break;\n      case SrcColorFactor:\n        blendFactor = GPUBlendFactor.Src;\n        break;\n      case OneMinusSrcColorFactor:\n        blendFactor = GPUBlendFactor.OneMinusSrc;\n        break;\n      case SrcAlphaFactor:\n        blendFactor = GPUBlendFactor.SrcAlpha;\n        break;\n      case OneMinusSrcAlphaFactor:\n        blendFactor = GPUBlendFactor.OneMinusSrcAlpha;\n        break;\n      case DstColorFactor:\n        blendFactor = GPUBlendFactor.Dst;\n        break;\n      case OneMinusDstColorFactor:\n        blendFactor = GPUBlendFactor.OneMinusDstColor;\n        break;\n      case DstAlphaFactor:\n        blendFactor = GPUBlendFactor.DstAlpha;\n        break;\n      case OneMinusDstAlphaFactor:\n        blendFactor = GPUBlendFactor.OneMinusDstAlpha;\n        break;\n      case SrcAlphaSaturateFactor:\n        blendFactor = GPUBlendFactor.SrcAlphaSaturated;\n        break;\n      case BlendColorFactor:\n        blendFactor = GPUBlendFactor.Constant;\n        break;\n      case OneMinusBlendColorFactor:\n        blendFactor = GPUBlendFactor.OneMinusConstant;\n        break;\n      default:\n        console.error('THREE.WebGPURenderer: Blend factor not supported.', blend);\n    }\n    return blendFactor;\n  }\n  _getStencilCompare(material) {\n    let stencilCompare;\n    const stencilFunc = material.stencilFunc;\n    switch (stencilFunc) {\n      case NeverStencilFunc:\n        stencilCompare = GPUCompareFunction.Never;\n        break;\n      case AlwaysStencilFunc:\n        stencilCompare = GPUCompareFunction.Always;\n        break;\n      case LessStencilFunc:\n        stencilCompare = GPUCompareFunction.Less;\n        break;\n      case LessEqualStencilFunc:\n        stencilCompare = GPUCompareFunction.LessEqual;\n        break;\n      case EqualStencilFunc:\n        stencilCompare = GPUCompareFunction.Equal;\n        break;\n      case GreaterEqualStencilFunc:\n        stencilCompare = GPUCompareFunction.GreaterEqual;\n        break;\n      case GreaterStencilFunc:\n        stencilCompare = GPUCompareFunction.Greater;\n        break;\n      case NotEqualStencilFunc:\n        stencilCompare = GPUCompareFunction.NotEqual;\n        break;\n      default:\n        console.error('THREE.WebGPURenderer: Invalid stencil function.', stencilFunc);\n    }\n    return stencilCompare;\n  }\n  _getStencilOperation(op) {\n    let stencilOperation;\n    switch (op) {\n      case KeepStencilOp:\n        stencilOperation = GPUStencilOperation.Keep;\n        break;\n      case ZeroStencilOp:\n        stencilOperation = GPUStencilOperation.Zero;\n        break;\n      case ReplaceStencilOp:\n        stencilOperation = GPUStencilOperation.Replace;\n        break;\n      case InvertStencilOp:\n        stencilOperation = GPUStencilOperation.Invert;\n        break;\n      case IncrementStencilOp:\n        stencilOperation = GPUStencilOperation.IncrementClamp;\n        break;\n      case DecrementStencilOp:\n        stencilOperation = GPUStencilOperation.DecrementClamp;\n        break;\n      case IncrementWrapStencilOp:\n        stencilOperation = GPUStencilOperation.IncrementWrap;\n        break;\n      case DecrementWrapStencilOp:\n        stencilOperation = GPUStencilOperation.DecrementWrap;\n        break;\n      default:\n        console.error('THREE.WebGPURenderer: Invalid stencil operation.', stencilOperation);\n    }\n    return stencilOperation;\n  }\n  _getBlendOperation(blendEquation) {\n    let blendOperation;\n    switch (blendEquation) {\n      case AddEquation:\n        blendOperation = GPUBlendOperation.Add;\n        break;\n      case SubtractEquation:\n        blendOperation = GPUBlendOperation.Subtract;\n        break;\n      case ReverseSubtractEquation:\n        blendOperation = GPUBlendOperation.ReverseSubtract;\n        break;\n      case MinEquation:\n        blendOperation = GPUBlendOperation.Min;\n        break;\n      case MaxEquation:\n        blendOperation = GPUBlendOperation.Max;\n        break;\n      default:\n        console.error('THREE.WebGPUPipelineUtils: Blend equation not supported.', blendEquation);\n    }\n    return blendOperation;\n  }\n  _getPrimitiveState(object, geometry, material) {\n    const descriptor = {};\n    const utils = this.backend.utils;\n    descriptor.topology = utils.getPrimitiveTopology(object, material);\n    if (geometry.index !== null && object.isLine === true && object.isLineSegments !== true) {\n      descriptor.stripIndexFormat = geometry.index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n    }\n    switch (material.side) {\n      case FrontSide:\n        descriptor.frontFace = GPUFrontFace.CCW;\n        descriptor.cullMode = GPUCullMode.Back;\n        break;\n      case BackSide:\n        descriptor.frontFace = GPUFrontFace.CCW;\n        descriptor.cullMode = GPUCullMode.Front;\n        break;\n      case DoubleSide:\n        descriptor.frontFace = GPUFrontFace.CCW;\n        descriptor.cullMode = GPUCullMode.None;\n        break;\n      default:\n        console.error('THREE.WebGPUPipelineUtils: Unknown material.side value.', material.side);\n        break;\n    }\n    return descriptor;\n  }\n  _getColorWriteMask(material) {\n    return material.colorWrite === true ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;\n  }\n  _getDepthCompare(material) {\n    let depthCompare;\n    if (material.depthTest === false) {\n      depthCompare = GPUCompareFunction.Always;\n    } else {\n      const depthFunc = material.depthFunc;\n      switch (depthFunc) {\n        case NeverDepth:\n          depthCompare = GPUCompareFunction.Never;\n          break;\n        case AlwaysDepth:\n          depthCompare = GPUCompareFunction.Always;\n          break;\n        case LessDepth:\n          depthCompare = GPUCompareFunction.Less;\n          break;\n        case LessEqualDepth:\n          depthCompare = GPUCompareFunction.LessEqual;\n          break;\n        case EqualDepth:\n          depthCompare = GPUCompareFunction.Equal;\n          break;\n        case GreaterEqualDepth:\n          depthCompare = GPUCompareFunction.GreaterEqual;\n          break;\n        case GreaterDepth:\n          depthCompare = GPUCompareFunction.Greater;\n          break;\n        case NotEqualDepth:\n          depthCompare = GPUCompareFunction.NotEqual;\n          break;\n        default:\n          console.error('THREE.WebGPUPipelineUtils: Invalid depth function.', depthFunc);\n      }\n    }\n    return depthCompare;\n  }\n}\n\n/*// debugger tools\nimport 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';\n//*/\n\n//\n\nclass WebGPUBackend extends Backend {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.isWebGPUBackend = true;\n\n    // some parameters require default values other than \"undefined\"\n    this.parameters.alpha = parameters.alpha === undefined ? true : parameters.alpha;\n    this.parameters.requiredLimits = parameters.requiredLimits === undefined ? {} : parameters.requiredLimits;\n    this.trackTimestamp = parameters.trackTimestamp === true;\n    this.device = null;\n    this.context = null;\n    this.colorBuffer = null;\n    this.defaultRenderPassdescriptor = null;\n    this.utils = new WebGPUUtils(this);\n    this.attributeUtils = new WebGPUAttributeUtils(this);\n    this.bindingUtils = new WebGPUBindingUtils(this);\n    this.pipelineUtils = new WebGPUPipelineUtils(this);\n    this.textureUtils = new WebGPUTextureUtils(this);\n    this.occludedResolveCache = new Map();\n  }\n  async init(renderer) {\n    await super.init(renderer);\n\n    //\n\n    const parameters = this.parameters;\n\n    // create the device if it is not passed with parameters\n\n    let device;\n    if (parameters.device === undefined) {\n      const adapterOptions = {\n        powerPreference: parameters.powerPreference\n      };\n      const adapter = typeof navigator !== 'undefined' ? await navigator.gpu.requestAdapter(adapterOptions) : null;\n      if (adapter === null) {\n        throw new Error('WebGPUBackend: Unable to create WebGPU adapter.');\n      }\n\n      // feature support\n\n      const features = Object.values(GPUFeatureName);\n      const supportedFeatures = [];\n      for (const name of features) {\n        if (adapter.features.has(name)) {\n          supportedFeatures.push(name);\n        }\n      }\n      const deviceDescriptor = {\n        requiredFeatures: supportedFeatures,\n        requiredLimits: parameters.requiredLimits\n      };\n      device = await adapter.requestDevice(deviceDescriptor);\n    } else {\n      device = parameters.device;\n    }\n    device.lost.then(info => {\n      const deviceLossInfo = {\n        api: 'WebGPU',\n        message: info.message || 'Unknown reason',\n        reason: info.reason || null,\n        originalEvent: info\n      };\n      renderer.onDeviceLost(deviceLossInfo);\n    });\n    const context = parameters.context !== undefined ? parameters.context : renderer.domElement.getContext('webgpu');\n    this.device = device;\n    this.context = context;\n    const alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';\n    this.trackTimestamp = this.trackTimestamp && this.hasFeature(GPUFeatureName.TimestampQuery);\n    this.context.configure({\n      device: this.device,\n      format: this.utils.getPreferredCanvasFormat(),\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      alphaMode: alphaMode\n    });\n    this.updateSize();\n  }\n  get coordinateSystem() {\n    return WebGPUCoordinateSystem;\n  }\n  async getArrayBufferAsync(attribute) {\n    return await this.attributeUtils.getArrayBufferAsync(attribute);\n  }\n  getContext() {\n    return this.context;\n  }\n  _getDefaultRenderPassDescriptor() {\n    let descriptor = this.defaultRenderPassdescriptor;\n    if (descriptor === null) {\n      const renderer = this.renderer;\n      descriptor = {\n        colorAttachments: [{\n          view: null\n        }]\n      };\n      if (this.renderer.depth === true || this.renderer.stencil === true) {\n        descriptor.depthStencilAttachment = {\n          view: this.textureUtils.getDepthBuffer(renderer.depth, renderer.stencil).createView()\n        };\n      }\n      const colorAttachment = descriptor.colorAttachments[0];\n      if (this.renderer.samples > 0) {\n        colorAttachment.view = this.colorBuffer.createView();\n      } else {\n        colorAttachment.resolveTarget = undefined;\n      }\n      this.defaultRenderPassdescriptor = descriptor;\n    }\n    const colorAttachment = descriptor.colorAttachments[0];\n    if (this.renderer.samples > 0) {\n      colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n    } else {\n      colorAttachment.view = this.context.getCurrentTexture().createView();\n    }\n    return descriptor;\n  }\n  _getRenderPassDescriptor(renderContext) {\n    const renderTarget = renderContext.renderTarget;\n    const renderTargetData = this.get(renderTarget);\n    let descriptors = renderTargetData.descriptors;\n    if (descriptors === undefined || renderTargetData.width !== renderTarget.width || renderTargetData.height !== renderTarget.height || renderTargetData.activeMipmapLevel !== renderTarget.activeMipmapLevel || renderTargetData.samples !== renderTarget.samples) {\n      descriptors = {};\n      renderTargetData.descriptors = descriptors;\n\n      // dispose\n\n      const onDispose = () => {\n        renderTarget.removeEventListener('dispose', onDispose);\n        this.delete(renderTarget);\n      };\n      renderTarget.addEventListener('dispose', onDispose);\n    }\n    const cacheKey = renderContext.getCacheKey();\n    let descriptor = descriptors[cacheKey];\n    if (descriptor === undefined) {\n      const textures = renderContext.textures;\n      const colorAttachments = [];\n      for (let i = 0; i < textures.length; i++) {\n        const textureData = this.get(textures[i]);\n        const textureView = textureData.texture.createView({\n          baseMipLevel: renderContext.activeMipmapLevel,\n          mipLevelCount: 1,\n          baseArrayLayer: renderContext.activeCubeFace,\n          dimension: GPUTextureViewDimension.TwoD\n        });\n        let view, resolveTarget;\n        if (textureData.msaaTexture !== undefined) {\n          view = textureData.msaaTexture.createView();\n          resolveTarget = textureView;\n        } else {\n          view = textureView;\n          resolveTarget = undefined;\n        }\n        colorAttachments.push({\n          view,\n          resolveTarget,\n          loadOp: GPULoadOp.Load,\n          storeOp: GPUStoreOp.Store\n        });\n      }\n      descriptor = {\n        colorAttachments\n      };\n      if (renderContext.depth) {\n        const depthTextureData = this.get(renderContext.depthTexture);\n        const depthStencilAttachment = {\n          view: depthTextureData.texture.createView()\n        };\n        descriptor.depthStencilAttachment = depthStencilAttachment;\n      }\n      descriptors[cacheKey] = descriptor;\n      renderTargetData.width = renderTarget.width;\n      renderTargetData.height = renderTarget.height;\n      renderTargetData.samples = renderTarget.samples;\n      renderTargetData.activeMipmapLevel = renderTarget.activeMipmapLevel;\n    }\n    return descriptor;\n  }\n  beginRender(renderContext) {\n    const renderContextData = this.get(renderContext);\n    const device = this.device;\n    const occlusionQueryCount = renderContext.occlusionQueryCount;\n    let occlusionQuerySet;\n    if (occlusionQueryCount > 0) {\n      if (renderContextData.currentOcclusionQuerySet) renderContextData.currentOcclusionQuerySet.destroy();\n      if (renderContextData.currentOcclusionQueryBuffer) renderContextData.currentOcclusionQueryBuffer.destroy();\n\n      // Get a reference to the array of objects with queries. The renderContextData property\n      // can be changed by another render pass before the buffer.mapAsyc() completes.\n      renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;\n      renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;\n      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n      //\n\n      occlusionQuerySet = device.createQuerySet({\n        type: 'occlusion',\n        count: occlusionQueryCount,\n        label: `occlusionQuerySet_${renderContext.id}`\n      });\n      renderContextData.occlusionQuerySet = occlusionQuerySet;\n      renderContextData.occlusionQueryIndex = 0;\n      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);\n      renderContextData.lastOcclusionObject = null;\n    }\n    let descriptor;\n    if (renderContext.textures === null) {\n      descriptor = this._getDefaultRenderPassDescriptor();\n    } else {\n      descriptor = this._getRenderPassDescriptor(renderContext);\n    }\n    this.initTimestampQuery(renderContext, descriptor);\n    descriptor.occlusionQuerySet = occlusionQuerySet;\n    const depthStencilAttachment = descriptor.depthStencilAttachment;\n    if (renderContext.textures !== null) {\n      const colorAttachments = descriptor.colorAttachments;\n      for (let i = 0; i < colorAttachments.length; i++) {\n        const colorAttachment = colorAttachments[i];\n        if (renderContext.clearColor) {\n          colorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n          };\n          colorAttachment.loadOp = GPULoadOp.Clear;\n          colorAttachment.storeOp = GPUStoreOp.Store;\n        } else {\n          colorAttachment.loadOp = GPULoadOp.Load;\n          colorAttachment.storeOp = GPUStoreOp.Store;\n        }\n      }\n    } else {\n      const colorAttachment = descriptor.colorAttachments[0];\n      if (renderContext.clearColor) {\n        colorAttachment.clearValue = renderContext.clearColorValue;\n        colorAttachment.loadOp = GPULoadOp.Clear;\n        colorAttachment.storeOp = GPUStoreOp.Store;\n      } else {\n        colorAttachment.loadOp = GPULoadOp.Load;\n        colorAttachment.storeOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    if (renderContext.depth) {\n      if (renderContext.clearDepth) {\n        depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      }\n    }\n    if (renderContext.stencil) {\n      if (renderContext.clearStencil) {\n        depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    const encoder = device.createCommandEncoder({\n      label: 'renderContext_' + renderContext.id\n    });\n    const currentPass = encoder.beginRenderPass(descriptor);\n\n    //\n\n    renderContextData.descriptor = descriptor;\n    renderContextData.encoder = encoder;\n    renderContextData.currentPass = currentPass;\n    renderContextData.currentSets = {\n      attributes: {},\n      bindingGroups: [],\n      pipeline: null,\n      index: null\n    };\n    renderContextData.renderBundles = [];\n\n    //\n\n    if (renderContext.viewport) {\n      this.updateViewport(renderContext);\n    }\n    if (renderContext.scissor) {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = renderContext.scissorValue;\n      currentPass.setScissorRect(x, y, width, height);\n    }\n  }\n  finishRender(renderContext) {\n    const renderContextData = this.get(renderContext);\n    const occlusionQueryCount = renderContext.occlusionQueryCount;\n    if (renderContextData.renderBundles.length > 0) {\n      renderContextData.currentPass.executeBundles(renderContextData.renderBundles);\n    }\n    if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {\n      renderContextData.currentPass.endOcclusionQuery();\n    }\n    renderContextData.currentPass.end();\n    if (occlusionQueryCount > 0) {\n      const bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results\n\n      //\n\n      let queryResolveBuffer = this.occludedResolveCache.get(bufferSize);\n      if (queryResolveBuffer === undefined) {\n        queryResolveBuffer = this.device.createBuffer({\n          size: bufferSize,\n          usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n        });\n        this.occludedResolveCache.set(bufferSize, queryResolveBuffer);\n      }\n\n      //\n\n      const readBuffer = this.device.createBuffer({\n        size: bufferSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n      });\n\n      // two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined\n      renderContextData.encoder.resolveQuerySet(renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0);\n      renderContextData.encoder.copyBufferToBuffer(queryResolveBuffer, 0, readBuffer, 0, bufferSize);\n      renderContextData.occlusionQueryBuffer = readBuffer;\n\n      //\n\n      this.resolveOccludedAsync(renderContext);\n    }\n    this.prepareTimestampBuffer(renderContext, renderContextData.encoder);\n    this.device.queue.submit([renderContextData.encoder.finish()]);\n\n    //\n\n    if (renderContext.textures !== null) {\n      const textures = renderContext.textures;\n      for (let i = 0; i < textures.length; i++) {\n        const texture = textures[i];\n        if (texture.generateMipmaps === true) {\n          this.textureUtils.generateMipmaps(texture);\n        }\n      }\n    }\n  }\n  isOccluded(renderContext, object) {\n    const renderContextData = this.get(renderContext);\n    return renderContextData.occluded && renderContextData.occluded.has(object);\n  }\n  async resolveOccludedAsync(renderContext) {\n    const renderContextData = this.get(renderContext);\n\n    // handle occlusion query results\n\n    const {\n      currentOcclusionQueryBuffer,\n      currentOcclusionQueryObjects\n    } = renderContextData;\n    if (currentOcclusionQueryBuffer && currentOcclusionQueryObjects) {\n      const occluded = new WeakSet();\n      renderContextData.currentOcclusionQueryObjects = null;\n      renderContextData.currentOcclusionQueryBuffer = null;\n      await currentOcclusionQueryBuffer.mapAsync(GPUMapMode.READ);\n      const buffer = currentOcclusionQueryBuffer.getMappedRange();\n      const results = new BigUint64Array(buffer);\n      for (let i = 0; i < currentOcclusionQueryObjects.length; i++) {\n        if (results[i] !== BigInt(0)) {\n          occluded.add(currentOcclusionQueryObjects[i]);\n        }\n      }\n      currentOcclusionQueryBuffer.destroy();\n      renderContextData.occluded = occluded;\n    }\n  }\n  updateViewport(renderContext) {\n    const {\n      currentPass\n    } = this.get(renderContext);\n    const {\n      x,\n      y,\n      width,\n      height,\n      minDepth,\n      maxDepth\n    } = renderContext.viewportValue;\n    currentPass.setViewport(x, y, width, height, minDepth, maxDepth);\n  }\n  clear(color, depth, stencil, renderTargetData = null) {\n    const device = this.device;\n    const renderer = this.renderer;\n    let colorAttachments = [];\n    let depthStencilAttachment;\n    let clearValue;\n    let supportsDepth;\n    let supportsStencil;\n    if (color) {\n      const clearColor = this.getClearColor();\n      if (this.renderer.alpha === true) {\n        // premultiply alpha\n\n        const a = clearColor.a;\n        clearValue = {\n          r: clearColor.r * a,\n          g: clearColor.g * a,\n          b: clearColor.b * a,\n          a: a\n        };\n      } else {\n        clearValue = {\n          r: clearColor.r,\n          g: clearColor.g,\n          b: clearColor.b,\n          a: clearColor.a\n        };\n      }\n    }\n    if (renderTargetData === null) {\n      supportsDepth = renderer.depth;\n      supportsStencil = renderer.stencil;\n      const descriptor = this._getDefaultRenderPassDescriptor();\n      if (color) {\n        colorAttachments = descriptor.colorAttachments;\n        const colorAttachment = colorAttachments[0];\n        colorAttachment.clearValue = clearValue;\n        colorAttachment.loadOp = GPULoadOp.Clear;\n        colorAttachment.storeOp = GPUStoreOp.Store;\n      }\n      if (supportsDepth || supportsStencil) {\n        depthStencilAttachment = descriptor.depthStencilAttachment;\n      }\n    } else {\n      supportsDepth = renderTargetData.depth;\n      supportsStencil = renderTargetData.stencil;\n      if (color) {\n        for (const texture of renderTargetData.textures) {\n          const textureData = this.get(texture);\n          const textureView = textureData.texture.createView();\n          let view, resolveTarget;\n          if (textureData.msaaTexture !== undefined) {\n            view = textureData.msaaTexture.createView();\n            resolveTarget = textureView;\n          } else {\n            view = textureView;\n            resolveTarget = undefined;\n          }\n          colorAttachments.push({\n            view,\n            resolveTarget,\n            clearValue,\n            loadOp: GPULoadOp.Clear,\n            storeOp: GPUStoreOp.Store\n          });\n        }\n      }\n      if (supportsDepth || supportsStencil) {\n        const depthTextureData = this.get(renderTargetData.depthTexture);\n        depthStencilAttachment = {\n          view: depthTextureData.texture.createView()\n        };\n      }\n    }\n\n    //\n\n    if (supportsDepth) {\n      if (depth) {\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.depthClearValue = renderer.getClearDepth();\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    if (supportsStencil) {\n      if (stencil) {\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n        depthStencilAttachment.stencilClearValue = renderer.getClearStencil();\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      } else {\n        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n      }\n    }\n\n    //\n\n    const encoder = device.createCommandEncoder({});\n    const currentPass = encoder.beginRenderPass({\n      colorAttachments,\n      depthStencilAttachment\n    });\n    currentPass.end();\n    device.queue.submit([encoder.finish()]);\n  }\n\n  // compute\n\n  beginCompute(computeGroup) {\n    const groupGPU = this.get(computeGroup);\n    const descriptor = {};\n    this.initTimestampQuery(computeGroup, descriptor);\n    groupGPU.cmdEncoderGPU = this.device.createCommandEncoder();\n    groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass(descriptor);\n  }\n  compute(computeGroup, computeNode, bindings, pipeline) {\n    const {\n      passEncoderGPU\n    } = this.get(computeGroup);\n\n    // pipeline\n\n    const pipelineGPU = this.get(pipeline).pipeline;\n    passEncoderGPU.setPipeline(pipelineGPU);\n\n    // bind groups\n\n    for (let i = 0, l = bindings.length; i < l; i++) {\n      const bindGroup = bindings[i];\n      const bindingsData = this.get(bindGroup);\n      passEncoderGPU.setBindGroup(i, bindingsData.group);\n    }\n    const maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;\n    const computeNodeData = this.get(computeNode);\n    if (computeNodeData.dispatchSize === undefined) computeNodeData.dispatchSize = {\n      x: 0,\n      y: 1,\n      z: 1\n    };\n    const {\n      dispatchSize\n    } = computeNodeData;\n    if (computeNode.dispatchCount > maxComputeWorkgroupsPerDimension) {\n      dispatchSize.x = Math.min(computeNode.dispatchCount, maxComputeWorkgroupsPerDimension);\n      dispatchSize.y = Math.ceil(computeNode.dispatchCount / maxComputeWorkgroupsPerDimension);\n    } else {\n      dispatchSize.x = computeNode.dispatchCount;\n    }\n    passEncoderGPU.dispatchWorkgroups(dispatchSize.x, dispatchSize.y, dispatchSize.z);\n  }\n  finishCompute(computeGroup) {\n    const groupData = this.get(computeGroup);\n    groupData.passEncoderGPU.end();\n    this.prepareTimestampBuffer(computeGroup, groupData.cmdEncoderGPU);\n    this.device.queue.submit([groupData.cmdEncoderGPU.finish()]);\n  }\n  async waitForGPU() {\n    await this.device.queue.onSubmittedWorkDone();\n  }\n\n  // render object\n\n  draw(renderObject, info) {\n    const {\n      object,\n      context,\n      pipeline\n    } = renderObject;\n    const bindings = renderObject.getBindings();\n    const renderContextData = this.get(context);\n    const pipelineGPU = this.get(pipeline).pipeline;\n    const currentSets = renderContextData.currentSets;\n    const passEncoderGPU = renderContextData.currentPass;\n    const drawParams = renderObject.getDrawParameters();\n    if (drawParams === null) return;\n\n    // pipeline\n\n    if (currentSets.pipeline !== pipelineGPU) {\n      passEncoderGPU.setPipeline(pipelineGPU);\n      currentSets.pipeline = pipelineGPU;\n    }\n\n    // bind groups\n\n    const currentBindingGroups = currentSets.bindingGroups;\n    for (let i = 0, l = bindings.length; i < l; i++) {\n      const bindGroup = bindings[i];\n      const bindingsData = this.get(bindGroup);\n      if (currentBindingGroups[bindGroup.index] !== bindGroup.id) {\n        passEncoderGPU.setBindGroup(bindGroup.index, bindingsData.group);\n        currentBindingGroups[bindGroup.index] = bindGroup.id;\n      }\n    }\n\n    // attributes\n\n    const index = renderObject.getIndex();\n    const hasIndex = index !== null;\n\n    // index\n\n    if (hasIndex === true) {\n      if (currentSets.index !== index) {\n        const buffer = this.get(index).buffer;\n        const indexFormat = index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n        passEncoderGPU.setIndexBuffer(buffer, indexFormat);\n        currentSets.index = index;\n      }\n    }\n\n    // vertex buffers\n\n    const vertexBuffers = renderObject.getVertexBuffers();\n    for (let i = 0, l = vertexBuffers.length; i < l; i++) {\n      const vertexBuffer = vertexBuffers[i];\n      if (currentSets.attributes[i] !== vertexBuffer) {\n        const buffer = this.get(vertexBuffer).buffer;\n        passEncoderGPU.setVertexBuffer(i, buffer);\n        currentSets.attributes[i] = vertexBuffer;\n      }\n    }\n\n    // occlusion queries - handle multiple consecutive draw calls for an object\n\n    if (renderContextData.occlusionQuerySet !== undefined) {\n      const lastObject = renderContextData.lastOcclusionObject;\n      if (lastObject !== object) {\n        if (lastObject !== null && lastObject.occlusionTest === true) {\n          passEncoderGPU.endOcclusionQuery();\n          renderContextData.occlusionQueryIndex++;\n        }\n        if (object.occlusionTest === true) {\n          passEncoderGPU.beginOcclusionQuery(renderContextData.occlusionQueryIndex);\n          renderContextData.occlusionQueryObjects[renderContextData.occlusionQueryIndex] = object;\n        }\n        renderContextData.lastOcclusionObject = object;\n      }\n    }\n\n    // draw\n\n    if (object.isBatchedMesh === true) {\n      const starts = object._multiDrawStarts;\n      const counts = object._multiDrawCounts;\n      const drawCount = object._multiDrawCount;\n      const drawInstances = object._multiDrawInstances;\n      const bytesPerElement = hasIndex ? index.array.BYTES_PER_ELEMENT : 1;\n      for (let i = 0; i < drawCount; i++) {\n        const count = drawInstances ? drawInstances[i] : 1;\n        const firstInstance = count > 1 ? 0 : i;\n        passEncoderGPU.drawIndexed(counts[i], count, starts[i] / bytesPerElement, 0, firstInstance);\n      }\n    } else if (hasIndex === true) {\n      const {\n        vertexCount: indexCount,\n        instanceCount,\n        firstVertex: firstIndex\n      } = drawParams;\n      const indirect = renderObject.getIndirect();\n      if (indirect !== null) {\n        const buffer = this.get(indirect).buffer;\n        passEncoderGPU.drawIndexedIndirect(buffer, 0);\n      } else {\n        passEncoderGPU.drawIndexed(indexCount, instanceCount, firstIndex, 0, 0);\n      }\n      info.update(object, indexCount, instanceCount);\n    } else {\n      const {\n        vertexCount,\n        instanceCount,\n        firstVertex\n      } = drawParams;\n      const indirect = renderObject.getIndirect();\n      if (indirect !== null) {\n        const buffer = this.get(indirect).buffer;\n        passEncoderGPU.drawIndirect(buffer, 0);\n      } else {\n        passEncoderGPU.draw(vertexCount, instanceCount, firstVertex, 0);\n      }\n      info.update(object, vertexCount, instanceCount);\n    }\n  }\n\n  // cache key\n\n  needsRenderUpdate(renderObject) {\n    const data = this.get(renderObject);\n    const {\n      object,\n      material\n    } = renderObject;\n    const utils = this.utils;\n    const sampleCount = utils.getSampleCountRenderContext(renderObject.context);\n    const colorSpace = utils.getCurrentColorSpace(renderObject.context);\n    const colorFormat = utils.getCurrentColorFormat(renderObject.context);\n    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);\n    const primitiveTopology = utils.getPrimitiveTopology(object, material);\n    let needsUpdate = false;\n    if (data.material !== material || data.materialVersion !== material.version || data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha || data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation || data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha || data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc || data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc || data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass || data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask || data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage || data.sampleCount !== sampleCount || data.colorSpace !== colorSpace || data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat || data.primitiveTopology !== primitiveTopology || data.clippingContextCacheKey !== renderObject.clippingContextCacheKey) {\n      data.material = material;\n      data.materialVersion = material.version;\n      data.transparent = material.transparent;\n      data.blending = material.blending;\n      data.premultipliedAlpha = material.premultipliedAlpha;\n      data.blendSrc = material.blendSrc;\n      data.blendDst = material.blendDst;\n      data.blendEquation = material.blendEquation;\n      data.blendSrcAlpha = material.blendSrcAlpha;\n      data.blendDstAlpha = material.blendDstAlpha;\n      data.blendEquationAlpha = material.blendEquationAlpha;\n      data.colorWrite = material.colorWrite;\n      data.depthWrite = material.depthWrite;\n      data.depthTest = material.depthTest;\n      data.depthFunc = material.depthFunc;\n      data.stencilWrite = material.stencilWrite;\n      data.stencilFunc = material.stencilFunc;\n      data.stencilFail = material.stencilFail;\n      data.stencilZFail = material.stencilZFail;\n      data.stencilZPass = material.stencilZPass;\n      data.stencilFuncMask = material.stencilFuncMask;\n      data.stencilWriteMask = material.stencilWriteMask;\n      data.side = material.side;\n      data.alphaToCoverage = material.alphaToCoverage;\n      data.sampleCount = sampleCount;\n      data.colorSpace = colorSpace;\n      data.colorFormat = colorFormat;\n      data.depthStencilFormat = depthStencilFormat;\n      data.primitiveTopology = primitiveTopology;\n      data.clippingContextCacheKey = renderObject.clippingContextCacheKey;\n      needsUpdate = true;\n    }\n    return needsUpdate;\n  }\n  getRenderCacheKey(renderObject) {\n    const {\n      object,\n      material\n    } = renderObject;\n    const utils = this.utils;\n    const renderContext = renderObject.context;\n    return [material.transparent, material.blending, material.premultipliedAlpha, material.blendSrc, material.blendDst, material.blendEquation, material.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha, material.colorWrite, material.depthWrite, material.depthTest, material.depthFunc, material.stencilWrite, material.stencilFunc, material.stencilFail, material.stencilZFail, material.stencilZPass, material.stencilFuncMask, material.stencilWriteMask, material.side, utils.getSampleCountRenderContext(renderContext), utils.getCurrentColorSpace(renderContext), utils.getCurrentColorFormat(renderContext), utils.getCurrentDepthStencilFormat(renderContext), utils.getPrimitiveTopology(object, material), renderObject.getGeometryCacheKey(), renderObject.clippingContextCacheKey].join();\n  }\n\n  // textures\n\n  createSampler(texture) {\n    this.textureUtils.createSampler(texture);\n  }\n  destroySampler(texture) {\n    this.textureUtils.destroySampler(texture);\n  }\n  createDefaultTexture(texture) {\n    this.textureUtils.createDefaultTexture(texture);\n  }\n  createTexture(texture, options) {\n    this.textureUtils.createTexture(texture, options);\n  }\n  updateTexture(texture, options) {\n    this.textureUtils.updateTexture(texture, options);\n  }\n  generateMipmaps(texture) {\n    this.textureUtils.generateMipmaps(texture);\n  }\n  destroyTexture(texture) {\n    this.textureUtils.destroyTexture(texture);\n  }\n  copyTextureToBuffer(texture, x, y, width, height, faceIndex) {\n    return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);\n  }\n  initTimestampQuery(renderContext, descriptor) {\n    if (!this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (!renderContextData.timeStampQuerySet) {\n      const type = renderContext.isComputeNode ? 'compute' : 'render';\n      const timeStampQuerySet = this.device.createQuerySet({\n        type: 'timestamp',\n        count: 2,\n        label: `timestamp_${type}_${renderContext.id}`\n      });\n      const timestampWrites = {\n        querySet: timeStampQuerySet,\n        beginningOfPassWriteIndex: 0,\n        // Write timestamp in index 0 when pass begins.\n        endOfPassWriteIndex: 1 // Write timestamp in index 1 when pass ends.\n      };\n      Object.assign(descriptor, {\n        timestampWrites\n      });\n      renderContextData.timeStampQuerySet = timeStampQuerySet;\n    }\n  }\n\n  // timestamp utils\n\n  prepareTimestampBuffer(renderContext, encoder) {\n    if (!this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    const size = 2 * BigInt64Array.BYTES_PER_ELEMENT;\n    if (renderContextData.currentTimestampQueryBuffers === undefined) {\n      renderContextData.currentTimestampQueryBuffers = {\n        resolveBuffer: this.device.createBuffer({\n          label: 'timestamp resolve buffer',\n          size: size,\n          usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n        }),\n        resultBuffer: this.device.createBuffer({\n          label: 'timestamp result buffer',\n          size: size,\n          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n        })\n      };\n    }\n    const {\n      resolveBuffer,\n      resultBuffer\n    } = renderContextData.currentTimestampQueryBuffers;\n    encoder.resolveQuerySet(renderContextData.timeStampQuerySet, 0, 2, resolveBuffer, 0);\n    if (resultBuffer.mapState === 'unmapped') {\n      encoder.copyBufferToBuffer(resolveBuffer, 0, resultBuffer, 0, size);\n    }\n  }\n  async resolveTimestampAsync(renderContext, type = 'render') {\n    if (!this.trackTimestamp) return;\n    const renderContextData = this.get(renderContext);\n    if (renderContextData.currentTimestampQueryBuffers === undefined) return;\n    const {\n      resultBuffer\n    } = renderContextData.currentTimestampQueryBuffers;\n    await this.device.queue.onSubmittedWorkDone();\n    if (resultBuffer.mapState === 'unmapped') {\n      resultBuffer.mapAsync(GPUMapMode.READ).then(() => {\n        const times = new BigUint64Array(resultBuffer.getMappedRange());\n        const duration = Number(times[1] - times[0]) / 1000000;\n        this.renderer.info.updateTimestamp(type, duration);\n        resultBuffer.unmap();\n      });\n    }\n  }\n\n  // node builder\n\n  createNodeBuilder(object, renderer) {\n    return new WGSLNodeBuilder(object, renderer);\n  }\n\n  // program\n\n  createProgram(program) {\n    const programGPU = this.get(program);\n    programGPU.module = {\n      module: this.device.createShaderModule({\n        code: program.code,\n        label: program.stage\n      }),\n      entryPoint: 'main'\n    };\n  }\n  destroyProgram(program) {\n    this.delete(program);\n  }\n\n  // pipelines\n\n  createRenderPipeline(renderObject, promises) {\n    this.pipelineUtils.createRenderPipeline(renderObject, promises);\n  }\n  createComputePipeline(computePipeline, bindings) {\n    this.pipelineUtils.createComputePipeline(computePipeline, bindings);\n  }\n  beginBundle(renderContext) {\n    const renderContextData = this.get(renderContext);\n    renderContextData._currentPass = renderContextData.currentPass;\n    renderContextData._currentSets = renderContextData.currentSets;\n    renderContextData.currentSets = {\n      attributes: {},\n      bindingGroups: [],\n      pipeline: null,\n      index: null\n    };\n    renderContextData.currentPass = this.pipelineUtils.createBundleEncoder(renderContext);\n  }\n  finishBundle(renderContext, bundle) {\n    const renderContextData = this.get(renderContext);\n    const bundleEncoder = renderContextData.currentPass;\n    const bundleGPU = bundleEncoder.finish();\n    this.get(bundle).bundleGPU = bundleGPU;\n\n    // restore render pass state\n\n    renderContextData.currentSets = renderContextData._currentSets;\n    renderContextData.currentPass = renderContextData._currentPass;\n  }\n  addBundle(renderContext, bundle) {\n    const renderContextData = this.get(renderContext);\n    renderContextData.renderBundles.push(this.get(bundle).bundleGPU);\n  }\n\n  // bindings\n\n  createBindings(bindGroup, bindings, cacheIndex, version) {\n    this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);\n  }\n  updateBindings(bindGroup, bindings, cacheIndex, version) {\n    this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);\n  }\n  updateBinding(binding) {\n    this.bindingUtils.updateBinding(binding);\n  }\n\n  // attributes\n\n  createIndexAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  createAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  createStorageAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  createIndirectStorageAttribute(attribute) {\n    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);\n  }\n  updateAttribute(attribute) {\n    this.attributeUtils.updateAttribute(attribute);\n  }\n  destroyAttribute(attribute) {\n    this.attributeUtils.destroyAttribute(attribute);\n  }\n\n  // canvas\n\n  updateSize() {\n    this.colorBuffer = this.textureUtils.getColorBuffer();\n    this.defaultRenderPassdescriptor = null;\n  }\n\n  // utils public\n\n  getMaxAnisotropy() {\n    return 16;\n  }\n  hasFeature(name) {\n    return this.device.features.has(name);\n  }\n  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {\n    let dstX = 0;\n    let dstY = 0;\n    let dstLayer = 0;\n    let srcX = 0;\n    let srcY = 0;\n    let srcLayer = 0;\n    let srcWidth = srcTexture.image.width;\n    let srcHeight = srcTexture.image.height;\n    if (srcRegion !== null) {\n      srcX = srcRegion.x;\n      srcY = srcRegion.y;\n      srcLayer = srcRegion.z || 0;\n      srcWidth = srcRegion.width;\n      srcHeight = srcRegion.height;\n    }\n    if (dstPosition !== null) {\n      dstX = dstPosition.x;\n      dstY = dstPosition.y;\n      dstLayer = dstPosition.z || 0;\n    }\n    const encoder = this.device.createCommandEncoder({\n      label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id\n    });\n    const sourceGPU = this.get(srcTexture).texture;\n    const destinationGPU = this.get(dstTexture).texture;\n    encoder.copyTextureToTexture({\n      texture: sourceGPU,\n      mipLevel: level,\n      origin: {\n        x: srcX,\n        y: srcY,\n        z: srcLayer\n      }\n    }, {\n      texture: destinationGPU,\n      mipLevel: level,\n      origin: {\n        x: dstX,\n        y: dstY,\n        z: dstLayer\n      }\n    }, [srcWidth, srcHeight, 1]);\n    this.device.queue.submit([encoder.finish()]);\n  }\n  copyFramebufferToTexture(texture, renderContext, rectangle) {\n    const renderContextData = this.get(renderContext);\n    let sourceGPU = null;\n    if (renderContext.renderTarget) {\n      if (texture.isDepthTexture) {\n        sourceGPU = this.get(renderContext.depthTexture).texture;\n      } else {\n        sourceGPU = this.get(renderContext.textures[0]).texture;\n      }\n    } else {\n      if (texture.isDepthTexture) {\n        sourceGPU = this.textureUtils.getDepthBuffer(renderContext.depth, renderContext.stencil);\n      } else {\n        sourceGPU = this.context.getCurrentTexture();\n      }\n    }\n    const destinationGPU = this.get(texture).texture;\n    if (sourceGPU.format !== destinationGPU.format) {\n      console.error('WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format);\n      return;\n    }\n    let encoder;\n    if (renderContextData.currentPass) {\n      renderContextData.currentPass.end();\n      encoder = renderContextData.encoder;\n    } else {\n      encoder = this.device.createCommandEncoder({\n        label: 'copyFramebufferToTexture_' + texture.id\n      });\n    }\n    encoder.copyTextureToTexture({\n      texture: sourceGPU,\n      origin: [rectangle.x, rectangle.y, 0]\n    }, {\n      texture: destinationGPU\n    }, [rectangle.z, rectangle.w]);\n    if (texture.generateMipmaps) this.textureUtils.generateMipmaps(texture);\n    if (renderContextData.currentPass) {\n      const {\n        descriptor\n      } = renderContextData;\n      for (let i = 0; i < descriptor.colorAttachments.length; i++) {\n        descriptor.colorAttachments[i].loadOp = GPULoadOp.Load;\n      }\n      if (renderContext.depth) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n      if (renderContext.stencil) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n      renderContextData.currentPass = encoder.beginRenderPass(descriptor);\n      renderContextData.currentSets = {\n        attributes: {},\n        bindingGroups: [],\n        pipeline: null,\n        index: null\n      };\n      if (renderContext.viewport) {\n        this.updateViewport(renderContext);\n      }\n      if (renderContext.scissor) {\n        const {\n          x,\n          y,\n          width,\n          height\n        } = renderContext.scissorValue;\n        renderContextData.currentPass.setScissorRect(x, y, width, height);\n      }\n    } else {\n      this.device.queue.submit([encoder.finish()]);\n    }\n  }\n}\nclass IESSpotLight extends SpotLight {\n  constructor(color, intensity, distance, angle, penumbra, decay) {\n    super(color, intensity, distance, angle, penumbra, decay);\n    this.iesMap = null;\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.iesMap = source.iesMap;\n    return this;\n  }\n}\nclass StandardNodeLibrary extends NodeLibrary {\n  constructor() {\n    super();\n    this.addMaterial(MeshPhongNodeMaterial, 'MeshPhongMaterial');\n    this.addMaterial(MeshStandardNodeMaterial, 'MeshStandardMaterial');\n    this.addMaterial(MeshPhysicalNodeMaterial, 'MeshPhysicalMaterial');\n    this.addMaterial(MeshToonNodeMaterial, 'MeshToonMaterial');\n    this.addMaterial(MeshBasicNodeMaterial, 'MeshBasicMaterial');\n    this.addMaterial(MeshLambertNodeMaterial, 'MeshLambertMaterial');\n    this.addMaterial(MeshNormalNodeMaterial, 'MeshNormalMaterial');\n    this.addMaterial(MeshMatcapNodeMaterial, 'MeshMatcapMaterial');\n    this.addMaterial(LineBasicNodeMaterial, 'LineBasicMaterial');\n    this.addMaterial(LineDashedNodeMaterial, 'LineDashedMaterial');\n    this.addMaterial(PointsNodeMaterial, 'PointsMaterial');\n    this.addMaterial(SpriteNodeMaterial, 'SpriteMaterial');\n    this.addMaterial(ShadowNodeMaterial, 'ShadowMaterial');\n    this.addLight(PointLightNode, PointLight);\n    this.addLight(DirectionalLightNode, DirectionalLight);\n    this.addLight(RectAreaLightNode, RectAreaLight);\n    this.addLight(SpotLightNode, SpotLight);\n    this.addLight(AmbientLightNode, AmbientLight);\n    this.addLight(HemisphereLightNode, HemisphereLight);\n    this.addLight(LightProbeNode, LightProbe);\n    this.addLight(IESSpotLightNode, IESSpotLight);\n    this.addToneMapping(linearToneMapping, LinearToneMapping);\n    this.addToneMapping(reinhardToneMapping, ReinhardToneMapping);\n    this.addToneMapping(cineonToneMapping, CineonToneMapping);\n    this.addToneMapping(acesFilmicToneMapping, ACESFilmicToneMapping);\n    this.addToneMapping(agxToneMapping, AgXToneMapping);\n    this.addToneMapping(neutralToneMapping, NeutralToneMapping);\n  }\n}\n\n/*\nconst debugHandler = {\n\n\tget: function ( target, name ) {\n\n\t\t// Add |update\n\t\tif ( /^(create|destroy)/.test( name ) ) console.log( 'WebGPUBackend.' + name );\n\n\t\treturn target[ name ];\n\n\t}\n\n};\n*/\nclass WebGPURenderer extends Renderer {\n  constructor(parameters = {}) {\n    let BackendClass;\n    if (parameters.forceWebGL) {\n      BackendClass = WebGLBackend;\n    } else {\n      BackendClass = WebGPUBackend;\n      parameters.getFallback = () => {\n        console.warn('THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.');\n        return new WebGLBackend(parameters);\n      };\n    }\n    const backend = new BackendClass(parameters);\n\n    //super( new Proxy( backend, debugHandler ) );\n    super(backend, parameters);\n    this.library = new StandardNodeLibrary();\n    this.isWebGPURenderer = true;\n  }\n}\nclass BundleGroup extends Group {\n  constructor() {\n    super();\n    this.isBundleGroup = true;\n    this.type = 'BundleGroup';\n    this.static = true;\n    this.version = 0;\n  }\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n}\nconst _material = /*@__PURE__*/new NodeMaterial();\nconst _quadMesh = /*@__PURE__*/new QuadMesh(_material);\nclass PostProcessing {\n  constructor(renderer, outputNode = vec4(0, 0, 1, 1)) {\n    this.renderer = renderer;\n    this.outputNode = outputNode;\n    this.outputColorTransform = true;\n    this.needsUpdate = true;\n    _material.name = 'PostProcessing';\n  }\n  render() {\n    this.update();\n    const renderer = this.renderer;\n    const toneMapping = renderer.toneMapping;\n    const outputColorSpace = renderer.outputColorSpace;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputColorSpace = LinearSRGBColorSpace;\n\n    //\n\n    _quadMesh.render(renderer);\n\n    //\n\n    renderer.toneMapping = toneMapping;\n    renderer.outputColorSpace = outputColorSpace;\n  }\n  update() {\n    if (this.needsUpdate === true) {\n      const renderer = this.renderer;\n      const toneMapping = renderer.toneMapping;\n      const outputColorSpace = renderer.outputColorSpace;\n      _quadMesh.material.fragmentNode = this.outputColorTransform === true ? renderOutput(this.outputNode, toneMapping, outputColorSpace) : this.outputNode.context({\n        toneMapping,\n        outputColorSpace\n      });\n      _quadMesh.material.needsUpdate = true;\n      this.needsUpdate = false;\n    }\n  }\n  async renderAsync() {\n    this.update();\n    const renderer = this.renderer;\n    const toneMapping = renderer.toneMapping;\n    const outputColorSpace = renderer.outputColorSpace;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputColorSpace = LinearSRGBColorSpace;\n\n    //\n\n    await _quadMesh.renderAsync(renderer);\n\n    //\n\n    renderer.toneMapping = toneMapping;\n    renderer.outputColorSpace = outputColorSpace;\n  }\n}\n\n// renderer state\n\nfunction saveRendererState(renderer, state = {}) {\n  state.toneMapping = renderer.toneMapping;\n  state.toneMappingExposure = renderer.toneMappingExposure;\n  state.outputColorSpace = renderer.outputColorSpace;\n  state.renderTarget = renderer.getRenderTarget();\n  state.activeCubeFace = renderer.getActiveCubeFace();\n  state.activeMipmapLevel = renderer.getActiveMipmapLevel();\n  state.renderObjectFunction = renderer.getRenderObjectFunction();\n  state.pixelRatio = renderer.getPixelRatio();\n  state.mrt = renderer.getMRT();\n  state.clearColor = renderer.getClearColor(state.clearColor || new Color());\n  state.clearAlpha = renderer.getClearAlpha();\n  state.autoClear = renderer.autoClear;\n  state.scissorTest = renderer.getScissorTest();\n  return state;\n}\nfunction resetRendererState(renderer, state) {\n  state = saveRendererState(renderer, state);\n  renderer.setMRT(null);\n  renderer.setRenderObjectFunction(null);\n  renderer.setClearColor(0x000000, 1);\n  renderer.autoClear = true;\n  return state;\n}\nfunction restoreRendererState(renderer, state) {\n  renderer.toneMapping = state.toneMapping;\n  renderer.toneMappingExposure = state.toneMappingExposure;\n  renderer.outputColorSpace = state.outputColorSpace;\n  renderer.setRenderTarget(state.renderTarget, state.activeCubeFace, state.activeMipmapLevel);\n  renderer.setRenderObjectFunction(state.renderObjectFunction);\n  renderer.setPixelRatio(state.pixelRatio);\n  renderer.setMRT(state.mrt);\n  renderer.setClearColor(state.clearColor, state.clearAlpha);\n  renderer.autoClear = state.autoClear;\n  renderer.setScissorTest(state.scissorTest);\n}\n\n// renderer and scene state\n\nfunction saveRendererAndSceneState(renderer, scene, state = {}) {\n  state = saveRendererState(renderer, state);\n  state.background = scene.background;\n  state.backgroundNode = scene.backgroundNode;\n  state.overrideMaterial = scene.overrideMaterial;\n  return state;\n}\nfunction resetRendererAndSceneState(renderer, scene, state) {\n  state = saveRendererAndSceneState(renderer, scene, state);\n  scene.background = null;\n  scene.backgroundNode = null;\n  scene.overrideMaterial = null;\n  return state;\n}\nfunction restoreRendererAndSceneState(renderer, scene, state) {\n  restoreRendererState(renderer, state);\n  scene.background = state.background;\n  scene.backgroundNode = state.backgroundNode;\n  scene.overrideMaterial = state.overrideMaterial;\n}\nvar PostProcessingUtils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  resetRendererAndSceneState: resetRendererAndSceneState,\n  resetRendererState: resetRendererState,\n  restoreRendererAndSceneState: restoreRendererAndSceneState,\n  restoreRendererState: restoreRendererState,\n  saveRendererAndSceneState: saveRendererAndSceneState,\n  saveRendererState: saveRendererState\n});\nclass StorageTexture extends Texture {\n  constructor(width = 1, height = 1) {\n    super();\n    this.image = {\n      width,\n      height\n    };\n    this.magFilter = LinearFilter;\n    this.minFilter = LinearFilter;\n    this.isStorageTexture = true;\n  }\n}\nclass IndirectStorageBufferAttribute extends StorageBufferAttribute {\n  constructor(array, itemSize) {\n    super(array, itemSize, Uint32Array);\n    this.isIndirectStorageBufferAttribute = true;\n  }\n}\nclass NodeLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.textures = {};\n    this.nodes = {};\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, text => {\n      try {\n        onLoad(this.parse(JSON.parse(text)));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        this.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parseNodes(json) {\n    const nodes = {};\n    if (json !== undefined) {\n      for (const nodeJSON of json) {\n        const {\n          uuid,\n          type\n        } = nodeJSON;\n        nodes[uuid] = this.createNodeFromType(type);\n        nodes[uuid].uuid = uuid;\n      }\n      const meta = {\n        nodes,\n        textures: this.textures\n      };\n      for (const nodeJSON of json) {\n        nodeJSON.meta = meta;\n        const node = nodes[nodeJSON.uuid];\n        node.deserialize(nodeJSON);\n        delete nodeJSON.meta;\n      }\n    }\n    return nodes;\n  }\n  parse(json) {\n    const node = this.createNodeFromType(json.type);\n    node.uuid = json.uuid;\n    const nodes = this.parseNodes(json.nodes);\n    const meta = {\n      nodes,\n      textures: this.textures\n    };\n    json.meta = meta;\n    node.deserialize(json);\n    delete json.meta;\n    return node;\n  }\n  setTextures(value) {\n    this.textures = value;\n    return this;\n  }\n  setNodes(value) {\n    this.nodes = value;\n    return this;\n  }\n  createNodeFromType(type) {\n    if (this.nodes[type] === undefined) {\n      console.error('THREE.NodeLoader: Node type not found:', type);\n      return float();\n    }\n    return nodeObject(new this.nodes[type]());\n  }\n}\nclass NodeMaterialLoader extends MaterialLoader {\n  constructor(manager) {\n    super(manager);\n    this.nodes = {};\n    this.nodeMaterials = {};\n  }\n  parse(json) {\n    const material = super.parse(json);\n    const nodes = this.nodes;\n    const inputNodes = json.inputNodes;\n    for (const property in inputNodes) {\n      const uuid = inputNodes[property];\n      material[property] = nodes[uuid];\n    }\n    return material;\n  }\n  setNodes(value) {\n    this.nodes = value;\n    return this;\n  }\n  setNodeMaterials(value) {\n    this.nodeMaterials = value;\n    return this;\n  }\n  createMaterialFromType(type) {\n    const materialClass = this.nodeMaterials[type];\n    if (materialClass !== undefined) {\n      return new materialClass();\n    }\n    return super.createMaterialFromType(type);\n  }\n}\nclass NodeObjectLoader extends ObjectLoader {\n  constructor(manager) {\n    super(manager);\n    this.nodes = {};\n    this.nodeMaterials = {};\n    this._nodesJSON = null;\n  }\n  setNodes(value) {\n    this.nodes = value;\n    return this;\n  }\n  setNodeMaterials(value) {\n    this.nodeMaterials = value;\n    return this;\n  }\n  parse(json, onLoad) {\n    this._nodesJSON = json.nodes;\n    const data = super.parse(json, onLoad);\n    this._nodesJSON = null; // dispose\n\n    return data;\n  }\n  parseNodes(json, textures) {\n    if (json !== undefined) {\n      const loader = new NodeLoader();\n      loader.setNodes(this.nodes);\n      loader.setTextures(textures);\n      return loader.parseNodes(json);\n    }\n    return {};\n  }\n  parseMaterials(json, textures) {\n    const materials = {};\n    if (json !== undefined) {\n      const nodes = this.parseNodes(this._nodesJSON, textures);\n      const loader = new NodeMaterialLoader();\n      loader.setTextures(textures);\n      loader.setNodes(nodes);\n      loader.setNodeMaterials(this.nodeMaterials);\n      for (let i = 0, l = json.length; i < l; i++) {\n        const data = json[i];\n        materials[data.uuid] = loader.parse(data);\n      }\n    }\n    return materials;\n  }\n}\nclass ClippingGroup extends Group {\n  constructor() {\n    super();\n    this.isClippingGroup = true;\n    this.clippingPlanes = [];\n    this.enabled = true;\n    this.clipIntersection = false;\n    this.clipShadows = false;\n  }\n}\nexport { ACESFilmicToneMapping, AONode, AddEquation, AddOperation, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightNode, AnalyticLightNode, ArrayElementNode, AssignNode, AttributeNode, BackSide, BasicEnvironmentNode, BasicShadowMap, BatchNode, BoxGeometry, BufferAttribute, BufferAttributeNode, BufferGeometry, BufferNode, BumpMapNode, BundleGroup, BypassNode, ByteType, CacheNode, CineonToneMapping, ClampToEdgeWrapping, ClippingGroup, CodeNode, Color, ColorManagement, ColorSpaceNode, ComputeNode, ConstNode, ContextNode, ConvertNode, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureNode, CubeUVReflectionMapping, CullFaceBack, CullFaceFront, CullFaceNone, CustomBlending, DataArrayTexture, DataTexture, DecrementStencilOp, DecrementWrapStencilOp, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightNode, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicDrawUsage, EnvironmentNode, EqualCompare, EqualDepth, EqualStencilFunc, EquirectUVNode, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExpressionNode, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, FogExp2Node, FogNode, FogRangeNode, FramebufferTexture, FrontFacingNode, FrontSide, Frustum, FunctionCallNode, FunctionNode, FunctionOverloadingNode, GLSLNodeParser, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, Group, HalfFloatType, HemisphereLight, HemisphereLightNode, IESSpotLight, IESSpotLightNode, IncrementStencilOp, IncrementWrapStencilOp, IndexNode, IndirectStorageBufferAttribute, InstanceNode, InstancedBufferAttribute, InstancedInterleavedBuffer, InstancedMeshNode, InstancedPointsNodeMaterial, IntType, InterleavedBuffer, InterleavedBufferAttribute, InvertStencilOp, IrradianceNode, JoinNode, KeepStencilOp, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, LightProbe, LightProbeNode, Lighting, LightingContextNode, LightingModel, LightingNode, LightsNode, Line2NodeMaterial, LineBasicMaterial, LineBasicNodeMaterial, LineDashedMaterial, LineDashedNodeMaterial, LinearFilter, LinearMipMapLinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, Loader, LoopNode, LuminanceAlphaFormat, LuminanceFormat, MRTNode, MatcapUVNode, Material, MaterialLoader, MaterialNode, MaterialReferenceNode, MathUtils, Matrix3, Matrix4, MaxEquation, MaxMipLevelNode, Mesh, MeshBasicMaterial, MeshBasicNodeMaterial, MeshLambertMaterial, MeshLambertNodeMaterial, MeshMatcapMaterial, MeshMatcapNodeMaterial, MeshNormalMaterial, MeshNormalNodeMaterial, MeshPhongMaterial, MeshPhongNodeMaterial, MeshPhysicalMaterial, MeshPhysicalNodeMaterial, MeshSSSNodeMaterial, MeshStandardMaterial, MeshStandardNodeMaterial, MeshToonMaterial, MeshToonNodeMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, ModelNode, ModelViewProjectionNode, MorphNode, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, Node, NodeAccess, NodeAttribute, NodeBuilder, NodeCache, NodeCode, NodeFrame, NodeFunctionInput, NodeLoader, NodeMaterial, NodeMaterialLoader, NodeMaterialObserver, NodeObjectLoader, NodeShaderStage, NodeType, NodeUniform, NodeUpdateType, NodeUtils, NodeVar, NodeVarying, NormalBlending, NormalMapNode, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, Object3D, Object3DNode, ObjectLoader, ObjectSpaceNormalMap, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, OutputStructNode, PCFShadowMap, PMREMGenerator, PMREMNode, ParameterNode, PassNode, PerspectiveCamera, PhongLightingModel, PhysicalLightingModel, Plane, PointLight, PointLightNode, PointUVNode, PointsMaterial, PointsNodeMaterial, PostProcessing, PostProcessingUtils, PosterizeNode, PropertyNode, QuadMesh, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBFormat, RGBIntegerFormat, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RTTNode, RangeNode, RectAreaLight, RectAreaLightNode, RedFormat, RedIntegerFormat, ReferenceNode, ReflectorNode, ReinhardToneMapping, RemapNode, RenderOutputNode, RenderTarget, RendererReferenceNode, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RotateNode, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, SceneNode, ScreenNode, ScriptableNode, ScriptableValueNode, SetNode, ShadowMaterial, ShadowNode, ShadowNodeMaterial, ShortType, SkinningNode, SphereGeometry, SplitNode, SpotLight, SpotLightNode, SpriteMaterial, SpriteNodeMaterial, SpriteSheetUVNode, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StackNode, StaticDrawUsage, StorageArrayElementNode, StorageBufferAttribute, StorageBufferNode, StorageInstancedBufferAttribute, StorageTexture, StorageTextureNode, SubtractEquation, SubtractiveBlending, TSL, TangentSpaceNormalMap, TempNode, Texture, Texture3DNode, TextureNode, TextureSizeNode, ToneMappingNode, ToonOutlinePassNode, TriplanarTexturesNode, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, UniformArrayNode, UniformGroupNode, UniformNode, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, UserDataNode, VSMShadowMap, VarNode, VaryingNode, Vector2, Vector3, Vector4, VertexColorNode, ViewportDepthNode, ViewportDepthTextureNode, ViewportSharedTextureNode, ViewportTextureNode, VolumeNodeMaterial, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGPUCoordinateSystem, WebGPURenderer, ZeroFactor, ZeroStencilOp, createCanvasElement, defaultBuildStages, defaultShaderStages, shaderStages, vectorComponents };","map":{"version":3,"names":["Color","Vector2","Vector3","Vector4","Matrix3","Matrix4","EventDispatcher","MathUtils","ColorManagement","SRGBTransfer","NoToneMapping","StaticDrawUsage","InterleavedBuffer","DynamicDrawUsage","InterleavedBufferAttribute","NoColorSpace","UnsignedIntType","IntType","WebGLCoordinateSystem","BackSide","CubeReflectionMapping","CubeRefractionMapping","WebGPUCoordinateSystem","TangentSpaceNormalMap","ObjectSpaceNormalMap","InstancedInterleavedBuffer","InstancedBufferAttribute","DataArrayTexture","FloatType","FramebufferTexture","LinearMipmapLinearFilter","DepthTexture","Material","NormalBlending","PointsMaterial","LineBasicMaterial","LineDashedMaterial","NoBlending","MeshNormalMaterial","WebGLCubeRenderTarget","BoxGeometry","Mesh","Scene","LinearFilter","CubeCamera","CubeTexture","EquirectangularReflectionMapping","EquirectangularRefractionMapping","AddOperation","MixOperation","MultiplyOperation","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","Texture","MeshStandardMaterial","MeshPhysicalMaterial","MeshToonMaterial","MeshMatcapMaterial","SpriteMaterial","ShadowMaterial","Uint32BufferAttribute","Uint16BufferAttribute","DoubleSide","DepthStencilFormat","DepthFormat","UnsignedInt248Type","UnsignedByteType","RenderTarget","Plane","Object3D","HalfFloatType","LinearMipMapLinearFilter","OrthographicCamera","BufferGeometry","Float32BufferAttribute","BufferAttribute","UVMapping","Euler","LinearSRGBColorSpace","LessCompare","VSMShadowMap","RGFormat","BasicShadowMap","SphereGeometry","CubeUVReflectionMapping","PerspectiveCamera","RGBAFormat","LinearMipmapNearestFilter","NearestMipmapLinearFilter","Float16BufferAttribute","REVISION","SRGBColorSpace","PCFShadowMap","FrontSide","Frustum","DataTexture","RedIntegerFormat","RedFormat","RGIntegerFormat","RGBIntegerFormat","RGBFormat","RGBAIntegerFormat","UnsignedShortType","ByteType","ShortType","createCanvasElement","AddEquation","SubtractEquation","ReverseSubtractEquation","ZeroFactor","OneFactor","SrcColorFactor","SrcAlphaFactor","SrcAlphaSaturateFactor","DstColorFactor","DstAlphaFactor","OneMinusSrcColorFactor","OneMinusSrcAlphaFactor","OneMinusDstColorFactor","OneMinusDstAlphaFactor","CullFaceNone","CullFaceBack","CullFaceFront","CustomBlending","MultiplyBlending","SubtractiveBlending","AdditiveBlending","NotEqualDepth","GreaterDepth","GreaterEqualDepth","EqualDepth","LessEqualDepth","LessDepth","AlwaysDepth","NeverDepth","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedInt5999Type","AlphaFormat","LuminanceFormat","LuminanceAlphaFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_ETC1_Format","RGB_ETC2_Format","RGBA_ETC2_EAC_Format","RGBA_ASTC_4x4_Format","RGBA_ASTC_5x4_Format","RGBA_ASTC_5x5_Format","RGBA_ASTC_6x5_Format","RGBA_ASTC_6x6_Format","RGBA_ASTC_8x5_Format","RGBA_ASTC_8x6_Format","RGBA_ASTC_8x8_Format","RGBA_ASTC_10x5_Format","RGBA_ASTC_10x6_Format","RGBA_ASTC_10x8_Format","RGBA_ASTC_10x10_Format","RGBA_ASTC_12x10_Format","RGBA_ASTC_12x12_Format","RGBA_BPTC_Format","RED_RGTC1_Format","SIGNED_RED_RGTC1_Format","RED_GREEN_RGTC2_Format","SIGNED_RED_GREEN_RGTC2_Format","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipmapNearestFilter","NeverCompare","AlwaysCompare","LessEqualCompare","EqualCompare","GreaterEqualCompare","GreaterCompare","NotEqualCompare","warnOnce","NotEqualStencilFunc","GreaterStencilFunc","GreaterEqualStencilFunc","EqualStencilFunc","LessEqualStencilFunc","LessStencilFunc","AlwaysStencilFunc","NeverStencilFunc","DecrementWrapStencilOp","IncrementWrapStencilOp","DecrementStencilOp","IncrementStencilOp","InvertStencilOp","ReplaceStencilOp","ZeroStencilOp","KeepStencilOp","MaxEquation","MinEquation","SpotLight","PointLight","DirectionalLight","RectAreaLight","AmbientLight","HemisphereLight","LightProbe","LinearToneMapping","ReinhardToneMapping","CineonToneMapping","ACESFilmicToneMapping","AgXToneMapping","NeutralToneMapping","Group","Loader","FileLoader","MaterialLoader","ObjectLoader","AdditiveAnimationBlendMode","AnimationAction","AnimationClip","AnimationLoader","AnimationMixer","AnimationObjectGroup","AnimationUtils","ArcCurve","ArrayCamera","ArrowHelper","AttachedBindMode","Audio","AudioAnalyser","AudioContext","AudioListener","AudioLoader","AxesHelper","BasicDepthPacking","BatchedMesh","Bone","BooleanKeyframeTrack","Box2","Box3","Box3Helper","BoxHelper","BufferGeometryLoader","Cache","Camera","CameraHelper","CanvasTexture","CapsuleGeometry","CatmullRomCurve3","CircleGeometry","Clock","ColorKeyframeTrack","CompressedArrayTexture","CompressedCubeTexture","CompressedTexture","CompressedTextureLoader","ConeGeometry","ConstantAlphaFactor","ConstantColorFactor","Controls","CubeTextureLoader","CubicBezierCurve","CubicBezierCurve3","CubicInterpolant","CullFaceFrontBack","Curve","CurvePath","CustomToneMapping","CylinderGeometry","Cylindrical","Data3DTexture","DataTextureLoader","DataUtils","DefaultLoadingManager","DetachedBindMode","DirectionalLightHelper","DiscreteInterpolant","DodecahedronGeometry","DynamicCopyUsage","DynamicReadUsage","EdgesGeometry","EllipseCurve","ExtrudeGeometry","Fog","FogExp2","GLBufferAttribute","GLSL1","GLSL3","GridHelper","HemisphereLightHelper","IcosahedronGeometry","ImageBitmapLoader","ImageLoader","ImageUtils","InstancedBufferGeometry","InstancedMesh","Int16BufferAttribute","Int32BufferAttribute","Int8BufferAttribute","Interpolant","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","KeyframeTrack","LOD","LatheGeometry","Layers","Light","Line","Line3","LineCurve","LineCurve3","LineLoop","LineSegments","LinearInterpolant","LinearMipMapNearestFilter","LinearTransfer","LoaderUtils","LoadingManager","LoopOnce","LoopPingPong","LoopRepeat","MOUSE","Matrix2","MeshDepthMaterial","MeshDistanceMaterial","NearestMipMapLinearFilter","NearestMipMapNearestFilter","NormalAnimationBlendMode","NumberKeyframeTrack","OctahedronGeometry","OneMinusConstantAlphaFactor","OneMinusConstantColorFactor","PCFSoftShadowMap","Path","PlaneGeometry","PlaneHelper","PointLightHelper","Points","PolarGridHelper","PolyhedronGeometry","PositionalAudio","PropertyBinding","PropertyMixer","QuadraticBezierCurve","QuadraticBezierCurve3","Quaternion","QuaternionKeyframeTrack","QuaternionLinearInterpolant","RGBADepthPacking","RGBDepthPacking","RGB_BPTC_SIGNED_Format","RGB_BPTC_UNSIGNED_Format","RGDepthPacking","RawShaderMaterial","Ray","Raycaster","RingGeometry","ShaderMaterial","Shape","ShapeGeometry","ShapePath","ShapeUtils","Skeleton","SkeletonHelper","SkinnedMesh","Source","Sphere","Spherical","SphericalHarmonics3","SplineCurve","SpotLightHelper","Sprite","StaticCopyUsage","StaticReadUsage","StereoCamera","StreamCopyUsage","StreamDrawUsage","StreamReadUsage","StringKeyframeTrack","TOUCH","TetrahedronGeometry","TextureLoader","TextureUtils","TorusGeometry","TorusKnotGeometry","Triangle","TriangleFanDrawMode","TriangleStripDrawMode","TrianglesDrawMode","TubeGeometry","Uint8BufferAttribute","Uint8ClampedBufferAttribute","Uniform","UniformsGroup","VectorKeyframeTrack","VideoTexture","WebGL3DRenderTarget","WebGLArrayRenderTarget","WebGLMultipleRenderTargets","WebGLRenderTarget","WireframeGeometry","WrapAroundEnding","ZeroCurvatureEnding","ZeroSlopeEnding","refreshUniforms","NodeMaterialObserver","constructor","builder","renderObjects","WeakMap","hasNode","containsNode","hasAnimation","object","isSkinnedMesh","renderId","firstInitialization","renderObject","hasInitialized","has","getRenderObjectData","data","get","undefined","geometry","material","getMaterialData","attributes","getAttributesData","indexVersion","index","version","drawRange","start","count","worldMatrix","matrixWorld","clone","center","morphTargetInfluences","slice","bundle","transmission","width","height","context","bufferWidth","bufferHeight","set","attributesData","name","attribute","property","isNode","renderer","nodes","modelViewMatrix","modelNormalViewMatrix","value","isTexture","id","equals","renderObjectData","copy","materialData","mtlValue","storedGeometryData","storedAttributes","storedAttributeNames","Object","keys","currentAttributeNames","length","storedAttributeData","storedIndexVersion","currentIndexVersion","morphChanged","i","needsRefresh","nodeFrame","isStatic","static","isBundle","notEqual","cyrb53","seed","h1","h2","Array","val","Math","imul","ch","charCodeAt","hashString","str","hashArray","array","hash$1","params","getCacheKey$1","force","values","push","getSelf","childNode","getNodeChildren","getCacheKey","node","toJSON","startsWith","isArray","child","subProperty","typeFromLength","Map","getTypeFromLength","getLengthFromType","type","test","console","error","getValueType","typeOf","isVector2","isVector3","isVector4","isMatrix3","isMatrix4","isColor","ArrayBuffer","getValueFromType","last4","base64ToArrayBuffer","arrayBufferToBase64","arrayBuffer","chars","Uint8Array","String","fromCharCode","btoa","base64","from","atob","c","buffer","NodeUtils","freeze","__proto__","hash","NodeShaderStage","VERTEX","FRAGMENT","NodeUpdateType","NONE","FRAME","RENDER","OBJECT","NodeType","BOOLEAN","INTEGER","FLOAT","VECTOR2","VECTOR3","VECTOR4","MATRIX2","MATRIX3","MATRIX4","NodeAccess","READ_ONLY","WRITE_ONLY","READ_WRITE","defaultShaderStages","defaultBuildStages","shaderStages","vectorComponents","_nodeId","Node","nodeType","updateType","updateBeforeType","updateAfterType","uuid","generateUUID","_cacheKey","_cacheKeyVersion","global","defineProperty","needsUpdate","onUpdate","callback","update","bind","onFrameUpdate","onRenderUpdate","onObjectUpdate","onReference","updateReference","self","isGlobal","getChildren","dispose","dispatchEvent","traverse","getScope","getHash","getUpdateType","getUpdateBeforeType","getUpdateAfterType","getElementType","getNodeType","elementType","nodeProperties","getNodeProperties","outputNode","getShared","nodeFromHash","getNodeFromHash","setup","analyze","usageCount","increaseUsage","build","generate","output","updateBefore","warn","updateAfter","refNode","addNode","addChain","result","buildStage","getBuildStage","properties","initialized","stackNodesBeforeSetup","stack","isGenerateOnce","nodeData","getDataFromNode","snippet","flowCodes","nodeBlock","addFlowCodeHierarchy","format","removeChain","addSequentialNode","getSerializeChildren","serialize","json","nodeChildren","inputNodes","Number","isInteger","meta","deserialize","inputArray","inputObject","isRoot","textures","images","metadata","generator","extractFromCache","cache","key","ArrayElementNode","indexNode","isArrayElementNode","nodeSnippet","indexSnippet","ConvertNode","convertTo","requestType","overloadingType","split","getTypeLength","TempNode","isTempNode","hasDependencies","getVectorType","propertyName","nodeVar","getVarFromNode","getPropertyName","addLineFlowCode","JoinNode","reduce","cur","primitiveType","getComponentType","snippetValues","input","inputSnippet","inputPrimitiveType","getType","join","stringVectorComponents","SplitNode","components","isSplitNode","getVectorLength","vectorLength","max","indexOf","nodeTypeLength","componentsLength","SetNode","sourceNode","targetNode","sourceType","targetType","targetSnippet","sourceSnippet","component","FlipNode","sourceCache","sourceProperty","componentIndex","InputNode","isInputNode","precision","getInputType","setPrecision","toArray","valueType","fromArray","ConstNode","isConstNode","generateConst","currentStack","NodeElements","addMethodChaining","nodeElement","Error","parseSwizzle","props","replace","parseSwizzleAndSort","sort","shaderNodeHandler","NodeClosure","inputs","shift","nodeObjects","prop","nodeObj","isStackNode","assign","add","endsWith","nodeObject","toLowerCase","Reflect","nodeObjectsCacheMap","nodeBuilderFunctionsCacheMap","ShaderNodeObject","obj","altType","Proxy","getConstNode","Fn","ShaderNodeObjects","objects","ShaderNodeArray","len","ShaderNodeProxy","NodeClass","scope","factor","settings","assignNode","nodeArray","ShaderNodeImmutable","ShaderCallNodeInternal","shaderNode","getOutputNode","call","onceOutput","layout","functionNodesCacheMap","functionNode","buildFunctionNode","currentFunctionNode","includes","jsFunc","once","setupOutput","addStack","removeStack","ShaderNodeInternal","setLayout","bools","uints","ints","floats","PI","boolsCacheMap","bool","uintsCacheMap","uint","intsCacheMap","map","el","int","floatsCacheMap","float","cacheMaps","constNodesCacheMap","safeGetNodeType","_","ConvertType","cacheMap","every","param","defined","v","getConstNodeType","ShaderNode","nodeProxy","nodeImmutable","fn","tslFn","setCurrentStack","getCurrentStack","If","append","color","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat2","mat3","mat4","string","element","convert","types","channels","UniformGroupNode","shared","order","isUniformGroup","uniformGroup","sharedUniformGroup","frameGroup","renderGroup","objectGroup","UniformNode","isUniformNode","groupNode","label","setGroup","group","getGroup","getUniformHash","frame","sharedNode","setHashNode","sharedNodeType","nodeUniform","getUniformFromNode","shaderStage","uniform","arg1","arg2","PropertyNode","varying","isPropertyNode","getVaryingFromNode","needsInterpolation","varyingProperty","diffuseColor","emissive","roughness","metalness","clearcoat","clearcoatRoughness","sheen","sheenRoughness","iridescence","iridescenceIOR","iridescenceThickness","alphaT","anisotropy","anisotropyT","anisotropyB","specularColor","specularF90","shininess","dashSize","gapSize","pointWidth","ior","thickness","attenuationDistance","attenuationColor","dispersion","AssignNode","needsSplitAssign","isAvailable","targetLength","assignDiferentVector","target","source","sourceVar","targetRoot","FunctionCallNode","parameters","setParameters","getParameters","getInputs","generateInput","inputNode","pointer","functionName","func","OperatorNode","op","aNode","bNode","finalOp","typeA","typeB","getIntegerType","typeLength","isMatrix","isVector","getVectorFromMatrix","changeComponentType","a","b","outputLength","fnOpSnippet","getFunctionOperator","useComparisonMethod","getMethod","sub","mul","div","modInt","equal","lessThan","greaterThan","lessThanEqual","greaterThanEqual","and","or","not","xor","bitAnd","bitNot","bitOr","bitXor","shiftLeft","shiftRight","remainder","MathNode","method","cNode","aType","bType","cType","aLen","bLen","cLen","LENGTH","DISTANCE","DOT","CROSS","ALL","EQUALS","MOD","inputType","isWebGL","isWebGLRenderer","TRANSFORM_DIRECTION","tA","tB","mulNode","xyz","normalize","NEGATE","ONE_MINUS","RECIPROCAL","DIFFERENCE","abs","STEP","MIN","MAX","REFRACT","MIX","ANY","RADIANS","DEGREES","EXP","EXP2","LOG","LOG2","SQRT","INVERSE_SQRT","FLOOR","CEIL","NORMALIZE","FRACT","SIN","COS","TAN","ASIN","ACOS","ATAN","ABS","SIGN","DFDX","DFDY","ROUND","TRUNC","FWIDTH","BITCAST","TRANSPOSE","ATAN2","REFLECT","POW","CLAMP","SMOOTHSTEP","FACEFORWARD","EPSILON","INFINITY","PI2","all","any","radians","degrees","exp","exp2","log","log2","sqrt","inverseSqrt","floor","ceil","fract","sin","cos","tan","asin","acos","atan","sign","negate","oneMinus","dFdx","dFdy","round","reciprocal","trunc","fwidth","bitcast","transpose","atan2","min$1","max$1","mod","step","reflect","distance","difference","dot","cross","pow","pow2","pow3","pow4","transformDirection","cbrt","lengthSq","mix","clamp","low","high","saturate","refract","smoothstep","faceForward","rand","uv","dt","xy","sn","mixElement","t","e1","e2","smoothstepElement","x","ConditionalNode","condNode","ifNode","elseNode","ifType","elseType","currentNodeBlock","parentNodeBlock","nodeProperty","needsOutput","addFlowCode","tab","addFlowTab","ifSnippet","removeFlowTab","elseSnippet","select","cond","ContextNode","isContextNode","previousContext","getContext","setContext","VarNode","isVarNode","createVar","temp","VaryingNode","isVaryingNode","setupVarying","flowNodeFromShaderStage","sRGBTransferEOTF","rgbResult","sRGBTransferOETF","WORKING_COLOR_SPACE","OUTPUT_COLOR_SPACE","ColorSpaceNode","colorNode","resolveColorSpace","colorSpace","workingColorSpace","outputColorSpace","enabled","getTransfer","rgb","getPrimaries","_getMatrix","toOutputColorSpace","toWorkingColorSpace","workingToColorSpace","colorSpaceToWorking","convertColorSpace","sourceColorSpace","targetColorSpace","ReferenceElementNode$1","ReferenceElementNode","referenceNode","isReferenceElementNode","uniformType","arrayType","ReferenceBaseNode","reference","setNodeType","updateValue","getValueFromReference","state","reference$1","RendererReferenceNode","rendererReference","ToneMappingNode","toneMapping","exposureNode","toneMappingExposure","toneMappingFn","library","getToneMappingFunction","mapping","exposure","BufferAttributeNode","bufferType","bufferStride","bufferOffset","isBufferNode","usage","instanced","isBufferAttribute","isInstancedBufferAttribute","bufferData","globalCache","getData","setData","getTypeFromAttribute","itemSize","stride","offset","isInterleavedBuffer","bufferAttribute","setUsage","nodeAttribute","getBufferAttributeFromNode","nodeVarying","setInstanced","dynamicBufferAttribute","instancedBufferAttribute","instancedDynamicBufferAttribute","bufferNode","ComputeNode","computeNode","workgroupSize","isComputeNode","dispatchCount","onInitFunction","updateDispatchCount","size","onInit","compute","CacheNode","parent","isCacheNode","previousCache","getCache","getCacheFromNode","setCache","BypassNode","returnNode","callNode","isBypassNode","bypass","RemapNode","inLowNode","inHighNode","outLowNode","outHighNode","doClamp","remap","remapClamp","ExpressionNode","expression","Discard","conditional","Return","RenderOutputNode","isRenderOutput","renderOutput","addNodeElement","AttributeNode","attributeName","_attributeName","getAttributeName","hasGeometryAttribute","getAttribute","setAttributeName","geometryAttribute","attributeType","TextureSizeNode","textureNode","levelNode","isTextureSizeNode","textureProperty","level","textureSize","MaxMipLevelNode","_textureNode","texture","image","maxMipLevel","TextureNode","uvNode","biasNode","isTextureNode","compareNode","depthNode","gradNode","sampler","updateMatrix","_value","_matrixUniform","setUpdateMatrix","isDepthTexture","getDefaultUV","channel","getTransformedUV","matrix","setupUV","isFlipY","ImageBitmap","flipY","isRenderTargetTexture","isFramebufferTexture","setY","y","forceUVContext","getUV","getTextureLevel","generateUV","generateSnippet","uvSnippet","levelSnippet","biasSnippet","depthSnippet","compareSnippet","gradSnippet","generateTextureLevel","generateTextureBias","generateTextureGrad","generateTextureCompare","generateTextureLoad","generateTexture","isReference","needsToWorkingColorSpace","setSampler","getSampler","blur","amountNode","bias","compare","grad","gradNodeX","gradNodeY","depth","matrixUniform","matrixAutoUpdate","newNode","textureLoad","aTexture","cameraNear","camera","near","cameraFar","far","cameraProjectionMatrix","projectionMatrix","cameraProjectionMatrixInverse","projectionMatrixInverse","cameraViewMatrix","matrixWorldInverse","cameraWorldMatrix","cameraNormalMatrix","normalMatrix","cameraPosition","setFromMatrixPosition","Object3DNode","object3d","_uniformNode","WORLD_MATRIX","POSITION","VIEW_POSITION","DIRECTION","SCALE","uniformNode","setFromMatrixScale","getWorldDirection","applyMatrix4","objectDirection","objectWorldMatrix","objectPosition","objectScale","objectViewPosition","ModelNode","modelDirection","modelWorldMatrix","modelPosition","modelScale","modelViewPosition","modelNormalMatrix","getNormalMatrix","modelWorldMatrixInverse","invert","toVar","highPrecisionModelViewMatrix","isHighPrecisionModelViewMatrix","multiplyMatrices","highPrecisionModelNormalViewMatrix","positionGeometry","positionLocal","positionPrevious","positionWorld","positionWorldDirection","positionView","positionViewDirection","FrontFacingNode","isFrontFacingNode","coordinateSystem","side","getFrontFacing","frontFacing","faceDirection","normalGeometry","normalLocal","hasAttribute","normalFlat","normalView","flatShading","transformNormalToView","normalWorld","transformedNormalView","setupNormal","transformedNormalWorld","transformedClearcoatNormalView","setupClearcoatNormal","transformNormal","normal","m","transformedNormal","materialRefractionRatio","refractionRatio","reflectView","refractView","reflectVector","refractVector","CubeTextureNode","isCubeTextureNode","yz","cubeUV","cubeTexture","BufferNode","bufferCount","UniformArrayElementNode","isArrayBufferElementNode","UniformArrayNode","_elementType","_elementLength","isArrayBufferNode","getElementLength","elementLength","vector","r","g","z","w","Float32Array","charAt","Int32Array","Uint32Array","uniformArray","uniforms","ReferenceNode","referenceBuffer","MaterialReferenceNode","isMaterialReferenceNode","materialReference","tangentGeometry","computeTangents","tangentLocal","tangentView","tangentWorld","transformedTangentView","transformedTangentWorld","getBitangent","crossNormalTangent","bitangentGeometry","bitangentLocal","bitangentView","bitangentWorld","transformedBitangentView","transformedBitangentWorld","TBNViewMatrix","parallaxDirection","parallaxUV","scale","transformedBentNormalView","bentNormal","perturbNormal2Arb","eye_pos","surf_norm","mapN","q0","q1","st0","st1","N","q1perp","q0perp","T","B","det","NormalMapNode","scaleNode","normalMapType","normalMap","tangent","dHdxy_fwd","bumpScale","sampleTexture","texNode","Hll","perturbNormalArb","surf_pos","dHdxy","vSigmaX","vSigmaY","vN","R1","R2","fDet","vGrad","BumpMapNode","bumpMap","_propertyCache","MaterialNode","getFloat","getColor","getTexture","COLOR","OPACITY","opacityNode","alphaMap","SPECULAR_STRENGTH","specularMap","SPECULAR_INTENSITY","specularIntensity","SPECULAR_COLOR","specularColorNode","specularColorMap","ROUGHNESS","roughnessNode","roughnessMap","METALNESS","metalnessNode","metalnessMap","EMISSIVE","emissiveIntensityNode","emissiveNode","emissiveMap","NORMAL","CLEARCOAT","clearcoatNode","clearcoatMap","CLEARCOAT_ROUGHNESS","clearcoatRoughnessNode","clearcoatRoughnessMap","CLEARCOAT_NORMAL","clearcoatNormalMap","SHEEN","sheenNode","sheenColorMap","SHEEN_ROUGHNESS","sheenRoughnessNode","sheenRoughnessMap","ANISOTROPY","anisotropyMap","anisotropyPolar","anisotropyMat","materialAnisotropyVector","rg","IRIDESCENCE_THICKNESS","iridescenceThicknessMaximum","iridescenceThicknessRange","iridescenceThicknessMap","iridescenceThicknessMinimum","TRANSMISSION","transmissionNode","transmissionMap","THICKNESS","thicknessNode","thicknessMap","IOR","LIGHT_MAP","AO_MAP","outputType","ALPHA_TEST","SHININESS","SPECULAR","REFLECTIVITY","ROTATION","IRIDESCENCE","IRIDESCENCE_IOR","ATTENUATION_DISTANCE","ATTENUATION_COLOR","LINE_SCALE","LINE_DASH_SIZE","LINE_GAP_SIZE","LINE_WIDTH","LINE_DASH_OFFSET","POINT_WIDTH","DISPERSION","materialAlphaTest","materialColor","materialShininess","materialEmissive","materialOpacity","materialSpecular","materialSpecularIntensity","materialSpecularColor","materialSpecularStrength","materialReflectivity","materialRoughness","materialMetalness","materialNormal","materialClearcoat","materialClearcoatRoughness","materialClearcoatNormal","materialRotation","materialSheen","materialSheenRoughness","materialAnisotropy","materialIridescence","materialIridescenceIOR","materialIridescenceThickness","materialTransmission","materialThickness","materialIOR","materialAttenuationDistance","materialAttenuationColor","materialLineScale","materialLineDashSize","materialLineGapSize","materialLineWidth","materialLineDashOffset","materialPointWidth","materialDispersion","materialLightMap","materialAOMap","anisotropyRotation","ModelViewProjectionNode","positionNode","mvp","position","viewMatrix","modelViewProjection","IndexNode","isInstanceIndexNode","getVertexIndex","INSTANCE","getInstanceIndex","DRAW","getDrawIndex","INVOCATION_LOCAL","getInvocationLocalIndex","INVOCATION_SUBGROUP","getInvocationSubgroupIndex","SUBGROUP","getSubgroupIndex","vertexIndex","instanceIndex","subgroupIndex","invocationSubgroupIndex","invocationLocalIndex","drawIndex","InstanceNode","instanceMatrix","instanceColor","instanceMatrixNode","instanceColorNode","bufferColor","bufferFn","instanceBuffers","instancePosition","instanceNormal","instance","InstancedMeshNode","instanceMesh","instancedMesh","BatchNode","batchMesh","batchingIdNode","getIndirectIndex","_indirectTexture","indirectId","matricesTexture","_matricesTexture","j","toInt","batchingMatrix","colorsTexture","_colorsTexture","getBatchingColor","bm","batchingNormal","mulAssign","batch","_frameId","SkinningNode","skinnedMesh","useReference","skinIndexNode","skinWeightNode","bindMatrixNode","bindMatrixInverseNode","boneMatricesNode","skeleton","bones","bindMatrix","bindMatrixInverse","boneMatrices","previousBoneMatricesNode","getSkinnedPosition","boneMatX","boneMatY","boneMatZ","boneMatW","skinVertex","skinned","getSkinnedNormal","skinMatrix","getPreviousSkinnedPosition","previousBoneMatrices","needsPreviousBoneMatrices","mrt","getMRT","skinPosition","skinNormal","frameId","skinning","skinningReference","LoopNode","getVarName","getProperties","stackNode","l","returnsNode","end","condition","internalParam","startSnippet","endSnippet","declarationSnippet","conditionalSnippet","updateSnippet","getVar","forSnippet","stackSnippet","returnsSnippet","Loop","Continue","Break","loop","_morphTextures","_morphVec4","getMorph","bufferMap","influence","texelIndex","bufferAttrib","getEntry","hasMorphPosition","morphAttributes","hasMorphNormals","hasMorphColors","morphAttribute","morphTargetsCount","entry","morphTargets","morphNormals","morphColors","vertexDataCount","maxTextureSize","bufferTexture","vertexDataStride","morphTarget","morphNormal","morphColor","fromBufferAttribute","disposeTexture","delete","removeEventListener","addEventListener","MorphNode","mesh","morphBaseInfluence","morphTexture","addAssign","morphTargetsRelative","morphReference","LightingNode","isLightingNode","AONode","aoNode","ambientOcclusion","LightingContextNode","lightingModel","backdropNode","backdropAlphaNode","directDiffuse","directSpecular","indirectDiffuse","indirectSpecular","reflectedLight","radiance","irradiance","iblIrradiance","backdrop","backdropAlpha","lightingContext","IrradianceNode","screenSizeVec","viewportVec","ScreenNode","isViewportNode","VIEWPORT","SIZE","renderTarget","getRenderTarget","viewport","getViewport","multiplyScalar","getPixelRatio","getDrawingBufferSize","screenCoordinate","screenSize","COORDINATE","coord","getFragCoord","UV","screenUV","viewportSize","zw","viewportCoordinate","viewportUV","viewportResolution","viewportTopLeft","viewportBottomLeft","_size$4","ViewportTextureNode","framebufferTexture","minFilter","generateMipmaps","isOutputTextureNode","currentGenerateMipmaps","copyFramebufferToTexture","viewportTextureNode","viewportTexture","viewportMipTexture","sharedDepthbuffer","ViewportDepthTextureNode","viewportDepthTexture","ViewportDepthNode","valueNode","isViewportDepthNode","DEPTH_BASE","getFragDepth","depthBase","DEPTH","isPerspectiveCamera","viewZToPerspectiveDepth","viewZToOrthographicDepth","LINEAR_DEPTH","viewZ","perspectiveDepthToViewZ","orthographicDepthToViewZ","viewZToLogarithmicDepth","numerator","denominator","logarithmicDepthToViewZ","exponent","E","linearDepth","viewportLinearDepth","BuiltinNode","isBuiltinNode","builtin","ClippingNode","DEFAULT","clippingContext","intersectionPlanes","unionPlanes","hardwareClipping","ALPHA_TO_COVERAGE","setupAlphaToCoverage","HARDWARE","setupHardwareClipping","setupDefault","distanceToPlane","distanceGradient","clipOpacity","numUnionPlanes","clippingPlanes","plane","numIntersectionPlanes","intersectionClipOpacity","discard","clipped","enableHardwareClipping","hw_clip_distances","getClipDistance","clipping","clippingAlpha","ALPHA_HASH_SCALE","hash2D","hash3D","getAlphaHashThreshold","maxDeriv","pixScale","pixScales","alpha","lerpFactor","cases","threshold","NodeMaterial","isNodeMaterial","forceSinglePass","fog","lights","lightsNode","envNode","normalNode","alphaTestNode","geometryNode","shadowPositionNode","receivedShadowNode","castShadowNode","mrtNode","fragmentNode","vertexNode","customProgramCacheKey","setupObserver","setupPosition","addFlow","resultNode","clippingNode","setupClipping","depthWrite","depthBuffer","setupDepth","setupDiffuseColor","setupVariants","outgoingLightNode","setupLighting","basicOutput","materialMRT","merge","isOutputStructNode","monitor","samples","alphaToCoverage","candidateCount","logarithmicDepthBuffer","displacementMap","displacementScale","displacementBias","isBatchedMesh","isInstancedMesh","vertex","vertexColors","batchColor","alphaTest","alphaHash","transparent","blending","setupOutgoingLight","setupEnvironment","envMap","isCubeTexture","setupLightMap","lightMap","setupLights","materialLightsNode","lightMapNode","aoMap","lightsN","lighting","createNode","getLights","setupLightingModel","hasLights","fogNode","setDefaultValues","descriptors","getOwnPropertyDescriptors","prototype","getOwnPropertyDescriptor","_defaultValues$e","InstancedPointsNodeMaterial","useAlphaToCoverage","useColor","pointColorNode","pointWidthNode","setValues","setupShaders","mvPos","aspect","clipPos","len2","dlen","_defaultValues$d","LineBasicNodeMaterial","isLineBasicNodeMaterial","_defaultValues$c","LineDashedNodeMaterial","isLineDashedNodeMaterial","dashOffset","offsetNode","dashScaleNode","dashSizeNode","gapSizeNode","offsetNodeNode","dashGapNode","vLineDistance","vLineDistanceOffset","_sharedFramebuffer","ViewportSharedTextureNode","viewportSharedTexture","_defaultValues$b","Line2NodeMaterial","useDash","dashed","useWorldUnits","lineWidth","lineColorNode","worldUnits","trimSegment","nearEstimate","instanceStart","instanceEnd","instanceDistanceStart","instanceDistanceEnd","lineDistance","perspective","ElseIf","clipStart","clipEnd","ndcStart","ndcEnd","dir","clip","worldDir","tmpFwd","worldUp","worldFwd","worldPos","hw","subAssign","clipPose","closestLineToLine","p1","p2","p3","p4","p13","p43","p21","d1343","d4321","d1321","d4343","d2121","denom","numer","mua","mub","vUv","worldStart","worldEnd","rayEnd","lineDir","delta","norm","dnorm","instanceColorStart","instanceColorEnd","directionToColor","colorToDirection","_defaultValues$a","MeshNormalNodeMaterial","isMeshNormalNodeMaterial","EquirectUVNode","dirNode","u","equirectUV","CubeRenderTarget","options","isCubeRenderTarget","fromEquirectangularTexture","texture$1","currentMinFilter","magFilter","scene","currentMRT","setMRT","_cache$1","CubeMapNode","_cubeTexture","_cubeTextureNode","defaultTexture","_defaultTexture","cubeMap","mapTextureMapping","isEquirectangularMapReady$1","onTextureDispose","event","cubeMapNode","BasicEnvironmentNode","environment","BasicLightMapNode","RECIPROCAL_PI","irradianceLightMap","LightingModel","finish","direct","directRectArea","indirect","BasicLightingModel","outgoingLight","combine","_defaultValues$9","MeshBasicNodeMaterial","isMeshBasicNodeMaterial","F_Schlick","f0","f90","dotVH","fresnel","BRDF_Lambert","G_BlinnPhong_Implicit","D_BlinnPhong","dotNH","BRDF_BlinnPhong","lightDirection","halfDir","F","G","D","PhongLightingModel","specular","lightColor","dotNL","_defaultValues$8","MeshLambertNodeMaterial","isMeshLambertNodeMaterial","_defaultValues$7","MeshPhongNodeMaterial","isMeshPhongNodeMaterial","shininessNode","specularNode","getGeometryRoughness","dxy","geometryRoughness","getRoughness","roughnessFactor","min","V_GGX_SmithCorrelated","dotNV","a2","gv","gl","V_GGX_SmithCorrelated_Anisotropic","alphaB","dotTV","dotBV","dotTL","dotBL","qualifier","D_GGX","D_GGX_Anisotropic","dotTH","dotBH","v2","w2","BRDF_GGX","f","USE_IRIDESCENCE","USE_ANISOTROPY","V","DFGApprox","c0","c1","a004","fab","EnvironmentBRDF","Schlick_to_F0","x2","x5","D_Charlie","invAlpha","cos2h","sin2h","V_Neubelt","BRDF_Sheen","LTC_Uv","LUT_SIZE","LUT_SCALE","LUT_BIAS","LTC_ClippedSphereFormFactor","LTC_EdgeVectorFormFactor","v1","theta_sintheta","LTC_Evaluate","P","mInv","p0","lightNormal","T1","T2","mat","coords0","coords1","coords2","coords3","vectorFormFactor","bC","w0","w1","w3","g0","g1","h0","bicubic","texelSize","lod","uvScaled","iuv","fuv","g0x","g1x","h0x","h1x","h0y","h1y","textureBicubic","lodNode","fLodSize","cLodSize","fLodSizeInv","cLodSizeInv","fSample","cSample","getVolumeTransmissionRay","n","modelMatrix","refractionVector","applyIorToRoughness","viewportBackSideTexture","viewportFrontSideTexture","getTransmissionSample","fragCoord","vTexture","transmissionSample","volumeAttenuation","transmissionDistance","attenuationCoefficient","transmittance","getIBLVolumeRefraction","projMatrix","transmittedLight","halfSpread","iors","transmissionRay","refractedRayExit","ndcPos","refractionCoords","divAssign","attenuatedColor","transmittanceFactor","XYZ_TO_REC709","Fresnel0ToIor","fresnel0","sqrtF0","IorToFresnel0","transmittedIor","incidentIor","evalSensitivity","OPD","phase","pos","VAR","evalIridescence","outsideIOR","eta2","cosTheta1","thinFilmThickness","baseF0","sinTheta2Sq","cosTheta2Sq","cosTheta2","R0","R12","T121","phi12","phi21","baseIOR","toVec3","R23","phi23","phi","R123","r123","Rs","C0","I","Cm","Sm","IBLSheenBRDF","viewDir","r2","DG","clearcoatF0","clearcoatF90","PhysicalLightingModel","clearcoatRadiance","clearcoatSpecularDirect","clearcoatSpecularIndirect","sheenSpecularDirect","sheenSpecularIndirect","iridescenceFresnel","iridescenceF0","dotNVi","computeMultiscattering","singleScatter","multiScatter","Fr","FssEss","Ess","Ems","Favg","Fms","dotNLcc","ccIrradiance","lightPosition","halfWidth","halfHeight","ltc_1","ltc_2","t1","t2","dotNVcc","clearcoatEnv","singleScattering","multiScattering","cosineWeightedIrradiance","totalScattering","diffuse","aoNV","aoExp","Fcc","clearcoatLight","sheenEnergyComp","sheenLight","cubeUV_r0","cubeUV_m0","cubeUV_r1","cubeUV_m1","cubeUV_r4","cubeUV_m4","cubeUV_r5","cubeUV_m5","cubeUV_r6","cubeUV_m6","cubeUV_minMipLevel","cubeUV_minTileSize","getFace","direction","absDirection","face","Else","roughnessToMip","mip","getDirection","uv_immutable","zyx","xzy","xz","textureCubeUV","sampleDir_immutable","roughness_immutable","CUBEUV_TEXEL_WIDTH","CUBEUV_TEXEL_HEIGHT","CUBEUV_MAX_MIP","sampleDir","mipF","mipInt","color0","bilinearCubeUV","color1","direction_immutable","mipInt_immutable","filterInt","faceSize","getSample","outputDirection","theta","axis","cosTheta","sampleDirection","latitudinal","poleAxis","weights","dTheta","gl_FragColor","_generator","_cache","_generateCubeUVSize","imageHeight","maxMip","texelHeight","texelWidth","_getPMREMFromTexture","cacheTexture","pmremVersion","isCubeMapReady","fromCubemap","isEquirectangularMapReady","fromEquirectangular","PMREMNode","_pmrem","_texture","_width","_height","_maxMip","updateFromTexture","cubeUVSize","pmrem","isPMREMTexture","createPMREMGenerator","pmremTexture","_envNodeCache","EnvironmentNode","cacheEnvNode","intensity","useAnisotropy","radianceNormalView","createRadianceContext","createIrradianceContext","isolateRadiance","isolateIrradiance","clearcoatRadianceContext","isolateClearcoatRadiance","normalViewNode","reflectVec","normalWorldNode","_defaultValues$6","MeshStandardNodeMaterial","isMeshStandardNodeMaterial","environmentNode","setupSpecular","_defaultValues$5","MeshPhysicalNodeMaterial","isMeshPhysicalNodeMaterial","clearcoatNormalNode","iridescenceNode","iridescenceIORNode","iridescenceThicknessNode","specularIntensityNode","iorNode","attenuationDistanceNode","attenuationColorNode","dispersionNode","anisotropyNode","useClearcoat","useIridescence","useSheen","useTransmission","useDispersion","anisotropyV","SSSLightingModel","useSSS","thicknessColorNode","thicknessDistortionNode","thicknessAmbientNode","thicknessAttenuationNode","thicknessPowerNode","thicknessScaleNode","scatteringHalf","scatteringDot","scatteringIllu","MeshSSSNodeMaterial","getGradientIrradiance","gradientMap","fw","ToonLightingModel","_defaultValues$4","MeshToonNodeMaterial","isMeshToonNodeMaterial","MatcapUVNode","matcapUV","_defaultValues$3","MeshMatcapNodeMaterial","isMeshMatcapNodeMaterial","matcapColor","matcap","_defaultValues$2","PointsNodeMaterial","isPointsNodeMaterial","sizeNode","RotateNode","rotationNode","cosAngle","sinAngle","rotationMatrix","rotation","rotationXMatrix","rotationYMatrix","rotationZMatrix","rotate","_defaultValues$1","SpriteNodeMaterial","isSpriteNodeMaterial","_useSizeAttenuation","sizeAttenuation","mvPosition","orthoScale","alignedPosition","rotatedPosition","ShadowMaskModel","shadowNode","shadowMask","_defaultValues","ShadowNodeMaterial","isShadowNodeMaterial","epsilon","ret","Texture3DNode","isTexture3DNode","texture3D","VolumeNodeMaterial","isVolumeNodeMaterial","testNode","hitBox","orig","box_min","box_max","inv_dir","tmin_tmp","tmax_tmp","tmin","tmax","t0","vOrigin","vDirection","rayDir","bounds","p","inc","ac","d","mapValue","probe","finalColor","Animation","info","_context","_animationLoop","_requestId","time","requestAnimationFrame","autoReset","reset","stop","cancelAnimationFrame","setAnimationLoop","ChainMap","weakMap","_id$7","getKeys","proto","getPrototypeOf","descriptor","RenderObject","geometries","renderContext","_nodes","_geometries","pipeline","vertexBuffers","drawParams","clippingContextCacheKey","cacheKey","initialNodesCacheKey","getDynamicCacheKey","initialCacheKey","_nodeBuilderState","_bindings","_monitor","onDispose","isRenderObject","onMaterialDispose","updateClipping","clippingNeedsUpdate","hardwareClippingPlanes","unionClippingCount","getNodeBuilderState","getForRender","getMonitor","getBindings","createBindings","getIndex","getIndirect","getChainArray","setGeometry","getAttributes","nodeAttributes","Set","isInterleavedBufferAttribute","getVertexBuffers","getDrawParameters","vertexCount","firstVertex","instanceCount","firstInstance","hasIndex","isInstancedBufferGeometry","rangeFactor","wireframe","isPoints","isLineSegments","isLine","isLineLoop","lastVertex","itemCount","Infinity","getGeometryCacheKey","normalized","getMaterialCacheKey","valueKey","receiveShadow","needsGeometryUpdate","chainArray","RenderObjects","pipelines","bindings","chainMaps","passId","chainMap","getChainMap","createRenderObject","DataMap","AttributeType","INDEX","STORAGE","INDIRECT","GPU_CHUNK_BYTES","BlendColorFactor","OneMinusBlendColorFactor","Attributes","backend","attributeData","destroyAttribute","createAttribute","createIndexAttribute","createStorageAttribute","createIndirectStorageAttribute","_getBufferAttribute","updateAttribute","arrayNeedsUint32","getWireframeVersion","getWireframeIndex","indices","geometryIndex","geometryPosition","Geometries","wireframes","attributeCall","updateForRender","initGeometry","updateAttributes","geometryData","memory","geometryAttributes","wireframeAttribute","isStorageBufferAttribute","isStorageInstancedBufferAttribute","callId","render","calls","Info","frameCalls","drawCalls","triangles","points","lines","timestamp","previousFrameCalls","timestampCalls","isMesh","isSprite","updateTimestamp","previousRenderFrameCalls","previousComputeFrameCalls","Pipeline","usedTimes","RenderPipeline","vertexProgram","fragmentProgram","ComputePipeline","computeProgram","isComputePipeline","_id$6","ProgrammableStage","code","transforms","stage","Pipelines","caches","programs","fragment","getForCompute","_needsComputeUpdate","previousPipeline","nodeBuilderState","stageCompute","computeShader","_releaseProgram","createProgram","_getComputeCacheKey","_releasePipeline","_getComputePipeline","promises","_needsRenderUpdate","stageVertex","vertexShader","stageFragment","fragmentShader","_getRenderCacheKey","_getRenderPipeline","createComputePipeline","createRenderPipeline","getRenderCacheKey","program","needsRenderUpdate","Bindings","bindGroup","groupData","_init","updateForCompute","_updateBindings","_update","binding","isSampledTexture","updateTexture","isStorageBuffer","isIndirectStorageBufferAttribute","needsBindingsUpdate","cacheBindings","cacheIndex","isNodeUniformsGroup","updated","updateGroup","isUniformBuffer","updateBinding","isSampler","texturesTextureData","generation","textureData","externalTexture","isDefaultTexture","isWebGPUBackend","isStorageTexture","store","needsMipmap","needsMipmaps","updateBindings","painterSortStable","groupOrder","renderOrder","reversePainterSortStable","needsDoublePass","hasTransmission","RenderList","renderItems","renderItemsIndex","opaque","transparentDoublePass","bundles","getNode","lightsArray","occlusionQueryCount","begin","getNextRenderItem","renderItem","occlusionTest","unshift","pushBundle","pushLight","light","customOpaqueSort","customTransparentSort","setLights","il","RenderLists","lists","list","id$1","RenderContext","clearColor","clearColorValue","clearDepth","clearDepthValue","stencil","clearStencil","clearStencilValue","viewportValue","scissor","scissorValue","depthTexture","activeCubeFace","sampleCount","isRenderContext","RenderContexts","chainKey","attachmentState","stencilBuffer","renderState","_size$3","Textures","updateRenderTarget","activeMipmapLevel","renderTargetData","depthTextureMips","getSize","mipWidth","mipHeight","useDepthTexture","textureNeedsUpdate","_destroyTexture","isRenderTarget","destroySampler","destroyTexture","levels","getMipLevels","createSampler","createTexture","needsCreate","complete","dataReady","mipmaps","createDefaultTexture","mipLevelCount","isCompressedTexture","isEnvironmentTexture","Color4","ParameterNode","isParameterNode","parameter","StackNode","_currentCond","boolNode","methodNode","previousStack","else","elseif","StructTypeNode","isStructTypeNode","getMemberTypes","OutputStructNode","members","getStructTypeFromNode","getOutputStructName","structPrefix","outputStruct","getTextureIndex","MRTNode","outputNodes","isMRTNode","outputs","toUint","word","toFloat","parabola","k","gain","pcurve","sinc","tri","tri3","triNoise3D","p_immutable","spd","rz","bp","dg","FunctionOverloadingNode","functionNodes","parametersNodes","_candidateFnCall","candidateFnCall","candidateFn","candidateScore","score","overloadingBaseFn","overloadingFn","deltaTime","timerLocal","timeScale","timerGlobal","timerDelta","oscSine","oscSquare","oscTriangle","oscSawtooth","rotateUV","spherizeUV","strength","delta2","delta4","deltaOffset","billboarding","horizontal","vertical","viewportSafeUV","depthDiff","finalUV","SpriteSheetUVNode","countNode","frameNode","frameNum","column","row","uvFrameOffset","spritesheetUV","TriplanarTexturesNode","textureXNode","textureYNode","textureZNode","bf","tx","ty","zx","tz","textureX","textureY","textureZ","cx","cy","cz","triplanarTextures","triplanarTexture","_reflectorPlane","_normal","_reflectorWorldPosition","_cameraWorldPosition","_rotationMatrix","_lookAtPosition","clipPlane","_view","_target","_q","_size$2","_defaultRT","_defaultUV","flipX","_inReflector","ReflectorNode","_reflectorBaseNode","reflector","ReflectorBaseNode","_depthNode","getDepthNode","isQuadMesh","reflectorNode","resolution","bounces","virtualCameras","renderTargets","_updateResolution","setSize","getVirtualCamera","virtualCamera","extractRotation","subVectors","up","lookAt","updateMatrixWorld","setFromNormalAndCoplanarPoint","constant","elements","clipBias","visible","currentRenderTarget","setRenderTarget","_camera","QuadGeometry","setAttribute","_geometry","QuadMesh","renderAsync","_size$1","RTTNode","autoUpdate","updateMap","_rttNode","_quadMesh","autoSize","getSharedContext","effectiveWidth","pixelRatio","effectiveHeight","setPixelRatio","rtt","convertToTexture","isPassNode","getTextureNode","getViewPosition","screenPosition","clipSpacePosition","viewSpacePosition","getScreenPosition","viewPosition","sampleClipPos","sampleUv","getNormalFromDepth","l2","l1","r1","b2","b1","dl","dr","db","ce","dpdx","dpdy","StorageInstancedBufferAttribute","typeClass","isView","StorageBufferAttribute","StorageArrayElementNode","storageBufferNode","isStorageArrayElementNode","isPBO","setupPBO","isAssignContext","generatePBO","storageElement","StorageBufferNode","isStorageBufferNode","access","isAtomic","_attribute","_varying","setPBO","getPBO","setAccess","toReadOnly","setAtomic","toAtomic","getAttributeData","registerTransform","storage","storageObject","attributeArray","instancedArray","VertexColorNode","isVertexColorNode","vertexColor","PointUVNode","isPointUVNode","pointUV","_e1","_m1","SceneNode","BACKGROUND_BLURRINESS","BACKGROUND_INTENSITY","BACKGROUND_ROTATION","background","backgroundRotation","makeRotationFromEuler","identity","backgroundBlurriness","backgroundIntensity","StorageTextureNode","storeNode","isStorageTextureNode","generateStore","toReadWrite","toWriteOnly","storeSnippet","generateTextureStore","storageTexture","textureStore","UserDataNode","userData","_objectData","VelocityNode","previousModelWorldMatrix","previousProjectionMatrix","previousCameraViewMatrix","setProjectionMatrix","previousModelMatrix","getPreviousMatrix","cameraData","currentProjectionMatrix","currentCameraViewMatrix","previousModelViewMatrix","clipPositionCurrent","clipPositionPrevious","ndcPositionCurrent","ndcPositionPrevious","velocity","objectData","blendBurn","base","blend","blendDodge","blendScreen","blendOverlay","blendColor","outAlpha","burn","dodge","screen","overlay","grayscale","luminance","saturation","adjustment","vibrance","average","mx","amt","hue","luminanceCoefficients","getLuminanceCoefficients","cdl","slope","power","luma","pv","PosterizeNode","stepsNode","posterize","_size","PassTextureNode","passNode","PassMultipleTextureNode","textureName","previousTexture","getPreviousTexture","PassNode","_pixelRatio","_textures","_textureNodes","_linearDepthNodes","_viewZNodes","_previousTextures","_previousTextureNodes","_cameraNear","_cameraFar","_mrt","refTexture","toggleTexture","prevTexture","getPreviousTextureNode","getViewZNode","viewZNode","getLinearDepthNode","linearDepthNode","isWebGLBackend","isMultisampleRenderTargetTexture","pass","passTexture","depthPass","ToonOutlinePassNode","alphaNode","_materialCache","currentRenderObjectFunction","getRenderObjectFunction","setRenderObjectFunction","isMeshToonMaterial","outlineMaterial","_getOutlineMaterial","_createMaterial","isMeshToonOutlineMaterial","outlineNormal","ratio","pos2","originalMaterial","toonOutlinePass","linearToneMapping","reinhardToneMapping","cineonToneMapping","RRTAndODTFit","acesFilmicToneMapping","ACESInputMat","ACESOutputMat","LINEAR_REC2020_TO_LINEAR_SRGB","LINEAR_SRGB_TO_LINEAR_REC2020","agxDefaultContrastApprox","x_immutable","x4","agxToneMapping","colortone","AgXInsetMatrix","AgXOutsetMatrix","AgxMinEv","AgxMaxEv","neutralToneMapping","StartCompression","Desaturation","peak","newPeak","CodeNode","language","isCodeNode","setIncludes","getIncludes","include","nodeCode","getCodeFromNode","js","src","wgsl","glsl","FunctionNode","getNodeFunction","nodeFunction","parser","parseFunction","getCode","nativeFn","glslFn","wgslFn","ScriptableValueNode","outpuType","events","isScriptableValueNode","isScriptableOutputNode","URL","revokeObjectURL","refresh","getValue","createObjectURL","Blob","scriptableValue","Resources","Parameters","scriptableNode","getLayout","getInputLayout","ScriptableNodeResources","ScriptableNode","codeNode","_local","_output","_outputs","_source","_method","_object","_needsOutputUpdate","onRefresh","isScriptableNode","setLocal","getLocal","_refresh","getOutputLayout","setOutput","getOutput","getParameter","setParameter","deleteParameter","getDefaultOutput","clearParameters","getObject","callAsync","getDefaultOutputNode","THREE","TSL","clear","_exec","parametersProps","interfaceProps","declarations","returns","Function","scriptable","FogNode","factorNode","isFogNode","getViewZ","FogRangeNode","nearNode","farNode","isFogRangeNode","rangeFog","FogExp2Node","densityNode","isFogExp2Node","density","densityFog","RangeNode","minNode","maxNode","minLength","maxLength","minValue","maxValue","setScalar","minElementValue","getComponent","maxElementValue","lerp","random","range","ComputeBuiltinNode","builtinName","_builtinName","getBuiltinName","setBuiltinName","hasBuiltin","computeBuiltin","numWorkgroups","workgroupId","localId","subgroupSize","BarrierNode","barrier","workgroupBarrier","storageBarrier","textureBarrier","WorkgroupInfoElementNode","workgroupInfoNode","isWorkgroupInfoElementNode","WorkgroupInfoNode","isWorkgroupInfoNode","setScope","getScopedArray","workgroupArray","AtomicFunctionNode","pointerNode","methodSnippet","varSnippet","ATOMIC_LOAD","ATOMIC_STORE","ATOMIC_ADD","ATOMIC_SUB","ATOMIC_MAX","ATOMIC_MIN","ATOMIC_AND","ATOMIC_OR","ATOMIC_XOR","atomicNode","atomicFunc","atomicStore","atomicAdd","atomicSub","atomicMax","atomicMin","atomicAnd","atomicOr","atomicXor","uniformsLib","getLightData","lightShadowMatrix","shadowMatrix","shadow","updateMatrices","lightProjectionUV","projectionUV","spotLightCoord","lightTargetPosition","targetPosition","lightViewPosition","lightTargetDirection","sortLights","getLightNodeById","lightNodes","lightNode","isAnalyticLightNode","_lightsNodeRef","LightsNode","totalDiffuseNode","totalSpecularNode","_lights","_lightNodes","_lightNodesHash","setupLightsNode","previousLightNodes","nodeLibrary","lightNodeClass","getLightNodeClass","totalDiffuse","shadowMaterialLib","shadowWorldPosition","linearDistance","dist","linearShadowDistance","nearDistance","farDistance","referencePosition","getShadowMaterial","isPointLight","BasicShadowFilter","shadowCoord","PCFShadowFilter","depthCompare","mapSize","radius","dx0","dy0","dx1","dy1","dx2","dy2","dx3","dy3","PCFSoftShadowFilter","dx","dy","VSMShadowFilter","occlusion","distribution","hardShadow","variance","softnessProbability","VSMPassVertical","shadowPass","mean","squaredMean","uvStride","uvStart","uvOffset","std_dev","VSMPassHorizontal","_shadowFilterLib","_quadMesh$1","ShadowNode","shadowMap","vsmShadowMapVertical","vsmShadowMapHorizontal","vsmMaterialVertical","vsmMaterialHorizontal","_node","isShadowNode","setupShadowFilter","filterFn","frustumTest","setupShadowCoord","shadowPosition","coordZ","isOrthographicCamera","cameraNearLocal","cameraFarLocal","getShadowFilterFn","setupShadow","shadowMapType","compareFunction","createRenderTarget","updateProjectionMatrix","shadowPassVertical","shadowPassHorizontal","shadowIntensity","normalBias","filterNode","shadowDepthTexture","shadowTexture","shadowColor","shadowOutput","renderShadow","updateShadow","shadowType","depthVersion","_depthVersionCached","currentOverrideMaterial","overrideMaterial","layers","mask","castShadow","vsmPass","AnalyticLightNode","baseColorNode","shadowColorNode","setupShadowNode","customShadowNode","getDistanceAttenuation","lightDistance","cutoffDistance","decayExponent","distanceFalloff","_clearColor$2","cubeToUV","texelSizeY","absV","scaleToCube","planar","almostATexel","almostOne","signX","signY","BasicPointShadowFilter","bd3D","dp","PointShadowFilter","xyy","yyy","xyx","yyx","xxy","yxy","xxx","yxx","pointShadowFilter","lightToPosition","lightToPositionLength","_viewport","_viewportSize","_shadowMapSize","PointShadowNode","shadowFrameExtents","getFrameExtents","multiply","previousAutoClear","autoClear","previousClearColor","getClearColor","previousClearAlpha","getClearAlpha","setClearColor","clearAlpha","viewportCount","getViewportCount","vp","pointShadow","directPointLight","lVector","lightAttenuation","PointLightNode","cutoffDistanceNode","decayExponentNode","decay","checker","mx_select","b_immutable","t_immutable","f_immutable","mx_negate_if","val_immutable","mx_floor","mx_floorfrac","mx_bilerp_0","v0_immutable","v1_immutable","v2_immutable","v3_immutable","s_immutable","s","v3","v0","s1","mx_bilerp_1","mx_bilerp","mx_trilerp_0","v4_immutable","v5_immutable","v6_immutable","v7_immutable","r_immutable","v7","v6","v5","v4","mx_trilerp_1","mx_trilerp","mx_gradient_float_0","hash_immutable","y_immutable","h","mx_gradient_float_1","z_immutable","mx_gradient_float","mx_gradient_vec3_0","mx_gradient_vec3_1","mx_gradient_vec3","mx_gradient_scale2d_0","v_immutable","mx_gradient_scale3d_0","mx_gradient_scale2d_1","mx_gradient_scale2d","mx_gradient_scale3d_1","mx_gradient_scale3d","mx_rotl32","k_immutable","mx_bjmix","bitXorAssign","mx_bjfinal","a_immutable","c_immutable","mx_bits_to_01","bits_immutable","bits","mx_fade","mx_hash_int_0","mx_hash_int_1","mx_hash_int_2","mx_hash_int_3","xx_immutable","xx","mx_hash_int_4","yy_immutable","yy","mx_hash_int","mx_hash_vec3_0","mx_hash_vec3_1","mx_hash_vec3","mx_perlin_noise_float_0","X","Y","fx","fy","mx_perlin_noise_float_1","Z","fz","mx_perlin_noise_float","mx_perlin_noise_vec3_0","mx_perlin_noise_vec3_1","mx_perlin_noise_vec3","mx_cell_noise_float_0","ix","mx_cell_noise_float_1","iy","mx_cell_noise_float_2","iz","mx_cell_noise_float_3","iw","mx_cell_noise_float$1","mx_cell_noise_vec3_0","mx_cell_noise_vec3_1","mx_cell_noise_vec3_2","mx_cell_noise_vec3_3","mx_cell_noise_vec3","mx_fractal_noise_float$1","octaves_immutable","lacunarity_immutable","diminish_immutable","diminish","lacunarity","octaves","amplitude","mx_fractal_noise_vec3$1","mx_fractal_noise_vec2$1","mx_fractal_noise_vec4$1","mx_worley_distance_0","xoff_immutable","yoff_immutable","jitter_immutable","metric_immutable","metric","jitter","yoff","xoff","tmp","off","cellpos","diff","mx_worley_distance_1","zoff_immutable","zoff","mx_worley_distance","mx_worley_noise_float_0","localpos","sqdist","mx_worley_noise_vec2_0","mx_worley_noise_vec3_0","mx_worley_noise_float_1","mx_worley_noise_float$1","mx_worley_noise_vec2_1","mx_worley_noise_vec2$1","mx_worley_noise_vec3_1","mx_worley_noise_vec3$1","mx_hsvtorgb","hsv","hi","q","mx_rgbtohsv","mincomp","maxcomp","mx_srgb_texture_to_lin_rec709","color_immutable","isAbove","linSeg","powSeg","mx_aastep","afwidth","_ramp","mx_ramplr","valuel","valuer","texcoord","mx_ramptb","valuet","valueb","_split","mx_splitlr","mx_splittb","mx_transform_uv","uv_scale","uv_offset","uv_geo","mx_safepower","in1","in2","mx_contrast","amount","pivot","mx_noise_float","mx_noise_vec3","mx_noise_vec4","noise_vec4","mx_worley_noise_float","mx_worley_noise_vec2","mx_worley_noise_vec3","mx_cell_noise_float","mx_fractal_noise_float","mx_fractal_noise_vec2","mx_fractal_noise_vec3","mx_fractal_noise_vec4","getParallaxCorrectNormal","cubeSize","cubePos","nDir","rbmax","rbmin","rbminmax","correction","boxIntersection","getShIrradianceAt","shCoefficients","_clearColor$1","Background","renderList","getBackgroundNode","forceClear","_clearColor","getRGB","sceneData","backgroundNode","backgroundMesh","backgroundMeshNode","viewProj","setZ","nodeMaterial","depthTest","frustumCulled","onBeforeRender","copyPosition","backgroundCacheKey","depthClearValue","_clearDepth","stencilClearValue","_clearStencil","autoClearColor","autoClearDepth","autoClearStencil","_id$5","BindGroup","bindingsReference","NodeBuilderState","updateNodes","updateBeforeNodes","updateAfterNodes","instanceGroup","bindingsGroup","instanceBinding","NodeAttribute","isNodeAttribute","NodeUniform","isNodeUniform","NodeVar","isNodeVar","NodeVarying","isNodeVarying","NodeCode","NodeCache","nodesData","boundary","setValue","NumberUniform","isNumberUniform","Vector2Uniform","isVector2Uniform","Vector3Uniform","isVector3Uniform","Vector4Uniform","isVector4Uniform","ColorUniform","isColorUniform","Matrix3Uniform","isMatrix3Uniform","Matrix4Uniform","isMatrix4Uniform","NumberNodeUniform","Vector2NodeUniform","Vector3NodeUniform","Vector4NodeUniform","ColorNodeUniform","Matrix3NodeUniform","Matrix4NodeUniform","LOD_MIN","EXTRA_LOD_SIGMA","MAX_SAMPLES","_flatCamera","_cubeCamera","_oldTarget","_oldActiveCubeFace","_oldActiveMipmapLevel","PHI","INV_PHI","_axisDirections","_faceLib","PMREMGenerator","_renderer","_pingPongRenderTarget","_lodMax","_cubeSize","_lodPlanes","_sizeLods","_sigmas","_lodMeshes","_blurMaterial","_cubemapMaterial","_equirectMaterial","_backgroundBox","_hasInitialized","fromScene","sigma","_setSize","cubeUVRenderTarget","_allocateTargets","fromSceneAsync","getActiveCubeFace","getActiveMipmapLevel","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","init","equirectangular","_setSizeFromTexture","fromEquirectangularAsync","_fromTexture","cubemap","fromCubemapAsync","compileCubemapShader","_getCubemapMaterial","_compileMaterial","compileEquirectangularShader","_getEquirectMaterial","_dispose","outputTarget","scissorTest","_setViewport","_textureToCubeUV","_createRenderTarget","sizeLods","lodPlanes","sigmas","lodMeshes","_createPlanes","_getBlurShader","tmpMesh","compile","cubeCamera","upSign","forwardSign","originalAutoClear","backgroundBox","backgroundMaterial","useSolidColor","col","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","blurMaterial","STANDARD_DEVIATIONS","blurMesh","blurUniforms","pixels","radiansPerPixel","isFinite","sigmaPixels","sum","weight","outputSize","lodMax","totalLods","sizeLod","uv1","cubeFaces","vertices","positionSize","uvSize","faceIndexSize","faceIndex","coordinates","faceIdx","fill","planes","_getMaterial","materialUniforms","envTexture","rendererCache","typeFromArray","Int8Array","Int16Array","Uint16Array","NodeBuilder","sequentialNodes","hashNodes","flowNodes","flowCode","structs","bindingsIndexes","bindGroups","bufferAttributes","varyings","codes","vars","flow","chaining","stacks","flowsData","getBindGroupsCache","bindGroupsCache","createCubeRenderTarget","_getBindGroup","groupName","bindingsArray","sharedGroup","getBindGroupArray","bindingsGroups","groups","groupUniforms","sortBindingGroups","bindingGroup","buildUpdateNodes","currentNode","isFilteredTexture","lastChain","pop","generateTextureLod","componentType","getComponentTypeFromTexture","isDataTexture","exec","baseType","prefix","getTypeFromArray","dataAttribute","vecType","vecNum","newComponentType","lastStack","structType","variable","flowCodeBlock","needsFlowCode","nodeBlockHierarchy","addLineFlowCodeBlock","codeBlock","getFlowData","flowNode","flowData","flowChildNode","previous","buildFunctionCode","flowShaderNode","Symbol","iterator","next","done","flowStagesNode","previousFlow","previousVars","previousBuildStage","setBuildStage","getVars","previousShaderStage","setShaderStage","getAttributesArray","concat","getVaryings","getUniforms","getCodes","getShaderStage","buildCode","fromMaterial","getNodeUniform","createNodeMaterial","fromType","toType","fromTypeLength","toTypeLength","getSignature","NodeFrame","startTime","updateBeforeMap","updateAfterMap","_getMaps","referenceMap","nodeRef","maps","renderMap","frameMap","updateBeforeNode","updateAfterNode","updateNode","lastTime","performance","now","NodeFunctionInput","isConst","isNodeFunctionInput","DirectionalLightNode","_matrix41","_matrix42","ltcLib","RectAreaLightNode","premultiply","LTC_FLOAT_1","LTC_FLOAT_2","LTC_HALF_1","LTC_HALF_2","setLTC","ltc","SpotLightNode","coneCosNode","penumbraCosNode","angle","penumbra","getSpotAttenuation","angleCosine","angleCos","spotAttenuation","projectedTexture","inSpotLightMap","IESSpotLightNode","iesMap","AmbientLightNode","HemisphereLightNode","lightPositionNode","lightDirectionNode","groundColorNode","groundColor","hemiDiffuseWeight","LightProbeNode","lightProbe","sh","coefficients","NodeParser","NodeFunction","isNodeFunction","declarationRegexp$1","propertiesRegexp$1","pragmaMain","parse$1","trim","pragmaMainIndex","mainCode","declaration","match","inputsCode","propsMatches","nameMatch","parseInt","isNaN","blockCode","substring","headerCode","GLSLNodeFunction","declarationCode","GLSLNodeParser","outputNodeMap","Nodes","nodeBuilderCache","callHashCache","groupsData","nodeUniformsGroup","uniformsGroupData","groupChain","getForRenderCacheKey","nodeBuilder","createNodeBuilder","getEnvironmentNode","getFogNode","_createNodeBuilderState","computeData","chain","cacheKeyData","updateScene","updateEnvironment","updateFog","updateBackground","isToneMappingState","forceUpdate","isFogExp2","isFog","getNodeFrame","getNodeFrameForRender","getOutputCacheKey","currentColorSpace","hasOutputChange","outputTexture","_plane","ClippingContext","parentContext","clipIntersection","viewNormalMatrix","clippingGroupContexts","parentVersion","projectPlanes","destination","updateGlobal","clippingGroup","srcClippingPlanes","dstClippingPlanes","getGroupContext","clipShadows","RenderBundle","RenderBundles","NodeLibrary","materialNodes","toneMappingNodes","nodeMaterialClass","getMaterialNodeClass","addToneMapping","toneMappingNode","addType","materialType","addMaterial","materialNodeClass","materialClassType","addLight","lightClass","addClass","nodeClass","baseClass","_defaultLights","Lighting","_scene","_drawingBufferSize","_screen","_frustum","_projScreenMatrix","_vector4","Renderer","isRenderer","antialias","getFallback","domElement","getDomElement","sortObjects","_getFallback","_scissor","_scissorTest","_attributes","_animation","_objects","_pipelines","_bundles","_renderLists","_renderContexts","_background","_quad","_currentRenderContext","_opaqueSort","_transparentSort","_frameBufferTarget","alphaClear","_renderTarget","_activeCubeFace","_activeMipmapLevel","_renderObjectFunction","_currentRenderObjectFunction","_currentRenderBundle","_handleObjectFunction","_renderObjectDirect","_isDeviceLost","onDeviceLost","_onDeviceLost","_initialized","_initPromise","_compilationPromises","xr","debug","checkShaderErrors","onShaderError","getShaderAsync","compileAsync","Promise","resolve","reject","targetScene","previousRenderId","previousRenderContext","previousRenderObjectFunction","previousCompilationPromises","sceneRef","isScene","compilationPromises","_createObjectPipeline","_projectObject","traverseVisible","isLight","opaqueObjects","transparentObjects","transparentDoublePassObjects","_renderObjects","_renderTransparents","_renderScene","resolveTimestampAsync","waitForGPU","errorMessage","api","message","reason","_renderBundle","bundleGroup","renderBundle","renderBundleData","renderContexts","renderBundleNeedsUpdate","beginBundle","finishBundle","addBundle","_getFrameBufferTarget","currentToneMapping","useToneMapping","useColorSpace","frameBufferTarget","isPostProcessingRenderTarget","useFrameBufferTarget","outputRenderTarget","matrixWorldAutoUpdate","minDepth","maxDepth","setFromProjectionMatrix","beginRender","_renderBundles","finishRender","quad","onAfterRender","getMaxAnisotropy","getArrayBufferAsync","setDrawingBufferSize","setViewport","updateSize","updateStyle","style","setOpaqueSort","setTransparentSort","getScissor","setScissor","getScissorTest","setScissorTest","boolean","setClearAlpha","getClearDepth","setClearDepth","getClearStencil","setClearStencil","isOccluded","clearAsync","clearColorAsync","clearDepthAsync","clearStencilAsync","renderObjectFunction","computeNodes","isDeviceLost","computeAsync","computeList","beginCompute","onInitFn","computeBindings","computePipeline","finishCompute","hasFeatureAsync","hasFeature","initTextureAsync","initTexture","rectangle","copyTextureToTexture","srcTexture","dstTexture","srcRegion","dstPosition","readRenderTargetPixelsAsync","copyTextureToBuffer","isGroup","isClippingGroup","isLOD","intersectsSprite","intersectsObject","boundingSphere","computeBoundingSphere","groupMaterial","materialIndex","isBundleGroup","baseRenderList","children","doublePassList","isArrayCamera","cameras","jl","camera2","updateViewport","overridePositionNode","overrideColorNode","overrideDepthNode","shadowSide","draw","Binding","visibility","setVisibility","getFloatLength","floatLength","Buffer","isBuffer","bytesPerElement","BYTES_PER_ELEMENT","_buffer","byteLength","UniformBuffer","_id$4","NodeUniformBuffer","isUniformsGroup","_values","addUniform","removeUniform","splice","chunkOffset","remainingSizeInChunk","updateByType","updateNumber","updateVector2","updateVector3","updateVector4","updateColor","updateMatrix3","updateMatrix4","_getBufferForType","e","arraysEqual","setArray","_id$3","NodeUniformsGroup","getNodes","_id$2","SampledTexture","isVideoTexture","NodeSampledTexture","NodeSampledCubeTexture","isSampledCubeTexture","NodeSampledTexture3D","isSampledTexture3D","glslMethods","textureDimensions","precisionLib","medium","supports$1","swizzleAssign","storageBuffer","defaultPrecisions","GLSLNodeBuilder","uniformGroups","extensions","builtins","pbo","originalArray","numElements","typeMap","Uint8ClampedArray","newSize","newArray","pboTexture","isPBOTexture","pboNode","storageArrayElementNode","elementNodeData","bufferNodeData","propertySizeName","uvIndexSnippet","snippets","bindingSnippets","typePrefix","isDataArrayTexture","isCompressedArrayTexture","bufferCountSnippet","vectorType","groupSnippets","_getGLSLUniformStruct","gpuType","location","getStructMembers","struct","member","getStructs","flat","acc","curr","enableExtension","behavior","getExtensions","ext","extensionName","planeCount","varyingName","attributeNode","getTransforms","transform","_getGLSLVertexCode","shaderData","_getGLSLFragmentCode","shadersData","mainNode","flowSlotData","slotName","stageData","uniformGPU","uniformsStage","uniformsGroup","vector2","vector4","color4","Backend","destroyProgram","destroyPipeline","getInstanceCount","canvas","_id$1","DualAttributeData","dualBuffer","buffers","bufferGPU","activeBufferIndex","baseId","transformBuffer","switchBuffers","WebGLAttributeUtils","STATIC_DRAW","_createBuffer","isFloat16BufferAttribute","HALF_FLOAT","UNSIGNED_SHORT","SHORT","UNSIGNED_INT","INT","BYTE","UNSIGNED_BYTE","bufferGPUDual","updateRanges","bindBuffer","bufferSubData","clearUpdateRanges","deleteBuffer","COPY_READ_BUFFER","writeBuffer","createBuffer","COPY_WRITE_BUFFER","STREAM_READ","copyBufferSubData","utils","_clientWaitAsync","dstBuffer","getBufferSubData","initialized$1","equationToGL","factorToGL","WebGLState","currentFlipSided","currentCullFace","currentProgram","currentBlendingEnabled","currentBlending","currentBlendSrc","currentBlendDst","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentPolygonOffsetFactor","currentPolygonOffsetUnits","currentColorMask","currentDepthFunc","currentDepthMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilMask","currentLineWidth","currentClippingPlanes","currentBoundFramebuffers","currentDrawbuffers","maxTextures","MAX_TEXTURE_IMAGE_UNITS","currentTextureSlot","currentBoundTextures","currentBoundBufferBases","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","ZERO","ONE","SRC_COLOR","SRC_ALPHA","SRC_ALPHA_SATURATE","DST_COLOR","DST_ALPHA","ONE_MINUS_SRC_COLOR","ONE_MINUS_SRC_ALPHA","ONE_MINUS_DST_COLOR","ONE_MINUS_DST_ALPHA","enable","disable","setFlipSided","flipSided","frontFace","CW","CCW","setCullFace","cullFace","CULL_FACE","BACK","FRONT","FRONT_AND_BACK","setLineWidth","setBlending","blendEquation","blendSrc","blendDst","blendEquationAlpha","blendSrcAlpha","blendDstAlpha","premultipliedAlpha","BLEND","currentBlendEquation","currentBlendEquationAlpha","blendFuncSeparate","blendFunc","blendEquationSeparate","setColorMask","colorMask","setDepthTest","DEPTH_TEST","setDepthMask","depthMask","setDepthFunc","depthFunc","NEVER","ALWAYS","LESS","LEQUAL","EQUAL","GEQUAL","GREATER","NOTEQUAL","setStencilTest","stencilTest","STENCIL_TEST","setStencilMask","stencilMask","setStencilFunc","stencilFunc","stencilRef","setStencilOp","stencilFail","stencilZFail","stencilZPass","stencilOp","setMaterial","frontFaceCW","colorWrite","stencilWrite","stencilWriteMask","stencilFuncMask","setPolygonOffset","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","SAMPLE_ALPHA_TO_COVERAGE","CLIP_DISTANCE0_WEBGL","units","POLYGON_OFFSET_FILL","useProgram","bindFramebuffer","framebuffer","DRAW_FRAMEBUFFER","FRAMEBUFFER","drawBuffers","COLOR_ATTACHMENT0","activeTexture","webglSlot","TEXTURE0","bindTexture","webglType","webglTexture","boundTexture","bindBufferBase","unbindTexture","WebGLUtils","extension","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_INT_5_9_9_9_REV","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","DEPTH_COMPONENT","DEPTH_STENCIL","RED","RED_INTEGER","RG","RG_INTEGER","RGBA_INTEGER","COMPRESSED_SRGB_S3TC_DXT1_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_SRGB8_ETC2","COMPRESSED_RGB8_ETC2","COMPRESSED_SRGB8_ALPHA8_ETC2_EAC","COMPRESSED_RGBA8_ETC2_EAC","COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR","COMPRESSED_RGBA_ASTC_4x4_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR","COMPRESSED_RGBA_ASTC_5x4_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR","COMPRESSED_RGBA_ASTC_5x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR","COMPRESSED_RGBA_ASTC_6x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR","COMPRESSED_RGBA_ASTC_6x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR","COMPRESSED_RGBA_ASTC_8x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR","COMPRESSED_RGBA_ASTC_8x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR","COMPRESSED_RGBA_ASTC_8x8_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR","COMPRESSED_RGBA_ASTC_10x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR","COMPRESSED_RGBA_ASTC_10x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR","COMPRESSED_RGBA_ASTC_10x8_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR","COMPRESSED_RGBA_ASTC_10x10_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR","COMPRESSED_RGBA_ASTC_12x10_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR","COMPRESSED_RGBA_ASTC_12x12_KHR","COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT","COMPRESSED_RGBA_BPTC_UNORM_EXT","COMPRESSED_RED_RGTC1_EXT","COMPRESSED_SIGNED_RED_RGTC1_EXT","COMPRESSED_RED_GREEN_RGTC2_EXT","COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT","UNSIGNED_INT_24_8","sync","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","res","clientWaitSync","SYNC_FLUSH_COMMANDS_BIT","WAIT_FAILED","deleteSync","TIMEOUT_EXPIRED","wrappingToGL","filterToGL","compareToGL","WebGLTextureUtils","defaultTextures","REPEAT","CLAMP_TO_EDGE","MIRRORED_REPEAT","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","filterFallback","getGLTextureType","glTextureType","TEXTURE_CUBE_MAP","TEXTURE_2D_ARRAY","isData3DTexture","TEXTURE_3D","TEXTURE_2D","getInternalFormat","internalFormatName","glFormat","glType","forceLinearTransfer","internalFormat","R32F","R16F","R8","R16","R32UI","R8I","R16I","R32I","R8UI","R16UI","RG32F","RG16F","RG8","RG16","RG32UI","RG8I","RG16I","RG32I","RG8UI","RG16UI","RGB32F","RGB16F","RGB8","RGB16","RGB32UI","RGB8I","RGB16I","RGB32I","SRGB8","UNSIGNED_SHORT_5_6_5","RGB565","RGB5_A1","RGB4","RGB9_E5","RGB_INTEGER","RGB8UI","RGB16UI","RGBA32F","RGBA16F","RGBA8","RGBA16","RGBA32UI","RGBA8I","RGBA16I","RGBA32I","SRGB8_ALPHA8","RGBA4","RGBA8UI","RGBA16UI","DEPTH24_STENCIL8","DEPTH_COMPONENT32F","setTextureParameters","textureType","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","premultiplyAlpha","UNPACK_ALIGNMENT","unpackAlignment","UNPACK_COLORSPACE_CONVERSION_WEBGL","texParameteri","TEXTURE_WRAP_S","wrapS","TEXTURE_WRAP_T","wrapT","TEXTURE_WRAP_R","wrapR","TEXTURE_MAG_FILTER","hasMipmaps","TEXTURE_MIN_FILTER","TEXTURE_COMPARE_MODE","COMPARE_REF_TO_TEXTURE","TEXTURE_COMPARE_FUNC","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","textureGPU","isDefault","glInternalFormat","texStorage3D","texStorage2D","copyBufferToTexture","PIXEL_UNPACK_BUFFER","texSubImage2D","getImage","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","mipmap","compressedTexSubImage3D","texSubImage3D","compressedTexSubImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","texImage2D","generateMipmap","deallocateRenderBuffers","renderContextData","renderBufferStorageSetup","framebuffers","deleteFramebuffer","depthRenderbuffer","deleteRenderbuffer","stencilRenderbuffer","msaaFrameBuffer","msaaRenderbuffers","deleteTexture","dstTextureGPU","minX","minY","dstX","dstY","currentUnpackRowLen","UNPACK_ROW_LENGTH","currentUnpackImageHeight","UNPACK_IMAGE_HEIGHT","currentUnpackSkipPixels","UNPACK_SKIP_PIXELS","currentUnpackSkipRows","UNPACK_SKIP_ROWS","currentUnpackSkipImages","UNPACK_SKIP_IMAGES","srcTextureData","dstTextureData","srcRenderContextData","dstRenderContextData","srcFramebuffer","dstFramebuffer","READ_FRAMEBUFFER","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","blitFramebuffer","requireDrawFrameBuffer","srcHeight","gerDrawingBufferSize","partial","attachment","DEPTH_ATTACHMENT","STENCIL_BUFFER_BIT","renderTargetContextData","fb","flippedY","copyTexSubImage2D","createFramebuffer","framebufferTexture2D","_setFramebuffer","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","DEPTH_COMPONENT24","renderbufferStorageMultisample","renderbufferStorage","framebufferRenderbuffer","DEPTH_STENCIL_ATTACHMENT","typedArrayType","_getTypedArrayType","bytesPerTexel","_getBytesPerTexel","elementCount","PIXEL_PACK_BUFFER","readPixels","bytesPerComponent","WebGLExtensions","availableExtensions","getSupportedExtensions","getExtension","WebGLCapabilities","maxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","GLFeatureName","WebGLBufferRenderer","mode","drawElements","drawArrays","renderInstances","primcount","drawElementsInstanced","drawArraysInstanced","renderMultiDraw","starts","counts","drawCount","multiDrawElementsWEBGL","multiDrawArraysWEBGL","renderMultiDrawInstances","multiDrawElementsInstancedWEBGL","multiDrawArraysInstancedWEBGL","WebGLBackend","glContext","onContextLost","preventDefault","contextLossInfo","statusMessage","originalEvent","_onContextLost","capabilities","attributeUtils","textureUtils","bufferRenderer","vaoCache","transformFeedbackCache","trackTimestamp","disjoint","parallel","_knownBindings","WeakSet","_currentContext","initTimestampQuery","queryRunning","queryQueue","activeQuery","endQuery","TIME_ELAPSED_EXT","createQuery","beginQuery","prepareTimestampBuffer","gpuQueries","query","nextRenderContext","queryInfo","available","getQueryParameter","QUERY_RESULT_AVAILABLE","GPU_DISJOINT_EXT","elapsed","QUERY_RESULT","duration","deleteQuery","drawingBufferWidth","drawingBufferHeight","currentOcclusionQueries","occlusionQueries","currentOcclusionQueryObjects","occlusionQueryObjects","lastOcclusionObject","occlusionQueryIndex","ANY_SAMPLES_PASSED","resolveOccludedAsync","viewY","invalidateSubFramebuffer","invalidationArray","invalidateFramebuffer","occluded","check","completed","SCISSOR_TEST","setFrameBuffer","clearBufferfv","clearBufferfi","clearBufferiv","STENCIL","computeGroup","RASTERIZER_DISCARD","programGPU","transformBuffers","vaoKey","_getVaoKey","vaoGPU","_createVao","bindVertexArray","_bindUniforms","transformFeedbackGPU","_getTransformFeedback","bindTransformFeedback","TRANSFORM_FEEDBACK","beginTransformFeedback","POINTS","endTransformFeedback","dualAttributeData","contextData","determinant","staticVao","geometryId","lastObject","LINES","LINE_STRIP","LINE_LOOP","wireframeLinewidth","TRIANGLES","indexData","_multiDrawInstances","_multiDrawStarts","_multiDrawCounts","_multiDrawCount","shader","createShader","FRAGMENT_SHADER","VERTEX_SHADER","shaderSource","compileShader","shaderGPU","attachShader","linkProgram","checkStatus","getProgramParameter","COMPLETION_STATUS_KHR","_completeCompile","_handleSource","errorLine","lines2","to","line","_getShaderErrors","status","getShaderParameter","COMPILE_STATUS","errors","getShaderInfoLog","errorMatches","toUpperCase","getShaderSource","_logProgramError","glFragmentShader","glVertexShader","programLog","getProgramInfoLog","LINK_STATUS","vertexErrors","fragmentErrors","getError","VALIDATE_STATUS","pipelineData","_setupBindings","transformVaryingNames","transformAttributeNodes","transformFeedbackVaryings","SEPARATE_ATTRIBS","attributeNodes","ARRAY_BUFFER","uniformBuffers","bindGroupData","UNIFORM_BUFFER","DYNAMIC_DRAW","bindingData","ELEMENT_ARRAY_BUFFER","keysMatching","filter","currentFrameBuffer","isCube","isWebGLCubeRenderTarget","msaaFb","cubeFramebuffers","cubeFace","depthStyle","createRenderbuffer","createVertexArray","enableVertexAttribArray","vertexAttribIPointer","vertexAttribPointer","vertexAttribDivisor","meshPerAttribute","isInstancedInterleavedBuffer","createTransformFeedback","TRANSFORM_FEEDBACK_BUFFER","getUniformBlockIndex","uniformBlockBinding","getUniformLocation","uniform1i","GPUPrimitiveTopology","PointList","LineList","LineStrip","TriangleList","TriangleStrip","GPUCompareFunction","Never","Less","Equal","LessEqual","Greater","NotEqual","GreaterEqual","Always","GPUStoreOp","Store","GPULoadOp","Load","Clear","GPUFrontFace","GPUCullMode","None","Front","Back","GPUIndexFormat","Uint16","Uint32","GPUTextureFormat","R8Unorm","R8Snorm","R8Uint","R8Sint","R16Uint","R16Sint","R16Float","RG8Unorm","RG8Snorm","RG8Uint","RG8Sint","R32Uint","R32Sint","R32Float","RG16Uint","RG16Sint","RG16Float","RGBA8Unorm","RGBA8UnormSRGB","RGBA8Snorm","RGBA8Uint","RGBA8Sint","BGRA8Unorm","BGRA8UnormSRGB","RGB9E5UFloat","RGB10A2Unorm","RG11B10uFloat","RG32Uint","RG32Sint","RG32Float","RGBA16Uint","RGBA16Sint","RGBA16Float","RGBA32Uint","RGBA32Sint","RGBA32Float","Stencil8","Depth16Unorm","Depth24Plus","Depth24PlusStencil8","Depth32Float","Depth32FloatStencil8","BC1RGBAUnorm","BC1RGBAUnormSRGB","BC2RGBAUnorm","BC2RGBAUnormSRGB","BC3RGBAUnorm","BC3RGBAUnormSRGB","BC4RUnorm","BC4RSnorm","BC5RGUnorm","BC5RGSnorm","BC6HRGBUFloat","BC6HRGBFloat","BC7RGBAUnorm","BC7RGBAUnormSRGB","ETC2RGB8Unorm","ETC2RGB8UnormSRGB","ETC2RGB8A1Unorm","ETC2RGB8A1UnormSRGB","ETC2RGBA8Unorm","ETC2RGBA8UnormSRGB","EACR11Unorm","EACR11Snorm","EACRG11Unorm","EACRG11Snorm","ASTC4x4Unorm","ASTC4x4UnormSRGB","ASTC5x4Unorm","ASTC5x4UnormSRGB","ASTC5x5Unorm","ASTC5x5UnormSRGB","ASTC6x5Unorm","ASTC6x5UnormSRGB","ASTC6x6Unorm","ASTC6x6UnormSRGB","ASTC8x5Unorm","ASTC8x5UnormSRGB","ASTC8x6Unorm","ASTC8x6UnormSRGB","ASTC8x8Unorm","ASTC8x8UnormSRGB","ASTC10x5Unorm","ASTC10x5UnormSRGB","ASTC10x6Unorm","ASTC10x6UnormSRGB","ASTC10x8Unorm","ASTC10x8UnormSRGB","ASTC10x10Unorm","ASTC10x10UnormSRGB","ASTC12x10Unorm","ASTC12x10UnormSRGB","ASTC12x12Unorm","ASTC12x12UnormSRGB","GPUAddressMode","ClampToEdge","Repeat","MirrorRepeat","GPUFilterMode","Linear","Nearest","GPUBlendFactor","Zero","One","Src","OneMinusSrc","SrcAlpha","OneMinusSrcAlpha","Dst","OneMinusDstColor","DstAlpha","OneMinusDstAlpha","SrcAlphaSaturated","Constant","OneMinusConstant","GPUBlendOperation","Add","Subtract","ReverseSubtract","Min","Max","GPUColorWriteFlags","Red","Green","Blue","Alpha","All","GPUStencilOperation","Keep","Replace","Invert","IncrementClamp","DecrementClamp","IncrementWrap","DecrementWrap","GPUBufferBindingType","Storage","ReadOnlyStorage","GPUStorageTextureAccess","WriteOnly","ReadOnly","ReadWrite","GPUTextureSampleType","Float","UnfilterableFloat","Depth","SInt","UInt","GPUTextureDimension","OneD","TwoD","ThreeD","GPUTextureViewDimension","TwoDArray","Cube","CubeArray","GPUTextureAspect","StencilOnly","DepthOnly","GPUInputStepMode","Vertex","Instance","GPUFeatureName","DepthClipControl","TextureCompressionBC","TextureCompressionETC2","TextureCompressionASTC","TimestampQuery","IndirectFirstInstance","ShaderF16","RG11B10UFloat","BGRA8UNormStorage","Float32Filterable","ClipDistances","DualSourceBlending","Subgroups","Sampler","NodeSampler","StorageBuffer","_id","NodeStorageBuffer","WebGPUTexturePassUtils","device","mipmapVertexSource","mipmapFragmentSource","flipYFragmentSource","mipmapSampler","flipYSampler","transferPipelines","flipYPipelines","mipmapVertexShaderModule","createShaderModule","mipmapFragmentShaderModule","flipYFragmentShaderModule","getTransferPipeline","module","entryPoint","targets","primitive","topology","stripIndexFormat","getFlipYPipeline","textureGPUDescriptor","baseArrayLayer","transferPipeline","flipYPipeline","tempTexture","depthOrArrayLayers","GPUTextureUsage","RENDER_ATTACHMENT","TEXTURE_BINDING","srcView","createView","baseMipLevel","dimension","dstView","commandEncoder","createCommandEncoder","sourceView","destinationView","bindGroupLayout","getBindGroupLayout","createBindGroup","entries","resource","passEncoder","beginRenderPass","colorAttachments","view","loadOp","storeOp","clearValue","setPipeline","setBindGroup","queue","submit","destroy","useCount","passes","_mipmapCreateBundles","_mipmapRunBundles","passDescriptor","createRenderBundleEncoder","colorFormats","renderBundles","executeBundles","_compareToWebGPU","_flipMap","WebGPUTextureUtils","_passUtils","defaultCubeTexture","defaultVideoFrame","colorBuffer","samplerDescriptorGPU","addressModeU","_convertAddressMode","addressModeV","addressModeW","_convertFilterMode","mipmapFilter","getFormat","_getDefaultCubeTextureGPU","_getDefaultVideoFrame","_getDefaultTextureGPU","getCurrentColorFormat","getPreferredCanvasFormat","_getDimension","getSampleCount","primarySampleCount","COPY_DST","COPY_SRC","STORAGE_BINDING","textureDescriptorGPU","video","videoFrame","VideoFrame","displayWidth","displayHeight","close","msaaTextureDescriptorGPU","msaaTexture","_generateMipmaps","getColorBuffer","getDepthBuffer","depthTextureGPU","_copyBufferToTexture","_copyCompressedBufferToTexture","_copyCubeMapToTexture","_copyImageToTexture","bytesPerRow","readBuffer","GPUBufferUsage","MAP_READ","encoder","origin","mapAsync","GPUMapMode","READ","getMappedRange","_isEnvironmentTexture","codedWidth","codedHeight","flipIndex","originDepth","copyExternalImageToTexture","mipLevel","_flipY","_getPassUtils","passUtils","writeTexture","blockData","_getBlockData","isTextureArray","bytesPerImage","rowsPerImage","BC4RSNorm","addressMode","filterMode","formatGPU","features","declarationRegexp","propertiesRegexp","wgslTypeLib$1","parse","resolvedType","WGSLNodeFunction","WGSLNodeParser","GPUShaderStage","COMPUTE","accessNames","wrapNames","gpuShaderStageLib","supports","wgslFnOpLib","wgslTypeLib","wgslCodeCache","wgslPolyfill","tsl_xor","mod_float","mod_vec2","mod_vec3","mod_vec4","equals_bool","equals_bvec2","equals_bvec3","equals_bvec4","repeatWrapping_float","mirrorWrapping_float","clampWrapping_float","biquadraticTexture","wgslMethods","inversesqrt","navigator","userAgent","pow_float","pow_vec2","pow_vec3","pow_vec4","diagnostics","WGSLNodeBuilder","directives","scopedArrays","_generateTextureSample","generateFilteredTexture","_generateVideoSample","_generateTextureSampleLevel","isUnfilterable","generateWrapFunction","addWrapSnippet","wrap","generateTextureDimension","dimensionsSnippet","textureDimensionNode","textureDimensionsParams","_include","wrapFunction","textureDimension","coordSnippet","valueSnippet","isSampleCompare","_getUniformGroupCount","fnOp","getNodeAccess","getStorageAccess","bufferClass","getBuiltin","getSubgroupSize","enableSubGroups","enableDirective","getDirectives","directive","enableSubgroupsF16","enableClipDistances","enableShaderF16","enableDualSourceBlending","getBuiltins","getScopedArrays","attributesSnippet","_getWGSLStruct","bufferSnippets","structSnippets","uniformIndexes","multisampled","componentPrefix","bufferTypeSnippet","bufferSnippet","bufferAccessMode","_getWGSLStructBinding","isOutputStruct","returnType","structSnippet","_getWGSLVertexCode","_getWGSLFragmentCode","_getWGSLComputeCode","wgslMethod","_getWGSLMethod","structName","WebGPUUtils","getCurrentDepthStencilFormat","getTextureFormatGPU","getCurrentColorSpace","getPrimitiveTopology","getSampleCountRenderContext","gpu","typedArraysToVertexFormatPrefix","typedAttributeToVertexFormatPrefix","typeArraysToVertexFormatPrefixForItemSize1","WebGPUAttributeUtils","tempArray","subarray","mappedAtCreation","unmap","isTypedArray","_isTypedArray","byteOffsetFactor","dataOffset","createShaderVertexBuffers","slot","vertexBufferLayout","arrayStride","stepMode","_getVertexFormat","shaderLocation","readBufferGPU","cmdEncoder","copyBufferToBuffer","gpuCommands","ArrayType","prefixOptions","bytesPerUnit","paddedBytesPerUnit","paddedItemSize","DataView","WebGPUBindingUtils","bindGroupLayoutCache","createBindingsLayout","bindingGPU","sampleType","viewDimension","createBindGroupLayout","bindingsData","bindLayoutGPU","bindGroupGPU","versions","layoutGPU","bindingPoint","entriesGPU","UNIFORM","resourceGPU","importExternalTexture","aspectGPU","dimensionViewGPU","WebGPUPipelineUtils","_getSampleCount","renderObjectContext","bindGroupLayouts","_getBlending","stencilFront","_getStencilCompare","failOp","_getStencilOperation","depthFailOp","passOp","colorWriteMask","_getColorWriteMask","colorFormat","writeMask","vertexModule","fragmentModule","primitiveState","_getPrimitiveState","_getDepthCompare","depthStencilFormat","pipelineDescriptor","multisample","alphaToCoverageEnabled","createPipelineLayout","depthStencil","renderDepth","renderStencil","depthWriteEnabled","stencilBack","stencilReadMask","createRenderPipelineAsync","then","createBundleEncoder","pipelineGPU","srcFactor","_getBlendFactor","dstFactor","operation","_getBlendOperation","setBlend","srcRGB","dstRGB","srcAlpha","dstAlpha","blendFactor","stencilCompare","stencilOperation","blendOperation","cullMode","WebGPUBackend","requiredLimits","defaultRenderPassdescriptor","bindingUtils","pipelineUtils","occludedResolveCache","adapterOptions","powerPreference","adapter","requestAdapter","supportedFeatures","deviceDescriptor","requiredFeatures","requestDevice","lost","deviceLossInfo","alphaMode","configure","_getDefaultRenderPassDescriptor","depthStencilAttachment","colorAttachment","resolveTarget","getCurrentTexture","_getRenderPassDescriptor","textureView","depthTextureData","occlusionQuerySet","currentOcclusionQuerySet","currentOcclusionQueryBuffer","occlusionQueryBuffer","createQuerySet","depthLoadOp","depthStoreOp","stencilLoadOp","stencilStoreOp","currentPass","currentSets","bindingGroups","setScissorRect","endOcclusionQuery","bufferSize","queryResolveBuffer","QUERY_RESOLVE","resolveQuerySet","results","BigUint64Array","BigInt","supportsDepth","supportsStencil","groupGPU","cmdEncoderGPU","passEncoderGPU","beginComputePass","maxComputeWorkgroupsPerDimension","limits","computeNodeData","dispatchSize","dispatchWorkgroups","onSubmittedWorkDone","currentBindingGroups","indexFormat","setIndexBuffer","vertexBuffer","setVertexBuffer","beginOcclusionQuery","drawInstances","drawIndexed","indexCount","firstIndex","drawIndexedIndirect","drawIndirect","primitiveTopology","materialVersion","timeStampQuerySet","timestampWrites","querySet","beginningOfPassWriteIndex","endOfPassWriteIndex","BigInt64Array","currentTimestampQueryBuffers","resolveBuffer","resultBuffer","mapState","times","_currentPass","_currentSets","bundleEncoder","bundleGPU","dstLayer","srcX","srcY","srcLayer","srcWidth","sourceGPU","destinationGPU","IESSpotLight","recursive","StandardNodeLibrary","WebGPURenderer","BackendClass","forceWebGL","isWebGPURenderer","BundleGroup","_material","PostProcessing","outputColorTransform","saveRendererState","resetRendererState","restoreRendererState","saveRendererAndSceneState","resetRendererAndSceneState","restoreRendererAndSceneState","PostProcessingUtils","StorageTexture","IndirectStorageBufferAttribute","NodeLoader","manager","load","url","onLoad","onProgress","onError","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","JSON","itemError","parseNodes","nodeJSON","createNodeFromType","setTextures","setNodes","NodeMaterialLoader","nodeMaterials","setNodeMaterials","createMaterialFromType","materialClass","NodeObjectLoader","_nodesJSON","parseMaterials","materials","ClippingGroup"],"sources":["/Users/BrooksCole/Documents/reading-community/frontend/node_modules/three/build/three.webgpu.js"],"sourcesContent":["/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nimport { Color, Vector2, Vector3, Vector4, Matrix3, Matrix4, EventDispatcher, MathUtils, ColorManagement, SRGBTransfer, NoToneMapping, StaticDrawUsage, InterleavedBuffer, DynamicDrawUsage, InterleavedBufferAttribute, NoColorSpace, UnsignedIntType, IntType, WebGLCoordinateSystem, BackSide, CubeReflectionMapping, CubeRefractionMapping, WebGPUCoordinateSystem, TangentSpaceNormalMap, ObjectSpaceNormalMap, InstancedInterleavedBuffer, InstancedBufferAttribute, DataArrayTexture, FloatType, FramebufferTexture, LinearMipmapLinearFilter, DepthTexture, Material, NormalBlending, PointsMaterial, LineBasicMaterial, LineDashedMaterial, NoBlending, MeshNormalMaterial, WebGLCubeRenderTarget, BoxGeometry, Mesh, Scene, LinearFilter, CubeCamera, CubeTexture, EquirectangularReflectionMapping, EquirectangularRefractionMapping, AddOperation, MixOperation, MultiplyOperation, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, Texture, MeshStandardMaterial, MeshPhysicalMaterial, MeshToonMaterial, MeshMatcapMaterial, SpriteMaterial, ShadowMaterial, Uint32BufferAttribute, Uint16BufferAttribute, DoubleSide, DepthStencilFormat, DepthFormat, UnsignedInt248Type, UnsignedByteType, RenderTarget, Plane, Object3D, HalfFloatType, LinearMipMapLinearFilter, OrthographicCamera, BufferGeometry, Float32BufferAttribute, BufferAttribute, UVMapping, Euler, LinearSRGBColorSpace, LessCompare, VSMShadowMap, RGFormat, BasicShadowMap, SphereGeometry, CubeUVReflectionMapping, PerspectiveCamera, RGBAFormat, LinearMipmapNearestFilter, NearestMipmapLinearFilter, Float16BufferAttribute, REVISION, SRGBColorSpace, PCFShadowMap, FrontSide, Frustum, DataTexture, RedIntegerFormat, RedFormat, RGIntegerFormat, RGBIntegerFormat, RGBFormat, RGBAIntegerFormat, UnsignedShortType, ByteType, ShortType, createCanvasElement, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, SrcAlphaFactor, SrcAlphaSaturateFactor, DstColorFactor, DstAlphaFactor, OneMinusSrcColorFactor, OneMinusSrcAlphaFactor, OneMinusDstColorFactor, OneMinusDstAlphaFactor, CullFaceNone, CullFaceBack, CullFaceFront, CustomBlending, MultiplyBlending, SubtractiveBlending, AdditiveBlending, NotEqualDepth, GreaterDepth, GreaterEqualDepth, EqualDepth, LessEqualDepth, LessDepth, AlwaysDepth, NeverDepth, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt5999Type, AlphaFormat, LuminanceFormat, LuminanceAlphaFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, RED_RGTC1_Format, SIGNED_RED_RGTC1_Format, RED_GREEN_RGTC2_Format, SIGNED_RED_GREEN_RGTC2_Format, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NeverCompare, AlwaysCompare, LessEqualCompare, EqualCompare, GreaterEqualCompare, GreaterCompare, NotEqualCompare, warnOnce, NotEqualStencilFunc, GreaterStencilFunc, GreaterEqualStencilFunc, EqualStencilFunc, LessEqualStencilFunc, LessStencilFunc, AlwaysStencilFunc, NeverStencilFunc, DecrementWrapStencilOp, IncrementWrapStencilOp, DecrementStencilOp, IncrementStencilOp, InvertStencilOp, ReplaceStencilOp, ZeroStencilOp, KeepStencilOp, MaxEquation, MinEquation, SpotLight, PointLight, DirectionalLight, RectAreaLight, AmbientLight, HemisphereLight, LightProbe, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, AgXToneMapping, NeutralToneMapping, Group, Loader, FileLoader, MaterialLoader, ObjectLoader } from './three.core.js';\nexport { AdditiveAnimationBlendMode, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BasicDepthPacking, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxHelper, BufferGeometryLoader, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CircleGeometry, Clock, ColorKeyframeTrack, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeTextureLoader, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceFrontBack, Curve, CurvePath, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataTextureLoader, DataUtils, DefaultLoadingManager, DetachedBindMode, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DynamicCopyUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, ExtrudeGeometry, Fog, FogExp2, GLBufferAttribute, GLSL1, GLSL3, GridHelper, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, InstancedBufferGeometry, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, KeyframeTrack, LOD, LatheGeometry, Layers, Light, Line, Line3, LineCurve, LineCurve3, LineLoop, LineSegments, LinearInterpolant, LinearMipMapNearestFilter, LinearTransfer, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, MOUSE, Matrix2, MeshDepthMaterial, MeshDistanceMaterial, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NormalAnimationBlendMode, NumberKeyframeTrack, OctahedronGeometry, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, PCFSoftShadowMap, Path, PlaneGeometry, PlaneHelper, PointLightHelper, Points, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RGBADepthPacking, RGBDepthPacking, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGDepthPacking, RawShaderMaterial, Ray, Raycaster, RingGeometry, ShaderMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, Spherical, SphericalHarmonics3, SplineCurve, SpotLightHelper, Sprite, StaticCopyUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, TOUCH, TetrahedronGeometry, TextureLoader, TextureUtils, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, VectorKeyframeTrack, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLMultipleRenderTargets, WebGLRenderTarget, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding } from './three.core.js';\n\nconst refreshUniforms = [\n\t'alphaMap',\n\t'alphaTest',\n\t'anisotropy',\n\t'anisotropyMap',\n\t'anisotropyRotation',\n\t'aoMap',\n\t'attenuationColor',\n\t'attenuationDistance',\n\t'bumpMap',\n\t'clearcoat',\n\t'clearcoatMap',\n\t'clearcoatNormalMap',\n\t'clearcoatNormalScale',\n\t'clearcoatRoughness',\n\t'color',\n\t'dispersion',\n\t'displacementMap',\n\t'emissive',\n\t'emissiveMap',\n\t'envMap',\n\t'gradientMap',\n\t'ior',\n\t'iridescence',\n\t'iridescenceIOR',\n\t'iridescenceMap',\n\t'iridescenceThicknessMap',\n\t'lightMap',\n\t'map',\n\t'matcap',\n\t'metalness',\n\t'metalnessMap',\n\t'normalMap',\n\t'normalScale',\n\t'opacity',\n\t'roughness',\n\t'roughnessMap',\n\t'sheen',\n\t'sheenColor',\n\t'sheenColorMap',\n\t'sheenRoughnessMap',\n\t'shininess',\n\t'specular',\n\t'specularColor',\n\t'specularColorMap',\n\t'specularIntensity',\n\t'specularIntensityMap',\n\t'specularMap',\n\t'thickness',\n\t'transmission',\n\t'transmissionMap'\n];\n\nclass NodeMaterialObserver {\n\n\tconstructor( builder ) {\n\n\t\tthis.renderObjects = new WeakMap();\n\t\tthis.hasNode = this.containsNode( builder );\n\t\tthis.hasAnimation = builder.object.isSkinnedMesh === true;\n\t\tthis.refreshUniforms = refreshUniforms;\n\t\tthis.renderId = 0;\n\n\t}\n\n\tfirstInitialization( renderObject ) {\n\n\t\tconst hasInitialized = this.renderObjects.has( renderObject );\n\n\t\tif ( hasInitialized === false ) {\n\n\t\t\tthis.getRenderObjectData( renderObject );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetRenderObjectData( renderObject ) {\n\n\t\tlet data = this.renderObjects.get( renderObject );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconst { geometry, material, object } = renderObject;\n\n\t\t\tdata = {\n\t\t\t\tmaterial: this.getMaterialData( material ),\n\t\t\t\tgeometry: {\n\t\t\t\t\tattributes: this.getAttributesData( geometry.attributes ),\n\t\t\t\t\tindexVersion: geometry.index ? geometry.index.version : null,\n\t\t\t\t\tdrawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }\n\t\t\t\t},\n\t\t\t\tworldMatrix: object.matrixWorld.clone()\n\t\t\t};\n\n\t\t\tif ( object.center ) {\n\n\t\t\t\tdata.center = object.center.clone();\n\n\t\t\t}\n\n\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\tdata.morphTargetInfluences = object.morphTargetInfluences.slice();\n\n\t\t\t}\n\n\t\t\tif ( renderObject.bundle !== null ) {\n\n\t\t\t\tdata.version = renderObject.bundle.version;\n\n\t\t\t}\n\n\t\t\tif ( data.material.transmission > 0 ) {\n\n\t\t\t\tconst { width, height } = renderObject.context;\n\n\t\t\t\tdata.bufferWidth = width;\n\t\t\t\tdata.bufferHeight = height;\n\n\t\t\t}\n\n\t\t\tthis.renderObjects.set( renderObject, data );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tgetAttributesData( attributes ) {\n\n\t\tconst attributesData = {};\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tattributesData[ name ] = {\n\t\t\t\tversion: attribute.version\n\t\t\t};\n\n\t\t}\n\n\t\treturn attributesData;\n\n\t}\n\n\tcontainsNode( builder ) {\n\n\t\tconst material = builder.material;\n\n\t\tfor ( const property in material ) {\n\n\t\t\tif ( material[ property ] && material[ property ].isNode )\n\t\t\t\treturn true;\n\n\t\t}\n\n\t\tif ( builder.renderer.nodes.modelViewMatrix !== null || builder.renderer.nodes.modelNormalViewMatrix !== null )\n\t\t\treturn true;\n\n\t\treturn false;\n\n\t}\n\n\tgetMaterialData( material ) {\n\n\t\tconst data = {};\n\n\t\tfor ( const property of this.refreshUniforms ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( value === null || value === undefined ) continue;\n\n\t\t\tif ( typeof value === 'object' && value.clone !== undefined ) {\n\n\t\t\t\tif ( value.isTexture === true ) {\n\n\t\t\t\t\tdata[ property ] = { id: value.id, version: value.version };\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdata[ property ] = value.clone();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdata[ property ] = value;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tequals( renderObject ) {\n\n\t\tconst { object, material, geometry } = renderObject;\n\n\t\tconst renderObjectData = this.getRenderObjectData( renderObject );\n\n\t\t// world matrix\n\n\t\tif ( renderObjectData.worldMatrix.equals( object.matrixWorld ) !== true ) {\n\n\t\t\trenderObjectData.worldMatrix.copy( object.matrixWorld );\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// material\n\n\t\tconst materialData = renderObjectData.material;\n\n\t\tfor ( const property in materialData ) {\n\n\t\t\tconst value = materialData[ property ];\n\t\t\tconst mtlValue = material[ property ];\n\n\t\t\tif ( value.equals !== undefined ) {\n\n\t\t\t\tif ( value.equals( mtlValue ) === false ) {\n\n\t\t\t\t\tvalue.copy( mtlValue );\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( mtlValue.isTexture === true ) {\n\n\t\t\t\tif ( value.id !== mtlValue.id || value.version !== mtlValue.version ) {\n\n\t\t\t\t\tvalue.id = mtlValue.id;\n\t\t\t\t\tvalue.version = mtlValue.version;\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( value !== mtlValue ) {\n\n\t\t\t\tmaterialData[ property ] = mtlValue;\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialData.transmission > 0 ) {\n\n\t\t\tconst { width, height } = renderObject.context;\n\n\t\t\tif ( renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height ) {\n\n\t\t\t\trenderObjectData.bufferWidth = width;\n\t\t\t\trenderObjectData.bufferHeight = height;\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// geometry\n\n\t\tconst storedGeometryData = renderObjectData.geometry;\n\t\tconst attributes = geometry.attributes;\n\t\tconst storedAttributes = storedGeometryData.attributes;\n\n\t\tconst storedAttributeNames = Object.keys( storedAttributes );\n\t\tconst currentAttributeNames = Object.keys( attributes );\n\n\t\tif ( storedAttributeNames.length !== currentAttributeNames.length ) {\n\n\t\t\trenderObjectData.geometry.attributes = this.getAttributesData( attributes );\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compare each attribute\n\n\t\tfor ( const name of storedAttributeNames ) {\n\n\t\t\tconst storedAttributeData = storedAttributes[ name ];\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tif ( attribute === undefined ) {\n\n\t\t\t\t// attribute was removed\n\t\t\t\tdelete storedAttributes[ name ];\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( storedAttributeData.version !== attribute.version ) {\n\n\t\t\t\tstoredAttributeData.version = attribute.version;\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check index\n\n\t\tconst index = geometry.index;\n\t\tconst storedIndexVersion = storedGeometryData.indexVersion;\n\t\tconst currentIndexVersion = index ? index.version : null;\n\n\t\tif ( storedIndexVersion !== currentIndexVersion ) {\n\n\t\t\tstoredGeometryData.indexVersion = currentIndexVersion;\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// check drawRange\n\n\t\tif ( storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count ) {\n\n\t\t\tstoredGeometryData.drawRange.start = geometry.drawRange.start;\n\t\t\tstoredGeometryData.drawRange.count = geometry.drawRange.count;\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tif ( renderObjectData.morphTargetInfluences ) {\n\n\t\t\tlet morphChanged = false;\n\n\t\t\tfor ( let i = 0; i < renderObjectData.morphTargetInfluences.length; i ++ ) {\n\n\t\t\t\tif ( renderObjectData.morphTargetInfluences[ i ] !== object.morphTargetInfluences[ i ] ) {\n\n\t\t\t\t\tmorphChanged = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( morphChanged ) return true;\n\n\t\t}\n\n\t\t// center\n\n\t\tif ( renderObjectData.center ) {\n\n\t\t\tif ( renderObjectData.center.equals( object.center ) === false ) {\n\n\t\t\t\trenderObjectData.center.copy( object.center );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// bundle\n\n\t\tif ( renderObject.bundle !== null ) {\n\n\t\t\trenderObjectData.version = renderObject.bundle.version;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tneedsRefresh( renderObject, nodeFrame ) {\n\n\t\tif ( this.hasNode || this.hasAnimation || this.firstInitialization( renderObject ) )\n\t\t\treturn true;\n\n\t\tconst { renderId } = nodeFrame;\n\n\t\tif ( this.renderId !== renderId ) {\n\n\t\t\tthis.renderId = renderId;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst isStatic = renderObject.object.static === true;\n\t\tconst isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData( renderObject ).version === renderObject.bundle.version;\n\n\t\tif ( isStatic || isBundle )\n\t\t\treturn false;\n\n\t\tconst notEqual = this.equals( renderObject ) !== true;\n\n\t\treturn notEqual;\n\n\t}\n\n}\n\n// cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.\n// A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.\n// Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.\n// See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480\n// https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\nfunction cyrb53( value, seed = 0 ) {\n\n\tlet h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n\n\tif ( value instanceof Array ) {\n\n\t\tfor ( let i = 0, val; i < value.length; i ++ ) {\n\n\t\t\tval = value[ i ];\n\t\t\th1 = Math.imul( h1 ^ val, 2654435761 );\n\t\t\th2 = Math.imul( h2 ^ val, 1597334677 );\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( let i = 0, ch; i < value.length; i ++ ) {\n\n\t\t\tch = value.charCodeAt( i );\n\t\t\th1 = Math.imul( h1 ^ ch, 2654435761 );\n\t\t\th2 = Math.imul( h2 ^ ch, 1597334677 );\n\n\t\t}\n\n\t}\n\n\th1 = Math.imul( h1 ^ ( h1 >>> 16 ), 2246822507 );\n\th1 ^= Math.imul( h2 ^ ( h2 >>> 13 ), 3266489909 );\n\th2 = Math.imul( h2 ^ ( h2 >>> 16 ), 2246822507 );\n\th2 ^= Math.imul( h1 ^ ( h1 >>> 13 ), 3266489909 );\n\n\treturn 4294967296 * ( 2097151 & h2 ) + ( h1 >>> 0 );\n\n}\n\nconst hashString = ( str ) => cyrb53( str );\nconst hashArray = ( array ) => cyrb53( array );\nconst hash$1 = ( ...params ) => cyrb53( params );\n\nfunction getCacheKey$1( object, force = false ) {\n\n\tconst values = [];\n\n\tif ( object.isNode === true ) {\n\n\t\tvalues.push( object.id );\n\t\tobject = object.getSelf();\n\n\t}\n\n\tfor ( const { property, childNode } of getNodeChildren( object ) ) {\n\n\t\tvalues.push( values, cyrb53( property.slice( 0, - 4 ) ), childNode.getCacheKey( force ) );\n\n\t}\n\n\treturn cyrb53( values );\n\n}\n\nfunction* getNodeChildren( node, toJSON = false ) {\n\n\tfor ( const property in node ) {\n\n\t\t// Ignore private properties.\n\t\tif ( property.startsWith( '_' ) === true ) continue;\n\n\t\tconst object = node[ property ];\n\n\t\tif ( Array.isArray( object ) === true ) {\n\n\t\t\tfor ( let i = 0; i < object.length; i ++ ) {\n\n\t\t\t\tconst child = object[ i ];\n\n\t\t\t\tif ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {\n\n\t\t\t\t\tyield { property, index: i, childNode: child };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( object && object.isNode === true ) {\n\n\t\t\tyield { property, childNode: object };\n\n\t\t} else if ( typeof object === 'object' ) {\n\n\t\t\tfor ( const subProperty in object ) {\n\n\t\t\t\tconst child = object[ subProperty ];\n\n\t\t\t\tif ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {\n\n\t\t\t\t\tyield { property, index: subProperty, childNode: child };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst typeFromLength = /*@__PURE__*/ new Map( [\n\t[ 1, 'float' ],\n\t[ 2, 'vec2' ],\n\t[ 3, 'vec3' ],\n\t[ 4, 'vec4' ],\n\t[ 9, 'mat3' ],\n\t[ 16, 'mat4' ]\n] );\n\nfunction getTypeFromLength( length ) {\n\n\treturn typeFromLength.get( length );\n\n}\n\nfunction getLengthFromType( type ) {\n\n\tif ( /float|int|uint/.test( type ) ) return 1;\n\tif ( /vec2/.test( type ) ) return 2;\n\tif ( /vec3/.test( type ) ) return 3;\n\tif ( /vec4/.test( type ) ) return 4;\n\tif ( /mat3/.test( type ) ) return 9;\n\tif ( /mat4/.test( type ) ) return 16;\n\n\tconsole.error( 'THREE.TSL: Unsupported type:', type );\n\n}\n\nfunction getValueType( value ) {\n\n\tif ( value === undefined || value === null ) return null;\n\n\tconst typeOf = typeof value;\n\n\tif ( value.isNode === true ) {\n\n\t\treturn 'node';\n\n\t} else if ( typeOf === 'number' ) {\n\n\t\treturn 'float';\n\n\t} else if ( typeOf === 'boolean' ) {\n\n\t\treturn 'bool';\n\n\t} else if ( typeOf === 'string' ) {\n\n\t\treturn 'string';\n\n\t} else if ( typeOf === 'function' ) {\n\n\t\treturn 'shader';\n\n\t} else if ( value.isVector2 === true ) {\n\n\t\treturn 'vec2';\n\n\t} else if ( value.isVector3 === true ) {\n\n\t\treturn 'vec3';\n\n\t} else if ( value.isVector4 === true ) {\n\n\t\treturn 'vec4';\n\n\t} else if ( value.isMatrix3 === true ) {\n\n\t\treturn 'mat3';\n\n\t} else if ( value.isMatrix4 === true ) {\n\n\t\treturn 'mat4';\n\n\t} else if ( value.isColor === true ) {\n\n\t\treturn 'color';\n\n\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\treturn 'ArrayBuffer';\n\n\t}\n\n\treturn null;\n\n}\n\nfunction getValueFromType( type, ...params ) {\n\n\tconst last4 = type ? type.slice( - 4 ) : undefined;\n\n\tif ( params.length === 1 ) { // ensure same behaviour as in NodeBuilder.format()\n\n\t\tif ( last4 === 'vec2' ) params = [ params[ 0 ], params[ 0 ] ];\n\t\telse if ( last4 === 'vec3' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ] ];\n\t\telse if ( last4 === 'vec4' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ], params[ 0 ] ];\n\n\t}\n\n\tif ( type === 'color' ) {\n\n\t\treturn new Color( ...params );\n\n\t} else if ( last4 === 'vec2' ) {\n\n\t\treturn new Vector2( ...params );\n\n\t} else if ( last4 === 'vec3' ) {\n\n\t\treturn new Vector3( ...params );\n\n\t} else if ( last4 === 'vec4' ) {\n\n\t\treturn new Vector4( ...params );\n\n\t} else if ( last4 === 'mat3' ) {\n\n\t\treturn new Matrix3( ...params );\n\n\t} else if ( last4 === 'mat4' ) {\n\n\t\treturn new Matrix4( ...params );\n\n\t} else if ( type === 'bool' ) {\n\n\t\treturn params[ 0 ] || false;\n\n\t} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {\n\n\t\treturn params[ 0 ] || 0;\n\n\t} else if ( type === 'string' ) {\n\n\t\treturn params[ 0 ] || '';\n\n\t} else if ( type === 'ArrayBuffer' ) {\n\n\t\treturn base64ToArrayBuffer( params[ 0 ] );\n\n\t}\n\n\treturn null;\n\n}\n\nfunction arrayBufferToBase64( arrayBuffer ) {\n\n\tlet chars = '';\n\n\tconst array = new Uint8Array( arrayBuffer );\n\n\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\tchars += String.fromCharCode( array[ i ] );\n\n\t}\n\n\treturn btoa( chars );\n\n}\n\nfunction base64ToArrayBuffer( base64 ) {\n\n\treturn Uint8Array.from( atob( base64 ), c => c.charCodeAt( 0 ) ).buffer;\n\n}\n\nvar NodeUtils = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tarrayBufferToBase64: arrayBufferToBase64,\n\tbase64ToArrayBuffer: base64ToArrayBuffer,\n\tgetCacheKey: getCacheKey$1,\n\tgetLengthFromType: getLengthFromType,\n\tgetNodeChildren: getNodeChildren,\n\tgetTypeFromLength: getTypeFromLength,\n\tgetValueFromType: getValueFromType,\n\tgetValueType: getValueType,\n\thash: hash$1,\n\thashArray: hashArray,\n\thashString: hashString\n});\n\nconst NodeShaderStage = {\n\tVERTEX: 'vertex',\n\tFRAGMENT: 'fragment'\n};\n\nconst NodeUpdateType = {\n\tNONE: 'none',\n\tFRAME: 'frame',\n\tRENDER: 'render',\n\tOBJECT: 'object'\n};\n\nconst NodeType = {\n\tBOOLEAN: 'bool',\n\tINTEGER: 'int',\n\tFLOAT: 'float',\n\tVECTOR2: 'vec2',\n\tVECTOR3: 'vec3',\n\tVECTOR4: 'vec4',\n\tMATRIX2: 'mat2',\n\tMATRIX3: 'mat3',\n\tMATRIX4: 'mat4'\n};\n\nconst NodeAccess = {\n\tREAD_ONLY: 'readOnly',\n\tWRITE_ONLY: 'writeOnly',\n\tREAD_WRITE: 'readWrite',\n};\n\nconst defaultShaderStages = [ 'fragment', 'vertex' ];\nconst defaultBuildStages = [ 'setup', 'analyze', 'generate' ];\nconst shaderStages = [ ...defaultShaderStages, 'compute' ];\nconst vectorComponents = [ 'x', 'y', 'z', 'w' ];\n\nlet _nodeId = 0;\n\nclass Node extends EventDispatcher {\n\n\tstatic get type() {\n\n\t\treturn 'Node';\n\n\t}\n\n\tconstructor( nodeType = null ) {\n\n\t\tsuper();\n\n\t\tthis.nodeType = nodeType;\n\n\t\tthis.updateType = NodeUpdateType.NONE;\n\t\tthis.updateBeforeType = NodeUpdateType.NONE;\n\t\tthis.updateAfterType = NodeUpdateType.NONE;\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tthis.version = 0;\n\n\t\tthis._cacheKey = null;\n\t\tthis._cacheKeyVersion = 0;\n\n\t\tthis.global = false;\n\n\t\tthis.isNode = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _nodeId ++ } );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t}\n\n\tget type() {\n\n\t\treturn this.constructor.type;\n\n\t}\n\n\tonUpdate( callback, updateType ) {\n\n\t\tthis.updateType = updateType;\n\t\tthis.update = callback.bind( this.getSelf() );\n\n\t\treturn this;\n\n\t}\n\n\tonFrameUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.FRAME );\n\n\t}\n\n\tonRenderUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.RENDER );\n\n\t}\n\n\tonObjectUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.OBJECT );\n\n\t}\n\n\tonReference( callback ) {\n\n\t\tthis.updateReference = callback.bind( this.getSelf() );\n\n\t\treturn this;\n\n\t}\n\n\tgetSelf() {\n\n\t\t// Returns non-node object.\n\n\t\treturn this.self || this;\n\n\t}\n\n\tupdateReference( /*state*/ ) {\n\n\t\treturn this;\n\n\t}\n\n\tisGlobal( /*builder*/ ) {\n\n\t\treturn this.global;\n\n\t}\n\n\t* getChildren() {\n\n\t\tfor ( const { childNode } of getNodeChildren( this ) ) {\n\n\t\t\tyield childNode;\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\ttraverse( callback ) {\n\n\t\tcallback( this );\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tchildNode.traverse( callback );\n\n\t\t}\n\n\t}\n\n\tgetCacheKey( force = false ) {\n\n\t\tforce = force || this.version !== this._cacheKeyVersion;\n\n\t\tif ( force === true || this._cacheKey === null ) {\n\n\t\t\tthis._cacheKey = getCacheKey$1( this, force );\n\t\t\tthis._cacheKeyVersion = this.version;\n\n\t\t}\n\n\t\treturn this._cacheKey;\n\n\t}\n\n\tgetScope() {\n\n\t\treturn this;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn this.uuid;\n\n\t}\n\n\tgetUpdateType() {\n\n\t\treturn this.updateType;\n\n\t}\n\n\tgetUpdateBeforeType() {\n\n\t\treturn this.updateBeforeType;\n\n\t}\n\n\tgetUpdateAfterType() {\n\n\t\treturn this.updateAfterType;\n\n\t}\n\n\tgetElementType( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst elementType = builder.getElementType( type );\n\n\t\treturn elementType;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tif ( nodeProperties.outputNode ) {\n\n\t\t\treturn nodeProperties.outputNode.getNodeType( builder );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\tgetShared( builder ) {\n\n\t\tconst hash = this.getHash( builder );\n\t\tconst nodeFromHash = builder.getNodeFromHash( hash );\n\n\t\treturn nodeFromHash || this;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tlet index = 0;\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tnodeProperties[ 'node' + index ++ ] = childNode;\n\n\t\t}\n\n\t\t// return a outputNode if exists\n\t\treturn null;\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tconst usageCount = builder.increaseUsage( this );\n\n\t\tif ( usageCount === 1 ) {\n\n\t\t\t// node flow children\n\n\t\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\t\tfor ( const childNode of Object.values( nodeProperties ) ) {\n\n\t\t\t\tif ( childNode && childNode.isNode === true ) {\n\n\t\t\t\t\tchildNode.build( builder );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { outputNode } = builder.getNodeProperties( this );\n\n\t\tif ( outputNode && outputNode.isNode === true ) {\n\n\t\t\treturn outputNode.build( builder, output );\n\n\t\t}\n\n\t}\n\n\tupdateBefore( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tupdateAfter( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tbuild( builder, output = null ) {\n\n\t\tconst refNode = this.getShared( builder );\n\n\t\tif ( this !== refNode ) {\n\n\t\t\treturn refNode.build( builder, output );\n\n\t\t}\n\n\t\tbuilder.addNode( this );\n\t\tbuilder.addChain( this );\n\n\t\t/* Build stages expected results:\n\t\t\t- \"setup\"\t\t-> Node\n\t\t\t- \"analyze\"\t\t-> null\n\t\t\t- \"generate\"\t-> String\n\t\t*/\n\t\tlet result = null;\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'setup' ) {\n\n\t\t\tthis.updateReference( builder );\n\n\t\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t\tif ( properties.initialized !== true ) {\n\n\t\t\t\tconst stackNodesBeforeSetup = builder.stack.nodes.length;\n\n\t\t\t\tproperties.initialized = true;\n\t\t\t\tproperties.outputNode = this.setup( builder );\n\n\t\t\t\tif ( properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeSetup ) ;\n\n\t\t\t\tfor ( const childNode of Object.values( properties ) ) {\n\n\t\t\t\t\tif ( childNode && childNode.isNode === true ) {\n\n\t\t\t\t\t\tchildNode.build( builder );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( buildStage === 'analyze' ) {\n\n\t\t\tthis.analyze( builder );\n\n\t\t} else if ( buildStage === 'generate' ) {\n\n\t\t\tconst isGenerateOnce = this.generate.length === 1;\n\n\t\t\tif ( isGenerateOnce ) {\n\n\t\t\t\tconst type = this.getNodeType( builder );\n\t\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\t\tresult = nodeData.snippet;\n\n\t\t\t\tif ( result === undefined ) {\n\n\t\t\t\t\tresult = this.generate( builder ) || '';\n\n\t\t\t\t\tnodeData.snippet = result;\n\n\t\t\t\t} else if ( nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined ) {\n\n\t\t\t\t\tbuilder.addFlowCodeHierarchy( this, builder.context.nodeBlock );\n\n\t\t\t\t}\n\n\t\t\t\tresult = builder.format( result, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tresult = this.generate( builder, output ) || '';\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeChain( this );\n\t\tbuilder.addSequentialNode( this );\n\n\t\treturn result;\n\n\t}\n\n\tgetSerializeChildren() {\n\n\t\treturn getNodeChildren( this );\n\n\t}\n\n\tserialize( json ) {\n\n\t\tconst nodeChildren = this.getSerializeChildren();\n\n\t\tconst inputNodes = {};\n\n\t\tfor ( const { property, index, childNode } of nodeChildren ) {\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tif ( inputNodes[ property ] === undefined ) {\n\n\t\t\t\t\tinputNodes[ property ] = Number.isInteger( index ) ? [] : {};\n\n\t\t\t\t}\n\n\t\t\t\tinputNodes[ property ][ index ] = childNode.toJSON( json.meta ).uuid;\n\n\t\t\t} else {\n\n\t\t\t\tinputNodes[ property ] = childNode.toJSON( json.meta ).uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( inputNodes ).length > 0 ) {\n\n\t\t\tjson.inputNodes = inputNodes;\n\n\t\t}\n\n\t}\n\n\tdeserialize( json ) {\n\n\t\tif ( json.inputNodes !== undefined ) {\n\n\t\t\tconst nodes = json.meta.nodes;\n\n\t\t\tfor ( const property in json.inputNodes ) {\n\n\t\t\t\tif ( Array.isArray( json.inputNodes[ property ] ) ) {\n\n\t\t\t\t\tconst inputArray = [];\n\n\t\t\t\t\tfor ( const uuid of json.inputNodes[ property ] ) {\n\n\t\t\t\t\t\tinputArray.push( nodes[ uuid ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis[ property ] = inputArray;\n\n\t\t\t\t} else if ( typeof json.inputNodes[ property ] === 'object' ) {\n\n\t\t\t\t\tconst inputObject = {};\n\n\t\t\t\t\tfor ( const subProperty in json.inputNodes[ property ] ) {\n\n\t\t\t\t\t\tconst uuid = json.inputNodes[ property ][ subProperty ];\n\n\t\t\t\t\t\tinputObject[ subProperty ] = nodes[ uuid ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis[ property ] = inputObject;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst uuid = json.inputNodes[ property ];\n\n\t\t\t\t\tthis[ property ] = nodes[ uuid ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst { uuid, type } = this;\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\t// serialize\n\n\t\tlet data = meta.nodes[ uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = {\n\t\t\t\tuuid,\n\t\t\t\ttype,\n\t\t\t\tmeta,\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.6,\n\t\t\t\t\ttype: 'Node',\n\t\t\t\t\tgenerator: 'Node.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif ( isRoot !== true ) meta.nodes[ data.uuid ] = data;\n\n\t\t\tthis.serialize( data );\n\n\t\t\tdelete data.meta;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass ArrayElementNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ArrayElementNode';\n\n\t} // @TODO: If extending from TempNode it breaks webgpu_compute\n\n\tconstructor( node, indexNode ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.indexNode = indexNode;\n\n\t\tthis.isArrayElementNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getElementType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeSnippet = this.node.build( builder );\n\t\tconst indexSnippet = this.indexNode.build( builder, 'uint' );\n\n\t\treturn `${nodeSnippet}[ ${indexSnippet} ]`;\n\n\t}\n\n}\n\nclass ConvertNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ConvertNode';\n\n\t}\n\n\tconstructor( node, convertTo ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.convertTo = convertTo;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst requestType = this.node.getNodeType( builder );\n\n\t\tlet convertTo = null;\n\n\t\tfor ( const overloadingType of this.convertTo.split( '|' ) ) {\n\n\t\t\tif ( convertTo === null || builder.getTypeLength( requestType ) === builder.getTypeLength( overloadingType ) ) {\n\n\t\t\t\tconvertTo = overloadingType;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn convertTo;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.convertTo = this.convertTo;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.convertTo = data.convertTo;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst snippet = node.build( builder, type );\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\nclass TempNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TempNode';\n\n\t}\n\n\tconstructor( type ) {\n\n\t\tsuper( type );\n\n\t\tthis.isTempNode = true;\n\n\t}\n\n\thasDependencies( builder ) {\n\n\t\treturn builder.getDataFromNode( this ).usageCount > 1;\n\n\t}\n\n\tbuild( builder, output ) {\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'generate' ) {\n\n\t\t\tconst type = builder.getVectorType( this.getNodeType( builder, output ) );\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tif ( nodeData.propertyName !== undefined ) {\n\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t\t} else if ( type !== 'void' && output !== 'void' && this.hasDependencies( builder ) ) {\n\n\t\t\t\tconst snippet = super.build( builder, type );\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, null, type );\n\t\t\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}`, this );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.build( builder, output );\n\n\t}\n\n}\n\nclass JoinNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'JoinNode';\n\n\t}\n\n\tconstructor( nodes = [], nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.nodes = nodes;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( this.nodeType !== null ) {\n\n\t\t\treturn builder.getVectorType( this.nodeType );\n\n\t\t}\n\n\t\treturn builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst nodes = this.nodes;\n\n\t\tconst primitiveType = builder.getComponentType( type );\n\n\t\tconst snippetValues = [];\n\n\t\tfor ( const input of nodes ) {\n\n\t\t\tlet inputSnippet = input.build( builder );\n\n\t\t\tconst inputPrimitiveType = builder.getComponentType( input.getNodeType( builder ) );\n\n\t\t\tif ( inputPrimitiveType !== primitiveType ) {\n\n\t\t\t\tinputSnippet = builder.format( inputSnippet, inputPrimitiveType, primitiveType );\n\n\t\t\t}\n\n\t\t\tsnippetValues.push( inputSnippet );\n\n\t\t}\n\n\t\tconst snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\nconst stringVectorComponents = vectorComponents.join( '' );\n\nclass SplitNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SplitNode';\n\n\t}\n\n\tconstructor( node, components = 'x' ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.components = components;\n\n\t\tthis.isSplitNode = true;\n\n\t}\n\n\tgetVectorLength() {\n\n\t\tlet vectorLength = this.components.length;\n\n\t\tfor ( const c of this.components ) {\n\n\t\t\tvectorLength = Math.max( vectorComponents.indexOf( c ) + 1, vectorLength );\n\n\t\t}\n\n\t\treturn vectorLength;\n\n\t}\n\n\tgetComponentType( builder ) {\n\n\t\treturn builder.getComponentType( this.node.getNodeType( builder ) );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn builder.getTypeFromLength( this.components.length, this.getComponentType( builder ) );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );\n\n\t\tlet snippet = null;\n\n\t\tif ( nodeTypeLength > 1 ) {\n\n\t\t\tlet type = null;\n\n\t\t\tconst componentsLength = this.getVectorLength();\n\n\t\t\tif ( componentsLength >= nodeTypeLength ) {\n\n\t\t\t\t// needed expand the input node\n\n\t\t\t\ttype = builder.getTypeFromLength( this.getVectorLength(), this.getComponentType( builder ) );\n\n\t\t\t}\n\n\t\t\tconst nodeSnippet = node.build( builder, type );\n\n\t\t\tif ( this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice( 0, this.components.length ) ) {\n\n\t\t\t\t// unnecessary swizzle\n\n\t\t\t\tsnippet = builder.format( nodeSnippet, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// ignore .components if .node returns float/integer\n\n\t\t\tsnippet = node.build( builder, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.components = this.components;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.components = data.components;\n\n\t}\n\n}\n\nclass SetNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'SetNode';\n\n\t}\n\n\tconstructor( sourceNode, components, targetNode ) {\n\n\t\tsuper();\n\n\t\tthis.sourceNode = sourceNode;\n\t\tthis.components = components;\n\t\tthis.targetNode = targetNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.sourceNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { sourceNode, components, targetNode } = this;\n\n\t\tconst sourceType = this.getNodeType( builder );\n\t\tconst targetType = builder.getTypeFromLength( components.length, targetNode.getNodeType( builder ) );\n\n\t\tconst targetSnippet = targetNode.build( builder, targetType );\n\t\tconst sourceSnippet = sourceNode.build( builder, sourceType );\n\n\t\tconst length = builder.getTypeLength( sourceType );\n\t\tconst snippetValues = [];\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst component = vectorComponents[ i ];\n\n\t\t\tif ( component === components[ 0 ] ) {\n\n\t\t\t\tsnippetValues.push( targetSnippet );\n\n\t\t\t\ti += components.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tsnippetValues.push( sourceSnippet + '.' + component );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\nclass FlipNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FlipNode';\n\n\t}\n\n\tconstructor( sourceNode, components ) {\n\n\t\tsuper();\n\n\t\tthis.sourceNode = sourceNode;\n\t\tthis.components = components;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.sourceNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { components, sourceNode } = this;\n\n\t\tconst sourceType = this.getNodeType( builder );\n\t\tconst sourceSnippet = sourceNode.build( builder );\n\n\t\tconst sourceCache = builder.getVarFromNode( this );\n\t\tconst sourceProperty = builder.getPropertyName( sourceCache );\n\n\t\tbuilder.addLineFlowCode( sourceProperty + ' = ' + sourceSnippet, this );\n\n\t\tconst length = builder.getTypeLength( sourceType );\n\t\tconst snippetValues = [];\n\n\t\tlet componentIndex = 0;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst component = vectorComponents[ i ];\n\n\t\t\tif ( component === components[ componentIndex ] ) {\n\n\t\t\t\tsnippetValues.push( '1.0 - ' + ( sourceProperty + '.' + component ) );\n\n\t\t\t\tcomponentIndex ++;\n\n\t\t\t} else {\n\n\t\t\t\tsnippetValues.push( sourceProperty + '.' + component );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\nclass InputNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'InputNode';\n\n\t}\n\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.isInputNode = true;\n\n\t\tthis.value = value;\n\t\tthis.precision = null;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.nodeType === null ) {\n\n\t\t\treturn getValueType( this.value );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\tsetPrecision( precision ) {\n\n\t\tthis.precision = precision;\n\n\t\treturn this;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value;\n\n\t\tif ( this.value && this.value.toArray ) data.value = this.value.toArray();\n\n\t\tdata.valueType = getValueType( this.value );\n\t\tdata.nodeType = this.nodeType;\n\n\t\tif ( data.valueType === 'ArrayBuffer' ) data.value = arrayBufferToBase64( data.value );\n\n\t\tdata.precision = this.precision;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.nodeType = data.nodeType;\n\t\tthis.value = Array.isArray( data.value ) ? getValueFromType( data.valueType, ...data.value ) : data.value;\n\n\t\tthis.precision = data.precision || null;\n\n\t\tif ( this.value && this.value.fromArray ) this.value = this.value.fromArray( data.value );\n\n\t}\n\n\tgenerate( /*builder, output*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nclass ConstNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'ConstNode';\n\n\t}\n\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\tthis.isConstNode = true;\n\n\t}\n\n\tgenerateConst( builder ) {\n\n\t\treturn builder.generateConst( this.getNodeType( builder ), this.value );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\treturn builder.format( this.generateConst( builder ), type, output );\n\n\t}\n\n}\n\n//\n\nlet currentStack = null;\n\nconst NodeElements = new Map();\n\nfunction addMethodChaining( name, nodeElement ) {\n\n\tif ( NodeElements.has( name ) ) {\n\n\t\tconsole.warn( `Redefinition of method chaining ${ name }` );\n\t\treturn;\n\n\t}\n\n\tif ( typeof nodeElement !== 'function' ) throw new Error( `Node element ${ name } is not a function` );\n\n\tNodeElements.set( name, nodeElement );\n\n}\n\nconst parseSwizzle = ( props ) => props.replace( /r|s/g, 'x' ).replace( /g|t/g, 'y' ).replace( /b|p/g, 'z' ).replace( /a|q/g, 'w' );\nconst parseSwizzleAndSort = ( props ) => parseSwizzle( props ).split( '' ).sort().join( '' );\n\nconst shaderNodeHandler = {\n\n\tsetup( NodeClosure, params ) {\n\n\t\tconst inputs = params.shift();\n\n\t\treturn NodeClosure( nodeObjects( inputs ), ...params );\n\n\t},\n\n\tget( node, prop, nodeObj ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\tif ( node.isStackNode !== true && prop === 'assign' ) {\n\n\t\t\t\treturn ( ...params ) => {\n\n\t\t\t\t\tcurrentStack.assign( nodeObj, ...params );\n\n\t\t\t\t\treturn nodeObj;\n\n\t\t\t\t};\n\n\t\t\t} else if ( NodeElements.has( prop ) ) {\n\n\t\t\t\tconst nodeElement = NodeElements.get( prop );\n\n\t\t\t\treturn node.isStackNode ? ( ...params ) => nodeObj.add( nodeElement( ...params ) ) : ( ...params ) => nodeElement( nodeObj, ...params );\n\n\t\t\t} else if ( prop === 'self' ) {\n\n\t\t\t\treturn node;\n\n\t\t\t} else if ( prop.endsWith( 'Assign' ) && NodeElements.has( prop.slice( 0, prop.length - 'Assign'.length ) ) ) {\n\n\t\t\t\tconst nodeElement = NodeElements.get( prop.slice( 0, prop.length - 'Assign'.length ) );\n\n\t\t\t\treturn node.isStackNode ? ( ...params ) => nodeObj.assign( params[ 0 ], nodeElement( ...params ) ) : ( ...params ) => nodeObj.assign( nodeElement( nodeObj, ...params ) );\n\n\t\t\t} else if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing properties ( swizzle )\n\n\t\t\t\tprop = parseSwizzle( prop );\n\n\t\t\t\treturn nodeObject( new SplitNode( nodeObj, prop ) );\n\n\t\t\t} else if ( /^set[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// set properties ( swizzle ) and sort to xyzw sequence\n\n\t\t\t\tprop = parseSwizzleAndSort( prop.slice( 3 ).toLowerCase() );\n\n\t\t\t\treturn ( value ) => nodeObject( new SetNode( node, prop, value ) );\n\n\t\t\t} else if ( /^flip[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// set properties ( swizzle ) and sort to xyzw sequence\n\n\t\t\t\tprop = parseSwizzleAndSort( prop.slice( 4 ).toLowerCase() );\n\n\t\t\t\treturn () => nodeObject( new FlipNode( nodeObject( node ), prop ) );\n\n\t\t\t} else if ( prop === 'width' || prop === 'height' || prop === 'depth' ) {\n\n\t\t\t\t// accessing property\n\n\t\t\t\tif ( prop === 'width' ) prop = 'x';\n\t\t\t\telse if ( prop === 'height' ) prop = 'y';\n\t\t\t\telse if ( prop === 'depth' ) prop = 'z';\n\n\t\t\t\treturn nodeObject( new SplitNode( node, prop ) );\n\n\t\t\t} else if ( /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing array\n\n\t\t\t\treturn nodeObject( new ArrayElementNode( nodeObj, new ConstNode( Number( prop ), 'uint' ) ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Reflect.get( node, prop, nodeObj );\n\n\t},\n\n\tset( node, prop, value, nodeObj ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\t// setting properties\n\n\t\t\tif ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\tnodeObj[ prop ].assign( value );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Reflect.set( node, prop, value, nodeObj );\n\n\t}\n\n};\n\nconst nodeObjectsCacheMap = new WeakMap();\nconst nodeBuilderFunctionsCacheMap = new WeakMap();\n\nconst ShaderNodeObject = function ( obj, altType = null ) {\n\n\tconst type = getValueType( obj );\n\n\tif ( type === 'node' ) {\n\n\t\tlet nodeObject = nodeObjectsCacheMap.get( obj );\n\n\t\tif ( nodeObject === undefined ) {\n\n\t\t\tnodeObject = new Proxy( obj, shaderNodeHandler );\n\n\t\t\tnodeObjectsCacheMap.set( obj, nodeObject );\n\t\t\tnodeObjectsCacheMap.set( nodeObject, nodeObject );\n\n\t\t}\n\n\t\treturn nodeObject;\n\n\t} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {\n\n\t\treturn nodeObject( getConstNode( obj, altType ) );\n\n\t} else if ( type === 'shader' ) {\n\n\t\treturn Fn( obj );\n\n\t}\n\n\treturn obj;\n\n};\n\nconst ShaderNodeObjects = function ( objects, altType = null ) {\n\n\tfor ( const name in objects ) {\n\n\t\tobjects[ name ] = nodeObject( objects[ name ], altType );\n\n\t}\n\n\treturn objects;\n\n};\n\nconst ShaderNodeArray = function ( array, altType = null ) {\n\n\tconst len = array.length;\n\n\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\tarray[ i ] = nodeObject( array[ i ], altType );\n\n\t}\n\n\treturn array;\n\n};\n\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {\n\n\tconst assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );\n\n\tif ( scope === null ) {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( ...nodeArray( params ) ) );\n\n\t\t};\n\n\t} else if ( factor !== null ) {\n\n\t\tfactor = nodeObject( factor );\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ), factor ) );\n\n\t\t};\n\n\t} else {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ) ) );\n\n\t\t};\n\n\t}\n\n};\n\nconst ShaderNodeImmutable = function ( NodeClass, ...params ) {\n\n\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\n\n};\n\nclass ShaderCallNodeInternal extends Node {\n\n\tconstructor( shaderNode, inputNodes ) {\n\n\t\tsuper();\n\n\t\tthis.shaderNode = shaderNode;\n\t\tthis.inputNodes = inputNodes;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.shaderNode.nodeType || this.getOutputNode( builder ).getNodeType( builder );\n\n\t}\n\n\tcall( builder ) {\n\n\t\tconst { shaderNode, inputNodes } = this;\n\n\t\tconst properties = builder.getNodeProperties( shaderNode );\n\t\tif ( properties.onceOutput ) return properties.onceOutput;\n\n\t\t//\n\n\t\tlet result = null;\n\n\t\tif ( shaderNode.layout ) {\n\n\t\t\tlet functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get( builder.constructor );\n\n\t\t\tif ( functionNodesCacheMap === undefined ) {\n\n\t\t\t\tfunctionNodesCacheMap = new WeakMap();\n\n\t\t\t\tnodeBuilderFunctionsCacheMap.set( builder.constructor, functionNodesCacheMap );\n\n\t\t\t}\n\n\t\t\tlet functionNode = functionNodesCacheMap.get( shaderNode );\n\n\t\t\tif ( functionNode === undefined ) {\n\n\t\t\t\tfunctionNode = nodeObject( builder.buildFunctionNode( shaderNode ) );\n\n\t\t\t\tfunctionNodesCacheMap.set( shaderNode, functionNode );\n\n\t\t\t}\n\n\t\t\tif ( builder.currentFunctionNode !== null ) {\n\n\t\t\t\tbuilder.currentFunctionNode.includes.push( functionNode );\n\n\t\t\t}\n\n\t\t\tresult = nodeObject( functionNode.call( inputNodes ) );\n\n\t\t} else {\n\n\t\t\tconst jsFunc = shaderNode.jsFunc;\n\t\t\tconst outputNode = inputNodes !== null ? jsFunc( inputNodes, builder ) : jsFunc( builder );\n\n\t\t\tresult = nodeObject( outputNode );\n\n\t\t}\n\n\t\tif ( shaderNode.once ) {\n\n\t\t\tproperties.onceOutput = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tgetOutputNode( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.outputNode === null ) {\n\n\t\t\tproperties.outputNode = this.setupOutput( builder );\n\n\t\t}\n\n\t\treturn properties.outputNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\treturn this.getOutputNode( builder );\n\n\t}\n\n\tsetupOutput( builder ) {\n\n\t\tbuilder.addStack();\n\n\t\tbuilder.stack.outputNode = this.call( builder );\n\n\t\treturn builder.removeStack();\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst outputNode = this.getOutputNode( builder );\n\n\t\treturn outputNode.build( builder, output );\n\n\t}\n\n}\n\nclass ShaderNodeInternal extends Node {\n\n\tconstructor( jsFunc, nodeType ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.jsFunc = jsFunc;\n\t\tthis.layout = null;\n\n\t\tthis.global = true;\n\n\t\tthis.once = false;\n\n\t}\n\n\tsetLayout( layout ) {\n\n\t\tthis.layout = layout;\n\n\t\treturn this;\n\n\t}\n\n\tcall( inputs = null ) {\n\n\t\tnodeObjects( inputs );\n\n\t\treturn nodeObject( new ShaderCallNodeInternal( this, inputs ) );\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.call();\n\n\t}\n\n}\n\nconst bools = [ false, true ];\nconst uints = [ 0, 1, 2, 3 ];\nconst ints = [ - 1, - 2 ];\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];\n\nconst boolsCacheMap = new Map();\nfor ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\n\nconst uintsCacheMap = new Map();\nfor ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\n\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\nfor ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\n\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\nfor ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\nfor ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\n\nconst cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\n\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\n\nconst getConstNode = ( value, type ) => {\n\n\tif ( constNodesCacheMap.has( value ) ) {\n\n\t\treturn constNodesCacheMap.get( value );\n\n\t} else if ( value.isNode === true ) {\n\n\t\treturn value;\n\n\t} else {\n\n\t\treturn new ConstNode( value, type );\n\n\t}\n\n};\n\nconst safeGetNodeType = ( node ) => {\n\n\ttry {\n\n\t\treturn node.getNodeType();\n\n\t} catch ( _ ) {\n\n\t\treturn undefined;\n\n\t}\n\n};\n\nconst ConvertType = function ( type, cacheMap = null ) {\n\n\treturn ( ...params ) => {\n\n\t\tif ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => typeof param !== 'object' ) ) ) {\n\n\t\t\tparams = [ getValueFromType( type, ...params ) ];\n\n\t\t}\n\n\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\n\n\t\t\treturn nodeObject( cacheMap.get( params[ 0 ] ) );\n\n\t\t}\n\n\t\tif ( params.length === 1 ) {\n\n\t\t\tconst node = getConstNode( params[ 0 ], type );\n\t\t\tif ( safeGetNodeType( node ) === type ) return nodeObject( node );\n\t\t\treturn nodeObject( new ConvertNode( node, type ) );\n\n\t\t}\n\n\t\tconst nodes = params.map( param => getConstNode( param ) );\n\t\treturn nodeObject( new JoinNode( nodes, type ) );\n\n\t};\n\n};\n\n// exports\n\nconst defined = ( v ) => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function\n\n// utils\n\nconst getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;\n\n// shader node base\n\nfunction ShaderNode( jsFunc, nodeType ) {\n\n\treturn new Proxy( new ShaderNodeInternal( jsFunc, nodeType ), shaderNodeHandler );\n\n}\n\nconst nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );\nconst nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );\nconst nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );\nconst nodeProxy = ( ...params ) => new ShaderNodeProxy( ...params );\nconst nodeImmutable = ( ...params ) => new ShaderNodeImmutable( ...params );\n\nconst Fn = ( jsFunc, nodeType ) => {\n\n\tconst shaderNode = new ShaderNode( jsFunc, nodeType );\n\n\tconst fn = ( ...params ) => {\n\n\t\tlet inputs;\n\n\t\tnodeObjects( params );\n\n\t\tif ( params[ 0 ] && params[ 0 ].isNode ) {\n\n\t\t\tinputs = [ ...params ];\n\n\t\t} else {\n\n\t\t\tinputs = params[ 0 ];\n\n\t\t}\n\n\t\treturn shaderNode.call( inputs );\n\n\t};\n\n\tfn.shaderNode = shaderNode;\n\n\tfn.setLayout = ( layout ) => {\n\n\t\tshaderNode.setLayout( layout );\n\n\t\treturn fn;\n\n\t};\n\n\tfn.once = () => {\n\n\t\tshaderNode.once = true;\n\n\t\treturn fn;\n\n\t};\n\n\treturn fn;\n\n};\n\nconst tslFn = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ShaderNode: tslFn() has been renamed to Fn().' );\n\treturn Fn( ...params );\n\n};\n\n//\n\naddMethodChaining( 'toGlobal', ( node ) => {\n\n\tnode.global = true;\n\n\treturn node;\n\n} );\n\n//\n\nconst setCurrentStack = ( stack ) => {\n\n\tcurrentStack = stack;\n\n};\n\nconst getCurrentStack = () => currentStack;\n\nconst If = ( ...params ) => currentStack.If( ...params );\n\nfunction append( node ) {\n\n\tif ( currentStack ) currentStack.add( node );\n\n\treturn node;\n\n}\n\naddMethodChaining( 'append', append );\n\n// types\n\nconst color = new ConvertType( 'color' );\n\nconst float = new ConvertType( 'float', cacheMaps.float );\nconst int = new ConvertType( 'int', cacheMaps.ints );\nconst uint = new ConvertType( 'uint', cacheMaps.uint );\nconst bool = new ConvertType( 'bool', cacheMaps.bool );\n\nconst vec2 = new ConvertType( 'vec2' );\nconst ivec2 = new ConvertType( 'ivec2' );\nconst uvec2 = new ConvertType( 'uvec2' );\nconst bvec2 = new ConvertType( 'bvec2' );\n\nconst vec3 = new ConvertType( 'vec3' );\nconst ivec3 = new ConvertType( 'ivec3' );\nconst uvec3 = new ConvertType( 'uvec3' );\nconst bvec3 = new ConvertType( 'bvec3' );\n\nconst vec4 = new ConvertType( 'vec4' );\nconst ivec4 = new ConvertType( 'ivec4' );\nconst uvec4 = new ConvertType( 'uvec4' );\nconst bvec4 = new ConvertType( 'bvec4' );\n\nconst mat2 = new ConvertType( 'mat2' );\nconst mat3 = new ConvertType( 'mat3' );\nconst mat4 = new ConvertType( 'mat4' );\n\nconst string = ( value = '' ) => nodeObject( new ConstNode( value, 'string' ) );\nconst arrayBuffer = ( value ) => nodeObject( new ConstNode( value, 'ArrayBuffer' ) );\n\naddMethodChaining( 'toColor', color );\naddMethodChaining( 'toFloat', float );\naddMethodChaining( 'toInt', int );\naddMethodChaining( 'toUint', uint );\naddMethodChaining( 'toBool', bool );\naddMethodChaining( 'toVec2', vec2 );\naddMethodChaining( 'toIVec2', ivec2 );\naddMethodChaining( 'toUVec2', uvec2 );\naddMethodChaining( 'toBVec2', bvec2 );\naddMethodChaining( 'toVec3', vec3 );\naddMethodChaining( 'toIVec3', ivec3 );\naddMethodChaining( 'toUVec3', uvec3 );\naddMethodChaining( 'toBVec3', bvec3 );\naddMethodChaining( 'toVec4', vec4 );\naddMethodChaining( 'toIVec4', ivec4 );\naddMethodChaining( 'toUVec4', uvec4 );\naddMethodChaining( 'toBVec4', bvec4 );\naddMethodChaining( 'toMat2', mat2 );\naddMethodChaining( 'toMat3', mat3 );\naddMethodChaining( 'toMat4', mat4 );\n\n// basic nodes\n\nconst element = /*@__PURE__*/ nodeProxy( ArrayElementNode );\nconst convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );\nconst split = ( node, channels ) => nodeObject( new SplitNode( nodeObject( node ), channels ) );\n\naddMethodChaining( 'element', element );\naddMethodChaining( 'convert', convert );\n\nclass UniformGroupNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'UniformGroupNode';\n\n\t}\n\n\tconstructor( name, shared = false, order = 1 ) {\n\n\t\tsuper( 'string' );\n\n\t\tthis.name = name;\n\t\tthis.version = 0;\n\n\t\tthis.shared = shared;\n\t\tthis.order = order;\n\t\tthis.isUniformGroup = true;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.name = this.name;\n\t\tdata.version = this.version;\n\t\tdata.shared = this.shared;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.name = data.name;\n\t\tthis.version = data.version;\n\t\tthis.shared = data.shared;\n\n\t}\n\n}\n\nconst uniformGroup = ( name ) => new UniformGroupNode( name );\nconst sharedUniformGroup = ( name, order = 0 ) => new UniformGroupNode( name, true, order );\n\nconst frameGroup = /*@__PURE__*/ sharedUniformGroup( 'frame' );\nconst renderGroup = /*@__PURE__*/ sharedUniformGroup( 'render' );\nconst objectGroup = /*@__PURE__*/ uniformGroup( 'object' );\n\nclass UniformNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformNode';\n\n\t}\n\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\tthis.isUniformNode = true;\n\n\t\tthis.name = '';\n\t\tthis.groupNode = objectGroup;\n\n\t}\n\n\tlabel( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\tsetGroup( group ) {\n\n\t\tthis.groupNode = group;\n\n\t\treturn this;\n\n\t}\n\n\tgetGroup() {\n\n\t\treturn this.groupNode;\n\n\t}\n\n\tgetUniformHash( builder ) {\n\n\t\treturn this.getHash( builder );\n\n\t}\n\n\tonUpdate( callback, updateType ) {\n\n\t\tconst self = this.getSelf();\n\n\t\tcallback = callback.bind( self );\n\n\t\treturn super.onUpdate( ( frame ) => {\n\n\t\t\tconst value = callback( frame, self );\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\tthis.value = value;\n\n\t\t\t}\n\n\t \t}, updateType );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst hash = this.getUniformHash( builder );\n\n\t\tlet sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode === undefined ) {\n\n\t\t\tbuilder.setHashNode( this, hash );\n\n\t\t\tsharedNode = this;\n\n\t\t}\n\n\t\tconst sharedNodeType = sharedNode.getInputType( builder );\n\n\t\tconst nodeUniform = builder.getUniformFromNode( sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label );\n\t\tconst propertyName = builder.getPropertyName( nodeUniform );\n\n\t\tif ( builder.context.label !== undefined ) delete builder.context.label;\n\n\t\treturn builder.format( propertyName, type, output );\n\n\t}\n\n}\n\nconst uniform = ( arg1, arg2 ) => {\n\n\tconst nodeType = getConstNodeType( arg2 || arg1 );\n\n\t// @TODO: get ConstNode from .traverse() in the future\n\tconst value = ( arg1 && arg1.isNode === true ) ? ( arg1.node && arg1.node.value ) || arg1.value : arg1;\n\n\treturn nodeObject( new UniformNode( value, nodeType ) );\n\n};\n\nclass PropertyNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'PropertyNode';\n\n\t}\n\n\tconstructor( nodeType, name = null, varying = false ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.name = name;\n\t\tthis.varying = varying;\n\n\t\tthis.isPropertyNode = true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tisGlobal( /*builder*/ ) {\n\n\t\treturn true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tlet nodeVar;\n\n\t\tif ( this.varying === true ) {\n\n\t\t\tnodeVar = builder.getVaryingFromNode( this, this.name );\n\t\t\tnodeVar.needsInterpolation = true;\n\n\t\t} else {\n\n\t\t\tnodeVar = builder.getVarFromNode( this, this.name );\n\n\t\t}\n\n\t\treturn builder.getPropertyName( nodeVar );\n\n\t}\n\n}\n\nconst property = ( type, name ) => nodeObject( new PropertyNode( type, name ) );\nconst varyingProperty = ( type, name ) => nodeObject( new PropertyNode( type, name, true ) );\n\nconst diffuseColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'DiffuseColor' );\nconst emissive = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'EmissiveColor' );\nconst roughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Roughness' );\nconst metalness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Metalness' );\nconst clearcoat = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Clearcoat' );\nconst clearcoatRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'ClearcoatRoughness' );\nconst sheen = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'Sheen' );\nconst sheenRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SheenRoughness' );\nconst iridescence = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Iridescence' );\nconst iridescenceIOR = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceIOR' );\nconst iridescenceThickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceThickness' );\nconst alphaT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AlphaT' );\nconst anisotropy = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Anisotropy' );\nconst anisotropyT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyT' );\nconst anisotropyB = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyB' );\nconst specularColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'SpecularColor' );\nconst specularF90 = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SpecularF90' );\nconst shininess = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Shininess' );\nconst output = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'Output' );\nconst dashSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'dashSize' );\nconst gapSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'gapSize' );\nconst pointWidth = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'pointWidth' );\nconst ior = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IOR' );\nconst transmission = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Transmission' );\nconst thickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Thickness' );\nconst attenuationDistance = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AttenuationDistance' );\nconst attenuationColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'AttenuationColor' );\nconst dispersion = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Dispersion' );\n\nclass AssignNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'AssignNode';\n\n\t}\n\n\tconstructor( targetNode, sourceNode ) {\n\n\t\tsuper();\n\n\t\tthis.targetNode = targetNode;\n\t\tthis.sourceNode = sourceNode;\n\n\t}\n\n\thasDependencies() {\n\n\t\treturn false;\n\n\t}\n\n\tgetNodeType( builder, output ) {\n\n\t\treturn output !== 'void' ? this.targetNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tneedsSplitAssign( builder ) {\n\n\t\tconst { targetNode } = this;\n\n\t\tif ( builder.isAvailable( 'swizzleAssign' ) === false && targetNode.isSplitNode && targetNode.components.length > 1 ) {\n\n\t\t\tconst targetLength = builder.getTypeLength( targetNode.node.getNodeType( builder ) );\n\t\t\tconst assignDiferentVector = vectorComponents.join( '' ).slice( 0, targetLength ) !== targetNode.components;\n\n\t\t\treturn assignDiferentVector;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { targetNode, sourceNode } = this;\n\n\t\tconst needsSplitAssign = this.needsSplitAssign( builder );\n\n\t\tconst targetType = targetNode.getNodeType( builder );\n\n\t\tconst target = targetNode.context( { assign: true } ).build( builder );\n\t\tconst source = sourceNode.build( builder, targetType );\n\n\t\tconst sourceType = sourceNode.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t//\n\n\t\tlet snippet;\n\n\t\tif ( nodeData.initialized === true ) {\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else if ( needsSplitAssign ) {\n\n\t\t\tconst sourceVar = builder.getVarFromNode( this, null, targetType );\n\t\t\tconst sourceProperty = builder.getPropertyName( sourceVar );\n\n\t\t\tbuilder.addLineFlowCode( `${ sourceProperty } = ${ source }`, this );\n\n\t\t\tconst targetRoot = targetNode.node.context( { assign: true } ).build( builder );\n\n\t\t\tfor ( let i = 0; i < targetNode.components.length; i ++ ) {\n\n\t\t\t\tconst component = targetNode.components[ i ];\n\n\t\t\t\tbuilder.addLineFlowCode( `${ targetRoot }.${ component } = ${ sourceProperty }[ ${ i } ]`, this );\n\n\t\t\t}\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsnippet = `${ target } = ${ source }`;\n\n\t\t\tif ( output === 'void' || sourceType === 'void' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\t\tsnippet = target;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tnodeData.initialized = true;\n\n\t\treturn builder.format( snippet, targetType, output );\n\n\t}\n\n}\n\nconst assign = /*@__PURE__*/ nodeProxy( AssignNode );\n\naddMethodChaining( 'assign', assign );\n\nclass FunctionCallNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionCallNode';\n\n\t}\n\n\tconstructor( functionNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\tthis.functionNode = functionNode;\n\t\tthis.parameters = parameters;\n\n\t}\n\n\tsetParameters( parameters ) {\n\n\t\tthis.parameters = parameters;\n\n\t\treturn this;\n\n\t}\n\n\tgetParameters() {\n\n\t\treturn this.parameters;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.functionNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst params = [];\n\n\t\tconst functionNode = this.functionNode;\n\n\t\tconst inputs = functionNode.getInputs( builder );\n\t\tconst parameters = this.parameters;\n\n\t\tconst generateInput = ( node, inputNode ) => {\n\n\t\t\tconst type = inputNode.type;\n\t\t\tconst pointer = type === 'pointer';\n\n\t\t\tlet output;\n\n\t\t\tif ( pointer ) output = '&' + node.build( builder );\n\t\t\telse output = node.build( builder, type );\n\n\t\t\treturn output;\n\n\t\t};\n\n\t\tif ( Array.isArray( parameters ) ) {\n\n\t\t\tfor ( let i = 0; i < parameters.length; i ++ ) {\n\n\t\t\t\tparams.push( generateInput( parameters[ i ], inputs[ i ] ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const inputNode of inputs ) {\n\n\t\t\t\tconst node = parameters[ inputNode.name ];\n\n\t\t\t\tif ( node !== undefined ) {\n\n\t\t\t\t\tparams.push( generateInput( node, inputNode ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.` );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst functionName = functionNode.build( builder, 'property' );\n\n\t\treturn `${functionName}( ${params.join( ', ' )} )`;\n\n\t}\n\n}\n\nconst call = ( func, ...params ) => {\n\n\tparams = params.length > 1 || ( params[ 0 ] && params[ 0 ].isNode === true ) ? nodeArray( params ) : nodeObjects( params[ 0 ] );\n\n\treturn nodeObject( new FunctionCallNode( nodeObject( func ), params ) );\n\n};\n\naddMethodChaining( 'call', call );\n\nclass OperatorNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'OperatorNode';\n\n\t}\n\n\tconstructor( op, aNode, bNode, ...params ) {\n\n\t\tsuper();\n\n\t\tif ( params.length > 0 ) {\n\n\t\t\tlet finalOp = new OperatorNode( op, aNode, bNode );\n\n\t\t\tfor ( let i = 0; i < params.length - 1; i ++ ) {\n\n\t\t\t\tfinalOp = new OperatorNode( op, finalOp, params[ i ] );\n\n\t\t\t}\n\n\t\t\taNode = finalOp;\n\t\t\tbNode = params[ params.length - 1 ];\n\n\t\t}\n\n\t\tthis.op = op;\n\t\tthis.aNode = aNode;\n\t\tthis.bNode = bNode;\n\n\t}\n\n\tgetNodeType( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst typeA = aNode.getNodeType( builder );\n\t\tconst typeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;\n\n\t\tif ( typeA === 'void' || typeB === 'void' ) {\n\n\t\t\treturn 'void';\n\n\t\t} else if ( op === '%' ) {\n\n\t\t\treturn typeA;\n\n\t\t} else if ( op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {\n\n\t\t\treturn builder.getIntegerType( typeA );\n\n\t\t} else if ( op === '!' || op === '==' || op === '&&' || op === '||' || op === '^^' ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\tconst typeLength = output ? builder.getTypeLength( output ) : Math.max( builder.getTypeLength( typeA ), builder.getTypeLength( typeB ) );\n\n\t\t\treturn typeLength > 1 ? `bvec${ typeLength }` : 'bool';\n\n\t\t} else {\n\n\t\t\tif ( typeA === 'float' && builder.isMatrix( typeB ) ) {\n\n\t\t\t\treturn typeB;\n\n\t\t\t} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t// matrix x vector\n\n\t\t\t\treturn builder.getVectorFromMatrix( typeA );\n\n\t\t\t} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t// vector x matrix\n\n\t\t\t\treturn builder.getVectorFromMatrix( typeB );\n\n\t\t\t} else if ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {\n\n\t\t\t\t// anytype x anytype: use the greater length vector\n\n\t\t\t\treturn typeB;\n\n\t\t\t}\n\n\t\t\treturn typeA;\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst type = this.getNodeType( builder, output );\n\n\t\tlet typeA = null;\n\t\tlet typeB = null;\n\n\t\tif ( type !== 'void' ) {\n\n\t\t\ttypeA = aNode.getNodeType( builder );\n\t\t\ttypeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;\n\n\t\t\tif ( op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==' ) {\n\n\t\t\t\tif ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\ttypeB = typeA;\n\n\t\t\t\t} else if ( typeA !== typeB ) {\n\n\t\t\t\t\ttypeA = typeB = 'float';\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>>' || op === '<<' ) {\n\n\t\t\t\ttypeA = type;\n\t\t\t\ttypeB = builder.changeComponentType( typeB, 'uint' );\n\n\t\t\t} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t// matrix x vector\n\n\t\t\t\ttypeB = builder.getVectorFromMatrix( typeA );\n\n\t\t\t} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t// vector x matrix\n\n\t\t\t\ttypeA = builder.getVectorFromMatrix( typeB );\n\n\t\t\t} else {\n\n\t\t\t\t// anytype x anytype\n\n\t\t\t\ttypeA = typeB = type;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttypeA = typeB = type;\n\n\t\t}\n\n\t\tconst a = aNode.build( builder, typeA );\n\t\tconst b = typeof bNode !== 'undefined' ? bNode.build( builder, typeB ) : null;\n\n\t\tconst outputLength = builder.getTypeLength( output );\n\t\tconst fnOpSnippet = builder.getFunctionOperator( op );\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\tif ( op === '<' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'lessThan', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } < ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '<=' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'lessThanEqual', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } <= ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'greaterThan', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } > ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>=' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'greaterThanEqual', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } >= ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '!' || op === '~' ) {\n\n\t\t\t\treturn builder.format( `(${op}${a})`, typeA, output );\n\n\t\t\t} else if ( fnOpSnippet ) {\n\n\t\t\t\treturn builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\treturn builder.format( `( ${ a } ${ op } ${ b } )`, type, output );\n\n\t\t\t}\n\n\t\t} else if ( typeA !== 'void' ) {\n\n\t\t\tif ( fnOpSnippet ) {\n\n\t\t\t\treturn builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\treturn builder.format( `${ a } ${ op } ${ b }`, type, output );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.op = this.op;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.op = data.op;\n\n\t}\n\n}\n\nconst add = /*@__PURE__*/ nodeProxy( OperatorNode, '+' );\nconst sub = /*@__PURE__*/ nodeProxy( OperatorNode, '-' );\nconst mul = /*@__PURE__*/ nodeProxy( OperatorNode, '*' );\nconst div = /*@__PURE__*/ nodeProxy( OperatorNode, '/' );\nconst modInt = /*@__PURE__*/ nodeProxy( OperatorNode, '%' );\nconst equal = /*@__PURE__*/ nodeProxy( OperatorNode, '==' );\nconst notEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '!=' );\nconst lessThan = /*@__PURE__*/ nodeProxy( OperatorNode, '<' );\nconst greaterThan = /*@__PURE__*/ nodeProxy( OperatorNode, '>' );\nconst lessThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '<=' );\nconst greaterThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '>=' );\nconst and = /*@__PURE__*/ nodeProxy( OperatorNode, '&&' );\nconst or = /*@__PURE__*/ nodeProxy( OperatorNode, '||' );\nconst not = /*@__PURE__*/ nodeProxy( OperatorNode, '!' );\nconst xor = /*@__PURE__*/ nodeProxy( OperatorNode, '^^' );\nconst bitAnd = /*@__PURE__*/ nodeProxy( OperatorNode, '&' );\nconst bitNot = /*@__PURE__*/ nodeProxy( OperatorNode, '~' );\nconst bitOr = /*@__PURE__*/ nodeProxy( OperatorNode, '|' );\nconst bitXor = /*@__PURE__*/ nodeProxy( OperatorNode, '^' );\nconst shiftLeft = /*@__PURE__*/ nodeProxy( OperatorNode, '<<' );\nconst shiftRight = /*@__PURE__*/ nodeProxy( OperatorNode, '>>' );\n\naddMethodChaining( 'add', add );\naddMethodChaining( 'sub', sub );\naddMethodChaining( 'mul', mul );\naddMethodChaining( 'div', div );\naddMethodChaining( 'modInt', modInt );\naddMethodChaining( 'equal', equal );\naddMethodChaining( 'notEqual', notEqual );\naddMethodChaining( 'lessThan', lessThan );\naddMethodChaining( 'greaterThan', greaterThan );\naddMethodChaining( 'lessThanEqual', lessThanEqual );\naddMethodChaining( 'greaterThanEqual', greaterThanEqual );\naddMethodChaining( 'and', and );\naddMethodChaining( 'or', or );\naddMethodChaining( 'not', not );\naddMethodChaining( 'xor', xor );\naddMethodChaining( 'bitAnd', bitAnd );\naddMethodChaining( 'bitNot', bitNot );\naddMethodChaining( 'bitOr', bitOr );\naddMethodChaining( 'bitXor', bitXor );\naddMethodChaining( 'shiftLeft', shiftLeft );\naddMethodChaining( 'shiftRight', shiftRight );\n\n\nconst remainder = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.OperatorNode: .remainder() has been renamed to .modInt().' );\n\treturn modInt( ...params );\n\n};\n\naddMethodChaining( 'remainder', remainder );\n\nclass MathNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'MathNode';\n\n\t}\n\n\tconstructor( method, aNode, bNode = null, cNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.method = method;\n\n\t\tthis.aNode = aNode;\n\t\tthis.bNode = bNode;\n\t\tthis.cNode = cNode;\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\tconst aType = this.aNode.getNodeType( builder );\n\t\tconst bType = this.bNode ? this.bNode.getNodeType( builder ) : null;\n\t\tconst cType = this.cNode ? this.cNode.getNodeType( builder ) : null;\n\n\t\tconst aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );\n\t\tconst bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );\n\t\tconst cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );\n\n\t\tif ( aLen > bLen && aLen > cLen ) {\n\n\t\t\treturn aType;\n\n\t\t} else if ( bLen > cLen ) {\n\n\t\t\treturn bType;\n\n\t\t} else if ( cLen > aLen ) {\n\n\t\t\treturn cType;\n\n\t\t}\n\n\t\treturn aType;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tif ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {\n\n\t\t\treturn 'float';\n\n\t\t} else if ( method === MathNode.CROSS ) {\n\n\t\t\treturn 'vec3';\n\n\t\t} else if ( method === MathNode.ALL ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( method === MathNode.EQUALS ) {\n\n\t\t\treturn builder.changeComponentType( this.aNode.getNodeType( builder ), 'bool' );\n\n\t\t} else if ( method === MathNode.MOD ) {\n\n\t\t\treturn this.aNode.getNodeType( builder );\n\n\t\t} else {\n\n\t\t\treturn this.getInputType( builder );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.aNode;\n\t\tconst b = this.bNode;\n\t\tconst c = this.cNode;\n\n\t\tconst isWebGL = builder.renderer.isWebGLRenderer === true;\n\n\t\tif ( method === MathNode.TRANSFORM_DIRECTION ) {\n\n\t\t\t// dir can be either a direction vector or a normal vector\n\t\t\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\t\t\tlet tA = a;\n\t\t\tlet tB = b;\n\n\t\t\tif ( builder.isMatrix( tA.getNodeType( builder ) ) ) {\n\n\t\t\t\ttB = vec4( vec3( tB ), 0.0 );\n\n\t\t\t} else {\n\n\t\t\t\ttA = vec4( vec3( tA ), 0.0 );\n\n\t\t\t}\n\n\t\t\tconst mulNode = mul( tA, tB ).xyz;\n\n\t\t\treturn normalize( mulNode ).build( builder, output );\n\n\t\t} else if ( method === MathNode.NEGATE ) {\n\n\t\t\treturn builder.format( '( - ' + a.build( builder, inputType ) + ' )', type, output );\n\n\t\t} else if ( method === MathNode.ONE_MINUS ) {\n\n\t\t\treturn sub( 1.0, a ).build( builder, output );\n\n\t\t} else if ( method === MathNode.RECIPROCAL ) {\n\n\t\t\treturn div( 1.0, a ).build( builder, output );\n\n\t\t} else if ( method === MathNode.DIFFERENCE ) {\n\n\t\t\treturn abs( sub( a, b ) ).build( builder, output );\n\n\t\t} else {\n\n\t\t\tconst params = [];\n\n\t\t\tif ( method === MathNode.CROSS || method === MathNode.MOD ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, type ),\n\t\t\t\t\tb.build( builder, type )\n\t\t\t\t);\n\n\t\t\t} else if ( isWebGL && method === MathNode.STEP ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),\n\t\t\t\t\tb.build( builder, inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( ( isWebGL && ( method === MathNode.MIN || method === MathNode.MAX ) ) || method === MathNode.MOD ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.REFRACT ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, 'float' )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.MIX ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tparams.push( a.build( builder, inputType ) );\n\t\t\t\tif ( b !== null ) params.push( b.build( builder, inputType ) );\n\t\t\t\tif ( c !== null ) params.push( c.build( builder, inputType ) );\n\n\t\t\t}\n\n\t\t\treturn builder.format( `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`, type, output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.method = this.method;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.method = data.method;\n\n\t}\n\n}\n\n// 1 input\n\nMathNode.ALL = 'all';\nMathNode.ANY = 'any';\nMathNode.EQUALS = 'equals';\n\nMathNode.RADIANS = 'radians';\nMathNode.DEGREES = 'degrees';\nMathNode.EXP = 'exp';\nMathNode.EXP2 = 'exp2';\nMathNode.LOG = 'log';\nMathNode.LOG2 = 'log2';\nMathNode.SQRT = 'sqrt';\nMathNode.INVERSE_SQRT = 'inversesqrt';\nMathNode.FLOOR = 'floor';\nMathNode.CEIL = 'ceil';\nMathNode.NORMALIZE = 'normalize';\nMathNode.FRACT = 'fract';\nMathNode.SIN = 'sin';\nMathNode.COS = 'cos';\nMathNode.TAN = 'tan';\nMathNode.ASIN = 'asin';\nMathNode.ACOS = 'acos';\nMathNode.ATAN = 'atan';\nMathNode.ABS = 'abs';\nMathNode.SIGN = 'sign';\nMathNode.LENGTH = 'length';\nMathNode.NEGATE = 'negate';\nMathNode.ONE_MINUS = 'oneMinus';\nMathNode.DFDX = 'dFdx';\nMathNode.DFDY = 'dFdy';\nMathNode.ROUND = 'round';\nMathNode.RECIPROCAL = 'reciprocal';\nMathNode.TRUNC = 'trunc';\nMathNode.FWIDTH = 'fwidth';\nMathNode.BITCAST = 'bitcast';\nMathNode.TRANSPOSE = 'transpose';\n\n// 2 inputs\n\nMathNode.ATAN2 = 'atan2';\nMathNode.MIN = 'min';\nMathNode.MAX = 'max';\nMathNode.MOD = 'mod';\nMathNode.STEP = 'step';\nMathNode.REFLECT = 'reflect';\nMathNode.DISTANCE = 'distance';\nMathNode.DIFFERENCE = 'difference';\nMathNode.DOT = 'dot';\nMathNode.CROSS = 'cross';\nMathNode.POW = 'pow';\nMathNode.TRANSFORM_DIRECTION = 'transformDirection';\n\n// 3 inputs\n\nMathNode.MIX = 'mix';\nMathNode.CLAMP = 'clamp';\nMathNode.REFRACT = 'refract';\nMathNode.SMOOTHSTEP = 'smoothstep';\nMathNode.FACEFORWARD = 'faceforward';\n\nconst EPSILON = /*@__PURE__*/ float( 1e-6 );\nconst INFINITY = /*@__PURE__*/ float( 1e6 );\nconst PI = /*@__PURE__*/ float( Math.PI );\nconst PI2 = /*@__PURE__*/ float( Math.PI * 2 );\n\nconst all = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ALL );\nconst any = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ANY );\nconst equals = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EQUALS );\n\nconst radians = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RADIANS );\nconst degrees = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DEGREES );\nconst exp = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP );\nconst exp2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP2 );\nconst log = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG );\nconst log2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG2 );\nconst sqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SQRT );\nconst inverseSqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.INVERSE_SQRT );\nconst floor = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FLOOR );\nconst ceil = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CEIL );\nconst normalize = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NORMALIZE );\nconst fract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FRACT );\nconst sin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIN );\nconst cos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.COS );\nconst tan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TAN );\nconst asin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ASIN );\nconst acos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ACOS );\nconst atan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN );\nconst abs = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ABS );\nconst sign = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIGN );\nconst length = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LENGTH );\nconst negate = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NEGATE );\nconst oneMinus = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ONE_MINUS );\nconst dFdx = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDX );\nconst dFdy = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDY );\nconst round = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ROUND );\nconst reciprocal = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RECIPROCAL );\nconst trunc = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRUNC );\nconst fwidth = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FWIDTH );\nconst bitcast = /*@__PURE__*/ nodeProxy( MathNode, MathNode.BITCAST );\nconst transpose = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSPOSE );\n\nconst atan2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN2 );\nconst min$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIN );\nconst max$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MAX );\nconst mod = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MOD );\nconst step = /*@__PURE__*/ nodeProxy( MathNode, MathNode.STEP );\nconst reflect = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFLECT );\nconst distance = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DISTANCE );\nconst difference = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DIFFERENCE );\nconst dot = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DOT );\nconst cross = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CROSS );\nconst pow = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW );\nconst pow2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 2 );\nconst pow3 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 3 );\nconst pow4 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 4 );\nconst transformDirection = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSFORM_DIRECTION );\n\nconst cbrt = ( a ) => mul( sign( a ), pow( abs( a ), 1.0 / 3.0 ) );\nconst lengthSq = ( a ) => dot( a, a );\nconst mix = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIX );\nconst clamp = ( value, low = 0, high = 1 ) => nodeObject( new MathNode( MathNode.CLAMP, nodeObject( value ), nodeObject( low ), nodeObject( high ) ) );\nconst saturate = ( value ) => clamp( value );\nconst refract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFRACT );\nconst smoothstep = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SMOOTHSTEP );\nconst faceForward = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FACEFORWARD );\n\nconst rand = /*@__PURE__*/ Fn( ( [ uv ] ) => {\n\n\tconst a = 12.9898, b = 78.233, c = 43758.5453;\n\tconst dt = dot( uv.xy, vec2( a, b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ).mul( c ) );\n\n} );\n\nconst mixElement = ( t, e1, e2 ) => mix( e1, e2, t );\nconst smoothstepElement = ( x, low, high ) => smoothstep( low, high, x );\n\naddMethodChaining( 'all', all );\naddMethodChaining( 'any', any );\naddMethodChaining( 'equals', equals );\n\naddMethodChaining( 'radians', radians );\naddMethodChaining( 'degrees', degrees );\naddMethodChaining( 'exp', exp );\naddMethodChaining( 'exp2', exp2 );\naddMethodChaining( 'log', log );\naddMethodChaining( 'log2', log2 );\naddMethodChaining( 'sqrt', sqrt );\naddMethodChaining( 'inverseSqrt', inverseSqrt );\naddMethodChaining( 'floor', floor );\naddMethodChaining( 'ceil', ceil );\naddMethodChaining( 'normalize', normalize );\naddMethodChaining( 'fract', fract );\naddMethodChaining( 'sin', sin );\naddMethodChaining( 'cos', cos );\naddMethodChaining( 'tan', tan );\naddMethodChaining( 'asin', asin );\naddMethodChaining( 'acos', acos );\naddMethodChaining( 'atan', atan );\naddMethodChaining( 'abs', abs );\naddMethodChaining( 'sign', sign );\naddMethodChaining( 'length', length );\naddMethodChaining( 'lengthSq', lengthSq );\naddMethodChaining( 'negate', negate );\naddMethodChaining( 'oneMinus', oneMinus );\naddMethodChaining( 'dFdx', dFdx );\naddMethodChaining( 'dFdy', dFdy );\naddMethodChaining( 'round', round );\naddMethodChaining( 'reciprocal', reciprocal );\naddMethodChaining( 'trunc', trunc );\naddMethodChaining( 'fwidth', fwidth );\naddMethodChaining( 'atan2', atan2 );\naddMethodChaining( 'min', min$1 );\naddMethodChaining( 'max', max$1 );\naddMethodChaining( 'mod', mod );\naddMethodChaining( 'step', step );\naddMethodChaining( 'reflect', reflect );\naddMethodChaining( 'distance', distance );\naddMethodChaining( 'dot', dot );\naddMethodChaining( 'cross', cross );\naddMethodChaining( 'pow', pow );\naddMethodChaining( 'pow2', pow2 );\naddMethodChaining( 'pow3', pow3 );\naddMethodChaining( 'pow4', pow4 );\naddMethodChaining( 'transformDirection', transformDirection );\naddMethodChaining( 'mix', mixElement );\naddMethodChaining( 'clamp', clamp );\naddMethodChaining( 'refract', refract );\naddMethodChaining( 'smoothstep', smoothstepElement );\naddMethodChaining( 'faceForward', faceForward );\naddMethodChaining( 'difference', difference );\naddMethodChaining( 'saturate', saturate );\naddMethodChaining( 'cbrt', cbrt );\naddMethodChaining( 'transpose', transpose );\naddMethodChaining( 'rand', rand );\n\nclass ConditionalNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ConditionalNode';\n\n\t}\n\n\tconstructor( condNode, ifNode, elseNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.condNode = condNode;\n\n\t\tthis.ifNode = ifNode;\n\t\tthis.elseNode = elseNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst ifType = this.ifNode.getNodeType( builder );\n\n\t\tif ( this.elseNode !== null ) {\n\n\t\t\tconst elseType = this.elseNode.getNodeType( builder );\n\n\t\t\tif ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {\n\n\t\t\t\treturn elseType;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ifType;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst condNode = this.condNode.cache();\n\t\tconst ifNode = this.ifNode.cache();\n\t\tconst elseNode = this.elseNode ? this.elseNode.cache() : null;\n\n\t\t//\n\n\t\tconst currentNodeBlock = builder.context.nodeBlock;\n\n\t\tbuilder.getDataFromNode( ifNode ).parentNodeBlock = currentNodeBlock;\n\t\tif ( elseNode !== null ) builder.getDataFromNode( elseNode ).parentNodeBlock = currentNodeBlock;\n\n\t\t//\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.condNode = condNode;\n\t\tproperties.ifNode = ifNode.context( { nodeBlock: ifNode } );\n\t\tproperties.elseNode = elseNode ? elseNode.context( { nodeBlock: elseNode } ) : null;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tif ( nodeData.nodeProperty !== undefined ) {\n\n\t\t\treturn nodeData.nodeProperty;\n\n\t\t}\n\n\t\tconst { condNode, ifNode, elseNode } = builder.getNodeProperties( this );\n\n\t\tconst needsOutput = output !== 'void';\n\t\tconst nodeProperty = needsOutput ? property( type ).build( builder ) : '';\n\n\t\tnodeData.nodeProperty = nodeProperty;\n\n\t\tconst nodeSnippet = condNode.build( builder, 'bool' );\n\n\t\tbuilder.addFlowCode( `\\n${ builder.tab }if ( ${ nodeSnippet } ) {\\n\\n` ).addFlowTab();\n\n\t\tlet ifSnippet = ifNode.build( builder, type );\n\n\t\tif ( ifSnippet ) {\n\n\t\t\tif ( needsOutput ) {\n\n\t\t\t\tifSnippet = nodeProperty + ' = ' + ifSnippet + ';';\n\n\t\t\t} else {\n\n\t\t\t\tifSnippet = 'return ' + ifSnippet + ';';\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeFlowTab().addFlowCode( builder.tab + '\\t' + ifSnippet + '\\n\\n' + builder.tab + '}' );\n\n\t\tif ( elseNode !== null ) {\n\n\t\t\tbuilder.addFlowCode( ' else {\\n\\n' ).addFlowTab();\n\n\t\t\tlet elseSnippet = elseNode.build( builder, type );\n\n\t\t\tif ( elseSnippet ) {\n\n\t\t\t\tif ( needsOutput ) {\n\n\t\t\t\t\telseSnippet = nodeProperty + ' = ' + elseSnippet + ';';\n\n\t\t\t\t} else {\n\n\t\t\t\t\telseSnippet = 'return ' + elseSnippet + ';';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbuilder.removeFlowTab().addFlowCode( builder.tab + '\\t' + elseSnippet + '\\n\\n' + builder.tab + '}\\n\\n' );\n\n\t\t} else {\n\n\t\t\tbuilder.addFlowCode( '\\n\\n' );\n\n\t\t}\n\n\t\treturn builder.format( nodeProperty, type, output );\n\n\t}\n\n}\n\nconst select = /*@__PURE__*/ nodeProxy( ConditionalNode );\n\naddMethodChaining( 'select', select );\n\n//\n\nconst cond = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ConditionalNode: cond() has been renamed to select().' );\n\treturn select( ...params );\n\n};\n\naddMethodChaining( 'cond', cond );\n\nclass ContextNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ContextNode';\n\n\t}\n\n\tconstructor( node, value = {} ) {\n\n\t\tsuper();\n\n\t\tthis.isContextNode = true;\n\n\t\tthis.node = node;\n\t\tthis.value = value;\n\n\t}\n\n\tgetScope() {\n\n\t\treturn this.node.getScope();\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tthis.node.build( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( { ...builder.context, ...this.value } );\n\n\t\tconst node = this.node.build( builder );\n\n\t\tbuilder.setContext( previousContext );\n\n\t\treturn node;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( { ...builder.context, ...this.value } );\n\n\t\tconst snippet = this.node.build( builder, output );\n\n\t\tbuilder.setContext( previousContext );\n\n\t\treturn snippet;\n\n\t}\n\n}\n\nconst context = /*@__PURE__*/ nodeProxy( ContextNode );\nconst label = ( node, name ) => context( node, { label: name } );\n\naddMethodChaining( 'context', context );\naddMethodChaining( 'label', label );\n\nclass VarNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'VarNode';\n\n\t}\n\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.name = name;\n\n\t\tthis.global = true;\n\n\t\tthis.isVarNode = true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { node, name } = this;\n\n\t\tconst nodeVar = builder.getVarFromNode( this, name, builder.getVectorType( this.getNodeType( builder ) ) );\n\n\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\tconst snippet = node.build( builder, nodeVar.type );\n\n\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}`, this );\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\nconst createVar = /*@__PURE__*/ nodeProxy( VarNode );\n\naddMethodChaining( 'toVar', ( ...params ) => createVar( ...params ).append() );\n\n// Deprecated\n\nconst temp = ( node ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: \"temp\" is deprecated. Use \".toVar()\" instead.' );\n\n\treturn createVar( node );\n\n};\n\naddMethodChaining( 'temp', temp );\n\nclass VaryingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'VaryingNode';\n\n\t}\n\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.name = name;\n\n\t\tthis.isVaryingNode = true;\n\n\t}\n\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\t// VaryingNode is auto type\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tsetupVarying( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tlet varying = properties.varying;\n\n\t\tif ( varying === undefined ) {\n\n\t\t\tconst name = this.name;\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tproperties.varying = varying = builder.getVaryingFromNode( this, name, type );\n\t\t\tproperties.node = this.node;\n\n\t\t}\n\n\t\t// this property can be used to check if the varying can be optimized for a variable\n\t\tvarying.needsInterpolation || ( varying.needsInterpolation = ( builder.shaderStage === 'fragment' ) );\n\n\t\treturn varying;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.setupVarying( builder );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tthis.setupVarying( builder );\n\n\t\treturn this.node.analyze( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst varying = this.setupVarying( builder );\n\n\t\tif ( properties.propertyName === undefined ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\t\t\tconst propertyName = builder.getPropertyName( varying, NodeShaderStage.VERTEX );\n\n\t\t\t// force node run in vertex stage\n\t\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node, type, propertyName );\n\n\t\t\tproperties.propertyName = propertyName;\n\n\t\t}\n\n\t\treturn builder.getPropertyName( varying );\n\n\t}\n\n}\n\nconst varying = /*@__PURE__*/ nodeProxy( VaryingNode );\n\naddMethodChaining( 'varying', varying );\n\nconst sRGBTransferEOTF = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.mul( 0.9478672986 ).add( 0.0521327014 ).pow( 2.4 );\n\tconst b = color.mul( 0.0773993808 );\n\tconst factor = color.lessThanEqual( 0.04045 );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn rgbResult;\n\n} ).setLayout( {\n\tname: 'sRGBTransferEOTF',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\nconst sRGBTransferOETF = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.pow( 0.41666 ).mul( 1.055 ).sub( 0.055 );\n\tconst b = color.mul( 12.92 );\n\tconst factor = color.lessThanEqual( 0.0031308 );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn rgbResult;\n\n} ).setLayout( {\n\tname: 'sRGBTransferOETF',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\nconst WORKING_COLOR_SPACE = 'WorkingColorSpace';\nconst OUTPUT_COLOR_SPACE = 'OutputColorSpace';\n\nclass ColorSpaceNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ColorSpaceNode';\n\n\t}\n\n\tconstructor( colorNode, source, target ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.colorNode = colorNode;\n\t\tthis.source = source;\n\t\tthis.target = target;\n\n\t}\n\n\tresolveColorSpace( builder, colorSpace ) {\n\n\t\tif ( colorSpace === WORKING_COLOR_SPACE ) {\n\n\t\t\treturn ColorManagement.workingColorSpace;\n\n\t\t} else if ( colorSpace === OUTPUT_COLOR_SPACE ) {\n\n\t\t\treturn builder.context.outputColorSpace || builder.renderer.outputColorSpace;\n\n\t\t}\n\n\t\treturn colorSpace;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { colorNode } = this;\n\n\t\tconst source = this.resolveColorSpace( builder, this.source );\n\t\tconst target = this.resolveColorSpace( builder, this.target );\n\n\t\tlet outputNode = colorNode;\n\n\t\tif ( ColorManagement.enabled === false || source === target || ! source || ! target ) {\n\n\t\t\treturn outputNode;\n\n\t\t}\n\n\t\tif ( ColorManagement.getTransfer( source ) === SRGBTransfer ) {\n\n\t\t\toutputNode = vec4( sRGBTransferEOTF( outputNode.rgb ), outputNode.a );\n\n\t\t}\n\n\t\tif ( ColorManagement.getPrimaries( source ) !== ColorManagement.getPrimaries( target ) ) {\n\n\t\t\toutputNode = vec4(\n\t\t\t\tmat3( ColorManagement._getMatrix( new Matrix3(), source, target ) ).mul( outputNode.rgb ),\n\t\t\t\toutputNode.a\n\t\t\t);\n\n\t\t}\n\n\t\tif ( ColorManagement.getTransfer( target ) === SRGBTransfer ) {\n\n\t\t\toutputNode = vec4( sRGBTransferOETF( outputNode.rgb ), outputNode.a );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nconst toOutputColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, OUTPUT_COLOR_SPACE ) );\nconst toWorkingColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), OUTPUT_COLOR_SPACE, WORKING_COLOR_SPACE ) );\n\nconst workingToColorSpace = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, colorSpace ) );\nconst colorSpaceToWorking = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), colorSpace, WORKING_COLOR_SPACE ) );\n\nconst convertColorSpace = ( node, sourceColorSpace, targetColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), sourceColorSpace, targetColorSpace ) );\n\naddMethodChaining( 'toOutputColorSpace', toOutputColorSpace );\naddMethodChaining( 'toWorkingColorSpace', toWorkingColorSpace );\n\naddMethodChaining( 'workingToColorSpace', workingToColorSpace );\naddMethodChaining( 'colorSpaceToWorking', colorSpaceToWorking );\n\nlet ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceElementNode';\n\n\t}\n\n\tconstructor( referenceNode, indexNode ) {\n\n\t\tsuper( referenceNode, indexNode );\n\n\t\tthis.referenceNode = referenceNode;\n\n\t\tthis.isReferenceElementNode = true;\n\n\t}\n\n\tgetNodeType() {\n\n\t\treturn this.referenceNode.uniformType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst arrayType = this.referenceNode.getNodeType();\n\t\tconst elementType = this.getNodeType();\n\n\t\treturn builder.format( snippet, arrayType, elementType );\n\n\t}\n\n};\n\nclass ReferenceBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceBaseNode';\n\n\t}\n\n\tconstructor( property, uniformType, object = null, count = null ) {\n\n\t\tsuper();\n\n\t\tthis.property = property;\n\t\tthis.uniformType = uniformType;\n\t\tthis.object = object;\n\t\tthis.count = count;\n\n\t\tthis.properties = property.split( '.' );\n\t\tthis.reference = object;\n\t\tthis.node = null;\n\t\tthis.group = null;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\tsetGroup( group ) {\n\n\t\tthis.group = group;\n\n\t\treturn this;\n\n\t}\n\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new ReferenceElementNode$1( this, nodeObject( indexNode ) ) );\n\n\t}\n\n\tsetNodeType( uniformType ) {\n\n\t\tconst node = uniform( null, uniformType ).getSelf();\n\n\t\tif ( this.group !== null ) {\n\n\t\t\tnode.setGroup( this.group );\n\n\t\t}\n\n\t\tthis.node = node;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( this.node === null ) {\n\n\t\t\tthis.updateReference( builder );\n\t\t\tthis.updateValue();\n\n\t\t}\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgetValueFromReference( object = this.reference ) {\n\n\t\tconst { properties } = this;\n\n\t\tlet value = object[ properties[ 0 ] ];\n\n\t\tfor ( let i = 1; i < properties.length; i ++ ) {\n\n\t\t\tvalue = value[ properties[ i ] ];\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.object !== null ? this.object : state.object;\n\n\t\treturn this.reference;\n\n\t}\n\n\tsetup() {\n\n\t\tthis.updateValue();\n\n\t\treturn this.node;\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tthis.updateValue();\n\n\t}\n\n\tupdateValue() {\n\n\t\tif ( this.node === null ) this.setNodeType( this.uniformType );\n\n\t\tconst value = this.getValueFromReference();\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tthis.node.array = value;\n\n\t\t} else {\n\n\t\t\tthis.node.value = value;\n\n\t\t}\n\n\t}\n\n}\n\nconst reference$1 = ( name, type, object ) => nodeObject( new ReferenceBaseNode( name, type, object ) );\n\nclass RendererReferenceNode extends ReferenceBaseNode {\n\n\tstatic get type() {\n\n\t\treturn 'RendererReferenceNode';\n\n\t}\n\n\tconstructor( property, inputType, renderer = null ) {\n\n\t\tsuper( property, inputType, renderer );\n\n\t\tthis.renderer = renderer;\n\n\t\tthis.setGroup( renderGroup );\n\n\t}\n\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.renderer !== null ? this.renderer : state.renderer;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\nconst rendererReference = ( name, type, renderer ) => nodeObject( new RendererReferenceNode( name, type, renderer ) );\n\nclass ToneMappingNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ToneMappingNode';\n\n\t}\n\n\tconstructor( toneMapping, exposureNode = toneMappingExposure, colorNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.toneMapping = toneMapping;\n\n\t\tthis.exposureNode = exposureNode;\n\t\tthis.colorNode = colorNode;\n\n\t}\n\n\tgetCacheKey() {\n\n\t\treturn hash$1( super.getCacheKey(), this.toneMapping );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst colorNode = this.colorNode || builder.context.color;\n\t\tconst toneMapping = this.toneMapping;\n\n\t\tif ( toneMapping === NoToneMapping ) return colorNode;\n\n\t\tlet outputNode = null;\n\n\t\tconst toneMappingFn = builder.renderer.library.getToneMappingFunction( toneMapping );\n\n\t\tif ( toneMappingFn !== null ) {\n\n\t\t\toutputNode = vec4( toneMappingFn( colorNode.rgb, this.exposureNode ), colorNode.a );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping );\n\n\t\t\toutputNode = colorNode;\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nconst toneMapping = ( mapping, exposure, color ) => nodeObject( new ToneMappingNode( mapping, nodeObject( exposure ), nodeObject( color ) ) );\nconst toneMappingExposure = /*@__PURE__*/ rendererReference( 'toneMappingExposure', 'float' );\n\naddMethodChaining( 'toneMapping', ( color, mapping, exposure ) => toneMapping( mapping, exposure, color ) );\n\nclass BufferAttributeNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'BufferAttributeNode';\n\n\t}\n\n\tconstructor( value, bufferType = null, bufferStride = 0, bufferOffset = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\tthis.isBufferNode = true;\n\n\t\tthis.bufferType = bufferType;\n\t\tthis.bufferStride = bufferStride;\n\t\tthis.bufferOffset = bufferOffset;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.instanced = false;\n\n\t\tthis.attribute = null;\n\n\t\tthis.global = true;\n\n\t\tif ( value && value.isBufferAttribute === true ) {\n\n\t\t\tthis.attribute = value;\n\t\t\tthis.usage = value.usage;\n\t\t\tthis.instanced = value.isInstancedBufferAttribute;\n\n\t\t}\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\tif ( this.bufferStride === 0 && this.bufferOffset === 0 ) {\n\n\t\t\tlet bufferData = builder.globalCache.getData( this.value );\n\n\t\t\tif ( bufferData === undefined ) {\n\n\t\t\t\tbufferData = {\n\t\t\t\t\tnode: this\n\t\t\t\t};\n\n\t\t\t\tbuilder.globalCache.setData( this.value, bufferData );\n\n\t\t\t}\n\n\t\t\treturn bufferData.node.uuid;\n\n\t\t}\n\n\t\treturn this.uuid;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( this.bufferType === null ) {\n\n\t\t\tthis.bufferType = builder.getTypeFromAttribute( this.attribute );\n\n\t\t}\n\n\t\treturn this.bufferType;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( this.attribute !== null ) return;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst array = this.value;\n\t\tconst itemSize = builder.getTypeLength( type );\n\t\tconst stride = this.bufferStride || itemSize;\n\t\tconst offset = this.bufferOffset;\n\n\t\tconst buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer( array, stride );\n\t\tconst bufferAttribute = new InterleavedBufferAttribute( buffer, itemSize, offset );\n\n\t\tbuffer.setUsage( this.usage );\n\n\t\tthis.attribute = bufferAttribute;\n\t\tthis.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tconst nodeAttribute = builder.getBufferAttributeFromNode( this, nodeType );\n\t\tconst propertyName = builder.getPropertyName( nodeAttribute );\n\n\t\tlet output = null;\n\n\t\tif ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {\n\n\t\t\tthis.name = propertyName;\n\n\t\t\toutput = propertyName;\n\n\t\t} else {\n\n\t\t\tconst nodeVarying = varying( this );\n\n\t\t\toutput = nodeVarying.build( builder, nodeType );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'bufferAttribute';\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\tif ( this.attribute && this.attribute.isBufferAttribute === true ) {\n\n\t\t\tthis.attribute.usage = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetInstanced( value ) {\n\n\t\tthis.instanced = value;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst bufferAttribute = ( array, type, stride, offset ) => nodeObject( new BufferAttributeNode( array, type, stride, offset ) );\nconst dynamicBufferAttribute = ( array, type, stride, offset ) => bufferAttribute( array, type, stride, offset ).setUsage( DynamicDrawUsage );\n\nconst instancedBufferAttribute = ( array, type, stride, offset ) => bufferAttribute( array, type, stride, offset ).setInstanced( true );\nconst instancedDynamicBufferAttribute = ( array, type, stride, offset ) => dynamicBufferAttribute( array, type, stride, offset ).setInstanced( true );\n\naddMethodChaining( 'toAttribute', ( bufferNode ) => bufferAttribute( bufferNode.value ) );\n\nclass ComputeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ComputeNode';\n\n\t}\n\n\tconstructor( computeNode, count, workgroupSize = [ 64 ] ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.isComputeNode = true;\n\n\t\tthis.computeNode = computeNode;\n\n\t\tthis.count = count;\n\t\tthis.workgroupSize = workgroupSize;\n\t\tthis.dispatchCount = 0;\n\n\t\tthis.version = 1;\n\t\tthis.updateBeforeType = NodeUpdateType.OBJECT;\n\n\t\tthis.onInitFunction = null;\n\n\t\tthis.updateDispatchCount();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tupdateDispatchCount() {\n\n\t\tconst { count, workgroupSize } = this;\n\n\t\tlet size = workgroupSize[ 0 ];\n\n\t\tfor ( let i = 1; i < workgroupSize.length; i ++ )\n\t\t\tsize *= workgroupSize[ i ];\n\n\t\tthis.dispatchCount = Math.ceil( count / size );\n\n\t}\n\n\tonInit( callback ) {\n\n\t\tthis.onInitFunction = callback;\n\n\t\treturn this;\n\n\t}\n\n\tupdateBefore( { renderer } ) {\n\n\t\trenderer.compute( this );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { shaderStage } = builder;\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tconst snippet = this.computeNode.build( builder, 'void' );\n\n\t\t\tif ( snippet !== '' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst compute = ( node, count, workgroupSize ) => nodeObject( new ComputeNode( nodeObject( node ), count, workgroupSize ) );\n\naddMethodChaining( 'compute', compute );\n\nclass CacheNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'CacheNode';\n\n\t}\n\n\tconstructor( node, parent = true ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.parent = parent;\n\n\t\tthis.isCacheNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tconst previousCache = builder.getCache();\n\t\tconst cache = builder.getCacheFromNode( this, this.parent );\n\n\t\tbuilder.setCache( cache );\n\n\t\tconst data = this.node.build( builder, ...params );\n\n\t\tbuilder.setCache( previousCache );\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst cache = ( node, ...params ) => nodeObject( new CacheNode( nodeObject( node ), ...params ) );\n\naddMethodChaining( 'cache', cache );\n\nclass BypassNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'BypassNode';\n\n\t}\n\n\tconstructor( returnNode, callNode ) {\n\n\t\tsuper();\n\n\t\tthis.isBypassNode = true;\n\n\t\tthis.outputNode = returnNode;\n\t\tthis.callNode = callNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = this.callNode.build( builder, 'void' );\n\n\t\tif ( snippet !== '' ) {\n\n\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t}\n\n\t\treturn this.outputNode.build( builder );\n\n\t}\n\n}\n\nconst bypass = /*@__PURE__*/ nodeProxy( BypassNode );\n\naddMethodChaining( 'bypass', bypass );\n\nclass RemapNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'RemapNode';\n\n\t}\n\n\tconstructor( node, inLowNode, inHighNode, outLowNode = float( 0 ), outHighNode = float( 1 ) ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.inLowNode = inLowNode;\n\t\tthis.inHighNode = inHighNode;\n\t\tthis.outLowNode = outLowNode;\n\t\tthis.outHighNode = outHighNode;\n\n\t\tthis.doClamp = true;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;\n\n\t\tlet t = node.sub( inLowNode ).div( inHighNode.sub( inLowNode ) );\n\n\t\tif ( doClamp === true ) t = t.clamp();\n\n\t\treturn t.mul( outHighNode.sub( outLowNode ) ).add( outLowNode );\n\n\t}\n\n}\n\nconst remap = /*@__PURE__*/ nodeProxy( RemapNode, null, null, { doClamp: false } );\nconst remapClamp = /*@__PURE__*/ nodeProxy( RemapNode );\n\naddMethodChaining( 'remap', remap );\naddMethodChaining( 'remapClamp', remapClamp );\n\nclass ExpressionNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ExpressionNode';\n\n\t}\n\n\tconstructor( snippet = '', nodeType = 'void' ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.snippet = snippet;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst snippet = this.snippet;\n\n\t\tif ( type === 'void' ) {\n\n\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t} else {\n\n\t\t\treturn builder.format( `( ${ snippet } )`, type, output );\n\n\t\t}\n\n\t}\n\n}\n\nconst expression = /*@__PURE__*/ nodeProxy( ExpressionNode );\n\nconst Discard = ( conditional ) => ( conditional ? select( conditional, expression( 'discard' ) ) : expression( 'discard' ) ).append();\nconst Return = () => expression( 'return' ).append();\n\naddMethodChaining( 'discard', Discard );\n\nclass RenderOutputNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'RenderOutputNode';\n\n\t}\n\n\tconstructor( colorNode, toneMapping, outputColorSpace ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.colorNode = colorNode;\n\t\tthis.toneMapping = toneMapping;\n\t\tthis.outputColorSpace = outputColorSpace;\n\n\t\tthis.isRenderOutput = true;\n\n\t}\n\n\tsetup( { context } ) {\n\n\t\tlet outputNode = this.colorNode || context.color;\n\n\t\t// tone mapping\n\n\t\tconst toneMapping = ( this.toneMapping !== null ? this.toneMapping : context.toneMapping ) || NoToneMapping;\n\t\tconst outputColorSpace = ( this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace ) || NoColorSpace;\n\n\t\tif ( toneMapping !== NoToneMapping ) {\n\n\t\t\toutputNode = outputNode.toneMapping( toneMapping );\n\n\t\t}\n\n\t\t// working to output color space\n\n\t\tif ( outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace ) {\n\n\t\t\toutputNode = outputNode.workingToColorSpace( outputColorSpace );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nconst renderOutput = ( color, toneMapping = null, outputColorSpace = null ) => nodeObject( new RenderOutputNode( nodeObject( color ), toneMapping, outputColorSpace ) );\n\naddMethodChaining( 'renderOutput', renderOutput );\n\n// Non-PURE exports list, side-effects are required here.\n// TSL Base Syntax\n\n\nfunction addNodeElement( name/*, nodeElement*/ ) {\n\n\tconsole.warn( 'THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add', name );\n\n}\n\nclass AttributeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'AttributeNode';\n\n\t}\n\n\tconstructor( attributeName, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.global = true;\n\n\t\tthis._attributeName = attributeName;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.getAttributeName( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tlet nodeType = this.nodeType;\n\n\t\tif ( nodeType === null ) {\n\n\t\t\tconst attributeName = this.getAttributeName( builder );\n\n\t\t\tif ( builder.hasGeometryAttribute( attributeName ) ) {\n\n\t\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\n\t\t\t\tnodeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\t} else {\n\n\t\t\t\tnodeType = 'float';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\tsetAttributeName( attributeName ) {\n\n\t\tthis._attributeName = attributeName;\n\n\t\treturn this;\n\n\t}\n\n\tgetAttributeName( /*builder*/ ) {\n\n\t\treturn this._attributeName;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\t\t\tconst attributeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\tconst nodeAttribute = builder.getAttribute( attributeName, attributeType );\n\n\t\t\tif ( builder.shaderStage === 'vertex' ) {\n\n\t\t\t\treturn builder.format( nodeAttribute.name, attributeType, nodeType );\n\n\t\t\t} else {\n\n\t\t\t\tconst nodeVarying = varying( this );\n\n\t\t\t\treturn nodeVarying.build( builder, nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( `AttributeNode: Vertex attribute \"${ attributeName }\" not found on geometry.` );\n\n\t\t\treturn builder.generateConst( nodeType );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.global = this.global;\n\t\tdata._attributeName = this._attributeName;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.global = data.global;\n\t\tthis._attributeName = data._attributeName;\n\n\t}\n\n}\n\nconst attribute = ( name, nodeType ) => nodeObject( new AttributeNode( name, nodeType ) );\n\nconst uv = ( index ) => attribute( 'uv' + ( index > 0 ? index : '' ), 'vec2' );\n\nclass TextureSizeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TextureSizeNode';\n\n\t}\n\n\tconstructor( textureNode, levelNode = null ) {\n\n\t\tsuper( 'uvec2' );\n\n\t\tthis.isTextureSizeNode = true;\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.levelNode = levelNode;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst textureProperty = this.textureNode.build( builder, 'property' );\n\t\tconst level = this.levelNode === null ? '0' : this.levelNode.build( builder, 'int' );\n\n\t\treturn builder.format( `${ builder.getMethod( 'textureDimensions' ) }( ${ textureProperty }, ${ level } )`, this.getNodeType( builder ), output );\n\n\t}\n\n}\n\nconst textureSize = /*@__PURE__*/ nodeProxy( TextureSizeNode );\n\nclass MaxMipLevelNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'MaxMipLevelNode';\n\n\t}\n\n\tconstructor( textureNode ) {\n\n\t\tsuper( 0 );\n\n\t\tthis._textureNode = textureNode;\n\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t}\n\n\tget textureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\tget texture() {\n\n\t\treturn this._textureNode.value;\n\n\t}\n\n\tupdate() {\n\n\t\tconst texture = this.texture;\n\t\tconst images = texture.images;\n\t\tconst image = ( images && images.length > 0 ) ? ( ( images[ 0 ] && images[ 0 ].image ) || images[ 0 ] ) : texture.image;\n\n\t\tif ( image && image.width !== undefined ) {\n\n\t\t\tconst { width, height } = image;\n\n\t\t\tthis.value = Math.log2( Math.max( width, height ) );\n\n\t\t}\n\n\t}\n\n}\n\nconst maxMipLevel = /*@__PURE__*/ nodeProxy( MaxMipLevelNode );\n\nclass TextureNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'TextureNode';\n\n\t}\n\n\tconstructor( value, uvNode = null, levelNode = null, biasNode = null ) {\n\n\t\tsuper( value );\n\n\t\tthis.isTextureNode = true;\n\n\t\tthis.uvNode = uvNode;\n\t\tthis.levelNode = levelNode;\n\t\tthis.biasNode = biasNode;\n\t\tthis.compareNode = null;\n\t\tthis.depthNode = null;\n\t\tthis.gradNode = null;\n\n\t\tthis.sampler = true;\n\t\tthis.updateMatrix = false;\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\tthis.referenceNode = null;\n\n\t\tthis._value = value;\n\t\tthis._matrixUniform = null;\n\n\t\tthis.setUpdateMatrix( uvNode === null );\n\n\t}\n\n\tset value( value ) {\n\n\t\tif ( this.referenceNode ) {\n\n\t\t\tthis.referenceNode.value = value;\n\n\t\t} else {\n\n\t\t\tthis._value = value;\n\n\t\t}\n\n\t}\n\n\tget value() {\n\n\t\treturn this.referenceNode ? this.referenceNode.value : this._value;\n\n\t}\n\n\tgetUniformHash( /*builder*/ ) {\n\n\t\treturn this.value.uuid;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.value.isDepthTexture === true ) return 'float';\n\n\t\tif ( this.value.type === UnsignedIntType ) {\n\n\t\t\treturn 'uvec4';\n\n\t\t} else if ( this.value.type === IntType ) {\n\n\t\t\treturn 'ivec4';\n\n\t\t}\n\n\t\treturn 'vec4';\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture';\n\n\t}\n\n\tgetDefaultUV() {\n\n\t\treturn uv( this.value.channel );\n\n\t}\n\n\tupdateReference( /*state*/ ) {\n\n\t\treturn this.value;\n\n\t}\n\n\tgetTransformedUV( uvNode ) {\n\n\t\tif ( this._matrixUniform === null ) this._matrixUniform = uniform( this.value.matrix );\n\n\t\treturn this._matrixUniform.mul( vec3( uvNode, 1 ) ).xy;\n\n\t}\n\n\tsetUpdateMatrix( value ) {\n\n\t\tthis.updateMatrix = value;\n\t\tthis.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;\n\n\t\treturn this;\n\n\t}\n\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.isFlipY() && ( ( texture.image instanceof ImageBitmap && texture.flipY === true ) || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true ) ) {\n\n\t\t\tif ( this.sampler ) {\n\n\t\t\t\tuvNode = uvNode.flipY();\n\n\t\t\t} else {\n\n\t\t\t\tuvNode = uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uvNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.referenceNode = this.referenceNode;\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( ( uvNode === null || builder.context.forceUVContext === true ) && builder.context.getUV ) {\n\n\t\t\tuvNode = builder.context.getUV( this );\n\n\t\t}\n\n\t\tif ( ! uvNode ) uvNode = this.getDefaultUV();\n\n\t\tif ( this.updateMatrix === true ) {\n\n\t\t\tuvNode = this.getTransformedUV( uvNode );\n\n\t\t}\n\n\t\tuvNode = this.setupUV( builder, uvNode );\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\t//\n\n\t\tproperties.uvNode = uvNode;\n\t\tproperties.levelNode = levelNode;\n\t\tproperties.biasNode = this.biasNode;\n\t\tproperties.compareNode = this.compareNode;\n\t\tproperties.gradNode = this.gradNode;\n\t\tproperties.depthNode = this.depthNode;\n\n\t}\n\n\tgenerateUV( builder, uvNode ) {\n\n\t\treturn uvNode.build( builder, this.sampler === true ? 'vec2' : 'ivec2' );\n\n\t}\n\n\tgenerateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet ) {\n\n\t\tconst texture = this.value;\n\n\t\tlet snippet;\n\n\t\tif ( levelSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet );\n\n\t\t} else if ( biasSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet );\n\n\t\t} else if ( gradSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet );\n\n\t\t} else if ( compareSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet );\n\n\t\t} else if ( this.sampler === false ) {\n\n\t\t\tsnippet = builder.generateTextureLoad( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t} else {\n\n\t\t\tsnippet = builder.generateTexture( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isTexture !== true ) {\n\n\t\t\tthrow new Error( 'TextureNode: Need a three.js texture.' );\n\n\t\t}\n\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\n\t\tif ( output === 'sampler' ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode } = properties;\n\n\t\t\t\tconst uvSnippet = this.generateUV( builder, uvNode );\n\t\t\t\tconst levelSnippet = levelNode ? levelNode.build( builder, 'float' ) : null;\n\t\t\t\tconst biasSnippet = biasNode ? biasNode.build( builder, 'float' ) : null;\n\t\t\t\tconst depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;\n\t\t\t\tconst compareSnippet = compareNode ? compareNode.build( builder, 'float' ) : null;\n\t\t\t\tconst gradSnippet = gradNode ? [ gradNode[ 0 ].build( builder, 'vec2' ), gradNode[ 1 ].build( builder, 'vec2' ) ] : null;\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this );\n\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tconst snippet = this.generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet );\n\n\t\t\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}`, this );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\tlet snippet = propertyName;\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( builder.needsToWorkingColorSpace( texture ) ) {\n\n\t\t\t\tsnippet = colorSpaceToWorking( expression( snippet, nodeType ), texture.colorSpace ).setup( builder ).build( builder, nodeType );\n\n\t\t\t}\n\n\t\t\treturn builder.format( snippet, nodeType, output );\n\n\t\t}\n\n\t}\n\n\tsetSampler( value ) {\n\n\t\tthis.sampler = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetSampler() {\n\n\t\treturn this.sampler;\n\n\t}\n\n\t// @TODO: Move to TSL\n\n\tuv( uvNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.uvNode = nodeObject( uvNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tblur( amountNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.biasNode = nodeObject( amountNode ).mul( maxMipLevel( textureNode ) );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tlevel( levelNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.levelNode = nodeObject( levelNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tsize( levelNode ) {\n\n\t\treturn textureSize( this, levelNode );\n\n\t}\n\n\tbias( biasNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.biasNode = nodeObject( biasNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tcompare( compareNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.compareNode = nodeObject( compareNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tgrad( gradNodeX, gradNodeY ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.gradNode = [ nodeObject( gradNodeX ), nodeObject( gradNodeY ) ];\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tdepth( depthNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.depthNode = nodeObject( depthNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t// --\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value.toJSON( data.meta ).uuid;\n\t\tdata.sampler = this.sampler;\n\t\tdata.updateMatrix = this.updateMatrix;\n\t\tdata.updateType = this.updateType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.value = data.meta.textures[ data.value ];\n\t\tthis.sampler = data.sampler;\n\t\tthis.updateMatrix = data.updateMatrix;\n\t\tthis.updateType = data.updateType;\n\n\t}\n\n\tupdate() {\n\n\t\tconst texture = this.value;\n\t\tconst matrixUniform = this._matrixUniform;\n\n\t\tif ( matrixUniform !== null ) matrixUniform.value = texture.matrix;\n\n\t\tif ( texture.matrixAutoUpdate === true ) {\n\n\t\t\ttexture.updateMatrix();\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new this.constructor( this.value, this.uvNode, this.levelNode, this.biasNode );\n\t\tnewNode.sampler = this.sampler;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\nconst texture = /*@__PURE__*/ nodeProxy( TextureNode );\nconst textureLoad = ( ...params ) => texture( ...params ).setSampler( false );\n\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\nconst sampler = ( aTexture ) => ( aTexture.isNode === true ? aTexture : texture( aTexture ) ).convert( 'sampler' );\n\nconst cameraNear = /*@__PURE__*/ uniform( 'float' ).label( 'cameraNear' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.near );\nconst cameraFar = /*@__PURE__*/ uniform( 'float' ).label( 'cameraFar' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.far );\nconst cameraProjectionMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraProjectionMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrix );\nconst cameraProjectionMatrixInverse = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraProjectionMatrixInverse' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrixInverse );\nconst cameraViewMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraViewMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorldInverse );\nconst cameraWorldMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraWorldMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorld );\nconst cameraNormalMatrix = /*@__PURE__*/ uniform( 'mat3' ).label( 'cameraNormalMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.normalMatrix );\nconst cameraPosition = /*@__PURE__*/ uniform( new Vector3() ).label( 'cameraPosition' ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => self.value.setFromMatrixPosition( camera.matrixWorld ) );\n\nclass Object3DNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'Object3DNode';\n\n\t}\n\n\tconstructor( scope, object3d = null ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\t\tthis.object3d = object3d;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\tthis._uniformNode = new UniformNode( null );\n\n\t}\n\n\tgetNodeType() {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\treturn 'mat4';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {\n\n\t\t\treturn 'vec3';\n\n\t\t}\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst object = this.object3d;\n\t\tconst uniformNode = this._uniformNode;\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tuniformNode.value = object.matrixWorld;\n\n\t\t} else if ( scope === Object3DNode.POSITION ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.SCALE ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tuniformNode.value.setFromMatrixScale( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.DIRECTION ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tobject.getWorldDirection( uniformNode.value );\n\n\t\t} else if ( scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\tconst camera = frame.camera;\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t\tuniformNode.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tthis._uniformNode.nodeType = 'mat4';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {\n\n\t\t\tthis._uniformNode.nodeType = 'vec3';\n\n\t\t}\n\n\t\treturn this._uniformNode.build( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nObject3DNode.WORLD_MATRIX = 'worldMatrix';\nObject3DNode.POSITION = 'position';\nObject3DNode.SCALE = 'scale';\nObject3DNode.VIEW_POSITION = 'viewPosition';\nObject3DNode.DIRECTION = 'direction';\n\nconst objectDirection = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.DIRECTION );\nconst objectWorldMatrix = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.WORLD_MATRIX );\nconst objectPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.POSITION );\nconst objectScale = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.SCALE );\nconst objectViewPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.VIEW_POSITION );\n\nclass ModelNode extends Object3DNode {\n\n\tstatic get type() {\n\n\t\treturn 'ModelNode';\n\n\t}\n\n\tconstructor( scope ) {\n\n\t\tsuper( scope );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tthis.object3d = frame.object;\n\n\t\tsuper.update( frame );\n\n\t}\n\n}\n\nconst modelDirection = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.DIRECTION );\nconst modelWorldMatrix = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );\nconst modelPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.POSITION );\nconst modelScale = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.SCALE );\nconst modelViewPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );\nconst modelNormalMatrix = /*@__PURE__*/ uniform( new Matrix3() ).onObjectUpdate( ( { object }, self ) => self.value.getNormalMatrix( object.matrixWorld ) );\nconst modelWorldMatrixInverse = /*@__PURE__*/ uniform( new Matrix4() ).onObjectUpdate( ( { object }, self ) => self.value.copy( object.matrixWorld ).invert() );\nconst modelViewMatrix = /*@__PURE__*/ cameraViewMatrix.mul( modelWorldMatrix ).toVar( 'modelViewMatrix' );\n\nconst highPrecisionModelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tbuilder.context.isHighPrecisionModelViewMatrix = true;\n\n\treturn uniform( 'mat4' ).onObjectUpdate( ( { object, camera } ) => {\n\n\t\treturn object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t} );\n\n} ).once() )().toVar( 'highPrecisionModelViewMatrix' );\n\nconst highPrecisionModelNormalViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tconst isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;\n\n\treturn uniform( 'mat3' ).onObjectUpdate( ( { object, camera } ) => {\n\n\t\tif ( isHighPrecisionModelViewMatrix !== true ) {\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\t}\n\n\t\treturn object.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t} );\n\n} ).once() )().toVar( 'highPrecisionModelNormalMatrix' );\n\nconst positionGeometry = /*@__PURE__*/ attribute( 'position', 'vec3' );\nconst positionLocal = /*@__PURE__*/ positionGeometry.varying( 'positionLocal' );\nconst positionPrevious = /*@__PURE__*/ positionGeometry.varying( 'positionPrevious' );\nconst positionWorld = /*@__PURE__*/ modelWorldMatrix.mul( positionLocal ).xyz.varying( 'v_positionWorld' );\nconst positionWorldDirection = /*@__PURE__*/ positionLocal.transformDirection( modelWorldMatrix ).varying( 'v_positionWorldDirection' ).normalize().toVar( 'positionWorldDirection' );\nconst positionView = /*@__PURE__*/ modelViewMatrix.mul( positionLocal ).xyz.varying( 'v_positionView' );\nconst positionViewDirection = /*@__PURE__*/ positionView.negate().varying( 'v_positionViewDirection' ).normalize().toVar( 'positionViewDirection' );\n\nclass FrontFacingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'FrontFacingNode';\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( 'bool' );\n\n\t\tthis.isFrontFacingNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { renderer, material } = builder;\n\n\t\tif ( renderer.coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\treturn 'false';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn builder.getFrontFacing();\n\n\t}\n\n}\n\nconst frontFacing = /*@__PURE__*/ nodeImmutable( FrontFacingNode );\nconst faceDirection = /*@__PURE__*/ float( frontFacing ).mul( 2.0 ).sub( 1.0 );\n\nconst normalGeometry = /*@__PURE__*/ attribute( 'normal', 'vec3' );\n\nconst normalLocal = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'normal' ) === false ) {\n\n\t\tconsole.warn( 'TSL.NormalNode: Vertex attribute \"normal\" not found on geometry.' );\n\n\t\treturn vec3( 0, 1, 0 );\n\n\t}\n\n\treturn normalGeometry;\n\n}, 'vec3' ).once() )().toVar( 'normalLocal' );\n\nconst normalFlat = /*@__PURE__*/ positionView.dFdx().cross( positionView.dFdy() ).normalize().toVar( 'normalFlat' );\n\nconst normalView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tlet node;\n\n\tif ( builder.material.flatShading === true ) {\n\n\t\tnode = normalFlat;\n\n\t} else {\n\n\t\tnode = varying( transformNormalToView( normalLocal ), 'v_normalView' ).normalize();\n\n\t}\n\n\treturn node;\n\n}, 'vec3' ).once() )().toVar( 'normalView' );\n\nconst normalWorld = /*@__PURE__*/ varying( normalView.transformDirection( cameraViewMatrix ), 'v_normalWorld' ).normalize().toVar( 'normalWorld' );\n\nconst transformedNormalView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.context.setupNormal();\n\n}, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedNormalView' );\n\n\nconst transformedNormalWorld = /*@__PURE__*/ transformedNormalView.transformDirection( cameraViewMatrix ).toVar( 'transformedNormalWorld' );\n\nconst transformedClearcoatNormalView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.context.setupClearcoatNormal();\n\n}, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedClearcoatNormalView' );\n\nconst transformNormal = /*@__PURE__*/ Fn( ( [ normal, matrix = modelWorldMatrix ] ) => {\n\n\tconst m = mat3( matrix );\n\n\tconst transformedNormal = normal.div( vec3( m[ 0 ].dot( m[ 0 ] ), m[ 1 ].dot( m[ 1 ] ), m[ 2 ].dot( m[ 2 ] ) ) );\n\n\treturn m.mul( transformedNormal ).xyz;\n\n} );\n\nconst transformNormalToView = /*@__PURE__*/ Fn( ( [ normal ], builder ) => {\n\n\tconst modelNormalViewMatrix = builder.renderer.nodes.modelNormalViewMatrix;\n\n\tif ( modelNormalViewMatrix !== null ) {\n\n\t\treturn modelNormalViewMatrix.transformDirection( normal );\n\n\t}\n\n\t//\n\n\tconst transformedNormal = modelNormalMatrix.mul( normal );\n\n\treturn cameraViewMatrix.transformDirection( transformedNormal );\n\n} );\n\nconst materialRefractionRatio = /*@__PURE__*/ uniform( 0 ).onReference( ( { material } ) => material ).onRenderUpdate( ( { material } ) => material.refractionRatio );\n\nconst reflectView = /*@__PURE__*/ positionViewDirection.negate().reflect( transformedNormalView );\nconst refractView = /*@__PURE__*/ positionViewDirection.negate().refract( transformedNormalView, materialRefractionRatio );\n\nconst reflectVector = /*@__PURE__*/ reflectView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );\nconst refractVector = /*@__PURE__*/ refractView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );\n\nclass CubeTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'CubeTextureNode';\n\n\t}\n\n\tconstructor( value, uvNode = null, levelNode = null, biasNode = null ) {\n\n\t\tsuper( value, uvNode, levelNode, biasNode );\n\n\t\tthis.isCubeTextureNode = true;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'cubeTexture';\n\n\t}\n\n\tgetDefaultUV() {\n\n\t\tconst texture = this.value;\n\n\t\tif ( texture.mapping === CubeReflectionMapping ) {\n\n\t\t\treturn reflectVector;\n\n\t\t} else if ( texture.mapping === CubeRefractionMapping ) {\n\n\t\t\treturn refractVector;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.CubeTextureNode: Mapping \"%s\" not supported.', texture.mapping );\n\n\t\t\treturn vec3( 0, 0, 0 );\n\n\t\t}\n\n\t}\n\n\tsetUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for CubeTextureNode\n\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem || ! texture.isRenderTargetTexture ) {\n\n\t\t\treturn vec3( uvNode.x.negate(), uvNode.yz );\n\n\t\t} else {\n\n\t\t\treturn uvNode;\n\n\t\t}\n\n\t}\n\n\tgenerateUV( builder, cubeUV ) {\n\n\t\treturn cubeUV.build( builder, 'vec3' );\n\n\t}\n\n}\n\nconst cubeTexture = /*@__PURE__*/ nodeProxy( CubeTextureNode );\n\nclass BufferNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'BufferNode';\n\n\t}\n\n\tconstructor( value, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\tthis.isBufferNode = true;\n\n\t\tthis.bufferType = bufferType;\n\t\tthis.bufferCount = bufferCount;\n\n\t}\n\n\tgetElementType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'buffer';\n\n\t}\n\n}\n\nconst buffer = ( value, type, count ) => nodeObject( new BufferNode( value, type, count ) );\n\nclass UniformArrayElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformArrayElementNode';\n\n\t}\n\n\tconstructor( arrayBuffer, indexNode ) {\n\n\t\tsuper( arrayBuffer, indexNode );\n\n\t\tthis.isArrayBufferElementNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst type = this.getNodeType();\n\n\t\treturn builder.format( snippet, 'vec4', type );\n\n\t}\n\n}\n\nclass UniformArrayNode extends BufferNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformArrayNode';\n\n\t}\n\n\tconstructor( value, elementType = null ) {\n\n\t\tsuper( null, 'vec4' );\n\n\t\tthis.array = value;\n\t\tthis.elementType = elementType;\n\n\t\tthis._elementType = null;\n\t\tthis._elementLength = 0;\n\n\t\tthis.updateType = NodeUpdateType.RENDER;\n\n\t\tthis.isArrayBufferNode = true;\n\n\t}\n\n\tgetElementType() {\n\n\t\treturn this.elementType || this._elementType;\n\n\t}\n\n\tgetElementLength() {\n\n\t\treturn this._elementLength;\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tconst { array, value } = this;\n\n\t\tconst elementLength = this.getElementLength();\n\t\tconst elementType = this.getElementType();\n\n\t\tif ( elementLength === 1 ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\n\t\t\t\tvalue[ index ] = array[ i ];\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'color' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst vector = array[ i ];\n\n\t\t\t\tvalue[ index ] = vector.r;\n\t\t\t\tvalue[ index + 1 ] = vector.g;\n\t\t\t\tvalue[ index + 2 ] = vector.b || 0;\n\t\t\t\t//value[ index + 3 ] = vector.a || 0;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst vector = array[ i ];\n\n\t\t\t\tvalue[ index ] = vector.x;\n\t\t\t\tvalue[ index + 1 ] = vector.y;\n\t\t\t\tvalue[ index + 2 ] = vector.z || 0;\n\t\t\t\tvalue[ index + 3 ] = vector.w || 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst length = this.array.length;\n\n\t\tthis._elementType = this.elementType === null ? getValueType( this.array[ 0 ] ) : this.elementType;\n\t\tthis._elementLength = builder.getTypeLength( this._elementType );\n\n\t\tlet arrayType = Float32Array;\n\n\t\tif ( this._elementType.charAt( 0 ) === 'i' ) arrayType = Int32Array;\n\t\telse if ( this._elementType.charAt( 0 ) === 'u' ) arrayType = Uint32Array;\n\n\t\tthis.value = new arrayType( length * 4 );\n\t\tthis.bufferCount = length;\n\t\tthis.bufferType = builder.changeComponentType( 'vec4', builder.getComponentType( this._elementType ) );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new UniformArrayElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n}\n\nconst uniformArray = ( values, nodeType ) => nodeObject( new UniformArrayNode( values, nodeType ) );\n\n//\n\nconst uniforms = ( values, nodeType ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.UniformArrayNode: uniforms() has been renamed to uniformArray().' );\n\treturn nodeObject( new UniformArrayNode( values, nodeType ) );\n\n};\n\nclass ReferenceElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceElementNode';\n\n\t}\n\n\tconstructor( referenceNode, indexNode ) {\n\n\t\tsuper( referenceNode, indexNode );\n\n\t\tthis.referenceNode = referenceNode;\n\n\t\tthis.isReferenceElementNode = true;\n\n\t}\n\n\tgetNodeType() {\n\n\t\treturn this.referenceNode.uniformType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst arrayType = this.referenceNode.getNodeType();\n\t\tconst elementType = this.getNodeType();\n\n\t\treturn builder.format( snippet, arrayType, elementType );\n\n\t}\n\n}\n\n// TODO: Extends this from ReferenceBaseNode\nclass ReferenceNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceNode';\n\n\t}\n\n\tconstructor( property, uniformType, object = null, count = null ) {\n\n\t\tsuper();\n\n\t\tthis.property = property;\n\t\tthis.uniformType = uniformType;\n\t\tthis.object = object;\n\t\tthis.count = count;\n\n\t\tthis.properties = property.split( '.' );\n\t\tthis.reference = object;\n\t\tthis.node = null;\n\t\tthis.group = null;\n\t\tthis.name = null;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new ReferenceElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n\tsetGroup( group ) {\n\n\t\tthis.group = group;\n\n\t\treturn this;\n\n\t}\n\n\tlabel( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\tsetNodeType( uniformType ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.count !== null ) {\n\n\t\t\tnode = buffer( null, uniformType, this.count );\n\n\t\t} else if ( Array.isArray( this.getValueFromReference() ) ) {\n\n\t\t\tnode = uniformArray( null, uniformType );\n\n\t\t} else if ( uniformType === 'texture' ) {\n\n\t\t\tnode = texture( null );\n\n\t\t} else if ( uniformType === 'cubeTexture' ) {\n\n\t\t\tnode = cubeTexture( null );\n\n\t\t} else {\n\n\t\t\tnode = uniform( null, uniformType );\n\n\t\t}\n\n\t\tif ( this.group !== null ) {\n\n\t\t\tnode.setGroup( this.group );\n\n\t\t}\n\n\t\tif ( this.name !== null ) node.label( this.name );\n\n\t\tthis.node = node.getSelf();\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( this.node === null ) {\n\n\t\t\tthis.updateReference( builder );\n\t\t\tthis.updateValue();\n\n\t\t}\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgetValueFromReference( object = this.reference ) {\n\n\t\tconst { properties } = this;\n\n\t\tlet value = object[ properties[ 0 ] ];\n\n\t\tfor ( let i = 1; i < properties.length; i ++ ) {\n\n\t\t\tvalue = value[ properties[ i ] ];\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.object !== null ? this.object : state.object;\n\n\t\treturn this.reference;\n\n\t}\n\n\tsetup() {\n\n\t\tthis.updateValue();\n\n\t\treturn this.node;\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tthis.updateValue();\n\n\t}\n\n\tupdateValue() {\n\n\t\tif ( this.node === null ) this.setNodeType( this.uniformType );\n\n\t\tconst value = this.getValueFromReference();\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tthis.node.array = value;\n\n\t\t} else {\n\n\t\t\tthis.node.value = value;\n\n\t\t}\n\n\t}\n\n}\n\nconst reference = ( name, type, object ) => nodeObject( new ReferenceNode( name, type, object ) );\nconst referenceBuffer = ( name, type, count, object ) => nodeObject( new ReferenceNode( name, type, object, count ) );\n\nclass MaterialReferenceNode extends ReferenceNode {\n\n\tstatic get type() {\n\n\t\treturn 'MaterialReferenceNode';\n\n\t}\n\n\tconstructor( property, inputType, material = null ) {\n\n\t\tsuper( property, inputType, material );\n\n\t\tthis.material = material;\n\n\t\t//this.updateType = NodeUpdateType.RENDER;\n\n\t\tthis.isMaterialReferenceNode = true;\n\n\t}\n\n\t/*setNodeType( node ) {\n\n\t\tsuper.setNodeType( node );\n\n\t\tthis.node.groupNode = renderGroup;\n\n\t}*/\n\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.material !== null ? this.material : state.material;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\nconst materialReference = ( name, type, material ) => nodeObject( new MaterialReferenceNode( name, type, material ) );\n\nconst tangentGeometry = /*@__PURE__*/ Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'tangent' ) === false ) {\n\n\t\tbuilder.geometry.computeTangents();\n\n\t}\n\n\treturn attribute( 'tangent', 'vec4' );\n\n} )();\n\nconst tangentLocal = /*@__PURE__*/ tangentGeometry.xyz.toVar( 'tangentLocal' );\nconst tangentView = /*@__PURE__*/ modelViewMatrix.mul( vec4( tangentLocal, 0 ) ).xyz.varying( 'v_tangentView' ).normalize().toVar( 'tangentView' );\nconst tangentWorld = /*@__PURE__*/ tangentView.transformDirection( cameraViewMatrix ).varying( 'v_tangentWorld' ).normalize().toVar( 'tangentWorld' );\nconst transformedTangentView = /*@__PURE__*/ tangentView.toVar( 'transformedTangentView' );\nconst transformedTangentWorld = /*@__PURE__*/ transformedTangentView.transformDirection( cameraViewMatrix ).normalize().toVar( 'transformedTangentWorld' );\n\nconst getBitangent = ( crossNormalTangent ) => crossNormalTangent.mul( tangentGeometry.w ).xyz;\n\nconst bitangentGeometry = /*@__PURE__*/ varying( getBitangent( normalGeometry.cross( tangentGeometry ) ), 'v_bitangentGeometry' ).normalize().toVar( 'bitangentGeometry' );\nconst bitangentLocal = /*@__PURE__*/ varying( getBitangent( normalLocal.cross( tangentLocal ) ), 'v_bitangentLocal' ).normalize().toVar( 'bitangentLocal' );\nconst bitangentView = /*@__PURE__*/ varying( getBitangent( normalView.cross( tangentView ) ), 'v_bitangentView' ).normalize().toVar( 'bitangentView' );\nconst bitangentWorld = /*@__PURE__*/ varying( getBitangent( normalWorld.cross( tangentWorld ) ), 'v_bitangentWorld' ).normalize().toVar( 'bitangentWorld' );\nconst transformedBitangentView = /*@__PURE__*/ getBitangent( transformedNormalView.cross( transformedTangentView ) ).normalize().toVar( 'transformedBitangentView' );\nconst transformedBitangentWorld = /*@__PURE__*/ transformedBitangentView.transformDirection( cameraViewMatrix ).normalize().toVar( 'transformedBitangentWorld' );\n\nconst TBNViewMatrix = /*@__PURE__*/ mat3( tangentView, bitangentView, normalView );\n\nconst parallaxDirection = /*@__PURE__*/ positionViewDirection.mul( TBNViewMatrix )/*.normalize()*/;\nconst parallaxUV = ( uv, scale ) => uv.sub( parallaxDirection.mul( scale ) );\n\nconst transformedBentNormalView = /*@__PURE__*/ ( () => {\n\n\t// https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy\n\n\tlet bentNormal = anisotropyB.cross( positionViewDirection );\n\tbentNormal = bentNormal.cross( anisotropyB ).normalize();\n\tbentNormal = mix( bentNormal, transformedNormalView, anisotropy.mul( roughness.oneMinus() ).oneMinus().pow2().pow2() ).normalize();\n\n\treturn bentNormal;\n\n\n} )();\n\n// Normal Mapping Without Precomputed Tangents\n// http://www.thetenthplanet.de/archives/1180\n\nconst perturbNormal2Arb = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { eye_pos, surf_norm, mapN, uv } = inputs;\n\n\tconst q0 = eye_pos.dFdx();\n\tconst q1 = eye_pos.dFdy();\n\tconst st0 = uv.dFdx();\n\tconst st1 = uv.dFdy();\n\n\tconst N = surf_norm; // normalized\n\n\tconst q1perp = q1.cross( N );\n\tconst q0perp = N.cross( q0 );\n\n\tconst T = q1perp.mul( st0.x ).add( q0perp.mul( st1.x ) );\n\tconst B = q1perp.mul( st0.y ).add( q0perp.mul( st1.y ) );\n\n\tconst det = T.dot( T ).max( B.dot( B ) );\n\tconst scale = faceDirection.mul( det.inverseSqrt() );\n\n\treturn add( T.mul( mapN.x, scale ), B.mul( mapN.y, scale ), N.mul( mapN.z ) ).normalize();\n\n} );\n\nclass NormalMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'NormalMapNode';\n\n\t}\n\n\tconstructor( node, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.node = node;\n\t\tthis.scaleNode = scaleNode;\n\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { normalMapType, scaleNode } = this;\n\n\t\tlet normalMap = this.node.mul( 2.0 ).sub( 1.0 );\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tnormalMap = vec3( normalMap.xy.mul( scaleNode ), normalMap.z );\n\n\t\t}\n\n\t\tlet outputNode = null;\n\n\t\tif ( normalMapType === ObjectSpaceNormalMap ) {\n\n\t\t\toutputNode = transformNormalToView( normalMap );\n\n\t\t} else if ( normalMapType === TangentSpaceNormalMap ) {\n\n\t\t\tconst tangent = builder.hasGeometryAttribute( 'tangent' );\n\n\t\t\tif ( tangent === true ) {\n\n\t\t\t\toutputNode = TBNViewMatrix.mul( normalMap ).normalize();\n\n\t\t\t} else {\n\n\t\t\t\toutputNode = perturbNormal2Arb( {\n\t\t\t\t\teye_pos: positionView,\n\t\t\t\t\tsurf_norm: normalView,\n\t\t\t\t\tmapN: normalMap,\n\t\t\t\t\tuv: uv()\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nconst normalMap = /*@__PURE__*/ nodeProxy( NormalMapNode );\n\n// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\nconst dHdxy_fwd = Fn( ( { textureNode, bumpScale } ) => {\n\n\t// It's used to preserve the same TextureNode instance\n\tconst sampleTexture = ( callback ) => textureNode.cache().context( { getUV: ( texNode ) => callback( texNode.uvNode || uv() ), forceUVContext: true } );\n\n\tconst Hll = float( sampleTexture( ( uvNode ) => uvNode ) );\n\n\treturn vec2(\n\t\tfloat( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdx() ) ) ).sub( Hll ),\n\t\tfloat( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdy() ) ) ).sub( Hll )\n\t).mul( bumpScale );\n\n} );\n\n// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\nconst perturbNormalArb = Fn( ( inputs ) => {\n\n\tconst { surf_pos, surf_norm, dHdxy } = inputs;\n\n\t// normalize is done to ensure that the bump map looks the same regardless of the texture's scale\n\tconst vSigmaX = surf_pos.dFdx().normalize();\n\tconst vSigmaY = surf_pos.dFdy().normalize();\n\tconst vN = surf_norm; // normalized\n\n\tconst R1 = vSigmaY.cross( vN );\n\tconst R2 = vN.cross( vSigmaX );\n\n\tconst fDet = vSigmaX.dot( R1 ).mul( faceDirection );\n\n\tconst vGrad = fDet.sign().mul( dHdxy.x.mul( R1 ).add( dHdxy.y.mul( R2 ) ) );\n\n\treturn fDet.abs().mul( surf_norm ).sub( vGrad ).normalize();\n\n} );\n\nclass BumpMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'BumpMapNode';\n\n\t}\n\n\tconstructor( textureNode, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.scaleNode = scaleNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst bumpScale = this.scaleNode !== null ? this.scaleNode : 1;\n\t\tconst dHdxy = dHdxy_fwd( { textureNode: this.textureNode, bumpScale } );\n\n\t\treturn perturbNormalArb( {\n\t\t\tsurf_pos: positionView,\n\t\t\tsurf_norm: normalView,\n\t\t\tdHdxy\n\t\t} );\n\n\t}\n\n}\n\nconst bumpMap = /*@__PURE__*/ nodeProxy( BumpMapNode );\n\nconst _propertyCache = new Map();\n\nclass MaterialNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MaterialNode';\n\n\t}\n\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgetCache( property, type ) {\n\n\t\tlet node = _propertyCache.get( property );\n\n\t\tif ( node === undefined ) {\n\n\t\t\tnode = materialReference( property, type );\n\n\t\t\t_propertyCache.set( property, node );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tgetFloat( property ) {\n\n\t\treturn this.getCache( property, 'float' );\n\n\t}\n\n\tgetColor( property ) {\n\n\t\treturn this.getCache( property, 'color' );\n\n\t}\n\n\tgetTexture( property ) {\n\n\t\treturn this.getCache( property === 'map' ? 'map' : property + 'Map', 'texture' );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst material = builder.context.material;\n\t\tconst scope = this.scope;\n\n\t\tlet node = null;\n\n\t\tif ( scope === MaterialNode.COLOR ) {\n\n\t\t\tconst colorNode = material.color !== undefined ? this.getColor( scope ) : vec3();\n\n\t\t\tif ( material.map && material.map.isTexture === true ) {\n\n\t\t\t\tnode = colorNode.mul( this.getTexture( 'map' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = colorNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.OPACITY ) {\n\n\t\t\tconst opacityNode = this.getFloat( scope );\n\n\t\t\tif ( material.alphaMap && material.alphaMap.isTexture === true ) {\n\n\t\t\t\tnode = opacityNode.mul( this.getTexture( 'alpha' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = opacityNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_STRENGTH ) {\n\n\t\t\tif ( material.specularMap && material.specularMap.isTexture === true ) {\n\n\t\t\t\tnode = this.getTexture( 'specular' ).r;\n\n\t\t\t} else {\n\n\t\t\t\tnode = float( 1 );\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_INTENSITY ) {\n\n\t\t\tconst specularIntensity = this.getFloat( scope );\n\n\t\t\tif ( material.specularMap ) {\n\n\t\t\t\tnode = specularIntensity.mul( this.getTexture( scope ).a );\n\n\t\t\t} else {\n\n\t\t\t\tnode = specularIntensity;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_COLOR ) {\n\n\t\t\tconst specularColorNode = this.getColor( scope );\n\n\t\t\tif ( material.specularColorMap && material.specularColorMap.isTexture === true ) {\n\n\t\t\t\tnode = specularColorNode.mul( this.getTexture( scope ).rgb );\n\n\t\t\t} else {\n\n\t\t\t\tnode = specularColorNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.ROUGHNESS ) { // TODO: cleanup similar branches\n\n\t\t\tconst roughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.roughnessMap && material.roughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = roughnessNode.mul( this.getTexture( scope ).g );\n\n\t\t\t} else {\n\n\t\t\t\tnode = roughnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.METALNESS ) {\n\n\t\t\tconst metalnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.metalnessMap && material.metalnessMap.isTexture === true ) {\n\n\t\t\t\tnode = metalnessNode.mul( this.getTexture( scope ).b );\n\n\t\t\t} else {\n\n\t\t\t\tnode = metalnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.EMISSIVE ) {\n\n\t\t\tconst emissiveIntensityNode = this.getFloat( 'emissiveIntensity' );\n\t\t\tconst emissiveNode = this.getColor( scope ).mul( emissiveIntensityNode );\n\n\t\t\tif ( material.emissiveMap && material.emissiveMap.isTexture === true ) {\n\n\t\t\t\tnode = emissiveNode.mul( this.getTexture( scope ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = emissiveNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.NORMAL ) {\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tnode = normalMap( this.getTexture( 'normal' ), this.getCache( 'normalScale', 'vec2' ) );\n\t\t\t\tnode.normalMapType = material.normalMapType;\n\n\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\tnode = bumpMap( this.getTexture( 'bump' ).r, this.getFloat( 'bumpScale' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = normalView;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT ) {\n\n\t\t\tconst clearcoatNode = this.getFloat( scope );\n\n\t\t\tif ( material.clearcoatMap && material.clearcoatMap.isTexture === true ) {\n\n\t\t\t\tnode = clearcoatNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = clearcoatNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT_ROUGHNESS ) {\n\n\t\t\tconst clearcoatRoughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = clearcoatRoughnessNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = clearcoatRoughnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT_NORMAL ) {\n\n\t\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\t\tnode = normalMap( this.getTexture( scope ), this.getCache( scope + 'Scale', 'vec2' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = normalView;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SHEEN ) {\n\n\t\t\tconst sheenNode = this.getColor( 'sheenColor' ).mul( this.getFloat( 'sheen' ) ); // Move this mul() to CPU\n\n\t\t\tif ( material.sheenColorMap && material.sheenColorMap.isTexture === true ) {\n\n\t\t\t\tnode = sheenNode.mul( this.getTexture( 'sheenColor' ).rgb );\n\n\t\t\t} else {\n\n\t\t\t\tnode = sheenNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SHEEN_ROUGHNESS ) {\n\n\t\t\tconst sheenRoughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = sheenRoughnessNode.mul( this.getTexture( scope ).a );\n\n\t\t\t} else {\n\n\t\t\t\tnode = sheenRoughnessNode;\n\n\t\t\t}\n\n\t\t\tnode = node.clamp( 0.07, 1.0 );\n\n\t\t} else if ( scope === MaterialNode.ANISOTROPY ) {\n\n\t\t\tif ( material.anisotropyMap && material.anisotropyMap.isTexture === true ) {\n\n\t\t\t\tconst anisotropyPolar = this.getTexture( scope );\n\t\t\t\tconst anisotropyMat = mat2( materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x );\n\n\t\t\t\tnode = anisotropyMat.mul( anisotropyPolar.rg.mul( 2.0 ).sub( vec2( 1.0 ) ).normalize().mul( anisotropyPolar.b ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = materialAnisotropyVector;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.IRIDESCENCE_THICKNESS ) {\n\n\t\t\tconst iridescenceThicknessMaximum = reference( '1', 'float', material.iridescenceThicknessRange );\n\n\t\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\t\tconst iridescenceThicknessMinimum = reference( '0', 'float', material.iridescenceThicknessRange );\n\n\t\t\t\tnode = iridescenceThicknessMaximum.sub( iridescenceThicknessMinimum ).mul( this.getTexture( scope ).g ).add( iridescenceThicknessMinimum );\n\n\t\t\t} else {\n\n\t\t\t\tnode = iridescenceThicknessMaximum;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.TRANSMISSION ) {\n\n\t\t\tconst transmissionNode = this.getFloat( scope );\n\n\t\t\tif ( material.transmissionMap ) {\n\n\t\t\t\tnode = transmissionNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = transmissionNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.THICKNESS ) {\n\n\t\t\tconst thicknessNode = this.getFloat( scope );\n\n\t\t\tif ( material.thicknessMap ) {\n\n\t\t\t\tnode = thicknessNode.mul( this.getTexture( scope ).g );\n\n\t\t\t} else {\n\n\t\t\t\tnode = thicknessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.IOR ) {\n\n\t\t\tnode = this.getFloat( scope );\n\n\t\t} else if ( scope === MaterialNode.LIGHT_MAP ) {\n\n\t\t\tnode = this.getTexture( scope ).rgb.mul( this.getFloat( 'lightMapIntensity' ) );\n\n\t\t} else if ( scope === MaterialNode.AO_MAP ) {\n\n\t\t\tnode = this.getTexture( scope ).r.sub( 1.0 ).mul( this.getFloat( 'aoMapIntensity' ) ).add( 1.0 );\n\n\t\t} else {\n\n\t\t\tconst outputType = this.getNodeType( builder );\n\n\t\t\tnode = this.getCache( scope, outputType );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nMaterialNode.ALPHA_TEST = 'alphaTest';\nMaterialNode.COLOR = 'color';\nMaterialNode.OPACITY = 'opacity';\nMaterialNode.SHININESS = 'shininess';\nMaterialNode.SPECULAR = 'specular';\nMaterialNode.SPECULAR_STRENGTH = 'specularStrength';\nMaterialNode.SPECULAR_INTENSITY = 'specularIntensity';\nMaterialNode.SPECULAR_COLOR = 'specularColor';\nMaterialNode.REFLECTIVITY = 'reflectivity';\nMaterialNode.ROUGHNESS = 'roughness';\nMaterialNode.METALNESS = 'metalness';\nMaterialNode.NORMAL = 'normal';\nMaterialNode.CLEARCOAT = 'clearcoat';\nMaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';\nMaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';\nMaterialNode.EMISSIVE = 'emissive';\nMaterialNode.ROTATION = 'rotation';\nMaterialNode.SHEEN = 'sheen';\nMaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';\nMaterialNode.ANISOTROPY = 'anisotropy';\nMaterialNode.IRIDESCENCE = 'iridescence';\nMaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';\nMaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';\nMaterialNode.IOR = 'ior';\nMaterialNode.TRANSMISSION = 'transmission';\nMaterialNode.THICKNESS = 'thickness';\nMaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';\nMaterialNode.ATTENUATION_COLOR = 'attenuationColor';\nMaterialNode.LINE_SCALE = 'scale';\nMaterialNode.LINE_DASH_SIZE = 'dashSize';\nMaterialNode.LINE_GAP_SIZE = 'gapSize';\nMaterialNode.LINE_WIDTH = 'linewidth';\nMaterialNode.LINE_DASH_OFFSET = 'dashOffset';\nMaterialNode.POINT_WIDTH = 'pointWidth';\nMaterialNode.DISPERSION = 'dispersion';\nMaterialNode.LIGHT_MAP = 'light';\nMaterialNode.AO_MAP = 'ao';\n\nconst materialAlphaTest = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );\nconst materialColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.COLOR );\nconst materialShininess = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHININESS );\nconst materialEmissive = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.EMISSIVE );\nconst materialOpacity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.OPACITY );\nconst materialSpecular = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR );\n\nconst materialSpecularIntensity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_INTENSITY );\nconst materialSpecularColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_COLOR );\n\nconst materialSpecularStrength = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_STRENGTH );\nconst materialReflectivity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.REFLECTIVITY );\nconst materialRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );\nconst materialMetalness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.METALNESS );\nconst materialNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.NORMAL ).context( { getUV: null } );\nconst materialClearcoat = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT );\nconst materialClearcoatRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS );\nconst materialClearcoatNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_NORMAL ).context( { getUV: null } );\nconst materialRotation = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROTATION );\nconst materialSheen = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN );\nconst materialSheenRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN_ROUGHNESS );\nconst materialAnisotropy = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ANISOTROPY );\nconst materialIridescence = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE );\nconst materialIridescenceIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_IOR );\nconst materialIridescenceThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS );\nconst materialTransmission = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.TRANSMISSION );\nconst materialThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.THICKNESS );\nconst materialIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IOR );\nconst materialAttenuationDistance = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_DISTANCE );\nconst materialAttenuationColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_COLOR );\nconst materialLineScale = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_SCALE );\nconst materialLineDashSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_SIZE );\nconst materialLineGapSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_GAP_SIZE );\nconst materialLineWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_WIDTH );\nconst materialLineDashOffset = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_OFFSET );\nconst materialPointWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.POINT_WIDTH );\nconst materialDispersion = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.DISPERSION );\nconst materialLightMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LIGHT_MAP );\nconst materialAOMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.AO_MAP );\nconst materialAnisotropyVector = /*@__PURE__*/ uniform( new Vector2() ).onReference( function ( frame ) {\n\n\treturn frame.material;\n\n} ).onRenderUpdate( function ( { material } ) {\n\n\tthis.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );\n\n} );\n\nclass ModelViewProjectionNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ModelViewProjectionNode';\n\n\t}\n\n\tconstructor( positionNode = null ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.positionNode = positionNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( builder.shaderStage === 'fragment' ) {\n\n\t\t\treturn varying( builder.context.mvp );\n\n\t\t}\n\n\t\tconst position = this.positionNode || positionLocal;\n\t\tconst viewMatrix = builder.renderer.nodes.modelViewMatrix || modelViewMatrix;\n\n\t\treturn cameraProjectionMatrix.mul( viewMatrix ).mul( position );\n\n\t}\n\n}\n\nconst modelViewProjection = /*@__PURE__*/ nodeProxy( ModelViewProjectionNode );\n\nclass IndexNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'IndexNode';\n\n\t}\n\n\tconstructor( scope ) {\n\n\t\tsuper( 'uint' );\n\n\t\tthis.scope = scope;\n\n\t\tthis.isInstanceIndexNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst scope = this.scope;\n\n\t\tlet propertyName;\n\n\t\tif ( scope === IndexNode.VERTEX ) {\n\n\t\t\t// The index of a vertex within a mesh.\n\t\t\tpropertyName = builder.getVertexIndex();\n\n\t\t} else if ( scope === IndexNode.INSTANCE ) {\n\n\t\t\t// The index of either a mesh instance or an invocation of a compute shader.\n\t\t\tpropertyName = builder.getInstanceIndex();\n\n\t\t} else if ( scope === IndexNode.DRAW ) {\n\n\t\t\t// The index of a draw call.\n\t\t\tpropertyName = builder.getDrawIndex();\n\n\t\t} else if ( scope === IndexNode.INVOCATION_LOCAL ) {\n\n\t\t\t// The index of a compute invocation within the scope of a workgroup load.\n\t\t\tpropertyName = builder.getInvocationLocalIndex();\n\n\t\t} else if ( scope === IndexNode.INVOCATION_SUBGROUP ) {\n\n\t\t\t// The index of a compute invocation within the scope of a subgroup.\n\t\t\tpropertyName = builder.getInvocationSubgroupIndex();\n\n\t\t} else if ( scope === IndexNode.SUBGROUP ) {\n\n\t\t\t// The index of the subgroup the current compute invocation belongs to.\n\t\t\tpropertyName = builder.getSubgroupIndex();\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.IndexNode: Unknown scope: ' + scope );\n\n\t\t}\n\n\t\tlet output;\n\n\t\tif ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {\n\n\t\t\toutput = propertyName;\n\n\t\t} else {\n\n\t\t\tconst nodeVarying = varying( this );\n\n\t\t\toutput = nodeVarying.build( builder, nodeType );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nIndexNode.VERTEX = 'vertex';\nIndexNode.INSTANCE = 'instance';\nIndexNode.SUBGROUP = 'subgroup';\nIndexNode.INVOCATION_LOCAL = 'invocationLocal';\nIndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';\nIndexNode.DRAW = 'draw';\n\nconst vertexIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.VERTEX );\nconst instanceIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INSTANCE );\nconst subgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.SUBGROUP );\nconst invocationSubgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_SUBGROUP );\nconst invocationLocalIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_LOCAL );\nconst drawIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.DRAW );\n\nclass InstanceNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'InstanceNode';\n\n\t}\n\n\tconstructor( count, instanceMatrix, instanceColor ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.count = count;\n\t\tthis.instanceMatrix = instanceMatrix;\n\t\tthis.instanceColor = instanceColor;\n\n\t\tthis.instanceMatrixNode = null;\n\n\t\tthis.instanceColorNode = null;\n\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t\tthis.buffer = null;\n\t\tthis.bufferColor = null;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { count, instanceMatrix, instanceColor } = this;\n\n\t\tlet { instanceMatrixNode, instanceColorNode } = this;\n\n\t\tif ( instanceMatrixNode === null ) {\n\n\t\t\t// Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.\n\n\t\t\tif ( count <= 1000 ) {\n\n\t\t\t\tinstanceMatrixNode = buffer( instanceMatrix.array, 'mat4', Math.max( count, 1 ) ).element( instanceIndex );\n\n\t\t\t} else {\n\n\t\t\t\tconst buffer = new InstancedInterleavedBuffer( instanceMatrix.array, 16, 1 );\n\n\t\t\t\tthis.buffer = buffer;\n\n\t\t\t\tconst bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n\n\t\t\t\tconst instanceBuffers = [\n\t\t\t\t\t// F.Signature -> bufferAttribute( array, type, stride, offset )\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 0 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 4 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 8 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 12 )\n\t\t\t\t];\n\n\t\t\t\tinstanceMatrixNode = mat4( ...instanceBuffers );\n\n\t\t\t}\n\n\t\t\tthis.instanceMatrixNode = instanceMatrixNode;\n\n\t\t}\n\n\t\tif ( instanceColor && instanceColorNode === null ) {\n\n\t\t\tconst buffer = new InstancedBufferAttribute( instanceColor.array, 3 );\n\n\t\t\tconst bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n\n\t\t\tthis.bufferColor = buffer;\n\n\t\t\tinstanceColorNode = vec3( bufferFn( buffer, 'vec3', 3, 0 ) );\n\n\t\t\tthis.instanceColorNode = instanceColorNode;\n\n\t\t}\n\n\t\t// POSITION\n\n\t\tconst instancePosition = instanceMatrixNode.mul( positionLocal ).xyz;\n\t\tpositionLocal.assign( instancePosition );\n\n\t\t// NORMAL\n\n\t\tif ( builder.hasGeometryAttribute( 'normal' ) ) {\n\n\t\t\tconst instanceNormal = transformNormal( normalLocal, instanceMatrixNode );\n\n\t\t\t// ASSIGNS\n\n\t\t\tnormalLocal.assign( instanceNormal );\n\n\t\t}\n\n\t\t// COLOR\n\n\t\tif ( this.instanceColorNode !== null ) {\n\n\t\t\tvaryingProperty( 'vec3', 'vInstanceColor' ).assign( this.instanceColorNode );\n\n\t\t}\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tif ( this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer != null && this.instanceMatrix.version !== this.buffer.version ) {\n\n\t\t\tthis.buffer.version = this.instanceMatrix.version;\n\n\t\t}\n\n\t\tif ( this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor != null && this.instanceColor.version !== this.bufferColor.version ) {\n\n\t\t\tthis.bufferColor.version = this.instanceColor.version;\n\n\t\t}\n\n\t}\n\n}\n\nconst instance = /*@__PURE__*/ nodeProxy( InstanceNode );\n\nclass InstancedMeshNode extends InstanceNode {\n\n\tstatic get type() {\n\n\t\treturn 'InstancedMeshNode';\n\n\t}\n\n\tconstructor( instanceMesh ) {\n\n\t\tconst { count, instanceMatrix, instanceColor } = instanceMesh;\n\n\t\tsuper( count, instanceMatrix, instanceColor );\n\n\t\tthis.instanceMesh = instanceMesh;\n\n\t}\n\n}\n\nconst instancedMesh = /*@__PURE__*/ nodeProxy( InstancedMeshNode );\n\nclass BatchNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'BatchNode';\n\n\t}\n\n\tconstructor( batchMesh ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.batchMesh = batchMesh;\n\n\n\t\tthis.batchingIdNode = null;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// POSITION\n\n\t\tif ( this.batchingIdNode === null ) {\n\n\t\t\tif ( builder.getDrawIndex() === null ) {\n\n\t\t\t\tthis.batchingIdNode = instanceIndex;\n\n\t\t\t} else {\n\n\t\t\t\tthis.batchingIdNode = drawIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst getIndirectIndex = Fn( ( [ id ] ) => {\n\n\t\t\tconst size = textureSize( textureLoad( this.batchMesh._indirectTexture ), 0 );\n\t\t\tconst x = int( id ).modInt( int( size ) );\n\t\t\tconst y = int( id ).div( int( size ) );\n\t\t\treturn textureLoad( this.batchMesh._indirectTexture, ivec2( x, y ) ).x;\n\n\t\t} ).setLayout( {\n\t\t\tname: 'getIndirectIndex',\n\t\t\ttype: 'uint',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'id', type: 'int' }\n\t\t\t]\n\t\t} );\n\n\t\tconst indirectId = getIndirectIndex( int( this.batchingIdNode ) );\n\n\t\tconst matricesTexture = this.batchMesh._matricesTexture;\n\n\t\tconst size = textureSize( textureLoad( matricesTexture ), 0 );\n\t\tconst j = float( indirectId ).mul( 4 ).toInt().toVar();\n\n\t\tconst x = j.modInt( size );\n\t\tconst y = j.div( int( size ) );\n\t\tconst batchingMatrix = mat4(\n\t\t\ttextureLoad( matricesTexture, ivec2( x, y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 1 ), y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 2 ), y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 3 ), y ) )\n\t\t);\n\n\n\t\tconst colorsTexture = this.batchMesh._colorsTexture;\n\n\t\tif ( colorsTexture !== null ) {\n\n\t\t\tconst getBatchingColor = Fn( ( [ id ] ) => {\n\n\t\t\t\tconst size = textureSize( textureLoad( colorsTexture ), 0 ).x;\n\t\t\t\tconst j = id;\n\t\t\t\tconst x = j.modInt( size );\n\t\t\t\tconst y = j.div( size );\n\t\t\t\treturn textureLoad( colorsTexture, ivec2( x, y ) ).rgb;\n\n\t\t\t} ).setLayout( {\n\t\t\t\tname: 'getBatchingColor',\n\t\t\t\ttype: 'vec3',\n\t\t\t\tinputs: [\n\t\t\t\t\t{ name: 'id', type: 'int' }\n\t\t\t\t]\n\t\t\t} );\n\n\t\t\tconst color = getBatchingColor( indirectId );\n\n\t\t\tvaryingProperty( 'vec3', 'vBatchColor' ).assign( color );\n\n\t\t}\n\n\t\tconst bm = mat3( batchingMatrix );\n\n\t\tpositionLocal.assign( batchingMatrix.mul( positionLocal ) );\n\n\t\tconst transformedNormal = normalLocal.div( vec3( bm[ 0 ].dot( bm[ 0 ] ), bm[ 1 ].dot( bm[ 1 ] ), bm[ 2 ].dot( bm[ 2 ] ) ) );\n\n\t\tconst batchingNormal = bm.mul( transformedNormal ).xyz;\n\n\t\tnormalLocal.assign( batchingNormal );\n\n\t\tif ( builder.hasGeometryAttribute( 'tangent' ) ) {\n\n\t\t\ttangentLocal.mulAssign( bm );\n\n\t\t}\n\n\t}\n\n}\n\nconst batch = /*@__PURE__*/ nodeProxy( BatchNode );\n\nconst _frameId = new WeakMap();\n\nclass SkinningNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SkinningNode';\n\n\t}\n\n\tconstructor( skinnedMesh, useReference = false ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.skinnedMesh = skinnedMesh;\n\t\tthis.useReference = useReference;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t//\n\n\t\tthis.skinIndexNode = attribute( 'skinIndex', 'uvec4' );\n\t\tthis.skinWeightNode = attribute( 'skinWeight', 'vec4' );\n\n\t\tlet bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;\n\n\t\tif ( useReference ) {\n\n\t\t\tbindMatrixNode = reference( 'bindMatrix', 'mat4' );\n\t\t\tbindMatrixInverseNode = reference( 'bindMatrixInverse', 'mat4' );\n\t\t\tboneMatricesNode = referenceBuffer( 'skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t} else {\n\n\t\t\tbindMatrixNode = uniform( skinnedMesh.bindMatrix, 'mat4' );\n\t\t\tbindMatrixInverseNode = uniform( skinnedMesh.bindMatrixInverse, 'mat4' );\n\t\t\tboneMatricesNode = buffer( skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t}\n\n\t\tthis.bindMatrixNode = bindMatrixNode;\n\t\tthis.bindMatrixInverseNode = bindMatrixInverseNode;\n\t\tthis.boneMatricesNode = boneMatricesNode;\n\t\tthis.previousBoneMatricesNode = null;\n\n\t}\n\n\tgetSkinnedPosition( boneMatrices = this.boneMatricesNode, position = positionLocal ) {\n\n\t\tconst { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;\n\n\t\tconst boneMatX = boneMatrices.element( skinIndexNode.x );\n\t\tconst boneMatY = boneMatrices.element( skinIndexNode.y );\n\t\tconst boneMatZ = boneMatrices.element( skinIndexNode.z );\n\t\tconst boneMatW = boneMatrices.element( skinIndexNode.w );\n\n\t\t// POSITION\n\n\t\tconst skinVertex = bindMatrixNode.mul( position );\n\n\t\tconst skinned = add(\n\t\t\tboneMatX.mul( skinWeightNode.x ).mul( skinVertex ),\n\t\t\tboneMatY.mul( skinWeightNode.y ).mul( skinVertex ),\n\t\t\tboneMatZ.mul( skinWeightNode.z ).mul( skinVertex ),\n\t\t\tboneMatW.mul( skinWeightNode.w ).mul( skinVertex )\n\t\t);\n\n\t\treturn bindMatrixInverseNode.mul( skinned ).xyz;\n\n\t}\n\n\tgetSkinnedNormal( boneMatrices = this.boneMatricesNode, normal = normalLocal ) {\n\n\t\tconst { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;\n\n\t\tconst boneMatX = boneMatrices.element( skinIndexNode.x );\n\t\tconst boneMatY = boneMatrices.element( skinIndexNode.y );\n\t\tconst boneMatZ = boneMatrices.element( skinIndexNode.z );\n\t\tconst boneMatW = boneMatrices.element( skinIndexNode.w );\n\n\t\t// NORMAL\n\n\t\tlet skinMatrix = add(\n\t\t\tskinWeightNode.x.mul( boneMatX ),\n\t\t\tskinWeightNode.y.mul( boneMatY ),\n\t\t\tskinWeightNode.z.mul( boneMatZ ),\n\t\t\tskinWeightNode.w.mul( boneMatW )\n\t\t);\n\n\t\tskinMatrix = bindMatrixInverseNode.mul( skinMatrix ).mul( bindMatrixNode );\n\n\t\treturn skinMatrix.transformDirection( normal ).xyz;\n\n\t}\n\n\tgetPreviousSkinnedPosition( builder ) {\n\n\t\tconst skinnedMesh = builder.object;\n\n\t\tif ( this.previousBoneMatricesNode === null ) {\n\n\t\t\tskinnedMesh.skeleton.previousBoneMatrices = new Float32Array( skinnedMesh.skeleton.boneMatrices );\n\n\t\t\tthis.previousBoneMatricesNode = referenceBuffer( 'skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t}\n\n\t\treturn this.getSkinnedPosition( this.previousBoneMatricesNode, positionPrevious );\n\n\t}\n\n\tneedsPreviousBoneMatrices( builder ) {\n\n\t\tconst mrt = builder.renderer.getMRT();\n\n\t\treturn mrt && mrt.has( 'velocity' );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( this.needsPreviousBoneMatrices( builder ) ) {\n\n\t\t\tpositionPrevious.assign( this.getPreviousSkinnedPosition( builder ) );\n\n\t\t}\n\n\t\tconst skinPosition = this.getSkinnedPosition();\n\n\n\t\tpositionLocal.assign( skinPosition );\n\n\t\tif ( builder.hasGeometryAttribute( 'normal' ) ) {\n\n\t\t\tconst skinNormal = this.getSkinnedNormal();\n\n\t\t\tnormalLocal.assign( skinNormal );\n\n\t\t\tif ( builder.hasGeometryAttribute( 'tangent' ) ) {\n\n\t\t\t\ttangentLocal.assign( skinNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\treturn positionLocal.build( builder, output );\n\n\t\t}\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst object = this.useReference ? frame.object : this.skinnedMesh;\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( _frameId.get( skeleton ) === frame.frameId ) return;\n\n\t\t_frameId.set( skeleton, frame.frameId );\n\n\t\tif ( this.previousBoneMatricesNode !== null ) skeleton.previousBoneMatrices.set( skeleton.boneMatrices );\n\n\t\tskeleton.update();\n\n\t}\n\n}\n\nconst skinning = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh ) );\nconst skinningReference = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh, true ) );\n\nclass LoopNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LoopNode';\n\n\t}\n\n\tconstructor( params = [] ) {\n\n\t\tsuper();\n\n\t\tthis.params = params;\n\n\t}\n\n\tgetVarName( index ) {\n\n\t\treturn String.fromCharCode( 'i'.charCodeAt() + index );\n\n\t}\n\n\tgetProperties( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.stackNode !== undefined ) return properties;\n\n\t\t//\n\n\t\tconst inputs = {};\n\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\n\n\t\t\tconst param = this.params[ i ];\n\n\t\t\tconst name = ( param.isNode !== true && param.name ) || this.getVarName( i );\n\t\t\tconst type = ( param.isNode !== true && param.type ) || 'int';\n\n\t\t\tinputs[ name ] = expression( name, type );\n\n\t\t}\n\n\t\tconst stack = builder.addStack(); // TODO: cache() it\n\n\t\tproperties.returnsNode = this.params[ this.params.length - 1 ]( inputs, stack, builder );\n\t\tproperties.stackNode = stack;\n\n\t\tbuilder.removeStack();\n\n\t\treturn properties;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst { returnsNode } = this.getProperties( builder );\n\n\t\treturn returnsNode ? returnsNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// setup properties\n\n\t\tthis.getProperties( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst properties = this.getProperties( builder );\n\n\t\tconst params = this.params;\n\t\tconst stackNode = properties.stackNode;\n\n\t\tfor ( let i = 0, l = params.length - 1; i < l; i ++ ) {\n\n\t\t\tconst param = params[ i ];\n\n\t\t\tlet start = null, end = null, name = null, type = null, condition = null, update = null;\n\n\t\t\tif ( param.isNode ) {\n\n\t\t\t\ttype = 'int';\n\t\t\t\tname = this.getVarName( i );\n\t\t\t\tstart = '0';\n\t\t\t\tend = param.build( builder, type );\n\t\t\t\tcondition = '<';\n\n\t\t\t} else {\n\n\t\t\t\ttype = param.type || 'int';\n\t\t\t\tname = param.name || this.getVarName( i );\n\t\t\t\tstart = param.start;\n\t\t\t\tend = param.end;\n\t\t\t\tcondition = param.condition;\n\t\t\t\tupdate = param.update;\n\n\t\t\t\tif ( typeof start === 'number' ) start = builder.generateConst( type, start );\n\t\t\t\telse if ( start && start.isNode ) start = start.build( builder, type );\n\n\t\t\t\tif ( typeof end === 'number' ) end = builder.generateConst( type, end );\n\t\t\t\telse if ( end && end.isNode ) end = end.build( builder, type );\n\n\t\t\t\tif ( start !== undefined && end === undefined ) {\n\n\t\t\t\t\tstart = start + ' - 1';\n\t\t\t\t\tend = '0';\n\t\t\t\t\tcondition = '>=';\n\n\t\t\t\t} else if ( end !== undefined && start === undefined ) {\n\n\t\t\t\t\tstart = '0';\n\t\t\t\t\tcondition = '<';\n\n\t\t\t\t}\n\n\t\t\t\tif ( condition === undefined ) {\n\n\t\t\t\t\tif ( Number( start ) > Number( end ) ) {\n\n\t\t\t\t\t\tcondition = '>=';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcondition = '<';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst internalParam = { start, end, condition };\n\n\t\t\t//\n\n\t\t\tconst startSnippet = internalParam.start;\n\t\t\tconst endSnippet = internalParam.end;\n\n\t\t\tlet declarationSnippet = '';\n\t\t\tlet conditionalSnippet = '';\n\t\t\tlet updateSnippet = '';\n\n\t\t\tif ( ! update ) {\n\n\t\t\t\tif ( type === 'int' || type === 'uint' ) {\n\n\t\t\t\t\tif ( condition.includes( '<' ) ) update = '++';\n\t\t\t\t\telse update = '--';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( condition.includes( '<' ) ) update = '+= 1.';\n\t\t\t\t\telse update = '-= 1.';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdeclarationSnippet += builder.getVar( type, name ) + ' = ' + startSnippet;\n\n\t\t\tconditionalSnippet += name + ' ' + condition + ' ' + endSnippet;\n\t\t\tupdateSnippet += name + ' ' + update;\n\n\t\t\tconst forSnippet = `for ( ${ declarationSnippet }; ${ conditionalSnippet }; ${ updateSnippet } )`;\n\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '\\n' : '' ) + builder.tab + forSnippet + ' {\\n\\n' ).addFlowTab();\n\n\t\t}\n\n\t\tconst stackSnippet = stackNode.build( builder, 'void' );\n\n\t\tconst returnsSnippet = properties.returnsNode ? properties.returnsNode.build( builder ) : '';\n\n\t\tbuilder.removeFlowTab().addFlowCode( '\\n' + builder.tab + stackSnippet );\n\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\n\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '' : builder.tab ) + '}\\n\\n' ).removeFlowTab();\n\n\t\t}\n\n\t\tbuilder.addFlowTab();\n\n\t\treturn returnsSnippet;\n\n\t}\n\n}\n\nconst Loop = ( ...params ) => nodeObject( new LoopNode( nodeArray( params, 'int' ) ) ).append();\nconst Continue = () => expression( 'continue' ).append();\nconst Break = () => expression( 'break' ).append();\n\n//\n\nconst loop = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.LoopNode: loop() has been renamed to Loop().' );\n\treturn Loop( ...params );\n\n};\n\nconst _morphTextures = /*@__PURE__*/ new WeakMap();\nconst _morphVec4 = /*@__PURE__*/ new Vector4();\n\nconst getMorph = /*@__PURE__*/ Fn( ( { bufferMap, influence, stride, width, depth, offset } ) => {\n\n\tconst texelIndex = int( vertexIndex ).mul( stride ).add( offset );\n\n\tconst y = texelIndex.div( width );\n\tconst x = texelIndex.sub( y.mul( width ) );\n\n\tconst bufferAttrib = textureLoad( bufferMap, ivec2( x, y ) ).depth( depth );\n\n\treturn bufferAttrib.mul( influence );\n\n} );\n\nfunction getEntry( geometry ) {\n\n\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\tconst hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n\t// instead of using attributes, the WebGL 2 code path encodes morph targets\n\t// into an array of data textures. Each layer represents a single morph target.\n\n\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\tlet entry = _morphTextures.get( geometry );\n\n\tif ( entry === undefined || entry.count !== morphTargetsCount ) {\n\n\t\tif ( entry !== undefined ) entry.texture.dispose();\n\n\t\tconst morphTargets = geometry.morphAttributes.position || [];\n\t\tconst morphNormals = geometry.morphAttributes.normal || [];\n\t\tconst morphColors = geometry.morphAttributes.color || [];\n\n\t\tlet vertexDataCount = 0;\n\n\t\tif ( hasMorphPosition === true ) vertexDataCount = 1;\n\t\tif ( hasMorphNormals === true ) vertexDataCount = 2;\n\t\tif ( hasMorphColors === true ) vertexDataCount = 3;\n\n\t\tlet width = geometry.attributes.position.count * vertexDataCount;\n\t\tlet height = 1;\n\n\t\tconst maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'\n\n\t\tif ( width > maxTextureSize ) {\n\n\t\t\theight = Math.ceil( width / maxTextureSize );\n\t\t\twidth = maxTextureSize;\n\n\t\t}\n\n\t\tconst buffer = new Float32Array( width * height * 4 * morphTargetsCount );\n\n\t\tconst bufferTexture = new DataArrayTexture( buffer, width, height, morphTargetsCount );\n\t\tbufferTexture.type = FloatType;\n\t\tbufferTexture.needsUpdate = true;\n\n\t\t// fill buffer\n\n\t\tconst vertexDataStride = vertexDataCount * 4;\n\n\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst morphNormal = morphNormals[ i ];\n\t\t\tconst morphColor = morphColors[ i ];\n\n\t\t\tconst offset = width * height * 4 * i;\n\n\t\t\tfor ( let j = 0; j < morphTarget.count; j ++ ) {\n\n\t\t\t\tconst stride = j * vertexDataStride;\n\n\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphTarget, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 0 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 1 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 2 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 3 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphNormal, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 4 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 5 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 6 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 7 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphColors === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphColor, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 8 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 9 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 10 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? _morphVec4.w : 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tentry = {\n\t\t\tcount: morphTargetsCount,\n\t\t\ttexture: bufferTexture,\n\t\t\tstride: vertexDataCount,\n\t\t\tsize: new Vector2( width, height )\n\t\t};\n\n\t\t_morphTextures.set( geometry, entry );\n\n\t\tfunction disposeTexture() {\n\n\t\t\tbufferTexture.dispose();\n\n\t\t\t_morphTextures.delete( geometry );\n\n\t\t\tgeometry.removeEventListener( 'dispose', disposeTexture );\n\n\t\t}\n\n\t\tgeometry.addEventListener( 'dispose', disposeTexture );\n\n\t}\n\n\treturn entry;\n\n}\n\n\nclass MorphNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MorphNode';\n\n\t}\n\n\tconstructor( mesh ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.mesh = mesh;\n\t\tthis.morphBaseInfluence = uniform( 1 );\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { geometry } = builder;\n\n\t\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\t\tconst hasMorphNormals = geometry.hasAttribute( 'normal' ) && geometry.morphAttributes.normal !== undefined;\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t// nodes\n\n\t\tconst { texture: bufferMap, stride, size } = getEntry( geometry );\n\n\t\tif ( hasMorphPosition === true ) positionLocal.mulAssign( this.morphBaseInfluence );\n\t\tif ( hasMorphNormals === true ) normalLocal.mulAssign( this.morphBaseInfluence );\n\n\t\tconst width = int( size.width );\n\n\t\tLoop( morphTargetsCount, ( { i } ) => {\n\n\t\t\tconst influence = float( 0 ).toVar();\n\n\t\t\tif ( this.mesh.count > 1 && ( this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined ) ) {\n\n\t\t\t\tinfluence.assign( textureLoad( this.mesh.morphTexture, ivec2( int( i ).add( 1 ), int( instanceIndex ) ) ).r );\n\n\t\t\t} else {\n\n\t\t\t\tinfluence.assign( reference( 'morphTargetInfluences', 'float' ).element( i ).toVar() );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\tpositionLocal.addAssign( getMorph( {\n\t\t\t\t\tbufferMap,\n\t\t\t\t\tinfluence,\n\t\t\t\t\tstride,\n\t\t\t\t\twidth,\n\t\t\t\t\tdepth: i,\n\t\t\t\t\toffset: int( 0 )\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\tnormalLocal.addAssign( getMorph( {\n\t\t\t\t\tbufferMap,\n\t\t\t\t\tinfluence,\n\t\t\t\t\tstride,\n\t\t\t\t\twidth,\n\t\t\t\t\tdepth: i,\n\t\t\t\t\toffset: int( 1 )\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tupdate() {\n\n\t\tconst morphBaseInfluence = this.morphBaseInfluence;\n\n\t\tif ( this.mesh.geometry.morphTargetsRelative ) {\n\n\t\t\tmorphBaseInfluence.value = 1;\n\n\t\t} else {\n\n\t\t\tmorphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce( ( a, b ) => a + b, 0 );\n\n\t\t}\n\n\t}\n\n}\n\nconst morphReference = /*@__PURE__*/ nodeProxy( MorphNode );\n\nclass LightingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LightingNode';\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.isLightingNode = true;\n\n\t}\n\n\tgenerate( /*builder*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nclass AONode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'AONode';\n\n\t}\n\n\tconstructor( aoNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.aoNode = aoNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.ambientOcclusion.mulAssign( this.aoNode );\n\n\t}\n\n}\n\nclass LightingContextNode extends ContextNode {\n\n\tstatic get type() {\n\n\t\treturn 'LightingContextNode';\n\n\t}\n\n\tconstructor( node, lightingModel = null, backdropNode = null, backdropAlphaNode = null ) {\n\n\t\tsuper( node );\n\n\t\tthis.lightingModel = lightingModel;\n\t\tthis.backdropNode = backdropNode;\n\t\tthis.backdropAlphaNode = backdropAlphaNode;\n\n\t\tthis._value = null;\n\n\t}\n\n\tgetContext() {\n\n\t\tconst { backdropNode, backdropAlphaNode } = this;\n\n\t\tconst directDiffuse = vec3().toVar( 'directDiffuse' ),\n\t\t\tdirectSpecular = vec3().toVar( 'directSpecular' ),\n\t\t\tindirectDiffuse = vec3().toVar( 'indirectDiffuse' ),\n\t\t\tindirectSpecular = vec3().toVar( 'indirectSpecular' );\n\n\t\tconst reflectedLight = {\n\t\t\tdirectDiffuse,\n\t\t\tdirectSpecular,\n\t\t\tindirectDiffuse,\n\t\t\tindirectSpecular\n\t\t};\n\n\t\tconst context = {\n\t\t\tradiance: vec3().toVar( 'radiance' ),\n\t\t\tirradiance: vec3().toVar( 'irradiance' ),\n\t\t\tiblIrradiance: vec3().toVar( 'iblIrradiance' ),\n\t\t\tambientOcclusion: float( 1 ).toVar( 'ambientOcclusion' ),\n\t\t\treflectedLight,\n\t\t\tbackdrop: backdropNode,\n\t\t\tbackdropAlpha: backdropAlphaNode\n\t\t};\n\n\t\treturn context;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.value = this._value || ( this._value = this.getContext() );\n\t\tthis.value.lightingModel = this.lightingModel || builder.context.lightingModel;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n}\n\nconst lightingContext = /*@__PURE__*/ nodeProxy( LightingContextNode );\n\nclass IrradianceNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'IrradianceNode';\n\n\t}\n\n\tconstructor( node ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.irradiance.addAssign( this.node );\n\n\t}\n\n}\n\nlet screenSizeVec, viewportVec;\n\nclass ScreenNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScreenNode';\n\n\t}\n\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t\tthis.isViewportNode = true;\n\n\t}\n\n\tgetNodeType() {\n\n\t\tif ( this.scope === ScreenNode.VIEWPORT ) return 'vec4';\n\t\telse return 'vec2';\n\n\t}\n\n\tgetUpdateType() {\n\n\t\tlet updateType = NodeUpdateType.NONE;\n\n\t\tif ( this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT ) {\n\n\t\t\tupdateType = NodeUpdateType.RENDER;\n\n\t\t}\n\n\t\tthis.updateType = updateType;\n\n\t\treturn updateType;\n\n\t}\n\n\tupdate( { renderer } ) {\n\n\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\tif ( this.scope === ScreenNode.VIEWPORT ) {\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tviewportVec.copy( renderTarget.viewport );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.getViewport( viewportVec );\n\n\t\t\t\tviewportVec.multiplyScalar( renderer.getPixelRatio() );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tscreenSizeVec.width = renderTarget.width;\n\t\t\t\tscreenSizeVec.height = renderTarget.height;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.getDrawingBufferSize( screenSizeVec );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( /*builder*/ ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet output = null;\n\n\t\tif ( scope === ScreenNode.SIZE ) {\n\n\t\t\toutput = uniform( screenSizeVec || ( screenSizeVec = new Vector2() ) );\n\n\t\t} else if ( scope === ScreenNode.VIEWPORT ) {\n\n\t\t\toutput = uniform( viewportVec || ( viewportVec = new Vector4() ) );\n\n\t\t} else {\n\n\t\t\toutput = vec2( screenCoordinate.div( screenSize ) );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tif ( this.scope === ScreenNode.COORDINATE ) {\n\n\t\t\tlet coord = builder.getFragCoord();\n\n\t\t\tif ( builder.isFlipY() ) {\n\n\t\t\t\t// follow webgpu standards\n\n\t\t\t\tconst size = builder.getNodeProperties( screenSize ).outputNode.build( builder );\n\n\t\t\t\tcoord = `${ builder.getType( 'vec2' ) }( ${ coord }.x, ${ size }.y - ${ coord }.y )`;\n\n\t\t\t}\n\n\t\t\treturn coord;\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n}\n\nScreenNode.COORDINATE = 'coordinate';\nScreenNode.VIEWPORT = 'viewport';\nScreenNode.SIZE = 'size';\nScreenNode.UV = 'uv';\n\n// Screen\n\nconst screenUV = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.UV );\nconst screenSize = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.SIZE );\nconst screenCoordinate = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.COORDINATE );\n\n// Viewport\n\nconst viewport = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.VIEWPORT );\nconst viewportSize = viewport.zw;\nconst viewportCoordinate = /*@__PURE__*/ screenCoordinate.sub( viewport.xy );\nconst viewportUV = /*@__PURE__*/ viewportCoordinate.div( viewportSize );\n\n// Deprecated\n\nconst viewportResolution = /*@__PURE__*/ ( Fn( () => { // @deprecated, r169\n\n\tconsole.warn( 'TSL.ViewportNode: \"viewportResolution\" is deprecated. Use \"screenSize\" instead.' );\n\n\treturn screenSize;\n\n}, 'vec2' ).once() )();\n\nconst viewportTopLeft = /*@__PURE__*/ ( Fn( () => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ViewportNode: \"viewportTopLeft\" is deprecated. Use \"screenUV\" instead.' );\n\n\treturn screenUV;\n\n}, 'vec2' ).once() )();\n\nconst viewportBottomLeft = /*@__PURE__*/ ( Fn( () => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ViewportNode: \"viewportBottomLeft\" is deprecated. Use \"screenUV.flipY()\" instead.' );\n\n\treturn screenUV.flipY();\n\n}, 'vec2' ).once() )();\n\nconst _size$4 = /*@__PURE__*/ new Vector2();\n\nclass ViewportTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportTextureNode';\n\n\t}\n\n\tconstructor( uvNode = screenUV, levelNode = null, framebufferTexture = null ) {\n\n\t\tif ( framebufferTexture === null ) {\n\n\t\t\tframebufferTexture = new FramebufferTexture();\n\t\t\tframebufferTexture.minFilter = LinearMipmapLinearFilter;\n\n\t\t}\n\n\t\tsuper( framebufferTexture, uvNode, levelNode );\n\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.isOutputTextureNode = true;\n\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst renderer = frame.renderer;\n\t\trenderer.getDrawingBufferSize( _size$4 );\n\n\t\t//\n\n\t\tconst framebufferTexture = this.value;\n\n\t\tif ( framebufferTexture.image.width !== _size$4.width || framebufferTexture.image.height !== _size$4.height ) {\n\n\t\t\tframebufferTexture.image.width = _size$4.width;\n\t\t\tframebufferTexture.image.height = _size$4.height;\n\t\t\tframebufferTexture.needsUpdate = true;\n\n\t\t}\n\n\t\t//\n\n\t\tconst currentGenerateMipmaps = framebufferTexture.generateMipmaps;\n\t\tframebufferTexture.generateMipmaps = this.generateMipmaps;\n\n\t\trenderer.copyFramebufferToTexture( framebufferTexture );\n\n\t\tframebufferTexture.generateMipmaps = currentGenerateMipmaps;\n\n\t}\n\n\tclone() {\n\n\t\tconst viewportTextureNode = new this.constructor( this.uvNode, this.levelNode, this.value );\n\t\tviewportTextureNode.generateMipmaps = this.generateMipmaps;\n\n\t\treturn viewportTextureNode;\n\n\t}\n\n}\n\nconst viewportTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode );\nconst viewportMipTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode, null, null, { generateMipmaps: true } );\n\nlet sharedDepthbuffer = null;\n\nclass ViewportDepthTextureNode extends ViewportTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportDepthTextureNode';\n\n\t}\n\n\tconstructor( uvNode = screenUV, levelNode = null ) {\n\n\t\tif ( sharedDepthbuffer === null ) {\n\n\t\t\tsharedDepthbuffer = new DepthTexture();\n\n\t\t}\n\n\t\tsuper( uvNode, levelNode, sharedDepthbuffer );\n\n\t}\n\n}\n\nconst viewportDepthTexture = /*@__PURE__*/ nodeProxy( ViewportDepthTextureNode );\n\nclass ViewportDepthNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportDepthNode';\n\n\t}\n\n\tconstructor( scope, valueNode = null ) {\n\n\t\tsuper( 'float' );\n\n\t\tthis.scope = scope;\n\t\tthis.valueNode = valueNode;\n\n\t\tthis.isViewportDepthNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { scope } = this;\n\n\t\tif ( scope === ViewportDepthNode.DEPTH_BASE ) {\n\n\t\t\treturn builder.getFragDepth();\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n\tsetup( { camera } ) {\n\n\t\tconst { scope } = this;\n\t\tconst value = this.valueNode;\n\n\t\tlet node = null;\n\n\t\tif ( scope === ViewportDepthNode.DEPTH_BASE ) {\n\n\t\t\tif ( value !== null ) {\n\n \t\t\t\tnode = depthBase().assign( value );\n\n\t\t\t}\n\n\t\t} else if ( scope === ViewportDepthNode.DEPTH ) {\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tnode = viewZToPerspectiveDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t} else {\n\n\t\t\t\tnode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t}\n\n\t\t} else if ( scope === ViewportDepthNode.LINEAR_DEPTH ) {\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tconst viewZ = perspectiveDepthToViewZ( value, cameraNear, cameraFar );\n\n\t\t\t\t\tnode = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode = value;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tnode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nViewportDepthNode.DEPTH_BASE = 'depthBase';\nViewportDepthNode.DEPTH = 'depth';\nViewportDepthNode.LINEAR_DEPTH = 'linearDepth';\n\n// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera\n\n// -near maps to 0; -far maps to 1\nconst viewZToOrthographicDepth = ( viewZ, near, far ) => viewZ.add( near ).div( near.sub( far ) );\n\n// maps orthographic depth in [ 0, 1 ] to viewZ\nconst orthographicDepthToViewZ = ( depth, near, far ) => near.sub( far ).mul( depth ).sub( near );\n\n// NOTE: https://twitter.com/gonnavis/status/1377183786949959682\n\n// -near maps to 0; -far maps to 1\nconst viewZToPerspectiveDepth = ( viewZ, near, far ) => near.add( viewZ ).mul( far ).div( far.sub( near ).mul( viewZ ) );\n\n// maps perspective depth in [ 0, 1 ] to viewZ\nconst perspectiveDepthToViewZ = ( depth, near, far ) => near.mul( far ).div( far.sub( near ).mul( depth ).sub( far ) );\n\n// -near maps to 0; -far maps to 1\nconst viewZToLogarithmicDepth = ( viewZ, near, far ) => {\n\n\t// NOTE: viewZ must be negative--see explanation at the end of this comment block.\n\t// The final logarithmic depth formula used here is adapted from one described in an\n\t// article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),\n\t// which was an improvement upon an earlier formula one described in an\n\t// Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).\n\t// Ulrich's formula is the following:\n\t//     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )\n\t//     where K = 2^k - 1, and k is the number of bits in the depth buffer.\n\t// The Outerra variant ignored the camera near plane (it assumed it was 0) and instead\n\t// opted for a \"C-constant\" for resolution adjustment of objects near the camera.\n\t// Outerra states: \"Notice that the 'C' variant doesn’t use a near plane distance, it has it\n\t// set at 0\" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).\n\t// Ulrich's variant has the benefit of constant relative precision over the whole near-far range.\n\t// It was debated here whether Outerra's \"C-constant\" or Ulrich's \"near plane\" variant should\n\t// be used, and ultimately Ulrich's \"near plane\" version was chosen.\n\t// Outerra eventually made another improvement to their original \"C-constant\" variant,\n\t// but it still does not incorporate the camera near plane (for this version,\n\t// see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).\n\t// Here we make 4 changes to Ulrich's formula:\n\t// 1. Clamp the camera near plane so we don't divide by 0.\n\t// 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).\n\t// 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).\n\t// 4. To maintain consistency with the functions \"viewZToOrthographicDepth\" and \"viewZToPerspectiveDepth\",\n\t//    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,\n\t//    so we do the same here, hence the 'viewZ.negate()' call.\n\t// For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u\n\tnear = near.max( 1e-6 ).toVar();\n\tconst numerator = log2( viewZ.negate().div( near ) );\n\tconst denominator = log2( far.div( near ) );\n\treturn numerator.div( denominator );\n\n};\n\n// maps logarithmic depth in [ 0, 1 ] to viewZ\nconst logarithmicDepthToViewZ = ( depth, near, far ) => {\n\n\t// NOTE: we add a 'negate()' call to the return value here to maintain consistency with\n\t// the functions \"orthographicDepthToViewZ\" and \"perspectiveDepthToViewZ\" (they return\n\t// a negative viewZ).\n\tconst exponent = depth.mul( log( far.div( near ) ) );\n\treturn float( Math.E ).pow( exponent ).mul( near ).negate();\n\n};\n\nconst depthBase = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.DEPTH_BASE );\n\nconst depth = /*@__PURE__*/ nodeImmutable( ViewportDepthNode, ViewportDepthNode.DEPTH );\nconst linearDepth = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH );\nconst viewportLinearDepth = /*@__PURE__*/ linearDepth( viewportDepthTexture() );\n\ndepth.assign = ( value ) => depthBase( value );\n\nclass BuiltinNode extends Node {\n\n\tconstructor( name ) {\n\n\t\tsuper( 'float' );\n\n\t\tthis.name = name;\n\n\t\tthis.isBuiltinNode = true;\n\n\t}\n\n\tgenerate( /* builder */ ) {\n\n\t\treturn this.name;\n\n\t}\n\n}\n\nconst builtin = nodeProxy( BuiltinNode );\n\nclass ClippingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ClippingNode';\n\n\t}\n\n\tconstructor( scope = ClippingNode.DEFAULT ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst clippingContext = builder.clippingContext;\n\t\tconst { intersectionPlanes, unionPlanes } = clippingContext;\n\n\t\tthis.hardwareClipping = builder.material.hardwareClipping;\n\n\t\tif ( this.scope === ClippingNode.ALPHA_TO_COVERAGE ) {\n\n\t\t\treturn this.setupAlphaToCoverage( intersectionPlanes, unionPlanes );\n\n\t\t} else if ( this.scope === ClippingNode.HARDWARE ) {\n\n\t\t\treturn this.setupHardwareClipping( unionPlanes, builder );\n\n\t\t} else {\n\n\t\t\treturn this.setupDefault( intersectionPlanes, unionPlanes );\n\n\t\t}\n\n\t}\n\n\tsetupAlphaToCoverage( intersectionPlanes, unionPlanes ) {\n\n\t\treturn Fn( () => {\n\n\t\t\tconst distanceToPlane = float().toVar( 'distanceToPlane' );\n\t\t\tconst distanceGradient = float().toVar( 'distanceToGradient' );\n\n\t\t\tconst clipOpacity = float( 1 ).toVar( 'clipOpacity' );\n\n\t\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\t\tif ( ! this.hardwareClipping && numUnionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( unionPlanes );\n\n\t\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\t\tdistanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );\n\t\t\t\t\tdistanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );\n\n\t\t\t\t\tclipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ) );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst numIntersectionPlanes = intersectionPlanes.length;\n\n\t\t\tif ( numIntersectionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( intersectionPlanes );\n\t\t\t\tconst intersectionClipOpacity = float( 1 ).toVar( 'intersectionClipOpacity' );\n\n\t\t\t\tLoop( numIntersectionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\t\tdistanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );\n\t\t\t\t\tdistanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );\n\n\t\t\t\t\tintersectionClipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ).oneMinus() );\n\n\t\t\t\t} );\n\n\t\t\t\tclipOpacity.mulAssign( intersectionClipOpacity.oneMinus() );\n\n\t\t\t}\n\n\t\t\tdiffuseColor.a.mulAssign( clipOpacity );\n\n\t\t\tdiffuseColor.a.equal( 0.0 ).discard();\n\n\t\t} )();\n\n\t}\n\n\tsetupDefault( intersectionPlanes, unionPlanes ) {\n\n\t\treturn Fn( () => {\n\n\t\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\t\tif ( ! this.hardwareClipping && numUnionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( unionPlanes );\n\n\t\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\t\t\t\t\tpositionView.dot( plane.xyz ).greaterThan( plane.w ).discard();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst numIntersectionPlanes = intersectionPlanes.length;\n\n\t\t\tif ( numIntersectionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( intersectionPlanes );\n\t\t\t\tconst clipped = bool( true ).toVar( 'clipped' );\n\n\t\t\t\tLoop( numIntersectionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\t\t\t\t\tclipped.assign( positionView.dot( plane.xyz ).greaterThan( plane.w ).and( clipped ) );\n\n\t\t\t\t} );\n\n\t\t\t\tclipped.discard();\n\n\t\t\t}\n\n\t\t} )();\n\n\t}\n\n\tsetupHardwareClipping( unionPlanes, builder ) {\n\n\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\tbuilder.enableHardwareClipping( numUnionPlanes );\n\n\t\treturn Fn( () => {\n\n\t\t\tconst clippingPlanes = uniformArray( unionPlanes );\n\t\t\tconst hw_clip_distances = builtin( builder.getClipDistance() );\n\n\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\tconst distance = positionView.dot( plane.xyz ).sub( plane.w ).negate();\n\t\t\t\thw_clip_distances.element( i ).assign( distance );\n\n\t\t\t} );\n\n\t\t} )();\n\n\t}\n\n}\n\nClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';\nClippingNode.DEFAULT = 'default';\nClippingNode.HARDWARE = 'hardware';\n\nconst clipping = () => nodeObject( new ClippingNode() );\nconst clippingAlpha = () => nodeObject( new ClippingNode( ClippingNode.ALPHA_TO_COVERAGE ) );\nconst hardwareClipping = () => nodeObject( new ClippingNode( ClippingNode.HARDWARE ) );\n\n/**\n * See: https://casual-effects.com/research/Wyman2017Hashed/index.html\n */\n\nconst ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.\n\nconst hash2D = /*@__PURE__*/ Fn( ( [ value ] ) => {\n\n\treturn fract( mul( 1.0e4, sin( mul( 17.0, value.x ).add( mul( 0.1, value.y ) ) ) ).mul( add( 0.1, abs( sin( mul( 13.0, value.y ).add( value.x ) ) ) ) ) );\n\n} );\n\nconst hash3D = /*@__PURE__*/ Fn( ( [ value ] ) => {\n\n\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\n} );\n\nconst getAlphaHashThreshold = /*@__PURE__*/ Fn( ( [ position ] ) => {\n\n\t// Find the discretized derivatives of our coordinates\n\tconst maxDeriv = max$1(\n\t\tlength( dFdx( position.xyz ) ),\n\t\tlength( dFdy( position.xyz ) )\n\t);\n\n\tconst pixScale = float( 1 ).div( float( ALPHA_HASH_SCALE ).mul( maxDeriv ) ).toVar( 'pixScale' );\n\n\t// Find two nearest log-discretized noise scales\n\tconst pixScales = vec2(\n\t\texp2( floor( log2( pixScale ) ) ),\n\t\texp2( ceil( log2( pixScale ) ) )\n\t);\n\n\t// Compute alpha thresholds at our two noise scales\n\tconst alpha = vec2(\n\t\thash3D( floor( pixScales.x.mul( position.xyz ) ) ),\n\t\thash3D( floor( pixScales.y.mul( position.xyz ) ) ),\n\t);\n\n\t// Factor to interpolate lerp with\n\tconst lerpFactor = fract( log2( pixScale ) );\n\n\t// Interpolate alpha threshold from noise at two scales\n\tconst x = add( mul( lerpFactor.oneMinus(), alpha.x ), mul( lerpFactor, alpha.y ) );\n\n\t// Pass into CDF to compute uniformly distrib threshold\n\tconst a = min$1( lerpFactor, lerpFactor.oneMinus() );\n\tconst cases = vec3(\n\t\tx.mul( x ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ),\n\t\tx.sub( mul( 0.5, a ) ).div( sub( 1.0, a ) ),\n\t\tsub( 1.0, sub( 1.0, x ).mul( sub( 1.0, x ) ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ) ) );\n\n\t// Find our final, uniformly distributed alpha threshold (ατ)\n\tconst threshold = x.lessThan( a.oneMinus() ).select( x.lessThan( a ).select( cases.x, cases.y ), cases.z );\n\n\t// Avoids ατ == 0. Could also do ατ =1-ατ\n\treturn clamp( threshold, 1.0e-6, 1.0 );\n\n} ).setLayout( {\n\tname: 'getAlphaHashThreshold',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'position', type: 'vec3' }\n\t]\n} );\n\nclass NodeMaterial extends Material {\n\n\tstatic get type() {\n\n\t\treturn 'NodeMaterial';\n\n\t}\n\n\tget type() {\n\n\t\treturn this.constructor.type;\n\n\t}\n\n\tset type( _value ) { /* */ }\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isNodeMaterial = true;\n\n\t\tthis.forceSinglePass = false;\n\n\t\tthis.fog = true;\n\t\tthis.lights = false;\n\t\tthis.hardwareClipping = false;\n\n\t\tthis.lightsNode = null;\n\t\tthis.envNode = null;\n\t\tthis.aoNode = null;\n\n\t\tthis.colorNode = null;\n\t\tthis.normalNode = null;\n\t\tthis.opacityNode = null;\n\t\tthis.backdropNode = null;\n\t\tthis.backdropAlphaNode = null;\n\t\tthis.alphaTestNode = null;\n\n\t\tthis.positionNode = null;\n\t\tthis.geometryNode = null;\n\n\t\tthis.depthNode = null;\n\t\tthis.shadowPositionNode = null;\n\t\tthis.receivedShadowNode = null;\n\t\tthis.castShadowNode = null;\n\n\t\tthis.outputNode = null;\n\t\tthis.mrtNode = null;\n\n\t\tthis.fragmentNode = null;\n\t\tthis.vertexNode = null;\n\n\t}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this.type + getCacheKey$1( this );\n\n\t}\n\n\tbuild( builder ) {\n\n\t\tthis.setup( builder );\n\n\t}\n\n\tsetupObserver( builder ) {\n\n\t\treturn new NodeMaterialObserver( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.setupNormal = () => this.setupNormal( builder );\n\n\t\tconst renderer = builder.renderer;\n\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\t// < VERTEX STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tbuilder.stack.outputNode = this.vertexNode || this.setupPosition( builder );\n\n\t\tif ( this.geometryNode !== null ) {\n\n\t\t\tbuilder.stack.outputNode = builder.stack.outputNode.bypass( this.geometryNode );\n\n\t\t}\n\n\t\tbuilder.addFlow( 'vertex', builder.removeStack() );\n\n\t\t// < FRAGMENT STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tlet resultNode;\n\n\t\tconst clippingNode = this.setupClipping( builder );\n\n\t\tif ( this.depthWrite === true ) {\n\n\t\t\t// only write depth if depth buffer is configured\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tif ( renderTarget.depthBuffer === true ) this.setupDepth( builder );\n\n\t\t\t} else {\n\n\t\t\t\tif ( renderer.depth === true ) this.setupDepth( builder );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.fragmentNode === null ) {\n\n\t\t\tthis.setupDiffuseColor( builder );\n\t\t\tthis.setupVariants( builder );\n\n\t\t\tconst outgoingLightNode = this.setupLighting( builder );\n\n\t\t\tif ( clippingNode !== null ) builder.stack.add( clippingNode );\n\n\t\t\t// force unsigned floats - useful for RenderTargets\n\n\t\t\tconst basicOutput = vec4( outgoingLightNode, diffuseColor.a ).max( 0 );\n\n\t\t\tresultNode = this.setupOutput( builder, basicOutput );\n\n\t\t\t// OUTPUT NODE\n\n\t\t\toutput.assign( resultNode );\n\n\t\t\t//\n\n\t\t\tif ( this.outputNode !== null ) resultNode = this.outputNode;\n\n\t\t\t// MRT\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tconst mrt = renderer.getMRT();\n\t\t\t\tconst materialMRT = this.mrtNode;\n\n\t\t\t\tif ( mrt !== null ) {\n\n\t\t\t\t\tresultNode = mrt;\n\n\t\t\t\t\tif ( materialMRT !== null ) {\n\n\t\t\t\t\t\tresultNode = mrt.merge( materialMRT );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialMRT !== null ) {\n\n\t\t\t\t\tresultNode = materialMRT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tlet fragmentNode = this.fragmentNode;\n\n\t\t\tif ( fragmentNode.isOutputStructNode !== true ) {\n\n\t\t\t\tfragmentNode = vec4( fragmentNode );\n\n\t\t\t}\n\n\t\t\tresultNode = this.setupOutput( builder, fragmentNode );\n\n\t\t}\n\n\t\tbuilder.stack.outputNode = resultNode;\n\n\t\tbuilder.addFlow( 'fragment', builder.removeStack() );\n\n\t\t// < MONITOR >\n\n\t\tbuilder.monitor = this.setupObserver( builder );\n\n\t}\n\n\tsetupClipping( builder ) {\n\n\t\tif ( builder.clippingContext === null ) return null;\n\n\t\tconst { unionPlanes, intersectionPlanes } = builder.clippingContext;\n\n\t\tlet result = null;\n\n\t\tif ( unionPlanes.length > 0 || intersectionPlanes.length > 0 ) {\n\n\t\t\tconst samples = builder.renderer.samples;\n\n\t\t\tif ( this.alphaToCoverage && samples > 1 ) {\n\n\t\t\t\t// to be added to flow when the color/alpha value has been determined\n\t\t\t\tresult = clippingAlpha();\n\n\t\t\t} else {\n\n\t\t\t\tbuilder.stack.add( clipping() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tsetupHardwareClipping( builder ) {\n\n\t\tthis.hardwareClipping = false;\n\n\t\tif ( builder.clippingContext === null ) return;\n\n\t\tconst candidateCount = builder.clippingContext.unionPlanes.length;\n\n\t\t// 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances\n\n\t\tif ( candidateCount > 0 && candidateCount <= 8 && builder.isAvailable( 'clipDistance' ) ) {\n\n\t\t\tbuilder.stack.add( hardwareClipping() );\n\n\t\t\tthis.hardwareClipping = true;\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\tsetupDepth( builder ) {\n\n\t\tconst { renderer, camera } = builder;\n\n\t\t// Depth\n\n\t\tlet depthNode = this.depthNode;\n\n\t\tif ( depthNode === null ) {\n\n\t\t\tconst mrt = renderer.getMRT();\n\n\t\t\tif ( mrt && mrt.has( 'depth' ) ) {\n\n\t\t\t\tdepthNode = mrt.get( 'depth' );\n\n\t\t\t} else if ( renderer.logarithmicDepthBuffer === true ) {\n\n\t\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tdepthNode = viewZToLogarithmicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdepthNode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( depthNode !== null ) {\n\n\t\t\tdepth.assign( depthNode ).append();\n\n\t\t}\n\n\t}\n\n\tsetupPosition( builder ) {\n\n\t\tconst { object } = builder;\n\t\tconst geometry = object.geometry;\n\n\t\tbuilder.addStack();\n\n\t\t// Vertex\n\n\t\tif ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {\n\n\t\t\tmorphReference( object ).append();\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\tskinningReference( object ).append();\n\n\t\t}\n\n\t\tif ( this.displacementMap ) {\n\n\t\t\tconst displacementMap = materialReference( 'displacementMap', 'texture' );\n\t\t\tconst displacementScale = materialReference( 'displacementScale', 'float' );\n\t\t\tconst displacementBias = materialReference( 'displacementBias', 'float' );\n\n\t\t\tpositionLocal.addAssign( normalLocal.normalize().mul( ( displacementMap.x.mul( displacementScale ).add( displacementBias ) ) ) );\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tbatch( object ).append();\n\n\t\t}\n\n\t\tif ( ( object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) ) {\n\n\t\t\tinstancedMesh( object ).append();\n\n\t\t}\n\n\t\tif ( this.positionNode !== null ) {\n\n\t\t\tpositionLocal.assign( this.positionNode );\n\n\t\t}\n\n\t\tthis.setupHardwareClipping( builder );\n\n\t\tconst mvp = modelViewProjection();\n\n\t\tbuilder.context.vertex = builder.removeStack();\n\t\tbuilder.context.mvp = mvp;\n\n\t\treturn mvp;\n\n\t}\n\n\tsetupDiffuseColor( { object, geometry } ) {\n\n\t\tlet colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;\n\n\t\t// VERTEX COLORS\n\n\t\tif ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {\n\n\t\t\tcolorNode = vec4( colorNode.xyz.mul( attribute( 'color', 'vec3' ) ), colorNode.a );\n\n\t\t}\n\n\t\t// Instanced colors\n\n\t\tif ( object.instanceColor ) {\n\n\t\t\tconst instanceColor = varyingProperty( 'vec3', 'vInstanceColor' );\n\n\t\t\tcolorNode = instanceColor.mul( colorNode );\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh && object._colorsTexture ) {\n\n\t\t\tconst batchColor = varyingProperty( 'vec3', 'vBatchColor' );\n\n\t\t\tcolorNode = batchColor.mul( colorNode );\n\n\t\t}\n\n\n\t\t// COLOR\n\n\t\tdiffuseColor.assign( colorNode );\n\n\t\t// OPACITY\n\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\t\tdiffuseColor.a.assign( diffuseColor.a.mul( opacityNode ) );\n\n\t\t// ALPHA TEST\n\n\t\tif ( this.alphaTestNode !== null || this.alphaTest > 0 ) {\n\n\t\t\tconst alphaTestNode = this.alphaTestNode !== null ? float( this.alphaTestNode ) : materialAlphaTest;\n\n\t\t\tdiffuseColor.a.lessThanEqual( alphaTestNode ).discard();\n\n\t\t}\n\n\t\t// ALPHA HASH\n\n\t\tif ( this.alphaHash === true ) {\n\n\t\t\tdiffuseColor.a.lessThan( getAlphaHashThreshold( positionLocal ) ).discard();\n\n\t\t}\n\n\t\tif ( this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false ) {\n\n\t\t\tdiffuseColor.a.assign( 1.0 );\n\n\t\t}\n\n\t}\n\n\tsetupVariants( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\tsetupOutgoingLight() {\n\n\t\treturn ( this.lights === true ) ? vec3( 0 ) : diffuseColor.rgb;\n\n\t}\n\n\tsetupNormal() {\n\n\t\treturn this.normalNode ? vec3( this.normalNode ) : materialNormal;\n\n\t}\n\n\tsetupEnvironment( /*builder*/ ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.envNode ) {\n\n\t\t\tnode = this.envNode;\n\n\t\t} else if ( this.envMap ) {\n\n\t\t\tnode = this.envMap.isCubeTexture ? materialReference( 'envMap', 'cubeTexture' ) : materialReference( 'envMap', 'texture' );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tsetupLightMap( builder ) {\n\n\t\tlet node = null;\n\n\t\tif ( builder.material.lightMap ) {\n\n\t\t\tnode = new IrradianceNode( materialLightMap );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tsetupLights( builder ) {\n\n\t\tconst materialLightsNode = [];\n\n\t\t//\n\n\t\tconst envNode = this.setupEnvironment( builder );\n\n\t\tif ( envNode && envNode.isLightingNode ) {\n\n\t\t\tmaterialLightsNode.push( envNode );\n\n\t\t}\n\n\t\tconst lightMapNode = this.setupLightMap( builder );\n\n\t\tif ( lightMapNode && lightMapNode.isLightingNode ) {\n\n\t\t\tmaterialLightsNode.push( lightMapNode );\n\n\t\t}\n\n\t\tif ( this.aoNode !== null || builder.material.aoMap ) {\n\n\t\t\tconst aoNode = this.aoNode !== null ? this.aoNode : materialAOMap;\n\n\t\t\tmaterialLightsNode.push( new AONode( aoNode ) );\n\n\t\t}\n\n\t\tlet lightsN = this.lightsNode || builder.lightsNode;\n\n\t\tif ( materialLightsNode.length > 0 ) {\n\n\t\t\tlightsN = builder.renderer.lighting.createNode( [ ...lightsN.getLights(), ...materialLightsNode ] );\n\n\t\t}\n\n\t\treturn lightsN;\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\tsetupLighting( builder ) {\n\n\t\tconst { material } = builder;\n\t\tconst { backdropNode, backdropAlphaNode, emissiveNode } = this;\n\n\t\t// OUTGOING LIGHT\n\n\t\tconst lights = this.lights === true || this.lightsNode !== null;\n\n\t\tconst lightsNode = lights ? this.setupLights( builder ) : null;\n\n\t\tlet outgoingLightNode = this.setupOutgoingLight( builder );\n\n\t\tif ( lightsNode && lightsNode.getScope().hasLights ) {\n\n\t\t\tconst lightingModel = this.setupLightingModel( builder );\n\n\t\t\toutgoingLightNode = lightingContext( lightsNode, lightingModel, backdropNode, backdropAlphaNode );\n\n\t\t} else if ( backdropNode !== null ) {\n\n\t\t\toutgoingLightNode = vec3( backdropAlphaNode !== null ? mix( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );\n\n\t\t}\n\n\t\t// EMISSIVE\n\n\t\tif ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {\n\n\t\t\temissive.assign( vec3( emissiveNode ? emissiveNode : materialEmissive ) );\n\n\t\t\toutgoingLightNode = outgoingLightNode.add( emissive );\n\n\t\t}\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\tsetupOutput( builder, outputNode ) {\n\n\t\t// FOG\n\n\t\tif ( this.fog === true ) {\n\n\t\t\tconst fogNode = builder.fogNode;\n\n\t\t\tif ( fogNode ) outputNode = vec4( fogNode.mix( outputNode.rgb, fogNode.colorNode ), outputNode.a );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n\tsetDefaultValues( material ) {\n\n\t\t// This approach is to reuse the native refreshUniforms*\n\t\t// and turn available the use of features like transmission and environment in core\n\n\t\tfor ( const property in material ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( this[ property ] === undefined ) {\n\n\t\t\t\tthis[ property ] = value;\n\n\t\t\t\tif ( value && value.clone ) this[ property ] = value.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&\n\t\t\t     descriptors[ key ].get !== undefined ) {\n\n\t\t\t\tObject.defineProperty( this.constructor.prototype, key, descriptors[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = Material.prototype.toJSON.call( this, meta );\n\t\tconst nodeChildren = getNodeChildren( this );\n\n\t\tdata.inputNodes = {};\n\n\t\tfor ( const { property, childNode } of nodeChildren ) {\n\n\t\t\tdata.inputNodes[ property ] = childNode.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.lightsNode = source.lightsNode;\n\t\tthis.envNode = source.envNode;\n\n\t\tthis.colorNode = source.colorNode;\n\t\tthis.normalNode = source.normalNode;\n\t\tthis.opacityNode = source.opacityNode;\n\t\tthis.backdropNode = source.backdropNode;\n\t\tthis.backdropAlphaNode = source.backdropAlphaNode;\n\t\tthis.alphaTestNode = source.alphaTestNode;\n\n\t\tthis.positionNode = source.positionNode;\n\t\tthis.geometryNode = source.geometryNode;\n\n\t\tthis.depthNode = source.depthNode;\n\t\tthis.shadowPositionNode = source.shadowPositionNode;\n\t\tthis.receivedShadowNode = source.receivedShadowNode;\n\t\tthis.castShadowNode = source.castShadowNode;\n\n\t\tthis.outputNode = source.outputNode;\n\t\tthis.mrtNode = source.mrtNode;\n\n\t\tthis.fragmentNode = source.fragmentNode;\n\t\tthis.vertexNode = source.vertexNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst _defaultValues$e = /*@__PURE__*/ new PointsMaterial();\n\nclass InstancedPointsNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'InstancedPointsNodeMaterial';\n\n\t}\n\n\tconstructor( params = {} ) {\n\n\t\tsuper();\n\n\t\tthis.lights = false;\n\n\t\tthis.useAlphaToCoverage = true;\n\n\t\tthis.useColor = params.vertexColors;\n\n\t\tthis.pointWidth = 1;\n\n\t\tthis.pointColorNode = null;\n\n\t\tthis.pointWidthNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$e );\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.setupShaders( builder );\n\n\t\tsuper.setup( builder );\n\n\t}\n\n\tsetupShaders( { renderer } ) {\n\n\t\tconst useAlphaToCoverage = this.alphaToCoverage;\n\t\tconst useColor = this.useColor;\n\n\t\tthis.vertexNode = Fn( () => {\n\n\t\t\tconst instancePosition = attribute( 'instancePosition' ).xyz;\n\n\t\t\t// camera space\n\t\t\tconst mvPos = vec4( modelViewMatrix.mul( vec4( instancePosition, 1.0 ) ) );\n\n\t\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t\t// clip space\n\t\t\tconst clipPos = cameraProjectionMatrix.mul( mvPos );\n\n\t\t\t// offset in ndc space\n\t\t\tconst offset = positionGeometry.xy.toVar();\n\n\t\t\toffset.mulAssign( this.pointWidthNode ? this.pointWidthNode : materialPointWidth );\n\n\t\t\toffset.assign( offset.div( viewport.z ) );\n\t\t\toffset.y.assign( offset.y.mul( aspect ) );\n\n\t\t\t// back to clip space\n\t\t\toffset.assign( offset.mul( clipPos.w ) );\n\n\t\t\t//clipPos.xy += offset;\n\t\t\tclipPos.addAssign( vec4( offset, 0, 0 ) );\n\n\t\t\treturn clipPos;\n\n\t\t} )();\n\n\t\tthis.fragmentNode = Fn( () => {\n\n\t\t\tconst alpha = float( 1 ).toVar();\n\n\t\t\tconst len2 = lengthSq( uv().mul( 2 ).sub( 1 ) );\n\n\t\t\tif ( useAlphaToCoverage && renderer.samples > 1 ) {\n\n\t\t\t\tconst dlen = float( len2.fwidth() ).toVar();\n\n\t\t\t\talpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t\t\t} else {\n\n\t\t\t\tlen2.greaterThan( 1.0 ).discard();\n\n\t\t\t}\n\n\t\t\tlet pointColorNode;\n\n\t\t\tif ( this.pointColorNode ) {\n\n\t\t\t\tpointColorNode = this.pointColorNode;\n\n\t\t\t} else {\n\n\t\t\t\tif ( useColor ) {\n\n\t\t\t\t\tconst instanceColor = attribute( 'instanceColor' );\n\n\t\t\t\t\tpointColorNode = instanceColor.mul( materialColor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpointColorNode = materialColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\talpha.mulAssign( materialOpacity );\n\n\t\t\treturn vec4( pointColorNode, alpha );\n\n\t\t} )();\n\n\t}\n\n\tget alphaToCoverage() {\n\n\t\treturn this.useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this.useAlphaToCoverage !== value ) {\n\n\t\t\tthis.useAlphaToCoverage = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nconst _defaultValues$d = /*@__PURE__*/ new LineBasicMaterial();\n\nclass LineBasicNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'LineBasicNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineBasicNodeMaterial = true;\n\n\t\tthis.lights = false;\n\n\t\tthis.setDefaultValues( _defaultValues$d );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n\nconst _defaultValues$c = /*@__PURE__*/ new LineDashedMaterial();\n\nclass LineDashedNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'LineDashedNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineDashedNodeMaterial = true;\n\n\t\tthis.lights = false;\n\n\t\tthis.setDefaultValues( _defaultValues$c );\n\n\t\tthis.dashOffset = 0;\n\n\t\tthis.offsetNode = null;\n\t\tthis.dashScaleNode = null;\n\t\tthis.dashSizeNode = null;\n\t\tthis.gapSizeNode = null;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupVariants() {\n\n\t\tconst offsetNode = this.offsetNode ? float( this.offsetNodeNode ) : materialLineDashOffset;\n\t\tconst dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;\n\t\tconst dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;\n\t\tconst gapSizeNode = this.dashSizeNode ? float( this.dashGapNode ) : materialLineGapSize;\n\n\t\tdashSize.assign( dashSizeNode );\n\t\tgapSize.assign( gapSizeNode );\n\n\t\tconst vLineDistance = varying( attribute( 'lineDistance' ).mul( dashScaleNode ) );\n\t\tconst vLineDistanceOffset = offsetNode ? vLineDistance.add( offsetNode ) : vLineDistance;\n\n\t\tvLineDistanceOffset.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard();\n\n\t}\n\n}\n\nlet _sharedFramebuffer = null;\n\nclass ViewportSharedTextureNode extends ViewportTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportSharedTextureNode';\n\n\t}\n\n\tconstructor( uvNode = screenUV, levelNode = null ) {\n\n\t\tif ( _sharedFramebuffer === null ) {\n\n\t\t\t_sharedFramebuffer = new FramebufferTexture();\n\n\t\t}\n\n\t\tsuper( uvNode, levelNode, _sharedFramebuffer );\n\n\t}\n\n\tupdateReference() {\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst viewportSharedTexture = /*@__PURE__*/ nodeProxy( ViewportSharedTextureNode );\n\nconst _defaultValues$b = /*@__PURE__*/ new LineDashedMaterial();\n\nclass Line2NodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'Line2NodeMaterial';\n\n\t}\n\n\tconstructor( params = {} ) {\n\n\t\tsuper();\n\n\t\tthis.lights = false;\n\n\t\tthis.setDefaultValues( _defaultValues$b );\n\n\t\tthis.useAlphaToCoverage = true;\n\t\tthis.useColor = params.vertexColors;\n\t\tthis.useDash = params.dashed;\n\t\tthis.useWorldUnits = false;\n\n\t\tthis.dashOffset = 0;\n\t\tthis.lineWidth = 1;\n\n\t\tthis.lineColorNode = null;\n\n\t\tthis.offsetNode = null;\n\t\tthis.dashScaleNode = null;\n\t\tthis.dashSizeNode = null;\n\t\tthis.gapSizeNode = null;\n\n\t\tthis.blending = NoBlending;\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.setupShaders( builder );\n\n\t\tsuper.setup( builder );\n\n\t}\n\n\tsetupShaders( { renderer } ) {\n\n\t\tconst useAlphaToCoverage = this.alphaToCoverage;\n\t\tconst useColor = this.useColor;\n\t\tconst useDash = this.dashed;\n\t\tconst useWorldUnits = this.worldUnits;\n\n\t\tconst trimSegment = Fn( ( { start, end } ) => {\n\n\t\t\tconst a = cameraProjectionMatrix.element( 2 ).element( 2 ); // 3nd entry in 3th column\n\t\t\tconst b = cameraProjectionMatrix.element( 3 ).element( 2 ); // 3nd entry in 4th column\n\t\t\tconst nearEstimate = b.mul( - 0.5 ).div( a );\n\n\t\t\tconst alpha = nearEstimate.sub( start.z ).div( end.z.sub( start.z ) );\n\n\t\t\treturn vec4( mix( start.xyz, end.xyz, alpha ), end.w );\n\n\t\t} ).setLayout( {\n\t\t\tname: 'trimSegment',\n\t\t\ttype: 'vec4',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'start', type: 'vec4' },\n\t\t\t\t{ name: 'end', type: 'vec4' }\n\t\t\t]\n\t\t} );\n\n\t\tthis.vertexNode = Fn( () => {\n\n\t\t\tconst instanceStart = attribute( 'instanceStart' );\n\t\t\tconst instanceEnd = attribute( 'instanceEnd' );\n\n\t\t\t// camera space\n\n\t\t\tconst start = vec4( modelViewMatrix.mul( vec4( instanceStart, 1.0 ) ) ).toVar( 'start' );\n\t\t\tconst end = vec4( modelViewMatrix.mul( vec4( instanceEnd, 1.0 ) ) ).toVar( 'end' );\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;\n\t\t\t\tconst offsetNode = this.offsetNode ? float( this.offsetNodeNode ) : materialLineDashOffset;\n\n\t\t\t\tconst instanceDistanceStart = attribute( 'instanceDistanceStart' );\n\t\t\t\tconst instanceDistanceEnd = attribute( 'instanceDistanceEnd' );\n\n\t\t\t\tlet lineDistance = positionGeometry.y.lessThan( 0.5 ).select( dashScaleNode.mul( instanceDistanceStart ), dashScaleNode.mul( instanceDistanceEnd ) );\n\t\t\t\tlineDistance = lineDistance.add( offsetNode );\n\n\t\t\t\tvaryingProperty( 'float', 'lineDistance' ).assign( lineDistance );\n\n\t\t\t}\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tvaryingProperty( 'vec3', 'worldStart' ).assign( start.xyz );\n\t\t\t\tvaryingProperty( 'vec3', 'worldEnd' ).assign( end.xyz );\n\n\t\t\t}\n\n\t\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tconst perspective = cameraProjectionMatrix.element( 2 ).element( 3 ).equal( - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tIf( perspective, () => {\n\n\t\t\t\tIf( start.z.lessThan( 0.0 ).and( end.z.greaterThan( 0.0 ) ), () => {\n\n\t\t\t\t\tend.assign( trimSegment( { start: start, end: end } ) );\n\n\t\t\t\t} ).ElseIf( end.z.lessThan( 0.0 ).and( start.z.greaterThanEqual( 0.0 ) ), () => {\n\n\t\t\t\t\tstart.assign( trimSegment( { start: end, end: start } ) );\n\n\t\t\t \t} );\n\n\t\t\t} );\n\n\t\t\t// clip space\n\t\t\tconst clipStart = cameraProjectionMatrix.mul( start );\n\t\t\tconst clipEnd = cameraProjectionMatrix.mul( end );\n\n\t\t\t// ndc space\n\t\t\tconst ndcStart = clipStart.xyz.div( clipStart.w );\n\t\t\tconst ndcEnd = clipEnd.xyz.div( clipEnd.w );\n\n\t\t\t// direction\n\t\t\tconst dir = ndcEnd.xy.sub( ndcStart.xy ).toVar();\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x.assign( dir.x.mul( aspect ) );\n\t\t\tdir.assign( dir.normalize() );\n\n\t\t\tconst clip = vec4().toVar();\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\n\t\t\t\tconst worldDir = end.xyz.sub( start.xyz ).normalize();\n\t\t\t\tconst tmpFwd = mix( start.xyz, end.xyz, 0.5 ).normalize();\n\t\t\t\tconst worldUp = worldDir.cross( tmpFwd ).normalize();\n\t\t\t\tconst worldFwd = worldDir.cross( worldUp );\n\n\t\t\t\tconst worldPos = varyingProperty( 'vec4', 'worldPos' );\n\n\t\t\t\tworldPos.assign( positionGeometry.y.lessThan( 0.5 ).select( start, end ) );\n\n\t\t\t\t// height offset\n\t\t\t\tconst hw = materialLineWidth.mul( 0.5 );\n\t\t\t\tworldPos.addAssign( vec4( positionGeometry.x.lessThan( 0.0 ).select( worldUp.mul( hw ), worldUp.mul( hw ).negate() ), 0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.addAssign( vec4( positionGeometry.y.lessThan( 0.5 ).select( worldDir.mul( hw ).negate(), worldDir.mul( hw ) ), 0 ) );\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.addAssign( vec4( worldFwd.mul( hw ), 0 ) );\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tIf( positionGeometry.y.greaterThan( 1.0 ).or( positionGeometry.y.lessThan( 0.0 ) ), () => {\n\n\t\t\t\t\t\tworldPos.subAssign( vec4( worldFwd.mul( 2.0 ).mul( hw ), 0 ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t// project the worldpos\n\t\t\t\tclip.assign( cameraProjectionMatrix.mul( worldPos ) );\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tconst clipPose = vec3().toVar();\n\n\t\t\t\tclipPose.assign( positionGeometry.y.lessThan( 0.5 ).select( ndcStart, ndcEnd ) );\n\t\t\t\tclip.z.assign( clipPose.z.mul( clip.w ) );\n\n\t\t\t} else {\n\n\t\t\t\tconst offset = vec2( dir.y, dir.x.negate() ).toVar( 'offset' );\n\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x.assign( dir.x.div( aspect ) );\n\t\t\t\toffset.x.assign( offset.x.div( aspect ) );\n\n\t\t\t\t// sign flip\n\t\t\t\toffset.assign( positionGeometry.x.lessThan( 0.0 ).select( offset.negate(), offset ) );\n\n\t\t\t\t// endcaps\n\t\t\t\tIf( positionGeometry.y.lessThan( 0.0 ), () => {\n\n\t\t\t\t\toffset.assign( offset.sub( dir ) );\n\n\t\t\t\t} ).ElseIf( positionGeometry.y.greaterThan( 1.0 ), () => {\n\n\t\t\t\t\toffset.assign( offset.add( dir ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset.assign( offset.mul( materialLineWidth ) );\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset.assign( offset.div( viewport.w ) );\n\n\t\t\t\t// select end\n\t\t\t\tclip.assign( positionGeometry.y.lessThan( 0.5 ).select( clipStart, clipEnd ) );\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset.assign( offset.mul( clip.w ) );\n\n\t\t\t\tclip.assign( clip.add( vec4( offset, 0, 0 ) ) );\n\n\t\t\t}\n\n\t\t\treturn clip;\n\n\t\t} )();\n\n\t\tconst closestLineToLine = Fn( ( { p1, p2, p3, p4 } ) => {\n\n\t\t\tconst p13 = p1.sub( p3 );\n\t\t\tconst p43 = p4.sub( p3 );\n\n\t\t\tconst p21 = p2.sub( p1 );\n\n\t\t\tconst d1343 = p13.dot( p43 );\n\t\t\tconst d4321 = p43.dot( p21 );\n\t\t\tconst d1321 = p13.dot( p21 );\n\t\t\tconst d4343 = p43.dot( p43 );\n\t\t\tconst d2121 = p21.dot( p21 );\n\n\t\t\tconst denom = d2121.mul( d4343 ).sub( d4321.mul( d4321 ) );\n\t\t\tconst numer = d1343.mul( d4321 ).sub( d1321.mul( d4343 ) );\n\n\t\t\tconst mua = numer.div( denom ).clamp();\n\t\t\tconst mub = d1343.add( d4321.mul( mua ) ).div( d4343 ).clamp();\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t} );\n\n\t\tthis.colorNode = Fn( () => {\n\n\t\t\tconst vUv = uv();\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;\n\t\t\t\tconst gapSizeNode = this.dashSizeNode ? float( this.dashGapNode ) : materialLineGapSize;\n\n\t\t\t\tdashSize.assign( dashSizeNode );\n\t\t\t\tgapSize.assign( gapSizeNode );\n\n\t\t\t\tconst vLineDistance = varyingProperty( 'float', 'lineDistance' );\n\n\t\t\t\tvUv.y.lessThan( - 1.0 ).or( vUv.y.greaterThan( 1.0 ) ).discard(); // discard endcaps\n\t\t\t\tvLineDistance.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard(); // todo - FIX\n\n\t\t\t}\n\n\t\t\tconst alpha = float( 1 ).toVar( 'alpha' );\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tconst worldStart = varyingProperty( 'vec3', 'worldStart' );\n\t\t\t\tconst worldEnd = varyingProperty( 'vec3', 'worldEnd' );\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tconst rayEnd = varyingProperty( 'vec4', 'worldPos' ).xyz.normalize().mul( 1e5 );\n\t\t\t\tconst lineDir = worldEnd.sub( worldStart );\n\t\t\t\tconst params = closestLineToLine( { p1: worldStart, p2: worldEnd, p3: vec3( 0.0, 0.0, 0.0 ), p4: rayEnd } );\n\n\t\t\t\tconst p1 = worldStart.add( lineDir.mul( params.x ) );\n\t\t\t\tconst p2 = rayEnd.mul( params.y );\n\t\t\t\tconst delta = p1.sub( p2 );\n\t\t\t\tconst len = delta.length();\n\t\t\t\tconst norm = len.div( materialLineWidth );\n\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\tif ( useAlphaToCoverage && renderer.samples > 1 ) {\n\n\t\t\t\t\t\tconst dnorm = norm.fwidth();\n\t\t\t\t\t\talpha.assign( smoothstep( dnorm.negate().add( 0.5 ), dnorm.add( 0.5 ), norm ).oneMinus() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnorm.greaterThan( 0.5 ).discard();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// round endcaps\n\n\t\t\t\tif ( useAlphaToCoverage && renderer.samples > 1 ) {\n\n\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\n\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\tconst dlen = float( len2.fwidth() ).toVar( 'dlen' );\n\n\t\t\t\t\tIf( vUv.y.abs().greaterThan( 1.0 ), () => {\n\n\t\t\t\t\t\talpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tIf( vUv.y.abs().greaterThan( 1.0 ), () => {\n\n\t\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\t\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\t\tlen2.greaterThan( 1.0 ).discard();\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet lineColorNode;\n\n\t\t\tif ( this.lineColorNode ) {\n\n\t\t\t\tlineColorNode = this.lineColorNode;\n\n\t\t\t} else {\n\n\t\t\t\tif ( useColor ) {\n\n\t\t\t\t\tconst instanceColorStart = attribute( 'instanceColorStart' );\n\t\t\t\t\tconst instanceColorEnd = attribute( 'instanceColorEnd' );\n\n\t\t\t\t\tconst instanceColor = positionGeometry.y.lessThan( 0.5 ).select( instanceColorStart, instanceColorEnd );\n\n\t\t\t\t\tlineColorNode = instanceColor.mul( materialColor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlineColorNode = materialColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn vec4( lineColorNode, alpha );\n\n\t\t} )();\n\n\t\tif ( this.transparent ) {\n\n\t\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\n\t\t\tthis.outputNode = vec4( this.colorNode.rgb.mul( opacityNode ).add( viewportSharedTexture().rgb.mul( opacityNode.oneMinus() ) ), this.colorNode.a );\n\n\t\t}\n\n\t}\n\n\n\tget worldUnits() {\n\n\t\treturn this.useWorldUnits;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( this.useWorldUnits !== value ) {\n\n\t\t\tthis.useWorldUnits = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\n\tget dashed() {\n\n\t\treturn this.useDash;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( this.useDash !== value ) {\n\n\t\t\tthis.useDash = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\n\tget alphaToCoverage() {\n\n\t\treturn this.useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this.useAlphaToCoverage !== value ) {\n\n\t\t\tthis.useAlphaToCoverage = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nconst directionToColor = ( node ) => nodeObject( node ).mul( 0.5 ).add( 0.5 );\nconst colorToDirection = ( node ) => nodeObject( node ).mul( 2.0 ).sub( 1 );\n\nconst _defaultValues$a = /*@__PURE__*/ new MeshNormalMaterial();\n\nclass MeshNormalNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshNormalNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.lights = false;\n\n\t\tthis.isMeshNormalNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$a );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupDiffuseColor() {\n\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\n\t\tdiffuseColor.assign( vec4( directionToColor( transformedNormalView ), opacityNode ) );\n\n\t}\n\n}\n\nclass EquirectUVNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'EquirectUVNode';\n\n\t}\n\n\tconstructor( dirNode = positionWorldDirection ) {\n\n\t\tsuper( 'vec2' );\n\n\t\tthis.dirNode = dirNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst dir = this.dirNode;\n\n\t\tconst u = dir.z.atan2( dir.x ).mul( 1 / ( Math.PI * 2 ) ).add( 0.5 );\n\t\tconst v = dir.y.clamp( - 1.0, 1.0 ).asin().mul( 1 / Math.PI ).add( 0.5 );\n\n\t\treturn vec2( u, v );\n\n\t}\n\n}\n\nconst equirectUV = /*@__PURE__*/ nodeProxy( EquirectUVNode );\n\n// @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget\n\nclass CubeRenderTarget extends WebGLCubeRenderTarget {\n\n\tconstructor( size = 1, options = {} ) {\n\n\t\tsuper( size, options );\n\n\t\tthis.isCubeRenderTarget = true;\n\n\t}\n\n\tfromEquirectangularTexture( renderer, texture$1 ) {\n\n\t\tconst currentMinFilter = texture$1.minFilter;\n\t\tconst currentGenerateMipmaps = texture$1.generateMipmaps;\n\n\t\ttexture$1.generateMipmaps = true;\n\n\t\tthis.texture.type = texture$1.type;\n\t\tthis.texture.colorSpace = texture$1.colorSpace;\n\n\t\tthis.texture.generateMipmaps = texture$1.generateMipmaps;\n\t\tthis.texture.minFilter = texture$1.minFilter;\n\t\tthis.texture.magFilter = texture$1.magFilter;\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst uvNode = equirectUV( positionWorldDirection );\n\n\t\tconst material = new NodeMaterial();\n\t\tmaterial.colorNode = texture( texture$1, uvNode, 0 );\n\t\tmaterial.side = BackSide;\n\t\tmaterial.blending = NoBlending;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst scene = new Scene();\n\t\tscene.add( mesh );\n\n\t\t// Avoid blurred poles\n\t\tif ( texture$1.minFilter === LinearMipmapLinearFilter ) texture$1.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\n\t\tconst currentMRT = renderer.getMRT();\n\t\trenderer.setMRT( null );\n\n\t\tcamera.update( renderer, scene );\n\n\t\trenderer.setMRT( currentMRT );\n\n\t\ttexture$1.minFilter = currentMinFilter;\n\t\ttexture$1.currentGenerateMipmaps = currentGenerateMipmaps;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _cache$1 = new WeakMap();\n\nclass CubeMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'CubeMapNode';\n\n\t}\n\n\tconstructor( envNode ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.envNode = envNode;\n\n\t\tthis._cubeTexture = null;\n\t\tthis._cubeTextureNode = cubeTexture();\n\n\t\tconst defaultTexture = new CubeTexture();\n\t\tdefaultTexture.isRenderTargetTexture = true;\n\n\t\tthis._defaultTexture = defaultTexture;\n\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer, material } = frame;\n\n\t\tconst envNode = this.envNode;\n\n\t\tif ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {\n\n\t\t\tconst texture = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];\n\n\t\t\tif ( texture && texture.isTexture ) {\n\n\t\t\t\tconst mapping = texture.mapping;\n\n\t\t\t\tif ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {\n\n\t\t\t\t\t// check for converted cubemap map\n\n\t\t\t\t\tif ( _cache$1.has( texture ) ) {\n\n\t\t\t\t\t\tconst cubeMap = _cache$1.get( texture );\n\n\t\t\t\t\t\tmapTextureMapping( cubeMap, texture.mapping );\n\t\t\t\t\t\tthis._cubeTexture = cubeMap;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// create cube map from equirectangular map\n\n\t\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\t\tif ( isEquirectangularMapReady$1( image ) ) {\n\n\t\t\t\t\t\t\tconst renderTarget = new CubeRenderTarget( image.height );\n\t\t\t\t\t\t\trenderTarget.fromEquirectangularTexture( renderer, texture );\n\n\t\t\t\t\t\t\tmapTextureMapping( renderTarget.texture, texture.mapping );\n\t\t\t\t\t\t\tthis._cubeTexture = renderTarget.texture;\n\n\t\t\t\t\t\t\t_cache$1.set( texture, renderTarget.texture );\n\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// default cube texture as fallback when equirectangular texture is not yet loaded\n\n\t\t\t\t\t\t\tthis._cubeTexture = this._defaultTexture;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\tthis._cubeTextureNode.value = this._cubeTexture;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// envNode already refers to a cube map\n\n\t\t\t\t\tthis._cubeTextureNode = this.envNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.updateBefore( builder );\n\n\t\treturn this._cubeTextureNode;\n\n\t}\n\n}\n\nfunction isEquirectangularMapReady$1( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\treturn image.height > 0;\n\n}\n\nfunction onTextureDispose( event ) {\n\n\tconst texture = event.target;\n\n\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\tconst renderTarget = _cache$1.get( texture );\n\n\tif ( renderTarget !== undefined ) {\n\n\t\t_cache$1.delete( texture );\n\n\t\trenderTarget.dispose();\n\n\t}\n\n}\n\nfunction mapTextureMapping( texture, mapping ) {\n\n\tif ( mapping === EquirectangularReflectionMapping ) {\n\n\t\ttexture.mapping = CubeReflectionMapping;\n\n\t} else if ( mapping === EquirectangularRefractionMapping ) {\n\n\t\ttexture.mapping = CubeRefractionMapping;\n\n\t}\n\n}\n\nconst cubeMapNode = /*@__PURE__*/ nodeProxy( CubeMapNode );\n\nclass BasicEnvironmentNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'BasicEnvironmentNode';\n\n\t}\n\n\tconstructor( envNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.envNode = envNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// environment property is used in the finish() method of BasicLightingModel\n\n\t\tbuilder.context.environment = cubeMapNode( this.envNode );\n\n\t}\n\n}\n\nclass BasicLightMapNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'BasicLightMapNode';\n\n\t}\n\n\tconstructor( lightMapNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.lightMapNode = lightMapNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel\n\n\t\tconst RECIPROCAL_PI = float( 1 / Math.PI );\n\n\t\tbuilder.context.irradianceLightMap = this.lightMapNode.mul( RECIPROCAL_PI );\n\n\t}\n\n}\n\nclass LightingModel {\n\n\tstart( /*input, stack, builder*/ ) { }\n\n\tfinish( /*input, stack, builder*/ ) { }\n\n\tdirect( /*input, stack, builder*/ ) { }\n\n\tdirectRectArea( /*input, stack, builder*/ ) {}\n\n\tindirect( /*input, stack, builder*/ ) { }\n\n\tambientOcclusion( /*input, stack, builder*/ ) { }\n\n}\n\nclass BasicLightingModel extends LightingModel {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t}\n\n\tindirect( context, stack, builder ) {\n\n\t\tconst ambientOcclusion = context.ambientOcclusion;\n\t\tconst reflectedLight = context.reflectedLight;\n\t\tconst irradianceLightMap = builder.context.irradianceLightMap;\n\n\t\treflectedLight.indirectDiffuse.assign( vec4( 0.0 ) );\n\n\t\t// accumulation (baked indirect lighting only)\n\n\t\tif ( irradianceLightMap ) {\n\n\t\t\treflectedLight.indirectDiffuse.addAssign( irradianceLightMap );\n\n\t\t} else {\n\n\t\t\treflectedLight.indirectDiffuse.addAssign( vec4( 1.0, 1.0, 1.0, 0.0 ) );\n\n\t\t}\n\n\t\t// modulation\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( diffuseColor.rgb );\n\n\t}\n\n\tfinish( context, stack, builder ) {\n\n\t\tconst material = builder.material;\n\t\tconst outgoingLight = context.outgoingLight;\n\t\tconst envNode = builder.context.environment;\n\n\t\tif ( envNode ) {\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\toutgoingLight.rgb.assign( mix( outgoingLight.rgb, outgoingLight.rgb.mul( envNode.rgb ), materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MixOperation:\n\t\t\t\t\toutgoingLight.rgb.assign( mix( outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AddOperation:\n\t\t\t\t\toutgoingLight.rgb.addAssign( envNode.rgb.mul( materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.BasicLightingModel: Unsupported .combine value:', material.combine );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst _defaultValues$9 = /*@__PURE__*/ new MeshBasicMaterial();\n\nclass MeshBasicNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshBasicNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshBasicNodeMaterial = true;\n\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$9 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupNormal() {\n\n\t\treturn normalView; // see #28839\n\n\t}\n\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\tsetupLightMap( builder ) {\n\n\t\tlet node = null;\n\n\t\tif ( builder.material.lightMap ) {\n\n\t\t\tnode = new BasicLightMapNode( materialLightMap );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tsetupOutgoingLight() {\n\n\t\treturn diffuseColor.rgb;\n\n\t}\n\n\tsetupLightingModel() {\n\n\t\treturn new BasicLightingModel();\n\n\t}\n\n}\n\nconst F_Schlick = /*@__PURE__*/ Fn( ( { f0, f90, dotVH } ) => {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tconst fresnel = dotVH.mul( - 5.55473 ).sub( 6.98316 ).mul( dotVH ).exp2();\n\n\treturn f0.mul( fresnel.oneMinus() ).add( f90.mul( fresnel ) );\n\n} ); // validated\n\nconst BRDF_Lambert = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\treturn inputs.diffuseColor.mul( 1 / Math.PI ); // punctual light\n\n} ); // validated\n\nconst G_BlinnPhong_Implicit = () => float( 0.25 );\n\nconst D_BlinnPhong = /*@__PURE__*/ Fn( ( { dotNH } ) => {\n\n\treturn shininess.mul( float( 0.5 ) ).add( 1.0 ).mul( float( 1 / Math.PI ) ).mul( dotNH.pow( shininess ) );\n\n} );\n\nconst BRDF_BlinnPhong = /*@__PURE__*/ Fn( ( { lightDirection } ) => {\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNH = transformedNormalView.dot( halfDir ).clamp();\n\tconst dotVH = positionViewDirection.dot( halfDir ).clamp();\n\n\tconst F = F_Schlick( { f0: specularColor, f90: 1.0, dotVH } );\n\tconst G = G_BlinnPhong_Implicit();\n\tconst D = D_BlinnPhong( { dotNH } );\n\n\treturn F.mul( G ).mul( D );\n\n} );\n\nclass PhongLightingModel extends BasicLightingModel {\n\n\tconstructor( specular = true ) {\n\n\t\tsuper();\n\n\t\tthis.specular = specular;\n\n\t}\n\n\tdirect( { lightDirection, lightColor, reflectedLight } ) {\n\n\t\tconst dotNL = transformedNormalView.dot( lightDirection ).clamp();\n\t\tconst irradiance = dotNL.mul( lightColor );\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t\tif ( this.specular === true ) {\n\n\t\t\treflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_BlinnPhong( { lightDirection } ) ).mul( materialSpecularStrength ) );\n\n\t\t}\n\n\t}\n\n\tindirect( { ambientOcclusion, irradiance, reflectedLight } ) {\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t}\n\n}\n\nconst _defaultValues$8 = /*@__PURE__*/ new MeshLambertMaterial();\n\nclass MeshLambertNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshLambertNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshLambertNodeMaterial = true;\n\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$8 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhongLightingModel( false ); // ( specular ) -> force lambert\n\n\t}\n\n}\n\nconst _defaultValues$7 = /*@__PURE__*/ new MeshPhongMaterial();\n\nclass MeshPhongNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshPhongNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhongNodeMaterial = true;\n\n\t\tthis.lights = true;\n\n\t\tthis.shininessNode = null;\n\t\tthis.specularNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$7 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhongLightingModel();\n\n\t}\n\n\tsetupVariants() {\n\n\t\t// SHININESS\n\n\t\tconst shininessNode = ( this.shininessNode ? float( this.shininessNode ) : materialShininess ).max( 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tshininess.assign( shininessNode );\n\n\t\t// SPECULAR COLOR\n\n\t\tconst specularNode = this.specularNode || materialSpecular;\n\n\t\tspecularColor.assign( specularNode );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.shininessNode = source.shininessNode;\n\t\tthis.specularNode = source.specularNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst getGeometryRoughness = /*@__PURE__*/ Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'normal' ) === false ) {\n\n\t\treturn float( 0 );\n\n\t}\n\n\tconst dxy = normalView.dFdx().abs().max( normalView.dFdy().abs() );\n\tconst geometryRoughness = dxy.x.max( dxy.y ).max( dxy.z );\n\n\treturn geometryRoughness;\n\n} );\n\nconst getRoughness = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { roughness } = inputs;\n\n\tconst geometryRoughness = getGeometryRoughness();\n\n\tlet roughnessFactor = roughness.max( 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.\n\troughnessFactor = roughnessFactor.add( geometryRoughness );\n\troughnessFactor = roughnessFactor.min( 1.0 );\n\n\treturn roughnessFactor;\n\n} );\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nconst V_GGX_SmithCorrelated = /*@__PURE__*/ Fn( ( { alpha, dotNL, dotNV } ) => {\n\n\tconst a2 = alpha.pow2();\n\n\tconst gv = dotNL.mul( a2.add( a2.oneMinus().mul( dotNV.pow2() ) ).sqrt() );\n\tconst gl = dotNV.mul( a2.add( a2.oneMinus().mul( dotNL.pow2() ) ).sqrt() );\n\n\treturn div( 0.5, gv.add( gl ).max( EPSILON ) );\n\n} ).setLayout( {\n\tname: 'V_GGX_SmithCorrelated',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alpha', type: 'float' },\n\t\t{ name: 'dotNL', type: 'float' },\n\t\t{ name: 'dotNV', type: 'float' }\n\t]\n} ); // validated\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } ) => {\n\n\tconst gv = dotNL.mul( vec3( alphaT.mul( dotTV ), alphaB.mul( dotBV ), dotNV ).length() );\n\tconst gl = dotNV.mul( vec3( alphaT.mul( dotTL ), alphaB.mul( dotBL ), dotNL ).length() );\n\tconst v = div( 0.5, gv.add( gl ) );\n\n\treturn v.saturate();\n\n} ).setLayout( {\n\tname: 'V_GGX_SmithCorrelated_Anisotropic',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alphaT', type: 'float', qualifier: 'in' },\n\t\t{ name: 'alphaB', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTL', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBL', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNL', type: 'float', qualifier: 'in' }\n\t]\n} );\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nconst D_GGX = /*@__PURE__*/ Fn( ( { alpha, dotNH } ) => {\n\n\tconst a2 = alpha.pow2();\n\n\tconst denom = dotNH.pow2().mul( a2.oneMinus() ).oneMinus(); // avoid alpha = 0 with dotNH = 1\n\n\treturn a2.div( denom.pow2() ).mul( 1 / Math.PI );\n\n} ).setLayout( {\n\tname: 'D_GGX',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alpha', type: 'float' },\n\t\t{ name: 'dotNH', type: 'float' }\n\t]\n} ); // validated\n\nconst RECIPROCAL_PI = /*@__PURE__*/ float( 1 / Math.PI );\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst D_GGX_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotNH, dotTH, dotBH } ) => {\n\n\tconst a2 = alphaT.mul( alphaB );\n\tconst v = vec3( alphaB.mul( dotTH ), alphaT.mul( dotBH ), a2.mul( dotNH ) );\n\tconst v2 = v.dot( v );\n\tconst w2 = a2.div( v2 );\n\n\treturn RECIPROCAL_PI.mul( a2.mul( w2.pow2() ) );\n\n} ).setLayout( {\n\tname: 'D_GGX_Anisotropic',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alphaT', type: 'float', qualifier: 'in' },\n\t\t{ name: 'alphaB', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNH', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTH', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBH', type: 'float', qualifier: 'in' }\n\t]\n} );\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nconst BRDF_GGX = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { lightDirection, f0, f90, roughness, f, USE_IRIDESCENCE, USE_ANISOTROPY } = inputs;\n\n\tconst normalView = inputs.normalView || transformedNormalView;\n\n\tconst alpha = roughness.pow2(); // UE4's roughness\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNL = normalView.dot( lightDirection ).clamp();\n\tconst dotNV = normalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\tconst dotNH = normalView.dot( halfDir ).clamp();\n\tconst dotVH = positionViewDirection.dot( halfDir ).clamp();\n\n\tlet F = F_Schlick( { f0, f90, dotVH } );\n\tlet V, D;\n\n\tif ( defined( USE_IRIDESCENCE ) ) {\n\n\t\tF = iridescence.mix( F, f );\n\n\t}\n\n\tif ( defined( USE_ANISOTROPY ) ) {\n\n\t\tconst dotTL = anisotropyT.dot( lightDirection );\n\t\tconst dotTV = anisotropyT.dot( positionViewDirection );\n\t\tconst dotTH = anisotropyT.dot( halfDir );\n\t\tconst dotBL = anisotropyB.dot( lightDirection );\n\t\tconst dotBV = anisotropyB.dot( positionViewDirection );\n\t\tconst dotBH = anisotropyB.dot( halfDir );\n\n\t\tV = V_GGX_SmithCorrelated_Anisotropic( { alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } );\n\t\tD = D_GGX_Anisotropic( { alphaT, alphaB: alpha, dotNH, dotTH, dotBH } );\n\n\t} else {\n\n\t\tV = V_GGX_SmithCorrelated( { alpha, dotNL, dotNV } );\n\t\tD = D_GGX( { alpha, dotNH } );\n\n\t}\n\n\treturn F.mul( V ).mul( D );\n\n} ); // validated\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from \"Physically Based Shading on Mobile\"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nconst DFGApprox = /*@__PURE__*/ Fn( ( { roughness, dotNV } ) => {\n\n\tconst c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tconst r = roughness.mul( c0 ).add( c1 );\n\n\tconst a004 = r.x.mul( r.x ).min( dotNV.mul( - 9.28 ).exp2() ).mul( r.x ).add( r.y );\n\n\tconst fab = vec2( - 1.04, 1.04 ).mul( a004 ).add( r.zw );\n\n\treturn fab;\n\n} ).setLayout( {\n\tname: 'DFGApprox',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' },\n\t\t{ name: 'dotNV', type: 'vec3' }\n\t]\n} );\n\nconst EnvironmentBRDF = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { dotNV, specularColor, specularF90, roughness } = inputs;\n\n\tconst fab = DFGApprox( { dotNV, roughness } );\n\treturn specularColor.mul( fab.x ).add( specularF90.mul( fab.y ) );\n\n} );\n\nconst Schlick_to_F0 = /*@__PURE__*/ Fn( ( { f, f90, dotVH } ) => {\n\n\tconst x = dotVH.oneMinus().saturate();\n\tconst x2 = x.mul( x );\n\tconst x5 = x.mul( x2, x2 ).clamp( 0, .9999 );\n\n\treturn f.sub( vec3( f90 ).mul( x5 ) ).div( x5.oneMinus() );\n\n} ).setLayout( {\n\tname: 'Schlick_to_F0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'f', type: 'vec3' },\n\t\t{ name: 'f90', type: 'float' },\n\t\t{ name: 'dotVH', type: 'float' }\n\t]\n} );\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst D_Charlie = /*@__PURE__*/ Fn( ( { roughness, dotNH } ) => {\n\n\tconst alpha = roughness.pow2();\n\n\t// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n\tconst invAlpha = float( 1.0 ).div( alpha );\n\tconst cos2h = dotNH.pow2();\n\tconst sin2h = cos2h.oneMinus().max( 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\n\treturn float( 2.0 ).add( invAlpha ).mul( sin2h.pow( invAlpha.mul( 0.5 ) ) ).div( 2.0 * Math.PI );\n\n} ).setLayout( {\n\tname: 'D_Charlie',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' },\n\t\t{ name: 'dotNH', type: 'float' }\n\t]\n} );\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst V_Neubelt = /*@__PURE__*/ Fn( ( { dotNV, dotNL } ) => {\n\n\t// Neubelt and Pettineo 2013, \"Crafting a Next-gen Material Pipeline for The Order: 1886\"\n\treturn float( 1.0 ).div( float( 4.0 ).mul( dotNL.add( dotNV ).sub( dotNL.mul( dotNV ) ) ) );\n\n} ).setLayout( {\n\tname: 'V_Neubelt',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'dotNV', type: 'float' },\n\t\t{ name: 'dotNL', type: 'float' }\n\t]\n} );\n\nconst BRDF_Sheen = /*@__PURE__*/ Fn( ( { lightDirection } ) => {\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNL = transformedNormalView.dot( lightDirection ).clamp();\n\tconst dotNV = transformedNormalView.dot( positionViewDirection ).clamp();\n\tconst dotNH = transformedNormalView.dot( halfDir ).clamp();\n\n\tconst D = D_Charlie( { roughness: sheenRoughness, dotNH } );\n\tconst V = V_Neubelt( { dotNV, dotNL } );\n\n\treturn sheen.mul( D ).mul( V );\n\n} );\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nconst LTC_Uv = /*@__PURE__*/ Fn( ( { N, V, roughness } ) => {\n\n\tconst LUT_SIZE = 64.0;\n\tconst LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst LUT_BIAS = 0.5 / LUT_SIZE;\n\n\tconst dotNV = N.dot( V ).saturate();\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tconst uv = vec2( roughness, dotNV.oneMinus().sqrt() );\n\n\tuv.assign( uv.mul( LUT_SCALE ).add( LUT_BIAS ) );\n\n\treturn uv;\n\n} ).setLayout( {\n\tname: 'LTC_Uv',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'N', type: 'vec3' },\n\t\t{ name: 'V', type: 'vec3' },\n\t\t{ name: 'roughness', type: 'float' }\n\t]\n} );\n\nconst LTC_ClippedSphereFormFactor = /*@__PURE__*/ Fn( ( { f } ) => {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tconst l = f.length();\n\n\treturn max$1( l.mul( l ).add( f.z ).div( l.add( 1.0 ) ), 0 );\n\n} ).setLayout( {\n\tname: 'LTC_ClippedSphereFormFactor',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'f', type: 'vec3' }\n\t]\n} );\n\nconst LTC_EdgeVectorFormFactor = /*@__PURE__*/ Fn( ( { v1, v2 } ) => {\n\n\tconst x = v1.dot( v2 );\n\tconst y = x.abs().toVar();\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tconst a = y.mul( 0.0145206 ).add( 0.4965155 ).mul( y ).add( 0.8543985 ).toVar();\n\tconst b = y.add( 4.1616724 ).mul( y ).add( 3.4175940 ).toVar();\n\tconst v = a.div( b );\n\n\tconst theta_sintheta = x.greaterThan( 0.0 ).select( v, max$1( x.mul( x ).oneMinus(), 1e-7 ).inverseSqrt().mul( 0.5 ).sub( v ) );\n\n\treturn v1.cross( v2 ).mul( theta_sintheta );\n\n} ).setLayout( {\n\tname: 'LTC_EdgeVectorFormFactor',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' }\n\t]\n} );\n\nconst LTC_Evaluate = /*@__PURE__*/ Fn( ( { N, V, P, mInv, p0, p1, p2, p3 } ) => {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tconst v1 = p1.sub( p0 ).toVar();\n\tconst v2 = p3.sub( p0 ).toVar();\n\n\tconst lightNormal = v1.cross( v2 );\n\tconst result = vec3().toVar();\n\n\tIf( lightNormal.dot( P.sub( p0 ) ).greaterThanEqual( 0.0 ), () => {\n\n\t\t// construct orthonormal basis around N\n\t\tconst T1 = V.sub( N.mul( V.dot( N ) ) ).normalize();\n\t\tconst T2 = N.cross( T1 ).negate(); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t\t// compute transform\n\t\tconst mat = mInv.mul( mat3( T1, T2, N ).transpose() ).toVar();\n\n\t\t// transform rect\n\t\t// & project rect onto sphere\n\t\tconst coords0 = mat.mul( p0.sub( P ) ).normalize().toVar();\n\t\tconst coords1 = mat.mul( p1.sub( P ) ).normalize().toVar();\n\t\tconst coords2 = mat.mul( p2.sub( P ) ).normalize().toVar();\n\t\tconst coords3 = mat.mul( p3.sub( P ) ).normalize().toVar();\n\n\t\t// calculate vector form factor\n\t\tconst vectorFormFactor = vec3( 0 ).toVar();\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords0, v2: coords1 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords1, v2: coords2 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords2, v2: coords3 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords3, v2: coords0 } ) );\n\n\t\t// adjust for horizon clipping\n\t\tresult.assign( vec3( LTC_ClippedSphereFormFactor( { f: vectorFormFactor } ) ) );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'LTC_Evaluate',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'N', type: 'vec3' },\n\t\t{ name: 'V', type: 'vec3' },\n\t\t{ name: 'P', type: 'vec3' },\n\t\t{ name: 'mInv', type: 'mat3' },\n\t\t{ name: 'p0', type: 'vec3' },\n\t\t{ name: 'p1', type: 'vec3' },\n\t\t{ name: 'p2', type: 'vec3' },\n\t\t{ name: 'p3', type: 'vec3' }\n\t]\n} );\n\n// Mipped Bicubic Texture Filtering by N8\n// https://www.shadertoy.com/view/Dl2SDW\n\nconst bC = 1.0 / 6.0;\n\nconst w0 = ( a ) => mul( bC, mul( a, mul( a, a.negate().add( 3.0 ) ).sub( 3.0 ) ).add( 1.0 ) );\n\nconst w1 = ( a ) => mul( bC, mul( a, mul( a, mul( 3.0, a ).sub( 6.0 ) ) ).add( 4.0 ) );\n\nconst w2 = ( a ) => mul( bC, mul( a, mul( a, mul( - 3.0, a ).add( 3.0 ) ).add( 3.0 ) ).add( 1.0 ) );\n\nconst w3 = ( a ) => mul( bC, pow( a, 3 ) );\n\nconst g0 = ( a ) => w0( a ).add( w1( a ) );\n\nconst g1 = ( a ) => w2( a ).add( w3( a ) );\n\n// h0 and h1 are the two offset functions\nconst h0 = ( a ) => add( - 1.0, w1( a ).div( w0( a ).add( w1( a ) ) ) );\n\nconst h1 = ( a ) => add( 1.0, w3( a ).div( w2( a ).add( w3( a ) ) ) );\n\nconst bicubic = ( textureNode, texelSize, lod ) => {\n\n\tconst uv = textureNode.uvNode;\n\tconst uvScaled = mul( uv, texelSize.zw ).add( 0.5 );\n\n\tconst iuv = floor( uvScaled );\n\tconst fuv = fract( uvScaled );\n\n\tconst g0x = g0( fuv.x );\n\tconst g1x = g1( fuv.x );\n\tconst h0x = h0( fuv.x );\n\tconst h1x = h1( fuv.x );\n\tconst h0y = h0( fuv.y );\n\tconst h1y = h1( fuv.y );\n\n\tconst p0 = vec2( iuv.x.add( h0x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p1 = vec2( iuv.x.add( h1x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p2 = vec2( iuv.x.add( h0x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p3 = vec2( iuv.x.add( h1x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );\n\n\tconst a = g0( fuv.y ).mul( add( g0x.mul( textureNode.uv( p0 ).level( lod ) ), g1x.mul( textureNode.uv( p1 ).level( lod ) ) ) );\n\tconst b = g1( fuv.y ).mul( add( g0x.mul( textureNode.uv( p2 ).level( lod ) ), g1x.mul( textureNode.uv( p3 ).level( lod ) ) ) );\n\n\treturn a.add( b );\n\n};\n\nconst textureBicubic = /*@__PURE__*/ Fn( ( [ textureNode, lodNode = float( 3 ) ] ) => {\n\n\tconst fLodSize = vec2( textureNode.size( int( lodNode ) ) );\n\tconst cLodSize = vec2( textureNode.size( int( lodNode.add( 1.0 ) ) ) );\n\tconst fLodSizeInv = div( 1.0, fLodSize );\n\tconst cLodSizeInv = div( 1.0, cLodSize );\n\tconst fSample = bicubic( textureNode, vec4( fLodSizeInv, fLodSize ), floor( lodNode ) );\n\tconst cSample = bicubic( textureNode, vec4( cLodSizeInv, cLodSize ), ceil( lodNode ) );\n\n\treturn fract( lodNode ).mix( fSample, cSample );\n\n} );\n\n//\n// Transmission\n//\n\nconst getVolumeTransmissionRay = /*@__PURE__*/ Fn( ( [ n, v, thickness, ior, modelMatrix ] ) => {\n\n\t// Direction of refracted light.\n\tconst refractionVector = vec3( refract( v.negate(), normalize( n ), div( 1.0, ior ) ) );\n\n\t// Compute rotation-independant scaling of the model matrix.\n\tconst modelScale = vec3(\n\t\tlength( modelMatrix[ 0 ].xyz ),\n\t\tlength( modelMatrix[ 1 ].xyz ),\n\t\tlength( modelMatrix[ 2 ].xyz )\n\t);\n\n\t// The thickness is specified in local space.\n\treturn normalize( refractionVector ).mul( thickness.mul( modelScale ) );\n\n} ).setLayout( {\n\tname: 'getVolumeTransmissionRay',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'n', type: 'vec3' },\n\t\t{ name: 'v', type: 'vec3' },\n\t\t{ name: 'thickness', type: 'float' },\n\t\t{ name: 'ior', type: 'float' },\n\t\t{ name: 'modelMatrix', type: 'mat4' }\n\t]\n} );\n\nconst applyIorToRoughness = /*@__PURE__*/ Fn( ( [ roughness, ior ] ) => {\n\n\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\treturn roughness.mul( clamp( ior.mul( 2.0 ).sub( 2.0 ), 0.0, 1.0 ) );\n\n} ).setLayout( {\n\tname: 'applyIorToRoughness',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' },\n\t\t{ name: 'ior', type: 'float' }\n\t]\n} );\n\nconst viewportBackSideTexture = /*@__PURE__*/ viewportMipTexture();\nconst viewportFrontSideTexture = /*@__PURE__*/ viewportMipTexture();\n\nconst getTransmissionSample = /*@__PURE__*/ Fn( ( [ fragCoord, roughness, ior ], { material } ) => {\n\n\tconst vTexture = material.side == BackSide ? viewportBackSideTexture : viewportFrontSideTexture;\n\n\tconst transmissionSample = vTexture.uv( fragCoord );\n\t//const transmissionSample = viewportMipTexture( fragCoord );\n\n\tconst lod = log2( screenSize.x ).mul( applyIorToRoughness( roughness, ior ) );\n\n\treturn textureBicubic( transmissionSample, lod );\n\n} );\n\nconst volumeAttenuation = /*@__PURE__*/ Fn( ( [ transmissionDistance, attenuationColor, attenuationDistance ] ) => {\n\n\tIf( attenuationDistance.notEqual( 0 ), () => {\n\n\t\t// Compute light attenuation using Beer's law.\n\t\tconst attenuationCoefficient = log( attenuationColor ).negate().div( attenuationDistance );\n\t\tconst transmittance = exp( attenuationCoefficient.negate().mul( transmissionDistance ) );\n\n\t\treturn transmittance;\n\n\t} );\n\n\t// Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.\n\treturn vec3( 1.0 );\n\n} ).setLayout( {\n\tname: 'volumeAttenuation',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'transmissionDistance', type: 'float' },\n\t\t{ name: 'attenuationColor', type: 'vec3' },\n\t\t{ name: 'attenuationDistance', type: 'float' }\n\t]\n} );\n\nconst getIBLVolumeRefraction = /*@__PURE__*/ Fn( ( [ n, v, roughness, diffuseColor, specularColor, specularF90, position, modelMatrix, viewMatrix, projMatrix, ior, thickness, attenuationColor, attenuationDistance, dispersion ] ) => {\n\n\tlet transmittedLight, transmittance;\n\n\tif ( dispersion ) {\n\n\t\ttransmittedLight = vec4().toVar();\n\t\ttransmittance = vec3().toVar();\n\n\t\tconst halfSpread = ior.sub( 1.0 ).mul( dispersion.mul( 0.025 ) );\n\t\tconst iors = vec3( ior.sub( halfSpread ), ior, ior.add( halfSpread ) );\n\n\t\tLoop( { start: 0, end: 3 }, ( { i } ) => {\n\n\t\t\tconst ior = iors.element( i );\n\n\t\t\tconst transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tconst refractedRayExit = position.add( transmissionRay );\n\n\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\tconst ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );\n\t\t\tconst refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();\n\t\t\trefractionCoords.addAssign( 1.0 );\n\t\t\trefractionCoords.divAssign( 2.0 );\n\t\t\trefractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu\n\n\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\tconst transmissionSample = getTransmissionSample( refractionCoords, roughness, ior );\n\n\t\t\ttransmittedLight.element( i ).assign( transmissionSample.element( i ) );\n\t\t\ttransmittedLight.a.addAssign( transmissionSample.a );\n\n\t\t\ttransmittance.element( i ).assign( diffuseColor.element( i ).mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ).element( i ) ) );\n\n\t\t} );\n\n\t\ttransmittedLight.a.divAssign( 3.0 );\n\n\t} else {\n\n\t\tconst transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tconst refractedRayExit = position.add( transmissionRay );\n\n\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\tconst ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );\n\t\tconst refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();\n\t\trefractionCoords.addAssign( 1.0 );\n\t\trefractionCoords.divAssign( 2.0 );\n\t\trefractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu\n\n\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\ttransmittance = diffuseColor.mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ) );\n\n\t}\n\n\tconst attenuatedColor = transmittance.rgb.mul( transmittedLight.rgb );\n\tconst dotNV = n.dot( v ).clamp();\n\n\t// Get the specular component.\n\tconst F = vec3( EnvironmentBRDF( { // n, v, specularColor, specularF90, roughness\n\t\tdotNV,\n\t\tspecularColor,\n\t\tspecularF90,\n\t\troughness\n\t} ) );\n\n\t// As less light is transmitted, the opacity should be increased. This simple approximation does a decent job\n\t// of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.\n\tconst transmittanceFactor = transmittance.r.add( transmittance.g, transmittance.b ).div( 3.0 );\n\n\treturn vec4( F.oneMinus().mul( attenuatedColor ), transmittedLight.a.oneMinus().mul( transmittanceFactor ).oneMinus() );\n\n} );\n\n//\n// Iridescence\n//\n\n// XYZ to linear-sRGB color space\nconst XYZ_TO_REC709 = /*@__PURE__*/ mat3(\n\t3.2404542, - 0.9692660, 0.0556434,\n\t- 1.5371385, 1.8760108, - 0.2040259,\n\t- 0.4985314, 0.0415560, 1.0572252\n);\n\n// Assume air interface for top\n// Note: We don't handle the case fresnel0 == 1\nconst Fresnel0ToIor = ( fresnel0 ) => {\n\n\tconst sqrtF0 = fresnel0.sqrt();\n\treturn vec3( 1.0 ).add( sqrtF0 ).div( vec3( 1.0 ).sub( sqrtF0 ) );\n\n};\n\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nconst IorToFresnel0 = ( transmittedIor, incidentIor ) => {\n\n\treturn transmittedIor.sub( incidentIor ).div( transmittedIor.add( incidentIor ) ).pow2();\n\n};\n\n// Fresnel equations for dielectric/dielectric interfaces.\n// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n// Evaluation XYZ sensitivity curves in Fourier space\nconst evalSensitivity = ( OPD, shift ) => {\n\n\tconst phase = OPD.mul( 2.0 * Math.PI * 1.0e-9 );\n\tconst val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\tconst pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\tconst VAR = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\tconst x = float( 9.7470e-14 * Math.sqrt( 2.0 * Math.PI * 4.5282e+09 ) ).mul( phase.mul( 2.2399e+06 ).add( shift.x ).cos() ).mul( phase.pow2().mul( - 4.5282e+09 ).exp() );\n\n\tlet xyz = val.mul( VAR.mul( 2.0 * Math.PI ).sqrt() ).mul( pos.mul( phase ).add( shift ).cos() ).mul( phase.pow2().negate().mul( VAR ).exp() );\n\txyz = vec3( xyz.x.add( x ), xyz.y, xyz.z ).div( 1.0685e-7 );\n\n\tconst rgb = XYZ_TO_REC709.mul( xyz );\n\n\treturn rgb;\n\n};\n\nconst evalIridescence = /*@__PURE__*/ Fn( ( { outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 } ) => {\n\n\t// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\n\tconst iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t// Evaluate the cosTheta on the base layer (Snell law)\n\tconst sinTheta2Sq = outsideIOR.div( iridescenceIOR ).pow2().mul( cosTheta1.pow2().oneMinus() );\n\n\t// Handle TIR:\n\tconst cosTheta2Sq = sinTheta2Sq.oneMinus();\n\n\tIf( cosTheta2Sq.lessThan( 0 ), () => {\n\n\t\treturn vec3( 1.0 );\n\n\t} );\n\n\tconst cosTheta2 = cosTheta2Sq.sqrt();\n\n\t// First interface\n\tconst R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\tconst R12 = F_Schlick( { f0: R0, f90: 1.0, dotVH: cosTheta1 } );\n\t//const R21 = R12;\n\tconst T121 = R12.oneMinus();\n\tconst phi12 = iridescenceIOR.lessThan( outsideIOR ).select( Math.PI, 0.0 );\n\tconst phi21 = float( Math.PI ).sub( phi12 );\n\n\t// Second interface\n\tconst baseIOR = Fresnel0ToIor( baseF0.clamp( 0.0, 0.9999 ) ); // guard against 1.0\n\tconst R1 = IorToFresnel0( baseIOR, iridescenceIOR.toVec3() );\n\tconst R23 = F_Schlick( { f0: R1, f90: 1.0, dotVH: cosTheta2 } );\n\tconst phi23 = vec3(\n\t\tbaseIOR.x.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),\n\t\tbaseIOR.y.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),\n\t\tbaseIOR.z.lessThan( iridescenceIOR ).select( Math.PI, 0.0 )\n\t);\n\n\t// Phase shift\n\tconst OPD = iridescenceIOR.mul( thinFilmThickness, cosTheta2, 2.0 );\n\tconst phi = vec3( phi21 ).add( phi23 );\n\n\t// Compound terms\n\tconst R123 = R12.mul( R23 ).clamp( 1e-5, 0.9999 );\n\tconst r123 = R123.sqrt();\n\tconst Rs = T121.pow2().mul( R23 ).div( vec3( 1.0 ).sub( R123 ) );\n\n\t// Reflectance term for m = 0 (DC term amplitude)\n\tconst C0 = R12.add( Rs );\n\tconst I = C0.toVar();\n\n\t// Reflectance term for m > 0 (pairs of diracs)\n\tconst Cm = Rs.sub( T121 ).toVar();\n\n\tLoop( { start: 1, end: 2, condition: '<=', name: 'm' }, ( { m } ) => {\n\n\t\tCm.mulAssign( r123 );\n\t\tconst Sm = evalSensitivity( float( m ).mul( OPD ), float( m ).mul( phi ) ).mul( 2.0 );\n\t\tI.addAssign( Cm.mul( Sm ) );\n\n\t} );\n\n\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\treturn I.max( vec3( 0.0 ) );\n\n} ).setLayout( {\n\tname: 'evalIridescence',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'outsideIOR', type: 'float' },\n\t\t{ name: 'eta2', type: 'float' },\n\t\t{ name: 'cosTheta1', type: 'float' },\n\t\t{ name: 'thinFilmThickness', type: 'float' },\n\t\t{ name: 'baseF0', type: 'vec3' }\n\t]\n} );\n\n//\n//\tSheen\n//\n\n// This is a curve-fit approxmation to the \"Charlie sheen\" BRDF integrated over the hemisphere from\n// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\". The analysis can be found\n// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nconst IBLSheenBRDF = /*@__PURE__*/ Fn( ( { normal, viewDir, roughness } ) => {\n\n\tconst dotNV = normal.dot( viewDir ).saturate();\n\n\tconst r2 = roughness.pow2();\n\n\tconst a = select(\n\t\troughness.lessThan( 0.25 ),\n\t\tfloat( - 339.2 ).mul( r2 ).add( float( 161.4 ).mul( roughness ) ).sub( 25.9 ),\n\t\tfloat( - 8.48 ).mul( r2 ).add( float( 14.3 ).mul( roughness ) ).sub( 9.95 )\n\t);\n\n\tconst b = select(\n\t\troughness.lessThan( 0.25 ),\n\t\tfloat( 44.0 ).mul( r2 ).sub( float( 23.7 ).mul( roughness ) ).add( 3.26 ),\n\t\tfloat( 1.97 ).mul( r2 ).sub( float( 3.27 ).mul( roughness ) ).add( 0.72 )\n\t);\n\n\tconst DG = select( roughness.lessThan( 0.25 ), 0.0, float( 0.1 ).mul( roughness ).sub( 0.025 ) ).add( a.mul( dotNV ).add( b ).exp() );\n\n\treturn DG.mul( 1.0 / Math.PI ).saturate();\n\n} );\n\nconst clearcoatF0 = vec3( 0.04 );\nconst clearcoatF90 = float( 1 );\n\n//\n\nclass PhysicalLightingModel extends LightingModel {\n\n\tconstructor( clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false ) {\n\n\t\tsuper();\n\n\t\tthis.clearcoat = clearcoat;\n\t\tthis.sheen = sheen;\n\t\tthis.iridescence = iridescence;\n\t\tthis.anisotropy = anisotropy;\n\t\tthis.transmission = transmission;\n\t\tthis.dispersion = dispersion;\n\n\t\tthis.clearcoatRadiance = null;\n\t\tthis.clearcoatSpecularDirect = null;\n\t\tthis.clearcoatSpecularIndirect = null;\n\t\tthis.sheenSpecularDirect = null;\n\t\tthis.sheenSpecularIndirect = null;\n\t\tthis.iridescenceFresnel = null;\n\t\tthis.iridescenceF0 = null;\n\n\t}\n\n\tstart( context ) {\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tthis.clearcoatRadiance = vec3().toVar( 'clearcoatRadiance' );\n\t\t\tthis.clearcoatSpecularDirect = vec3().toVar( 'clearcoatSpecularDirect' );\n\t\t\tthis.clearcoatSpecularIndirect = vec3().toVar( 'clearcoatSpecularIndirect' );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularDirect = vec3().toVar( 'sheenSpecularDirect' );\n\t\t\tthis.sheenSpecularIndirect = vec3().toVar( 'sheenSpecularIndirect' );\n\n\t\t}\n\n\t\tif ( this.iridescence === true ) {\n\n\t\t\tconst dotNVi = transformedNormalView.dot( positionViewDirection ).clamp();\n\n\t\t\tthis.iridescenceFresnel = evalIridescence( {\n\t\t\t\toutsideIOR: float( 1.0 ),\n\t\t\t\teta2: iridescenceIOR,\n\t\t\t\tcosTheta1: dotNVi,\n\t\t\t\tthinFilmThickness: iridescenceThickness,\n\t\t\t\tbaseF0: specularColor\n\t\t\t} );\n\n\t\t\tthis.iridescenceF0 = Schlick_to_F0( { f: this.iridescenceFresnel, f90: 1.0, dotVH: dotNVi } );\n\n\t\t}\n\n\t\tif ( this.transmission === true ) {\n\n\t\t\tconst position = positionWorld;\n\t\t\tconst v = cameraPosition.sub( positionWorld ).normalize(); // TODO: Create Node for this, same issue in MaterialX\n\t\t\tconst n = transformedNormalWorld;\n\n\t\t\tcontext.backdrop = getIBLVolumeRefraction(\n\t\t\t\tn,\n\t\t\t\tv,\n\t\t\t\troughness,\n\t\t\t\tdiffuseColor,\n\t\t\t\tspecularColor,\n\t\t\t\tspecularF90, // specularF90\n\t\t\t\tposition, // positionWorld\n\t\t\t\tmodelWorldMatrix, // modelMatrix\n\t\t\t\tcameraViewMatrix, // viewMatrix\n\t\t\t\tcameraProjectionMatrix, // projMatrix\n\t\t\t\tior,\n\t\t\t\tthickness,\n\t\t\t\tattenuationColor,\n\t\t\t\tattenuationDistance,\n\t\t\t\tthis.dispersion ? dispersion : null\n\t\t\t);\n\n\t\t\tcontext.backdropAlpha = transmission;\n\n\t\t\tdiffuseColor.a.mulAssign( mix( 1, context.backdrop.a, transmission ) );\n\n\t\t}\n\n\t}\n\n\t// Fdez-Agüera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n\t// Approximates multiscattering in order to preserve energy.\n\t// http://www.jcgt.org/published/0008/01/03/\n\n\tcomputeMultiscattering( singleScatter, multiScatter, specularF90 ) {\n\n\t\tconst dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\n\t\tconst fab = DFGApprox( { roughness, dotNV } );\n\n\t\tconst Fr = this.iridescenceF0 ? iridescence.mix( specularColor, this.iridescenceF0 ) : specularColor;\n\n\t\tconst FssEss = Fr.mul( fab.x ).add( specularF90.mul( fab.y ) );\n\n\t\tconst Ess = fab.x.add( fab.y );\n\t\tconst Ems = Ess.oneMinus();\n\n\t\tconst Favg = specularColor.add( specularColor.oneMinus().mul( 0.047619 ) ); // 1/21\n\t\tconst Fms = FssEss.mul( Favg ).div( Ems.mul( Favg ).oneMinus() );\n\n\t\tsingleScatter.addAssign( FssEss );\n\t\tmultiScatter.addAssign( Fms.mul( Ems ) );\n\n\t}\n\n\tdirect( { lightDirection, lightColor, reflectedLight } ) {\n\n\t\tconst dotNL = transformedNormalView.dot( lightDirection ).clamp();\n\t\tconst irradiance = dotNL.mul( lightColor );\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularDirect.addAssign( irradiance.mul( BRDF_Sheen( { lightDirection } ) ) );\n\n\t\t}\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNLcc = transformedClearcoatNormalView.dot( lightDirection ).clamp();\n\t\t\tconst ccIrradiance = dotNLcc.mul( lightColor );\n\n\t\t\tthis.clearcoatSpecularDirect.addAssign( ccIrradiance.mul( BRDF_GGX( { lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: transformedClearcoatNormalView } ) ) );\n\n\t\t}\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t\treflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_GGX( { lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy } ) ) );\n\n\t}\n\n\tdirectRectArea( { lightColor, lightPosition, halfWidth, halfHeight, reflectedLight, ltc_1, ltc_2 } ) {\n\n\t\tconst p0 = lightPosition.add( halfWidth ).sub( halfHeight ); // counterclockwise; light shines in local neg z direction\n\t\tconst p1 = lightPosition.sub( halfWidth ).sub( halfHeight );\n\t\tconst p2 = lightPosition.sub( halfWidth ).add( halfHeight );\n\t\tconst p3 = lightPosition.add( halfWidth ).add( halfHeight );\n\n\t\tconst N = transformedNormalView;\n\t\tconst V = positionViewDirection;\n\t\tconst P = positionView.toVar();\n\n\t\tconst uv = LTC_Uv( { N, V, roughness } );\n\n\t\tconst t1 = ltc_1.uv( uv ).toVar();\n\t\tconst t2 = ltc_2.uv( uv ).toVar();\n\n\t\tconst mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3( 0, 1, 0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t).toVar();\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tconst fresnel = specularColor.mul( t2.x ).add( specularColor.oneMinus().mul( t2.y ) ).toVar();\n\n\t\treflectedLight.directSpecular.addAssign( lightColor.mul( fresnel ).mul( LTC_Evaluate( { N, V, P, mInv, p0, p1, p2, p3 } ) ) );\n\n\t\treflectedLight.directDiffuse.addAssign( lightColor.mul( diffuseColor ).mul( LTC_Evaluate( { N, V, P, mInv: mat3( 1, 0, 0, 0, 1, 0, 0, 0, 1 ), p0, p1, p2, p3 } ) ) );\n\n\t}\n\n\tindirect( context, stack, builder ) {\n\n\t\tthis.indirectDiffuse( context, stack, builder );\n\t\tthis.indirectSpecular( context, stack, builder );\n\t\tthis.ambientOcclusion( context, stack, builder );\n\n\t}\n\n\tindirectDiffuse( { irradiance, reflectedLight } ) {\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t}\n\n\tindirectSpecular( { radiance, iblIrradiance, reflectedLight } ) {\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularIndirect.addAssign( iblIrradiance.mul(\n\t\t\t\tsheen,\n\t\t\t\tIBLSheenBRDF( {\n\t\t\t\t\tnormal: transformedNormalView,\n\t\t\t\t\tviewDir: positionViewDirection,\n\t\t\t\t\troughness: sheenRoughness\n\t\t\t\t} )\n\t\t\t) );\n\n\t\t}\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();\n\n\t\t\tconst clearcoatEnv = EnvironmentBRDF( {\n\t\t\t\tdotNV: dotNVcc,\n\t\t\t\tspecularColor: clearcoatF0,\n\t\t\t\tspecularF90: clearcoatF90,\n\t\t\t\troughness: clearcoatRoughness\n\t\t\t} );\n\n\t\t\tthis.clearcoatSpecularIndirect.addAssign( this.clearcoatRadiance.mul( clearcoatEnv ) );\n\n\t\t}\n\n\t\t// Both indirect specular and indirect diffuse light accumulate here\n\n\t\tconst singleScattering = vec3().toVar( 'singleScattering' );\n\t\tconst multiScattering = vec3().toVar( 'multiScattering' );\n\t\tconst cosineWeightedIrradiance = iblIrradiance.mul( 1 / Math.PI );\n\n\t\tthis.computeMultiscattering( singleScattering, multiScattering, specularF90 );\n\n\t\tconst totalScattering = singleScattering.add( multiScattering );\n\n\t\tconst diffuse = diffuseColor.mul( totalScattering.r.max( totalScattering.g ).max( totalScattering.b ).oneMinus() );\n\n\t\treflectedLight.indirectSpecular.addAssign( radiance.mul( singleScattering ) );\n\t\treflectedLight.indirectSpecular.addAssign( multiScattering.mul( cosineWeightedIrradiance ) );\n\n\t\treflectedLight.indirectDiffuse.addAssign( diffuse.mul( cosineWeightedIrradiance ) );\n\n\t}\n\n\tambientOcclusion( { ambientOcclusion, reflectedLight } ) {\n\n\t\tconst dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\n\t\tconst aoNV = dotNV.add( ambientOcclusion );\n\t\tconst aoExp = roughness.mul( - 16.0 ).oneMinus().negate().exp2();\n\n\t\tconst aoNode = ambientOcclusion.sub( aoNV.pow( aoExp ).oneMinus() ).clamp();\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tthis.clearcoatSpecularIndirect.mulAssign( ambientOcclusion );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularIndirect.mulAssign( ambientOcclusion );\n\n\t\t}\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\t\treflectedLight.indirectSpecular.mulAssign( aoNode );\n\n\t}\n\n\tfinish( context ) {\n\n\t\tconst { outgoingLight } = context;\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();\n\n\t\t\tconst Fcc = F_Schlick( {\n\t\t\t\tdotVH: dotNVcc,\n\t\t\t\tf0: clearcoatF0,\n\t\t\t\tf90: clearcoatF90\n\t\t\t} );\n\n\t\t\tconst clearcoatLight = outgoingLight.mul( clearcoat.mul( Fcc ).oneMinus() ).add( this.clearcoatSpecularDirect.add( this.clearcoatSpecularIndirect ).mul( clearcoat ) );\n\n\t\t\toutgoingLight.assign( clearcoatLight );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tconst sheenEnergyComp = sheen.r.max( sheen.g ).max( sheen.b ).mul( 0.157 ).oneMinus();\n\t\t\tconst sheenLight = outgoingLight.mul( sheenEnergyComp ).add( this.sheenSpecularDirect, this.sheenSpecularIndirect );\n\n\t\t\toutgoingLight.assign( sheenLight );\n\n\t\t}\n\n\t}\n\n}\n\n// These defines must match with PMREMGenerator\n\nconst cubeUV_r0 = /*@__PURE__*/ float( 1.0 );\nconst cubeUV_m0 = /*@__PURE__*/ float( - 2.0 );\nconst cubeUV_r1 = /*@__PURE__*/ float( 0.8 );\nconst cubeUV_m1 = /*@__PURE__*/ float( - 1.0 );\nconst cubeUV_r4 = /*@__PURE__*/ float( 0.4 );\nconst cubeUV_m4 = /*@__PURE__*/ float( 2.0 );\nconst cubeUV_r5 = /*@__PURE__*/ float( 0.305 );\nconst cubeUV_m5 = /*@__PURE__*/ float( 3.0 );\nconst cubeUV_r6 = /*@__PURE__*/ float( 0.21 );\nconst cubeUV_m6 = /*@__PURE__*/ float( 4.0 );\n\nconst cubeUV_minMipLevel = /*@__PURE__*/ float( 4.0 );\nconst cubeUV_minTileSize = /*@__PURE__*/ float( 16.0 );\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized ).\n\nconst getFace = /*@__PURE__*/ Fn( ( [ direction ] ) => {\n\n\tconst absDirection = vec3( abs( direction ) ).toVar();\n\tconst face = float( - 1.0 ).toVar();\n\n\tIf( absDirection.x.greaterThan( absDirection.z ), () => {\n\n\t\tIf( absDirection.x.greaterThan( absDirection.y ), () => {\n\n\t\t\tface.assign( select( direction.x.greaterThan( 0.0 ), 0.0, 3.0 ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tface.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );\n\n\t\t} );\n\n\t} ).Else( () => {\n\n\t\tIf( absDirection.z.greaterThan( absDirection.y ), () => {\n\n\t\t\tface.assign( select( direction.z.greaterThan( 0.0 ), 2.0, 5.0 ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tface.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );\n\n\t\t} );\n\n\t} );\n\n\treturn face;\n\n} ).setLayout( {\n\tname: 'getFace',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'direction', type: 'vec3' }\n\t]\n} );\n\n// RH coordinate system; PMREM face-indexing convention\nconst getUV = /*@__PURE__*/ Fn( ( [ direction, face ] ) => {\n\n\tconst uv = vec2().toVar();\n\n\tIf( face.equal( 0.0 ), () => {\n\n\t\tuv.assign( vec2( direction.z, direction.y ).div( abs( direction.x ) ) ); // pos x\n\n\t} ).ElseIf( face.equal( 1.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.z.negate() ).div( abs( direction.y ) ) ); // pos y\n\n\t} ).ElseIf( face.equal( 2.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.y ).div( abs( direction.z ) ) ); // pos z\n\n\t} ).ElseIf( face.equal( 3.0 ), () => {\n\n\t\tuv.assign( vec2( direction.z.negate(), direction.y ).div( abs( direction.x ) ) ); // neg x\n\n\t} ).ElseIf( face.equal( 4.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.z ).div( abs( direction.y ) ) ); // neg y\n\n\t} ).Else( () => {\n\n\t\tuv.assign( vec2( direction.x, direction.y ).div( abs( direction.z ) ) ); // neg z\n\n\t} );\n\n\treturn mul( 0.5, uv.add( 1.0 ) );\n\n} ).setLayout( {\n\tname: 'getUV',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'direction', type: 'vec3' },\n\t\t{ name: 'face', type: 'float' }\n\t]\n} );\n\nconst roughnessToMip = /*@__PURE__*/ Fn( ( [ roughness ] ) => {\n\n\tconst mip = float( 0.0 ).toVar();\n\n\tIf( roughness.greaterThanEqual( cubeUV_r1 ), () => {\n\n\t\tmip.assign( cubeUV_r0.sub( roughness ).mul( cubeUV_m1.sub( cubeUV_m0 ) ).div( cubeUV_r0.sub( cubeUV_r1 ) ).add( cubeUV_m0 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r4 ), () => {\n\n\t\tmip.assign( cubeUV_r1.sub( roughness ).mul( cubeUV_m4.sub( cubeUV_m1 ) ).div( cubeUV_r1.sub( cubeUV_r4 ) ).add( cubeUV_m1 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r5 ), () => {\n\n\t\tmip.assign( cubeUV_r4.sub( roughness ).mul( cubeUV_m5.sub( cubeUV_m4 ) ).div( cubeUV_r4.sub( cubeUV_r5 ) ).add( cubeUV_m4 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r6 ), () => {\n\n\t\tmip.assign( cubeUV_r5.sub( roughness ).mul( cubeUV_m6.sub( cubeUV_m5 ) ).div( cubeUV_r5.sub( cubeUV_r6 ) ).add( cubeUV_m5 ) );\n\n\t} ).Else( () => {\n\n\t\tmip.assign( float( - 2.0 ).mul( log2( mul( 1.16, roughness ) ) ) ); // 1.16 = 1.79^0.25\n\n\t} );\n\n\treturn mip;\n\n} ).setLayout( {\n\tname: 'roughnessToMip',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' }\n\t]\n} );\n\n// RH coordinate system; PMREM face-indexing convention\nconst getDirection = /*@__PURE__*/ Fn( ( [ uv_immutable, face ] ) => {\n\n\tconst uv = uv_immutable.toVar();\n\tuv.assign( mul( 2.0, uv ).sub( 1.0 ) );\n\tconst direction = vec3( uv, 1.0 ).toVar();\n\n\tIf( face.equal( 0.0 ), () => {\n\n\t\tdirection.assign( direction.zyx ); // ( 1, v, u ) pos x\n\n\t} ).ElseIf( face.equal( 1.0 ), () => {\n\n\t\tdirection.assign( direction.xzy );\n\t\tdirection.xz.mulAssign( - 1.0 ); // ( -u, 1, -v ) pos y\n\n\t} ).ElseIf( face.equal( 2.0 ), () => {\n\n\t\tdirection.x.mulAssign( - 1.0 ); // ( -u, v, 1 ) pos z\n\n\t} ).ElseIf( face.equal( 3.0 ), () => {\n\n\t\tdirection.assign( direction.zyx );\n\t\tdirection.xz.mulAssign( - 1.0 ); // ( -1, v, -u ) neg x\n\n\t} ).ElseIf( face.equal( 4.0 ), () => {\n\n\t\tdirection.assign( direction.xzy );\n\t\tdirection.xy.mulAssign( - 1.0 ); // ( -u, -1, v ) neg y\n\n\t} ).ElseIf( face.equal( 5.0 ), () => {\n\n\t\tdirection.z.mulAssign( - 1.0 ); // ( u, v, -1 ) neg zS\n\n\t} );\n\n\treturn direction;\n\n} ).setLayout( {\n\tname: 'getDirection',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'uv', type: 'vec2' },\n\t\t{ name: 'face', type: 'float' }\n\t]\n} );\n\n//\n\nconst textureCubeUV = /*@__PURE__*/ Fn( ( [ envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {\n\n\tconst roughness = float( roughness_immutable );\n\tconst sampleDir = vec3( sampleDir_immutable );\n\n\tconst mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\tconst mipF = fract( mip );\n\tconst mipInt = floor( mip );\n\tconst color0 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();\n\n\tIf( mipF.notEqual( 0.0 ), () => {\n\n\t\tconst color1 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt.add( 1.0 ), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();\n\n\t\tcolor0.assign( mix( color0, color1, mipF ) );\n\n\t} );\n\n\treturn color0;\n\n} );\n\nconst bilinearCubeUV = /*@__PURE__*/ Fn( ( [ envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {\n\n\tconst mipInt = float( mipInt_immutable ).toVar();\n\tconst direction = vec3( direction_immutable );\n\tconst face = float( getFace( direction ) ).toVar();\n\tconst filterInt = float( max$1( cubeUV_minMipLevel.sub( mipInt ), 0.0 ) ).toVar();\n\tmipInt.assign( max$1( mipInt, cubeUV_minMipLevel ) );\n\tconst faceSize = float( exp2( mipInt ) ).toVar();\n\tconst uv = vec2( getUV( direction, face ).mul( faceSize.sub( 2.0 ) ).add( 1.0 ) ).toVar();\n\n\tIf( face.greaterThan( 2.0 ), () => {\n\n\t\tuv.y.addAssign( faceSize );\n\t\tface.subAssign( 3.0 );\n\n\t} );\n\n\tuv.x.addAssign( face.mul( faceSize ) );\n\tuv.x.addAssign( filterInt.mul( mul( 3.0, cubeUV_minTileSize ) ) );\n\tuv.y.addAssign( mul( 4.0, exp2( CUBEUV_MAX_MIP ).sub( faceSize ) ) );\n\tuv.x.mulAssign( CUBEUV_TEXEL_WIDTH );\n\tuv.y.mulAssign( CUBEUV_TEXEL_HEIGHT );\n\n\treturn envMap.uv( uv ).grad( vec2(), vec2() ); // disable anisotropic filtering\n\n} );\n\nconst getSample = /*@__PURE__*/ Fn( ( { envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst cosTheta = cos( theta );\n\n\t// Rodrigues' axis-angle rotation\n\tconst sampleDirection = outputDirection.mul( cosTheta )\n\t\t.add( axis.cross( outputDirection ).mul( sin( theta ) ) )\n\t\t.add( axis.mul( axis.dot( outputDirection ).mul( cosTheta.oneMinus() ) ) );\n\n\treturn bilinearCubeUV( envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP );\n\n} );\n\nconst blur = /*@__PURE__*/ Fn( ( { n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst axis = vec3( select( latitudinal, poleAxis, cross( poleAxis, outputDirection ) ) ).toVar();\n\n\tIf( all( axis.equals( vec3( 0.0 ) ) ), () => {\n\n\t\taxis.assign( vec3( outputDirection.z, 0.0, outputDirection.x.negate() ) );\n\n\t} );\n\n\taxis.assign( normalize( axis ) );\n\n\tconst gl_FragColor = vec3().toVar();\n\tgl_FragColor.addAssign( weights.element( int( 0 ) ).mul( getSample( { theta: 0.0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\n\tLoop( { start: int( 1 ), end: n }, ( { i } ) => {\n\n\t\tIf( i.greaterThanEqual( samples ), () => {\n\n\t\t\tBreak();\n\n\t\t} );\n\n\t\tconst theta = float( dTheta.mul( float( i ) ) ).toVar();\n\t\tgl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta: theta.mul( - 1.0 ), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\t\tgl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\n\t} );\n\n\treturn vec4( gl_FragColor, 1 );\n\n} );\n\nlet _generator = null;\n\nconst _cache = new WeakMap();\n\nfunction _generateCubeUVSize( imageHeight ) {\n\n\tconst maxMip = Math.log2( imageHeight ) - 2;\n\n\tconst texelHeight = 1.0 / imageHeight;\n\n\tconst texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );\n\n\treturn { texelWidth, texelHeight, maxMip };\n\n}\n\nfunction _getPMREMFromTexture( texture ) {\n\n\tlet cacheTexture = _cache.get( texture );\n\n\tconst pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : - 1;\n\n\tif ( pmremVersion !== texture.pmremVersion ) {\n\n\t\tconst image = texture.image;\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tif ( isCubeMapReady( image ) ) {\n\n\t\t\t\tcacheTexture = _generator.fromCubemap( texture, cacheTexture );\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\tif ( isEquirectangularMapReady( image ) ) {\n\n\t\t\t\tcacheTexture = _generator.fromEquirectangular( texture, cacheTexture );\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcacheTexture.pmremVersion = texture.pmremVersion;\n\n\t\t_cache.set( texture, cacheTexture );\n\n\t}\n\n\treturn cacheTexture.texture;\n\n}\n\nclass PMREMNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PMREMNode';\n\n\t}\n\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis._value = value;\n\t\tthis._pmrem = null;\n\n\t\tthis.uvNode = uvNode;\n\t\tthis.levelNode = levelNode;\n\n\t\tthis._generator = null;\n\n\t\tconst defaultTexture = new Texture();\n\t\tdefaultTexture.isRenderTargetTexture = true;\n\n\t\tthis._texture = texture( defaultTexture );\n\n\t\tthis._width = uniform( 0 );\n\t\tthis._height = uniform( 0 );\n\t\tthis._maxMip = uniform( 0 );\n\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tset value( value ) {\n\n\t\tthis._value = value;\n\t\tthis._pmrem = null;\n\n\t}\n\n\tget value() {\n\n\t\treturn this._value;\n\n\t}\n\n\tupdateFromTexture( texture ) {\n\n\t\tconst cubeUVSize = _generateCubeUVSize( texture.image.height );\n\n\t\tthis._texture.value = texture;\n\t\tthis._width.value = cubeUVSize.texelWidth;\n\t\tthis._height.value = cubeUVSize.texelHeight;\n\t\tthis._maxMip.value = cubeUVSize.maxMip;\n\n\t}\n\n\tupdateBefore() {\n\n\t\tlet pmrem = this._pmrem;\n\n\t\tconst pmremVersion = pmrem ? pmrem.pmremVersion : - 1;\n\t\tconst texture = this._value;\n\n\t\tif ( pmremVersion !== texture.pmremVersion ) {\n\n\t\t\tif ( texture.isPMREMTexture === true ) {\n\n\t\t\t\tpmrem = texture;\n\n\t\t\t} else {\n\n\t\t\t\tpmrem = _getPMREMFromTexture( texture );\n\n\t\t\t}\n\n\t\t\tif ( pmrem !== null ) {\n\n\t\t\t\tthis._pmrem = pmrem;\n\n\t\t\t\tthis.updateFromTexture( pmrem );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( _generator === null ) {\n\n\t\t\t_generator = builder.createPMREMGenerator();\n\n\t\t}\n\n\t\t//\n\n\t\tthis.updateBefore( builder );\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( uvNode === null && builder.context.getUV ) {\n\n\t\t\tuvNode = builder.context.getUV( this );\n\n\t\t}\n\n\t\t//\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.renderer.coordinateSystem === WebGLCoordinateSystem && texture.isPMREMTexture !== true && texture.isRenderTargetTexture === true ) {\n\n\t\t\tuvNode = vec3( uvNode.x.negate(), uvNode.yz );\n\n\t\t}\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\t//\n\n\t\treturn textureCubeUV( this._texture, uvNode, levelNode, this._width, this._height, this._maxMip );\n\n\t}\n\n}\n\nfunction isCubeMapReady( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\tlet count = 0;\n\tconst length = 6;\n\n\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\tif ( image[ i ] !== undefined ) count ++;\n\n\t}\n\n\treturn count === length;\n\n\n}\n\nfunction isEquirectangularMapReady( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\treturn image.height > 0;\n\n}\n\nconst pmremTexture = /*@__PURE__*/ nodeProxy( PMREMNode );\n\nconst _envNodeCache = new WeakMap();\n\nclass EnvironmentNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'EnvironmentNode';\n\n\t}\n\n\tconstructor( envNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.envNode = envNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { material } = builder;\n\n\t\tlet envNode = this.envNode;\n\n\t\tif ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {\n\n\t\t\tconst value = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];\n\n\t\t\tlet cacheEnvNode = _envNodeCache.get( value );\n\n\t\t\tif ( cacheEnvNode === undefined ) {\n\n\t\t\t\tcacheEnvNode = pmremTexture( value );\n\n\t\t\t\t_envNodeCache.set( value, cacheEnvNode );\n\n\t\t\t}\n\n\t\t\tenvNode\t= cacheEnvNode;\n\n\t\t}\n\n\t\t//\n\n\t\tconst envMap = material.envMap;\n\t\tconst intensity = envMap ? reference( 'envMapIntensity', 'float', builder.material ) : reference( 'environmentIntensity', 'float', builder.scene ); // @TODO: Add materialEnvIntensity in MaterialNode\n\n\t\tconst useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;\n\t\tconst radianceNormalView = useAnisotropy ? transformedBentNormalView : transformedNormalView;\n\n\t\tconst radiance = envNode.context( createRadianceContext( roughness, radianceNormalView ) ).mul( intensity );\n\t\tconst irradiance = envNode.context( createIrradianceContext( transformedNormalWorld ) ).mul( Math.PI ).mul( intensity );\n\n\t\tconst isolateRadiance = cache( radiance );\n\t\tconst isolateIrradiance = cache( irradiance );\n\n\t\t//\n\n\t\tbuilder.context.radiance.addAssign( isolateRadiance );\n\n\t\tbuilder.context.iblIrradiance.addAssign( isolateIrradiance );\n\n\t\t//\n\n\t\tconst clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;\n\n\t\tif ( clearcoatRadiance ) {\n\n\t\t\tconst clearcoatRadianceContext = envNode.context( createRadianceContext( clearcoatRoughness, transformedClearcoatNormalView ) ).mul( intensity );\n\t\t\tconst isolateClearcoatRadiance = cache( clearcoatRadianceContext );\n\n\t\t\tclearcoatRadiance.addAssign( isolateClearcoatRadiance );\n\n\t\t}\n\n\t}\n\n}\n\nconst createRadianceContext = ( roughnessNode, normalViewNode ) => {\n\n\tlet reflectVec = null;\n\n\treturn {\n\t\tgetUV: () => {\n\n\t\t\tif ( reflectVec === null ) {\n\n\t\t\t\treflectVec = positionViewDirection.negate().reflect( normalViewNode );\n\n\t\t\t\t// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n\t\t\t\treflectVec = roughnessNode.mul( roughnessNode ).mix( reflectVec, normalViewNode ).normalize();\n\n\t\t\t\treflectVec = reflectVec.transformDirection( cameraViewMatrix );\n\n\t\t\t}\n\n\t\t\treturn reflectVec;\n\n\t\t},\n\t\tgetTextureLevel: () => {\n\n\t\t\treturn roughnessNode;\n\n\t\t}\n\t};\n\n};\n\nconst createIrradianceContext = ( normalWorldNode ) => {\n\n\treturn {\n\t\tgetUV: () => {\n\n\t\t\treturn normalWorldNode;\n\n\t\t},\n\t\tgetTextureLevel: () => {\n\n\t\t\treturn float( 1.0 );\n\n\t\t}\n\t};\n\n};\n\nconst _defaultValues$6 = /*@__PURE__*/ new MeshStandardMaterial();\n\nclass MeshStandardNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshStandardNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshStandardNodeMaterial = true;\n\n\t\tthis.lights = true;\n\n\t\tthis.emissiveNode = null;\n\n\t\tthis.metalnessNode = null;\n\t\tthis.roughnessNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$6 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupEnvironment( builder ) {\n\n\t\tlet envNode = super.setupEnvironment( builder );\n\n\t\tif ( envNode === null && builder.environmentNode ) {\n\n\t\t\tenvNode = builder.environmentNode;\n\n\t\t}\n\n\t\treturn envNode ? new EnvironmentNode( envNode ) : null;\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhysicalLightingModel();\n\n\t}\n\n\tsetupSpecular() {\n\n\t\tconst specularColorNode = mix( vec3( 0.04 ), diffuseColor.rgb, metalness );\n\n\t\tspecularColor.assign( specularColorNode );\n\t\tspecularF90.assign( 1.0 );\n\n\t}\n\n\tsetupVariants() {\n\n\t\t// METALNESS\n\n\t\tconst metalnessNode = this.metalnessNode ? float( this.metalnessNode ) : materialMetalness;\n\n\t\tmetalness.assign( metalnessNode );\n\n\t\t// ROUGHNESS\n\n\t\tlet roughnessNode = this.roughnessNode ? float( this.roughnessNode ) : materialRoughness;\n\t\troughnessNode = getRoughness( { roughness: roughnessNode } );\n\n\t\troughness.assign( roughnessNode );\n\n\t\t// SPECULAR COLOR\n\n\t\tthis.setupSpecular();\n\n\t\t// DIFFUSE COLOR\n\n\t\tdiffuseColor.assign( vec4( diffuseColor.rgb.mul( metalnessNode.oneMinus() ), diffuseColor.a ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.emissiveNode = source.emissiveNode;\n\n\t\tthis.metalnessNode = source.metalnessNode;\n\t\tthis.roughnessNode = source.roughnessNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst _defaultValues$5 = /*@__PURE__*/ new MeshPhysicalMaterial();\n\nclass MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshPhysicalNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhysicalNodeMaterial = true;\n\n\t\tthis.clearcoatNode = null;\n\t\tthis.clearcoatRoughnessNode = null;\n\t\tthis.clearcoatNormalNode = null;\n\n\t\tthis.sheenNode = null;\n\t\tthis.sheenRoughnessNode = null;\n\n\t\tthis.iridescenceNode = null;\n\t\tthis.iridescenceIORNode = null;\n\t\tthis.iridescenceThicknessNode = null;\n\n\t\tthis.specularIntensityNode = null;\n\t\tthis.specularColorNode = null;\n\n\t\tthis.iorNode = null;\n\t\tthis.transmissionNode = null;\n\t\tthis.thicknessNode = null;\n\t\tthis.attenuationDistanceNode = null;\n\t\tthis.attenuationColorNode = null;\n\t\tthis.dispersionNode = null;\n\n\t\tthis.anisotropyNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$5 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget useClearcoat() {\n\n\t\treturn this.clearcoat > 0 || this.clearcoatNode !== null;\n\n\t}\n\n\tget useIridescence() {\n\n\t\treturn this.iridescence > 0 || this.iridescenceNode !== null;\n\n\t}\n\n\tget useSheen() {\n\n\t\treturn this.sheen > 0 || this.sheenNode !== null;\n\n\t}\n\n\tget useAnisotropy() {\n\n\t\treturn this.anisotropy > 0 || this.anisotropyNode !== null;\n\n\t}\n\n\tget useTransmission() {\n\n\t\treturn this.transmission > 0 || this.transmissionNode !== null;\n\n\t}\n\n\tget useDispersion() {\n\n\t\treturn this.dispersion > 0 || this.dispersionNode !== null;\n\n\t}\n\n\tsetupSpecular() {\n\n\t\tconst iorNode = this.iorNode ? float( this.iorNode ) : materialIOR;\n\n\t\tior.assign( iorNode );\n\t\tspecularColor.assign( mix( min$1( pow2( ior.sub( 1.0 ).div( ior.add( 1.0 ) ) ).mul( materialSpecularColor ), vec3( 1.0 ) ).mul( materialSpecularIntensity ), diffuseColor.rgb, metalness ) );\n\t\tspecularF90.assign( mix( materialSpecularIntensity, 1.0, metalness ) );\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhysicalLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion );\n\n\t}\n\n\tsetupVariants( builder ) {\n\n\t\tsuper.setupVariants( builder );\n\n\t\t// CLEARCOAT\n\n\t\tif ( this.useClearcoat ) {\n\n\t\t\tconst clearcoatNode = this.clearcoatNode ? float( this.clearcoatNode ) : materialClearcoat;\n\t\t\tconst clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float( this.clearcoatRoughnessNode ) : materialClearcoatRoughness;\n\n\t\t\tclearcoat.assign( clearcoatNode );\n\t\t\tclearcoatRoughness.assign( getRoughness( { roughness: clearcoatRoughnessNode } ) );\n\n\t\t}\n\n\t\t// SHEEN\n\n\t\tif ( this.useSheen ) {\n\n\t\t\tconst sheenNode = this.sheenNode ? vec3( this.sheenNode ) : materialSheen;\n\t\t\tconst sheenRoughnessNode = this.sheenRoughnessNode ? float( this.sheenRoughnessNode ) : materialSheenRoughness;\n\n\t\t\tsheen.assign( sheenNode );\n\t\t\tsheenRoughness.assign( sheenRoughnessNode );\n\n\t\t}\n\n\t\t// IRIDESCENCE\n\n\t\tif ( this.useIridescence ) {\n\n\t\t\tconst iridescenceNode = this.iridescenceNode ? float( this.iridescenceNode ) : materialIridescence;\n\t\t\tconst iridescenceIORNode = this.iridescenceIORNode ? float( this.iridescenceIORNode ) : materialIridescenceIOR;\n\t\t\tconst iridescenceThicknessNode = this.iridescenceThicknessNode ? float( this.iridescenceThicknessNode ) : materialIridescenceThickness;\n\n\t\t\tiridescence.assign( iridescenceNode );\n\t\t\tiridescenceIOR.assign( iridescenceIORNode );\n\t\t\tiridescenceThickness.assign( iridescenceThicknessNode );\n\n\t\t}\n\n\t\t// ANISOTROPY\n\n\t\tif ( this.useAnisotropy ) {\n\n\t\t\tconst anisotropyV = ( this.anisotropyNode ? vec2( this.anisotropyNode ) : materialAnisotropy ).toVar();\n\n\t\t\tanisotropy.assign( anisotropyV.length() );\n\n\t\t\tIf( anisotropy.equal( 0.0 ), () => {\n\n\t\t\t\tanisotropyV.assign( vec2( 1.0, 0.0 ) );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tanisotropyV.divAssign( vec2( anisotropy ) );\n\t\t\t\tanisotropy.assign( anisotropy.saturate() );\n\n\t\t\t} );\n\n\t\t\t// Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.\n\t\t\talphaT.assign( anisotropy.pow2().mix( roughness.pow2(), 1.0 ) );\n\n\t\t\tanisotropyT.assign( TBNViewMatrix[ 0 ].mul( anisotropyV.x ).add( TBNViewMatrix[ 1 ].mul( anisotropyV.y ) ) );\n\t\t\tanisotropyB.assign( TBNViewMatrix[ 1 ].mul( anisotropyV.x ).sub( TBNViewMatrix[ 0 ].mul( anisotropyV.y ) ) );\n\n\t\t}\n\n\t\t// TRANSMISSION\n\n\t\tif ( this.useTransmission ) {\n\n\t\t\tconst transmissionNode = this.transmissionNode ? float( this.transmissionNode ) : materialTransmission;\n\t\t\tconst thicknessNode = this.thicknessNode ? float( this.thicknessNode ) : materialThickness;\n\t\t\tconst attenuationDistanceNode = this.attenuationDistanceNode ? float( this.attenuationDistanceNode ) : materialAttenuationDistance;\n\t\t\tconst attenuationColorNode = this.attenuationColorNode ? vec3( this.attenuationColorNode ) : materialAttenuationColor;\n\n\t\t\ttransmission.assign( transmissionNode );\n\t\t\tthickness.assign( thicknessNode );\n\t\t\tattenuationDistance.assign( attenuationDistanceNode );\n\t\t\tattenuationColor.assign( attenuationColorNode );\n\n\t\t\tif ( this.useDispersion ) {\n\n\t\t\t\tconst dispersionNode = this.dispersionNode ? float( this.dispersionNode ) : materialDispersion;\n\n\t\t\t\tdispersion.assign( dispersionNode );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetupClearcoatNormal() {\n\n\t\treturn this.clearcoatNormalNode ? vec3( this.clearcoatNormalNode ) : materialClearcoatNormal;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.setupClearcoatNormal = () => this.setupClearcoatNormal( builder );\n\n\t\tsuper.setup( builder );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.clearcoatNode = source.clearcoatNode;\n\t\tthis.clearcoatRoughnessNode = source.clearcoatRoughnessNode;\n\t\tthis.clearcoatNormalNode = source.clearcoatNormalNode;\n\n\t\tthis.sheenNode = source.sheenNode;\n\t\tthis.sheenRoughnessNode = source.sheenRoughnessNode;\n\n\t\tthis.iridescenceNode = source.iridescenceNode;\n\t\tthis.iridescenceIORNode = source.iridescenceIORNode;\n\t\tthis.iridescenceThicknessNode = source.iridescenceThicknessNode;\n\n\t\tthis.specularIntensityNode = source.specularIntensityNode;\n\t\tthis.specularColorNode = source.specularColorNode;\n\n\t\tthis.transmissionNode = source.transmissionNode;\n\t\tthis.thicknessNode = source.thicknessNode;\n\t\tthis.attenuationDistanceNode = source.attenuationDistanceNode;\n\t\tthis.attenuationColorNode = source.attenuationColorNode;\n\t\tthis.dispersionNode = source.dispersionNode;\n\n\t\tthis.anisotropyNode = source.anisotropyNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nclass SSSLightingModel extends PhysicalLightingModel {\n\n\tconstructor( useClearcoat, useSheen, useIridescence, useSSS ) {\n\n\t\tsuper( useClearcoat, useSheen, useIridescence );\n\n\t\tthis.useSSS = useSSS;\n\n\t}\n\n\tdirect( { lightDirection, lightColor, reflectedLight }, stack, builder ) {\n\n\t\tif ( this.useSSS === true ) {\n\n\t\t\tconst material = builder.material;\n\n\t\t\tconst { thicknessColorNode, thicknessDistortionNode, thicknessAmbientNode, thicknessAttenuationNode, thicknessPowerNode, thicknessScaleNode } = material;\n\n\t\t\tconst scatteringHalf = lightDirection.add( transformedNormalView.mul( thicknessDistortionNode ) ).normalize();\n\t\t\tconst scatteringDot = float( positionViewDirection.dot( scatteringHalf.negate() ).saturate().pow( thicknessPowerNode ).mul( thicknessScaleNode ) );\n\t\t\tconst scatteringIllu = vec3( scatteringDot.add( thicknessAmbientNode ).mul( thicknessColorNode ) );\n\n\t\t\treflectedLight.directDiffuse.addAssign( scatteringIllu.mul( thicknessAttenuationNode.mul( lightColor ) ) );\n\n\t\t}\n\n\t\tsuper.direct( { lightDirection, lightColor, reflectedLight }, stack, builder );\n\n\t}\n\n}\n\nclass MeshSSSNodeMaterial extends MeshPhysicalNodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshSSSNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper( parameters );\n\n\t\tthis.thicknessColorNode = null;\n\t\tthis.thicknessDistortionNode = float( 0.1 );\n\t\tthis.thicknessAmbientNode = float( 0.0 );\n\t\tthis.thicknessAttenuationNode = float( .1 );\n\t\tthis.thicknessPowerNode = float( 2.0 );\n\t\tthis.thicknessScaleNode = float( 10.0 );\n\n\t}\n\n\tget useSSS() {\n\n\t\treturn this.thicknessColorNode !== null;\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new SSSLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useSSS );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.thicknessColorNode = source.thicknessColorNode;\n\t\tthis.thicknessDistortionNode = source.thicknessDistortionNode;\n\t\tthis.thicknessAmbientNode = source.thicknessAmbientNode;\n\t\tthis.thicknessAttenuationNode = source.thicknessAttenuationNode;\n\t\tthis.thicknessPowerNode = source.thicknessPowerNode;\n\t\tthis.thicknessScaleNode = source.thicknessScaleNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst getGradientIrradiance = /*@__PURE__*/ Fn( ( { normal, lightDirection, builder } ) => {\n\n\t// dotNL will be from -1.0 to 1.0\n\tconst dotNL = normal.dot( lightDirection );\n\tconst coord = vec2( dotNL.mul( 0.5 ).add( 0.5 ), 0.0 );\n\n\tif ( builder.material.gradientMap ) {\n\n\t\tconst gradientMap = materialReference( 'gradientMap', 'texture' ).context( { getUV: () => coord } );\n\n\t\treturn vec3( gradientMap.r );\n\n\t} else {\n\n\t\tconst fw = coord.fwidth().mul( 0.5 );\n\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( float( 0.7 ).sub( fw.x ), float( 0.7 ).add( fw.x ), coord.x ) );\n\n\t}\n\n} );\n\nclass ToonLightingModel extends LightingModel {\n\n\tdirect( { lightDirection, lightColor, reflectedLight }, stack, builder ) {\n\n\t\tconst irradiance = getGradientIrradiance( { normal: normalGeometry, lightDirection, builder } ).mul( lightColor );\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t}\n\n\tindirect( { ambientOcclusion, irradiance, reflectedLight } ) {\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t}\n\n}\n\nconst _defaultValues$4 = /*@__PURE__*/ new MeshToonMaterial();\n\nclass MeshToonNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshToonNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshToonNodeMaterial = true;\n\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$4 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new ToonLightingModel();\n\n\t}\n\n}\n\nclass MatcapUVNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'MatcapUVNode';\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t}\n\n\tsetup() {\n\n\t\tconst x = vec3( positionViewDirection.z, 0, positionViewDirection.x.negate() ).normalize();\n\t\tconst y = positionViewDirection.cross( x );\n\n\t\treturn vec2( x.dot( transformedNormalView ), y.dot( transformedNormalView ) ).mul( 0.495 ).add( 0.5 ); // 0.495 to remove artifacts caused by undersized matcap disks\n\n\t}\n\n}\n\nconst matcapUV = /*@__PURE__*/ nodeImmutable( MatcapUVNode );\n\nconst _defaultValues$3 = /*@__PURE__*/ new MeshMatcapMaterial();\n\nclass MeshMatcapNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshMatcapNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.lights = false;\n\n\t\tthis.isMeshMatcapNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$3 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupVariants( builder ) {\n\n\t\tconst uv = matcapUV;\n\n\t\tlet matcapColor;\n\n\t\tif ( builder.material.matcap ) {\n\n\t\t\tmatcapColor = materialReference( 'matcap', 'texture' ).context( { getUV: () => uv } );\n\n\t\t} else {\n\n\t\t\tmatcapColor = vec3( mix( 0.2, 0.8, uv.y ) ); // default if matcap is missing\n\n\t\t}\n\n\t\tdiffuseColor.rgb.mulAssign( matcapColor.rgb );\n\n\t}\n\n}\n\nconst _defaultValues$2 = /*@__PURE__*/ new PointsMaterial();\n\nclass PointsNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'PointsNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isPointsNodeMaterial = true;\n\n\t\tthis.lights = false;\n\t\tthis.transparent = true;\n\n\t\tthis.sizeNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$2 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.sizeNode = source.sizeNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nclass RotateNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'RotateNode';\n\n\t}\n\n\tconstructor( positionNode, rotationNode ) {\n\n\t\tsuper();\n\n\t\tthis.positionNode = positionNode;\n\t\tthis.rotationNode = rotationNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.positionNode.getNodeType( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { rotationNode, positionNode } = this;\n\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tif ( nodeType === 'vec2' ) {\n\n\t\t\tconst cosAngle = rotationNode.cos();\n\t\t\tconst sinAngle = rotationNode.sin();\n\n\t\t\tconst rotationMatrix = mat2(\n\t\t\t\tcosAngle, sinAngle,\n\t\t\t\tsinAngle.negate(), cosAngle\n\t\t\t);\n\n\t\t\treturn rotationMatrix.mul( positionNode );\n\n\t\t} else {\n\n\t\t\tconst rotation = rotationNode;\n\t\t\tconst rotationXMatrix = mat4( vec4( 1.0, 0.0, 0.0, 0.0 ), vec4( 0.0, cos( rotation.x ), sin( rotation.x ).negate(), 0.0 ), vec4( 0.0, sin( rotation.x ), cos( rotation.x ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\t\t\tconst rotationYMatrix = mat4( vec4( cos( rotation.y ), 0.0, sin( rotation.y ), 0.0 ), vec4( 0.0, 1.0, 0.0, 0.0 ), vec4( sin( rotation.y ).negate(), 0.0, cos( rotation.y ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\t\t\tconst rotationZMatrix = mat4( vec4( cos( rotation.z ), sin( rotation.z ).negate(), 0.0, 0.0 ), vec4( sin( rotation.z ), cos( rotation.z ), 0.0, 0.0 ), vec4( 0.0, 0.0, 1.0, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\n\t\t\treturn rotationXMatrix.mul( rotationYMatrix ).mul( rotationZMatrix ).mul( vec4( positionNode, 1.0 ) ).xyz;\n\n\t\t}\n\n\t}\n\n}\n\nconst rotate = /*@__PURE__*/ nodeProxy( RotateNode );\n\nconst _defaultValues$1 = /*@__PURE__*/ new SpriteMaterial();\n\nclass SpriteNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'SpriteNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isSpriteNodeMaterial = true;\n\n\t\tthis.lights = false;\n\t\tthis._useSizeAttenuation = true;\n\n\t\tthis.positionNode = null;\n\t\tthis.rotationNode = null;\n\t\tthis.scaleNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$1 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupPosition( { object, camera, context } ) {\n\n\t\tconst sizeAttenuation = this.sizeAttenuation;\n\n\t\t// < VERTEX STAGE >\n\n\t\tconst { positionNode, rotationNode, scaleNode } = this;\n\n\t\tconst vertex = positionLocal;\n\n\t\tlet mvPosition = modelViewMatrix.mul( vec3( positionNode || 0 ) );\n\n\t\tlet scale = vec2( modelWorldMatrix[ 0 ].xyz.length(), modelWorldMatrix[ 1 ].xyz.length() );\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tscale = scale.mul( scaleNode );\n\n\t\t}\n\n\n\t\tif ( ! sizeAttenuation ) {\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tscale = scale.mul( mvPosition.z.negate() );\n\n\t\t\t} else {\n\n\t\t\t\tconst orthoScale = float( 2.0 ).div( cameraProjectionMatrix.element( 1 ).element( 1 ) );\n\t\t\t\tscale = scale.mul( orthoScale.mul( 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet alignedPosition = vertex.xy;\n\n\t\tif ( object.center && object.center.isVector2 === true ) {\n\n\t\t\tconst center = reference$1( 'center', 'vec2' );\n\n\t\t\talignedPosition = alignedPosition.sub( center.sub( 0.5 ) );\n\n\t\t}\n\n\t\talignedPosition = alignedPosition.mul( scale );\n\n\t\tconst rotation = float( rotationNode || materialRotation );\n\n\t\tconst rotatedPosition = rotate( alignedPosition, rotation );\n\n\t\tmvPosition = vec4( mvPosition.xy.add( rotatedPosition ), mvPosition.zw );\n\n\t\tconst modelViewProjection = cameraProjectionMatrix.mul( mvPosition );\n\n\t\tcontext.vertex = vertex;\n\n\t\treturn modelViewProjection;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.positionNode = source.positionNode;\n\t\tthis.rotationNode = source.rotationNode;\n\t\tthis.scaleNode = source.scaleNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n\tget sizeAttenuation() {\n\n\t\treturn this._useSizeAttenuation;\n\n\t}\n\n\tset sizeAttenuation( value ) {\n\n\t\tif ( this._useSizeAttenuation !== value ) {\n\n\t\t\tthis._useSizeAttenuation = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass ShadowMaskModel extends LightingModel {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.shadowNode = float( 1 ).toVar( 'shadowMask' );\n\n\t}\n\n\tdirect( { shadowMask } ) {\n\n\t\tthis.shadowNode.mulAssign( shadowMask );\n\n\t}\n\n\tfinish( context ) {\n\n\t\tdiffuseColor.a.mulAssign( this.shadowNode.oneMinus() );\n\n\t\tcontext.outgoingLight.rgb.assign( diffuseColor.rgb ); // TODO: Optimize LightsNode to avoid this assignment\n\n\t}\n\n}\n\nconst _defaultValues = /*@__PURE__*/ new ShadowMaterial();\n\nclass ShadowNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'ShadowNodeMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isShadowNodeMaterial = true;\n\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new ShadowMaskModel();\n\n\t}\n\n}\n\nconst normal = Fn( ( { texture, uv } ) => {\n\n\tconst epsilon = 0.0001;\n\n\tconst ret = vec3().toVar();\n\n\tIf( uv.x.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 1, 0, 0 ) );\n\n\t} ).ElseIf( uv.y.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 1, 0 ) );\n\n\t} ).ElseIf( uv.z.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 0, 1 ) );\n\n\t} ).ElseIf( uv.x.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( - 1, 0, 0 ) );\n\n\t} ).ElseIf( uv.y.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( 0, - 1, 0 ) );\n\n\t} ).ElseIf( uv.z.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 0, - 1 ) );\n\n\t} ).Else( () => {\n\n\t\tconst step = 0.01;\n\n\t\tconst x = texture.uv( uv.add( vec3( - step, 0.0, 0.0 ) ) ).r.sub( texture.uv( uv.add( vec3( step, 0.0, 0.0 ) ) ).r );\n\t\tconst y = texture.uv( uv.add( vec3( 0.0, - step, 0.0 ) ) ).r.sub( texture.uv( uv.add( vec3( 0.0, step, 0.0 ) ) ).r );\n\t\tconst z = texture.uv( uv.add( vec3( 0.0, 0.0, - step ) ) ).r.sub( texture.uv( uv.add( vec3( 0.0, 0.0, step ) ) ).r );\n\n\t\tret.assign( vec3( x, y, z ) );\n\n\t} );\n\n\treturn ret.normalize();\n\n} );\n\n\nclass Texture3DNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'Texture3DNode';\n\n\t}\n\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( value, uvNode, levelNode );\n\n\t\tthis.isTexture3DNode = true;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture3D';\n\n\t}\n\n\tgetDefaultUV() {\n\n\t\treturn vec3( 0.5, 0.5, 0.5 );\n\n\t}\n\n\tsetUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for 3d TextureNode\n\n\tsetupUV( builder, uvNode ) {\n\n\t\treturn uvNode;\n\n\t}\n\n\tgenerateUV( builder, uvNode ) {\n\n\t\treturn uvNode.build( builder, 'vec3' );\n\n\t}\n\n\tnormal( uvNode ) {\n\n\t\treturn normal( { texture: this, uv: uvNode } );\n\n\t}\n\n}\n\nconst texture3D = /*@__PURE__*/ nodeProxy( Texture3DNode );\n\nclass VolumeNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'VolumeNodeMaterial';\n\n\t}\n\n\tconstructor( params = {} ) {\n\n\t\tsuper();\n\n\t\tthis.lights = false;\n\t\tthis.isVolumeNodeMaterial = true;\n\t\tthis.testNode = null;\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst map = texture3D( this.map, null, 0 );\n\n\t\tconst hitBox = Fn( ( { orig, dir } ) => {\n\n\t\t\tconst box_min = vec3( - 0.5 );\n\t\t\tconst box_max = vec3( 0.5 );\n\n\t\t\tconst inv_dir = dir.reciprocal();\n\n\t\t\tconst tmin_tmp = box_min.sub( orig ).mul( inv_dir );\n\t\t\tconst tmax_tmp = box_max.sub( orig ).mul( inv_dir );\n\n\t\t\tconst tmin = min$1( tmin_tmp, tmax_tmp );\n\t\t\tconst tmax = max$1( tmin_tmp, tmax_tmp );\n\n\t\t\tconst t0 = max$1( tmin.x, max$1( tmin.y, tmin.z ) );\n\t\t\tconst t1 = min$1( tmax.x, min$1( tmax.y, tmax.z ) );\n\n\t\t\treturn vec2( t0, t1 );\n\n\t\t} );\n\n\t\tthis.fragmentNode = Fn( () => {\n\n\t\t\tconst vOrigin = varying( vec3( modelWorldMatrixInverse.mul( vec4( cameraPosition, 1.0 ) ) ) );\n\t\t\tconst vDirection = varying( positionGeometry.sub( vOrigin ) );\n\n\t\t\tconst rayDir = vDirection.normalize();\n\t\t\tconst bounds = vec2( hitBox( { orig: vOrigin, dir: rayDir } ) ).toVar();\n\n\t\t\tbounds.x.greaterThan( bounds.y ).discard();\n\n\t\t\tbounds.assign( vec2( max$1( bounds.x, 0.0 ), bounds.y ) );\n\n\t\t\tconst p = vec3( vOrigin.add( bounds.x.mul( rayDir ) ) ).toVar();\n\t\t\tconst inc = vec3( rayDir.abs().reciprocal() ).toVar();\n\t\t\tconst delta = float( min$1( inc.x, min$1( inc.y, inc.z ) ) ).toVar( 'delta' ); // used 'delta' name in loop\n\n\t\t\tdelta.divAssign( materialReference( 'steps', 'float' ) );\n\n\t\t\tconst ac = vec4( materialReference( 'base', 'color' ), 0.0 ).toVar();\n\n\t\t\tLoop( { type: 'float', start: bounds.x, end: bounds.y, update: '+= delta' }, () => {\n\n\t\t\t\tconst d = property( 'float', 'd' ).assign( map.uv( p.add( 0.5 ) ).r );\n\n\t\t\t\tif ( this.testNode !== null ) {\n\n\t\t\t\t\tthis.testNode( { map: map, mapValue: d, probe: p, finalColor: ac } ).append();\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// default to show surface of mesh\n\t\t\t\t\tac.a.assign( 1 );\n\t\t\t\t\tBreak();\n\n\t\t\t\t}\n\n\t\t\t\tp.addAssign( rayDir.mul( delta ) );\n\n\t\t\t} );\n\n\t\t\tac.a.equal( 0 ).discard();\n\n\t\t\treturn vec4( ac );\n\n\t\t} )();\n\n\t\tsuper.setup( builder );\n\n\t}\n\n}\n\nclass Animation {\n\n\tconstructor( nodes, info ) {\n\n\t\tthis.nodes = nodes;\n\t\tthis.info = info;\n\n\t\tthis._context = self;\n\t\tthis._animationLoop = null;\n\t\tthis._requestId = null;\n\n\t}\n\n\tstart() {\n\n\t\tconst update = ( time, frame ) => {\n\n\t\t\tthis._requestId = this._context.requestAnimationFrame( update );\n\n\t\t\tif ( this.info.autoReset === true ) this.info.reset();\n\n\t\t\tthis.nodes.nodeFrame.update();\n\n\t\t\tthis.info.frame = this.nodes.nodeFrame.frameId;\n\n\t\t\tif ( this._animationLoop !== null ) this._animationLoop( time, frame );\n\n\t\t};\n\n\t\tupdate();\n\n\t}\n\n\tstop() {\n\n\t\tthis._context.cancelAnimationFrame( this._requestId );\n\n\t\tthis._requestId = null;\n\n\t}\n\n\tsetAnimationLoop( callback ) {\n\n\t\tthis._animationLoop = callback;\n\n\t}\n\n\tsetContext( context ) {\n\n\t\tthis._context = context;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.stop();\n\n\t}\n\n}\n\nclass ChainMap {\n\n\tconstructor() {\n\n\t\tthis.weakMap = new WeakMap();\n\n\t}\n\n\tget( keys ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length; i ++ ) {\n\n\t\t\tmap = map.get( keys[ i ] );\n\n\t\t\tif ( map === undefined ) return undefined;\n\n\t\t}\n\n\t\treturn map.get( keys[ keys.length - 1 ] );\n\n\t}\n\n\tset( keys, value ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length; i ++ ) {\n\n\t\t\tconst key = keys[ i ];\n\n\t\t\tif ( map.has( key ) === false ) map.set( key, new WeakMap() );\n\n\t\t\tmap = map.get( key );\n\n\t\t}\n\n\t\treturn map.set( keys[ keys.length - 1 ], value );\n\n\t}\n\n\tdelete( keys ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length; i ++ ) {\n\n\t\t\tmap = map.get( keys[ i ] );\n\n\t\t\tif ( map === undefined ) return false;\n\n\t\t}\n\n\t\treturn map.delete( keys[ keys.length - 1 ] );\n\n\t}\n\n}\n\nlet _id$7 = 0;\n\nfunction getKeys( obj ) {\n\n\tconst keys = Object.keys( obj );\n\n\tlet proto = Object.getPrototypeOf( obj );\n\n\twhile ( proto ) {\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( proto );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( descriptors[ key ] !== undefined ) {\n\n\t\t\t\tconst descriptor = descriptors[ key ];\n\n\t\t\t\tif ( descriptor && typeof descriptor.get === 'function' ) {\n\n\t\t\t\t\tkeys.push( key );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tproto = Object.getPrototypeOf( proto );\n\n\t}\n\n\treturn keys;\n\n}\n\nclass RenderObject {\n\n\tconstructor( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext ) {\n\n\t\tthis._nodes = nodes;\n\t\tthis._geometries = geometries;\n\n\t\tthis.id = _id$7 ++;\n\n\t\tthis.renderer = renderer;\n\t\tthis.object = object;\n\t\tthis.material = material;\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\t\tthis.lightsNode = lightsNode;\n\t\tthis.context = renderContext;\n\n\t\tthis.geometry = object.geometry;\n\t\tthis.version = material.version;\n\n\t\tthis.drawRange = null;\n\n\t\tthis.attributes = null;\n\t\tthis.pipeline = null;\n\t\tthis.vertexBuffers = null;\n\t\tthis.drawParams = null;\n\n\t\tthis.bundle = null;\n\n\t\tthis.clippingContext = clippingContext;\n\t\tthis.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';\n\n\t\tthis.initialNodesCacheKey = this.getDynamicCacheKey();\n\t\tthis.initialCacheKey = this.getCacheKey();\n\n\t\tthis._nodeBuilderState = null;\n\t\tthis._bindings = null;\n\t\tthis._monitor = null;\n\n\t\tthis.onDispose = null;\n\n\t\tthis.isRenderObject = true;\n\n\t\tthis.onMaterialDispose = () => {\n\n\t\t\tthis.dispose();\n\n\t\t};\n\n\t\tthis.material.addEventListener( 'dispose', this.onMaterialDispose );\n\n\t}\n\n\tupdateClipping( parent ) {\n\n\t\tthis.clippingContext = parent;\n\n\t}\n\n\tget clippingNeedsUpdate() {\n\n\t\tif ( this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey ) return false;\n\n\t\tthis.clippingContextCacheKey = this.clippingContext.cacheKey;\n\n\t\treturn true;\n\n\t}\n\n\tget hardwareClippingPlanes() {\n\n\t\treturn this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;\n\n\t}\n\n\tgetNodeBuilderState() {\n\n\t\treturn this._nodeBuilderState || ( this._nodeBuilderState = this._nodes.getForRender( this ) );\n\n\t}\n\n\tgetMonitor() {\n\n\t\treturn this._monitor || ( this._monitor = this.getNodeBuilderState().monitor );\n\n\t}\n\n\tgetBindings() {\n\n\t\treturn this._bindings || ( this._bindings = this.getNodeBuilderState().createBindings() );\n\n\t}\n\n\tgetIndex() {\n\n\t\treturn this._geometries.getIndex( this );\n\n\t}\n\n\tgetIndirect() {\n\n\t\treturn this._geometries.getIndirect( this );\n\n\t}\n\n\tgetChainArray() {\n\n\t\treturn [ this.object, this.material, this.context, this.lightsNode ];\n\n\t}\n\n\tsetGeometry( geometry ) {\n\n\t\tthis.geometry = geometry;\n\t\tthis.attributes = null;\n\n\t}\n\n\tgetAttributes() {\n\n\t\tif ( this.attributes !== null ) return this.attributes;\n\n\t\tconst nodeAttributes = this.getNodeBuilderState().nodeAttributes;\n\t\tconst geometry = this.geometry;\n\n\t\tconst attributes = [];\n\t\tconst vertexBuffers = new Set();\n\n\t\tfor ( const nodeAttribute of nodeAttributes ) {\n\n\t\t\tconst attribute = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute( nodeAttribute.name );\n\n\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\tattributes.push( attribute );\n\n\t\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\t\tvertexBuffers.add( bufferAttribute );\n\n\t\t}\n\n\t\tthis.attributes = attributes;\n\t\tthis.vertexBuffers = Array.from( vertexBuffers.values() );\n\n\t\treturn attributes;\n\n\t}\n\n\tgetVertexBuffers() {\n\n\t\tif ( this.vertexBuffers === null ) this.getAttributes();\n\n\t\treturn this.vertexBuffers;\n\n\t}\n\n\tgetDrawParameters() {\n\n\t\tconst { object, material, geometry, group, drawRange } = this;\n\n\t\tconst drawParams = this.drawParams || ( this.drawParams = {\n\t\t\tvertexCount: 0,\n\t\t\tfirstVertex: 0,\n\t\t\tinstanceCount: 0,\n\t\t\tfirstInstance: 0\n\t\t} );\n\n\t\tconst index = this.getIndex();\n\t\tconst hasIndex = ( index !== null );\n\t\tconst instanceCount = geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.count > 1 ? object.count : 1 );\n\n\t\tif ( instanceCount === 0 ) return null;\n\n\t\tdrawParams.instanceCount = instanceCount;\n\n\t\tif ( object.isBatchedMesh === true ) return drawParams;\n\n\t\tlet rangeFactor = 1;\n\n\t\tif ( material.wireframe === true && ! object.isPoints && ! object.isLineSegments && ! object.isLine && ! object.isLineLoop ) {\n\n\t\t\trangeFactor = 2;\n\n\t\t}\n\n\t\tlet firstVertex = drawRange.start * rangeFactor;\n\t\tlet lastVertex = ( drawRange.start + drawRange.count ) * rangeFactor;\n\n\t\tif ( group !== null ) {\n\n\t\t\tfirstVertex = Math.max( firstVertex, group.start * rangeFactor );\n\t\t\tlastVertex = Math.min( lastVertex, ( group.start + group.count ) * rangeFactor );\n\n\t\t}\n\n\t\tconst position = geometry.attributes.position;\n\t\tlet itemCount = Infinity;\n\n\t\tif ( hasIndex ) {\n\n\t\t\titemCount = index.count;\n\n\t\t} else if ( position !== undefined && position !== null ) {\n\n\t\t\titemCount = position.count;\n\n\t\t}\n\n\t\tfirstVertex = Math.max( firstVertex, 0 );\n\t\tlastVertex = Math.min( lastVertex, itemCount );\n\n\t\tconst count = lastVertex - firstVertex;\n\n\t\tif ( count < 0 || count === Infinity ) return null;\n\n\t\tdrawParams.vertexCount = count;\n\t\tdrawParams.firstVertex = firstVertex;\n\n\t\treturn drawParams;\n\n\t}\n\n\tgetGeometryCacheKey() {\n\n\t\tconst { geometry } = this;\n\n\t\tlet cacheKey = '';\n\n\t\tfor ( const name of Object.keys( geometry.attributes ).sort() ) {\n\n\t\t\tconst attribute = geometry.attributes[ name ];\n\n\t\t\tcacheKey += name + ',';\n\n\t\t\tif ( attribute.data ) cacheKey += attribute.data.stride + ',';\n\t\t\tif ( attribute.offset ) cacheKey += attribute.offset + ',';\n\t\t\tif ( attribute.itemSize ) cacheKey += attribute.itemSize + ',';\n\t\t\tif ( attribute.normalized ) cacheKey += 'n,';\n\n\t\t}\n\n\t\tif ( geometry.index ) {\n\n\t\t\tcacheKey += 'index,';\n\n\t\t}\n\n\t\treturn cacheKey;\n\n\t}\n\n\tgetMaterialCacheKey() {\n\n\t\tconst { object, material } = this;\n\n\t\tlet cacheKey = material.customProgramCacheKey();\n\n\t\tfor ( const property of getKeys( material ) ) {\n\n\t\t\tif ( /^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test( property ) ) continue;\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tlet valueKey;\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\t// some material values require a formatting\n\n\t\t\t\tconst type = typeof value;\n\n\t\t\t\tif ( type === 'number' ) {\n\n\t\t\t\t\tvalueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc\n\n\t\t\t\t} else if ( type === 'object' ) {\n\n\t\t\t\t\tvalueKey = '{';\n\n\t\t\t\t\tif ( value.isTexture ) {\n\n\t\t\t\t\t\tvalueKey += value.mapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvalueKey += '}';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvalueKey = String( value );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvalueKey = String( value );\n\n\t\t\t}\n\n\t\t\tcacheKey += /*property + ':' +*/ valueKey + ',';\n\n\t\t}\n\n\t\tcacheKey += this.clippingContextCacheKey + ',';\n\n\t\tif ( object.geometry ) {\n\n\t\t\tcacheKey += this.getGeometryCacheKey();\n\n\t\t}\n\n\t\tif ( object.skeleton ) {\n\n\t\t\tcacheKey += object.skeleton.bones.length + ',';\n\n\t\t}\n\n\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\tcacheKey += object.morphTargetInfluences.length + ',';\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tcacheKey += object._matricesTexture.uuid + ',';\n\n\t\t\tif ( object._colorsTexture !== null ) {\n\n\t\t\t\tcacheKey += object._colorsTexture.uuid + ',';\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.count > 1 ) {\n\n\t\t\t// TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850\n\n\t\t\tcacheKey += object.uuid + ',';\n\n\t\t}\n\n\t\tcacheKey += object.receiveShadow + ',';\n\n\t\treturn hashString( cacheKey );\n\n\t}\n\n\tget needsGeometryUpdate() {\n\n\t\treturn this.geometry.id !== this.object.geometry.id;\n\n\t}\n\n\tget needsUpdate() {\n\n\t\treturn /*this.object.static !== true &&*/ ( this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate );\n\n\t}\n\n\tgetDynamicCacheKey() {\n\n\t\t// Environment Nodes Cache Key\n\n\t\tlet cacheKey = this._nodes.getCacheKey( this.scene, this.lightsNode );\n\n\t\tif ( this.object.receiveShadow ) {\n\n\t\t\tcacheKey += 1;\n\n\t\t}\n\n\t\treturn cacheKey;\n\n\t}\n\n\tgetCacheKey() {\n\n\t\treturn this.getMaterialCacheKey() + this.getDynamicCacheKey();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.material.removeEventListener( 'dispose', this.onMaterialDispose );\n\n\t\tthis.onDispose();\n\n\t}\n\n}\n\nconst chainArray = [];\n\nclass RenderObjects {\n\n\tconstructor( renderer, nodes, geometries, pipelines, bindings, info ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.nodes = nodes;\n\t\tthis.geometries = geometries;\n\t\tthis.pipelines = pipelines;\n\t\tthis.bindings = bindings;\n\t\tthis.info = info;\n\n\t\tthis.chainMaps = {};\n\n\t}\n\n\tget( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {\n\n\t\tconst chainMap = this.getChainMap( passId );\n\n\t\t// reuse chainArray\n\t\tchainArray[ 0 ] = object;\n\t\tchainArray[ 1 ] = material;\n\t\tchainArray[ 2 ] = renderContext;\n\t\tchainArray[ 3 ] = lightsNode;\n\n\t\tlet renderObject = chainMap.get( chainArray );\n\n\t\tif ( renderObject === undefined ) {\n\n\t\t\trenderObject = this.createRenderObject( this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );\n\n\t\t\tchainMap.set( chainArray, renderObject );\n\n\t\t} else {\n\n\t\t\trenderObject.updateClipping( clippingContext );\n\n\t\t\tif ( renderObject.needsGeometryUpdate ) {\n\n\t\t\t\trenderObject.setGeometry( object.geometry );\n\n\t\t\t}\n\n\t\t\tif ( renderObject.version !== material.version || renderObject.needsUpdate ) {\n\n\t\t\t\tif ( renderObject.initialCacheKey !== renderObject.getCacheKey() ) {\n\n\t\t\t\t\trenderObject.dispose();\n\n\t\t\t\t\trenderObject = this.get( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderObject.version = material.version;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn renderObject;\n\n\t}\n\n\tgetChainMap( passId = 'default' ) {\n\n\t\treturn this.chainMaps[ passId ] || ( this.chainMaps[ passId ] = new ChainMap() );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.chainMaps = {};\n\n\t}\n\n\tcreateRenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {\n\n\t\tconst chainMap = this.getChainMap( passId );\n\n\t\tconst renderObject = new RenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext );\n\n\t\trenderObject.onDispose = () => {\n\n\t\t\tthis.pipelines.delete( renderObject );\n\t\t\tthis.bindings.delete( renderObject );\n\t\t\tthis.nodes.delete( renderObject );\n\n\t\t\tchainMap.delete( renderObject.getChainArray() );\n\n\t\t};\n\n\t\treturn renderObject;\n\n\t}\n\n\n}\n\nclass DataMap {\n\n\tconstructor() {\n\n\t\tthis.data = new WeakMap();\n\n\t}\n\n\tget( object ) {\n\n\t\tlet map = this.data.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tthis.data.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\tdelete( object ) {\n\n\t\tlet map;\n\n\t\tif ( this.data.has( object ) ) {\n\n\t\t\tmap = this.data.get( object );\n\n\t\t\tthis.data.delete( object );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\thas( object ) {\n\n\t\treturn this.data.has( object );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.data = new WeakMap();\n\n\t}\n\n}\n\nconst AttributeType = {\n\tVERTEX: 1,\n\tINDEX: 2,\n\tSTORAGE: 3,\n\tINDIRECT: 4\n};\n\n// size of a chunk in bytes (STD140 layout)\n\nconst GPU_CHUNK_BYTES = 16;\n\n// @TODO: Move to src/constants.js\n\nconst BlendColorFactor = 211;\nconst OneMinusBlendColorFactor = 212;\n\nclass Attributes extends DataMap {\n\n\tconstructor( backend ) {\n\n\t\tsuper();\n\n\t\tthis.backend = backend;\n\n\t}\n\n\tdelete( attribute ) {\n\n\t\tconst attributeData = super.delete( attribute );\n\n\t\tif ( attributeData !== undefined ) {\n\n\t\t\tthis.backend.destroyAttribute( attribute );\n\n\t\t}\n\n\t\treturn attributeData;\n\n\t}\n\n\tupdate( attribute, type ) {\n\n\t\tconst data = this.get( attribute );\n\n\t\tif ( data.version === undefined ) {\n\n\t\t\tif ( type === AttributeType.VERTEX ) {\n\n\t\t\t\tthis.backend.createAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.INDEX ) {\n\n\t\t\t\tthis.backend.createIndexAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.STORAGE ) {\n\n\t\t\t\tthis.backend.createStorageAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.INDIRECT ) {\n\n\t\t\t\tthis.backend.createIndirectStorageAttribute( attribute );\n\n\t\t\t}\n\n\t\t\tdata.version = this._getBufferAttribute( attribute ).version;\n\n\t\t} else {\n\n\t\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\t\tif ( data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage ) {\n\n\t\t\t\tthis.backend.updateAttribute( attribute );\n\n\t\t\t\tdata.version = bufferAttribute.version;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_getBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn attribute;\n\n\t}\n\n}\n\nfunction arrayNeedsUint32( array ) {\n\n\t// assumes larger values usually on last\n\n\tfor ( let i = array.length - 1; i >= 0; -- i ) {\n\n\t\tif ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n\n\t}\n\n\treturn false;\n\n}\n\nfunction getWireframeVersion( geometry ) {\n\n\treturn ( geometry.index !== null ) ? geometry.index.version : geometry.attributes.position.version;\n\n}\n\nfunction getWireframeIndex( geometry ) {\n\n\tconst indices = [];\n\n\tconst geometryIndex = geometry.index;\n\tconst geometryPosition = geometry.attributes.position;\n\n\tif ( geometryIndex !== null ) {\n\n\t\tconst array = geometryIndex.array;\n\n\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tconst a = array[ i + 0 ];\n\t\t\tconst b = array[ i + 1 ];\n\t\t\tconst c = array[ i + 2 ];\n\n\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = geometryPosition.array;\n\n\t\tfor ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\tconst a = i + 0;\n\t\t\tconst b = i + 1;\n\t\t\tconst c = i + 2;\n\n\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t}\n\n\t}\n\n\tconst attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\tattribute.version = getWireframeVersion( geometry );\n\n\treturn attribute;\n\n}\n\nclass Geometries extends DataMap {\n\n\tconstructor( attributes, info ) {\n\n\t\tsuper();\n\n\t\tthis.attributes = attributes;\n\t\tthis.info = info;\n\n\t\tthis.wireframes = new WeakMap();\n\n\t\tthis.attributeCall = new WeakMap();\n\n\t}\n\n\thas( renderObject ) {\n\n\t\tconst geometry = renderObject.geometry;\n\n\t\treturn super.has( geometry ) && this.get( geometry ).initialized === true;\n\n\t}\n\n\tupdateForRender( renderObject ) {\n\n\t\tif ( this.has( renderObject ) === false ) this.initGeometry( renderObject );\n\n\t\tthis.updateAttributes( renderObject );\n\n\t}\n\n\tinitGeometry( renderObject ) {\n\n\t\tconst geometry = renderObject.geometry;\n\t\tconst geometryData = this.get( geometry );\n\n\t\tgeometryData.initialized = true;\n\n\t\tthis.info.memory.geometries ++;\n\n\t\tconst onDispose = () => {\n\n\t\t\tthis.info.memory.geometries --;\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst geometryAttributes = renderObject.getAttributes();\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tthis.attributes.delete( index );\n\n\t\t\t}\n\n\t\t\tfor ( const geometryAttribute of geometryAttributes ) {\n\n\t\t\t\tthis.attributes.delete( geometryAttribute );\n\n\t\t\t}\n\n\t\t\tconst wireframeAttribute = this.wireframes.get( geometry );\n\n\t\t\tif ( wireframeAttribute !== undefined ) {\n\n\t\t\t\tthis.attributes.delete( wireframeAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry.removeEventListener( 'dispose', onDispose );\n\n\t\t};\n\n\t\tgeometry.addEventListener( 'dispose', onDispose );\n\n\t}\n\n\tupdateAttributes( renderObject ) {\n\n\t\t// attributes\n\n\t\tconst attributes = renderObject.getAttributes();\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {\n\n\t\t\t\tthis.updateAttribute( attribute, AttributeType.STORAGE );\n\n\t\t\t} else {\n\n\t\t\t\tthis.updateAttribute( attribute, AttributeType.VERTEX );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indexes\n\n\t\tconst index = this.getIndex( renderObject );\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.updateAttribute( index, AttributeType.INDEX );\n\n\t\t}\n\n\t\t// indirect\n\n\t\tconst indirect = renderObject.geometry.indirect;\n\n\t\tif ( indirect !== null ) {\n\n\t\t\tthis.updateAttribute( indirect, AttributeType.INDIRECT );\n\n\t\t}\n\n\t}\n\n\tupdateAttribute( attribute, type ) {\n\n\t\tconst callId = this.info.render.calls;\n\n\t\tif ( ! attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( this.attributeCall.get( attribute ) !== callId ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.attributeCall.get( attribute ) === undefined ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t} else if ( this.attributeCall.get( attribute.data ) !== callId ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute.data, callId );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetIndirect( renderObject ) {\n\n\t\treturn renderObject.geometry.indirect;\n\n\t}\n\n\tgetIndex( renderObject ) {\n\n\t\tconst { geometry, material } = renderObject;\n\n\t\tlet index = geometry.index;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tconst wireframes = this.wireframes;\n\n\t\t\tlet wireframeAttribute = wireframes.get( geometry );\n\n\t\t\tif ( wireframeAttribute === undefined ) {\n\n\t\t\t\twireframeAttribute = getWireframeIndex( geometry );\n\n\t\t\t\twireframes.set( geometry, wireframeAttribute );\n\n\t\t\t} else if ( wireframeAttribute.version !== getWireframeVersion( geometry ) ) {\n\n\t\t\t\tthis.attributes.delete( wireframeAttribute );\n\n\t\t\t\twireframeAttribute = getWireframeIndex( geometry );\n\n\t\t\t\twireframes.set( geometry, wireframeAttribute );\n\n\t\t\t}\n\n\t\t\tindex = wireframeAttribute;\n\n\t\t}\n\n\t\treturn index;\n\n\t}\n\n}\n\nclass Info {\n\n\tconstructor() {\n\n\t\tthis.autoReset = true;\n\n\t\tthis.frame = 0;\n\t\tthis.calls = 0;\n\n\t\tthis.render = {\n\t\t\tcalls: 0,\n\t\t\tframeCalls: 0,\n\t\t\tdrawCalls: 0,\n\t\t\ttriangles: 0,\n\t\t\tpoints: 0,\n\t\t\tlines: 0,\n\t\t\ttimestamp: 0,\n\t\t\tpreviousFrameCalls: 0,\n\t\t\ttimestampCalls: 0\n\t\t};\n\n\t\tthis.compute = {\n\t\t\tcalls: 0,\n\t\t\tframeCalls: 0,\n\t\t\ttimestamp: 0,\n\t\t\tpreviousFrameCalls: 0,\n\t\t\ttimestampCalls: 0\n\t\t};\n\n\t\tthis.memory = {\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\t\t};\n\n\t}\n\n\tupdate( object, count, instanceCount ) {\n\n\t\tthis.render.drawCalls ++;\n\n\t\tif ( object.isMesh || object.isSprite ) {\n\n\t\t\tthis.render.triangles += instanceCount * ( count / 3 );\n\n\t\t} else if ( object.isPoints ) {\n\n\t\t\tthis.render.points += instanceCount * count;\n\n\t\t} else if ( object.isLineSegments ) {\n\n\t\t\tthis.render.lines += instanceCount * ( count / 2 );\n\n\t\t} else if ( object.isLine ) {\n\n\t\t\tthis.render.lines += instanceCount * ( count - 1 );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.WebGPUInfo: Unknown object type.' );\n\n\t\t}\n\n\t}\n\n\tupdateTimestamp( type, time ) {\n\n\t\tif ( this[ type ].timestampCalls === 0 ) {\n\n\t\t\tthis[ type ].timestamp = 0;\n\n\t\t}\n\n\n\t\tthis[ type ].timestamp += time;\n\n\t\tthis[ type ].timestampCalls ++;\n\n\n\t\tif ( this[ type ].timestampCalls >= this[ type ].previousFrameCalls ) {\n\n\t\t\tthis[ type ].timestampCalls = 0;\n\n\t\t}\n\n\n\t}\n\n\treset() {\n\n\t\tconst previousRenderFrameCalls = this.render.frameCalls;\n\t\tthis.render.previousFrameCalls = previousRenderFrameCalls;\n\n\t\tconst previousComputeFrameCalls = this.compute.frameCalls;\n\t\tthis.compute.previousFrameCalls = previousComputeFrameCalls;\n\n\n\t\tthis.render.drawCalls = 0;\n\t\tthis.render.frameCalls = 0;\n\t\tthis.compute.frameCalls = 0;\n\n\t\tthis.render.triangles = 0;\n\t\tthis.render.points = 0;\n\t\tthis.render.lines = 0;\n\n\n\t}\n\n\tdispose() {\n\n\t\tthis.reset();\n\n\t\tthis.calls = 0;\n\n\t\tthis.render.calls = 0;\n\t\tthis.compute.calls = 0;\n\n\t\tthis.render.timestamp = 0;\n\t\tthis.compute.timestamp = 0;\n\t\tthis.memory.geometries = 0;\n\t\tthis.memory.textures = 0;\n\n\t}\n\n}\n\nclass Pipeline {\n\n\tconstructor( cacheKey ) {\n\n\t\tthis.cacheKey = cacheKey;\n\n\t\tthis.usedTimes = 0;\n\n\t}\n\n}\n\nclass RenderPipeline extends Pipeline {\n\n\tconstructor( cacheKey, vertexProgram, fragmentProgram ) {\n\n\t\tsuper( cacheKey );\n\n\t\tthis.vertexProgram = vertexProgram;\n\t\tthis.fragmentProgram = fragmentProgram;\n\n\t}\n\n}\n\nclass ComputePipeline extends Pipeline {\n\n\tconstructor( cacheKey, computeProgram ) {\n\n\t\tsuper( cacheKey );\n\n\t\tthis.computeProgram = computeProgram;\n\n\t\tthis.isComputePipeline = true;\n\n\t}\n\n}\n\nlet _id$6 = 0;\n\nclass ProgrammableStage {\n\n\tconstructor( code, type, transforms = null, attributes = null ) {\n\n\t\tthis.id = _id$6 ++;\n\n\t\tthis.code = code;\n\t\tthis.stage = type;\n\t\tthis.transforms = transforms;\n\t\tthis.attributes = attributes;\n\n\t\tthis.usedTimes = 0;\n\n\t}\n\n}\n\nclass Pipelines extends DataMap {\n\n\tconstructor( backend, nodes ) {\n\n\t\tsuper();\n\n\t\tthis.backend = backend;\n\t\tthis.nodes = nodes;\n\n\t\tthis.bindings = null; // set by the bindings\n\n\t\tthis.caches = new Map();\n\t\tthis.programs = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map()\n\t\t};\n\n\t}\n\n\tgetForCompute( computeNode, bindings ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst data = this.get( computeNode );\n\n\t\tif ( this._needsComputeUpdate( computeNode ) ) {\n\n\t\t\tconst previousPipeline = data.pipeline;\n\n\t\t\tif ( previousPipeline ) {\n\n\t\t\t\tpreviousPipeline.usedTimes --;\n\t\t\t\tpreviousPipeline.computeProgram.usedTimes --;\n\n\t\t\t}\n\n\t\t\t// get shader\n\n\t\t\tconst nodeBuilderState = this.nodes.getForCompute( computeNode );\n\n\t\t\t// programmable stage\n\n\t\t\tlet stageCompute = this.programs.compute.get( nodeBuilderState.computeShader );\n\n\t\t\tif ( stageCompute === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.computeProgram );\n\n\t\t\t\tstageCompute = new ProgrammableStage( nodeBuilderState.computeShader, 'compute', nodeBuilderState.transforms, nodeBuilderState.nodeAttributes );\n\t\t\t\tthis.programs.compute.set( nodeBuilderState.computeShader, stageCompute );\n\n\t\t\t\tbackend.createProgram( stageCompute );\n\n\t\t\t}\n\n\t\t\t// determine compute pipeline\n\n\t\t\tconst cacheKey = this._getComputeCacheKey( computeNode, stageCompute );\n\n\t\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\t\tif ( pipeline === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );\n\n\t\t\t\tpipeline = this._getComputePipeline( computeNode, stageCompute, cacheKey, bindings );\n\n\t\t\t}\n\n\t\t\t// keep track of all used times\n\n\t\t\tpipeline.usedTimes ++;\n\t\t\tstageCompute.usedTimes ++;\n\n\t\t\t//\n\n\t\t\tdata.version = computeNode.version;\n\t\t\tdata.pipeline = pipeline;\n\n\t\t}\n\n\t\treturn data.pipeline;\n\n\t}\n\n\tgetForRender( renderObject, promises = null ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst data = this.get( renderObject );\n\n\t\tif ( this._needsRenderUpdate( renderObject ) ) {\n\n\t\t\tconst previousPipeline = data.pipeline;\n\n\t\t\tif ( previousPipeline ) {\n\n\t\t\t\tpreviousPipeline.usedTimes --;\n\t\t\t\tpreviousPipeline.vertexProgram.usedTimes --;\n\t\t\t\tpreviousPipeline.fragmentProgram.usedTimes --;\n\n\t\t\t}\n\n\t\t\t// get shader\n\n\t\t\tconst nodeBuilderState = renderObject.getNodeBuilderState();\n\n\t\t\t// programmable stages\n\n\t\t\tlet stageVertex = this.programs.vertex.get( nodeBuilderState.vertexShader );\n\n\t\t\tif ( stageVertex === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.vertexProgram );\n\n\t\t\t\tstageVertex = new ProgrammableStage( nodeBuilderState.vertexShader, 'vertex' );\n\t\t\t\tthis.programs.vertex.set( nodeBuilderState.vertexShader, stageVertex );\n\n\t\t\t\tbackend.createProgram( stageVertex );\n\n\t\t\t}\n\n\t\t\tlet stageFragment = this.programs.fragment.get( nodeBuilderState.fragmentShader );\n\n\t\t\tif ( stageFragment === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.fragmentProgram );\n\n\t\t\t\tstageFragment = new ProgrammableStage( nodeBuilderState.fragmentShader, 'fragment' );\n\t\t\t\tthis.programs.fragment.set( nodeBuilderState.fragmentShader, stageFragment );\n\n\t\t\t\tbackend.createProgram( stageFragment );\n\n\t\t\t}\n\n\t\t\t// determine render pipeline\n\n\t\t\tconst cacheKey = this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\n\n\t\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\t\tif ( pipeline === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );\n\n\t\t\t\tpipeline = this._getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises );\n\n\t\t\t} else {\n\n\t\t\t\trenderObject.pipeline = pipeline;\n\n\t\t\t}\n\n\t\t\t// keep track of all used times\n\n\t\t\tpipeline.usedTimes ++;\n\t\t\tstageVertex.usedTimes ++;\n\t\t\tstageFragment.usedTimes ++;\n\n\t\t\t//\n\n\t\t\tdata.pipeline = pipeline;\n\n\t\t}\n\n\t\treturn data.pipeline;\n\n\t}\n\n\tdelete( object ) {\n\n\t\tconst pipeline = this.get( object ).pipeline;\n\n\t\tif ( pipeline ) {\n\n\t\t\t// pipeline\n\n\t\t\tpipeline.usedTimes --;\n\n\t\t\tif ( pipeline.usedTimes === 0 ) this._releasePipeline( pipeline );\n\n\t\t\t// programs\n\n\t\t\tif ( pipeline.isComputePipeline ) {\n\n\t\t\t\tpipeline.computeProgram.usedTimes --;\n\n\t\t\t\tif ( pipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( pipeline.computeProgram );\n\n\t\t\t} else {\n\n\t\t\t\tpipeline.fragmentProgram.usedTimes --;\n\t\t\t\tpipeline.vertexProgram.usedTimes --;\n\n\t\t\t\tif ( pipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( pipeline.vertexProgram );\n\t\t\t\tif ( pipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( pipeline.fragmentProgram );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.delete( object );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis.caches = new Map();\n\t\tthis.programs = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map()\n\t\t};\n\n\t}\n\n\tupdateForRender( renderObject ) {\n\n\t\tthis.getForRender( renderObject );\n\n\t}\n\n\t_getComputePipeline( computeNode, stageCompute, cacheKey, bindings ) {\n\n\t\t// check for existing pipeline\n\n\t\tcacheKey = cacheKey || this._getComputeCacheKey( computeNode, stageCompute );\n\n\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = new ComputePipeline( cacheKey, stageCompute );\n\n\t\t\tthis.caches.set( cacheKey, pipeline );\n\n\t\t\tthis.backend.createComputePipeline( pipeline, bindings );\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t_getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises ) {\n\n\t\t// check for existing pipeline\n\n\t\tcacheKey = cacheKey || this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\n\n\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = new RenderPipeline( cacheKey, stageVertex, stageFragment );\n\n\t\t\tthis.caches.set( cacheKey, pipeline );\n\n\t\t\trenderObject.pipeline = pipeline;\n\n\t\t\tthis.backend.createRenderPipeline( renderObject, promises );\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t_getComputeCacheKey( computeNode, stageCompute ) {\n\n\t\treturn computeNode.id + ',' + stageCompute.id;\n\n\t}\n\n\t_getRenderCacheKey( renderObject, stageVertex, stageFragment ) {\n\n\t\treturn stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey( renderObject );\n\n\t}\n\n\t_releasePipeline( pipeline ) {\n\n\t\tthis.caches.delete( pipeline.cacheKey );\n\n\t}\n\n\t_releaseProgram( program ) {\n\n\t\tconst code = program.code;\n\t\tconst stage = program.stage;\n\n\t\tthis.programs[ stage ].delete( code );\n\n\t}\n\n\t_needsComputeUpdate( computeNode ) {\n\n\t\tconst data = this.get( computeNode );\n\n\t\treturn data.pipeline === undefined || data.version !== computeNode.version;\n\n\t}\n\n\t_needsRenderUpdate( renderObject ) {\n\n\t\tconst data = this.get( renderObject );\n\n\t\treturn data.pipeline === undefined || this.backend.needsRenderUpdate( renderObject );\n\n\t}\n\n}\n\nclass Bindings extends DataMap {\n\n\tconstructor( backend, nodes, textures, attributes, pipelines, info ) {\n\n\t\tsuper();\n\n\t\tthis.backend = backend;\n\t\tthis.textures = textures;\n\t\tthis.pipelines = pipelines;\n\t\tthis.attributes = attributes;\n\t\tthis.nodes = nodes;\n\t\tthis.info = info;\n\n\t\tthis.pipelines.bindings = this; // assign bindings to pipelines\n\n\t}\n\n\tgetForRender( renderObject ) {\n\n\t\tconst bindings = renderObject.getBindings();\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tconst groupData = this.get( bindGroup );\n\n\t\t\tif ( groupData.bindGroup === undefined ) {\n\n\t\t\t\t// each object defines an array of bindings (ubos, textures, samplers etc.)\n\n\t\t\t\tthis._init( bindGroup );\n\n\t\t\t\tthis.backend.createBindings( bindGroup, bindings, 0 );\n\n\t\t\t\tgroupData.bindGroup = bindGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n\tgetForCompute( computeNode ) {\n\n\t\tconst bindings = this.nodes.getForCompute( computeNode ).bindings;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tconst groupData = this.get( bindGroup );\n\n\t\t\tif ( groupData.bindGroup === undefined ) {\n\n\t\t\t\tthis._init( bindGroup );\n\n\t\t\t\tthis.backend.createBindings( bindGroup, bindings, 0 );\n\n\t\t\t\tgroupData.bindGroup = bindGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n\tupdateForCompute( computeNode ) {\n\n\t\tthis._updateBindings( this.getForCompute( computeNode ) );\n\n\t}\n\n\tupdateForRender( renderObject ) {\n\n\t\tthis._updateBindings( this.getForRender( renderObject ) );\n\n\t}\n\n\t_updateBindings( bindings ) {\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tthis._update( bindGroup, bindings );\n\n\t\t}\n\n\t}\n\n\t_init( bindGroup ) {\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isSampledTexture ) {\n\n\t\t\t\tthis.textures.updateTexture( binding.texture );\n\n\t\t\t} else if ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\tconst attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;\n\n\t\t\t\tthis.attributes.update( attribute, attributeType );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_update( bindGroup, bindings ) {\n\n\t\tconst { backend } = this;\n\n\t\tlet needsBindingsUpdate = false;\n\t\tlet cacheBindings = true;\n\t\tlet cacheIndex = 0;\n\t\tlet version = 0;\n\n\t\t// iterate over all bindings and check if buffer updates or a new binding group is required\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isNodeUniformsGroup ) {\n\n\t\t\t\tconst updated = this.nodes.updateGroup( binding );\n\n\t\t\t\tif ( ! updated ) continue;\n\n\t\t\t}\n\n\t\t\tif ( binding.isUniformBuffer ) {\n\n\t\t\t\tconst updated = binding.update();\n\n\t\t\t\tif ( updated ) {\n\n\t\t\t\t\tbackend.updateBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tbinding.update();\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst texturesTextureData = this.textures.get( binding.texture );\n\n\t\t\t\tif ( binding.needsBindingsUpdate( texturesTextureData.generation ) ) needsBindingsUpdate = true;\n\n\t\t\t\tconst updated = binding.update();\n\n\t\t\t\tconst texture = binding.texture;\n\n\t\t\t\tif ( updated ) {\n\n\t\t\t\t\tthis.textures.updateTexture( texture );\n\n\t\t\t\t}\n\n\t\t\t\tconst textureData = backend.get( texture );\n\n\t\t\t\tif ( textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture ) {\n\n\t\t\t\t\tcacheBindings = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcacheIndex = cacheIndex * 10 + texture.id;\n\t\t\t\t\tversion += texture.version;\n\n\t\t\t\t}\n\n\t\t\t\tif ( backend.isWebGPUBackend === true && textureData.texture === undefined && textureData.externalTexture === undefined ) {\n\n\t\t\t\t\t// TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend\n\t\t\t\t\tconsole.error( 'Bindings._update: binding should be available:', binding, updated, texture, binding.textureNode.value, needsBindingsUpdate );\n\n\t\t\t\t\tthis.textures.updateTexture( texture );\n\t\t\t\t\tneedsBindingsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.isStorageTexture === true ) {\n\n\t\t\t\t\tconst textureData = this.get( texture );\n\n\t\t\t\t\tif ( binding.store === true ) {\n\n\t\t\t\t\t\ttextureData.needsMipmap = true;\n\n\t\t\t\t\t} else if ( this.textures.needsMipmaps( texture ) && textureData.needsMipmap === true ) {\n\n\t\t\t\t\t\tthis.backend.generateMipmaps( texture );\n\n\t\t\t\t\t\ttextureData.needsMipmap = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsBindingsUpdate === true ) {\n\n\t\t\tthis.backend.updateBindings( bindGroup, bindings, cacheBindings ? cacheIndex : 0, version );\n\n\t\t}\n\n\t}\n\n}\n\nfunction painterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.material.id !== b.material.id ) {\n\n\t\treturn a.material.id - b.material.id;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn a.z - b.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\nfunction reversePainterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn b.z - a.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\nfunction needsDoublePass( material ) {\n\n\tconst hasTransmission = material.transmission > 0 || material.transmissionNode;\n\n\treturn hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;\n\n}\n\nclass RenderList {\n\n\tconstructor( lighting, scene, camera ) {\n\n\t\tthis.renderItems = [];\n\t\tthis.renderItemsIndex = 0;\n\n\t\tthis.opaque = [];\n\t\tthis.transparentDoublePass = [];\n\t\tthis.transparent = [];\n\t\tthis.bundles = [];\n\n\t\tthis.lightsNode = lighting.getNode( scene, camera );\n\t\tthis.lightsArray = [];\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.occlusionQueryCount = 0;\n\n\t}\n\n\tbegin() {\n\n\t\tthis.renderItemsIndex = 0;\n\n\t\tthis.opaque.length = 0;\n\t\tthis.transparentDoublePass.length = 0;\n\t\tthis.transparent.length = 0;\n\t\tthis.bundles.length = 0;\n\n\t\tthis.lightsArray.length = 0;\n\n\t\tthis.occlusionQueryCount = 0;\n\n\t\treturn this;\n\n\t}\n\n\tgetNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tlet renderItem = this.renderItems[ this.renderItemsIndex ];\n\n\t\tif ( renderItem === undefined ) {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\tz: z,\n\t\t\t\tgroup: group,\n\t\t\t\tclippingContext: clippingContext\n\t\t\t};\n\n\t\t\tthis.renderItems[ this.renderItemsIndex ] = renderItem;\n\n\t\t} else {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\trenderItem.z = z;\n\t\t\trenderItem.group = group;\n\t\t\trenderItem.clippingContext = clippingContext;\n\n\t\t}\n\n\t\tthis.renderItemsIndex ++;\n\n\t\treturn renderItem;\n\n\t}\n\n\tpush( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tconst renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );\n\n\t\tif ( object.occlusionTest === true ) this.occlusionQueryCount ++;\n\n\t\tif ( material.transparent === true || material.transmission > 0 ) {\n\n\t\t\tif ( needsDoublePass( material ) ) this.transparentDoublePass.push( renderItem );\n\n\t\t\tthis.transparent.push( renderItem );\n\n\t\t} else {\n\n\t\t\tthis.opaque.push( renderItem );\n\n\t\t}\n\n\t}\n\n\tunshift( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tconst renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );\n\n\t\tif ( material.transparent === true || material.transmission > 0 ) {\n\n\t\t\tif ( needsDoublePass( material ) ) this.transparentDoublePass.unshift( renderItem );\n\n\t\t\tthis.transparent.unshift( renderItem );\n\n\t\t} else {\n\n\t\t\tthis.opaque.unshift( renderItem );\n\n\t\t}\n\n\t}\n\n\tpushBundle( group ) {\n\n\t\tthis.bundles.push( group );\n\n\t}\n\n\tpushLight( light ) {\n\n\t\tthis.lightsArray.push( light );\n\n\t}\n\n\tsort( customOpaqueSort, customTransparentSort ) {\n\n\t\tif ( this.opaque.length > 1 ) this.opaque.sort( customOpaqueSort || painterSortStable );\n\t\tif ( this.transparentDoublePass.length > 1 ) this.transparentDoublePass.sort( customTransparentSort || reversePainterSortStable );\n\t\tif ( this.transparent.length > 1 ) this.transparent.sort( customTransparentSort || reversePainterSortStable );\n\n\t}\n\n\tfinish() {\n\n\t\t// update lights\n\n\t\tthis.lightsNode.setLights( this.lightsArray );\n\n\t\t// Clear references from inactive renderItems in the list\n\n\t\tfor ( let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = this.renderItems[ i ];\n\n\t\t\tif ( renderItem.id === null ) break;\n\n\t\t\trenderItem.id = null;\n\t\t\trenderItem.object = null;\n\t\t\trenderItem.geometry = null;\n\t\t\trenderItem.material = null;\n\t\t\trenderItem.groupOrder = null;\n\t\t\trenderItem.renderOrder = null;\n\t\t\trenderItem.z = null;\n\t\t\trenderItem.group = null;\n\t\t\trenderItem.clippingContext = null;\n\n\t\t}\n\n\t}\n\n}\n\nclass RenderLists {\n\n\tconstructor( lighting ) {\n\n\t\tthis.lighting = lighting;\n\n\t\tthis.lists = new ChainMap();\n\n\t}\n\n\tget( scene, camera ) {\n\n\t\tconst lists = this.lists;\n\t\tconst keys = [ scene, camera ];\n\n\t\tlet list = lists.get( keys );\n\n\t\tif ( list === undefined ) {\n\n\t\t\tlist = new RenderList( this.lighting, scene, camera );\n\t\t\tlists.set( keys, list );\n\n\t\t}\n\n\t\treturn list;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.lists = new ChainMap();\n\n\t}\n\n}\n\nlet id$1 = 0;\n\nclass RenderContext {\n\n\tconstructor() {\n\n\t\tthis.id = id$1 ++;\n\n\t\tthis.color = true;\n\t\tthis.clearColor = true;\n\t\tthis.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };\n\n\t\tthis.depth = true;\n\t\tthis.clearDepth = true;\n\t\tthis.clearDepthValue = 1;\n\n\t\tthis.stencil = false;\n\t\tthis.clearStencil = true;\n\t\tthis.clearStencilValue = 1;\n\n\t\tthis.viewport = false;\n\t\tthis.viewportValue = new Vector4();\n\n\t\tthis.scissor = false;\n\t\tthis.scissorValue = new Vector4();\n\n\t\tthis.textures = null;\n\t\tthis.depthTexture = null;\n\t\tthis.activeCubeFace = 0;\n\t\tthis.sampleCount = 1;\n\n\t\tthis.width = 0;\n\t\tthis.height = 0;\n\n\t\tthis.isRenderContext = true;\n\n\t}\n\n\tgetCacheKey() {\n\n\t\treturn getCacheKey( this );\n\n\t}\n\n}\n\nfunction getCacheKey( renderContext ) {\n\n\tconst { textures, activeCubeFace } = renderContext;\n\n\tconst values = [ activeCubeFace ];\n\n\tfor ( const texture of textures ) {\n\n\t\tvalues.push( texture.id );\n\n\t}\n\n\treturn hashArray( values );\n\n}\n\nclass RenderContexts {\n\n\tconstructor() {\n\n\t\tthis.chainMaps = {};\n\n\t}\n\n\tget( scene, camera, renderTarget = null ) {\n\n\t\tconst chainKey = [ scene, camera ];\n\n\t\tlet attachmentState;\n\n\t\tif ( renderTarget === null ) {\n\n\t\t\tattachmentState = 'default';\n\n\t\t} else {\n\n\t\t\tconst format = renderTarget.texture.format;\n\t\t\tconst count = renderTarget.textures.length;\n\n\t\t\tattachmentState = `${ count }:${ format }:${ renderTarget.samples }:${ renderTarget.depthBuffer }:${ renderTarget.stencilBuffer }`;\n\n\t\t}\n\n\t\tconst chainMap = this.getChainMap( attachmentState );\n\n\t\tlet renderState = chainMap.get( chainKey );\n\n\t\tif ( renderState === undefined ) {\n\n\t\t\trenderState = new RenderContext();\n\n\t\t\tchainMap.set( chainKey, renderState );\n\n\t\t}\n\n\t\tif ( renderTarget !== null ) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n\n\t\treturn renderState;\n\n\t}\n\n\tgetChainMap( attachmentState ) {\n\n\t\treturn this.chainMaps[ attachmentState ] || ( this.chainMaps[ attachmentState ] = new ChainMap() );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.chainMaps = {};\n\n\t}\n\n}\n\nconst _size$3 = /*@__PURE__*/ new Vector3();\n\nclass Textures extends DataMap {\n\n\tconstructor( renderer, backend, info ) {\n\n\t\tsuper();\n\n\t\tthis.renderer = renderer;\n\t\tthis.backend = backend;\n\t\tthis.info = info;\n\n\t}\n\n\tupdateRenderTarget( renderTarget, activeMipmapLevel = 0 ) {\n\n\t\tconst renderTargetData = this.get( renderTarget );\n\n\t\tconst sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n\t\tconst depthTextureMips = renderTargetData.depthTextureMips || ( renderTargetData.depthTextureMips = {} );\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tconst size = this.getSize( textures[ 0 ] );\n\n\t\tconst mipWidth = size.width >> activeMipmapLevel;\n\t\tconst mipHeight = size.height >> activeMipmapLevel;\n\n\t\tlet depthTexture = renderTarget.depthTexture || depthTextureMips[ activeMipmapLevel ];\n\t\tconst useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;\n\n\t\tlet textureNeedsUpdate = false;\n\n\t\tif ( depthTexture === undefined && useDepthTexture ) {\n\n\t\t\tdepthTexture = new DepthTexture();\n\t\t\tdepthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;\n\t\t\tdepthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType\n\t\t\tdepthTexture.image.width = mipWidth;\n\t\t\tdepthTexture.image.height = mipHeight;\n\n\t\t\tdepthTextureMips[ activeMipmapLevel ] = depthTexture;\n\n\t\t}\n\n\t\tif ( renderTargetData.width !== size.width || size.height !== renderTargetData.height ) {\n\n\t\t\ttextureNeedsUpdate = true;\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tdepthTexture.needsUpdate = true;\n\t\t\t\tdepthTexture.image.width = mipWidth;\n\t\t\t\tdepthTexture.image.height = mipHeight;\n\n\t\t\t}\n\n\t\t}\n\n\t\trenderTargetData.width = size.width;\n\t\trenderTargetData.height = size.height;\n\t\trenderTargetData.textures = textures;\n\t\trenderTargetData.depthTexture = depthTexture || null;\n\t\trenderTargetData.depth = renderTarget.depthBuffer;\n\t\trenderTargetData.stencil = renderTarget.stencilBuffer;\n\t\trenderTargetData.renderTarget = renderTarget;\n\n\t\tif ( renderTargetData.sampleCount !== sampleCount ) {\n\n\t\t\ttextureNeedsUpdate = true;\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tdepthTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\trenderTargetData.sampleCount = sampleCount;\n\n\t\t}\n\n\t\t//\n\n\t\tconst options = { sampleCount };\n\n\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\tconst texture = textures[ i ];\n\n\t\t\tif ( textureNeedsUpdate ) texture.needsUpdate = true;\n\n\t\t\tthis.updateTexture( texture, options );\n\n\t\t}\n\n\t\tif ( depthTexture ) {\n\n\t\t\tthis.updateTexture( depthTexture, options );\n\n\t\t}\n\n\t\t// dispose handler\n\n\t\tif ( renderTargetData.initialized !== true ) {\n\n\t\t\trenderTargetData.initialized = true;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\trenderTarget.removeEventListener( 'dispose', onDispose );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tthis._destroyTexture( textures[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( depthTexture ) {\n\n\t\t\t\t\tthis._destroyTexture( depthTexture );\n\n\t\t\t\t}\n\n\t\t\t\tthis.delete( renderTarget );\n\n\t\t\t};\n\n\t\t\trenderTarget.addEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t}\n\n\tupdateTexture( texture, options = {} ) {\n\n\t\tconst textureData = this.get( texture );\n\t\tif ( textureData.initialized === true && textureData.version === texture.version ) return;\n\n\t\tconst isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;\n\t\tconst backend = this.backend;\n\n\t\tif ( isRenderTarget && textureData.initialized === true ) {\n\n\t\t\t// it's an update\n\n\t\t\tbackend.destroySampler( texture );\n\t\t\tbackend.destroyTexture( texture );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tconst renderTarget = this.renderer.getRenderTarget();\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\ttexture.type = renderTarget.texture.type;\n\n\t\t\t} else {\n\n\t\t\t\ttexture.type = UnsignedByteType;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst { width, height, depth } = this.getSize( texture );\n\n\t\toptions.width = width;\n\t\toptions.height = height;\n\t\toptions.depth = depth;\n\t\toptions.needsMipmaps = this.needsMipmaps( texture );\n\t\toptions.levels = options.needsMipmaps ? this.getMipLevels( texture, width, height ) : 1;\n\n\t\t//\n\n\t\tif ( isRenderTarget || texture.isStorageTexture === true ) {\n\n\t\t\tbackend.createSampler( texture );\n\t\t\tbackend.createTexture( texture, options );\n\n\t\t\ttextureData.generation = texture.version;\n\n\t\t} else {\n\n\t\t\tconst needsCreate = textureData.initialized !== true;\n\n\t\t\tif ( needsCreate ) backend.createSampler( texture );\n\n\t\t\tif ( texture.version > 0 ) {\n\n\t\t\t\tconst image = texture.image;\n\n\t\t\t\tif ( image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Renderer: Texture marked for update but image is undefined.' );\n\n\t\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Renderer: Texture marked for update but image is incomplete.' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( texture.images ) {\n\n\t\t\t\t\t\tconst images = [];\n\n\t\t\t\t\t\tfor ( const image of texture.images ) {\n\n\t\t\t\t\t\t\timages.push( image );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toptions.images = images;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toptions.image = image;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true ) {\n\n\t\t\t\t\t\tbackend.createTexture( texture, options );\n\n\t\t\t\t\t\ttextureData.isDefaultTexture = false;\n\t\t\t\t\t\ttextureData.generation = texture.version;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texture.source.dataReady === true ) backend.updateTexture( texture, options );\n\n\t\t\t\t\tif ( options.needsMipmaps && texture.mipmaps.length === 0 ) backend.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// async update\n\n\t\t\t\tbackend.createDefaultTexture( texture );\n\n\t\t\t\ttextureData.isDefaultTexture = true;\n\t\t\t\ttextureData.generation = texture.version;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// dispose handler\n\n\t\tif ( textureData.initialized !== true ) {\n\n\t\t\ttextureData.initialized = true;\n\t\t\ttextureData.generation = texture.version;\n\n\t\t\t//\n\n\t\t\tthis.info.memory.textures ++;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\ttexture.removeEventListener( 'dispose', onDispose );\n\n\t\t\t\tthis._destroyTexture( texture );\n\n\t\t\t\tthis.info.memory.textures --;\n\n\t\t\t};\n\n\t\t\ttexture.addEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t\t//\n\n\t\ttextureData.version = texture.version;\n\n\t}\n\n\tgetSize( texture, target = _size$3 ) {\n\n\t\tlet image = texture.images ? texture.images[ 0 ] : texture.image;\n\n\t\tif ( image ) {\n\n\t\t\tif ( image.image !== undefined ) image = image.image;\n\n\t\t\ttarget.width = image.width || 1;\n\t\t\ttarget.height = image.height || 1;\n\t\t\ttarget.depth = texture.isCubeTexture ? 6 : ( image.depth || 1 );\n\n\t\t} else {\n\n\t\t\ttarget.width = target.height = target.depth = 1;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetMipLevels( texture, width, height ) {\n\n\t\tlet mipLevelCount;\n\n\t\tif ( texture.isCompressedTexture ) {\n\n\t\t\tif ( texture.mipmaps ) {\n\n\t\t\t\tmipLevelCount = texture.mipmaps.length;\n\n\t\t\t} else {\n\n\t\t\t\tmipLevelCount = 1;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmipLevelCount = Math.floor( Math.log2( Math.max( width, height ) ) ) + 1;\n\n\t\t}\n\n\t\treturn mipLevelCount;\n\n\t}\n\n\tneedsMipmaps( texture ) {\n\n\t\treturn this.isEnvironmentTexture( texture ) || texture.isCompressedTexture === true || texture.generateMipmaps;\n\n\t}\n\n\tisEnvironmentTexture( texture ) {\n\n\t\tconst mapping = texture.mapping;\n\n\t\treturn ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\n\n\t}\n\n\t_destroyTexture( texture ) {\n\n\t\tthis.backend.destroySampler( texture );\n\t\tthis.backend.destroyTexture( texture );\n\n\t\tthis.delete( texture );\n\n\t}\n\n}\n\nclass Color4 extends Color {\n\n\tconstructor( r, g, b, a = 1 ) {\n\n\t\tsuper( r, g, b );\n\n\t\tthis.a = a;\n\n\t}\n\n\tset( r, g, b, a = 1 ) {\n\n\t\tthis.a = a;\n\n\t\treturn super.set( r, g, b );\n\n\t}\n\n\tcopy( color ) {\n\n\t\tif ( color.a !== undefined ) this.a = color.a;\n\n\t\treturn super.copy( color );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.r, this.g, this.b, this.a );\n\n\t}\n\n}\n\nclass ParameterNode extends PropertyNode {\n\n\tstatic get type() {\n\n\t\treturn 'ParameterNode';\n\n\t}\n\n\tconstructor( nodeType, name = null ) {\n\n\t\tsuper( nodeType, name );\n\n\t\tthis.isParameterNode = true;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.uuid;\n\n\t}\n\n\tgenerate() {\n\n\t\treturn this.name;\n\n\t}\n\n}\n\nconst parameter = ( type, name ) => nodeObject( new ParameterNode( type, name ) );\n\nclass StackNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'StackNode';\n\n\t}\n\n\tconstructor( parent = null ) {\n\n\t\tsuper();\n\n\t\tthis.nodes = [];\n\t\tthis.outputNode = null;\n\n\t\tthis.parent = parent;\n\n\t\tthis._currentCond = null;\n\n\t\tthis.isStackNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode ? this.outputNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tadd( node ) {\n\n\t\tthis.nodes.push( node );\n\n\t\treturn this;\n\n\t}\n\n\tIf( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tthis._currentCond = select( boolNode, methodNode );\n\n\t\treturn this.add( this._currentCond );\n\n\t}\n\n\tElseIf( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tconst ifNode = select( boolNode, methodNode );\n\n\t\tthis._currentCond.elseNode = ifNode;\n\t\tthis._currentCond = ifNode;\n\n\t\treturn this;\n\n\t}\n\n\tElse( method ) {\n\n\t\tthis._currentCond.elseNode = new ShaderNode( method );\n\n\t\treturn this;\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tconst previousStack = getCurrentStack();\n\n\t\tsetCurrentStack( this );\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tnode.build( builder, 'void' );\n\n\t\t}\n\n\t\tsetCurrentStack( previousStack );\n\n\t\treturn this.outputNode ? this.outputNode.build( builder, ...params ) : super.build( builder, ...params );\n\n\t}\n\n\t//\n\n\telse( ...params ) { // @deprecated, r168\n\n\t\tconsole.warn( 'TSL.StackNode: .else() has been renamed to .Else().' );\n\t\treturn this.Else( ...params );\n\n\t}\n\n\telseif( ...params ) { // @deprecated, r168\n\n\t\tconsole.warn( 'TSL.StackNode: .elseif() has been renamed to .ElseIf().' );\n\t\treturn this.ElseIf( ...params );\n\n\t}\n\n}\n\nconst stack = /*@__PURE__*/ nodeProxy( StackNode );\n\nclass StructTypeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'StructTypeNode';\n\n\t}\n\n\tconstructor( types ) {\n\n\t\tsuper();\n\n\t\tthis.types = types;\n\t\tthis.isStructTypeNode = true;\n\n\t}\n\n\tgetMemberTypes() {\n\n\t\treturn this.types;\n\n\t}\n\n}\n\nclass OutputStructNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'OutputStructNode';\n\n\t}\n\n\tconstructor( ...members ) {\n\n\t\tsuper();\n\n\t\tthis.members = members;\n\n\t\tthis.isOutputStructNode = true;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst members = this.members;\n\t\tconst types = [];\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\ttypes.push( members[ i ].getNodeType( builder ) );\n\n\t\t}\n\n\t\tthis.nodeType = builder.getStructTypeFromNode( new StructTypeNode( types ) ).name;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst propertyName = builder.getOutputStructName();\n\t\tconst members = this.members;\n\n\t\tconst structPrefix = propertyName !== '' ? propertyName + '.' : '';\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\tconst snippet = members[ i ].build( builder, output );\n\n\t\t\tbuilder.addLineFlowCode( `${ structPrefix }m${ i } = ${ snippet }`, this );\n\n\t\t}\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\nconst outputStruct = /*@__PURE__*/ nodeProxy( OutputStructNode );\n\nfunction getTextureIndex( textures, name ) {\n\n\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\tif ( textures[ i ].name === name ) {\n\n\t\t\treturn i;\n\n\t\t}\n\n\t}\n\n\treturn - 1;\n\n}\n\nclass MRTNode extends OutputStructNode {\n\n\tstatic get type() {\n\n\t\treturn 'MRTNode';\n\n\t}\n\n\tconstructor( outputNodes ) {\n\n\t\tsuper();\n\n\t\tthis.outputNodes = outputNodes;\n\n\t\tthis.isMRTNode = true;\n\n\t}\n\n\thas( name ) {\n\n\t\treturn this.outputNodes[ name ] !== undefined;\n\n\t}\n\n\tget( name ) {\n\n\t\treturn this.outputNodes[ name ];\n\n\t}\n\n\tmerge( mrtNode ) {\n\n\t\tconst outputs = { ...this.outputNodes, ...mrtNode.outputNodes };\n\n\t\treturn mrt( outputs );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst outputNodes = this.outputNodes;\n\t\tconst mrt = builder.renderer.getRenderTarget();\n\n\t\tconst members = [];\n\n\t\tconst textures = mrt.textures;\n\n\t\tfor ( const name in outputNodes ) {\n\n\t\t\tconst index = getTextureIndex( textures, name );\n\n\t\t\tmembers[ index ] = vec4( outputNodes[ name ] );\n\n\t\t}\n\n\t\tthis.members = members;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n}\n\nconst mrt = /*@__PURE__*/ nodeProxy( MRTNode );\n\nconst hash = /*@__PURE__*/ Fn( ( [ seed ] ) => {\n\n\t// Taken from https://www.shadertoy.com/view/XlGcRh, originally from pcg-random.org\n\n\tconst state = seed.toUint().mul( 747796405 ).add( 2891336453 );\n\tconst word = state.shiftRight( state.shiftRight( 28 ).add( 4 ) ).bitXor( state ).mul( 277803737 );\n\tconst result = word.shiftRight( 22 ).bitXor( word );\n\n\treturn result.toFloat().mul( 1 / 2 ** 32 ); // Convert to range [0, 1)\n\n} );\n\n// remapping functions https://iquilezles.org/articles/functions/\nconst parabola = ( x, k ) => pow( mul( 4.0, x.mul( sub( 1.0, x ) ) ), k );\nconst gain = ( x, k ) => x.lessThan( 0.5 ) ? parabola( x.mul( 2.0 ), k ).div( 2.0 ) : sub( 1.0, parabola( mul( sub( 1.0, x ), 2.0 ), k ).div( 2.0 ) );\nconst pcurve = ( x, a, b ) => pow( div( pow( x, a ), add( pow( x, a ), pow( sub( 1.0, x ), b ) ) ), 1.0 / a );\nconst sinc = ( x, k ) => sin( PI.mul( k.mul( x ).sub( 1.0 ) ) ).div( PI.mul( k.mul( x ).sub( 1.0 ) ) );\n\n// https://github.com/cabbibo/glsl-tri-noise-3d\n\n\nconst tri = /*@__PURE__*/ Fn( ( [ x ] ) => {\n\n\treturn x.fract().sub( .5 ).abs();\n\n} ).setLayout( {\n\tname: 'tri',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'x', type: 'float' }\n\t]\n} );\n\nconst tri3 = /*@__PURE__*/ Fn( ( [ p ] ) => {\n\n\treturn vec3( tri( p.z.add( tri( p.y.mul( 1. ) ) ) ), tri( p.z.add( tri( p.x.mul( 1. ) ) ) ), tri( p.y.add( tri( p.x.mul( 1. ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'tri3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst triNoise3D = /*@__PURE__*/ Fn( ( [ p_immutable, spd, time ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst z = float( 1.4 ).toVar();\n\tconst rz = float( 0.0 ).toVar();\n\tconst bp = vec3( p ).toVar();\n\n\tLoop( { start: float( 0.0 ), end: float( 3.0 ), type: 'float', condition: '<=' }, () => {\n\n\t\tconst dg = vec3( tri3( bp.mul( 2.0 ) ) ).toVar();\n\t\tp.addAssign( dg.add( time.mul( float( 0.1 ).mul( spd ) ) ) );\n\t\tbp.mulAssign( 1.8 );\n\t\tz.mulAssign( 1.5 );\n\t\tp.mulAssign( 1.2 );\n\n\t\tconst t = float( tri( p.z.add( tri( p.x.add( tri( p.y ) ) ) ) ) ).toVar();\n\t\trz.addAssign( t.div( z ) );\n\t\tbp.addAssign( 0.14 );\n\n\t} );\n\n\treturn rz;\n\n} ).setLayout( {\n\tname: 'triNoise3D',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'spd', type: 'float' },\n\t\t{ name: 'time', type: 'float' }\n\t]\n} );\n\nclass FunctionOverloadingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionOverloadingNode';\n\n\t}\n\n\tconstructor( functionNodes = [], ...parametersNodes ) {\n\n\t\tsuper();\n\n\t\tthis.functionNodes = functionNodes;\n\t\tthis.parametersNodes = parametersNodes;\n\n\t\tthis._candidateFnCall = null;\n\n\t\tthis.global = true;\n\n\t}\n\n\tgetNodeType() {\n\n\t\treturn this.functionNodes[ 0 ].shaderNode.layout.type;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst params = this.parametersNodes;\n\n\t\tlet candidateFnCall = this._candidateFnCall;\n\n\t\tif ( candidateFnCall === null ) {\n\n\t\t\tlet candidateFn = null;\n\t\t\tlet candidateScore = - 1;\n\n\t\t\tfor ( const functionNode of this.functionNodes ) {\n\n\t\t\t\tconst shaderNode = functionNode.shaderNode;\n\t\t\t\tconst layout = shaderNode.layout;\n\n\t\t\t\tif ( layout === null ) {\n\n\t\t\t\t\tthrow new Error( 'FunctionOverloadingNode: FunctionNode must be a layout.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst inputs = layout.inputs;\n\n\t\t\t\tif ( params.length === inputs.length ) {\n\n\t\t\t\t\tlet score = 0;\n\n\t\t\t\t\tfor ( let i = 0; i < params.length; i ++ ) {\n\n\t\t\t\t\t\tconst param = params[ i ];\n\t\t\t\t\t\tconst input = inputs[ i ];\n\n\t\t\t\t\t\tif ( param.getNodeType( builder ) === input.type ) {\n\n\t\t\t\t\t\t\tscore ++;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tscore = 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( score > candidateScore ) {\n\n\t\t\t\t\t\tcandidateFn = functionNode;\n\t\t\t\t\t\tcandidateScore = score;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._candidateFnCall = candidateFnCall = candidateFn( ...params );\n\n\t\t}\n\n\t\treturn candidateFnCall;\n\n\t}\n\n}\n\nconst overloadingBaseFn = /*@__PURE__*/ nodeProxy( FunctionOverloadingNode );\n\nconst overloadingFn = ( functionNodes ) => ( ...params ) => overloadingBaseFn( functionNodes, ...params );\n\nconst time = /*@__PURE__*/ uniform( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.time );\nconst deltaTime = /*@__PURE__*/ uniform( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.deltaTime );\nconst frameId = /*@__PURE__*/ uniform( 0, 'uint' ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.frameId );\n\n// Deprecated\n\nconst timerLocal = ( timeScale = 1 ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: timerLocal() is deprecated. Use \"time\" instead.' );\n\treturn time.mul( timeScale );\n\n};\n\nconst timerGlobal = ( timeScale = 1 ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: timerGlobal() is deprecated. Use \"time\" instead.' );\n\treturn time.mul( timeScale );\n\n};\n\nconst timerDelta = ( timeScale = 1 ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: timerDelta() is deprecated. Use \"deltaTime\" instead.' );\n\treturn deltaTime.mul( timeScale );\n\n};\n\nconst oscSine = ( t = time ) => t.add( 0.75 ).mul( Math.PI * 2 ).sin().mul( 0.5 ).add( 0.5 );\nconst oscSquare = ( t = time ) => t.fract().round();\nconst oscTriangle = ( t = time ) => t.add( 0.5 ).fract().mul( 2 ).sub( 1 ).abs();\nconst oscSawtooth = ( t = time ) => t.fract();\n\nconst rotateUV = /*@__PURE__*/ Fn( ( [ uv, rotation, center = vec2( 0.5 ) ] ) => {\n\n\treturn rotate( uv.sub( center ), rotation ).add( center );\n\n} );\n\nconst spherizeUV = /*@__PURE__*/ Fn( ( [ uv, strength, center = vec2( 0.5 ) ] ) => {\n\n\tconst delta = uv.sub( center );\n\tconst delta2 = delta.dot( delta );\n\tconst delta4 = delta2.mul( delta2 );\n\tconst deltaOffset = delta4.mul( strength );\n\n\treturn uv.add( delta.mul( deltaOffset ) );\n\n} );\n\nconst billboarding = /*@__PURE__*/ Fn( ( { position = null, horizontal = true, vertical = false } ) => {\n\n\tlet worldMatrix;\n\n\tif ( position !== null ) {\n\n\t\tworldMatrix = modelWorldMatrix.toVar();\n\t\tworldMatrix[ 3 ][ 0 ] = position.x;\n\t\tworldMatrix[ 3 ][ 1 ] = position.y;\n\t\tworldMatrix[ 3 ][ 2 ] = position.z;\n\n\t} else {\n\n\t\tworldMatrix = modelWorldMatrix;\n\n\t}\n\n\tconst modelViewMatrix = cameraViewMatrix.mul( worldMatrix );\n\n\tif ( defined( horizontal ) ) {\n\n\t\tmodelViewMatrix[ 0 ][ 0 ] = modelWorldMatrix[ 0 ].length();\n\t\tmodelViewMatrix[ 0 ][ 1 ] = 0;\n\t\tmodelViewMatrix[ 0 ][ 2 ] = 0;\n\n\t}\n\n\tif ( defined( vertical ) ) {\n\n\t\tmodelViewMatrix[ 1 ][ 0 ] = 0;\n\t\tmodelViewMatrix[ 1 ][ 1 ] = modelWorldMatrix[ 1 ].length();\n\t\tmodelViewMatrix[ 1 ][ 2 ] = 0;\n\n\t}\n\n\tmodelViewMatrix[ 2 ][ 0 ] = 0;\n\tmodelViewMatrix[ 2 ][ 1 ] = 0;\n\tmodelViewMatrix[ 2 ][ 2 ] = 1;\n\n\treturn cameraProjectionMatrix.mul( modelViewMatrix ).mul( positionLocal );\n\n} );\n\nconst viewportSafeUV = /*@__PURE__*/ Fn( ( [ uv = null ] ) => {\n\n\tconst depth = linearDepth();\n\tconst depthDiff = linearDepth( viewportDepthTexture( uv ) ).sub( depth );\n\tconst finalUV = depthDiff.lessThan( 0 ).select( screenUV, uv );\n\n\treturn finalUV;\n\n} );\n\nclass SpriteSheetUVNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SpriteSheetUVNode';\n\n\t}\n\n\tconstructor( countNode, uvNode = uv(), frameNode = float( 0 ) ) {\n\n\t\tsuper( 'vec2' );\n\n\t\tthis.countNode = countNode;\n\t\tthis.uvNode = uvNode;\n\t\tthis.frameNode = frameNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { frameNode, uvNode, countNode } = this;\n\n\t\tconst { width, height } = countNode;\n\n\t\tconst frameNum = frameNode.mod( width.mul( height ) ).floor();\n\n\t\tconst column = frameNum.mod( width );\n\t\tconst row = height.sub( frameNum.add( 1 ).div( width ).ceil() );\n\n\t\tconst scale = countNode.reciprocal();\n\t\tconst uvFrameOffset = vec2( column, row );\n\n\t\treturn uvNode.add( uvFrameOffset ).mul( scale );\n\n\t}\n\n}\n\nconst spritesheetUV = /*@__PURE__*/ nodeProxy( SpriteSheetUVNode );\n\nclass TriplanarTexturesNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TriplanarTexturesNode';\n\n\t}\n\n\tconstructor( textureXNode, textureYNode = null, textureZNode = null, scaleNode = float( 1 ), positionNode = positionLocal, normalNode = normalLocal ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.textureXNode = textureXNode;\n\t\tthis.textureYNode = textureYNode;\n\t\tthis.textureZNode = textureZNode;\n\n\t\tthis.scaleNode = scaleNode;\n\n\t\tthis.positionNode = positionNode;\n\t\tthis.normalNode = normalNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;\n\n\t\t// Ref: https://github.com/keijiro/StandardTriplanar\n\n\t\t// Blending factor of triplanar mapping\n\t\tlet bf = normalNode.abs().normalize();\n\t\tbf = bf.div( bf.dot( vec3( 1.0 ) ) );\n\n\t\t// Triplanar mapping\n\t\tconst tx = positionNode.yz.mul( scaleNode );\n\t\tconst ty = positionNode.zx.mul( scaleNode );\n\t\tconst tz = positionNode.xy.mul( scaleNode );\n\n\t\t// Base color\n\t\tconst textureX = textureXNode.value;\n\t\tconst textureY = textureYNode !== null ? textureYNode.value : textureX;\n\t\tconst textureZ = textureZNode !== null ? textureZNode.value : textureX;\n\n\t\tconst cx = texture( textureX, tx ).mul( bf.x );\n\t\tconst cy = texture( textureY, ty ).mul( bf.y );\n\t\tconst cz = texture( textureZ, tz ).mul( bf.z );\n\n\t\treturn add( cx, cy, cz );\n\n\t}\n\n}\n\nconst triplanarTextures = /*@__PURE__*/ nodeProxy( TriplanarTexturesNode );\nconst triplanarTexture = ( ...params ) => triplanarTextures( ...params );\n\nconst _reflectorPlane = new Plane();\nconst _normal = new Vector3();\nconst _reflectorWorldPosition = new Vector3();\nconst _cameraWorldPosition = new Vector3();\nconst _rotationMatrix = new Matrix4();\nconst _lookAtPosition = new Vector3( 0, 0, - 1 );\nconst clipPlane = new Vector4();\n\nconst _view = new Vector3();\nconst _target = new Vector3();\nconst _q = new Vector4();\n\nconst _size$2 = new Vector2();\n\nconst _defaultRT = new RenderTarget();\nconst _defaultUV = screenUV.flipX();\n\n_defaultRT.depthTexture = new DepthTexture( 1, 1 );\n\nlet _inReflector = false;\n\nclass ReflectorNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReflectorNode';\n\n\t}\n\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters.defaultTexture || _defaultRT.texture, _defaultUV );\n\n\t\tthis._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode( this, parameters );\n\t\tthis._depthNode = null;\n\n\t\tthis.setUpdateMatrix( false );\n\n\t}\n\n\tget reflector() {\n\n\t\treturn this._reflectorBaseNode;\n\n\t}\n\n\tget target() {\n\n\t\treturn this._reflectorBaseNode.target;\n\n\t}\n\n\tgetDepthNode() {\n\n\t\tif ( this._depthNode === null ) {\n\n\t\t\tif ( this._reflectorBaseNode.depth !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ' );\n\n\t\t\t}\n\n\t\t\tthis._depthNode = nodeObject( new ReflectorNode( {\n\t\t\t\tdefaultTexture: _defaultRT.depthTexture,\n\t\t\t\treflector: this._reflectorBaseNode\n\t\t\t} ) );\n\n\t\t}\n\n\t\treturn this._depthNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// ignore if used in post-processing\n\t\tif ( ! builder.object.isQuadMesh ) this._reflectorBaseNode.build( builder );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\tconst texture = new this.constructor( this.reflectorNode );\n\t\ttexture._reflectorBaseNode = this._reflectorBaseNode;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n\nclass ReflectorBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReflectorBaseNode';\n\n\t}\n\n\tconstructor( textureNode, parameters = {} ) {\n\n\t\tsuper();\n\n\t\tconst {\n\t\t\ttarget = new Object3D(),\n\t\t\tresolution = 1,\n\t\t\tgenerateMipmaps = false,\n\t\t\tbounces = true,\n\t\t\tdepth = false\n\t\t} = parameters;\n\n\t\t//\n\n\t\tthis.textureNode = textureNode;\n\n\t\tthis.target = target;\n\t\tthis.resolution = resolution;\n\t\tthis.generateMipmaps = generateMipmaps;\n\t\tthis.bounces = bounces;\n\t\tthis.depth = depth;\n\n\t\tthis.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n\n\t\tthis.virtualCameras = new WeakMap();\n\t\tthis.renderTargets = new WeakMap();\n\n\t}\n\n\t_updateResolution( renderTarget, renderer ) {\n\n\t\tconst resolution = this.resolution;\n\n\t\trenderer.getDrawingBufferSize( _size$2 );\n\n\t\trenderTarget.setSize( Math.round( _size$2.width * resolution ), Math.round( _size$2.height * resolution ) );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._updateResolution( _defaultRT, builder.renderer );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tgetVirtualCamera( camera ) {\n\n\t\tlet virtualCamera = this.virtualCameras.get( camera );\n\n\t\tif ( virtualCamera === undefined ) {\n\n\t\t\tvirtualCamera = camera.clone();\n\n\t\t\tthis.virtualCameras.set( camera, virtualCamera );\n\n\t\t}\n\n\t\treturn virtualCamera;\n\n\t}\n\n\tgetRenderTarget( camera ) {\n\n\t\tlet renderTarget = this.renderTargets.get( camera );\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = new RenderTarget( 0, 0, { type: HalfFloatType } );\n\n\t\t\tif ( this.generateMipmaps === true ) {\n\n\t\t\t\trenderTarget.texture.minFilter = LinearMipMapLinearFilter;\n\t\t\t\trenderTarget.texture.generateMipmaps = true;\n\n\t\t\t}\n\n\t\t\tif ( this.depth === true ) {\n\n\t\t\t\trenderTarget.depthTexture = new DepthTexture();\n\n\t\t\t}\n\n\t\t\tthis.renderTargets.set( camera, renderTarget );\n\n\t\t}\n\n\t\treturn renderTarget;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tif ( this.bounces === false && _inReflector ) return;\n\n\t\t_inReflector = true;\n\n\t\tconst { scene, camera, renderer, material } = frame;\n\t\tconst { target } = this;\n\n\t\tconst virtualCamera = this.getVirtualCamera( camera );\n\t\tconst renderTarget = this.getRenderTarget( virtualCamera );\n\n\t\trenderer.getDrawingBufferSize( _size$2 );\n\n\t\tthis._updateResolution( renderTarget, renderer );\n\n\t\t//\n\n\t\t_reflectorWorldPosition.setFromMatrixPosition( target.matrixWorld );\n\t\t_cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t_rotationMatrix.extractRotation( target.matrixWorld );\n\n\t\t_normal.set( 0, 0, 1 );\n\t\t_normal.applyMatrix4( _rotationMatrix );\n\n\t\t_view.subVectors( _reflectorWorldPosition, _cameraWorldPosition );\n\n\t\t// Avoid rendering when reflector is facing away\n\n\t\tif ( _view.dot( _normal ) > 0 ) return;\n\n\t\t_view.reflect( _normal ).negate();\n\t\t_view.add( _reflectorWorldPosition );\n\n\t\t_rotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t_lookAtPosition.set( 0, 0, - 1 );\n\t\t_lookAtPosition.applyMatrix4( _rotationMatrix );\n\t\t_lookAtPosition.add( _cameraWorldPosition );\n\n\t\t_target.subVectors( _reflectorWorldPosition, _lookAtPosition );\n\t\t_target.reflect( _normal ).negate();\n\t\t_target.add( _reflectorWorldPosition );\n\n\t\t//\n\n\t\tvirtualCamera.coordinateSystem = camera.coordinateSystem;\n\t\tvirtualCamera.position.copy( _view );\n\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\tvirtualCamera.up.applyMatrix4( _rotationMatrix );\n\t\tvirtualCamera.up.reflect( _normal );\n\t\tvirtualCamera.lookAt( _target );\n\n\t\tvirtualCamera.near = camera.near;\n\t\tvirtualCamera.far = camera.far;\n\n\t\tvirtualCamera.updateMatrixWorld();\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t_reflectorPlane.setFromNormalAndCoplanarPoint( _normal, _reflectorWorldPosition );\n\t\t_reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( _reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant );\n\n\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t_q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t_q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t_q.z = - 1.0;\n\t\t_q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 1.0 / clipPlane.dot( _q ) );\n\n\t\tconst clipBias = 0;\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = ( renderer.coordinateSystem === WebGPUCoordinateSystem ) ? ( clipPlane.z - clipBias ) : ( clipPlane.z + 1.0 - clipBias );\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t//\n\n\t\tthis.textureNode.value = renderTarget.texture;\n\n\t\tif ( this.depth === true ) {\n\n\t\t\tthis.textureNode.getDepthNode().value = renderTarget.depthTexture;\n\n\t\t}\n\n\t\tmaterial.visible = false;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentMRT = renderer.getMRT();\n\n\t\trenderer.setMRT( null );\n\t\trenderer.setRenderTarget( renderTarget );\n\n\t\trenderer.render( scene, virtualCamera );\n\n\t\trenderer.setMRT( currentMRT );\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\tmaterial.visible = true;\n\n\t\t_inReflector = false;\n\n\t}\n\n}\n\nconst reflector = ( parameters ) => nodeObject( new ReflectorNode( parameters ) );\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nclass QuadGeometry extends BufferGeometry {\n\n\tconstructor( flipY = false ) {\n\n\t\tsuper();\n\n\t\tconst uv = flipY === false ? [ 0, - 1, 0, 1, 2, 1 ] : [ 0, 2, 0, 0, 2, 0 ];\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );\n\n\t}\n\n}\n\nconst _geometry = /*@__PURE__*/ new QuadGeometry();\n\nclass QuadMesh extends Mesh {\n\n\tconstructor( material = null ) {\n\n\t\tsuper( _geometry, material );\n\n\t\tthis.camera = _camera;\n\n\t\tthis.isQuadMesh = true;\n\n\t}\n\n\trenderAsync( renderer ) {\n\n\t\treturn renderer.renderAsync( this, _camera );\n\n\t}\n\n\trender( renderer ) {\n\n\t\trenderer.render( this, _camera );\n\n\t}\n\n}\n\nconst _size$1 = /*@__PURE__*/ new Vector2();\n\nclass RTTNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'RTTNode';\n\n\t}\n\n\tconstructor( node, width = null, height = null, options = { type: HalfFloatType } ) {\n\n\t\tconst renderTarget = new RenderTarget( width, height, options );\n\n\t\tsuper( renderTarget.texture, uv() );\n\n\t\tthis.node = node;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tthis.renderTarget = renderTarget;\n\n\t\tthis.textureNeedsUpdate = true;\n\t\tthis.autoUpdate = true;\n\n\t\tthis.updateMap = new WeakMap();\n\n\t\tthis._rttNode = null;\n\t\tthis._quadMesh = new QuadMesh( new NodeMaterial() );\n\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tget autoSize() {\n\n\t\treturn this.width === null;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._rttNode = this.node.context( builder.getSharedContext() );\n\t\tthis._quadMesh.material.name = 'RTT';\n\t\tthis._quadMesh.material.needsUpdate = true;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tconst effectiveWidth = width * this.pixelRatio;\n\t\tconst effectiveHeight = height * this.pixelRatio;\n\n\t\tthis.renderTarget.setSize( effectiveWidth, effectiveHeight );\n\n\t\tthis.textureNeedsUpdate = true;\n\n\t}\n\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis.pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this.width, this.height );\n\n\t}\n\n\tupdateBefore( { renderer } ) {\n\n\t\tif ( this.textureNeedsUpdate === false && this.autoUpdate === false ) return;\n\n\t\tthis.textureNeedsUpdate = false;\n\n\t\t//\n\n\t\tif ( this.autoSize === true ) {\n\n\t\t\tthis.pixelRatio = renderer.getPixelRatio();\n\n\t\t\tconst size = renderer.getSize( _size$1 );\n\n\t\t\tthis.setSize( size.width, size.height );\n\n\t\t}\n\n\t\t//\n\n\t\tthis._quadMesh.material.fragmentNode = this._rttNode;\n\n\t\t//\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\trenderer.setRenderTarget( this.renderTarget );\n\n\t\tthis._quadMesh.render( renderer );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new TextureNode( this.value, this.uvNode, this.levelNode );\n\t\tnewNode.sampler = this.sampler;\n\t\tnewNode.referenceNode = this;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\nconst rtt = ( node, ...params ) => nodeObject( new RTTNode( nodeObject( node ), ...params ) );\n\nconst convertToTexture = ( node, ...params ) => {\n\n\tif ( node.isTextureNode ) return node;\n\tif ( node.isPassNode ) return node.getTextureNode();\n\n\treturn rtt( node, ...params );\n\n};\n\n/**\n* Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments\n* depth value and the camera's inverse projection matrix.\n*\n* @param {vec2} screenPosition - The fragment's screen position expressed as uv coordinates.\n* @param {float} depth - The fragment's depth value.\n* @param {mat4} projectionMatrixInverse - The camera's inverse projection matrix.\n* @return {vec3} The fragments position in view space.\n*/\nconst getViewPosition = /*@__PURE__*/ Fn( ( [ screenPosition, depth, projectionMatrixInverse ], builder ) => {\n\n\tlet clipSpacePosition;\n\n\tif ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\tscreenPosition = vec2( screenPosition.x, screenPosition.y.oneMinus() ).mul( 2.0 ).sub( 1.0 );\n\t\tclipSpacePosition = vec4( vec3( screenPosition, depth ), 1.0 );\n\n\t} else {\n\n\t\tclipSpacePosition = vec4( vec3( screenPosition.x, screenPosition.y.oneMinus(), depth ).mul( 2.0 ).sub( 1.0 ), 1.0 );\n\n\t}\n\n\tconst viewSpacePosition = vec4( projectionMatrixInverse.mul( clipSpacePosition ) );\n\n\treturn viewSpacePosition.xyz.div( viewSpacePosition.w );\n\n} );\n\n/**\n* Computes a screen position expressed as uv coordinates based on a fragment's position in view space\n* and the camera's projection matrix\n*\n* @param {vec3} viewPosition - The fragments position in view space.\n* @param {mat4} projectionMatrix - The camera's projection matrix.\n* @return {vec2} The fragment's screen position expressed as uv coordinates.\n*/\nconst getScreenPosition = /*@__PURE__*/ Fn( ( [ viewPosition, projectionMatrix ] ) => {\n\n\tconst sampleClipPos = projectionMatrix.mul( vec4( viewPosition, 1.0 ) );\n\tconst sampleUv = sampleClipPos.xy.div( sampleClipPos.w ).mul( 0.5 ).add( 0.5 ).toVar();\n\treturn vec2( sampleUv.x, sampleUv.y.oneMinus() );\n\n} );\n\n/**\n* Computes a normal vector based on depth data. Can be used as a fallback when no normal render\n* target is available or if flat surface normals are required.\n*\n* @param {vec2} uv - The texture coordinate.\n* @param {DepthTexture} depthTexture - The depth texture.\n* @param {mat4} projectionMatrixInverse - The camera's inverse projection matrix.\n* @return {vec3} The computed normal vector.\n*/\nconst getNormalFromDepth = /*@__PURE__*/ Fn( ( [ uv, depthTexture, projectionMatrixInverse ] ) => {\n\n\tconst size = textureSize( textureLoad( depthTexture ) );\n\tconst p = ivec2( uv.mul( size ) ).toVar();\n\n\tconst c0 = textureLoad( depthTexture, p ).toVar();\n\n\tconst l2 = textureLoad( depthTexture, p.sub( ivec2( 2, 0 ) ) ).toVar();\n\tconst l1 = textureLoad( depthTexture, p.sub( ivec2( 1, 0 ) ) ).toVar();\n\tconst r1 = textureLoad( depthTexture, p.add( ivec2( 1, 0 ) ) ).toVar();\n\tconst r2 = textureLoad( depthTexture, p.add( ivec2( 2, 0 ) ) ).toVar();\n\tconst b2 = textureLoad( depthTexture, p.add( ivec2( 0, 2 ) ) ).toVar();\n\tconst b1 = textureLoad( depthTexture, p.add( ivec2( 0, 1 ) ) ).toVar();\n\tconst t1 = textureLoad( depthTexture, p.sub( ivec2( 0, 1 ) ) ).toVar();\n\tconst t2 = textureLoad( depthTexture, p.sub( ivec2( 0, 2 ) ) ).toVar();\n\n\tconst dl = abs( sub( float( 2 ).mul( l1 ).sub( l2 ), c0 ) ).toVar();\n\tconst dr = abs( sub( float( 2 ).mul( r1 ).sub( r2 ), c0 ) ).toVar();\n\tconst db = abs( sub( float( 2 ).mul( b1 ).sub( b2 ), c0 ) ).toVar();\n\tconst dt = abs( sub( float( 2 ).mul( t1 ).sub( t2 ), c0 ) ).toVar();\n\n\tconst ce = getViewPosition( uv, c0, projectionMatrixInverse ).toVar();\n\n\tconst dpdx = dl.lessThan( dr ).select( ce.sub( getViewPosition( uv.sub( vec2( float( 1 ).div( size.x ), 0 ) ), l1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.add( vec2( float( 1 ).div( size.x ), 0 ) ), r1, projectionMatrixInverse ) ) );\n\tconst dpdy = db.lessThan( dt ).select( ce.sub( getViewPosition( uv.add( vec2( 0, float( 1 ).div( size.y ) ) ), b1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.sub( vec2( 0, float( 1 ).div( size.y ) ) ), t1, projectionMatrixInverse ) ) );\n\n\treturn normalize( cross( dpdx, dpdy ) );\n\n} );\n\nclass StorageInstancedBufferAttribute extends InstancedBufferAttribute {\n\n\tconstructor( array, itemSize, typeClass = Float32Array ) {\n\n\t\tif ( ArrayBuffer.isView( array ) === false ) array = new typeClass( array * itemSize );\n\n\t\tsuper( array, itemSize );\n\n\t\tthis.isStorageInstancedBufferAttribute = true;\n\n\t}\n\n}\n\nclass StorageBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, typeClass = Float32Array ) {\n\n\t\tif ( ArrayBuffer.isView( array ) === false ) array = new typeClass( array * itemSize );\n\n\t\tsuper( array, itemSize );\n\n\t\tthis.isStorageBufferAttribute = true;\n\n\t}\n\n}\n\nclass StorageArrayElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageArrayElementNode';\n\n\t}\n\n\tconstructor( storageBufferNode, indexNode ) {\n\n\t\tsuper( storageBufferNode, indexNode );\n\n\t\tthis.isStorageArrayElementNode = true;\n\n\t}\n\n\tset storageBufferNode( value ) {\n\n\t\tthis.node = value;\n\n\t}\n\n\tget storageBufferNode() {\n\n\t\treturn this.node;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) === false ) {\n\n\t\t\tif ( this.node.isPBO === true ) {\n\n\t\t\t\tbuilder.setupPBO( this.node );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tconst isAssignContext = builder.context.assign;\n\n\t\t//\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) === false ) {\n\n\t\t\tif ( this.node.isPBO === true && isAssignContext !== true && ( this.node.value.isInstancedBufferAttribute || builder.shaderStage !== 'compute' ) ) {\n\n\t\t\t\tsnippet = builder.generatePBO( this );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = this.node.build( builder );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsnippet = super.generate( builder );\n\n\t\t}\n\n\t\tif ( isAssignContext !== true ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tsnippet = builder.format( snippet, type, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n}\n\nconst storageElement = /*@__PURE__*/ nodeProxy( StorageArrayElementNode );\n\nclass StorageBufferNode extends BufferNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageBufferNode';\n\n\t}\n\n\tconstructor( value, bufferType = null, bufferCount = 0 ) {\n\n\t\tif ( bufferType === null && ( value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute ) ) {\n\n\t\t\tbufferType = getTypeFromLength( value.itemSize );\n\t\t\tbufferCount = value.count;\n\n\t\t}\n\n\t\tsuper( value, bufferType, bufferCount );\n\n\t\tthis.isStorageBufferNode = true;\n\n\t\tthis.access = NodeAccess.READ_WRITE;\n\t\tthis.isAtomic = false;\n\t\tthis.isPBO = false;\n\n\t\tthis.bufferCount = bufferCount;\n\n\t\tthis._attribute = null;\n\t\tthis._varying = null;\n\n\t\tthis.global = true;\n\n\t\tif ( value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true ) {\n\n\t\t\t// TOOD: Improve it, possibly adding a new property to the BufferAttribute to identify it as a storage buffer read-only attribute in Renderer\n\n\t\t\tif ( value.isInstancedBufferAttribute ) value.isStorageInstancedBufferAttribute = true;\n\t\t\telse value.isStorageBufferAttribute = true;\n\n\t\t}\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\tif ( this.bufferCount === 0 ) {\n\n\t\t\tlet bufferData = builder.globalCache.getData( this.value );\n\n\t\t\tif ( bufferData === undefined ) {\n\n\t\t\t\tbufferData = {\n\t\t\t\t\tnode: this\n\t\t\t\t};\n\n\t\t\t\tbuilder.globalCache.setData( this.value, bufferData );\n\n\t\t\t}\n\n\t\t\treturn bufferData.node.uuid;\n\n\t\t}\n\n\t\treturn this.uuid;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer';\n\n\t}\n\n\telement( indexNode ) {\n\n\t\treturn storageElement( this, indexNode );\n\n\t}\n\n\tsetPBO( value ) {\n\n\t\tthis.isPBO = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetPBO() {\n\n\t\treturn this.isPBO;\n\n\t}\n\n\tsetAccess( value ) {\n\n\t\tthis.access = value;\n\n\t\treturn this;\n\n\t}\n\n\ttoReadOnly() {\n\n\t\treturn this.setAccess( NodeAccess.READ_ONLY );\n\n\t}\n\n\tsetAtomic( value ) {\n\n\t\tthis.isAtomic = value;\n\n\t\treturn this;\n\n\t}\n\n\ttoAtomic() {\n\n\t\treturn this.setAtomic( true );\n\n\t}\n\n\tgetAttributeData() {\n\n\t\tif ( this._attribute === null ) {\n\n\t\t\tthis._attribute = bufferAttribute( this.value );\n\t\t\tthis._varying = varying( this._attribute );\n\n\t\t}\n\n\t\treturn {\n\t\t\tattribute: this._attribute,\n\t\t\tvarying: this._varying\n\t\t};\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {\n\n\t\t\treturn super.getNodeType( builder );\n\n\t\t}\n\n\t\tconst { attribute } = this.getAttributeData();\n\n\t\treturn attribute.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {\n\n\t\t\treturn super.generate( builder );\n\n\t\t}\n\n\t\tconst { attribute, varying } = this.getAttributeData();\n\n\t\tconst output = varying.build( builder );\n\n\t\tbuilder.registerTransform( output, attribute );\n\n\t\treturn output;\n\n\t}\n\n}\n\nconst storage = ( value, type, count ) => nodeObject( new StorageBufferNode( value, type, count ) );\n\nconst storageObject = ( value, type, count ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"storageObject()\" is deprecated. Use \"storage().setPBO( true )\" instead.' );\n\n\treturn storage( value, type, count ).setPBO( true );\n\n};\n\nconst attributeArray = ( count, type = 'float' ) => {\n\n\tconst itemSize = getLengthFromType( type );\n\n\tconst buffer = new StorageBufferAttribute( count, itemSize );\n\tconst node = storage( buffer, type, count );\n\n\treturn node;\n\n};\n\n\nconst instancedArray = ( count, type = 'float' ) => {\n\n\tconst itemSize = getLengthFromType( type );\n\n\tconst buffer = new StorageInstancedBufferAttribute( count, itemSize );\n\tconst node = storage( buffer, type, count );\n\n\treturn node;\n\n};\n\nclass VertexColorNode extends AttributeNode {\n\n\tstatic get type() {\n\n\t\treturn 'VertexColorNode';\n\n\t}\n\n\tconstructor( index = 0 ) {\n\n\t\tsuper( null, 'vec4' );\n\n\t\tthis.isVertexColorNode = true;\n\n\t\tthis.index = index;\n\n\t}\n\n\tgetAttributeName( /*builder*/ ) {\n\n\t\tconst index = this.index;\n\n\t\treturn 'color' + ( index > 0 ? index : '' );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tlet result;\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tresult = super.generate( builder );\n\n\t\t} else {\n\n\t\t\t// Vertex color fallback should be white\n\t\t\tresult = builder.generateConst( this.nodeType, new Vector4( 1, 1, 1, 1 ) );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.index = this.index;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.index = data.index;\n\n\t}\n\n}\n\nconst vertexColor = ( ...params ) => nodeObject( new VertexColorNode( ...params ) );\n\nclass PointUVNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'PointUVNode';\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t\tthis.isPointUVNode = true;\n\n\t}\n\n\tgenerate( /*builder*/ ) {\n\n\t\treturn 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';\n\n\t}\n\n}\n\nconst pointUV = /*@__PURE__*/ nodeImmutable( PointUVNode );\n\nconst _e1 = /*@__PURE__*/ new Euler();\nconst _m1 = /*@__PURE__*/ new Matrix4();\n\nclass SceneNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SceneNode';\n\n\t}\n\n\tconstructor( scope = SceneNode.BACKGROUND_BLURRINESS, scene = null ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\t\tthis.scene = scene;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst scope = this.scope;\n\t\tconst scene = this.scene !== null ? this.scene : builder.scene;\n\n\t\tlet output;\n\n\t\tif ( scope === SceneNode.BACKGROUND_BLURRINESS ) {\n\n\t\t\toutput = reference( 'backgroundBlurriness', 'float', scene );\n\n\t\t} else if ( scope === SceneNode.BACKGROUND_INTENSITY ) {\n\n\t\t\toutput = reference( 'backgroundIntensity', 'float', scene );\n\n\t\t} else if ( scope === SceneNode.BACKGROUND_ROTATION ) {\n\n\t\t\toutput = uniform( 'mat4' ).label( 'backgroundRotation' ).setGroup( renderGroup ).onRenderUpdate( () => {\n\n\t\t\t\tconst background = scene.background;\n\n\t\t\t\tif ( background !== null && background.isTexture && background.mapping !== UVMapping ) {\n\n\t\t\t\t\t_e1.copy( scene.backgroundRotation );\n\n\t\t\t\t\t// accommodate left-handed frame\n\t\t\t\t\t_e1.x *= - 1; _e1.y *= - 1; _e1.z *= - 1;\n\n\t\t\t\t\t_m1.makeRotationFromEuler( _e1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_m1.identity();\n\n\t\t\t\t}\n\n\t\t\t\treturn _m1;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.SceneNode: Unknown scope:', scope );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nSceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';\nSceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';\nSceneNode.BACKGROUND_ROTATION = 'backgroundRotation';\n\nconst backgroundBlurriness = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_BLURRINESS );\nconst backgroundIntensity = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_INTENSITY );\nconst backgroundRotation = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_ROTATION );\n\nclass StorageTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageTextureNode';\n\n\t}\n\n\tconstructor( value, uvNode, storeNode = null ) {\n\n\t\tsuper( value, uvNode );\n\n\t\tthis.storeNode = storeNode;\n\n\t\tthis.isStorageTextureNode = true;\n\n\t\tthis.access = NodeAccess.WRITE_ONLY;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'storageTexture';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.storeNode = this.storeNode;\n\n\t}\n\n\tsetAccess( value ) {\n\n\t\tthis.access = value;\n\t\treturn this;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tif ( this.storeNode !== null ) {\n\n\t\t\tsnippet = this.generateStore( builder );\n\n\t\t} else {\n\n\t\t\tsnippet = super.generate( builder, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\ttoReadWrite() {\n\n\t\treturn this.setAccess( NodeAccess.READ_WRITE );\n\n\t}\n\n\ttoReadOnly() {\n\n\t\treturn this.setAccess( NodeAccess.READ_ONLY );\n\n\t}\n\n\ttoWriteOnly() {\n\n\t\treturn this.setAccess( NodeAccess.WRITE_ONLY );\n\n\t}\n\n\tgenerateStore( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst { uvNode, storeNode } = properties;\n\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\t\tconst uvSnippet = uvNode.build( builder, 'uvec2' );\n\t\tconst storeSnippet = storeNode.build( builder, 'vec4' );\n\n\t\tconst snippet = builder.generateTextureStore( builder, textureProperty, uvSnippet, storeSnippet );\n\n\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t}\n\n}\n\nconst storageTexture = /*@__PURE__*/ nodeProxy( StorageTextureNode );\n\nconst textureStore = ( value, uvNode, storeNode ) => {\n\n\tconst node = storageTexture( value, uvNode, storeNode );\n\n\tif ( storeNode !== null ) node.append();\n\n\treturn node;\n\n};\n\nclass UserDataNode extends ReferenceNode {\n\n\tstatic get type() {\n\n\t\treturn 'UserDataNode';\n\n\t}\n\n\tconstructor( property, inputType, userData = null ) {\n\n\t\tsuper( property, inputType, userData );\n\n\t\tthis.userData = userData;\n\n\t}\n\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.userData !== null ? this.userData : state.object.userData;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\nconst userData = ( name, inputType, userData ) => nodeObject( new UserDataNode( name, inputType, userData ) );\n\nconst _objectData = new WeakMap();\n\nclass VelocityNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'VelocityNode';\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t\tthis.projectionMatrix = null;\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\t\tthis.updateAfterType = NodeUpdateType.OBJECT;\n\n\t\tthis.previousModelWorldMatrix = uniform( new Matrix4() );\n\t\tthis.previousProjectionMatrix = uniform( new Matrix4() ).setGroup( renderGroup );\n\t\tthis.previousCameraViewMatrix = uniform( new Matrix4() );\n\n\t}\n\n\tsetProjectionMatrix( projectionMatrix ) {\n\n\t\tthis.projectionMatrix = projectionMatrix;\n\n\t}\n\n\tupdate( { frameId, camera, object } ) {\n\n\t\tconst previousModelMatrix = getPreviousMatrix( object );\n\n\t\tthis.previousModelWorldMatrix.value.copy( previousModelMatrix );\n\n\t\t//\n\n\t\tconst cameraData = getData( camera );\n\n\t\tif ( cameraData.frameId !== frameId ) {\n\n\t\t\tcameraData.frameId = frameId;\n\n\t\t\tif ( cameraData.previousProjectionMatrix === undefined ) {\n\n\t\t\t\tcameraData.previousProjectionMatrix = new Matrix4();\n\t\t\t\tcameraData.previousCameraViewMatrix = new Matrix4();\n\n\t\t\t\tcameraData.currentProjectionMatrix = new Matrix4();\n\t\t\t\tcameraData.currentCameraViewMatrix = new Matrix4();\n\n\t\t\t\tcameraData.previousProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );\n\t\t\t\tcameraData.previousCameraViewMatrix.copy( camera.matrixWorldInverse );\n\n\t\t\t} else {\n\n\t\t\t\tcameraData.previousProjectionMatrix.copy( cameraData.currentProjectionMatrix );\n\t\t\t\tcameraData.previousCameraViewMatrix.copy( cameraData.currentCameraViewMatrix );\n\n\t\t\t}\n\n\t\t\tcameraData.currentProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );\n\t\t\tcameraData.currentCameraViewMatrix.copy( camera.matrixWorldInverse );\n\n\t\t\tthis.previousProjectionMatrix.value.copy( cameraData.previousProjectionMatrix );\n\t\t\tthis.previousCameraViewMatrix.value.copy( cameraData.previousCameraViewMatrix );\n\n\t\t}\n\n\t}\n\n\tupdateAfter( { object } ) {\n\n\t\tgetPreviousMatrix( object ).copy( object.matrixWorld );\n\n\t}\n\n\tsetup( /*builder*/ ) {\n\n\t\tconst projectionMatrix = ( this.projectionMatrix === null ) ? cameraProjectionMatrix : uniform( this.projectionMatrix );\n\n\t\tconst previousModelViewMatrix = this.previousCameraViewMatrix.mul( this.previousModelWorldMatrix );\n\n\t\tconst clipPositionCurrent = projectionMatrix.mul( modelViewMatrix ).mul( positionLocal );\n\t\tconst clipPositionPrevious = this.previousProjectionMatrix.mul( previousModelViewMatrix ).mul( positionPrevious );\n\n\t\tconst ndcPositionCurrent = clipPositionCurrent.xy.div( clipPositionCurrent.w );\n\t\tconst ndcPositionPrevious = clipPositionPrevious.xy.div( clipPositionPrevious.w );\n\n\t\tconst velocity = sub( ndcPositionCurrent, ndcPositionPrevious );\n\n\t\treturn velocity;\n\n\t}\n\n}\n\nfunction getData( object ) {\n\n\tlet objectData = _objectData.get( object );\n\n\tif ( objectData === undefined ) {\n\n\t\tobjectData = {};\n\t\t_objectData.set( object, objectData );\n\n\t}\n\n\treturn objectData;\n\n}\n\nfunction getPreviousMatrix( object, index = 0 ) {\n\n\tconst objectData = getData( object );\n\n\tlet matrix = objectData[ index ];\n\n\tif ( matrix === undefined ) {\n\n\t\tobjectData[ index ] = matrix = new Matrix4();\n\n\t}\n\n\treturn matrix;\n\n}\n\nconst velocity = /*@__PURE__*/ nodeImmutable( VelocityNode );\n\nconst blendBurn = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn min$1( 1.0, base.oneMinus().div( blend ) ).oneMinus();\n\n} ).setLayout( {\n\tname: 'blendBurn',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\nconst blendDodge = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn min$1( base.div( blend.oneMinus() ), 1.0 );\n\n} ).setLayout( {\n\tname: 'blendDodge',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\nconst blendScreen = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn base.oneMinus().mul( blend.oneMinus() ).oneMinus();\n\n} ).setLayout( {\n\tname: 'blendScreen',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\nconst blendOverlay = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn mix( base.mul( 2.0 ).mul( blend ), base.oneMinus().mul( 2.0 ).mul( blend.oneMinus() ).oneMinus(), step( 0.5, base ) );\n\n} ).setLayout( {\n\tname: 'blendOverlay',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\nconst blendColor = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\tconst outAlpha = blend.a.add( base.a.mul( blend.a.oneMinus() ) );\n\n\treturn vec4( blend.rgb.mul( blend.a ).add( base.rgb.mul( base.a ).mul( blend.a.oneMinus() ) ).div( outAlpha ), outAlpha );\n\n} ).setLayout( {\n\tname: 'blendColor',\n\ttype: 'vec4',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec4' },\n\t\t{ name: 'blend', type: 'vec4' }\n\t]\n} );\n\n// deprecated\n\nconst burn = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"burn\" has been renamed. Use \"blendBurn\" instead.' );\n\treturn blendBurn( params );\n\n};\n\nconst dodge = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"dodge\" has been renamed. Use \"blendDodge\" instead.' );\n\treturn blendDodge( params );\n\n};\n\nconst screen = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"screen\" has been renamed. Use \"blendScreen\" instead.' );\n\treturn blendScreen( params );\n\n};\n\nconst overlay = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"overlay\" has been renamed. Use \"blendOverlay\" instead.' );\n\treturn blendOverlay( params );\n\n};\n\nconst grayscale = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\treturn luminance( color.rgb );\n\n} );\n\nconst saturation = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\treturn adjustment.mix( luminance( color.rgb ), color.rgb );\n\n} );\n\nconst vibrance = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\tconst average = add( color.r, color.g, color.b ).div( 3.0 );\n\n\tconst mx = color.r.max( color.g.max( color.b ) );\n\tconst amt = mx.sub( average ).mul( adjustment ).mul( - 3.0 );\n\n\treturn mix( color.rgb, mx, amt );\n\n} );\n\nconst hue = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\tconst k = vec3( 0.57735, 0.57735, 0.57735 );\n\n\tconst cosAngle = adjustment.cos();\n\n\treturn vec3( color.rgb.mul( cosAngle ).add( k.cross( color.rgb ).mul( adjustment.sin() ).add( k.mul( dot( k, color.rgb ).mul( cosAngle.oneMinus() ) ) ) ) );\n\n} );\n\nconst luminance = (\n\tcolor,\n\tluminanceCoefficients = vec3( ColorManagement.getLuminanceCoefficients( new Vector3() ) )\n) => dot( color, luminanceCoefficients );\n\nconst threshold = ( color, threshold ) => mix( vec3( 0.0 ), color, luminance( color ).sub( threshold ).max( 0 ) );\n\n/**\n * Color Decision List (CDL) v1.2\n *\n * Compact representation of color grading information, defined by slope, offset, power, and\n * saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,\n * or AgX Log), and will return output in the same space. Output may require clamping >=0.\n *\n * @param {vec4} color Input (-Infinity < input < +Infinity)\n * @param {number | vec3} slope Slope (0 ≤ slope < +Infinity)\n * @param {number | vec3} offset Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1)\n * @param {number | vec3} power Power (0 < power < +Infinity)\n * @param {number} saturation Saturation (0 ≤ saturation < +Infinity; typically 0 ≤ saturation < 4)\n * @param {vec3} luminanceCoefficients Luminance coefficients for saturation term, typically Rec. 709\n * @return Output, -Infinity < output < +Infinity\n *\n * References:\n * - ASC CDL v1.2\n * - https://blender.stackexchange.com/a/55239/43930\n * - https://docs.acescentral.com/specifications/acescc/\n */\nconst cdl = /*@__PURE__*/ Fn( ( [\n\tcolor,\n\tslope = vec3( 1 ),\n\toffset = vec3( 0 ),\n\tpower = vec3( 1 ),\n\tsaturation = float( 1 ),\n\t// ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.\n\tluminanceCoefficients = vec3( ColorManagement.getLuminanceCoefficients( new Vector3(), LinearSRGBColorSpace ) )\n] ) => {\n\n\t// NOTE: The ASC CDL v1.2 defines a [0, 1] clamp on the slope+offset term, and another on the\n\t// saturation term. Per the ACEScc specification and Filament, limits may be omitted to support\n\t// values outside [0, 1], requiring a workaround for negative values in the power expression.\n\n\tconst luma = color.rgb.dot( vec3( luminanceCoefficients ) );\n\n\tconst v = max$1( color.rgb.mul( slope ).add( offset ), 0.0 ).toVar();\n\tconst pv = v.pow( power ).toVar();\n\n\tIf( v.r.greaterThan( 0.0 ), () => { v.r.assign( pv.r ); } ); // eslint-disable-line\n\tIf( v.g.greaterThan( 0.0 ), () => { v.g.assign( pv.g ); } ); // eslint-disable-line\n\tIf( v.b.greaterThan( 0.0 ), () => { v.b.assign( pv.b ); } ); // eslint-disable-line\n\n\tv.assign( luma.add( v.sub( luma ).mul( saturation ) ) );\n\n\treturn vec4( v.rgb, color.a );\n\n} );\n\nclass PosterizeNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PosterizeNode';\n\n\t}\n\n\tconstructor( sourceNode, stepsNode ) {\n\n\t\tsuper();\n\n\t\tthis.sourceNode = sourceNode;\n\t\tthis.stepsNode = stepsNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { sourceNode, stepsNode } = this;\n\n\t\treturn sourceNode.mul( stepsNode ).floor().div( stepsNode );\n\n\t}\n\n}\n\nconst posterize = /*@__PURE__*/ nodeProxy( PosterizeNode );\n\nconst _size = /*@__PURE__*/ new Vector2();\n\nclass PassTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassTextureNode';\n\n\t}\n\n\tconstructor( passNode, texture ) {\n\n\t\tsuper( texture );\n\n\t\tthis.passNode = passNode;\n\n\t\tthis.setUpdateMatrix( false );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( builder.object.isQuadMesh ) this.passNode.build( builder );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.passNode, this.value );\n\n\t}\n\n}\n\nclass PassMultipleTextureNode extends PassTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassMultipleTextureNode';\n\n\t}\n\n\tconstructor( passNode, textureName, previousTexture = false ) {\n\n\t\tsuper( passNode, null );\n\n\t\tthis.textureName = textureName;\n\t\tthis.previousTexture = previousTexture;\n\n\t}\n\n\tupdateTexture() {\n\n\t\tthis.value = this.previousTexture ? this.passNode.getPreviousTexture( this.textureName ) : this.passNode.getTexture( this.textureName );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.updateTexture();\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.passNode, this.textureName, this.previousTexture );\n\n\t}\n\n}\n\nclass PassNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassNode';\n\n\t}\n\n\tconstructor( scope, scene, camera, options = {} ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.scope = scope;\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\t\tthis.options = options;\n\n\t\tthis._pixelRatio = 1;\n\t\tthis._width = 1;\n\t\tthis._height = 1;\n\n\t\tconst depthTexture = new DepthTexture();\n\t\tdepthTexture.isRenderTargetTexture = true;\n\t\t//depthTexture.type = FloatType;\n\t\tdepthTexture.name = 'depth';\n\n\t\tconst renderTarget = new RenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options, } );\n\t\trenderTarget.texture.name = 'output';\n\t\trenderTarget.depthTexture = depthTexture;\n\n\t\tthis.renderTarget = renderTarget;\n\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\tthis._textures = {\n\t\t\toutput: renderTarget.texture,\n\t\t\tdepth: depthTexture\n\t\t};\n\n\t\tthis._textureNodes = {};\n\t\tthis._linearDepthNodes = {};\n\t\tthis._viewZNodes = {};\n\n\t\tthis._previousTextures = {};\n\t\tthis._previousTextureNodes = {};\n\n\t\tthis._cameraNear = uniform( 0 );\n\t\tthis._cameraFar = uniform( 0 );\n\n\t\tthis._mrt = null;\n\n\t\tthis.isPassNode = true;\n\n\t}\n\n\tsetMRT( mrt ) {\n\n\t\tthis._mrt = mrt;\n\n\t\treturn this;\n\n\t}\n\n\tgetMRT() {\n\n\t\treturn this._mrt;\n\n\t}\n\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\tgetTexture( name ) {\n\n\t\tlet texture = this._textures[ name ];\n\n\t\tif ( texture === undefined ) {\n\n\t\t\tconst refTexture = this.renderTarget.texture;\n\n\t\t\ttexture = refTexture.clone();\n\t\t\ttexture.isRenderTargetTexture = true;\n\t\t\ttexture.name = name;\n\n\t\t\tthis._textures[ name ] = texture;\n\n\t\t\tthis.renderTarget.textures.push( texture );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tgetPreviousTexture( name ) {\n\n\t\tlet texture = this._previousTextures[ name ];\n\n\t\tif ( texture === undefined ) {\n\n\t\t\ttexture = this.getTexture( name ).clone();\n\t\t\ttexture.isRenderTargetTexture = true;\n\n\t\t\tthis._previousTextures[ name ] = texture;\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\ttoggleTexture( name ) {\n\n\t\tconst prevTexture = this._previousTextures[ name ];\n\n\t\tif ( prevTexture !== undefined ) {\n\n\t\t\tconst texture = this._textures[ name ];\n\n\t\t\tconst index = this.renderTarget.textures.indexOf( texture );\n\t\t\tthis.renderTarget.textures[ index ] = prevTexture;\n\n\t\t\tthis._textures[ name ] = prevTexture;\n\t\t\tthis._previousTextures[ name ] = texture;\n\n\t\t\tthis._textureNodes[ name ].updateTexture();\n\t\t\tthis._previousTextureNodes[ name ].updateTexture();\n\n\t\t}\n\n\t}\n\n\tgetTextureNode( name = 'output' ) {\n\n\t\tlet textureNode = this._textureNodes[ name ];\n\n\t\tif ( textureNode === undefined ) {\n\n\t\t\ttextureNode = nodeObject( new PassMultipleTextureNode( this, name ) );\n\t\t\ttextureNode.updateTexture();\n\t\t\tthis._textureNodes[ name ] = textureNode;\n\n\t\t}\n\n\t\treturn textureNode;\n\n\t}\n\n\tgetPreviousTextureNode( name = 'output' ) {\n\n\t\tlet textureNode = this._previousTextureNodes[ name ];\n\n\t\tif ( textureNode === undefined ) {\n\n\t\t\tif ( this._textureNodes[ name ] === undefined ) this.getTextureNode( name );\n\n\t\t\ttextureNode = nodeObject( new PassMultipleTextureNode( this, name, true ) );\n\t\t\ttextureNode.updateTexture();\n\t\t\tthis._previousTextureNodes[ name ] = textureNode;\n\n\t\t}\n\n\t\treturn textureNode;\n\n\t}\n\n\tgetViewZNode( name = 'depth' ) {\n\n\t\tlet viewZNode = this._viewZNodes[ name ];\n\n\t\tif ( viewZNode === undefined ) {\n\n\t\t\tconst cameraNear = this._cameraNear;\n\t\t\tconst cameraFar = this._cameraFar;\n\n\t\t\tthis._viewZNodes[ name ] = viewZNode = perspectiveDepthToViewZ( this.getTextureNode( name ), cameraNear, cameraFar );\n\n\t\t}\n\n\t\treturn viewZNode;\n\n\t}\n\n\tgetLinearDepthNode( name = 'depth' ) {\n\n\t\tlet linearDepthNode = this._linearDepthNodes[ name ];\n\n\t\tif ( linearDepthNode === undefined ) {\n\n\t\t\tconst cameraNear = this._cameraNear;\n\t\t\tconst cameraFar = this._cameraFar;\n\t\t\tconst viewZNode = this.getViewZNode( name );\n\n\t\t\t// TODO: just if ( builder.camera.isPerspectiveCamera )\n\n\t\t\tthis._linearDepthNodes[ name ] = linearDepthNode = viewZToOrthographicDepth( viewZNode, cameraNear, cameraFar );\n\n\t\t}\n\n\t\treturn linearDepthNode;\n\n\t}\n\n\tsetup( { renderer } ) {\n\n\t\tthis.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;\n\n\t\t// Disable MSAA for WebGL backend for now\n\t\tif ( renderer.backend.isWebGLBackend === true ) {\n\n\t\t\tthis.renderTarget.samples = 0;\n\n\t\t}\n\n\t\tthis.renderTarget.depthTexture.isMultisampleRenderTargetTexture = this.renderTarget.samples > 1;\n\n\t\treturn this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\t\tconst { scene, camera } = this;\n\n\t\tthis._pixelRatio = renderer.getPixelRatio();\n\n\t\tconst size = renderer.getSize( _size );\n\n\t\tthis.setSize( size.width, size.height );\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentMRT = renderer.getMRT();\n\n\t\tthis._cameraNear.value = camera.near;\n\t\tthis._cameraFar.value = camera.far;\n\n\t\tfor ( const name in this._previousTextures ) {\n\n\t\t\tthis.toggleTexture( name );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( this.renderTarget );\n\t\trenderer.setMRT( this._mrt );\n\n\t\trenderer.render( scene, camera );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.setMRT( currentMRT );\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tconst effectiveWidth = this._width * this._pixelRatio;\n\t\tconst effectiveHeight = this._height * this._pixelRatio;\n\n\t\tthis.renderTarget.setSize( effectiveWidth, effectiveHeight );\n\n\t}\n\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this._width, this._height );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.renderTarget.dispose();\n\n\t}\n\n\n}\n\nPassNode.COLOR = 'color';\nPassNode.DEPTH = 'depth';\n\nconst pass = ( scene, camera, options ) => nodeObject( new PassNode( PassNode.COLOR, scene, camera, options ) );\nconst passTexture = ( pass, texture ) => nodeObject( new PassTextureNode( pass, texture ) );\nconst depthPass = ( scene, camera ) => nodeObject( new PassNode( PassNode.DEPTH, scene, camera ) );\n\nclass ToonOutlinePassNode extends PassNode {\n\n\tstatic get type() {\n\n\t\treturn 'ToonOutlinePassNode';\n\n\t}\n\n\tconstructor( scene, camera, colorNode, thicknessNode, alphaNode ) {\n\n\t\tsuper( PassNode.COLOR, scene, camera );\n\n\t\tthis.colorNode = colorNode;\n\t\tthis.thicknessNode = thicknessNode;\n\t\tthis.alphaNode = alphaNode;\n\n\t\tthis._materialCache = new WeakMap();\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\tconst currentRenderObjectFunction = renderer.getRenderObjectFunction();\n\n\t\trenderer.setRenderObjectFunction( ( object, scene, camera, geometry, material, group, lightsNode, clippingContext ) => {\n\n\t\t\t// only render outline for supported materials\n\n\t\t\tif ( material.isMeshToonMaterial || material.isMeshToonNodeMaterial ) {\n\n\t\t\t\tif ( material.wireframe === false ) {\n\n\t\t\t\t\tconst outlineMaterial = this._getOutlineMaterial( material );\n\t\t\t\t\trenderer.renderObject( object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// default\n\n\t\t\trenderer.renderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext );\n\n\t\t} );\n\n\t\tsuper.updateBefore( frame );\n\n\t\trenderer.setRenderObjectFunction( currentRenderObjectFunction );\n\n\t}\n\n\t_createMaterial() {\n\n\t\tconst material = new NodeMaterial();\n\t\tmaterial.isMeshToonOutlineMaterial = true;\n\t\tmaterial.name = 'Toon_Outline';\n\t\tmaterial.side = BackSide;\n\n\t\t// vertex node\n\n\t\tconst outlineNormal = normalLocal.negate();\n\t\tconst mvp = cameraProjectionMatrix.mul( modelViewMatrix );\n\n\t\tconst ratio = float( 1.0 ); // TODO: support outline thickness ratio for each vertex\n\t\tconst pos = mvp.mul( vec4( positionLocal, 1.0 ) );\n\t\tconst pos2 = mvp.mul( vec4( positionLocal.add( outlineNormal ), 1.0 ) );\n\t\tconst norm = normalize( pos.sub( pos2 ) ); // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\n\t\tmaterial.vertexNode = pos.add( norm.mul( this.thicknessNode ).mul( pos.w ).mul( ratio ) );\n\n\t\t// color node\n\n\t\tmaterial.colorNode = vec4( this.colorNode, this.alphaNode );\n\n\t\treturn material;\n\n\t}\n\n\t_getOutlineMaterial( originalMaterial ) {\n\n\t\tlet outlineMaterial = this._materialCache.get( originalMaterial );\n\n\t\tif ( outlineMaterial === undefined ) {\n\n\t\t\toutlineMaterial = this._createMaterial();\n\n\t\t\tthis._materialCache.set( originalMaterial, outlineMaterial );\n\n\t\t}\n\n\t\treturn outlineMaterial;\n\n\t}\n\n}\n\nconst toonOutlinePass = ( scene, camera, color = new Color( 0, 0, 0 ), thickness = 0.003, alpha = 1 ) => nodeObject( new ToonOutlinePassNode( scene, camera, nodeObject( color ), nodeObject( thickness ), nodeObject( alpha ) ) );\n\n// exposure only\n\nconst linearToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\treturn color.mul( exposure ).clamp();\n\n} ).setLayout( {\n\tname: 'linearToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf\n\nconst reinhardToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tcolor = color.mul( exposure );\n\n\treturn color.div( color.add( 1.0 ) ).clamp();\n\n} ).setLayout( {\n\tname: 'reinhardToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n\nconst cineonToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\t// filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor = color.mul( exposure );\n\tcolor = color.sub( 0.004 ).max( 0.0 );\n\n\tconst a = color.mul( color.mul( 6.2 ).add( 0.5 ) );\n\tconst b = color.mul( color.mul( 6.2 ).add( 1.7 ) ).add( 0.06 );\n\n\treturn a.div( b ).pow( 2.2 );\n\n} ).setLayout( {\n\tname: 'cineonToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n\nconst RRTAndODTFit = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.mul( color.add( 0.0245786 ) ).sub( 0.000090537 );\n\tconst b = color.mul( color.add( 0.4329510 ).mul( 0.983729 ) ).add( 0.238081 );\n\n\treturn a.div( b );\n\n} );\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n\nconst acesFilmicToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\t// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n\tconst ACESInputMat = mat3(\n\t\t0.59719, 0.35458, 0.04823,\n\t\t0.07600, 0.90834, 0.01566,\n\t\t0.02840, 0.13383, 0.83777\n\t);\n\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n\tconst ACESOutputMat = mat3(\n\t\t1.60475, - 0.53108, - 0.07367,\n\t\t- 0.10208, 1.10813, - 0.00605,\n\t\t- 0.00327, - 0.07276, 1.07602\n\t);\n\n\tcolor = color.mul( exposure ).div( 0.6 );\n\n\tcolor = ACESInputMat.mul( color );\n\n\t// Apply RRT and ODT\n\tcolor = RRTAndODTFit( color );\n\n\tcolor = ACESOutputMat.mul( color );\n\n\t// Clamp to [0, 1]\n\treturn color.clamp();\n\n} ).setLayout( {\n\tname: 'acesFilmicToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\nconst LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/ mat3( vec3( 1.6605, - 0.1246, - 0.0182 ), vec3( - 0.5876, 1.1329, - 0.1006 ), vec3( - 0.0728, - 0.0083, 1.1187 ) );\nconst LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/ mat3( vec3( 0.6274, 0.0691, 0.0164 ), vec3( 0.3293, 0.9195, 0.0880 ), vec3( 0.0433, 0.0113, 0.8956 ) );\n\nconst agxDefaultContrastApprox = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = vec3( x_immutable ).toVar();\n\tconst x2 = vec3( x.mul( x ) ).toVar();\n\tconst x4 = vec3( x2.mul( x2 ) ).toVar();\n\n\treturn float( 15.5 ).mul( x4.mul( x2 ) ).sub( mul( 40.14, x4.mul( x ) ) ).add( mul( 31.96, x4 ).sub( mul( 6.868, x2.mul( x ) ) ).add( mul( 0.4298, x2 ).add( mul( 0.1191, x ).sub( 0.00232 ) ) ) );\n\n} );\n\nconst agxToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tconst colortone = vec3( color ).toVar();\n\tconst AgXInsetMatrix = mat3( vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ), vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ), vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 ) );\n\tconst AgXOutsetMatrix = mat3( vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ), vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ), vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 ) );\n\tconst AgxMinEv = float( - 12.47393 );\n\tconst AgxMaxEv = float( 4.026069 );\n\tcolortone.mulAssign( exposure );\n\tcolortone.assign( LINEAR_SRGB_TO_LINEAR_REC2020.mul( colortone ) );\n\tcolortone.assign( AgXInsetMatrix.mul( colortone ) );\n\tcolortone.assign( max$1( colortone, 1e-10 ) );\n\tcolortone.assign( log2( colortone ) );\n\tcolortone.assign( colortone.sub( AgxMinEv ).div( AgxMaxEv.sub( AgxMinEv ) ) );\n\tcolortone.assign( clamp( colortone, 0.0, 1.0 ) );\n\tcolortone.assign( agxDefaultContrastApprox( colortone ) );\n\tcolortone.assign( AgXOutsetMatrix.mul( colortone ) );\n\tcolortone.assign( pow( max$1( vec3( 0.0 ), colortone ), vec3( 2.2 ) ) );\n\tcolortone.assign( LINEAR_REC2020_TO_LINEAR_SRGB.mul( colortone ) );\n\tcolortone.assign( clamp( colortone, 0.0, 1.0 ) );\n\n\treturn colortone;\n\n} ).setLayout( {\n\tname: 'agxToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n// https://modelviewer.dev/examples/tone-mapping\n\nconst neutralToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tconst StartCompression = float( 0.8 - 0.04 );\n\tconst Desaturation = float( 0.15 );\n\n\tcolor = color.mul( exposure );\n\n\tconst x = min$1( color.r, min$1( color.g, color.b ) );\n\tconst offset = select( x.lessThan( 0.08 ), x.sub( mul( 6.25, x.mul( x ) ) ), 0.04 );\n\n\tcolor.subAssign( offset );\n\n\tconst peak = max$1( color.r, max$1( color.g, color.b ) );\n\n\tIf( peak.lessThan( StartCompression ), () => {\n\n\t\treturn color;\n\n\t} );\n\n\tconst d = sub( 1, StartCompression );\n\tconst newPeak = sub( 1, d.mul( d ).div( peak.add( d.sub( StartCompression ) ) ) );\n\tcolor.mulAssign( newPeak.div( peak ) );\n\tconst g = sub( 1, div( 1, Desaturation.mul( peak.sub( newPeak ) ).add( 1 ) ) );\n\n\treturn mix( color, vec3( newPeak ), g );\n\n} ).setLayout( {\n\tname: 'neutralToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\nclass CodeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'CodeNode';\n\n\t}\n\n\tconstructor( code = '', includes = [], language = '' ) {\n\n\t\tsuper( 'code' );\n\n\t\tthis.isCodeNode = true;\n\n\t\tthis.code = code;\n\t\tthis.language = language;\n\n\t\tthis.includes = includes;\n\n\t}\n\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\tsetIncludes( includes ) {\n\n\t\tthis.includes = includes;\n\n\t\treturn this;\n\n\t}\n\n\tgetIncludes( /*builder*/ ) {\n\n\t\treturn this.includes;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst includes = this.getIncludes( builder );\n\n\t\tfor ( const include of includes ) {\n\n\t\t\tinclude.build( builder );\n\n\t\t}\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, this.getNodeType( builder ) );\n\t\tnodeCode.code = this.code;\n\n\t\treturn nodeCode.code;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.code = this.code;\n\t\tdata.language = this.language;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.code = data.code;\n\t\tthis.language = data.language;\n\n\t}\n\n}\n\nconst code = /*@__PURE__*/ nodeProxy( CodeNode );\n\nconst js = ( src, includes ) => code( src, includes, 'js' );\nconst wgsl = ( src, includes ) => code( src, includes, 'wgsl' );\nconst glsl = ( src, includes ) => code( src, includes, 'glsl' );\n\nclass FunctionNode extends CodeNode {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionNode';\n\n\t}\n\n\tconstructor( code = '', includes = [], language = '' ) {\n\n\t\tsuper( code, includes, language );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).type;\n\n\t}\n\n\tgetInputs( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).inputs;\n\n\t}\n\n\tgetNodeFunction( builder ) {\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tlet nodeFunction = nodeData.nodeFunction;\n\n\t\tif ( nodeFunction === undefined ) {\n\n\t\t\tnodeFunction = builder.parser.parseFunction( this.code );\n\n\t\t\tnodeData.nodeFunction = nodeFunction;\n\n\t\t}\n\n\t\treturn nodeFunction;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tsuper.generate( builder );\n\n\t\tconst nodeFunction = this.getNodeFunction( builder );\n\n\t\tconst name = nodeFunction.name;\n\t\tconst type = nodeFunction.type;\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, type );\n\n\t\tif ( name !== '' ) {\n\n\t\t\t// use a custom property name\n\n\t\t\tnodeCode.name = name;\n\n\t\t}\n\n\t\tconst propertyName = builder.getPropertyName( nodeCode );\n\n\t\tconst code = this.getNodeFunction( builder ).getCode( propertyName );\n\n\t\tnodeCode.code = code + '\\n';\n\n\t\tif ( output === 'property' ) {\n\n\t\t\treturn propertyName;\n\n\t\t} else {\n\n\t\t\treturn builder.format( `${ propertyName }()`, type, output );\n\n\t\t}\n\n\t}\n\n}\n\nconst nativeFn = ( code, includes = [], language = '' ) => {\n\n\tfor ( let i = 0; i < includes.length; i ++ ) {\n\n\t\tconst include = includes[ i ];\n\n\t\t// TSL Function: glslFn, wgslFn\n\n\t\tif ( typeof include === 'function' ) {\n\n\t\t\tincludes[ i ] = include.functionNode;\n\n\t\t}\n\n\t}\n\n\tconst functionNode = nodeObject( new FunctionNode( code, includes, language ) );\n\n\tconst fn = ( ...params ) => functionNode.call( ...params );\n\tfn.functionNode = functionNode;\n\n\treturn fn;\n\n};\n\nconst glslFn = ( code, includes ) => nativeFn( code, includes, 'glsl' );\nconst wgslFn = ( code, includes ) => nativeFn( code, includes, 'wgsl' );\n\nclass ScriptableValueNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScriptableValueNode';\n\n\t}\n\n\tconstructor( value = null ) {\n\n\t\tsuper();\n\n\t\tthis._value = value;\n\t\tthis._cache = null;\n\n\t\tthis.inputType = null;\n\t\tthis.outpuType = null;\n\n\t\tthis.events = new EventDispatcher();\n\n\t\tthis.isScriptableValueNode = true;\n\n\t}\n\n\tget isScriptableOutputNode() {\n\n\t\treturn this.outputType !== null;\n\n\t}\n\n\tset value( val ) {\n\n\t\tif ( this._value === val ) return;\n\n\t\tif ( this._cache && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer ) {\n\n\t\t\tURL.revokeObjectURL( this._cache );\n\n\t\t\tthis._cache = null;\n\n\t\t}\n\n\t\tthis._value = val;\n\n\t\tthis.events.dispatchEvent( { type: 'change' } );\n\n\t\tthis.refresh();\n\n\t}\n\n\tget value() {\n\n\t\treturn this._value;\n\n\t}\n\n\trefresh() {\n\n\t\tthis.events.dispatchEvent( { type: 'refresh' } );\n\n\t}\n\n\tgetValue() {\n\n\t\tconst value = this.value;\n\n\t\tif ( value && this._cache === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer ) {\n\n\t\t\tthis._cache = URL.createObjectURL( new Blob( [ value.value ] ) );\n\n\t\t} else if ( value && value.value !== null && value.value !== undefined && (\n\t\t\t( ( this.inputType === 'URL' || this.inputType === 'String' ) && typeof value.value === 'string' ) ||\n\t\t\t( this.inputType === 'Number' && typeof value.value === 'number' ) ||\n\t\t\t( this.inputType === 'Vector2' && value.value.isVector2 ) ||\n\t\t\t( this.inputType === 'Vector3' && value.value.isVector3 ) ||\n\t\t\t( this.inputType === 'Vector4' && value.value.isVector4 ) ||\n\t\t\t( this.inputType === 'Color' && value.value.isColor ) ||\n\t\t\t( this.inputType === 'Matrix3' && value.value.isMatrix3 ) ||\n\t\t\t( this.inputType === 'Matrix4' && value.value.isMatrix4 )\n\t\t) ) {\n\n\t\t\treturn value.value;\n\n\t\t}\n\n\t\treturn this._cache || value;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.value && this.value.isNode ? this.value.getNodeType( builder ) : 'float';\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.value && this.value.isNode ? this.value : float();\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tif ( this.value !== null ) {\n\n\t\t\tif ( this.inputType === 'ArrayBuffer' ) {\n\n\t\t\t\tdata.value = arrayBufferToBase64( this.value );\n\n\t\t\t} else {\n\n\t\t\t\tdata.value = this.value ? this.value.toJSON( data.meta ).uuid : null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdata.value = null;\n\n\t\t}\n\n\t\tdata.inputType = this.inputType;\n\t\tdata.outputType = this.outputType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tlet value = null;\n\n\t\tif ( data.value !== null ) {\n\n\t\t\tif ( data.inputType === 'ArrayBuffer' ) {\n\n\t\t\t\tvalue = base64ToArrayBuffer( data.value );\n\n\t\t\t} else if ( data.inputType === 'Texture' ) {\n\n\t\t\t\tvalue = data.meta.textures[ data.value ];\n\n\t\t\t} else {\n\n\t\t\t\tvalue = data.meta.nodes[ data.value ] || null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tthis.inputType = data.inputType;\n\t\tthis.outputType = data.outputType;\n\n\t}\n\n}\n\nconst scriptableValue = /*@__PURE__*/ nodeProxy( ScriptableValueNode );\n\nclass Resources extends Map {\n\n\tget( key, callback = null, ...params ) {\n\n\t\tif ( this.has( key ) ) return super.get( key );\n\n\t\tif ( callback !== null ) {\n\n\t\t\tconst value = callback( ...params );\n\t\t\tthis.set( key, value );\n\t\t\treturn value;\n\n\t\t}\n\n\t}\n\n}\n\nclass Parameters {\n\n\tconstructor( scriptableNode ) {\n\n\t\tthis.scriptableNode = scriptableNode;\n\n\t}\n\n\tget parameters() {\n\n\t\treturn this.scriptableNode.parameters;\n\n\t}\n\n\tget layout() {\n\n\t\treturn this.scriptableNode.getLayout();\n\n\t}\n\n\tgetInputLayout( id ) {\n\n\t\treturn this.scriptableNode.getInputLayout( id );\n\n\t}\n\n\tget( name ) {\n\n\t\tconst param = this.parameters[ name ];\n\t\tconst value = param ? param.getValue() : null;\n\n\t\treturn value;\n\n\t}\n\n}\n\nconst ScriptableNodeResources = new Resources();\n\nclass ScriptableNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScriptableNode';\n\n\t}\n\n\tconstructor( codeNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\tthis.codeNode = codeNode;\n\t\tthis.parameters = parameters;\n\n\t\tthis._local = new Resources();\n\t\tthis._output = scriptableValue();\n\t\tthis._outputs = {};\n\t\tthis._source = this.source;\n\t\tthis._method = null;\n\t\tthis._object = null;\n\t\tthis._value = null;\n\t\tthis._needsOutputUpdate = true;\n\n\t\tthis.onRefresh = this.onRefresh.bind( this );\n\n\t\tthis.isScriptableNode = true;\n\n\t}\n\n\tget source() {\n\n\t\treturn this.codeNode ? this.codeNode.code : '';\n\n\t}\n\n\tsetLocal( name, value ) {\n\n\t\treturn this._local.set( name, value );\n\n\t}\n\n\tgetLocal( name ) {\n\n\t\treturn this._local.get( name );\n\n\t}\n\n\tonRefresh() {\n\n\t\tthis._refresh();\n\n\t}\n\n\tgetInputLayout( id ) {\n\n\t\tfor ( const element of this.getLayout() ) {\n\n\t\t\tif ( element.inputType && ( element.id === id || element.name === id ) ) {\n\n\t\t\t\treturn element;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetOutputLayout( id ) {\n\n\t\tfor ( const element of this.getLayout() ) {\n\n\t\t\tif ( element.outputType && ( element.id === id || element.name === id ) ) {\n\n\t\t\t\treturn element;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetOutput( name, value ) {\n\n\t\tconst outputs = this._outputs;\n\n\t\tif ( outputs[ name ] === undefined ) {\n\n\t\t\toutputs[ name ] = scriptableValue( value );\n\n\t\t} else {\n\n\t\t\toutputs[ name ].value = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetOutput( name ) {\n\n\t\treturn this._outputs[ name ];\n\n\t}\n\n\tgetParameter( name ) {\n\n\t\treturn this.parameters[ name ];\n\n\t}\n\n\tsetParameter( name, value ) {\n\n\t\tconst parameters = this.parameters;\n\n\t\tif ( value && value.isScriptableNode ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t\tparameters[ name ] = value;\n\t\t\tparameters[ name ].getDefaultOutput().events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else if ( value && value.isScriptableValueNode ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t\tparameters[ name ] = value;\n\t\t\tparameters[ name ].events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else if ( parameters[ name ] === undefined ) {\n\n\t\t\tparameters[ name ] = scriptableValue( value );\n\t\t\tparameters[ name ].events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else {\n\n\t\t\tparameters[ name ].value = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.getDefaultOutput().getValue();\n\n\t}\n\n\tdeleteParameter( name ) {\n\n\t\tlet valueNode = this.parameters[ name ];\n\n\t\tif ( valueNode ) {\n\n\t\t\tif ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();\n\n\t\t\tvalueNode.events.removeEventListener( 'refresh', this.onRefresh );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclearParameters() {\n\n\t\tfor ( const name of Object.keys( this.parameters ) ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tcall( name, ...params ) {\n\n\t\tconst object = this.getObject();\n\t\tconst method = object[ name ];\n\n\t\tif ( typeof method === 'function' ) {\n\n\t\t\treturn method( ...params );\n\n\t\t}\n\n\t}\n\n\tasync callAsync( name, ...params ) {\n\n\t\tconst object = this.getObject();\n\t\tconst method = object[ name ];\n\n\t\tif ( typeof method === 'function' ) {\n\n\t\t\treturn method.constructor.name === 'AsyncFunction' ? await method( ...params ) : method( ...params );\n\n\t\t}\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.getDefaultOutputNode().getNodeType( builder );\n\n\t}\n\n\trefresh( output = null ) {\n\n\t\tif ( output !== null ) {\n\n\t\t\tthis.getOutput( output ).refresh();\n\n\t\t} else {\n\n\t\t\tthis._refresh();\n\n\t\t}\n\n\t}\n\n\tgetObject() {\n\n\t\tif ( this.needsUpdate ) this.dispose();\n\t\tif ( this._object !== null ) return this._object;\n\n\t\t//\n\n\t\tconst refresh = () => this.refresh();\n\t\tconst setOutput = ( id, value ) => this.setOutput( id, value );\n\n\t\tconst parameters = new Parameters( this );\n\n\t\tconst THREE = ScriptableNodeResources.get( 'THREE' );\n\t\tconst TSL = ScriptableNodeResources.get( 'TSL' );\n\n\t\tconst method = this.getMethod( this.codeNode );\n\t\tconst params = [ parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE, TSL ];\n\n\t\tthis._object = method( ...params );\n\n\t\tconst layout = this._object.layout;\n\n\t\tif ( layout ) {\n\n\t\t\tif ( layout.cache === false ) {\n\n\t\t\t\tthis._local.clear();\n\n\t\t\t}\n\n\t\t\t// default output\n\t\t\tthis._output.outputType = layout.outputType || null;\n\n\t\t\tif ( Array.isArray( layout.elements ) ) {\n\n\t\t\t\tfor ( const element of layout.elements ) {\n\n\t\t\t\t\tconst id = element.id || element.name;\n\n\t\t\t\t\tif ( element.inputType ) {\n\n\t\t\t\t\t\tif ( this.getParameter( id ) === undefined ) this.setParameter( id, null );\n\n\t\t\t\t\t\tthis.getParameter( id ).inputType = element.inputType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( element.outputType ) {\n\n\t\t\t\t\t\tif ( this.getOutput( id ) === undefined ) this.setOutput( id, null );\n\n\t\t\t\t\t\tthis.getOutput( id ).outputType = element.outputType;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this._object;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tfor ( const name in this.parameters ) {\n\n\t\t\tlet valueNode = this.parameters[ name ];\n\n\t\t\tif ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();\n\n\t\t\tvalueNode.events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t}\n\n\t}\n\n\tgetLayout() {\n\n\t\treturn this.getObject().layout;\n\n\t}\n\n\tgetDefaultOutputNode() {\n\n\t\tconst output = this.getDefaultOutput().value;\n\n\t\tif ( output && output.isNode ) {\n\n\t\t\treturn output;\n\n\t\t}\n\n\t\treturn float();\n\n\t}\n\n\tgetDefaultOutput()\t{\n\n\t\treturn this._exec()._output;\n\n\t}\n\n\tgetMethod() {\n\n\t\tif ( this.needsUpdate ) this.dispose();\n\t\tif ( this._method !== null ) return this._method;\n\n\t\t//\n\n\t\tconst parametersProps = [ 'parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL' ];\n\t\tconst interfaceProps = [ 'layout', 'init', 'main', 'dispose' ];\n\n\t\tconst properties = interfaceProps.join( ', ' );\n\t\tconst declarations = 'var ' + properties + '; var output = {};\\n';\n\t\tconst returns = '\\nreturn { ...output, ' + properties + ' };';\n\n\t\tconst code = declarations + this.codeNode.code + returns;\n\n\t\t//\n\n\t\tthis._method = new Function( ...parametersProps, code );\n\n\t\treturn this._method;\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this._method === null ) return;\n\n\t\tif ( this._object && typeof this._object.dispose === 'function' ) {\n\n\t\t\tthis._object.dispose();\n\n\t\t}\n\n\t\tthis._method = null;\n\t\tthis._object = null;\n\t\tthis._source = null;\n\t\tthis._value = null;\n\t\tthis._needsOutputUpdate = true;\n\t\tthis._output.value = null;\n\t\tthis._outputs = {};\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.getDefaultOutputNode();\n\n\t}\n\n\tgetCacheKey( force ) {\n\n\t\tconst values = [ hashString( this.source ), this.getDefaultOutputNode().getCacheKey( force ) ];\n\n\t\tfor ( const param in this.parameters ) {\n\n\t\t\tvalues.push( this.parameters[ param ].getCacheKey( force ) );\n\n\t\t}\n\n\t\treturn hashArray( values );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.dispose();\n\n\t}\n\n\tget needsUpdate() {\n\n\t\treturn this.source !== this._source;\n\n\t}\n\n\t_exec()\t{\n\n\t\tif ( this.codeNode === null ) return this;\n\n\t\tif ( this._needsOutputUpdate === true ) {\n\n\t\t\tthis._value = this.call( 'main' );\n\n\t\t\tthis._needsOutputUpdate = false;\n\n\t\t}\n\n\t\tthis._output.value = this._value;\n\n\t\treturn this;\n\n\t}\n\n\t_refresh() {\n\n\t\tthis.needsUpdate = true;\n\n\t\tthis._exec();\n\n\t\tthis._output.refresh();\n\n\t}\n\n}\n\nconst scriptable = /*@__PURE__*/ nodeProxy( ScriptableNode );\n\nclass FogNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'FogNode';\n\n\t}\n\n\tconstructor( colorNode, factorNode ) {\n\n\t\tsuper( 'float' );\n\n\t\tthis.isFogNode = true;\n\n\t\tthis.colorNode = colorNode;\n\t\tthis.factorNode = factorNode;\n\n\t}\n\n\tgetViewZNode( builder ) {\n\n\t\tlet viewZ;\n\n\t\tconst getViewZ = builder.context.getViewZ;\n\n\t\tif ( getViewZ !== undefined ) {\n\n\t\t\tviewZ = getViewZ( this );\n\n\t\t}\n\n\t\treturn ( viewZ || positionView.z ).negate();\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.factorNode;\n\n\t}\n\n}\n\nconst fog = /*@__PURE__*/ nodeProxy( FogNode );\n\nclass FogRangeNode extends FogNode {\n\n\tstatic get type() {\n\n\t\treturn 'FogRangeNode';\n\n\t}\n\n\tconstructor( colorNode, nearNode, farNode ) {\n\n\t\tsuper( colorNode );\n\n\t\tthis.isFogRangeNode = true;\n\n\t\tthis.nearNode = nearNode;\n\t\tthis.farNode = farNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst viewZ = this.getViewZNode( builder );\n\n\t\treturn smoothstep( this.nearNode, this.farNode, viewZ );\n\n\t}\n\n}\n\nconst rangeFog = /*@__PURE__*/ nodeProxy( FogRangeNode );\n\nclass FogExp2Node extends FogNode {\n\n\tstatic get type() {\n\n\t\treturn 'FogExp2Node';\n\n\t}\n\n\tconstructor( colorNode, densityNode ) {\n\n\t\tsuper( colorNode );\n\n\t\tthis.isFogExp2Node = true;\n\n\t\tthis.densityNode = densityNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst viewZ = this.getViewZNode( builder );\n\t\tconst density = this.densityNode;\n\n\t\treturn density.mul( density, viewZ, viewZ ).negate().exp().oneMinus();\n\n\t}\n\n}\n\nconst densityFog = /*@__PURE__*/ nodeProxy( FogExp2Node );\n\nlet min = null;\nlet max = null;\n\nclass RangeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'RangeNode';\n\n\t}\n\n\tconstructor( minNode = float(), maxNode = float() ) {\n\n\t\tsuper();\n\n\t\tthis.minNode = minNode;\n\t\tthis.maxNode = maxNode;\n\n\t}\n\n\tgetVectorLength( builder ) {\n\n\t\tconst minLength = builder.getTypeLength( getValueType( this.minNode.value ) );\n\t\tconst maxLength = builder.getTypeLength( getValueType( this.maxNode.value ) );\n\n\t\treturn minLength > maxLength ? minLength : maxLength;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn builder.object.count > 1 ? builder.getTypeFromLength( this.getVectorLength( builder ) ) : 'float';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst object = builder.object;\n\n\t\tlet output = null;\n\n\t\tif ( object.count > 1 ) {\n\n\t\t\tconst minValue = this.minNode.value;\n\t\t\tconst maxValue = this.maxNode.value;\n\n\t\t\tconst minLength = builder.getTypeLength( getValueType( minValue ) );\n\t\t\tconst maxLength = builder.getTypeLength( getValueType( maxValue ) );\n\n\t\t\tmin = min || new Vector4();\n\t\t\tmax = max || new Vector4();\n\n\t\t\tmin.setScalar( 0 );\n\t\t\tmax.setScalar( 0 );\n\n\t\t\tif ( minLength === 1 ) min.setScalar( minValue );\n\t\t\telse if ( minValue.isColor ) min.set( minValue.r, minValue.g, minValue.b );\n\t\t\telse min.set( minValue.x, minValue.y, minValue.z || 0, minValue.w || 0 );\n\n\t\t\tif ( maxLength === 1 ) max.setScalar( maxValue );\n\t\t\telse if ( maxValue.isColor ) max.set( maxValue.r, maxValue.g, maxValue.b );\n\t\t\telse max.set( maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0 );\n\n\t\t\tconst stride = 4;\n\n\t\t\tconst length = stride * object.count;\n\t\t\tconst array = new Float32Array( length );\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tconst index = i % stride;\n\n\t\t\t\tconst minElementValue = min.getComponent( index );\n\t\t\t\tconst maxElementValue = max.getComponent( index );\n\n\t\t\t\tarray[ i ] = MathUtils.lerp( minElementValue, maxElementValue, Math.random() );\n\n\t\t\t}\n\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( object.count <= 4096 ) {\n\n\t\t\t\toutput = buffer( array, 'vec4', object.count ).element( instanceIndex ).convert( nodeType );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: Improve anonymous buffer attribute creation removing this part\n\t\t\t\tconst bufferAttribute = new InstancedBufferAttribute( array, 4 );\n\t\t\t\tbuilder.geometry.setAttribute( '__range' + this.id, bufferAttribute );\n\n\t\t\t\toutput = instancedBufferAttribute( bufferAttribute ).convert( nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\toutput = float( 0 );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nconst range = /*@__PURE__*/ nodeProxy( RangeNode );\n\nclass ComputeBuiltinNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ComputeBuiltinNode';\n\n\t}\n\n\tconstructor( builtinName, nodeType ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis._builtinName = builtinName;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.getBuiltinName( builder );\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.nodeType;\n\n\t}\n\n\tsetBuiltinName( builtinName ) {\n\n\t\tthis._builtinName = builtinName;\n\n\t\treturn this;\n\n\t}\n\n\tgetBuiltinName( /*builder*/ ) {\n\n\t\treturn this._builtinName;\n\n\t}\n\n\thasBuiltin( builder ) {\n\n\t\tbuilder.hasBuiltin( this._builtinName );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst builtinName = this.getBuiltinName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tif ( builder.shaderStage === 'compute' ) {\n\n\t\t\treturn builder.format( builtinName, nodeType, output );\n\n\t\t} else {\n\n\t\t\tconsole.warn( `ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage` );\n\t\t\treturn builder.generateConst( nodeType );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.global = this.global;\n\t\tdata._builtinName = this._builtinName;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.global = data.global;\n\t\tthis._builtinName = data._builtinName;\n\n\t}\n\n}\n\nconst computeBuiltin = ( name, nodeType ) => nodeObject( new ComputeBuiltinNode( name, nodeType ) );\n\nconst numWorkgroups = /*@__PURE__*/ computeBuiltin( 'numWorkgroups', 'uvec3' );\nconst workgroupId = /*@__PURE__*/ computeBuiltin( 'workgroupId', 'uvec3' );\nconst localId = /*@__PURE__*/ computeBuiltin( 'localId', 'uvec3' );\nconst subgroupSize = /*@__PURE__*/ computeBuiltin( 'subgroupSize', 'uint' );\n\nclass BarrierNode extends Node {\n\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { scope } = this;\n\t\tconst { renderer } = builder;\n\n\t\tif ( renderer.backend.isWebGLBackend === true ) {\n\n\t\t\tbuilder.addFlowCode( `\\t// ${scope}Barrier \\n` );\n\n\t\t} else {\n\n\t\t\tbuilder.addLineFlowCode( `${scope}Barrier()`, this );\n\n\t\t}\n\n\t}\n\n}\n\nconst barrier = nodeProxy( BarrierNode );\n\nconst workgroupBarrier = () => barrier( 'workgroup' ).append();\nconst storageBarrier = () => barrier( 'storage' ).append();\nconst textureBarrier = () => barrier( 'texture' ).append();\n\nclass WorkgroupInfoElementNode extends ArrayElementNode {\n\n\tconstructor( workgroupInfoNode, indexNode ) {\n\n\t\tsuper( workgroupInfoNode, indexNode );\n\n\t\tthis.isWorkgroupInfoElementNode = true;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tconst isAssignContext = builder.context.assign;\n\t\tsnippet = super.generate( builder );\n\n\t\tif ( isAssignContext !== true ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tsnippet = builder.format( snippet, type, output );\n\n\t\t}\n\n\t\t// TODO: Possibly activate clip distance index on index access rather than from clipping context\n\n\t\treturn snippet;\n\n\t}\n\n}\n\n\nclass WorkgroupInfoNode extends Node {\n\n\tconstructor( scope, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( bufferType );\n\n\t\tthis.bufferType = bufferType;\n\t\tthis.bufferCount = bufferCount;\n\n\t\tthis.isWorkgroupInfoNode = true;\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tlabel( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.uuid;\n\n\t}\n\n\tsetScope( scope ) {\n\n\t\tthis.scope = scope;\n\n\t\treturn this;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn `${this.scope}Array`;\n\n\t}\n\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new WorkgroupInfoElementNode( this, indexNode ) );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn builder.getScopedArray( this.name || `${this.scope}Array_${this.id}`, this.scope.toLowerCase(), this.bufferType, this.bufferCount );\n\n\t}\n\n}\n\nconst workgroupArray = ( type, count ) => nodeObject( new WorkgroupInfoNode( 'Workgroup', type, count ) );\n\nclass AtomicFunctionNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'AtomicFunctionNode';\n\n\t}\n\n\tconstructor( method, pointerNode, valueNode, storeNode = null ) {\n\n\t\tsuper( 'uint' );\n\n\t\tthis.method = method;\n\n\t\tthis.pointerNode = pointerNode;\n\t\tthis.valueNode = valueNode;\n\t\tthis.storeNode = storeNode;\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\treturn this.pointerNode.getNodeType( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.getInputType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.pointerNode;\n\t\tconst b = this.valueNode;\n\n\t\tconst params = [];\n\n\t\tparams.push( `&${ a.build( builder, inputType ) }` );\n\t\tparams.push( b.build( builder, inputType ) );\n\n\t\tconst methodSnippet = `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`;\n\n\t\tif ( this.storeNode !== null ) {\n\n\t\t\tconst varSnippet = this.storeNode.build( builder, inputType );\n\n\t\t\tbuilder.addLineFlowCode( `${varSnippet} = ${methodSnippet}`, this );\n\n\t\t} else {\n\n\t\t\tbuilder.addLineFlowCode( methodSnippet, this );\n\n\t\t}\n\n\t}\n\n}\n\nAtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';\nAtomicFunctionNode.ATOMIC_STORE = 'atomicStore';\nAtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';\nAtomicFunctionNode.ATOMIC_SUB = 'atomicSub';\nAtomicFunctionNode.ATOMIC_MAX = 'atomicMax';\nAtomicFunctionNode.ATOMIC_MIN = 'atomicMin';\nAtomicFunctionNode.ATOMIC_AND = 'atomicAnd';\nAtomicFunctionNode.ATOMIC_OR = 'atomicOr';\nAtomicFunctionNode.ATOMIC_XOR = 'atomicXor';\n\nconst atomicNode = nodeProxy( AtomicFunctionNode );\n\nconst atomicFunc = ( method, pointerNode, valueNode, storeNode ) => {\n\n\tconst node = atomicNode( method, pointerNode, valueNode, storeNode );\n\tnode.append();\n\n\treturn node;\n\n};\n\nconst atomicStore = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode, storeNode );\nconst atomicAdd = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode, storeNode );\nconst atomicSub = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode, storeNode );\nconst atomicMax = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode, storeNode );\nconst atomicMin = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode, storeNode );\nconst atomicAnd = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode, storeNode );\nconst atomicOr = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode, storeNode );\nconst atomicXor = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode, storeNode );\n\nlet uniformsLib;\n\nfunction getLightData( light ) {\n\n\tuniformsLib = uniformsLib || new WeakMap();\n\n\tlet uniforms = uniformsLib.get( light );\n\n\tif ( uniforms === undefined ) uniformsLib.set( light, uniforms = {} );\n\n\treturn uniforms;\n\n}\n\nfunction lightShadowMatrix( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.shadowMatrix || ( data.shadowMatrix = uniform( 'mat4' ).setGroup( renderGroup ).onRenderUpdate( () => {\n\n\t\tlight.shadow.updateMatrices( light );\n\n\t\treturn light.shadow.matrix;\n\n\t} ) );\n\n}\n\nfunction lightProjectionUV( light ) {\n\n\tconst data = getLightData( light );\n\n\tif ( data.projectionUV === undefined ) {\n\n\t\tconst spotLightCoord = lightShadowMatrix( light ).mul( positionWorld );\n\n\t\tdata.projectionUV = spotLightCoord.xyz.div( spotLightCoord.w );\n\n\n\t}\n\n\treturn data.projectionUV;\n\n}\n\nfunction lightPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.position || ( data.position = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.matrixWorld ) ) );\n\n}\n\nfunction lightTargetPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.targetPosition || ( data.targetPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.target.matrixWorld ) ) );\n\n}\n\nfunction lightViewPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.viewPosition || ( data.viewPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => {\n\n\t\tself.value = self.value || new Vector3();\n\t\tself.value.setFromMatrixPosition( light.matrixWorld );\n\n\t\tself.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t} ) );\n\n}\n\nconst lightTargetDirection = ( light ) => cameraViewMatrix.transformDirection( lightPosition( light ).sub( lightTargetPosition( light ) ) );\n\nconst sortLights = ( lights ) => {\n\n\treturn lights.sort( ( a, b ) => a.id - b.id );\n\n};\n\nconst getLightNodeById = ( id, lightNodes ) => {\n\n\tfor ( const lightNode of lightNodes ) {\n\n\t\tif ( lightNode.isAnalyticLightNode && lightNode.light.id === id ) {\n\n\t\t\treturn lightNode;\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n};\n\nconst _lightsNodeRef = /*@__PURE__*/ new WeakMap();\n\nclass LightsNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LightsNode';\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.totalDiffuseNode = vec3().toVar( 'totalDiffuse' );\n\t\tthis.totalSpecularNode = vec3().toVar( 'totalSpecular' );\n\n\t\tthis.outgoingLightNode = vec3().toVar( 'outgoingLight' );\n\n\t\tthis._lights = [];\n\n\t\tthis._lightNodes = null;\n\t\tthis._lightNodesHash = null;\n\n\t\tthis.global = true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\tif ( this._lightNodesHash === null ) {\n\n\t\t\tif ( this._lightNodes === null ) this.setupLightsNode( builder );\n\n\t\t\tconst hash = [];\n\n\t\t\tfor ( const lightNode of this._lightNodes ) {\n\n\t\t\t\thash.push( lightNode.getSelf().getHash() );\n\n\t\t\t}\n\n\t\t\tthis._lightNodesHash = 'lights-' + hash.join( ',' );\n\n\t\t}\n\n\t\treturn this._lightNodesHash;\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tconst properties = builder.getDataFromNode( this );\n\n\t\tfor ( const node of properties.nodes ) {\n\n\t\t\tnode.build( builder );\n\n\t\t}\n\n\t}\n\n\tsetupLightsNode( builder ) {\n\n\t\tconst lightNodes = [];\n\n\t\tconst previousLightNodes = this._lightNodes;\n\n\t\tconst lights = sortLights( this._lights );\n\t\tconst nodeLibrary = builder.renderer.library;\n\n\t\tfor ( const light of lights ) {\n\n\t\t\tif ( light.isNode ) {\n\n\t\t\t\tlightNodes.push( nodeObject( light ) );\n\n\t\t\t} else {\n\n\t\t\t\tlet lightNode = null;\n\n\t\t\t\tif ( previousLightNodes !== null ) {\n\n\t\t\t\t\tlightNode = getLightNodeById( light.id, previousLightNodes ); // resuse existing light node\n\n\t\t\t\t}\n\n\t\t\t\tif ( lightNode === null ) {\n\n\t\t\t\t\tconst lightNodeClass = nodeLibrary.getLightNodeClass( light.constructor );\n\n\t\t\t\t\tif ( lightNodeClass === null ) {\n\n\t\t\t\t\t\tconsole.warn( `LightsNode.setupNodeLights: Light node not found for ${ light.constructor.name }` );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet lightNode = null;\n\n\t\t\t\t\tif ( ! _lightsNodeRef.has( light ) ) {\n\n\t\t\t\t\t\tlightNode = nodeObject( new lightNodeClass( light ) );\n\t\t\t\t\t\t_lightsNodeRef.set( light, lightNode );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlightNode = _lightsNodeRef.get( light );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlightNodes.push( lightNode );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._lightNodes = lightNodes;\n\n\t}\n\n\tsetupLights( builder, lightNodes ) {\n\n\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\tlightNode.build( builder );\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( this._lightNodes === null ) this.setupLightsNode( builder );\n\n\t\tconst context = builder.context;\n\t\tconst lightingModel = context.lightingModel;\n\n\t\tlet outgoingLightNode = this.outgoingLightNode;\n\n\t\tif ( lightingModel ) {\n\n\t\t\tconst { _lightNodes, totalDiffuseNode, totalSpecularNode } = this;\n\n\t\t\tcontext.outgoingLight = outgoingLightNode;\n\n\t\t\tconst stack = builder.addStack();\n\n\t\t\t//\n\n\t\t\tconst properties = builder.getDataFromNode( this );\n\t\t\tproperties.nodes = stack.nodes;\n\n\t\t\t//\n\n\t\t\tlightingModel.start( context, stack, builder );\n\n\t\t\t// lights\n\n\t\t\tthis.setupLights( builder, _lightNodes );\n\n\t\t\t//\n\n\t\t\tlightingModel.indirect( context, stack, builder );\n\n\t\t\t//\n\n\t\t\tconst { backdrop, backdropAlpha } = context;\n\t\t\tconst { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context.reflectedLight;\n\n\t\t\tlet totalDiffuse = directDiffuse.add( indirectDiffuse );\n\n\t\t\tif ( backdrop !== null ) {\n\n\t\t\t\tif ( backdropAlpha !== null ) {\n\n\t\t\t\t\ttotalDiffuse = vec3( backdropAlpha.mix( totalDiffuse, backdrop ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttotalDiffuse = vec3( backdrop );\n\n\t\t\t\t}\n\n\t\t\t\tcontext.material.transparent = true;\n\n\t\t\t}\n\n\t\t\ttotalDiffuseNode.assign( totalDiffuse );\n\t\t\ttotalSpecularNode.assign( directSpecular.add( indirectSpecular ) );\n\n\t\t\toutgoingLightNode.assign( totalDiffuseNode.add( totalSpecularNode ) );\n\n\t\t\t//\n\n\t\t\tlightingModel.finish( context, stack, builder );\n\n\t\t\t//\n\n\t\t\toutgoingLightNode = outgoingLightNode.bypass( builder.removeStack() );\n\n\t\t}\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\tsetLights( lights ) {\n\n\t\tthis._lights = lights;\n\n\t\tthis._lightNodes = null;\n\t\tthis._lightNodesHash = null;\n\n\t\treturn this;\n\n\t}\n\n\tgetLights() {\n\n\t\treturn this._lights;\n\n\t}\n\n\tget hasLights() {\n\n\t\treturn this._lights.length > 0;\n\n\t}\n\n}\n\nconst lights = ( lights = [] ) => nodeObject( new LightsNode() ).setLights( lights );\n\nconst shadowMaterialLib = /*@__PURE__*/ new WeakMap();\nconst shadowWorldPosition = /*@__PURE__*/ vec3().toVar( 'shadowWorldPosition' );\n\nconst linearDistance = /*@__PURE__*/ Fn( ( [ position, cameraNear, cameraFar ] ) => {\n\n\tlet dist = positionWorld.sub( position ).length();\n\tdist = dist.sub( cameraNear ).div( cameraFar.sub( cameraNear ) );\n\tdist = dist.saturate(); // clamp to [ 0, 1 ]\n\n\treturn dist;\n\n} );\n\nconst linearShadowDistance = ( light ) => {\n\n\tconst camera = light.shadow.camera;\n\n\tconst nearDistance = reference( 'near', 'float', camera ).setGroup( renderGroup );\n\tconst farDistance = reference( 'far', 'float', camera ).setGroup( renderGroup );\n\n\tconst referencePosition = objectPosition( light );\n\n\treturn linearDistance( referencePosition, nearDistance, farDistance );\n\n};\n\nconst getShadowMaterial = ( light ) => {\n\n\tlet material = shadowMaterialLib.get( light );\n\n\tif ( material === undefined ) {\n\n\t\tconst depthNode = light.isPointLight ? linearShadowDistance( light ) : null;\n\n\t\tmaterial = new NodeMaterial();\n\t\tmaterial.colorNode = vec4( 0, 0, 0, 1 );\n\t\tmaterial.depthNode = depthNode;\n\t\tmaterial.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode\n\t\tmaterial.blending = NoBlending;\n\t\tmaterial.name = 'ShadowMaterial';\n\n\t\tshadowMaterialLib.set( light, material );\n\n\t}\n\n\treturn material;\n\n};\n\nconst BasicShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord } ) => {\n\n\treturn texture( depthTexture, shadowCoord.xy ).compare( shadowCoord.z );\n\n} );\n\nconst PCFShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow } ) => {\n\n\tconst depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );\n\n\tconst mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\n\tconst texelSize = vec2( 1 ).div( mapSize );\n\tconst dx0 = texelSize.x.negate().mul( radius );\n\tconst dy0 = texelSize.y.negate().mul( radius );\n\tconst dx1 = texelSize.x.mul( radius );\n\tconst dy1 = texelSize.y.mul( radius );\n\tconst dx2 = dx0.div( 2 );\n\tconst dy2 = dy0.div( 2 );\n\tconst dx3 = dx1.div( 2 );\n\tconst dy3 = dy1.div( 2 );\n\n\treturn add(\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy, shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n\t).mul( 1 / 17 );\n\n} );\n\nconst PCFSoftShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow } ) => {\n\n\tconst depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );\n\n\tconst mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\n\tconst texelSize = vec2( 1 ).div( mapSize );\n\tconst dx = texelSize.x;\n\tconst dy = texelSize.y;\n\n\tconst uv = shadowCoord.xy;\n\tconst f = fract( uv.mul( mapSize ).add( 0.5 ) );\n\tuv.subAssign( f.mul( texelSize ) );\n\n\treturn add(\n\t\tdepthCompare( uv, shadowCoord.z ),\n\t\tdepthCompare( uv.add( vec2( dx, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( uv.add( vec2( 0, dy ) ), shadowCoord.z ),\n\t\tdepthCompare( uv.add( texelSize ), shadowCoord.z ),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx.negate(), 0 ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), 0 ) ), shadowCoord.z ),\n\t\t\tf.x\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy ) ), shadowCoord.z ),\n\t\t\tf.x\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( 0, dy.negate() ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( 0, dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\tf.y\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx, dy.negate() ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx, dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\tf.y\n\t\t),\n\t\tmix(\n\t\t\tmix(\n\t\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy.negate() ) ), shadowCoord.z ),\n\t\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy.negate() ) ), shadowCoord.z ),\n\t\t\t\tf.x\n\t\t\t),\n\t\t\tmix(\n\t\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\t\tf.x\n\t\t\t),\n\t\t\tf.y\n\t\t)\n\t).mul( 1 / 9 );\n\n} );\n\n// VSM\n\nconst VSMShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord } ) => {\n\n\tconst occlusion = float( 1 ).toVar();\n\n\tconst distribution = texture( depthTexture ).uv( shadowCoord.xy ).rg;\n\n\tconst hardShadow = step( shadowCoord.z, distribution.x );\n\n\tIf( hardShadow.notEqual( float( 1.0 ) ), () => {\n\n\t\tconst distance = shadowCoord.z.sub( distribution.x );\n\t\tconst variance = max$1( 0, distribution.y.mul( distribution.y ) );\n\t\tlet softnessProbability = variance.div( variance.add( distance.mul( distance ) ) ); // Chebeyshevs inequality\n\t\tsoftnessProbability = clamp( sub( softnessProbability, 0.3 ).div( 0.95 - 0.3 ) );\n\t\tocclusion.assign( clamp( max$1( hardShadow, softnessProbability ) ) );\n\n\t} );\n\n\treturn occlusion;\n\n} );\n\nconst VSMPassVertical = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass } ) => {\n\n\tconst mean = float( 0 ).toVar();\n\tconst squaredMean = float( 0 ).toVar();\n\n\tconst uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );\n\tconst uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );\n\n\tLoop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\tconst uvOffset = uvStart.add( float( i ).mul( uvStride ) );\n\n\t\tconst depth = shadowPass.uv( add( screenCoordinate.xy, vec2( 0, uvOffset ).mul( radius ) ).div( size ) ).x;\n\t\tmean.addAssign( depth );\n\t\tsquaredMean.addAssign( depth.mul( depth ) );\n\n\t} );\n\n\tmean.divAssign( samples );\n\tsquaredMean.divAssign( samples );\n\n\tconst std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );\n\treturn vec2( mean, std_dev );\n\n} );\n\nconst VSMPassHorizontal = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass } ) => {\n\n\tconst mean = float( 0 ).toVar();\n\tconst squaredMean = float( 0 ).toVar();\n\n\tconst uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );\n\tconst uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );\n\n\tLoop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\tconst uvOffset = uvStart.add( float( i ).mul( uvStride ) );\n\n\t\tconst distribution = shadowPass.uv( add( screenCoordinate.xy, vec2( uvOffset, 0 ).mul( radius ) ).div( size ) );\n\t\tmean.addAssign( distribution.x );\n\t\tsquaredMean.addAssign( add( distribution.y.mul( distribution.y ), distribution.x.mul( distribution.x ) ) );\n\n\t} );\n\n\tmean.divAssign( samples );\n\tsquaredMean.divAssign( samples );\n\n\tconst std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );\n\treturn vec2( mean, std_dev );\n\n} );\n\nconst _shadowFilterLib = [ BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter ];\n\n//\n\nconst _quadMesh$1 = /*@__PURE__*/ new QuadMesh();\n\nclass ShadowNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ShadowNode';\n\n\t}\n\n\tconstructor( light, shadow = null ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\t\tthis.shadow = shadow || light.shadow;\n\n\t\tthis.shadowMap = null;\n\n\t\tthis.vsmShadowMapVertical = null;\n\t\tthis.vsmShadowMapHorizontal = null;\n\n\t\tthis.vsmMaterialVertical = null;\n\t\tthis.vsmMaterialHorizontal = null;\n\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\t\tthis._node = null;\n\n\t\tthis.isShadowNode = true;\n\n\t}\n\n\tsetupShadowFilter( builder, { filterFn, depthTexture, shadowCoord, shadow } ) {\n\n\t\tconst frustumTest = shadowCoord.x.greaterThanEqual( 0 )\n\t\t\t.and( shadowCoord.x.lessThanEqual( 1 ) )\n\t\t\t.and( shadowCoord.y.greaterThanEqual( 0 ) )\n\t\t\t.and( shadowCoord.y.lessThanEqual( 1 ) )\n\t\t\t.and( shadowCoord.z.lessThanEqual( 1 ) );\n\n\t\tconst shadowNode = filterFn( { depthTexture, shadowCoord, shadow } );\n\n\t\treturn frustumTest.select( shadowNode, float( 1 ) );\n\n\t}\n\n\tsetupShadowCoord( builder, shadowPosition ) {\n\n\t\tconst { shadow } = this;\n\t\tconst { renderer } = builder;\n\n\t\tconst bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );\n\n\t\tlet shadowCoord = shadowPosition;\n\t\tlet coordZ;\n\n\t\tif ( shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true ) {\n\n\t\t\tshadowCoord = shadowCoord.xyz.div( shadowCoord.w );\n\n\t\t\tcoordZ = shadowCoord.z;\n\n\t\t\tif ( renderer.coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\t\tcoordZ = coordZ.mul( 2 ).sub( 1 ); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst w = shadowCoord.w;\n\t\t\tshadowCoord = shadowCoord.xy.div( w ); // <-- Only divide X/Y coords since we don't need Z\n\n\t\t\t// The normally available \"cameraNear\" and \"cameraFar\" nodes cannot be used here because they do not get\n\t\t\t// updated to use the shadow camera. So, we have to declare our own \"local\" ones here.\n\t\t\t// TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?\n\t\t\tconst cameraNearLocal = reference( 'near', 'float', shadow.camera ).setGroup( renderGroup );\n\t\t\tconst cameraFarLocal = reference( 'far', 'float', shadow.camera ).setGroup( renderGroup );\n\n\t\t\tcoordZ = viewZToLogarithmicDepth( w.negate(), cameraNearLocal, cameraFarLocal );\n\n\t\t}\n\n\t\tshadowCoord = vec3(\n\t\t\tshadowCoord.x,\n\t\t\tshadowCoord.y.oneMinus(), // follow webgpu standards\n\t\t\tcoordZ.add( bias )\n\t\t);\n\n\t\treturn shadowCoord;\n\n\t}\n\n\tgetShadowFilterFn( type ) {\n\n\t\treturn _shadowFilterLib[ type ];\n\n\t}\n\n\tsetupShadow( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tconst { light, shadow } = this;\n\n\t\tconst shadowMapType = renderer.shadowMap.type;\n\n\t\tconst depthTexture = new DepthTexture( shadow.mapSize.width, shadow.mapSize.height );\n\t\tdepthTexture.compareFunction = LessCompare;\n\n\t\tconst shadowMap = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height );\n\t\tshadowMap.depthTexture = depthTexture;\n\n\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t// VSM\n\n\t\tif ( shadowMapType === VSMShadowMap ) {\n\n\t\t\tdepthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()\n\n\t\t\tthis.vsmShadowMapVertical = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );\n\t\t\tthis.vsmShadowMapHorizontal = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );\n\n\t\t\tconst shadowPassVertical = texture( depthTexture );\n\t\t\tconst shadowPassHorizontal = texture( this.vsmShadowMapVertical.texture );\n\n\t\t\tconst samples = reference( 'blurSamples', 'float', shadow ).setGroup( renderGroup );\n\t\t\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\t\t\tconst size = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\n\t\t\tlet material = this.vsmMaterialVertical || ( this.vsmMaterialVertical = new NodeMaterial() );\n\t\t\tmaterial.fragmentNode = VSMPassVertical( { samples, radius, size, shadowPass: shadowPassVertical } ).context( builder.getSharedContext() );\n\t\t\tmaterial.name = 'VSMVertical';\n\n\t\t\tmaterial = this.vsmMaterialHorizontal || ( this.vsmMaterialHorizontal = new NodeMaterial() );\n\t\t\tmaterial.fragmentNode = VSMPassHorizontal( { samples, radius, size, shadowPass: shadowPassHorizontal } ).context( builder.getSharedContext() );\n\t\t\tmaterial.name = 'VSMHorizontal';\n\n\t\t}\n\n\t\t//\n\n\t\tconst shadowIntensity = reference( 'intensity', 'float', shadow ).setGroup( renderGroup );\n\t\tconst normalBias = reference( 'normalBias', 'float', shadow ).setGroup( renderGroup );\n\n\t\tconst shadowPosition = lightShadowMatrix( light ).mul( shadowWorldPosition.add( transformedNormalWorld.mul( normalBias ) ) );\n\t\tconst shadowCoord = this.setupShadowCoord( builder, shadowPosition );\n\n\t\t//\n\n\t\tconst filterFn = shadow.filterNode || this.getShadowFilterFn( renderer.shadowMap.type ) || null;\n\n\t\tif ( filterFn === null ) {\n\n\t\t\tthrow new Error( 'THREE.WebGPURenderer: Shadow map type not supported yet.' );\n\n\t\t}\n\n\t\tconst shadowDepthTexture = ( shadowMapType === VSMShadowMap ) ? this.vsmShadowMapHorizontal.texture : depthTexture;\n\n\t\tconst shadowNode = this.setupShadowFilter( builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow } );\n\n\t\tconst shadowColor = texture( shadowMap.texture, shadowCoord );\n\t\tconst shadowOutput = mix( 1, shadowNode.rgb.mix( shadowColor, 1 ), shadowIntensity.mul( shadowColor.a ) ).toVar();\n\n\t\tthis.shadowMap = shadowMap;\n\t\tthis.shadow.map = shadowMap;\n\n\t\treturn shadowOutput;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( builder.renderer.shadowMap.enabled === false ) return;\n\n\t\treturn Fn( ( { material } ) => {\n\n\t\t\tshadowWorldPosition.assign( material.shadowPositionNode || positionWorld );\n\n\t\t\tlet node = this._node;\n\n\t\t\tif ( node === null ) {\n\n\t\t\t\tthis._node = node = this.setupShadow( builder );\n\n\t\t\t}\n\n\t\t\tif ( builder.material.shadowNode ) { // @deprecated, r171\n\n\t\t\t\tconsole.warn( 'THREE.NodeMaterial: \".shadowNode\" is deprecated. Use \".castShadowNode\" instead.' );\n\n\t\t\t}\n\n\t\t\tif ( builder.material.receivedShadowNode ) {\n\n\t\t\t\tnode = builder.material.receivedShadowNode( node );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} )();\n\n\t}\n\n\trenderShadow( frame ) {\n\n\t\tconst { shadow, shadowMap } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tshadowMap.setSize( shadow.mapSize.width, shadow.mapSize.height );\n\n\t\trenderer.render( scene, shadow.camera );\n\n\t}\n\n\tupdateShadow( frame ) {\n\n\t\tconst { shadowMap, light, shadow } = this;\n\t\tconst { renderer, scene, camera } = frame;\n\n\t\tconst shadowType = renderer.shadowMap.type;\n\n\t\tconst depthVersion = shadowMap.depthTexture.version;\n\t\tthis._depthVersionCached = depthVersion;\n\n\t\tconst currentOverrideMaterial = scene.overrideMaterial;\n\n\t\tscene.overrideMaterial = getShadowMaterial( light );\n\n\t\tshadow.camera.layers.mask = camera.layers.mask;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentRenderObjectFunction = renderer.getRenderObjectFunction();\n\t\tconst currentMRT = renderer.getMRT();\n\n\t\trenderer.setMRT( null );\n\n\t\trenderer.setRenderObjectFunction( ( object, ...params ) => {\n\n\t\t\tif ( object.castShadow === true || ( object.receiveShadow && shadowType === VSMShadowMap ) ) {\n\n\t\t\t\trenderer.renderObject( object, ...params );\n\n\t\t\t}\n\n\t\t} );\n\n\t\trenderer.setRenderTarget( shadowMap );\n\n\t\tthis.renderShadow( frame );\n\n\t\trenderer.setRenderObjectFunction( currentRenderObjectFunction );\n\n\t\t// vsm blur pass\n\n\t\tif ( light.isPointLight !== true && shadowType === VSMShadowMap ) {\n\n\t\t\tthis.vsmPass( renderer );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\trenderer.setMRT( currentMRT );\n\n\t\tscene.overrideMaterial = currentOverrideMaterial;\n\n\t}\n\n\tvsmPass( renderer ) {\n\n\t\tconst { shadow } = this;\n\n\t\tthis.vsmShadowMapVertical.setSize( shadow.mapSize.width, shadow.mapSize.height );\n\t\tthis.vsmShadowMapHorizontal.setSize( shadow.mapSize.width, shadow.mapSize.height );\n\n\t\trenderer.setRenderTarget( this.vsmShadowMapVertical );\n\t\t_quadMesh$1.material = this.vsmMaterialVertical;\n\t\t_quadMesh$1.render( renderer );\n\n\t\trenderer.setRenderTarget( this.vsmShadowMapHorizontal );\n\t\t_quadMesh$1.material = this.vsmMaterialHorizontal;\n\t\t_quadMesh$1.render( renderer );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadowMap.dispose();\n\t\tthis.shadowMap = null;\n\n\t\tif ( this.vsmShadowMapVertical !== null ) {\n\n\t\t\tthis.vsmShadowMapVertical.dispose();\n\t\t\tthis.vsmShadowMapVertical = null;\n\n\t\t\tthis.vsmMaterialVertical.dispose();\n\t\t\tthis.vsmMaterialVertical = null;\n\n\t\t}\n\n\t\tif ( this.vsmShadowMapHorizontal !== null ) {\n\n\t\t\tthis.vsmShadowMapHorizontal.dispose();\n\t\t\tthis.vsmShadowMapHorizontal = null;\n\n\t\t\tthis.vsmMaterialHorizontal.dispose();\n\t\t\tthis.vsmMaterialHorizontal = null;\n\n\t\t}\n\n\t\tthis.updateBeforeType = NodeUpdateType.NONE;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { shadow } = this;\n\n\t\tconst needsUpdate = shadow.needsUpdate || shadow.autoUpdate;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tthis.updateShadow( frame );\n\n\t\t\tif ( this.shadowMap.depthTexture.version === this._depthVersionCached ) {\n\n\t\t\t\tshadow.needsUpdate = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst shadow = ( light, shadow ) => nodeObject( new ShadowNode( light, shadow ) );\n\nclass AnalyticLightNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'AnalyticLightNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.color = new Color();\n\t\tthis.colorNode = ( light && light.colorNode ) || uniform( this.color ).setGroup( renderGroup );\n\n\t\tthis.baseColorNode = null;\n\n\t\tthis.shadowNode = null;\n\t\tthis.shadowColorNode = null;\n\n\t\tthis.isAnalyticLightNode = true;\n\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t}\n\n\tgetCacheKey() {\n\n\t\treturn hash$1( super.getCacheKey(), this.light.id, this.light.castShadow ? 1 : 0 );\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.light.uuid;\n\n\t}\n\n\tsetupShadowNode() {\n\n\t\treturn shadow( this.light );\n\n\t}\n\n\tsetupShadow( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tif ( renderer.shadowMap.enabled === false ) return;\n\n\t\tlet shadowColorNode = this.shadowColorNode;\n\n\t\tif ( shadowColorNode === null ) {\n\n\t\t\tconst customShadowNode = this.light.shadow.shadowNode;\n\n\t\t\tlet shadowNode;\n\n\t\t\tif ( customShadowNode !== undefined ) {\n\n\t\t\t\tshadowNode = nodeObject( customShadowNode );\n\n\t\t\t} else {\n\n\t\t\t\tshadowNode = this.setupShadowNode( builder );\n\n\t\t\t}\n\n\t\t\tthis.shadowNode = shadowNode;\n\n\t\t\tthis.shadowColorNode = shadowColorNode = this.colorNode.mul( shadowNode );\n\n\t\t\tthis.baseColorNode = this.colorNode;\n\n\t\t}\n\n\t\t//\n\n\t\tthis.colorNode = shadowColorNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.colorNode = this.baseColorNode || this.colorNode;\n\n\t\tif ( this.light.castShadow ) {\n\n\t\t\tif ( builder.object.receiveShadow ) {\n\n\t\t\t\tthis.setupShadow( builder );\n\n\t\t\t}\n\n\t\t} else if ( this.shadowNode !== null ) {\n\n\t\t\tthis.shadowNode.dispose();\n\t\t\tthis.shadowNode = null;\n\t\t\tthis.shadowColorNode = null;\n\n\t\t}\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tconst { light } = this;\n\n\t\tthis.color.copy( light.color ).multiplyScalar( light.intensity );\n\n\t}\n\n}\n\nconst getDistanceAttenuation = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { lightDistance, cutoffDistance, decayExponent } = inputs;\n\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t// page 32, equation 26: E[window1]\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\tconst distanceFalloff = lightDistance.pow( decayExponent ).max( 0.01 ).reciprocal();\n\n\treturn cutoffDistance.greaterThan( 0 ).select(\n\t\tdistanceFalloff.mul( lightDistance.div( cutoffDistance ).pow4().oneMinus().clamp().pow2() ),\n\t\tdistanceFalloff\n\t);\n\n} ); // validated\n\nconst _clearColor$2 = /*@__PURE__*/ new Color();\n\n// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n// vector suitable for 2D texture mapping. This code uses the following layout for the\n// 2D texture:\n//\n// xzXZ\n//  y Y\n//\n// Y - Positive y direction\n// y - Negative y direction\n// X - Positive x direction\n// x - Negative x direction\n// Z - Positive z direction\n// z - Negative z direction\n//\n// Source and test bed:\n// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\nconst cubeToUV = /*@__PURE__*/ Fn( ( [ pos, texelSizeY ] ) => {\n\n\tconst v = pos.toVar();\n\n\t// Number of texels to avoid at the edge of each square\n\n\tconst absV = abs( v );\n\n\t// Intersect unit cube\n\n\tconst scaleToCube = div( 1.0, max$1( absV.x, max$1( absV.y, absV.z ) ) );\n\tabsV.mulAssign( scaleToCube );\n\n\t// Apply scale to avoid seams\n\n\t// two texels less per square (one texel will do for NEAREST)\n\tv.mulAssign( scaleToCube.mul( texelSizeY.mul( 2 ).oneMinus() ) );\n\n\t// Unwrap\n\n\t// space: -1 ... 1 range for each square\n\t//\n\t// #X##\t\tdim    := ( 4 , 2 )\n\t//  # #\t\tcenter := ( 1 , 1 )\n\n\tconst planar = vec2( v.xy ).toVar();\n\n\tconst almostATexel = texelSizeY.mul( 1.5 );\n\tconst almostOne = almostATexel.oneMinus();\n\n\tIf( absV.z.greaterThanEqual( almostOne ), () => {\n\n\t\tIf( v.z.greaterThan( 0.0 ), () => {\n\n\t\t\tplanar.x.assign( sub( 4.0, v.x ) );\n\n\t\t} );\n\n\t} ).ElseIf( absV.x.greaterThanEqual( almostOne ), () => {\n\n\t\tconst signX = sign( v.x );\n\t\tplanar.x.assign( v.z.mul( signX ).add( signX.mul( 2.0 ) ) );\n\n\t} ).ElseIf( absV.y.greaterThanEqual( almostOne ), () => {\n\n\t\tconst signY = sign( v.y );\n\t\tplanar.x.assign( v.x.add( signY.mul( 2.0 ) ).add( 2.0 ) );\n\t\tplanar.y.assign( v.z.mul( signY ).sub( 2.0 ) );\n\n\t} );\n\n\t// Transform to UV space\n\n\t// scale := 0.5 / dim\n\t// translate := ( center + 0.5 ) / dim\n\treturn vec2( 0.125, 0.25 ).mul( planar ).add( vec2( 0.375, 0.75 ) ).flipY();\n\n} ).setLayout( {\n\tname: 'cubeToUV',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'pos', type: 'vec3' },\n\t\t{ name: 'texelSizeY', type: 'float' }\n\t]\n} );\n\nconst BasicPointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize } ) => {\n\n\treturn texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp );\n\n} );\n\nconst PointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize, shadow } ) => {\n\n\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\tconst offset = vec2( - 1.0, 1.0 ).mul( radius ).mul( texelSize.y );\n\n\treturn texture( depthTexture, cubeToUV( bd3D.add( offset.xyy ), texelSize.y ) ).compare( dp )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xyx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxx ), texelSize.y ) ).compare( dp ) )\n\t\t.mul( 1.0 / 9.0 );\n\n} );\n\nconst pointShadowFilter = /*@__PURE__*/ Fn( ( { filterFn, depthTexture, shadowCoord, shadow } ) => {\n\n\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t// the vector from the light to the world-space position of the fragment.\n\tconst lightToPosition = shadowCoord.xyz.toVar();\n\tconst lightToPositionLength = lightToPosition.length();\n\n\tconst cameraNearLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.near );\n\tconst cameraFarLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.far );\n\tconst bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );\n\tconst mapSize = uniform( shadow.mapSize ).setGroup( renderGroup );\n\n\tconst result = float( 1.0 ).toVar();\n\n\tIf( lightToPositionLength.sub( cameraFarLocal ).lessThanEqual( 0.0 ).and( lightToPositionLength.sub( cameraNearLocal ).greaterThanEqual( 0.0 ) ), () => {\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tconst dp = lightToPositionLength.sub( cameraNearLocal ).div( cameraFarLocal.sub( cameraNearLocal ) ).toVar(); // need to clamp?\n\t\tdp.addAssign( bias );\n\n\t\t// bd3D = base direction 3D\n\t\tconst bd3D = lightToPosition.normalize();\n\t\tconst texelSize = vec2( 1.0 ).div( mapSize.mul( vec2( 4.0, 2.0 ) ) );\n\n\t\t// percentage-closer filtering\n\t\tresult.assign( filterFn( { depthTexture, bd3D, dp, texelSize, shadow } ) );\n\n\t} );\n\n\treturn result;\n\n} );\n\nconst _viewport = /*@__PURE__*/ new Vector4();\nconst _viewportSize = /*@__PURE__*/ new Vector2();\nconst _shadowMapSize = /*@__PURE__*/ new Vector2();\n\n//\n\nclass PointShadowNode extends ShadowNode {\n\n\tstatic get type() {\n\n\t\treturn 'PointShadowNode';\n\n\t}\n\n\tconstructor( light, shadow = null ) {\n\n\t\tsuper( light, shadow );\n\n\t}\n\n\tgetShadowFilterFn( type ) {\n\n\t\treturn type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;\n\n\t}\n\n\tsetupShadowCoord( builder, shadowPosition ) {\n\n\t\treturn shadowPosition;\n\n\t}\n\n\tsetupShadowFilter( builder, { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } ) {\n\n\t\treturn pointShadowFilter( { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } );\n\n\t}\n\n\trenderShadow( frame ) {\n\n\t\tconst { shadow, shadowMap, light } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\tshadowMap.setSize( _shadowMapSize.width, _shadowMapSize.height );\n\n\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t//\n\n\t\tconst previousAutoClear = renderer.autoClear;\n\n\t\tconst previousClearColor = renderer.getClearColor( _clearColor$2 );\n\t\tconst previousClearAlpha = renderer.getClearAlpha();\n\n\t\trenderer.autoClear = false;\n\t\trenderer.setClearColor( shadow.clearColor, shadow.clearAlpha );\n\t\trenderer.clear();\n\n\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\tconst x = _viewportSize.x * viewport.x;\n\t\t\tconst y = _shadowMapSize.y - _viewportSize.y - ( _viewportSize.y * viewport.y );\n\n\t\t\t_viewport.set(\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t);\n\n\t\t\tshadowMap.viewport.copy( _viewport );\n\n\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\trenderer.render( scene, shadow.camera );\n\n\t\t}\n\n\t\t//\n\n\t\trenderer.autoClear = previousAutoClear;\n\t\trenderer.setClearColor( previousClearColor, previousClearAlpha );\n\n\t}\n\n}\n\nconst pointShadow = ( light, shadow ) => nodeObject( new PointShadowNode( light, shadow ) );\n\nconst directPointLight = Fn( ( { color, lightViewPosition, cutoffDistance, decayExponent }, builder ) => {\n\n\tconst lightingModel = builder.context.lightingModel;\n\n\tconst lVector = lightViewPosition.sub( positionView ); // @TODO: Add it into LightNode\n\n\tconst lightDirection = lVector.normalize();\n\tconst lightDistance = lVector.length();\n\n\tconst lightAttenuation = getDistanceAttenuation( {\n\t\tlightDistance,\n\t\tcutoffDistance,\n\t\tdecayExponent\n\t} );\n\n\tconst lightColor = color.mul( lightAttenuation );\n\n\tconst reflectedLight = builder.context.reflectedLight;\n\n\tlightingModel.direct( {\n\t\tlightDirection,\n\t\tlightColor,\n\t\treflectedLight\n\t}, builder.stack, builder );\n\n} );\n\nclass PointLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'PointLightNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tthis.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );\n\t\tthis.decayExponentNode = uniform( 0 ).setGroup( renderGroup );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\tthis.cutoffDistanceNode.value = light.distance;\n\t\tthis.decayExponentNode.value = light.decay;\n\n\t}\n\n\tsetupShadowNode() {\n\n\t\treturn pointShadow( this.light );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tdirectPointLight( {\n\t\t\tcolor: this.colorNode,\n\t\t\tlightViewPosition: lightViewPosition( this.light ),\n\t\t\tcutoffDistance: this.cutoffDistanceNode,\n\t\t\tdecayExponent: this.decayExponentNode\n\t\t} ).append();\n\n\t}\n\n}\n\nconst checker = /*@__PURE__*/ Fn( ( [ coord = uv() ] ) => {\n\n\tconst uv = coord.mul( 2.0 );\n\n\tconst cx = uv.x.floor();\n\tconst cy = uv.y.floor();\n\tconst result = cx.add( cy ).mod( 2.0 );\n\n\treturn result.sign();\n\n} );\n\n// Three.js Transpiler\n// https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/libraries/stdlib/genglsl/lib/mx_noise.glsl\n\n\n\nconst mx_select = /*@__PURE__*/ Fn( ( [ b_immutable, t_immutable, f_immutable ] ) => {\n\n\tconst f = float( f_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst b = bool( b_immutable ).toVar();\n\n\treturn select( b, t, f );\n\n} ).setLayout( {\n\tname: 'mx_select',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'b', type: 'bool' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'f', type: 'float' }\n\t]\n} );\n\nconst mx_negate_if = /*@__PURE__*/ Fn( ( [ val_immutable, b_immutable ] ) => {\n\n\tconst b = bool( b_immutable ).toVar();\n\tconst val = float( val_immutable ).toVar();\n\n\treturn select( b, val.negate(), val );\n\n} ).setLayout( {\n\tname: 'mx_negate_if',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'val', type: 'float' },\n\t\t{ name: 'b', type: 'bool' }\n\t]\n} );\n\nconst mx_floor = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = float( x_immutable ).toVar();\n\n\treturn int( floor( x ) );\n\n} ).setLayout( {\n\tname: 'mx_floor',\n\ttype: 'int',\n\tinputs: [\n\t\t{ name: 'x', type: 'float' }\n\t]\n} );\n\nconst mx_floorfrac = /*@__PURE__*/ Fn( ( [ x_immutable, i ] ) => {\n\n\tconst x = float( x_immutable ).toVar();\n\ti.assign( mx_floor( x ) );\n\n\treturn x.sub( float( i ) );\n\n} );\n\nconst mx_bilerp_0 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v3 = float( v3_immutable ).toVar();\n\tconst v2 = float( v2_immutable ).toVar();\n\tconst v1 = float( v1_immutable ).toVar();\n\tconst v0 = float( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\n\treturn sub( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bilerp_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v0', type: 'float' },\n\t\t{ name: 'v1', type: 'float' },\n\t\t{ name: 'v2', type: 'float' },\n\t\t{ name: 'v3', type: 'float' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_bilerp_1 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v3 = vec3( v3_immutable ).toVar();\n\tconst v2 = vec3( v2_immutable ).toVar();\n\tconst v1 = vec3( v1_immutable ).toVar();\n\tconst v0 = vec3( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\n\treturn sub( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bilerp_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v0', type: 'vec3' },\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' },\n\t\t{ name: 'v3', type: 'vec3' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_bilerp = /*@__PURE__*/ overloadingFn( [ mx_bilerp_0, mx_bilerp_1 ] );\n\nconst mx_trilerp_0 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {\n\n\tconst r = float( r_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v7 = float( v7_immutable ).toVar();\n\tconst v6 = float( v6_immutable ).toVar();\n\tconst v5 = float( v5_immutable ).toVar();\n\tconst v4 = float( v4_immutable ).toVar();\n\tconst v3 = float( v3_immutable ).toVar();\n\tconst v2 = float( v2_immutable ).toVar();\n\tconst v1 = float( v1_immutable ).toVar();\n\tconst v0 = float( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\tconst t1 = float( sub( 1.0, t ) ).toVar();\n\tconst r1 = float( sub( 1.0, r ) ).toVar();\n\n\treturn r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_trilerp_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v0', type: 'float' },\n\t\t{ name: 'v1', type: 'float' },\n\t\t{ name: 'v2', type: 'float' },\n\t\t{ name: 'v3', type: 'float' },\n\t\t{ name: 'v4', type: 'float' },\n\t\t{ name: 'v5', type: 'float' },\n\t\t{ name: 'v6', type: 'float' },\n\t\t{ name: 'v7', type: 'float' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'r', type: 'float' }\n\t]\n} );\n\nconst mx_trilerp_1 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {\n\n\tconst r = float( r_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v7 = vec3( v7_immutable ).toVar();\n\tconst v6 = vec3( v6_immutable ).toVar();\n\tconst v5 = vec3( v5_immutable ).toVar();\n\tconst v4 = vec3( v4_immutable ).toVar();\n\tconst v3 = vec3( v3_immutable ).toVar();\n\tconst v2 = vec3( v2_immutable ).toVar();\n\tconst v1 = vec3( v1_immutable ).toVar();\n\tconst v0 = vec3( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\tconst t1 = float( sub( 1.0, t ) ).toVar();\n\tconst r1 = float( sub( 1.0, r ) ).toVar();\n\n\treturn r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_trilerp_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v0', type: 'vec3' },\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' },\n\t\t{ name: 'v3', type: 'vec3' },\n\t\t{ name: 'v4', type: 'vec3' },\n\t\t{ name: 'v5', type: 'vec3' },\n\t\t{ name: 'v6', type: 'vec3' },\n\t\t{ name: 'v7', type: 'vec3' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'r', type: 'float' }\n\t]\n} );\n\nconst mx_trilerp = /*@__PURE__*/ overloadingFn( [ mx_trilerp_0, mx_trilerp_1 ] );\n\nconst mx_gradient_float_0 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable ] ) => {\n\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uint( hash_immutable ).toVar();\n\tconst h = uint( hash.bitAnd( uint( 7 ) ) ).toVar();\n\tconst u = float( mx_select( h.lessThan( uint( 4 ) ), x, y ) ).toVar();\n\tconst v = float( mul( 2.0, mx_select( h.lessThan( uint( 4 ) ), y, x ) ) ).toVar();\n\n\treturn mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uint' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_float_1 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = float( z_immutable ).toVar();\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uint( hash_immutable ).toVar();\n\tconst h = uint( hash.bitAnd( uint( 15 ) ) ).toVar();\n\tconst u = float( mx_select( h.lessThan( uint( 8 ) ), x, y ) ).toVar();\n\tconst v = float( mx_select( h.lessThan( uint( 4 ) ), y, mx_select( h.equal( uint( 12 ) ).or( h.equal( uint( 14 ) ) ), x, z ) ) ).toVar();\n\n\treturn mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uint' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' },\n\t\t{ name: 'z', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_float = /*@__PURE__*/ overloadingFn( [ mx_gradient_float_0, mx_gradient_float_1 ] );\n\nconst mx_gradient_vec3_0 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable ] ) => {\n\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uvec3( hash_immutable ).toVar();\n\n\treturn vec3( mx_gradient_float( hash.x, x, y ), mx_gradient_float( hash.y, x, y ), mx_gradient_float( hash.z, x, y ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uvec3' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_vec3_1 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = float( z_immutable ).toVar();\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uvec3( hash_immutable ).toVar();\n\n\treturn vec3( mx_gradient_float( hash.x, x, y, z ), mx_gradient_float( hash.y, x, y, z ), mx_gradient_float( hash.z, x, y, z ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uvec3' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' },\n\t\t{ name: 'z', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_vec3 = /*@__PURE__*/ overloadingFn( [ mx_gradient_vec3_0, mx_gradient_vec3_1 ] );\n\nconst mx_gradient_scale2d_0 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = float( v_immutable ).toVar();\n\n\treturn mul( 0.6616, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale2d_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_scale3d_0 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = float( v_immutable ).toVar();\n\n\treturn mul( 0.9820, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale3d_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_scale2d_1 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = vec3( v_immutable ).toVar();\n\n\treturn mul( 0.6616, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale2d_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v', type: 'vec3' }\n\t]\n} );\n\nconst mx_gradient_scale2d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale2d_0, mx_gradient_scale2d_1 ] );\n\nconst mx_gradient_scale3d_1 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = vec3( v_immutable ).toVar();\n\n\treturn mul( 0.9820, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale3d_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v', type: 'vec3' }\n\t]\n} );\n\nconst mx_gradient_scale3d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale3d_0, mx_gradient_scale3d_1 ] );\n\nconst mx_rotl32 = /*@__PURE__*/ Fn( ( [ x_immutable, k_immutable ] ) => {\n\n\tconst k = int( k_immutable ).toVar();\n\tconst x = uint( x_immutable ).toVar();\n\n\treturn x.shiftLeft( k ).bitOr( x.shiftRight( int( 32 ).sub( k ) ) );\n\n} ).setLayout( {\n\tname: 'mx_rotl32',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'uint' },\n\t\t{ name: 'k', type: 'int' }\n\t]\n} );\n\nconst mx_bjmix = /*@__PURE__*/ Fn( ( [ a, b, c ] ) => {\n\n\ta.subAssign( c );\n\ta.bitXorAssign( mx_rotl32( c, int( 4 ) ) );\n\tc.addAssign( b );\n\tb.subAssign( a );\n\tb.bitXorAssign( mx_rotl32( a, int( 6 ) ) );\n\ta.addAssign( c );\n\tc.subAssign( b );\n\tc.bitXorAssign( mx_rotl32( b, int( 8 ) ) );\n\tb.addAssign( a );\n\ta.subAssign( c );\n\ta.bitXorAssign( mx_rotl32( c, int( 16 ) ) );\n\tc.addAssign( b );\n\tb.subAssign( a );\n\tb.bitXorAssign( mx_rotl32( a, int( 19 ) ) );\n\ta.addAssign( c );\n\tc.subAssign( b );\n\tc.bitXorAssign( mx_rotl32( b, int( 4 ) ) );\n\tb.addAssign( a );\n\n} );\n\nconst mx_bjfinal = /*@__PURE__*/ Fn( ( [ a_immutable, b_immutable, c_immutable ] ) => {\n\n\tconst c = uint( c_immutable ).toVar();\n\tconst b = uint( b_immutable ).toVar();\n\tconst a = uint( a_immutable ).toVar();\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 14 ) ) );\n\ta.bitXorAssign( c );\n\ta.subAssign( mx_rotl32( c, int( 11 ) ) );\n\tb.bitXorAssign( a );\n\tb.subAssign( mx_rotl32( a, int( 25 ) ) );\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 16 ) ) );\n\ta.bitXorAssign( c );\n\ta.subAssign( mx_rotl32( c, int( 4 ) ) );\n\tb.bitXorAssign( a );\n\tb.subAssign( mx_rotl32( a, int( 14 ) ) );\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 24 ) ) );\n\n\treturn c;\n\n} ).setLayout( {\n\tname: 'mx_bjfinal',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'a', type: 'uint' },\n\t\t{ name: 'b', type: 'uint' },\n\t\t{ name: 'c', type: 'uint' }\n\t]\n} );\n\nconst mx_bits_to_01 = /*@__PURE__*/ Fn( ( [ bits_immutable ] ) => {\n\n\tconst bits = uint( bits_immutable ).toVar();\n\n\treturn float( bits ).div( float( uint( int( 0xffffffff ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bits_to_01',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'bits', type: 'uint' }\n\t]\n} );\n\nconst mx_fade = /*@__PURE__*/ Fn( ( [ t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\n\treturn t.mul( t ).mul( t ).mul( t.mul( t.mul( 6.0 ).sub( 15.0 ) ).add( 10.0 ) );\n\n} ).setLayout( {\n\tname: 'mx_fade',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_hash_int_0 = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 1 ) ).toVar();\n\tconst seed = uint( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ).toVar();\n\n\treturn mx_bjfinal( seed.add( uint( x ) ), seed, seed );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_0',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_1 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable ] ) => {\n\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 2 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_1',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_2 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 3 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_2',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_3 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable, xx_immutable ] ) => {\n\n\tconst xx = int( xx_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 4 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\tmx_bjmix( a, b, c );\n\ta.addAssign( uint( xx ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_3',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xx', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_4 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable ] ) => {\n\n\tconst yy = int( yy_immutable ).toVar();\n\tconst xx = int( xx_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 5 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\tmx_bjmix( a, b, c );\n\ta.addAssign( uint( xx ) );\n\tb.addAssign( uint( yy ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_4',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xx', type: 'int' },\n\t\t{ name: 'yy', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int = /*@__PURE__*/ overloadingFn( [ mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4 ] );\n\nconst mx_hash_vec3_0 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable ] ) => {\n\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst h = uint( mx_hash_int( x, y ) ).toVar();\n\tconst result = uvec3().toVar();\n\tresult.x.assign( h.bitAnd( int( 0xFF ) ) );\n\tresult.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );\n\tresult.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hash_vec3_0',\n\ttype: 'uvec3',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' }\n\t]\n} );\n\nconst mx_hash_vec3_1 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst h = uint( mx_hash_int( x, y, z ) ).toVar();\n\tconst result = uvec3().toVar();\n\tresult.x.assign( h.bitAnd( int( 0xFF ) ) );\n\tresult.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );\n\tresult.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hash_vec3_1',\n\ttype: 'uvec3',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' }\n\t]\n} );\n\nconst mx_hash_vec3 = /*@__PURE__*/ overloadingFn( [ mx_hash_vec3_0, mx_hash_vec3_1 ] );\n\nconst mx_perlin_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst result = float( mx_bilerp( mx_gradient_float( mx_hash_int( X, Y ), fx, fy ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();\n\n\treturn mx_gradient_scale2d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_perlin_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst fz = float( mx_floorfrac( p.z, Z ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst w = float( mx_fade( fz ) ).toVar();\n\tconst result = float( mx_trilerp( mx_gradient_float( mx_hash_int( X, Y, Z ), fx, fy, fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();\n\n\treturn mx_gradient_scale3d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_perlin_noise_float = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_float_0, mx_perlin_noise_float_1 ] );\n\nconst mx_perlin_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst result = vec3( mx_bilerp( mx_gradient_vec3( mx_hash_vec3( X, Y ), fx, fy ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();\n\n\treturn mx_gradient_scale2d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_perlin_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst fz = float( mx_floorfrac( p.z, Z ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst w = float( mx_fade( fz ) ).toVar();\n\tconst result = vec3( mx_trilerp( mx_gradient_vec3( mx_hash_vec3( X, Y, Z ), fx, fy, fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();\n\n\treturn mx_gradient_scale3d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_perlin_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1 ] );\n\nconst mx_cell_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = float( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'float' }\n\t]\n} );\n\nconst mx_cell_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_cell_noise_float_2 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy, iz ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_2',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_cell_noise_float_3 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec4( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\tconst iw = int( mx_floor( p.w ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy, iz, iw ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_3',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec4' }\n\t]\n} );\n\nconst mx_cell_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3 ] );\n\nconst mx_cell_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = float( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'float' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_2 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_2',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_3 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec4( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\tconst iw = int( mx_floor( p.w ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec4' }\n\t]\n} );\n\nconst mx_cell_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3 ] );\n\nconst mx_fractal_noise_float$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst result = float( 0.0 ).toVar();\n\tconst amplitude = float( 1.0 ).toVar();\n\n\tLoop( octaves, () => {\n\n\t\tresult.addAssign( amplitude.mul( mx_perlin_noise_float( p ) ) );\n\t\tamplitude.mulAssign( diminish );\n\t\tp.mulAssign( lacunarity );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_float',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec3$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst result = vec3( 0.0 ).toVar();\n\tconst amplitude = float( 1.0 ).toVar();\n\n\tLoop( octaves, () => {\n\n\t\tresult.addAssign( amplitude.mul( mx_perlin_noise_vec3( p ) ) );\n\t\tamplitude.mulAssign( diminish );\n\t\tp.mulAssign( lacunarity );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec2$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\n\treturn vec2( mx_fractal_noise_float$1( p, octaves, lacunarity, diminish ), mx_fractal_noise_float$1( p.add( vec3( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) );\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec2',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec4$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst c = vec3( mx_fractal_noise_vec3$1( p, octaves, lacunarity, diminish ) ).toVar();\n\tconst f = float( mx_fractal_noise_float$1( p.add( vec3( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) ).toVar();\n\n\treturn vec4( c, f );\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec4',\n\ttype: 'vec4',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_worley_distance_0 = /*@__PURE__*/ Fn( ( [ p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst yoff = int( yoff_immutable ).toVar();\n\tconst xoff = int( xoff_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst tmp = vec3( mx_cell_noise_vec3( vec2( x.add( xoff ), y.add( yoff ) ) ) ).toVar();\n\tconst off = vec2( tmp.x, tmp.y ).toVar();\n\toff.subAssign( 0.5 );\n\toff.mulAssign( jitter );\n\toff.addAssign( 0.5 );\n\tconst cellpos = vec2( vec2( float( x ), float( y ) ).add( off ) ).toVar();\n\tconst diff = vec2( cellpos.sub( p ) ).toVar();\n\n\tIf( metric.equal( int( 2 ) ), () => {\n\n\t\treturn abs( diff.x ).add( abs( diff.y ) );\n\n\t} );\n\n\tIf( metric.equal( int( 3 ) ), () => {\n\n\t\treturn max$1( abs( diff.x ), abs( diff.y ) );\n\n\t} );\n\n\treturn dot( diff, diff );\n\n} ).setLayout( {\n\tname: 'mx_worley_distance_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'xoff', type: 'int' },\n\t\t{ name: 'yoff', type: 'int' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_distance_1 = /*@__PURE__*/ Fn( ( [ p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst zoff = int( zoff_immutable ).toVar();\n\tconst yoff = int( yoff_immutable ).toVar();\n\tconst xoff = int( xoff_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst off = vec3( mx_cell_noise_vec3( vec3( x.add( xoff ), y.add( yoff ), z.add( zoff ) ) ) ).toVar();\n\toff.subAssign( 0.5 );\n\toff.mulAssign( jitter );\n\toff.addAssign( 0.5 );\n\tconst cellpos = vec3( vec3( float( x ), float( y ), float( z ) ).add( off ) ).toVar();\n\tconst diff = vec3( cellpos.sub( p ) ).toVar();\n\n\tIf( metric.equal( int( 2 ) ), () => {\n\n\t\treturn abs( diff.x ).add( abs( diff.y ) ).add( abs( diff.z ) );\n\n\t} );\n\n\tIf( metric.equal( int( 3 ) ), () => {\n\n\t\treturn max$1( max$1( abs( diff.x ), abs( diff.y ) ), abs( diff.z ) );\n\n\t} );\n\n\treturn dot( diff, diff );\n\n} ).setLayout( {\n\tname: 'mx_worley_distance_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xoff', type: 'int' },\n\t\t{ name: 'yoff', type: 'int' },\n\t\t{ name: 'zoff', type: 'int' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_distance = /*@__PURE__*/ overloadingFn( [ mx_worley_distance_0, mx_worley_distance_1 ] );\n\nconst mx_worley_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = float( 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\t\t\tsqdist.assign( min$1( sqdist, dist ) );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec2_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = vec2( 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\n\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec2_0',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = vec3( 1e6, 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\n\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.z ), () => {\n\n\t\t\t\tsqdist.z.assign( dist );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = float( 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\t\t\t\tsqdist.assign( min$1( sqdist, dist ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_float_0, mx_worley_noise_float_1 ] );\n\nconst mx_worley_noise_vec2_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = vec2( 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\n\t\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec2_1',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec2$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec2_0, mx_worley_noise_vec2_1 ] );\n\nconst mx_worley_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = vec3( 1e6, 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\n\t\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.z ), () => {\n\n\t\t\t\t\tsqdist.z.assign( dist );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec3$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec3_0, mx_worley_noise_vec3_1 ] );\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl\n\n\nconst mx_hsvtorgb = /*@__PURE__*/ Fn( ( [ hsv ] ) => {\n\n\tconst s = hsv.y;\n\tconst v = hsv.z;\n\n\tconst result = vec3().toVar();\n\n\tIf( s.lessThan( 0.0001 ), () => {\n\n\t\tresult.assign( vec3( v, v, v ) );\n\n\t} ).Else( () => {\n\n\t\tlet h = hsv.x;\n\t\th = h.sub( floor( h ) ).mul( 6.0 ).toVar(); // TODO: check what .toVar() is needed in node system cache\n\t\tconst hi = int( trunc( h ) );\n\t\tconst f = h.sub( float( hi ) );\n\t\tconst p = v.mul( s.oneMinus() );\n\t\tconst q = v.mul( s.mul( f ).oneMinus() );\n\t\tconst t = v.mul( s.mul( f.oneMinus() ).oneMinus() );\n\n\t\tIf( hi.equal( int( 0 ) ), () => {\n\n\t\t\tresult.assign( vec3( v, t, p ) );\n\n\t\t} ).ElseIf( hi.equal( int( 1 ) ), () => {\n\n\t\t\tresult.assign( vec3( q, v, p ) );\n\n\t\t} ).ElseIf( hi.equal( int( 2 ) ), () => {\n\n\t\t\tresult.assign( vec3( p, v, t ) );\n\n\t\t} ).ElseIf( hi.equal( int( 3 ) ), () => {\n\n\t\t\tresult.assign( vec3( p, q, v ) );\n\n\t\t} ).ElseIf( hi.equal( int( 4 ) ), () => {\n\n\t\t\tresult.assign( vec3( t, p, v ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tresult.assign( vec3( v, p, q ) );\n\n\t\t} );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hsvtorgb',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hsv', type: 'vec3' }\n\t]\n} );\n\nconst mx_rgbtohsv = /*@__PURE__*/ Fn( ( [ c_immutable ] ) => {\n\n\tconst c = vec3( c_immutable ).toVar();\n\tconst r = float( c.x ).toVar();\n\tconst g = float( c.y ).toVar();\n\tconst b = float( c.z ).toVar();\n\tconst mincomp = float( min$1( r, min$1( g, b ) ) ).toVar();\n\tconst maxcomp = float( max$1( r, max$1( g, b ) ) ).toVar();\n\tconst delta = float( maxcomp.sub( mincomp ) ).toVar();\n\tconst h = float().toVar(), s = float().toVar(), v = float().toVar();\n\tv.assign( maxcomp );\n\n\tIf( maxcomp.greaterThan( 0.0 ), () => {\n\n\t\ts.assign( delta.div( maxcomp ) );\n\n\t} ).Else( () => {\n\n\t\ts.assign( 0.0 );\n\n\t} );\n\n\tIf( s.lessThanEqual( 0.0 ), () => {\n\n\t\th.assign( 0.0 );\n\n\t} ).Else( () => {\n\n\t\tIf( r.greaterThanEqual( maxcomp ), () => {\n\n\t\t\th.assign( g.sub( b ).div( delta ) );\n\n\t\t} ).ElseIf( g.greaterThanEqual( maxcomp ), () => {\n\n\t\t\th.assign( add( 2.0, b.sub( r ).div( delta ) ) );\n\n\t\t} ).Else( () => {\n\n\t\t\th.assign( add( 4.0, r.sub( g ).div( delta ) ) );\n\n\t\t} );\n\n\t\th.mulAssign( 1.0 / 6.0 );\n\n\t\tIf( h.lessThan( 0.0 ), () => {\n\n\t\t\th.addAssign( 1.0 );\n\n\t\t} );\n\n\t} );\n\n\treturn vec3( h, s, v );\n\n} ).setLayout( {\n\tname: 'mx_rgbtohsv',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'c', type: 'vec3' }\n\t]\n} );\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl\n\n\nconst mx_srgb_texture_to_lin_rec709 = /*@__PURE__*/ Fn( ( [ color_immutable ] ) => {\n\n\tconst color = vec3( color_immutable ).toVar();\n\tconst isAbove = bvec3( greaterThan( color, vec3( 0.04045 ) ) ).toVar();\n\tconst linSeg = vec3( color.div( 12.92 ) ).toVar();\n\tconst powSeg = vec3( pow( max$1( color.add( vec3( 0.055 ) ), vec3( 0.0 ) ).div( 1.055 ), vec3( 2.4 ) ) ).toVar();\n\n\treturn mix( linSeg, powSeg, isAbove );\n\n} ).setLayout( {\n\tname: 'mx_srgb_texture_to_lin_rec709',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\nconst mx_aastep = ( threshold, value ) => {\n\n\tthreshold = float( threshold );\n\tvalue = float( value );\n\n\tconst afwidth = vec2( value.dFdx(), value.dFdy() ).length().mul( 0.70710678118654757 );\n\n\treturn smoothstep( threshold.sub( afwidth ), threshold.add( afwidth ), value );\n\n};\n\nconst _ramp = ( a, b, uv, p ) => mix( a, b, uv[ p ].clamp() );\nconst mx_ramplr = ( valuel, valuer, texcoord = uv() ) => _ramp( valuel, valuer, texcoord, 'x' );\nconst mx_ramptb = ( valuet, valueb, texcoord = uv() ) => _ramp( valuet, valueb, texcoord, 'y' );\n\nconst _split = ( a, b, center, uv, p ) => mix( a, b, mx_aastep( center, uv[ p ] ) );\nconst mx_splitlr = ( valuel, valuer, center, texcoord = uv() ) => _split( valuel, valuer, center, texcoord, 'x' );\nconst mx_splittb = ( valuet, valueb, center, texcoord = uv() ) => _split( valuet, valueb, center, texcoord, 'y' );\n\nconst mx_transform_uv = ( uv_scale = 1, uv_offset = 0, uv_geo = uv() ) => uv_geo.mul( uv_scale ).add( uv_offset );\n\nconst mx_safepower = ( in1, in2 = 1 ) => {\n\n\tin1 = float( in1 );\n\n\treturn in1.abs().pow( in2 ).mul( in1.sign() );\n\n};\n\nconst mx_contrast = ( input, amount = 1, pivot = .5 ) => float( input ).sub( pivot ).mul( amount ).add( pivot );\n\nconst mx_noise_float = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_float( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\n//export const mx_noise_vec2 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\nconst mx_noise_vec3 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\nconst mx_noise_vec4 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => {\n\n\ttexcoord = texcoord.convert( 'vec2|vec3' ); // overloading type\n\n\tconst noise_vec4 = vec4( mx_perlin_noise_vec3( texcoord ), mx_perlin_noise_float( texcoord.add( vec2( 19, 73 ) ) ) );\n\n\treturn noise_vec4.mul( amplitude ).add( pivot );\n\n};\n\nconst mx_worley_noise_float = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_float$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\nconst mx_worley_noise_vec2 = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_vec2$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\nconst mx_worley_noise_vec3 = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_vec3$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\n\nconst mx_cell_noise_float = ( texcoord = uv() ) => mx_cell_noise_float$1( texcoord.convert( 'vec2|vec3' ) );\n\nconst mx_fractal_noise_float = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_float$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec2 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec2$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec3 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec3$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec4 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec4$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\n\n// https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html\n\nconst getParallaxCorrectNormal = /*@__PURE__*/ Fn( ( [ normal, cubeSize, cubePos ] ) => {\n\n\tconst nDir = normalize( normal ).toVar( 'nDir' );\n\tconst rbmax = sub( float( 0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld ).div( nDir ).toVar( 'rbmax' );\n\tconst rbmin = sub( float( - 0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld ).div( nDir ).toVar( 'rbmin' );\n\tconst rbminmax = vec3().toVar( 'rbminmax' );\n\trbminmax.x = nDir.x.greaterThan( float( 0 ) ).select( rbmax.x, rbmin.x );\n\trbminmax.y = nDir.y.greaterThan( float( 0 ) ).select( rbmax.y, rbmin.y );\n\trbminmax.z = nDir.z.greaterThan( float( 0 ) ).select( rbmax.z, rbmin.z );\n\n\tconst correction = min$1( min$1( rbminmax.x, rbminmax.y ), rbminmax.z ).toVar( 'correction' );\n\tconst boxIntersection = positionWorld.add( nDir.mul( correction ) ).toVar( 'boxIntersection' );\n\treturn boxIntersection.sub( cubePos );\n\n} );\n\nconst getShIrradianceAt = /*@__PURE__*/ Fn( ( [ normal, shCoefficients ] ) => {\n\n\t// normal is assumed to have unit length\n\n\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t// band 0\n\tlet result = shCoefficients.element( 0 ).mul( 0.886227 );\n\n\t// band 1\n\tresult = result.add( shCoefficients.element( 1 ).mul( 2.0 * 0.511664 ).mul( y ) );\n\tresult = result.add( shCoefficients.element( 2 ).mul( 2.0 * 0.511664 ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 3 ).mul( 2.0 * 0.511664 ).mul( x ) );\n\n\t// band 2\n\tresult = result.add( shCoefficients.element( 4 ).mul( 2.0 * 0.429043 ).mul( x ).mul( y ) );\n\tresult = result.add( shCoefficients.element( 5 ).mul( 2.0 * 0.429043 ).mul( y ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 6 ).mul( z.mul( z ).mul( 0.743125 ).sub( 0.247708 ) ) );\n\tresult = result.add( shCoefficients.element( 7 ).mul( 2.0 * 0.429043 ).mul( x ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 8 ).mul( 0.429043 ).mul( mul( x, x ).sub( mul( y, y ) ) ) );\n\n\treturn result;\n\n} );\n\n// constants\n\nvar TSL = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBRDF_GGX: BRDF_GGX,\n\tBRDF_Lambert: BRDF_Lambert,\n\tBasicShadowFilter: BasicShadowFilter,\n\tBreak: Break,\n\tContinue: Continue,\n\tDFGApprox: DFGApprox,\n\tD_GGX: D_GGX,\n\tDiscard: Discard,\n\tEPSILON: EPSILON,\n\tF_Schlick: F_Schlick,\n\tFn: Fn,\n\tINFINITY: INFINITY,\n\tIf: If,\n\tLoop: Loop,\n\tNodeAccess: NodeAccess,\n\tNodeShaderStage: NodeShaderStage,\n\tNodeType: NodeType,\n\tNodeUpdateType: NodeUpdateType,\n\tPCFShadowFilter: PCFShadowFilter,\n\tPCFSoftShadowFilter: PCFSoftShadowFilter,\n\tPI: PI,\n\tPI2: PI2,\n\tReturn: Return,\n\tSchlick_to_F0: Schlick_to_F0,\n\tScriptableNodeResources: ScriptableNodeResources,\n\tShaderNode: ShaderNode,\n\tTBNViewMatrix: TBNViewMatrix,\n\tVSMShadowFilter: VSMShadowFilter,\n\tV_GGX_SmithCorrelated: V_GGX_SmithCorrelated,\n\tabs: abs,\n\tacesFilmicToneMapping: acesFilmicToneMapping,\n\tacos: acos,\n\tadd: add,\n\taddMethodChaining: addMethodChaining,\n\taddNodeElement: addNodeElement,\n\tagxToneMapping: agxToneMapping,\n\tall: all,\n\talphaT: alphaT,\n\tand: and,\n\tanisotropy: anisotropy,\n\tanisotropyB: anisotropyB,\n\tanisotropyT: anisotropyT,\n\tany: any,\n\tappend: append,\n\tarrayBuffer: arrayBuffer,\n\tasin: asin,\n\tassign: assign,\n\tatan: atan,\n\tatan2: atan2,\n\tatomicAdd: atomicAdd,\n\tatomicAnd: atomicAnd,\n\tatomicFunc: atomicFunc,\n\tatomicMax: atomicMax,\n\tatomicMin: atomicMin,\n\tatomicOr: atomicOr,\n\tatomicStore: atomicStore,\n\tatomicSub: atomicSub,\n\tatomicXor: atomicXor,\n\tattenuationColor: attenuationColor,\n\tattenuationDistance: attenuationDistance,\n\tattribute: attribute,\n\tattributeArray: attributeArray,\n\tbackgroundBlurriness: backgroundBlurriness,\n\tbackgroundIntensity: backgroundIntensity,\n\tbackgroundRotation: backgroundRotation,\n\tbatch: batch,\n\tbillboarding: billboarding,\n\tbitAnd: bitAnd,\n\tbitNot: bitNot,\n\tbitOr: bitOr,\n\tbitXor: bitXor,\n\tbitangentGeometry: bitangentGeometry,\n\tbitangentLocal: bitangentLocal,\n\tbitangentView: bitangentView,\n\tbitangentWorld: bitangentWorld,\n\tbitcast: bitcast,\n\tblendBurn: blendBurn,\n\tblendColor: blendColor,\n\tblendDodge: blendDodge,\n\tblendOverlay: blendOverlay,\n\tblendScreen: blendScreen,\n\tblur: blur,\n\tbool: bool,\n\tbuffer: buffer,\n\tbufferAttribute: bufferAttribute,\n\tbumpMap: bumpMap,\n\tburn: burn,\n\tbvec2: bvec2,\n\tbvec3: bvec3,\n\tbvec4: bvec4,\n\tbypass: bypass,\n\tcache: cache,\n\tcall: call,\n\tcameraFar: cameraFar,\n\tcameraNear: cameraNear,\n\tcameraNormalMatrix: cameraNormalMatrix,\n\tcameraPosition: cameraPosition,\n\tcameraProjectionMatrix: cameraProjectionMatrix,\n\tcameraProjectionMatrixInverse: cameraProjectionMatrixInverse,\n\tcameraViewMatrix: cameraViewMatrix,\n\tcameraWorldMatrix: cameraWorldMatrix,\n\tcbrt: cbrt,\n\tcdl: cdl,\n\tceil: ceil,\n\tchecker: checker,\n\tcineonToneMapping: cineonToneMapping,\n\tclamp: clamp,\n\tclearcoat: clearcoat,\n\tclearcoatRoughness: clearcoatRoughness,\n\tcode: code,\n\tcolor: color,\n\tcolorSpaceToWorking: colorSpaceToWorking,\n\tcolorToDirection: colorToDirection,\n\tcompute: compute,\n\tcond: cond,\n\tcontext: context,\n\tconvert: convert,\n\tconvertColorSpace: convertColorSpace,\n\tconvertToTexture: convertToTexture,\n\tcos: cos,\n\tcross: cross,\n\tcubeTexture: cubeTexture,\n\tdFdx: dFdx,\n\tdFdy: dFdy,\n\tdashSize: dashSize,\n\tdefaultBuildStages: defaultBuildStages,\n\tdefaultShaderStages: defaultShaderStages,\n\tdefined: defined,\n\tdegrees: degrees,\n\tdeltaTime: deltaTime,\n\tdensityFog: densityFog,\n\tdepth: depth,\n\tdepthPass: depthPass,\n\tdifference: difference,\n\tdiffuseColor: diffuseColor,\n\tdirectPointLight: directPointLight,\n\tdirectionToColor: directionToColor,\n\tdispersion: dispersion,\n\tdistance: distance,\n\tdiv: div,\n\tdodge: dodge,\n\tdot: dot,\n\tdrawIndex: drawIndex,\n\tdynamicBufferAttribute: dynamicBufferAttribute,\n\telement: element,\n\temissive: emissive,\n\tequal: equal,\n\tequals: equals,\n\tequirectUV: equirectUV,\n\texp: exp,\n\texp2: exp2,\n\texpression: expression,\n\tfaceDirection: faceDirection,\n\tfaceForward: faceForward,\n\tfloat: float,\n\tfloor: floor,\n\tfog: fog,\n\tfract: fract,\n\tframeGroup: frameGroup,\n\tframeId: frameId,\n\tfrontFacing: frontFacing,\n\tfwidth: fwidth,\n\tgain: gain,\n\tgapSize: gapSize,\n\tgetConstNodeType: getConstNodeType,\n\tgetCurrentStack: getCurrentStack,\n\tgetDirection: getDirection,\n\tgetDistanceAttenuation: getDistanceAttenuation,\n\tgetGeometryRoughness: getGeometryRoughness,\n\tgetNormalFromDepth: getNormalFromDepth,\n\tgetParallaxCorrectNormal: getParallaxCorrectNormal,\n\tgetRoughness: getRoughness,\n\tgetScreenPosition: getScreenPosition,\n\tgetShIrradianceAt: getShIrradianceAt,\n\tgetTextureIndex: getTextureIndex,\n\tgetViewPosition: getViewPosition,\n\tglsl: glsl,\n\tglslFn: glslFn,\n\tgrayscale: grayscale,\n\tgreaterThan: greaterThan,\n\tgreaterThanEqual: greaterThanEqual,\n\thash: hash,\n\thighPrecisionModelNormalViewMatrix: highPrecisionModelNormalViewMatrix,\n\thighPrecisionModelViewMatrix: highPrecisionModelViewMatrix,\n\thue: hue,\n\tinstance: instance,\n\tinstanceIndex: instanceIndex,\n\tinstancedArray: instancedArray,\n\tinstancedBufferAttribute: instancedBufferAttribute,\n\tinstancedDynamicBufferAttribute: instancedDynamicBufferAttribute,\n\tinstancedMesh: instancedMesh,\n\tint: int,\n\tinverseSqrt: inverseSqrt,\n\tinvocationLocalIndex: invocationLocalIndex,\n\tinvocationSubgroupIndex: invocationSubgroupIndex,\n\tior: ior,\n\tiridescence: iridescence,\n\tiridescenceIOR: iridescenceIOR,\n\tiridescenceThickness: iridescenceThickness,\n\tivec2: ivec2,\n\tivec3: ivec3,\n\tivec4: ivec4,\n\tjs: js,\n\tlabel: label,\n\tlength: length,\n\tlengthSq: lengthSq,\n\tlessThan: lessThan,\n\tlessThanEqual: lessThanEqual,\n\tlightPosition: lightPosition,\n\tlightProjectionUV: lightProjectionUV,\n\tlightShadowMatrix: lightShadowMatrix,\n\tlightTargetDirection: lightTargetDirection,\n\tlightTargetPosition: lightTargetPosition,\n\tlightViewPosition: lightViewPosition,\n\tlightingContext: lightingContext,\n\tlights: lights,\n\tlinearDepth: linearDepth,\n\tlinearToneMapping: linearToneMapping,\n\tlocalId: localId,\n\tlog: log,\n\tlog2: log2,\n\tlogarithmicDepthToViewZ: logarithmicDepthToViewZ,\n\tloop: loop,\n\tluminance: luminance,\n\tmat2: mat2,\n\tmat3: mat3,\n\tmat4: mat4,\n\tmatcapUV: matcapUV,\n\tmaterialAOMap: materialAOMap,\n\tmaterialAlphaTest: materialAlphaTest,\n\tmaterialAnisotropy: materialAnisotropy,\n\tmaterialAnisotropyVector: materialAnisotropyVector,\n\tmaterialAttenuationColor: materialAttenuationColor,\n\tmaterialAttenuationDistance: materialAttenuationDistance,\n\tmaterialClearcoat: materialClearcoat,\n\tmaterialClearcoatNormal: materialClearcoatNormal,\n\tmaterialClearcoatRoughness: materialClearcoatRoughness,\n\tmaterialColor: materialColor,\n\tmaterialDispersion: materialDispersion,\n\tmaterialEmissive: materialEmissive,\n\tmaterialIOR: materialIOR,\n\tmaterialIridescence: materialIridescence,\n\tmaterialIridescenceIOR: materialIridescenceIOR,\n\tmaterialIridescenceThickness: materialIridescenceThickness,\n\tmaterialLightMap: materialLightMap,\n\tmaterialLineDashOffset: materialLineDashOffset,\n\tmaterialLineDashSize: materialLineDashSize,\n\tmaterialLineGapSize: materialLineGapSize,\n\tmaterialLineScale: materialLineScale,\n\tmaterialLineWidth: materialLineWidth,\n\tmaterialMetalness: materialMetalness,\n\tmaterialNormal: materialNormal,\n\tmaterialOpacity: materialOpacity,\n\tmaterialPointWidth: materialPointWidth,\n\tmaterialReference: materialReference,\n\tmaterialReflectivity: materialReflectivity,\n\tmaterialRefractionRatio: materialRefractionRatio,\n\tmaterialRotation: materialRotation,\n\tmaterialRoughness: materialRoughness,\n\tmaterialSheen: materialSheen,\n\tmaterialSheenRoughness: materialSheenRoughness,\n\tmaterialShininess: materialShininess,\n\tmaterialSpecular: materialSpecular,\n\tmaterialSpecularColor: materialSpecularColor,\n\tmaterialSpecularIntensity: materialSpecularIntensity,\n\tmaterialSpecularStrength: materialSpecularStrength,\n\tmaterialThickness: materialThickness,\n\tmaterialTransmission: materialTransmission,\n\tmax: max$1,\n\tmaxMipLevel: maxMipLevel,\n\tmetalness: metalness,\n\tmin: min$1,\n\tmix: mix,\n\tmixElement: mixElement,\n\tmod: mod,\n\tmodInt: modInt,\n\tmodelDirection: modelDirection,\n\tmodelNormalMatrix: modelNormalMatrix,\n\tmodelPosition: modelPosition,\n\tmodelScale: modelScale,\n\tmodelViewMatrix: modelViewMatrix,\n\tmodelViewPosition: modelViewPosition,\n\tmodelViewProjection: modelViewProjection,\n\tmodelWorldMatrix: modelWorldMatrix,\n\tmodelWorldMatrixInverse: modelWorldMatrixInverse,\n\tmorphReference: morphReference,\n\tmrt: mrt,\n\tmul: mul,\n\tmx_aastep: mx_aastep,\n\tmx_cell_noise_float: mx_cell_noise_float,\n\tmx_contrast: mx_contrast,\n\tmx_fractal_noise_float: mx_fractal_noise_float,\n\tmx_fractal_noise_vec2: mx_fractal_noise_vec2,\n\tmx_fractal_noise_vec3: mx_fractal_noise_vec3,\n\tmx_fractal_noise_vec4: mx_fractal_noise_vec4,\n\tmx_hsvtorgb: mx_hsvtorgb,\n\tmx_noise_float: mx_noise_float,\n\tmx_noise_vec3: mx_noise_vec3,\n\tmx_noise_vec4: mx_noise_vec4,\n\tmx_ramplr: mx_ramplr,\n\tmx_ramptb: mx_ramptb,\n\tmx_rgbtohsv: mx_rgbtohsv,\n\tmx_safepower: mx_safepower,\n\tmx_splitlr: mx_splitlr,\n\tmx_splittb: mx_splittb,\n\tmx_srgb_texture_to_lin_rec709: mx_srgb_texture_to_lin_rec709,\n\tmx_transform_uv: mx_transform_uv,\n\tmx_worley_noise_float: mx_worley_noise_float,\n\tmx_worley_noise_vec2: mx_worley_noise_vec2,\n\tmx_worley_noise_vec3: mx_worley_noise_vec3,\n\tnegate: negate,\n\tneutralToneMapping: neutralToneMapping,\n\tnodeArray: nodeArray,\n\tnodeImmutable: nodeImmutable,\n\tnodeObject: nodeObject,\n\tnodeObjects: nodeObjects,\n\tnodeProxy: nodeProxy,\n\tnormalFlat: normalFlat,\n\tnormalGeometry: normalGeometry,\n\tnormalLocal: normalLocal,\n\tnormalMap: normalMap,\n\tnormalView: normalView,\n\tnormalWorld: normalWorld,\n\tnormalize: normalize,\n\tnot: not,\n\tnotEqual: notEqual,\n\tnumWorkgroups: numWorkgroups,\n\tobjectDirection: objectDirection,\n\tobjectGroup: objectGroup,\n\tobjectPosition: objectPosition,\n\tobjectScale: objectScale,\n\tobjectViewPosition: objectViewPosition,\n\tobjectWorldMatrix: objectWorldMatrix,\n\toneMinus: oneMinus,\n\tor: or,\n\torthographicDepthToViewZ: orthographicDepthToViewZ,\n\toscSawtooth: oscSawtooth,\n\toscSine: oscSine,\n\toscSquare: oscSquare,\n\toscTriangle: oscTriangle,\n\toutput: output,\n\toutputStruct: outputStruct,\n\toverlay: overlay,\n\toverloadingFn: overloadingFn,\n\tparabola: parabola,\n\tparallaxDirection: parallaxDirection,\n\tparallaxUV: parallaxUV,\n\tparameter: parameter,\n\tpass: pass,\n\tpassTexture: passTexture,\n\tpcurve: pcurve,\n\tperspectiveDepthToViewZ: perspectiveDepthToViewZ,\n\tpmremTexture: pmremTexture,\n\tpointUV: pointUV,\n\tpointWidth: pointWidth,\n\tpositionGeometry: positionGeometry,\n\tpositionLocal: positionLocal,\n\tpositionPrevious: positionPrevious,\n\tpositionView: positionView,\n\tpositionViewDirection: positionViewDirection,\n\tpositionWorld: positionWorld,\n\tpositionWorldDirection: positionWorldDirection,\n\tposterize: posterize,\n\tpow: pow,\n\tpow2: pow2,\n\tpow3: pow3,\n\tpow4: pow4,\n\tproperty: property,\n\tradians: radians,\n\trand: rand,\n\trange: range,\n\trangeFog: rangeFog,\n\treciprocal: reciprocal,\n\treference: reference,\n\treferenceBuffer: referenceBuffer,\n\treflect: reflect,\n\treflectVector: reflectVector,\n\treflectView: reflectView,\n\treflector: reflector,\n\trefract: refract,\n\trefractVector: refractVector,\n\trefractView: refractView,\n\treinhardToneMapping: reinhardToneMapping,\n\tremainder: remainder,\n\tremap: remap,\n\tremapClamp: remapClamp,\n\trenderGroup: renderGroup,\n\trenderOutput: renderOutput,\n\trendererReference: rendererReference,\n\trotate: rotate,\n\trotateUV: rotateUV,\n\troughness: roughness,\n\tround: round,\n\trtt: rtt,\n\tsRGBTransferEOTF: sRGBTransferEOTF,\n\tsRGBTransferOETF: sRGBTransferOETF,\n\tsampler: sampler,\n\tsaturate: saturate,\n\tsaturation: saturation,\n\tscreen: screen,\n\tscreenCoordinate: screenCoordinate,\n\tscreenSize: screenSize,\n\tscreenUV: screenUV,\n\tscriptable: scriptable,\n\tscriptableValue: scriptableValue,\n\tselect: select,\n\tsetCurrentStack: setCurrentStack,\n\tshaderStages: shaderStages,\n\tshadow: shadow,\n\tsharedUniformGroup: sharedUniformGroup,\n\tsheen: sheen,\n\tsheenRoughness: sheenRoughness,\n\tshiftLeft: shiftLeft,\n\tshiftRight: shiftRight,\n\tshininess: shininess,\n\tsign: sign,\n\tsin: sin,\n\tsinc: sinc,\n\tskinning: skinning,\n\tskinningReference: skinningReference,\n\tsmoothstep: smoothstep,\n\tsmoothstepElement: smoothstepElement,\n\tspecularColor: specularColor,\n\tspecularF90: specularF90,\n\tspherizeUV: spherizeUV,\n\tsplit: split,\n\tspritesheetUV: spritesheetUV,\n\tsqrt: sqrt,\n\tstack: stack,\n\tstep: step,\n\tstorage: storage,\n\tstorageBarrier: storageBarrier,\n\tstorageObject: storageObject,\n\tstorageTexture: storageTexture,\n\tstring: string,\n\tsub: sub,\n\tsubgroupIndex: subgroupIndex,\n\tsubgroupSize: subgroupSize,\n\ttan: tan,\n\ttangentGeometry: tangentGeometry,\n\ttangentLocal: tangentLocal,\n\ttangentView: tangentView,\n\ttangentWorld: tangentWorld,\n\ttemp: temp,\n\ttexture: texture,\n\ttexture3D: texture3D,\n\ttextureBarrier: textureBarrier,\n\ttextureBicubic: textureBicubic,\n\ttextureCubeUV: textureCubeUV,\n\ttextureLoad: textureLoad,\n\ttextureSize: textureSize,\n\ttextureStore: textureStore,\n\tthickness: thickness,\n\tthreshold: threshold,\n\ttime: time,\n\ttimerDelta: timerDelta,\n\ttimerGlobal: timerGlobal,\n\ttimerLocal: timerLocal,\n\ttoOutputColorSpace: toOutputColorSpace,\n\ttoWorkingColorSpace: toWorkingColorSpace,\n\ttoneMapping: toneMapping,\n\ttoneMappingExposure: toneMappingExposure,\n\ttoonOutlinePass: toonOutlinePass,\n\ttransformDirection: transformDirection,\n\ttransformNormal: transformNormal,\n\ttransformNormalToView: transformNormalToView,\n\ttransformedBentNormalView: transformedBentNormalView,\n\ttransformedBitangentView: transformedBitangentView,\n\ttransformedBitangentWorld: transformedBitangentWorld,\n\ttransformedClearcoatNormalView: transformedClearcoatNormalView,\n\ttransformedNormalView: transformedNormalView,\n\ttransformedNormalWorld: transformedNormalWorld,\n\ttransformedTangentView: transformedTangentView,\n\ttransformedTangentWorld: transformedTangentWorld,\n\ttransmission: transmission,\n\ttranspose: transpose,\n\ttri: tri,\n\ttri3: tri3,\n\ttriNoise3D: triNoise3D,\n\ttriplanarTexture: triplanarTexture,\n\ttriplanarTextures: triplanarTextures,\n\ttrunc: trunc,\n\ttslFn: tslFn,\n\tuint: uint,\n\tuniform: uniform,\n\tuniformArray: uniformArray,\n\tuniformGroup: uniformGroup,\n\tuniforms: uniforms,\n\tuserData: userData,\n\tuv: uv,\n\tuvec2: uvec2,\n\tuvec3: uvec3,\n\tuvec4: uvec4,\n\tvarying: varying,\n\tvaryingProperty: varyingProperty,\n\tvec2: vec2,\n\tvec3: vec3,\n\tvec4: vec4,\n\tvectorComponents: vectorComponents,\n\tvelocity: velocity,\n\tvertexColor: vertexColor,\n\tvertexIndex: vertexIndex,\n\tvibrance: vibrance,\n\tviewZToLogarithmicDepth: viewZToLogarithmicDepth,\n\tviewZToOrthographicDepth: viewZToOrthographicDepth,\n\tviewZToPerspectiveDepth: viewZToPerspectiveDepth,\n\tviewport: viewport,\n\tviewportBottomLeft: viewportBottomLeft,\n\tviewportCoordinate: viewportCoordinate,\n\tviewportDepthTexture: viewportDepthTexture,\n\tviewportLinearDepth: viewportLinearDepth,\n\tviewportMipTexture: viewportMipTexture,\n\tviewportResolution: viewportResolution,\n\tviewportSafeUV: viewportSafeUV,\n\tviewportSharedTexture: viewportSharedTexture,\n\tviewportSize: viewportSize,\n\tviewportTexture: viewportTexture,\n\tviewportTopLeft: viewportTopLeft,\n\tviewportUV: viewportUV,\n\twgsl: wgsl,\n\twgslFn: wgslFn,\n\tworkgroupArray: workgroupArray,\n\tworkgroupBarrier: workgroupBarrier,\n\tworkgroupId: workgroupId,\n\tworkingToColorSpace: workingToColorSpace,\n\txor: xor\n});\n\nconst _clearColor$1 = /*@__PURE__*/ new Color4();\n\nclass Background extends DataMap {\n\n\tconstructor( renderer, nodes ) {\n\n\t\tsuper();\n\n\t\tthis.renderer = renderer;\n\t\tthis.nodes = nodes;\n\n\t}\n\n\tupdate( scene, renderList, renderContext ) {\n\n\t\tconst renderer = this.renderer;\n\t\tconst background = this.nodes.getBackgroundNode( scene ) || scene.background;\n\n\t\tlet forceClear = false;\n\n\t\tif ( background === null ) {\n\n\t\t\t// no background settings, use clear color configuration from the renderer\n\n\t\t\trenderer._clearColor.getRGB( _clearColor$1, LinearSRGBColorSpace );\n\t\t\t_clearColor$1.a = renderer._clearColor.a;\n\n\t\t} else if ( background.isColor === true ) {\n\n\t\t\t// background is an opaque color\n\n\t\t\tbackground.getRGB( _clearColor$1, LinearSRGBColorSpace );\n\t\t\t_clearColor$1.a = 1;\n\n\t\t\tforceClear = true;\n\n\t\t} else if ( background.isNode === true ) {\n\n\t\t\tconst sceneData = this.get( scene );\n\t\t\tconst backgroundNode = background;\n\n\t\t\t_clearColor$1.copy( renderer._clearColor );\n\n\t\t\tlet backgroundMesh = sceneData.backgroundMesh;\n\n\t\t\tif ( backgroundMesh === undefined ) {\n\n\t\t\t\tconst backgroundMeshNode = context( vec4( backgroundNode ).mul( backgroundIntensity ), {\n\t\t\t\t\t// @TODO: Add Texture2D support using node context\n\t\t\t\t\tgetUV: () => backgroundRotation.mul( normalWorld ),\n\t\t\t\t\tgetTextureLevel: () => backgroundBlurriness\n\t\t\t\t} );\n\n\t\t\t\tlet viewProj = modelViewProjection();\n\t\t\t\tviewProj = viewProj.setZ( viewProj.w );\n\n\t\t\t\tconst nodeMaterial = new NodeMaterial();\n\t\t\t\tnodeMaterial.name = 'Background.material';\n\t\t\t\tnodeMaterial.side = BackSide;\n\t\t\t\tnodeMaterial.depthTest = false;\n\t\t\t\tnodeMaterial.depthWrite = false;\n\t\t\t\tnodeMaterial.fog = false;\n\t\t\t\tnodeMaterial.lights = false;\n\t\t\t\tnodeMaterial.vertexNode = viewProj;\n\t\t\t\tnodeMaterial.colorNode = backgroundMeshNode;\n\n\t\t\t\tsceneData.backgroundMeshNode = backgroundMeshNode;\n\t\t\t\tsceneData.backgroundMesh = backgroundMesh = new Mesh( new SphereGeometry( 1, 32, 32 ), nodeMaterial );\n\t\t\t\tbackgroundMesh.frustumCulled = false;\n\t\t\t\tbackgroundMesh.name = 'Background.mesh';\n\n\t\t\t\tbackgroundMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tconst backgroundCacheKey = backgroundNode.getCacheKey();\n\n\t\t\tif ( sceneData.backgroundCacheKey !== backgroundCacheKey ) {\n\n\t\t\t\tsceneData.backgroundMeshNode.node = vec4( backgroundNode ).mul( backgroundIntensity );\n\t\t\t\tsceneData.backgroundMeshNode.needsUpdate = true;\n\n\t\t\t\tbackgroundMesh.material.needsUpdate = true;\n\n\t\t\t\tsceneData.backgroundCacheKey = backgroundCacheKey;\n\n\t\t\t}\n\n\t\t\trenderList.unshift( backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Renderer: Unsupported background configuration.', background );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderer.autoClear === true || forceClear === true ) {\n\n\t\t\tconst clearColorValue = renderContext.clearColorValue;\n\n\t\t\tclearColorValue.r = _clearColor$1.r;\n\t\t\tclearColorValue.g = _clearColor$1.g;\n\t\t\tclearColorValue.b = _clearColor$1.b;\n\t\t\tclearColorValue.a = _clearColor$1.a;\n\n\t\t\t// premultiply alpha\n\n\t\t\tif ( renderer.backend.isWebGLBackend === true || renderer.alpha === true ) {\n\n\t\t\t\tclearColorValue.r *= clearColorValue.a;\n\t\t\t\tclearColorValue.g *= clearColorValue.a;\n\t\t\t\tclearColorValue.b *= clearColorValue.a;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\trenderContext.depthClearValue = renderer._clearDepth;\n\t\t\trenderContext.stencilClearValue = renderer._clearStencil;\n\n\t\t\trenderContext.clearColor = renderer.autoClearColor === true;\n\t\t\trenderContext.clearDepth = renderer.autoClearDepth === true;\n\t\t\trenderContext.clearStencil = renderer.autoClearStencil === true;\n\n\t\t} else {\n\n\t\t\trenderContext.clearColor = false;\n\t\t\trenderContext.clearDepth = false;\n\t\t\trenderContext.clearStencil = false;\n\n\t\t}\n\n\t}\n\n}\n\nlet _id$5 = 0;\n\nclass BindGroup {\n\n\tconstructor( name = '', bindings = [], index = 0, bindingsReference = [] ) {\n\n\t\tthis.name = name;\n\t\tthis.bindings = bindings;\n\t\tthis.index = index;\n\t\tthis.bindingsReference = bindingsReference;\n\n\t\tthis.id = _id$5 ++;\n\n\t}\n\n}\n\nclass NodeBuilderState {\n\n\tconstructor( vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, monitor, transforms = [] ) {\n\n\t\tthis.vertexShader = vertexShader;\n\t\tthis.fragmentShader = fragmentShader;\n\t\tthis.computeShader = computeShader;\n\t\tthis.transforms = transforms;\n\n\t\tthis.nodeAttributes = nodeAttributes;\n\t\tthis.bindings = bindings;\n\n\t\tthis.updateNodes = updateNodes;\n\t\tthis.updateBeforeNodes = updateBeforeNodes;\n\t\tthis.updateAfterNodes = updateAfterNodes;\n\n\t\tthis.monitor = monitor;\n\n\t\tthis.usedTimes = 0;\n\n\t}\n\n\tcreateBindings() {\n\n\t\tconst bindings = [];\n\n\t\tfor ( const instanceGroup of this.bindings ) {\n\n\t\t\tconst shared = instanceGroup.bindings[ 0 ].groupNode.shared;\n\n\t\t\tif ( shared !== true ) {\n\n\t\t\t\tconst bindingsGroup = new BindGroup( instanceGroup.name, [], instanceGroup.index, instanceGroup );\n\t\t\t\tbindings.push( bindingsGroup );\n\n\t\t\t\tfor ( const instanceBinding of instanceGroup.bindings ) {\n\n\t\t\t\t\tbindingsGroup.bindings.push( instanceBinding.clone() );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbindings.push( instanceGroup );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n}\n\nclass NodeAttribute {\n\n\tconstructor( name, type, node = null ) {\n\n\t\tthis.isNodeAttribute = true;\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.node = node;\n\n\t}\n\n}\n\nclass NodeUniform {\n\n\tconstructor( name, type, node ) {\n\n\t\tthis.isNodeUniform = true;\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.node = node.getSelf();\n\n\t}\n\n\tget value() {\n\n\t\treturn this.node.value;\n\n\t}\n\n\tset value( val ) {\n\n\t\tthis.node.value = val;\n\n\t}\n\n\tget id() {\n\n\t\treturn this.node.id;\n\n\t}\n\n\tget groupNode() {\n\n\t\treturn this.node.groupNode;\n\n\t}\n\n}\n\nclass NodeVar {\n\n\tconstructor( name, type ) {\n\n\t\tthis.isNodeVar = true;\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\n\t}\n\n}\n\nclass NodeVarying extends NodeVar {\n\n\tconstructor( name, type ) {\n\n\t\tsuper( name, type );\n\n\t\tthis.needsInterpolation = false;\n\n\t\tthis.isNodeVarying = true;\n\n\t}\n\n}\n\nclass NodeCode {\n\n\tconstructor( name, type, code = '' ) {\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.code = code;\n\n\t\tObject.defineProperty( this, 'isNodeCode', { value: true } );\n\n\t}\n\n}\n\nlet id = 0;\n\nclass NodeCache {\n\n\tconstructor( parent = null ) {\n\n\t\tthis.id = id ++;\n\t\tthis.nodesData = new WeakMap();\n\n\t\tthis.parent = parent;\n\n\t}\n\n\tgetData( node ) {\n\n\t\tlet data = this.nodesData.get( node );\n\n\t\tif ( data === undefined && this.parent !== null ) {\n\n\t\t\tdata = this.parent.getData( node );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tsetData( node, data ) {\n\n\t\tthis.nodesData.set( node, data );\n\n\t}\n\n}\n\nclass Uniform {\n\n\tconstructor( name, value ) {\n\n\t\tthis.name = name;\n\t\tthis.value = value;\n\n\t\tthis.boundary = 0; // used to build the uniform buffer according to the STD140 layout\n\t\tthis.itemSize = 0;\n\n\t\tthis.offset = 0; // this property is set by WebGPUUniformsGroup and marks the start position in the uniform buffer\n\n\t}\n\n\tsetValue( value ) {\n\n\t\tthis.value = value;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.value;\n\n\t}\n\n}\n\nclass NumberUniform extends Uniform {\n\n\tconstructor( name, value = 0 ) {\n\n\t\tsuper( name, value );\n\n\t\tthis.isNumberUniform = true;\n\n\t\tthis.boundary = 4;\n\t\tthis.itemSize = 1;\n\n\t}\n\n}\n\nclass Vector2Uniform extends Uniform {\n\n\tconstructor( name, value = new Vector2() ) {\n\n\t\tsuper( name, value );\n\n\t\tthis.isVector2Uniform = true;\n\n\t\tthis.boundary = 8;\n\t\tthis.itemSize = 2;\n\n\t}\n\n}\n\nclass Vector3Uniform extends Uniform {\n\n\tconstructor( name, value = new Vector3() ) {\n\n\t\tsuper( name, value );\n\n\t\tthis.isVector3Uniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 3;\n\n\t}\n\n}\n\nclass Vector4Uniform extends Uniform {\n\n\tconstructor( name, value = new Vector4() ) {\n\n\t\tsuper( name, value );\n\n\t\tthis.isVector4Uniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 4;\n\n\t}\n\n}\n\nclass ColorUniform extends Uniform {\n\n\tconstructor( name, value = new Color() ) {\n\n\t\tsuper( name, value );\n\n\t\tthis.isColorUniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 3;\n\n\t}\n\n}\n\nclass Matrix3Uniform extends Uniform {\n\n\tconstructor( name, value = new Matrix3() ) {\n\n\t\tsuper( name, value );\n\n\t\tthis.isMatrix3Uniform = true;\n\n\t\tthis.boundary = 48;\n\t\tthis.itemSize = 12;\n\n\t}\n\n}\n\nclass Matrix4Uniform extends Uniform {\n\n\tconstructor( name, value = new Matrix4() ) {\n\n\t\tsuper( name, value );\n\n\t\tthis.isMatrix4Uniform = true;\n\n\t\tthis.boundary = 64;\n\t\tthis.itemSize = 16;\n\n\t}\n\n}\n\nclass NumberNodeUniform extends NumberUniform {\n\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nclass Vector2NodeUniform extends Vector2Uniform {\n\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nclass Vector3NodeUniform extends Vector3Uniform {\n\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nclass Vector4NodeUniform extends Vector4Uniform {\n\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nclass ColorNodeUniform extends ColorUniform {\n\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nclass Matrix3NodeUniform extends Matrix3Uniform {\n\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nclass Matrix4NodeUniform extends Matrix4Uniform {\n\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\nconst _cubeCamera = /*@__PURE__*/ new PerspectiveCamera( 90, 1 );\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 )\n];\n\n//\n\n// WebGPU Face indices\nconst _faceLib = [\n\t3, 1, 5,\n\t0, 4, 2\n];\n\nconst direction = getDirection( uv(), attribute( 'faceIndex' ) ).normalize();\nconst outputDirection = vec3( direction.x, direction.y.negate(), direction.z );\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._lodMax = 0;\n\t\tthis._cubeSize = 0;\n\t\tthis._lodPlanes = [];\n\t\tthis._sizeLods = [];\n\t\tthis._sigmas = [];\n\t\tthis._lodMeshes = [];\n\n\t\tthis._blurMaterial = null;\n\t\tthis._cubemapMaterial = null;\n\t\tthis._equirectMaterial = null;\n\t\tthis._backgroundBox = null;\n\n\t}\n\n\tget _hasInitialized() {\n\n\t\treturn this._renderer.hasInitialized();\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100, renderTarget = null ) {\n\n\t\tthis._setSize( 256 );\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.' );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n\t\t\tthis.fromSceneAsync( scene, sigma, near, far, cubeUVRenderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tcubeUVRenderTarget.depthBuffer = true;\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\tasync fromSceneAsync( scene, sigma = 0, near = 0.1, far = 100, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this.fromScene( scene, sigma, near, far, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromEquirectangular( equirectangular, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.' );\n\n\t\t\tthis._setSizeFromTexture( equirectangular );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n\t\t\tthis.fromEquirectangularAsync( equirectangular, cubeUVRenderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\tasync fromEquirectangularAsync( equirectangular, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromCubemap( cubemap, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.' );\n\n\t\t\tthis._setSizeFromTexture( cubemap );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n\t\t\tthis.fromCubemapAsync( cubemap, renderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\tasync fromCubemapAsync( cubemap, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tasync compileCubemapShader() {\n\n\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\t\t\tawait this._compileMaterial( this._cubemapMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tasync compileEquirectangularShader() {\n\n\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\t\t\tawait this._compileMaterial( this._equirectMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._dispose();\n\n\t\tif ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();\n\t\tif ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();\n\t\tif ( this._backgroundBox !== null ) {\n\n\t\t\tthis._backgroundBox.geometry.dispose();\n\t\t\tthis._backgroundBox.material.dispose();\n\n\t\t}\n\n\t}\n\n\t// private interface\n\n\t_setSizeFromTexture( texture ) {\n\n\t\tif ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {\n\n\t\t\tthis._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );\n\n\t\t} else { // Equirectangular\n\n\t\t\tthis._setSize( texture.image.width / 4 );\n\n\t\t}\n\n\t}\n\n\t_setSize( cubeSize ) {\n\n\t\tthis._lodMax = Math.floor( Math.log2( cubeSize ) );\n\t\tthis._cubeSize = Math.pow( 2, this._lodMax );\n\n\t}\n\n\t_dispose() {\n\n\t\tif ( this._blurMaterial !== null ) this._blurMaterial.dispose();\n\n\t\tif ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();\n\n\t\tfor ( let i = 0; i < this._lodPlanes.length; i ++ ) {\n\n\t\t\tthis._lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture, renderTarget ) {\n\n\t\tthis._setSizeFromTexture( texture );\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets() {\n\n\t\tconst width = 3 * Math.max( this._cubeSize, 16 * 7 );\n\t\tconst height = 4 * this._cubeSize;\n\n\t\tconst params = {\n\t\t\tmagFilter: LinearFilter,\n\t\t\tminFilter: LinearFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: HalfFloatType,\n\t\t\tformat: RGBAFormat,\n\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\t//depthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( width, height, params );\n\n\t\tif ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {\n\n\t\t\tif ( this._pingPongRenderTarget !== null ) {\n\n\t\t\t\tthis._dispose();\n\n\t\t\t}\n\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget( width, height, params );\n\n\t\t\tconst { _lodMax } = this;\n\t\t\t( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes( _lodMax ) );\n\n\t\t\tthis._blurMaterial = _getBlurShader( _lodMax, width, height );\n\n\t\t}\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\tasync _compileMaterial( material ) {\n\n\t\tconst tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );\n\t\tawait this._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\t\tconst cubeCamera = _cubeCamera;\n\t\tcubeCamera.near = near;\n\t\tcubeCamera.far = far;\n\n\t\t// px, py, pz, nx, ny, nz\n\t\tconst upSign = [ - 1, 1, - 1, - 1, - 1, - 1 ];\n\t\tconst forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.autoClear = false;\n\n\t\tlet backgroundBox = this._backgroundBox;\n\n\t\tif ( backgroundBox === null ) {\n\n\t\t\tconst backgroundMaterial = new MeshBasicMaterial( {\n\t\t\t\tname: 'PMREM.Background',\n\t\t\t\tside: BackSide,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tdepthTest: false\n\t\t\t} );\n\n\t\t\tbackgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );\n\n\t\t}\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundBox.material.color.copy( background );\n\t\t\t\tscene.background = null;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundBox.material.color.copy( _clearColor );\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\trenderer.clear();\n\n\t\tif ( useSolidColor ) {\n\n\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\n\t\t\tif ( col === 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t\t} else if ( col === 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\tconst size = this._cubeSize;\n\n\t\t\t_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\trenderer.autoClear = originalAutoClear;\n\t\tscene.background = background;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );\n\n\t\tif ( isCubeTexture ) {\n\n\t\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\t\tthis._cubemapMaterial = _getCubemapMaterial( texture );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\t\tthis._equirectMaterial = _getEquirectMaterial( texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n\t\tmaterial.fragmentNode.value = texture;\n\n\t\tconst mesh = this._lodMeshes[ 0 ];\n\t\tmesh.material = material;\n\n\t\tconst size = this._cubeSize;\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\t\tconst n = this._lodPlanes.length;\n\n\t\tfor ( let i = 1; i < n; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error( 'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = this._lodMeshes[ lodOut ];\n\t\tblurMesh.material = blurMaterial;\n\n\t\tconst blurUniforms = blurMaterial.uniforms;\n\n\t\tconst pixels = this._sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\ttargetIn.texture.frame = ( targetIn.texture.frame || 0 ) + 1;\n\n\t\tblurUniforms.envMap.value = targetIn.texture;\n\t\tblurUniforms.samples.value = samples;\n\t\tblurUniforms.weights.array = weights;\n\t\tblurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms.poleAxis.value = poleAxis;\n\n\t\t}\n\n\t\tconst { _lodMax } = this;\n\t\tblurUniforms.dTheta.value = radiansPerPixel;\n\t\tblurUniforms.mipInt.value = _lodMax - lodIn;\n\n\t\tconst outputSize = this._sizeLods[ lodOut ];\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\nfunction _createPlanes( lodMax ) {\n\n\tconst lodPlanes = [];\n\tconst sizeLods = [];\n\tconst sigmas = [];\n\tconst lodMeshes = [];\n\n\tlet lod = lodMax;\n\n\tconst totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n\tfor ( let i = 0; i < totalLods; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\tsizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > lodMax - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];\n\n\t\t} else if ( i === 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\tsigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 2 );\n\t\tconst min = - texelSize;\n\t\tconst max = 1 + texelSize;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\n\t\t\tconst faceIdx = _faceLib[ face ];\n\t\t\tposition.set( coordinates, positionSize * vertices * faceIdx );\n\t\t\tuv.set( uv1, uvSize * vertices * faceIdx );\n\t\t\tconst fill = [ faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * faceIdx );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\tlodPlanes.push( planes );\n\t\tlodMeshes.push( new Mesh( planes, null ) );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { lodPlanes, sizeLods, sigmas, lodMeshes };\n\n}\n\nfunction _createRenderTarget( width, height, params ) {\n\n\tconst cubeUVRenderTarget = new RenderTarget( width, height, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.texture.isPMREMTexture = true;\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getMaterial( type ) {\n\n\tconst material = new NodeMaterial();\n\tmaterial.depthTest = false;\n\tmaterial.depthWrite = false;\n\tmaterial.blending = NoBlending;\n\tmaterial.name = `PMREM_${ type }`;\n\n\treturn material;\n\n}\n\nfunction _getBlurShader( lodMax, width, height ) {\n\n\tconst weights = uniformArray( new Array( MAX_SAMPLES ).fill( 0 ) );\n\tconst poleAxis = uniform( new Vector3( 0, 1, 0 ) );\n\tconst dTheta = uniform( 0 );\n\tconst n = float( MAX_SAMPLES );\n\tconst latitudinal = uniform( 0 ); // false, bool\n\tconst samples = uniform( 1 ); // int\n\tconst envMap = texture( null );\n\tconst mipInt = uniform( 0 ); // int\n\tconst CUBEUV_TEXEL_WIDTH = float( 1 / width );\n\tconst CUBEUV_TEXEL_HEIGHT = float( 1 / height );\n\tconst CUBEUV_MAX_MIP = float( lodMax );\n\n\tconst materialUniforms = {\n\t\tn,\n\t\tlatitudinal,\n\t\tweights,\n\t\tpoleAxis,\n\t\toutputDirection,\n\t\tdTheta,\n\t\tsamples,\n\t\tenvMap,\n\t\tmipInt,\n\t\tCUBEUV_TEXEL_WIDTH,\n\t\tCUBEUV_TEXEL_HEIGHT,\n\t\tCUBEUV_MAX_MIP\n\t};\n\n\tconst material = _getMaterial( 'blur' );\n\tmaterial.uniforms = materialUniforms; // TODO: Move to outside of the material\n\tmaterial.fragmentNode = blur( { ...materialUniforms, latitudinal: latitudinal.equal( 1 ) } );\n\n\treturn material;\n\n}\n\nfunction _getCubemapMaterial( envTexture ) {\n\n\tconst material = _getMaterial( 'cubemap' );\n\tmaterial.fragmentNode = cubeTexture( envTexture, outputDirection );\n\n\treturn material;\n\n}\n\nfunction _getEquirectMaterial( envTexture ) {\n\n\tconst material = _getMaterial( 'equirect' );\n\tmaterial.fragmentNode = texture( envTexture, equirectUV( outputDirection ), 0 );\n\n\treturn material;\n\n}\n\nconst rendererCache = new WeakMap();\n\nconst typeFromArray = new Map( [\n\t[ Int8Array, 'int' ],\n\t[ Int16Array, 'int' ],\n\t[ Int32Array, 'int' ],\n\t[ Uint8Array, 'uint' ],\n\t[ Uint16Array, 'uint' ],\n\t[ Uint32Array, 'uint' ],\n\t[ Float32Array, 'float' ]\n] );\n\nconst toFloat = ( value ) => {\n\n\tif ( /e/g.test( value ) ) {\n\n\t\treturn String( value ).replace( /\\+/g, '' );\n\n\t} else {\n\n\t\tvalue = Number( value );\n\n\t\treturn value + ( value % 1 ? '' : '.0' );\n\n\t}\n\n};\n\nclass NodeBuilder {\n\n\tconstructor( object, renderer, parser ) {\n\n\t\tthis.object = object;\n\t\tthis.material = ( object && object.material ) || null;\n\t\tthis.geometry = ( object && object.geometry ) || null;\n\t\tthis.renderer = renderer;\n\t\tthis.parser = parser;\n\t\tthis.scene = null;\n\t\tthis.camera = null;\n\n\t\tthis.nodes = [];\n\t\tthis.sequentialNodes = [];\n\t\tthis.updateNodes = [];\n\t\tthis.updateBeforeNodes = [];\n\t\tthis.updateAfterNodes = [];\n\t\tthis.hashNodes = {};\n\n\t\tthis.monitor = null;\n\n\t\tthis.lightsNode = null;\n\t\tthis.environmentNode = null;\n\t\tthis.fogNode = null;\n\n\t\tthis.clippingContext = null;\n\n\t\tthis.vertexShader = null;\n\t\tthis.fragmentShader = null;\n\t\tthis.computeShader = null;\n\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: '' };\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.structs = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.bindings = { vertex: {}, fragment: {}, compute: {} };\n\t\tthis.bindingsIndexes = {};\n\t\tthis.bindGroups = null;\n\t\tthis.attributes = [];\n\t\tthis.bufferAttributes = [];\n\t\tthis.varyings = [];\n\t\tthis.codes = {};\n\t\tthis.vars = {};\n\t\tthis.flow = { code: '' };\n\t\tthis.chaining = [];\n\t\tthis.stack = stack();\n\t\tthis.stacks = [];\n\t\tthis.tab = '\\t';\n\n\t\tthis.currentFunctionNode = null;\n\n\t\tthis.context = {\n\t\t\tmaterial: this.material\n\t\t};\n\n\t\tthis.cache = new NodeCache();\n\t\tthis.globalCache = this.cache;\n\n\t\tthis.flowsData = new WeakMap();\n\n\t\tthis.shaderStage = null;\n\t\tthis.buildStage = null;\n\n\t\tthis.useComparisonMethod = false;\n\n\t}\n\n\tgetBindGroupsCache() {\n\n\t\tlet bindGroupsCache = rendererCache.get( this.renderer );\n\n\t\tif ( bindGroupsCache === undefined ) {\n\n\t\t\tbindGroupsCache = new ChainMap();\n\n\t\t\trendererCache.set( this.renderer, bindGroupsCache );\n\n\t\t}\n\n\t\treturn bindGroupsCache;\n\n\t}\n\n\tcreateRenderTarget( width, height, options ) {\n\n\t\treturn new RenderTarget( width, height, options );\n\n\t}\n\n\tcreateCubeRenderTarget( size, options ) {\n\n\t\treturn new CubeRenderTarget( size, options );\n\n\t}\n\n\tcreatePMREMGenerator() {\n\n\t\t// TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support\n\n\t\treturn new PMREMGenerator( this.renderer );\n\n\t}\n\n\tincludes( node ) {\n\n\t\treturn this.nodes.includes( node );\n\n\t}\n\n\t_getBindGroup( groupName, bindings ) {\n\n\t\tconst bindGroupsCache = this.getBindGroupsCache();\n\n\t\t//\n\n\t\tconst bindingsArray = [];\n\n\t\tlet sharedGroup = true;\n\n\t\tfor ( const binding of bindings ) {\n\n\t\t\tbindingsArray.push( binding );\n\n\t\t\tsharedGroup = sharedGroup && binding.groupNode.shared !== true;\n\n\t\t}\n\n\t\t//\n\n\t\tlet bindGroup;\n\n\t\tif ( sharedGroup ) {\n\n\t\t\tbindGroup = bindGroupsCache.get( bindingsArray );\n\n\t\t\tif ( bindGroup === undefined ) {\n\n\t\t\t\tbindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );\n\n\t\t\t\tbindGroupsCache.set( bindingsArray, bindGroup );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );\n\n\t\t}\n\n\t\treturn bindGroup;\n\n\t}\n\n\tgetBindGroupArray( groupName, shaderStage ) {\n\n\t\tconst bindings = this.bindings[ shaderStage ];\n\n\t\tlet bindGroup = bindings[ groupName ];\n\n\t\tif ( bindGroup === undefined ) {\n\n\t\t\tif ( this.bindingsIndexes[ groupName ] === undefined ) {\n\n\t\t\t\tthis.bindingsIndexes[ groupName ] = { binding: 0, group: Object.keys( this.bindingsIndexes ).length };\n\n\t\t\t}\n\n\t\t\tbindings[ groupName ] = bindGroup = [];\n\n\t\t}\n\n\t\treturn bindGroup;\n\n\t}\n\n\tgetBindings() {\n\n\t\tlet bindingsGroups = this.bindGroups;\n\n\t\tif ( bindingsGroups === null ) {\n\n\t\t\tconst groups = {};\n\t\t\tconst bindings = this.bindings;\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tfor ( const groupName in bindings[ shaderStage ] ) {\n\n\t\t\t\t\tconst uniforms = bindings[ shaderStage ][ groupName ];\n\n\t\t\t\t\tconst groupUniforms = groups[ groupName ] || ( groups[ groupName ] = [] );\n\t\t\t\t\tgroupUniforms.push( ...uniforms );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingsGroups = [];\n\n\t\t\tfor ( const groupName in groups ) {\n\n\t\t\t\tconst group = groups[ groupName ];\n\n\t\t\t\tconst bindingsGroup = this._getBindGroup( groupName, group );\n\n\t\t\t\tbindingsGroups.push( bindingsGroup );\n\n\t\t\t}\n\n\t\t\tthis.bindGroups = bindingsGroups;\n\n\t\t}\n\n\t\treturn bindingsGroups;\n\n\t}\n\n\tsortBindingGroups() {\n\n\t\tconst bindingsGroups = this.getBindings();\n\n\t\tbindingsGroups.sort( ( a, b ) => ( a.bindings[ 0 ].groupNode.order - b.bindings[ 0 ].groupNode.order ) );\n\n\t\tfor ( let i = 0; i < bindingsGroups.length; i ++ ) {\n\n\t\t\tconst bindingGroup = bindingsGroups[ i ];\n\t\t\tthis.bindingsIndexes[ bindingGroup.name ].group = i;\n\n\t\t\tbindingGroup.index = i;\n\n\t\t}\n\n\t}\n\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\taddNode( node ) {\n\n\t\tif ( this.nodes.includes( node ) === false ) {\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\taddSequentialNode( node ) {\n\n\t\tif ( this.sequentialNodes.includes( node ) === false ) {\n\n\t\t\tthis.sequentialNodes.push( node );\n\n\t\t}\n\n\t}\n\n\tbuildUpdateNodes() {\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tconst updateType = node.getUpdateType();\n\n\t\t\tif ( updateType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const node of this.sequentialNodes ) {\n\n\t\t\tconst updateBeforeType = node.getUpdateBeforeType();\n\t\t\tconst updateAfterType = node.getUpdateAfterType();\n\n\t\t\tif ( updateBeforeType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateBeforeNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t\tif ( updateAfterType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateAfterNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tget currentNode() {\n\n\t\treturn this.chaining[ this.chaining.length - 1 ];\n\n\t}\n\n\tisFilteredTexture( texture ) {\n\n\t\treturn ( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||\n\t\t\ttexture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter );\n\n\t}\n\n\taddChain( node ) {\n\n\t\t/*\n\t\tif ( this.chaining.indexOf( node ) !== - 1 ) {\n\n\t\t\tconsole.warn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.chaining.push( node );\n\n\t}\n\n\tremoveChain( node ) {\n\n\t\tconst lastChain = this.chaining.pop();\n\n\t\tif ( lastChain !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node chaining!' );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\tgetSharedContext() {\n\n\t\t({ ...this.context });\n\n\t\treturn this.context;\n\n\t}\n\n\tsetCache( cache ) {\n\n\t\tthis.cache = cache;\n\n\t}\n\n\tgetCache() {\n\n\t\treturn this.cache;\n\n\t}\n\n\tgetCacheFromNode( node, parent = true ) {\n\n\t\tconst data = this.getDataFromNode( node );\n\t\tif ( data.cache === undefined ) data.cache = new NodeCache( parent ? this.getCache() : null );\n\n\t\treturn data.cache;\n\n\t}\n\n\tisAvailable( /*name*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetDrawIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFragCoord() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\tincreaseUsage( node ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\t\tnodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;\n\n\t\treturn nodeData.usageCount;\n\n\t}\n\n\tgenerateTexture( /* texture, textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgenerateTextureLod( /* texture, textureProperty, uvSnippet, levelSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgenerateConst( type, value = null ) {\n\n\t\tif ( value === null ) {\n\n\t\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;\n\t\t\telse if ( type === 'bool' ) value = false;\n\t\t\telse if ( type === 'color' ) value = new Color();\n\t\t\telse if ( type === 'vec2' ) value = new Vector2();\n\t\t\telse if ( type === 'vec3' ) value = new Vector3();\n\t\t\telse if ( type === 'vec4' ) value = new Vector4();\n\n\t\t}\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst generateConst = value => this.generateConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) }, ${ generateConst( value.w ) } )`;\n\n\t\t} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ value.elements.map( generateConst ).join( ', ' ) } )`;\n\n\t\t} else if ( typeLength > 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }()`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\tgetType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\n\t\treturn type;\n\n\t}\n\n\thasGeometryAttribute( name ) {\n\n\t\treturn this.geometry && this.geometry.getAttribute( name ) !== undefined;\n\n\t}\n\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';\n\n\t}\n\n\tneedsToWorkingColorSpace( /*texture*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetComponentTypeFromTexture( texture ) {\n\n\t\tconst type = texture.type;\n\n\t\tif ( texture.isDataTexture ) {\n\n\t\t\tif ( type === IntType ) return 'int';\n\t\t\tif ( type === UnsignedIntType ) return 'uint';\n\n\t\t}\n\n\t\treturn 'float';\n\n\t}\n\n\tgetElementType( type ) {\n\n\t\tif ( type === 'mat2' ) return 'vec2';\n\t\tif ( type === 'mat3' ) return 'vec3';\n\t\tif ( type === 'mat4' ) return 'vec4';\n\n\t\treturn this.getComponentType( type );\n\n\t}\n\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tif ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\tgetTypeFromLength( length, componentType = 'float' ) {\n\n\t\tif ( length === 1 ) return componentType;\n\n\t\tconst baseType = getTypeFromLength( length );\n\t\tconst prefix = componentType === 'float' ? '' : componentType[ 0 ];\n\n\t\treturn prefix + baseType;\n\n\t}\n\n\tgetTypeFromArray( array ) {\n\n\t\treturn typeFromArray.get( array.constructor );\n\n\t}\n\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet dataAttribute = attribute;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\tconst array = dataAttribute.array;\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst normalized = attribute.normalized;\n\n\t\tlet arrayType;\n\n\t\tif ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {\n\n\t\t\tarrayType = this.getTypeFromArray( array );\n\n\t\t}\n\n\t\treturn this.getTypeFromLength( itemSize, arrayType );\n\n\t}\n\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\t\tif ( /mat2/.test( type ) === true ) return 4;\n\t\tif ( /mat3/.test( type ) === true ) return 9;\n\t\tif ( /mat4/.test( type ) === true ) return 16;\n\n\t\treturn 0;\n\n\t}\n\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\tchangeComponentType( type, newComponentType ) {\n\n\t\treturn this.getTypeFromLength( this.getTypeLength( type ), newComponentType );\n\n\t}\n\n\tgetIntegerType( type ) {\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tif ( componentType === 'int' || componentType === 'uint' ) return type;\n\n\t\treturn this.changeComponentType( type, 'int' );\n\n\t}\n\n\taddStack() {\n\n\t\tthis.stack = stack( this.stack );\n\n\t\tthis.stacks.push( getCurrentStack() || this.stack );\n\t\tsetCurrentStack( this.stack );\n\n\t\treturn this.stack;\n\n\t}\n\n\tremoveStack() {\n\n\t\tconst lastStack = this.stack;\n\t\tthis.stack = lastStack.parent;\n\n\t\tsetCurrentStack( this.stacks.pop() );\n\n\t\treturn lastStack;\n\n\t}\n\n\tgetDataFromNode( node, shaderStage = this.shaderStage, cache = null ) {\n\n\t\tcache = cache === null ? ( node.isGlobal( this ) ? this.globalCache : this.cache ) : cache;\n\n\t\tlet nodeData = cache.getData( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = {};\n\n\t\t\tcache.setData( node, nodeData );\n\n\t\t}\n\n\t\tif ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};\n\n\t\treturn nodeData[ shaderStage ];\n\n\t}\n\n\tgetNodeProperties( node, shaderStage = 'any' ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\treturn nodeData.properties || ( nodeData.properties = { outputNode: null } );\n\n\t}\n\n\tgetBufferAttributeFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet bufferAttribute = nodeData.bufferAttribute;\n\n\t\tif ( bufferAttribute === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tbufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );\n\n\t\t\tthis.bufferAttributes.push( bufferAttribute );\n\n\t\t\tnodeData.bufferAttribute = bufferAttribute;\n\n\t\t}\n\n\t\treturn bufferAttribute;\n\n\t}\n\n\tgetStructTypeFromNode( node, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tif ( nodeData.structType === undefined ) {\n\n\t\t\tconst index = this.structs.index ++;\n\n\t\t\tnode.name = `StructType${ index }`;\n\t\t\tthis.structs[ shaderStage ].push( node );\n\n\t\t\tnodeData.structType = node;\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\tgetVarFromNode( node, name = null, type = node.getNodeType( this ), shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeVar = nodeData.variable;\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst vars = this.vars[ shaderStage ] || ( this.vars[ shaderStage ] = [] );\n\n\t\t\tif ( name === null ) name = 'nodeVar' + vars.length;\n\n\t\t\tnodeVar = new NodeVar( name, type );\n\n\t\t\tvars.push( nodeVar );\n\n\t\t\tnodeData.variable = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\tgetVaryingFromNode( node, name = null, type = node.getNodeType( this ) ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, 'any' );\n\n\t\tlet nodeVarying = nodeData.varying;\n\n\t\tif ( nodeVarying === undefined ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst index = varyings.length;\n\n\t\t\tif ( name === null ) name = 'nodeVarying' + index;\n\n\t\t\tnodeVarying = new NodeVarying( name, type );\n\n\t\t\tvaryings.push( nodeVarying );\n\n\t\t\tnodeData.varying = nodeVarying;\n\n\t\t}\n\n\t\treturn nodeVarying;\n\n\t}\n\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ] || ( this.codes[ shaderStage ] = [] );\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\taddFlowCodeHierarchy( node, nodeBlock ) {\n\n\t\tconst { flowCodes, flowCodeBlock } = this.getDataFromNode( node );\n\n\t\tlet needsFlowCode = true;\n\t\tlet nodeBlockHierarchy = nodeBlock;\n\n\t\twhile ( nodeBlockHierarchy ) {\n\n\t\t\tif ( flowCodeBlock.get( nodeBlockHierarchy ) === true ) {\n\n\t\t\t\tneedsFlowCode = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tnodeBlockHierarchy = this.getDataFromNode( nodeBlockHierarchy ).parentNodeBlock;\n\n\t\t}\n\n\t\tif ( needsFlowCode ) {\n\n\t\t\tfor ( const flowCode of flowCodes ) {\n\n\t\t\t\tthis.addLineFlowCode( flowCode );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\taddLineFlowCodeBlock( node, code, nodeBlock ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\t\tconst flowCodes = nodeData.flowCodes || ( nodeData.flowCodes = [] );\n\t\tconst codeBlock = nodeData.flowCodeBlock || ( nodeData.flowCodeBlock = new WeakMap() );\n\n\t\tflowCodes.push( code );\n\t\tcodeBlock.set( nodeBlock, true );\n\n\t}\n\n\taddLineFlowCode( code, node = null ) {\n\n\t\tif ( code === '' ) return this;\n\n\t\tif ( node !== null && this.context.nodeBlock ) {\n\n\t\t\tthis.addLineFlowCodeBlock( node, code, this.context.nodeBlock );\n\n\t\t}\n\n\t\tcode = this.tab + code;\n\n\t\tif ( ! /;\\s*$/.test( code ) ) {\n\n\t\t\tcode = code + ';\\n';\n\n\t\t}\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\taddFlowTab() {\n\n\t\tthis.tab += '\\t';\n\n\t\treturn this;\n\n\t}\n\n\tremoveFlowTab() {\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\n\t\treturn this;\n\n\t}\n\n\tgetFlowData( node/*, shaderStage*/ ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\tflowNode( node ) {\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\treturn flowData;\n\n\t}\n\n\tbuildFunctionNode( shaderNode ) {\n\n\t\tconst fn = new FunctionNode();\n\n\t\tconst previous = this.currentFunctionNode;\n\n\t\tthis.currentFunctionNode = fn;\n\n\t\tfn.code = this.buildFunctionCode( shaderNode );\n\n\t\tthis.currentFunctionNode = previous;\n\n\t\treturn fn;\n\n\t}\n\n\tflowShaderNode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\n\t\tconst inputs = {\n\t\t\t[ Symbol.iterator ]() {\n\n\t\t\t\tlet index = 0;\n\t\t\t\tconst values = Object.values( this );\n\t\t\t\treturn {\n\t\t\t\t\tnext: () => ( {\n\t\t\t\t\t\tvalue: values[ index ],\n\t\t\t\t\t\tdone: index ++ >= values.length\n\t\t\t\t\t} )\n\t\t\t\t};\n\n\t\t\t}\n\t\t};\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tinputs[ input.name ] = new ParameterNode( input.type, input.name );\n\n\t\t}\n\n\t\t//\n\n\t\tshaderNode.layout = null;\n\n\t\tconst callNode = shaderNode.call( inputs );\n\t\tconst flowData = this.flowStagesNode( callNode, layout.type );\n\n\t\tshaderNode.layout = layout;\n\n\t\treturn flowData;\n\n\t}\n\n\tflowStagesNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\t\tconst previousVars = this.vars;\n\t\tconst previousCache = this.cache;\n\t\tconst previousBuildStage = this.buildStage;\n\t\tconst previousStack = this.stack;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\t\tthis.vars = {};\n\t\tthis.cache = new NodeCache();\n\t\tthis.stack = stack();\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tflow.result = node.build( this, output );\n\n\t\t}\n\n\t\tflow.vars = this.getVars( this.shaderStage );\n\n\t\tthis.flow = previousFlow;\n\t\tthis.vars = previousVars;\n\t\tthis.cache = previousCache;\n\t\tthis.stack = previousStack;\n\n\t\tthis.setBuildStage( previousBuildStage );\n\n\t\treturn flow;\n\n\t}\n\n\tgetFunctionOperator() {\n\n\t\treturn null;\n\n\t}\n\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousShaderStage = this.shaderStage;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tif ( propertyName !== null ) {\n\n\t\t\tflowData.code += `${ this.tab + propertyName } = ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\treturn flowData;\n\n\t}\n\n\tgetAttributesArray() {\n\n\t\treturn this.attributes.concat( this.bufferAttributes );\n\n\t}\n\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVaryings( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVar( type, name ) {\n\n\t\treturn `${ this.getType( type ) } ${ name }`;\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippet += `${ this.getVar( variable.type, variable.name ) }; `;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tif ( codes !== undefined ) {\n\n\t\t\tfor ( const nodeCode of codes ) {\n\n\t\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\n\n\t}\n\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\tsetBuildStage( buildStage ) {\n\n\t\tthis.buildStage = buildStage;\n\n\t}\n\n\tgetBuildStage() {\n\n\t\treturn this.buildStage;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tbuild() {\n\n\t\tconst { object, material, renderer } = this;\n\n\t\tif ( material !== null ) {\n\n\t\t\tlet nodeMaterial = renderer.library.fromMaterial( material );\n\n\t\t\tif ( nodeMaterial === null ) {\n\n\t\t\t\tconsole.error( `NodeMaterial: Material \"${ material.type }\" is not compatible.` );\n\n\t\t\t\tnodeMaterial = new NodeMaterial();\n\n\t\t\t}\n\n\t\t\tnodeMaterial.build( this );\n\n\t\t} else {\n\n\t\t\tthis.addFlow( 'compute', object );\n\n\t\t}\n\n\t\t// setup() -> stage 1: create possible new nodes and returns an output reference node\n\t\t// analyze()   -> stage 2: analyze nodes to possible optimization and validation\n\t\t// generate()  -> stage 3: generate shader\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t\t}\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\t\tif ( buildStage === 'generate' ) {\n\n\t\t\t\t\t\tthis.flowNode( node );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode.build( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setBuildStage( null );\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 4: build code for a specific output\n\n\t\tthis.buildCode();\n\t\tthis.buildUpdateNodes();\n\n\t\treturn this;\n\n\t}\n\n\tgetNodeUniform( uniformNode, type ) {\n\n\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) return new NumberNodeUniform( uniformNode );\n\t\tif ( type === 'vec2' || type === 'ivec2' || type === 'uvec2' ) return new Vector2NodeUniform( uniformNode );\n\t\tif ( type === 'vec3' || type === 'ivec3' || type === 'uvec3' ) return new Vector3NodeUniform( uniformNode );\n\t\tif ( type === 'vec4' || type === 'ivec4' || type === 'uvec4' ) return new Vector4NodeUniform( uniformNode );\n\t\tif ( type === 'color' ) return new ColorNodeUniform( uniformNode );\n\t\tif ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );\n\t\tif ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );\n\n\t\tthrow new Error( `Uniform \"${type}\" not declared.` );\n\n\t}\n\n\tcreateNodeMaterial( type = 'NodeMaterial' ) { // @deprecated, r168\n\n\t\tthrow new Error( `THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${ type }() instead.` );\n\n\t}\n\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength === 16 && toTypeLength === 9 ) {\n\n\t\t\treturn `${ this.getType( toType ) }(${ snippet }[0].xyz, ${ snippet }[1].xyz, ${ snippet }[2].xyz)`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 9 && toTypeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( toType ) }(${ snippet }[0].xy, ${ snippet }[1].xy)`;\n\n\t\t}\n\n\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 && fromTypeLength > 1 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType( toType ) ) { // fromType is float-like\n\n\t\t\t// convert a number value to vector type, e.g:\n\t\t\t// vec3( 1u ) -> vec3( float( 1u ) )\n\n\t\t\tsnippet = `${ this.getType( this.getComponentType( toType ) ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - Node System\\n`;\n\n\t}\n\n}\n\nclass NodeFrame {\n\n\tconstructor() {\n\n\t\tthis.time = 0;\n\t\tthis.deltaTime = 0;\n\n\t\tthis.frameId = 0;\n\t\tthis.renderId = 0;\n\n\t\tthis.startTime = null;\n\n\t\tthis.updateMap = new WeakMap();\n\t\tthis.updateBeforeMap = new WeakMap();\n\t\tthis.updateAfterMap = new WeakMap();\n\n\t\tthis.renderer = null;\n\t\tthis.material = null;\n\t\tthis.camera = null;\n\t\tthis.object = null;\n\t\tthis.scene = null;\n\n\t}\n\n\t_getMaps( referenceMap, nodeRef ) {\n\n\t\tlet maps = referenceMap.get( nodeRef );\n\n\t\tif ( maps === undefined ) {\n\n\t\t\tmaps = {\n\t\t\t\trenderMap: new WeakMap(),\n\t\t\t\tframeMap: new WeakMap()\n\t\t\t};\n\n\t\t\treferenceMap.set( nodeRef, maps );\n\n\t\t}\n\n\t\treturn maps;\n\n\t}\n\n\tupdateBeforeNode( node ) {\n\n\t\tconst updateType = node.getUpdateBeforeType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateBeforeMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.updateBefore( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateBeforeMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.updateBefore( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.updateBefore( this );\n\n\t\t}\n\n\t}\n\n\tupdateAfterNode( node ) {\n\n\t\tconst updateType = node.getUpdateAfterType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateAfterMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.updateAfter( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateAfterMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.updateAfter( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.updateAfter( this );\n\n\t\t}\n\n\t}\n\n\tupdateNode( node ) {\n\n\t\tconst updateType = node.getUpdateType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.update( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.update( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.update( this );\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tthis.frameId ++;\n\n\t\tif ( this.lastTime === undefined ) this.lastTime = performance.now();\n\n\t\tthis.deltaTime = ( performance.now() - this.lastTime ) / 1000;\n\n\t\tthis.lastTime = performance.now();\n\n\t\tthis.time += this.deltaTime;\n\n\t}\n\n}\n\nclass NodeFunctionInput {\n\n\tconstructor( type, name, count = null, qualifier = '', isConst = false ) {\n\n\t\tthis.type = type;\n\t\tthis.name = name;\n\t\tthis.count = count;\n\t\tthis.qualifier = qualifier;\n\t\tthis.isConst = isConst;\n\n\t}\n\n}\n\nNodeFunctionInput.isNodeFunctionInput = true;\n\nclass DirectionalLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'DirectionalLightNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst lightingModel = builder.context.lightingModel;\n\n\t\tconst lightColor = this.colorNode;\n\t\tconst lightDirection = lightTargetDirection( this.light );\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tlightingModel.direct( {\n\t\t\tlightDirection,\n\t\t\tlightColor,\n\t\t\treflectedLight\n\t\t}, builder.stack, builder );\n\n\t}\n\n}\n\nconst _matrix41 = /*@__PURE__*/ new Matrix4();\nconst _matrix42 = /*@__PURE__*/ new Matrix4();\n\nlet ltcLib = null;\n\nclass RectAreaLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'RectAreaLightNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tthis.halfHeight = uniform( new Vector3() ).setGroup( renderGroup );\n\t\tthis.halfWidth = uniform( new Vector3() ).setGroup( renderGroup );\n\n\t\tthis.updateType = NodeUpdateType.RENDER;\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tsuper.update( frame );\n\n\t\tconst { light } = this;\n\n\t\tconst viewMatrix = frame.camera.matrixWorldInverse;\n\n\t\t_matrix42.identity();\n\t\t_matrix41.copy( light.matrixWorld );\n\t\t_matrix41.premultiply( viewMatrix );\n\t\t_matrix42.extractRotation( _matrix41 );\n\n\t\tthis.halfWidth.value.set( light.width * 0.5, 0.0, 0.0 );\n\t\tthis.halfHeight.value.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\tthis.halfWidth.value.applyMatrix4( _matrix42 );\n\t\tthis.halfHeight.value.applyMatrix4( _matrix42 );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tlet ltc_1, ltc_2;\n\n\t\tif ( builder.isAvailable( 'float32Filterable' ) ) {\n\n\t\t\tltc_1 = texture( ltcLib.LTC_FLOAT_1 );\n\t\t\tltc_2 = texture( ltcLib.LTC_FLOAT_2 );\n\n\t\t} else {\n\n\t\t\tltc_1 = texture( ltcLib.LTC_HALF_1 );\n\t\t\tltc_2 = texture( ltcLib.LTC_HALF_2 );\n\n\t\t}\n\n\t\tconst { colorNode, light } = this;\n\t\tconst lightingModel = builder.context.lightingModel;\n\n\t\tconst lightPosition = lightViewPosition( light );\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tlightingModel.directRectArea( {\n\t\t\tlightColor: colorNode,\n\t\t\tlightPosition,\n\t\t\thalfWidth: this.halfWidth,\n\t\t\thalfHeight: this.halfHeight,\n\t\t\treflectedLight,\n\t\t\tltc_1,\n\t\t\tltc_2\n\t\t}, builder.stack, builder );\n\n\t}\n\n\tstatic setLTC( ltc ) {\n\n\t\tltcLib = ltc;\n\n\t}\n\n}\n\nclass SpotLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'SpotLightNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tthis.coneCosNode = uniform( 0 ).setGroup( renderGroup );\n\t\tthis.penumbraCosNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\tthis.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );\n\t\tthis.decayExponentNode = uniform( 0 ).setGroup( renderGroup );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tsuper.update( frame );\n\n\t\tconst { light } = this;\n\n\t\tthis.coneCosNode.value = Math.cos( light.angle );\n\t\tthis.penumbraCosNode.value = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\n\t\tthis.cutoffDistanceNode.value = light.distance;\n\t\tthis.decayExponentNode.value = light.decay;\n\n\t}\n\n\tgetSpotAttenuation( angleCosine ) {\n\n\t\tconst { coneCosNode, penumbraCosNode } = this;\n\n\t\treturn smoothstep( coneCosNode, penumbraCosNode, angleCosine );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst lightingModel = builder.context.lightingModel;\n\n\t\tconst { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;\n\n\t\tconst lVector = lightViewPosition( light ).sub( positionView ); // @TODO: Add it into LightNode\n\n\t\tconst lightDirection = lVector.normalize();\n\t\tconst angleCos = lightDirection.dot( lightTargetDirection( light ) );\n\t\tconst spotAttenuation = this.getSpotAttenuation( angleCos );\n\n\t\tconst lightDistance = lVector.length();\n\n\t\tconst lightAttenuation = getDistanceAttenuation( {\n\t\t\tlightDistance,\n\t\t\tcutoffDistance: cutoffDistanceNode,\n\t\t\tdecayExponent: decayExponentNode\n\t\t} );\n\n\t\tlet lightColor = colorNode.mul( spotAttenuation ).mul( lightAttenuation );\n\n\t\tif ( light.map ) {\n\n\t\t\tconst spotLightCoord = lightProjectionUV( light );\n\t\t\tconst projectedTexture = texture( light.map, spotLightCoord.xy ).onRenderUpdate( () => light.map );\n\n\t\t\tconst inSpotLightMap = spotLightCoord.mul( 2. ).sub( 1. ).abs().lessThan( 1. ).all();\n\n\t\t\tlightColor = inSpotLightMap.select( lightColor.mul( projectedTexture ), lightColor );\n\n\t\t}\n\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tlightingModel.direct( {\n\t\t\tlightDirection,\n\t\t\tlightColor,\n\t\t\treflectedLight\n\t\t}, builder.stack, builder );\n\n\t}\n\n}\n\nclass IESSpotLightNode extends SpotLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'IESSpotLightNode';\n\n\t}\n\n\tgetSpotAttenuation( angleCosine ) {\n\n\t\tconst iesMap = this.light.iesMap;\n\n\t\tlet spotAttenuation = null;\n\n\t\tif ( iesMap && iesMap.isTexture === true ) {\n\n\t\t\tconst angle = angleCosine.acos().mul( 1.0 / Math.PI );\n\n\t\t\tspotAttenuation = texture( iesMap, vec2( angle, 0 ), 0 ).r;\n\n\t\t} else {\n\n\t\t\tspotAttenuation = super.getSpotAttenuation( angleCosine );\n\n\t\t}\n\n\t\treturn spotAttenuation;\n\n\t}\n\n}\n\nclass AmbientLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'AmbientLightNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t}\n\n\tsetup( { context } ) {\n\n\t\tcontext.irradiance.addAssign( this.colorNode );\n\n\t}\n\n}\n\nclass HemisphereLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'HemisphereLightNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tthis.lightPositionNode = lightPosition( light );\n\t\tthis.lightDirectionNode = this.lightPositionNode.normalize();\n\n\t\tthis.groundColorNode = uniform( new Color() ).setGroup( renderGroup );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\tthis.lightPositionNode.object3d = light;\n\n\t\tthis.groundColorNode.value.copy( light.groundColor ).multiplyScalar( light.intensity );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { colorNode, groundColorNode, lightDirectionNode } = this;\n\n\t\tconst dotNL = normalView.dot( lightDirectionNode );\n\t\tconst hemiDiffuseWeight = dotNL.mul( 0.5 ).add( 0.5 );\n\n\t\tconst irradiance = mix( groundColorNode, colorNode, hemiDiffuseWeight );\n\n\t\tbuilder.context.irradiance.addAssign( irradiance );\n\n\t}\n\n}\n\nclass LightProbeNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'LightProbeNode';\n\n\t}\n\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tconst array = [];\n\n\t\tfor ( let i = 0; i < 9; i ++ ) array.push( new Vector3() );\n\n\t\tthis.lightProbe = uniformArray( array );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\t//\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.lightProbe.array[ i ].copy( light.sh.coefficients[ i ] ).multiplyScalar( light.intensity );\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst irradiance = getShIrradianceAt( normalWorld, this.lightProbe );\n\n\t\tbuilder.context.irradiance.addAssign( irradiance );\n\n\t}\n\n}\n\nclass NodeParser {\n\n\tparseFunction( /*source*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nclass NodeFunction {\n\n\tconstructor( type, inputs, name = '', precision = '' ) {\n\n\t\tthis.type = type;\n\t\tthis.inputs = inputs;\n\t\tthis.name = name;\n\t\tthis.precision = precision;\n\n\t}\n\n\tgetCode( /*name = this.name*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nNodeFunction.isNodeFunction = true;\n\nconst declarationRegexp$1 = /^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)/i;\nconst propertiesRegexp$1 = /[a-z_0-9]+/ig;\n\nconst pragmaMain = '#pragma main';\n\nconst parse$1 = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst pragmaMainIndex = source.indexOf( pragmaMain );\n\n\tconst mainCode = pragmaMainIndex !== - 1 ? source.slice( pragmaMainIndex + pragmaMain.length ) : source;\n\n\tconst declaration = mainCode.match( declarationRegexp$1 );\n\n\tif ( declaration !== null && declaration.length === 5 ) {\n\n\t\t// tokenizer\n\n\t\tconst inputsCode = declaration[ 4 ];\n\t\tconst propsMatches = [];\n\n\t\tlet nameMatch = null;\n\n\t\twhile ( ( nameMatch = propertiesRegexp$1.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( nameMatch );\n\n\t\t}\n\n\t\t// parser\n\n\t\tconst inputs = [];\n\n\t\tlet i = 0;\n\n\t\twhile ( i < propsMatches.length ) {\n\n\t\t\tconst isConst = propsMatches[ i ][ 0 ] === 'const';\n\n\t\t\tif ( isConst === true ) {\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tlet qualifier = propsMatches[ i ][ 0 ];\n\n\t\t\tif ( qualifier === 'in' || qualifier === 'out' || qualifier === 'inout' ) {\n\n\t\t\t\ti ++;\n\n\t\t\t} else {\n\n\t\t\t\tqualifier = '';\n\n\t\t\t}\n\n\t\t\tconst type = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tlet count = Number.parseInt( propsMatches[ i ][ 0 ] );\n\n\t\t\tif ( Number.isNaN( count ) === false ) i ++;\n\t\t\telse count = null;\n\n\t\t\tconst name = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tinputs.push( new NodeFunctionInput( type, name, count, qualifier, isConst ) );\n\n\t\t}\n\n\t\t//\n\n\t\tconst blockCode = mainCode.substring( declaration[ 0 ].length );\n\n\t\tconst name = declaration[ 3 ] !== undefined ? declaration[ 3 ] : '';\n\t\tconst type = declaration[ 2 ];\n\n\t\tconst precision = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\n\t\tconst headerCode = pragmaMainIndex !== - 1 ? source.slice( 0, pragmaMainIndex ) : '';\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tprecision,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\theaderCode\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a GLSL code.' );\n\n\t}\n\n};\n\nclass GLSLNodeFunction extends NodeFunction {\n\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, precision, inputsCode, blockCode, headerCode } = parse$1( source );\n\n\t\tsuper( type, inputs, name, precision );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.headerCode = headerCode;\n\n\t}\n\n\tgetCode( name = this.name ) {\n\n\t\tlet code;\n\n\t\tconst blockCode = this.blockCode;\n\n\t\tif ( blockCode !== '' ) {\n\n\t\t\tconst { type, inputsCode, headerCode, precision } = this;\n\n\t\t\tlet declarationCode = `${ type } ${ name } ( ${ inputsCode.trim() } )`;\n\n\t\t\tif ( precision !== '' ) {\n\n\t\t\t\tdeclarationCode = `${ precision } ${ declarationCode }`;\n\n\t\t\t}\n\n\t\t\tcode = headerCode + declarationCode + blockCode;\n\n\t\t} else {\n\n\t\t\t// interface function\n\n\t\t\tcode = '';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n}\n\nclass GLSLNodeParser extends NodeParser {\n\n\tparseFunction( source ) {\n\n\t\treturn new GLSLNodeFunction( source );\n\n\t}\n\n}\n\nconst outputNodeMap = new WeakMap();\n\nclass Nodes extends DataMap {\n\n\tconstructor( renderer, backend ) {\n\n\t\tsuper();\n\n\t\tthis.renderer = renderer;\n\t\tthis.backend = backend;\n\t\tthis.nodeFrame = new NodeFrame();\n\t\tthis.nodeBuilderCache = new Map();\n\t\tthis.callHashCache = new ChainMap();\n\t\tthis.groupsData = new ChainMap();\n\n\t}\n\n\tupdateGroup( nodeUniformsGroup ) {\n\n\t\tconst groupNode = nodeUniformsGroup.groupNode;\n\t\tconst name = groupNode.name;\n\n\t\t// objectGroup is every updated\n\n\t\tif ( name === objectGroup.name ) return true;\n\n\t\t// renderGroup is updated once per render/compute call\n\n\t\tif ( name === renderGroup.name ) {\n\n\t\t\tconst uniformsGroupData = this.get( nodeUniformsGroup );\n\t\t\tconst renderId = this.nodeFrame.renderId;\n\n\t\t\tif ( uniformsGroupData.renderId !== renderId ) {\n\n\t\t\t\tuniformsGroupData.renderId = renderId;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// frameGroup is updated once per frame\n\n\t\tif ( name === frameGroup.name ) {\n\n\t\t\tconst uniformsGroupData = this.get( nodeUniformsGroup );\n\t\t\tconst frameId = this.nodeFrame.frameId;\n\n\t\t\tif ( uniformsGroupData.frameId !== frameId ) {\n\n\t\t\t\tuniformsGroupData.frameId = frameId;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// other groups are updated just when groupNode.needsUpdate is true\n\n\t\tconst groupChain = [ groupNode, nodeUniformsGroup ];\n\n\t\tlet groupData = this.groupsData.get( groupChain );\n\t\tif ( groupData === undefined ) this.groupsData.set( groupChain, groupData = {} );\n\n\t\tif ( groupData.version !== groupNode.version ) {\n\n\t\t\tgroupData.version = groupNode.version;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetForRenderCacheKey( renderObject ) {\n\n\t\treturn renderObject.initialCacheKey;\n\n\t}\n\n\tgetForRender( renderObject ) {\n\n\t\tconst renderObjectData = this.get( renderObject );\n\n\t\tlet nodeBuilderState = renderObjectData.nodeBuilderState;\n\n\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\tconst { nodeBuilderCache } = this;\n\n\t\t\tconst cacheKey = this.getForRenderCacheKey( renderObject );\n\n\t\t\tnodeBuilderState = nodeBuilderCache.get( cacheKey );\n\n\t\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\t\tconst nodeBuilder = this.backend.createNodeBuilder( renderObject.object, this.renderer );\n\t\t\t\tnodeBuilder.scene = renderObject.scene;\n\t\t\t\tnodeBuilder.material = renderObject.material;\n\t\t\t\tnodeBuilder.camera = renderObject.camera;\n\t\t\t\tnodeBuilder.context.material = renderObject.material;\n\t\t\t\tnodeBuilder.lightsNode = renderObject.lightsNode;\n\t\t\t\tnodeBuilder.environmentNode = this.getEnvironmentNode( renderObject.scene );\n\t\t\t\tnodeBuilder.fogNode = this.getFogNode( renderObject.scene );\n\t\t\t\tnodeBuilder.clippingContext = renderObject.clippingContext;\n\t\t\t\tnodeBuilder.build();\n\n\t\t\t\tnodeBuilderState = this._createNodeBuilderState( nodeBuilder );\n\n\t\t\t\tnodeBuilderCache.set( cacheKey, nodeBuilderState );\n\n\t\t\t}\n\n\t\t\tnodeBuilderState.usedTimes ++;\n\n\t\t\trenderObjectData.nodeBuilderState = nodeBuilderState;\n\n\t\t}\n\n\t\treturn nodeBuilderState;\n\n\t}\n\n\tdelete( object ) {\n\n\t\tif ( object.isRenderObject ) {\n\n\t\t\tconst nodeBuilderState = this.get( object ).nodeBuilderState;\n\t\t\tnodeBuilderState.usedTimes --;\n\n\t\t\tif ( nodeBuilderState.usedTimes === 0 ) {\n\n\t\t\t\tthis.nodeBuilderCache.delete( this.getForRenderCacheKey( object ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.delete( object );\n\n\t}\n\n\tgetForCompute( computeNode ) {\n\n\t\tconst computeData = this.get( computeNode );\n\n\t\tlet nodeBuilderState = computeData.nodeBuilderState;\n\n\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\tconst nodeBuilder = this.backend.createNodeBuilder( computeNode, this.renderer );\n\t\t\tnodeBuilder.build();\n\n\t\t\tnodeBuilderState = this._createNodeBuilderState( nodeBuilder );\n\n\t\t\tcomputeData.nodeBuilderState = nodeBuilderState;\n\n\t\t}\n\n\t\treturn nodeBuilderState;\n\n\t}\n\n\t_createNodeBuilderState( nodeBuilder ) {\n\n\t\treturn new NodeBuilderState(\n\t\t\tnodeBuilder.vertexShader,\n\t\t\tnodeBuilder.fragmentShader,\n\t\t\tnodeBuilder.computeShader,\n\t\t\tnodeBuilder.getAttributesArray(),\n\t\t\tnodeBuilder.getBindings(),\n\t\t\tnodeBuilder.updateNodes,\n\t\t\tnodeBuilder.updateBeforeNodes,\n\t\t\tnodeBuilder.updateAfterNodes,\n\t\t\tnodeBuilder.monitor,\n\t\t\tnodeBuilder.transforms\n\t\t);\n\n\t}\n\n\tgetEnvironmentNode( scene ) {\n\n\t\treturn scene.environmentNode || this.get( scene ).environmentNode || null;\n\n\t}\n\n\tgetBackgroundNode( scene ) {\n\n\t\treturn scene.backgroundNode || this.get( scene ).backgroundNode || null;\n\n\t}\n\n\tgetFogNode( scene ) {\n\n\t\treturn scene.fogNode || this.get( scene ).fogNode || null;\n\n\t}\n\n\tgetCacheKey( scene, lightsNode ) {\n\n\t\tconst chain = [ scene, lightsNode ];\n\t\tconst callId = this.renderer.info.calls;\n\n\t\tlet cacheKeyData = this.callHashCache.get( chain );\n\n\t\tif ( cacheKeyData === undefined || cacheKeyData.callId !== callId ) {\n\n\t\t\tconst environmentNode = this.getEnvironmentNode( scene );\n\t\t\tconst fogNode = this.getFogNode( scene );\n\n\t\t\tconst values = [];\n\n\t\t\tif ( lightsNode ) values.push( lightsNode.getCacheKey( true ) );\n\t\t\tif ( environmentNode ) values.push( environmentNode.getCacheKey() );\n\t\t\tif ( fogNode ) values.push( fogNode.getCacheKey() );\n\n\t\t\tvalues.push( this.renderer.shadowMap.enabled ? 1 : 0 );\n\n\t\t\tcacheKeyData = {\n\t\t\t\tcallId,\n\t\t\t\tcacheKey: hashArray( values )\n\t\t\t};\n\n\t\t\tthis.callHashCache.set( chain, cacheKeyData );\n\n\t\t}\n\n\t\treturn cacheKeyData.cacheKey;\n\n\t}\n\n\tupdateScene( scene ) {\n\n\t\tthis.updateEnvironment( scene );\n\t\tthis.updateFog( scene );\n\t\tthis.updateBackground( scene );\n\n\t}\n\n\tget isToneMappingState() {\n\n\t\treturn this.renderer.getRenderTarget() ? false : true;\n\n\t}\n\n\tupdateBackground( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tconst forceUpdate = ( scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 ) || ( scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0 );\n\n\t\t\tif ( sceneData.background !== background || forceUpdate ) {\n\n\t\t\t\tlet backgroundNode = null;\n\n\t\t\t\tif ( background.isCubeTexture === true || ( background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping ) ) {\n\n\t\t\t\t\tif ( scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping ) {\n\n\t\t\t\t\t\tbackgroundNode = pmremTexture( background );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlet envMap;\n\n\t\t\t\t\t\tif ( background.isCubeTexture === true ) {\n\n\t\t\t\t\t\t\tenvMap = cubeTexture( background );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tenvMap = texture( background );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbackgroundNode = cubeMapNode( envMap );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( background.isTexture === true ) {\n\n\t\t\t\t\tbackgroundNode = texture( background, screenUV.flipY() ).setUpdateMatrix( true );\n\n\t\t\t\t} else if ( background.isColor !== true ) {\n\n\t\t\t\t\tconsole.error( 'WebGPUNodes: Unsupported background configuration.', background );\n\n\t\t\t\t}\n\n\t\t\t\tsceneData.backgroundNode = backgroundNode;\n\t\t\t\tsceneData.background = background;\n\t\t\t\tsceneData.backgroundBlurriness = scene.backgroundBlurriness;\n\n\t\t\t}\n\n\t\t} else if ( sceneData.backgroundNode ) {\n\n\t\t\tdelete sceneData.backgroundNode;\n\t\t\tdelete sceneData.background;\n\n\t\t}\n\n\t}\n\n\tupdateFog( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst fog = scene.fog;\n\n\t\tif ( fog ) {\n\n\t\t\tif ( sceneData.fog !== fog ) {\n\n\t\t\t\tlet fogNode = null;\n\n\t\t\t\tif ( fog.isFogExp2 ) {\n\n\t\t\t\t\tconst color = reference( 'color', 'color', fog ).setGroup( renderGroup );\n\t\t\t\t\tconst density = reference( 'density', 'float', fog ).setGroup( renderGroup );\n\n\t\t\t\t\tfogNode = densityFog( color, density );\n\n\t\t\t\t} else if ( fog.isFog ) {\n\n\t\t\t\t\tconst color = reference( 'color', 'color', fog ).setGroup( renderGroup );\n\t\t\t\t\tconst near = reference( 'near', 'float', fog ).setGroup( renderGroup );\n\t\t\t\t\tconst far = reference( 'far', 'float', fog ).setGroup( renderGroup );\n\n\t\t\t\t\tfogNode = rangeFog( color, near, far );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'WebGPUNodes: Unsupported fog configuration.', fog );\n\n\t\t\t\t}\n\n\t\t\t\tsceneData.fogNode = fogNode;\n\t\t\t\tsceneData.fog = fog;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdelete sceneData.fogNode;\n\t\t\tdelete sceneData.fog;\n\n\t\t}\n\n\t}\n\n\tupdateEnvironment( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst environment = scene.environment;\n\n\t\tif ( environment ) {\n\n\t\t\tif ( sceneData.environment !== environment ) {\n\n\t\t\t\tlet environmentNode = null;\n\n\t\t\t\tif ( environment.isCubeTexture === true ) {\n\n\t\t\t\t\tenvironmentNode = cubeTexture( environment );\n\n\t\t\t\t} else if ( environment.isTexture === true ) {\n\n\t\t\t\t\tenvironmentNode = texture( environment );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'Nodes: Unsupported environment configuration.', environment );\n\n\t\t\t\t}\n\n\t\t\t\tsceneData.environmentNode = environmentNode;\n\t\t\t\tsceneData.environment = environment;\n\n\t\t\t}\n\n\t\t} else if ( sceneData.environmentNode ) {\n\n\t\t\tdelete sceneData.environmentNode;\n\t\t\tdelete sceneData.environment;\n\n\t\t}\n\n\t}\n\n\tgetNodeFrame( renderer = this.renderer, scene = null, object = null, camera = null, material = null ) {\n\n\t\tconst nodeFrame = this.nodeFrame;\n\t\tnodeFrame.renderer = renderer;\n\t\tnodeFrame.scene = scene;\n\t\tnodeFrame.object = object;\n\t\tnodeFrame.camera = camera;\n\t\tnodeFrame.material = material;\n\n\t\treturn nodeFrame;\n\n\t}\n\n\tgetNodeFrameForRender( renderObject ) {\n\n\t\treturn this.getNodeFrame( renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material );\n\n\t}\n\n\tgetOutputCacheKey() {\n\n\t\tconst renderer = this.renderer;\n\n\t\treturn renderer.toneMapping + ',' + renderer.currentColorSpace;\n\n\t}\n\n\thasOutputChange( outputTarget ) {\n\n\t\tconst cacheKey = outputNodeMap.get( outputTarget );\n\n\t\treturn cacheKey !== this.getOutputCacheKey();\n\n\t}\n\n\tgetOutputNode( outputTexture ) {\n\n\t\tconst renderer = this.renderer;\n\t\tconst cacheKey = this.getOutputCacheKey();\n\n\t\tconst output = texture( outputTexture, screenUV ).renderOutput( renderer.toneMapping, renderer.currentColorSpace );\n\n\t\toutputNodeMap.set( outputTexture, cacheKey );\n\n\t\treturn output;\n\n\t}\n\n\tupdateBefore( renderObject ) {\n\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateBeforeNodes ) {\n\n\t\t\t// update frame state for each node\n\n\t\t\tthis.getNodeFrameForRender( renderObject ).updateBeforeNode( node );\n\n\t\t}\n\n\t}\n\n\tupdateAfter( renderObject ) {\n\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateAfterNodes ) {\n\n\t\t\t// update frame state for each node\n\n\t\t\tthis.getNodeFrameForRender( renderObject ).updateAfterNode( node );\n\n\t\t}\n\n\t}\n\n\tupdateForCompute( computeNode ) {\n\n\t\tconst nodeFrame = this.getNodeFrame();\n\t\tconst nodeBuilder = this.getForCompute( computeNode );\n\n\t\tfor ( const node of nodeBuilder.updateNodes ) {\n\n\t\t\tnodeFrame.updateNode( node );\n\n\t\t}\n\n\t}\n\n\tupdateForRender( renderObject ) {\n\n\t\tconst nodeFrame = this.getNodeFrameForRender( renderObject );\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateNodes ) {\n\n\t\t\tnodeFrame.updateNode( node );\n\n\t\t}\n\n\t}\n\n\tneedsRefresh( renderObject ) {\n\n\t\tconst nodeFrame = this.getNodeFrameForRender( renderObject );\n\t\tconst monitor = renderObject.getMonitor();\n\n\t\treturn monitor.needsRefresh( renderObject, nodeFrame );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis.nodeFrame = new NodeFrame();\n\t\tthis.nodeBuilderCache = new Map();\n\n\t}\n\n}\n\nconst _plane = /*@__PURE__*/ new Plane();\n\nclass ClippingContext {\n\n\tconstructor( parentContext = null ) {\n\n\t\tthis.version = 0;\n\n\t\tthis.clipIntersection = null;\n\t\tthis.cacheKey = '';\n\n\n\t\tif ( parentContext === null ) {\n\n\t\t\tthis.intersectionPlanes = [];\n\t\t\tthis.unionPlanes = [];\n\n\t\t\tthis.viewNormalMatrix = new Matrix3();\n\t\t\tthis.clippingGroupContexts = new WeakMap();\n\n\t\t\tthis.shadowPass = false;\n\n\t\t} else {\n\n\t\t\tthis.viewNormalMatrix = parentContext.viewNormalMatrix;\n\t\t\tthis.clippingGroupContexts = parentContext.clippingGroupContexts;\n\n\t\t\tthis.shadowPass = parentContext.shadowPass;\n\n\t\t\tthis.viewMatrix = parentContext.viewMatrix;\n\n\t\t}\n\n\t\tthis.parentVersion = null;\n\n\t}\n\n\tprojectPlanes( source, destination, offset ) {\n\n\t\tconst l = source.length;\n\n\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t_plane.copy( source[ i ] ).applyMatrix4( this.viewMatrix, this.viewNormalMatrix );\n\n\t\t\tconst v = destination[ offset + i ];\n\t\t\tconst normal = _plane.normal;\n\n\t\t\tv.x = - normal.x;\n\t\t\tv.y = - normal.y;\n\t\t\tv.z = - normal.z;\n\t\t\tv.w = _plane.constant;\n\n\t\t}\n\n\t}\n\n\tupdateGlobal( scene, camera ) {\n\n\t\tthis.shadowPass = ( scene.overrideMaterial !== null && scene.overrideMaterial.isShadowNodeMaterial );\n\t\tthis.viewMatrix = camera.matrixWorldInverse;\n\n\t\tthis.viewNormalMatrix.getNormalMatrix( this.viewMatrix );\n\n\t}\n\n\tupdate( parentContext, clippingGroup ) {\n\n\t\tlet update = false;\n\n\t\tif ( parentContext.version !== this.parentVersion ) {\n\n\t\t\tthis.intersectionPlanes = Array.from( parentContext.intersectionPlanes );\n\t\t\tthis.unionPlanes = Array.from( parentContext.unionPlanes );\n\t\t\tthis.parentVersion = parentContext.version;\n\n\t\t}\n\n\t\tif ( this.clipIntersection !== clippingGroup.clipIntersection ) {\n\n\t\t\tthis.clipIntersection = clippingGroup.clipIntersection;\n\n\t\t\tif ( this.clipIntersection ) {\n\n\t\t\t\tthis.unionPlanes.length = parentContext.unionPlanes.length;\n\n\t\t\t} else {\n\n\t\t\t\tthis.intersectionPlanes.length = parentContext.intersectionPlanes.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst srcClippingPlanes = clippingGroup.clippingPlanes;\n\t\tconst l = srcClippingPlanes.length;\n\n\t\tlet dstClippingPlanes;\n\t\tlet offset;\n\n\t\tif ( this.clipIntersection ) {\n\n\t\t\tdstClippingPlanes = this.intersectionPlanes;\n\t\t\toffset = parentContext.intersectionPlanes.length;\n\n\t\t} else {\n\n\t\t\tdstClippingPlanes = this.unionPlanes;\n\t\t\toffset = parentContext.unionPlanes.length;\n\n\t\t}\n\n\t\tif ( dstClippingPlanes.length !== offset + l ) {\n\n\t\t\tdstClippingPlanes.length = offset + l;\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tdstClippingPlanes[ offset + i ] = new Vector4();\n\n\t\t\t}\n\n\t\t\tupdate = true;\n\n\t\t}\n\n\t\tthis.projectPlanes( srcClippingPlanes, dstClippingPlanes, offset );\n\n\t\tif ( update ) {\n\n\t\t\tthis.version ++;\n\t\t\tthis.cacheKey = `${ this.intersectionPlanes.length }:${ this.unionPlanes.length }`;\n\n\t\t}\n\n\t}\n\n\tgetGroupContext( clippingGroup ) {\n\n\t\tif ( this.shadowPass && ! clippingGroup.clipShadows ) return this;\n\n\t\tlet context = this.clippingGroupContexts.get( clippingGroup );\n\n\t\tif ( context === undefined ) {\n\n\t\t\tcontext = new ClippingContext( this );\n\t\t\tthis.clippingGroupContexts.set( clippingGroup, context );\n\n\t\t}\n\n\t\tcontext.update( this, clippingGroup );\n\n\t\treturn context;\n\n\t}\n\n\tget unionClippingCount() {\n\n\t\treturn this.unionPlanes.length;\n\n\t}\n\n}\n\nclass RenderBundle {\n\n\tconstructor( scene, camera ) {\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t}\n\n\tclone() {\n\n\t\treturn Object.assign( new this.constructor(), this );\n\n\t}\n\n}\n\nclass RenderBundles {\n\n\tconstructor() {\n\n\t\tthis.lists = new ChainMap();\n\n\t}\n\n\tget( scene, camera ) {\n\n\t\tconst lists = this.lists;\n\t\tconst keys = [ scene, camera ];\n\n\t\tlet list = lists.get( keys );\n\n\t\tif ( list === undefined ) {\n\n\t\t\tlist = new RenderBundle( scene, camera );\n\t\t\tlists.set( keys, list );\n\n\t\t}\n\n\t\treturn list;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.lists = new ChainMap();\n\n\t}\n\n}\n\nclass NodeLibrary {\n\n\tconstructor() {\n\n\t\tthis.lightNodes = new WeakMap();\n\t\tthis.materialNodes = new Map();\n\t\tthis.toneMappingNodes = new Map();\n\n\t}\n\n\tfromMaterial( material ) {\n\n\t\tif ( material.isNodeMaterial ) return material;\n\n\t\tlet nodeMaterial = null;\n\n\t\tconst nodeMaterialClass = this.getMaterialNodeClass( material.type );\n\n\t\tif ( nodeMaterialClass !== null ) {\n\n\t\t\tnodeMaterial = new nodeMaterialClass();\n\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tnodeMaterial[ key ] = material[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeMaterial;\n\n\t}\n\n\taddToneMapping( toneMappingNode, toneMapping ) {\n\n\t\tthis.addType( toneMappingNode, toneMapping, this.toneMappingNodes );\n\n\t}\n\n\tgetToneMappingFunction( toneMapping ) {\n\n\t\treturn this.toneMappingNodes.get( toneMapping ) || null;\n\n\t}\n\n\tgetMaterialNodeClass( materialType ) {\n\n\t\treturn this.materialNodes.get( materialType ) || null;\n\n\t}\n\n\taddMaterial( materialNodeClass, materialClassType ) {\n\n\t\tthis.addType( materialNodeClass, materialClassType, this.materialNodes );\n\n\t}\n\n\tgetLightNodeClass( light ) {\n\n\t\treturn this.lightNodes.get( light ) || null;\n\n\t}\n\n\taddLight( lightNodeClass, lightClass ) {\n\n\t\tthis.addClass( lightNodeClass, lightClass, this.lightNodes );\n\n\t}\n\n\taddType( nodeClass, type, library ) {\n\n\t\tif ( library.has( type ) ) {\n\n\t\t\tconsole.warn( `Redefinition of node ${ type }` );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );\n\t\tif ( typeof type === 'function' || typeof type === 'object' ) throw new Error( `Base class ${ type } is not a class.` );\n\n\t\tlibrary.set( type, nodeClass );\n\n\t}\n\n\taddClass( nodeClass, baseClass, library ) {\n\n\t\tif ( library.has( baseClass ) ) {\n\n\t\t\tconsole.warn( `Redefinition of node ${ baseClass.name }` );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );\n\t\tif ( typeof baseClass !== 'function' ) throw new Error( `Base class ${ baseClass.name } is not a class.` );\n\n\t\tlibrary.set( baseClass, nodeClass );\n\n\t}\n\n}\n\nconst _defaultLights = /*@__PURE__*/ new LightsNode();\n\nclass Lighting extends ChainMap {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t}\n\n\tcreateNode( lights = [] ) {\n\n\t\treturn new LightsNode().setLights( lights );\n\n\t}\n\n\tgetNode( scene, camera ) {\n\n\t\t// ignore post-processing\n\n\t\tif ( scene.isQuadMesh ) return _defaultLights;\n\n\t\t// tiled lighting\n\n\t\tconst keys = [ scene, camera ];\n\n\t\tlet node = this.get( keys );\n\n\t\tif ( node === undefined ) {\n\n\t\t\tnode = this.createNode();\n\t\t\tthis.set( keys, node );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nconst _scene = /*@__PURE__*/ new Scene();\nconst _drawingBufferSize = /*@__PURE__*/ new Vector2();\nconst _screen = /*@__PURE__*/ new Vector4();\nconst _frustum = /*@__PURE__*/ new Frustum();\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _vector4 = /*@__PURE__*/ new Vector4();\n\nclass Renderer {\n\n\tconstructor( backend, parameters = {} ) {\n\n\t\tthis.isRenderer = true;\n\n\t\t//\n\n\t\tconst {\n\t\t\tlogarithmicDepthBuffer = false,\n\t\t\talpha = true,\n\t\t\tdepth = true,\n\t\t\tstencil = false,\n\t\t\tantialias = false,\n\t\t\tsamples = 0,\n\t\t\tgetFallback = null\n\t\t} = parameters;\n\n\t\t// public\n\t\tthis.domElement = backend.getDomElement();\n\n\t\tthis.backend = backend;\n\n\t\tthis.samples = samples || ( antialias === true ) ? 4 : 0;\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\n\t\tthis.alpha = alpha;\n\n\t\tthis.logarithmicDepthBuffer = logarithmicDepthBuffer;\n\n\t\tthis.outputColorSpace = SRGBColorSpace;\n\n\t\tthis.toneMapping = NoToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\n\t\tthis.sortObjects = true;\n\n\t\tthis.depth = depth;\n\t\tthis.stencil = stencil;\n\n\t\tthis.info = new Info();\n\n\t\tthis.nodes = {\n\t\t\tmodelViewMatrix: null,\n\t\t\tmodelNormalViewMatrix: null\n\t\t};\n\n\t\tthis.library = new NodeLibrary();\n\t\tthis.lighting = new Lighting();\n\n\t\t// internals\n\n\t\tthis._getFallback = getFallback;\n\n\t\tthis._pixelRatio = 1;\n\t\tthis._width = this.domElement.width;\n\t\tthis._height = this.domElement.height;\n\n\t\tthis._viewport = new Vector4( 0, 0, this._width, this._height );\n\t\tthis._scissor = new Vector4( 0, 0, this._width, this._height );\n\t\tthis._scissorTest = false;\n\n\t\tthis._attributes = null;\n\t\tthis._geometries = null;\n\t\tthis._nodes = null;\n\t\tthis._animation = null;\n\t\tthis._bindings = null;\n\t\tthis._objects = null;\n\t\tthis._pipelines = null;\n\t\tthis._bundles = null;\n\t\tthis._renderLists = null;\n\t\tthis._renderContexts = null;\n\t\tthis._textures = null;\n\t\tthis._background = null;\n\n\t\tthis._quad = new QuadMesh( new NodeMaterial() );\n\t\tthis._quad.material.type = 'Renderer_output';\n\n\t\tthis._currentRenderContext = null;\n\n\t\tthis._opaqueSort = null;\n\t\tthis._transparentSort = null;\n\n\t\tthis._frameBufferTarget = null;\n\n\t\tconst alphaClear = this.alpha === true ? 0 : 1;\n\n\t\tthis._clearColor = new Color4( 0, 0, 0, alphaClear );\n\t\tthis._clearDepth = 1;\n\t\tthis._clearStencil = 0;\n\n\t\tthis._renderTarget = null;\n\t\tthis._activeCubeFace = 0;\n\t\tthis._activeMipmapLevel = 0;\n\n\t\tthis._mrt = null;\n\n\t\tthis._renderObjectFunction = null;\n\t\tthis._currentRenderObjectFunction = null;\n\t\tthis._currentRenderBundle = null;\n\n\t\tthis._handleObjectFunction = this._renderObjectDirect;\n\n\t\tthis._isDeviceLost = false;\n\t\tthis.onDeviceLost = this._onDeviceLost;\n\n\t\tthis._initialized = false;\n\t\tthis._initPromise = null;\n\n\t\tthis._compilationPromises = null;\n\n\t\tthis.transparent = true;\n\t\tthis.opaque = true;\n\n\t\tthis.shadowMap = {\n\t\t\tenabled: false,\n\t\t\ttype: PCFShadowMap\n\t\t};\n\n\t\tthis.xr = {\n\t\t\tenabled: false\n\t\t};\n\n\t\tthis.debug = {\n\t\t\tcheckShaderErrors: true,\n\t\t\tonShaderError: null,\n\t\t\tgetShaderAsync: async ( scene, camera, object ) => {\n\n\t\t\t\tawait this.compileAsync( scene, camera );\n\n\t\t\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\t\t\tconst renderContext = this._renderContexts.get( scene, camera, this._renderTarget );\n\n\t\t\t\tconst material = scene.overrideMaterial || object.material;\n\n\t\t\t\tconst renderObject = this._objects.get( object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext );\n\n\t\t\t\tconst { fragmentShader, vertexShader } = renderObject.getNodeBuilderState();\n\n\t\t\t\treturn { fragmentShader, vertexShader };\n\n\t\t\t}\n\t\t};\n\n\t}\n\n\tasync init() {\n\n\t\tif ( this._initialized ) {\n\n\t\t\tthrow new Error( 'Renderer: Backend has already been initialized.' );\n\n\t\t}\n\n\t\tif ( this._initPromise !== null ) {\n\n\t\t\treturn this._initPromise;\n\n\t\t}\n\n\t\tthis._initPromise = new Promise( async ( resolve, reject ) => {\n\n\t\t\tlet backend = this.backend;\n\n\t\t\ttry {\n\n\t\t\t\tawait backend.init( this );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( this._getFallback !== null ) {\n\n\t\t\t\t\t// try the fallback\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tthis.backend = backend = this._getFallback( error );\n\t\t\t\t\t\tawait backend.init( this );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\treject( error );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\treject( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._nodes = new Nodes( this, backend );\n\t\t\tthis._animation = new Animation( this._nodes, this.info );\n\t\t\tthis._attributes = new Attributes( backend );\n\t\t\tthis._background = new Background( this, this._nodes );\n\t\t\tthis._geometries = new Geometries( this._attributes, this.info );\n\t\t\tthis._textures = new Textures( this, backend, this.info );\n\t\t\tthis._pipelines = new Pipelines( backend, this._nodes );\n\t\t\tthis._bindings = new Bindings( backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info );\n\t\t\tthis._objects = new RenderObjects( this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info );\n\t\t\tthis._renderLists = new RenderLists( this.lighting );\n\t\t\tthis._bundles = new RenderBundles();\n\t\t\tthis._renderContexts = new RenderContexts();\n\n\t\t\t//\n\n\t\t\tthis._animation.start();\n\t\t\tthis._initialized = true;\n\n\t\t\tresolve();\n\n\t\t} );\n\n\t\treturn this._initPromise;\n\n\t}\n\n\tget coordinateSystem() {\n\n\t\treturn this.backend.coordinateSystem;\n\n\t}\n\n\tasync compileAsync( scene, camera, targetScene = null ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\t// preserve render tree\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\t\tconst previousRenderContext = this._currentRenderContext;\n\t\tconst previousRenderObjectFunction = this._currentRenderObjectFunction;\n\t\tconst previousCompilationPromises = this._compilationPromises;\n\n\t\t//\n\n\t\tconst sceneRef = ( scene.isScene === true ) ? scene : _scene;\n\n\t\tif ( targetScene === null ) targetScene = scene;\n\n\t\tconst renderTarget = this._renderTarget;\n\t\tconst renderContext = this._renderContexts.get( targetScene, camera, renderTarget );\n\t\tconst activeMipmapLevel = this._activeMipmapLevel;\n\n\t\tconst compilationPromises = [];\n\n\t\tthis._currentRenderContext = renderContext;\n\t\tthis._currentRenderObjectFunction = this.renderObject;\n\n\t\tthis._handleObjectFunction = this._createObjectPipeline;\n\n\t\tthis._compilationPromises = compilationPromises;\n\n\t\tnodeFrame.renderId ++;\n\n\t\t//\n\n\t\tnodeFrame.update();\n\n\t\t//\n\n\t\trenderContext.depth = this.depth;\n\t\trenderContext.stencil = this.stencil;\n\n\t\tif ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();\n\t\trenderContext.clippingContext.updateGlobal( sceneRef, camera );\n\n\t\t//\n\n\t\tsceneRef.onBeforeRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\trenderList.begin();\n\n\t\tthis._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );\n\n\t\t// include lights from target scene\n\t\tif ( targetScene !== scene ) {\n\n\t\t\ttargetScene.traverseVisible( function ( object ) {\n\n\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\trenderList.pushLight( object );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\trenderList.finish();\n\n\t\t//\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget, activeMipmapLevel );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\n\t\t} else {\n\n\t\t\trenderContext.textures = null;\n\t\t\trenderContext.depthTexture = null;\n\n\t\t}\n\n\t\t//\n\n\t\tthis._nodes.updateScene( sceneRef );\n\n\t\t//\n\n\t\tthis._background.update( sceneRef, renderList, renderContext );\n\n\t\t// process render lists\n\n\t\tconst opaqueObjects = renderList.opaque;\n\t\tconst transparentObjects = renderList.transparent;\n\t\tconst transparentDoublePassObjects = renderList.transparentDoublePass;\n\t\tconst lightsNode = renderList.lightsNode;\n\n\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\tif ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );\n\n\t\t// restore render tree\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t\tthis._currentRenderContext = previousRenderContext;\n\t\tthis._currentRenderObjectFunction = previousRenderObjectFunction;\n\t\tthis._compilationPromises = previousCompilationPromises;\n\n\t\tthis._handleObjectFunction = this._renderObjectDirect;\n\n\t\t// wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete\n\n\t\tawait Promise.all( compilationPromises );\n\n\t}\n\n\tasync renderAsync( scene, camera ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tconst renderContext = this._renderScene( scene, camera );\n\n\t\tawait this.backend.resolveTimestampAsync( renderContext, 'render' );\n\n\t}\n\n\tasync waitForGPU() {\n\n\t\tawait this.backend.waitForGPU();\n\n\t}\n\n\tsetMRT( mrt ) {\n\n\t\tthis._mrt = mrt;\n\n\t\treturn this;\n\n\t}\n\n\tgetMRT() {\n\n\t\treturn this._mrt;\n\n\t}\n\n\t_onDeviceLost( info ) {\n\n\t\tlet errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\\n\\nMessage: ${info.message}`;\n\n\t\tif ( info.reason ) {\n\n\t\t\terrorMessage += `\\nReason: ${info.reason}`;\n\n\t\t}\n\n\t\tconsole.error( errorMessage );\n\n\t\tthis._isDeviceLost = true;\n\n\t}\n\n\n\t_renderBundle( bundle, sceneRef, lightsNode ) {\n\n\t\tconst { bundleGroup, camera, renderList } = bundle;\n\n\t\tconst renderContext = this._currentRenderContext;\n\n\t\t//\n\n\t\tconst renderBundle = this._bundles.get( bundleGroup, camera );\n\t\tconst renderBundleData = this.backend.get( renderBundle );\n\n\t\tif ( renderBundleData.renderContexts === undefined ) renderBundleData.renderContexts = new Set();\n\n\t\t//\n\n\t\tconst needsUpdate = bundleGroup.version !== renderBundleData.version;\n\t\tconst renderBundleNeedsUpdate = renderBundleData.renderContexts.has( renderContext ) === false || needsUpdate;\n\n\t\trenderBundleData.renderContexts.add( renderContext );\n\n\t\tif ( renderBundleNeedsUpdate ) {\n\n\t\t\tthis.backend.beginBundle( renderContext );\n\n\t\t\tif ( renderBundleData.renderObjects === undefined || needsUpdate ) {\n\n\t\t\t\trenderBundleData.renderObjects = [];\n\n\t\t\t}\n\n\t\t\tthis._currentRenderBundle = renderBundle;\n\n\t\t\tconst opaqueObjects = renderList.opaque;\n\n\t\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\n\t\t\tthis._currentRenderBundle = null;\n\n\t\t\t//\n\n\t\t\tthis.backend.finishBundle( renderContext, renderBundle );\n\n\t\t\trenderBundleData.version = bundleGroup.version;\n\n\t\t} else {\n\n\t\t\tconst { renderObjects } = renderBundleData;\n\n\t\t\tfor ( let i = 0, l = renderObjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst renderObject = renderObjects[ i ];\n\n\t\t\t\tif ( this._nodes.needsRefresh( renderObject ) ) {\n\n\t\t\t\t\tthis._nodes.updateBefore( renderObject );\n\n\t\t\t\t\tthis._nodes.updateForRender( renderObject );\n\t\t\t\t\tthis._bindings.updateForRender( renderObject );\n\n\t\t\t\t\tthis._nodes.updateAfter( renderObject );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.backend.addBundle( renderContext, renderBundle );\n\n\t}\n\n\trender( scene, camera ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.' );\n\n\t\t\treturn this.renderAsync( scene, camera );\n\n\t\t}\n\n\t\tthis._renderScene( scene, camera );\n\n\t}\n\n\t_getFrameBufferTarget() {\n\n\t\tconst { currentToneMapping, currentColorSpace } = this;\n\n\t\tconst useToneMapping = currentToneMapping !== NoToneMapping;\n\t\tconst useColorSpace = currentColorSpace !== LinearSRGBColorSpace;\n\n\t\tif ( useToneMapping === false && useColorSpace === false ) return null;\n\n\t\tconst { width, height } = this.getDrawingBufferSize( _drawingBufferSize );\n\t\tconst { depth, stencil } = this;\n\n\t\tlet frameBufferTarget = this._frameBufferTarget;\n\n\t\tif ( frameBufferTarget === null ) {\n\n\t\t\tframeBufferTarget = new RenderTarget( width, height, {\n\t\t\t\tdepthBuffer: depth,\n\t\t\t\tstencilBuffer: stencil,\n\t\t\t\ttype: HalfFloatType, // FloatType\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\t\tgenerateMipmaps: false,\n\t\t\t\tminFilter: LinearFilter,\n\t\t\t\tmagFilter: LinearFilter,\n\t\t\t\tsamples: this.samples\n\t\t\t} );\n\n\t\t\tframeBufferTarget.isPostProcessingRenderTarget = true;\n\n\t\t\tthis._frameBufferTarget = frameBufferTarget;\n\n\t\t}\n\n\t\tframeBufferTarget.depthBuffer = depth;\n\t\tframeBufferTarget.stencilBuffer = stencil;\n\t\tframeBufferTarget.setSize( width, height );\n\t\tframeBufferTarget.viewport.copy( this._viewport );\n\t\tframeBufferTarget.scissor.copy( this._scissor );\n\t\tframeBufferTarget.viewport.multiplyScalar( this._pixelRatio );\n\t\tframeBufferTarget.scissor.multiplyScalar( this._pixelRatio );\n\t\tframeBufferTarget.scissorTest = this._scissorTest;\n\n\t\treturn frameBufferTarget;\n\n\t}\n\n\t_renderScene( scene, camera, useFrameBufferTarget = true ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\tconst frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;\n\n\t\t// preserve render tree\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\t\tconst previousRenderContext = this._currentRenderContext;\n\t\tconst previousRenderObjectFunction = this._currentRenderObjectFunction;\n\n\t\t//\n\n\t\tconst sceneRef = ( scene.isScene === true ) ? scene : _scene;\n\n\t\tconst outputRenderTarget = this._renderTarget;\n\n\t\tconst activeCubeFace = this._activeCubeFace;\n\t\tconst activeMipmapLevel = this._activeMipmapLevel;\n\n\t\t//\n\n\t\tlet renderTarget;\n\n\t\tif ( frameBufferTarget !== null ) {\n\n\t\t\trenderTarget = frameBufferTarget;\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\n\t\t} else {\n\n\t\t\trenderTarget = outputRenderTarget;\n\n\t\t}\n\n\t\t//\n\n\t\tconst renderContext = this._renderContexts.get( scene, camera, renderTarget );\n\n\t\tthis._currentRenderContext = renderContext;\n\t\tthis._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;\n\n\t\t//\n\n\t\tthis.info.calls ++;\n\t\tthis.info.render.calls ++;\n\t\tthis.info.render.frameCalls ++;\n\n\t\tnodeFrame.renderId = this.info.calls;\n\n\t\t//\n\n\t\tconst coordinateSystem = this.coordinateSystem;\n\n\t\tif ( camera.coordinateSystem !== coordinateSystem ) {\n\n\t\t\tcamera.coordinateSystem = coordinateSystem;\n\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\n\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\t//\n\n\t\tlet viewport = this._viewport;\n\t\tlet scissor = this._scissor;\n\t\tlet pixelRatio = this._pixelRatio;\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tviewport = renderTarget.viewport;\n\t\t\tscissor = renderTarget.scissor;\n\t\t\tpixelRatio = 1;\n\n\t\t}\n\n\t\tthis.getDrawingBufferSize( _drawingBufferSize );\n\n\t\t_screen.set( 0, 0, _drawingBufferSize.width, _drawingBufferSize.height );\n\n\t\tconst minDepth = ( viewport.minDepth === undefined ) ? 0 : viewport.minDepth;\n\t\tconst maxDepth = ( viewport.maxDepth === undefined ) ? 1 : viewport.maxDepth;\n\n\t\trenderContext.viewportValue.copy( viewport ).multiplyScalar( pixelRatio ).floor();\n\t\trenderContext.viewportValue.width >>= activeMipmapLevel;\n\t\trenderContext.viewportValue.height >>= activeMipmapLevel;\n\t\trenderContext.viewportValue.minDepth = minDepth;\n\t\trenderContext.viewportValue.maxDepth = maxDepth;\n\t\trenderContext.viewport = renderContext.viewportValue.equals( _screen ) === false;\n\n\t\trenderContext.scissorValue.copy( scissor ).multiplyScalar( pixelRatio ).floor();\n\t\trenderContext.scissor = this._scissorTest && renderContext.scissorValue.equals( _screen ) === false;\n\t\trenderContext.scissorValue.width >>= activeMipmapLevel;\n\t\trenderContext.scissorValue.height >>= activeMipmapLevel;\n\n\t\tif ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();\n\t\trenderContext.clippingContext.updateGlobal( sceneRef, camera );\n\n\t\t//\n\n\t\tsceneRef.onBeforeRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromProjectionMatrix( _projScreenMatrix, coordinateSystem );\n\n\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\trenderList.begin();\n\n\t\tthis._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );\n\n\t\trenderList.finish();\n\n\t\tif ( this.sortObjects === true ) {\n\n\t\t\trenderList.sort( this._opaqueSort, this._transparentSort );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget, activeMipmapLevel );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\t\t\trenderContext.width = renderTargetData.width;\n\t\t\trenderContext.height = renderTargetData.height;\n\t\t\trenderContext.renderTarget = renderTarget;\n\t\t\trenderContext.depth = renderTarget.depthBuffer;\n\t\t\trenderContext.stencil = renderTarget.stencilBuffer;\n\n\t\t} else {\n\n\t\t\trenderContext.textures = null;\n\t\t\trenderContext.depthTexture = null;\n\t\t\trenderContext.width = this.domElement.width;\n\t\t\trenderContext.height = this.domElement.height;\n\t\t\trenderContext.depth = this.depth;\n\t\t\trenderContext.stencil = this.stencil;\n\n\t\t}\n\n\t\trenderContext.width >>= activeMipmapLevel;\n\t\trenderContext.height >>= activeMipmapLevel;\n\t\trenderContext.activeCubeFace = activeCubeFace;\n\t\trenderContext.activeMipmapLevel = activeMipmapLevel;\n\t\trenderContext.occlusionQueryCount = renderList.occlusionQueryCount;\n\n\t\t//\n\n\t\tthis._nodes.updateScene( sceneRef );\n\n\t\t//\n\n\t\tthis._background.update( sceneRef, renderList, renderContext );\n\n\t\t//\n\n\t\tthis.backend.beginRender( renderContext );\n\n\t\t// process render lists\n\n\t\tconst {\n\t\t\tbundles,\n\t\t\tlightsNode,\n\t\t\ttransparentDoublePass: transparentDoublePassObjects,\n\t\t\ttransparent: transparentObjects,\n\t\t\topaque: opaqueObjects\n\t\t} = renderList;\n\n\t\tif ( bundles.length > 0 ) this._renderBundles( bundles, sceneRef, lightsNode );\n\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\tif ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );\n\n\t\t// finish render pass\n\n\t\tthis.backend.finishRender( renderContext );\n\n\t\t// restore render tree\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t\tthis._currentRenderContext = previousRenderContext;\n\t\tthis._currentRenderObjectFunction = previousRenderObjectFunction;\n\n\t\t//\n\n\t\tif ( frameBufferTarget !== null ) {\n\n\t\t\tthis.setRenderTarget( outputRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t\t\tconst quad = this._quad;\n\n\t\t\tif ( this._nodes.hasOutputChange( renderTarget.texture ) ) {\n\n\t\t\t\tquad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );\n\t\t\t\tquad.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tthis._renderScene( quad, quad.camera, false );\n\n\t\t}\n\n\t\t//\n\n\t\tsceneRef.onAfterRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\treturn renderContext;\n\n\t}\n\n\tgetMaxAnisotropy() {\n\n\t\treturn this.backend.getMaxAnisotropy();\n\n\t}\n\n\tgetActiveCubeFace() {\n\n\t\treturn this._activeCubeFace;\n\n\t}\n\n\tgetActiveMipmapLevel() {\n\n\t\treturn this._activeMipmapLevel;\n\n\t}\n\n\tasync setAnimationLoop( callback ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis._animation.setAnimationLoop( callback );\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.backend.getArrayBufferAsync( attribute );\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.backend.getContext();\n\n\t}\n\n\tgetPixelRatio() {\n\n\t\treturn this._pixelRatio;\n\n\t}\n\n\tgetDrawingBufferSize( target ) {\n\n\t\treturn target.set( this._width * this._pixelRatio, this._height * this._pixelRatio ).floor();\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn target.set( this._width, this._height );\n\n\t}\n\n\tsetPixelRatio( value = 1 ) {\n\n\t\tif ( this._pixelRatio === value ) return;\n\n\t\tthis._pixelRatio = value;\n\n\t\tthis.setSize( this._width, this._height, false );\n\n\t}\n\n\tsetDrawingBufferSize( width, height, pixelRatio ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.domElement.width = Math.floor( width * pixelRatio );\n\t\tthis.domElement.height = Math.floor( height * pixelRatio );\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t\tif ( this._initialized ) this.backend.updateSize();\n\n\t}\n\n\tsetSize( width, height, updateStyle = true ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis.domElement.width = Math.floor( width * this._pixelRatio );\n\t\tthis.domElement.height = Math.floor( height * this._pixelRatio );\n\n\t\tif ( updateStyle === true ) {\n\n\t\t\tthis.domElement.style.width = width + 'px';\n\t\t\tthis.domElement.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t\tif ( this._initialized ) this.backend.updateSize();\n\n\t}\n\n\tsetOpaqueSort( method ) {\n\n\t\tthis._opaqueSort = method;\n\n\t}\n\n\tsetTransparentSort( method ) {\n\n\t\tthis._transparentSort = method;\n\n\t}\n\n\tgetScissor( target ) {\n\n\t\tconst scissor = this._scissor;\n\n\t\ttarget.x = scissor.x;\n\t\ttarget.y = scissor.y;\n\t\ttarget.width = scissor.width;\n\t\ttarget.height = scissor.height;\n\n\t\treturn target;\n\n\t}\n\n\tsetScissor( x, y, width, height ) {\n\n\t\tconst scissor = this._scissor;\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\tscissor.copy( x );\n\n\t\t} else {\n\n\t\t\tscissor.set( x, y, width, height );\n\n\t\t}\n\n\t}\n\n\tgetScissorTest() {\n\n\t\treturn this._scissorTest;\n\n\t}\n\n\tsetScissorTest( boolean ) {\n\n\t\tthis._scissorTest = boolean;\n\n\t\tthis.backend.setScissorTest( boolean );\n\n\t}\n\n\tgetViewport( target ) {\n\n\t\treturn target.copy( this._viewport );\n\n\t}\n\n\tsetViewport( x, y, width, height, minDepth = 0, maxDepth = 1 ) {\n\n\t\tconst viewport = this._viewport;\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\tviewport.copy( x );\n\n\t\t} else {\n\n\t\t\tviewport.set( x, y, width, height );\n\n\t\t}\n\n\t\tviewport.minDepth = minDepth;\n\t\tviewport.maxDepth = maxDepth;\n\n\t}\n\n\tgetClearColor( target ) {\n\n\t\treturn target.copy( this._clearColor );\n\n\t}\n\n\tsetClearColor( color, alpha = 1 ) {\n\n\t\tthis._clearColor.set( color );\n\t\tthis._clearColor.a = alpha;\n\n\t}\n\n\tgetClearAlpha() {\n\n\t\treturn this._clearColor.a;\n\n\t}\n\n\tsetClearAlpha( alpha ) {\n\n\t\tthis._clearColor.a = alpha;\n\n\t}\n\n\tgetClearDepth() {\n\n\t\treturn this._clearDepth;\n\n\t}\n\n\tsetClearDepth( depth ) {\n\n\t\tthis._clearDepth = depth;\n\n\t}\n\n\tgetClearStencil() {\n\n\t\treturn this._clearStencil;\n\n\t}\n\n\tsetClearStencil( stencil ) {\n\n\t\tthis._clearStencil = stencil;\n\n\t}\n\n\tisOccluded( object ) {\n\n\t\tconst renderContext = this._currentRenderContext;\n\n\t\treturn renderContext && this.backend.isOccluded( renderContext, object );\n\n\t}\n\n\tclear( color = true, depth = true, stencil = true ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.' );\n\n\t\t\treturn this.clearAsync( color, depth, stencil );\n\n\t\t}\n\n\t\tconst renderTarget = this._renderTarget || this._getFrameBufferTarget();\n\n\t\tlet renderTargetData = null;\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget );\n\n\t\t\trenderTargetData = this._textures.get( renderTarget );\n\n\t\t}\n\n\t\tthis.backend.clear( color, depth, stencil, renderTargetData );\n\n\t\tif ( renderTarget !== null && this._renderTarget === null ) {\n\n\t\t\t// If a color space transform or tone mapping is required,\n\t\t\t// the clear operation clears the intermediate renderTarget texture, but does not update the screen canvas.\n\n\t\t\tconst quad = this._quad;\n\n\t\t\tif ( this._nodes.hasOutputChange( renderTarget.texture ) ) {\n\n\t\t\t\tquad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );\n\t\t\t\tquad.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tthis._renderScene( quad, quad.camera, false );\n\n\t\t}\n\n\t}\n\n\tclearColor() {\n\n\t\treturn this.clear( true, false, false );\n\n\t}\n\n\tclearDepth() {\n\n\t\treturn this.clear( false, true, false );\n\n\t}\n\n\tclearStencil() {\n\n\t\treturn this.clear( false, false, true );\n\n\t}\n\n\tasync clearAsync( color = true, depth = true, stencil = true ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis.clear( color, depth, stencil );\n\n\t}\n\n\tclearColorAsync() {\n\n\t\treturn this.clearAsync( true, false, false );\n\n\t}\n\n\tclearDepthAsync() {\n\n\t\treturn this.clearAsync( false, true, false );\n\n\t}\n\n\tclearStencilAsync() {\n\n\t\treturn this.clearAsync( false, false, true );\n\n\t}\n\n\tget currentToneMapping() {\n\n\t\treturn this._renderTarget !== null ? NoToneMapping : this.toneMapping;\n\n\t}\n\n\tget currentColorSpace() {\n\n\t\treturn this._renderTarget !== null ? LinearSRGBColorSpace : this.outputColorSpace;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.info.dispose();\n\t\tthis.backend.dispose();\n\n\t\tthis._animation.dispose();\n\t\tthis._objects.dispose();\n\t\tthis._pipelines.dispose();\n\t\tthis._nodes.dispose();\n\t\tthis._bindings.dispose();\n\t\tthis._renderLists.dispose();\n\t\tthis._renderContexts.dispose();\n\t\tthis._textures.dispose();\n\n\t\tthis.setRenderTarget( null );\n\t\tthis.setAnimationLoop( null );\n\n\t}\n\n\tsetRenderTarget( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\tthis._renderTarget = renderTarget;\n\t\tthis._activeCubeFace = activeCubeFace;\n\t\tthis._activeMipmapLevel = activeMipmapLevel;\n\n\t}\n\n\tgetRenderTarget() {\n\n\t\treturn this._renderTarget;\n\n\t}\n\n\tsetRenderObjectFunction( renderObjectFunction ) {\n\n\t\tthis._renderObjectFunction = renderObjectFunction;\n\n\t}\n\n\tgetRenderObjectFunction() {\n\n\t\treturn this._renderObjectFunction;\n\n\t}\n\n\tcompute( computeNodes ) {\n\n\t\tif ( this.isDeviceLost === true ) return;\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.' );\n\n\t\t\treturn this.computeAsync( computeNodes );\n\n\t\t}\n\n\t\t//\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\n\t\t//\n\n\t\tthis.info.calls ++;\n\t\tthis.info.compute.calls ++;\n\t\tthis.info.compute.frameCalls ++;\n\n\t\tnodeFrame.renderId = this.info.calls;\n\n\t\t//\n\n\t\tconst backend = this.backend;\n\t\tconst pipelines = this._pipelines;\n\t\tconst bindings = this._bindings;\n\t\tconst nodes = this._nodes;\n\n\t\tconst computeList = Array.isArray( computeNodes ) ? computeNodes : [ computeNodes ];\n\n\t\tif ( computeList[ 0 ] === undefined || computeList[ 0 ].isComputeNode !== true ) {\n\n\t\t\tthrow new Error( 'THREE.Renderer: .compute() expects a ComputeNode.' );\n\n\t\t}\n\n\t\tbackend.beginCompute( computeNodes );\n\n\t\tfor ( const computeNode of computeList ) {\n\n\t\t\t// onInit\n\n\t\t\tif ( pipelines.has( computeNode ) === false ) {\n\n\t\t\t\tconst dispose = () => {\n\n\t\t\t\t\tcomputeNode.removeEventListener( 'dispose', dispose );\n\n\t\t\t\t\tpipelines.delete( computeNode );\n\t\t\t\t\tbindings.delete( computeNode );\n\t\t\t\t\tnodes.delete( computeNode );\n\n\t\t\t\t};\n\n\t\t\t\tcomputeNode.addEventListener( 'dispose', dispose );\n\n\t\t\t\t//\n\n\t\t\t\tconst onInitFn = computeNode.onInitFunction;\n\n\t\t\t\tif ( onInitFn !== null ) {\n\n\t\t\t\t\tonInitFn.call( computeNode, { renderer: this } );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnodes.updateForCompute( computeNode );\n\t\t\tbindings.updateForCompute( computeNode );\n\n\t\t\tconst computeBindings = bindings.getForCompute( computeNode );\n\t\t\tconst computePipeline = pipelines.getForCompute( computeNode, computeBindings );\n\n\t\t\tbackend.compute( computeNodes, computeNode, computeBindings, computePipeline );\n\n\t\t}\n\n\t\tbackend.finishCompute( computeNodes );\n\n\t\t//\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t}\n\n\tasync computeAsync( computeNodes ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis.compute( computeNodes );\n\n\t\tawait this.backend.resolveTimestampAsync( computeNodes, 'compute' );\n\n\t}\n\n\tasync hasFeatureAsync( name ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\treturn this.backend.hasFeature( name );\n\n\t}\n\n\thasFeature( name ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.' );\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.backend.hasFeature( name );\n\n\t}\n\n\thasInitialized() {\n\n\t\treturn this._initialized;\n\n\t}\n\n\tasync initTextureAsync( texture ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis._textures.updateTexture( texture );\n\n\t}\n\n\tinitTexture( texture ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.' );\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tthis._textures.updateTexture( texture );\n\n\t}\n\n\tcopyFramebufferToTexture( framebufferTexture, rectangle = null ) {\n\n\t\tif ( rectangle !== null ) {\n\n\t\t\tif ( rectangle.isVector2 ) {\n\n\t\t\t\trectangle = _vector4.set( rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height ).floor();\n\n\t\t\t} else if ( rectangle.isVector4 ) {\n\n\t\t\t\trectangle = _vector4.copy( rectangle ).floor();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.' );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trectangle = _vector4.set( 0, 0, framebufferTexture.image.width, framebufferTexture.image.height );\n\n\t\t}\n\n\t\t//\n\n\t\tlet renderContext = this._currentRenderContext;\n\t\tlet renderTarget;\n\n\t\tif ( renderContext !== null ) {\n\n\t\t\trenderTarget = renderContext.renderTarget;\n\n\t\t} else {\n\n\t\t\trenderTarget = this._renderTarget || this._getFrameBufferTarget();\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tthis._textures.updateRenderTarget( renderTarget );\n\n\t\t\t\trenderContext = this._textures.get( renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tthis._textures.updateTexture( framebufferTexture, { renderTarget } );\n\n\t\tthis.backend.copyFramebufferToTexture( framebufferTexture, renderContext, rectangle );\n\n\t}\n\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\tthis._textures.updateTexture( srcTexture );\n\t\tthis._textures.updateTexture( dstTexture );\n\n\t\tthis.backend.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );\n\n\t}\n\n\treadRenderTargetPixelsAsync( renderTarget, x, y, width, height, index = 0, faceIndex = 0 ) {\n\n\t\treturn this.backend.copyTextureToBuffer( renderTarget.textures[ index ], x, y, width, height, faceIndex );\n\n\t}\n\n\t_projectObject( object, camera, groupOrder, renderList, clippingContext ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible ) {\n\n\t\t\tif ( object.isGroup ) {\n\n\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t\tif ( object.isClippingGroup && object.enabled ) clippingContext = clippingContext.getGroupContext( object );\n\n\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\trenderList.pushLight( object );\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\t_vector4.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { geometry, material } = object;\n\n\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\trenderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\tconsole.error( 'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.' );\n\n\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tconst { geometry, material } = object;\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\t\t\t_vector4\n\t\t\t\t\t\t\t.copy( geometry.boundingSphere.center )\n\t\t\t\t\t\t\t.applyMatrix4( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\trenderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\trenderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.isBundleGroup === true && this.backend.beginBundle !== undefined ) {\n\n\t\t\tconst baseRenderList = renderList;\n\n\t\t\t// replace render list\n\t\t\trenderList = this._renderLists.get( object, camera );\n\n\t\t\trenderList.begin();\n\n\t\t\tbaseRenderList.pushBundle( {\n\t\t\t\tbundleGroup: object,\n\t\t\t\tcamera,\n\t\t\t\trenderList,\n\t\t\t} );\n\n\t\t\trenderList.finish();\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis._projectObject( children[ i ], camera, groupOrder, renderList, clippingContext );\n\n\t\t}\n\n\t}\n\n\t_renderBundles( bundles, sceneRef, lightsNode ) {\n\n\t\tfor ( const bundle of bundles ) {\n\n\t\t\tthis._renderBundle( bundle, sceneRef, lightsNode );\n\n\t\t}\n\n\t}\n\n\t_renderTransparents( renderList, doublePassList, camera, scene, lightsNode ) {\n\n\t\tif ( doublePassList.length > 0 ) {\n\n\t\t\t// render back side\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\n\t\t\t}\n\n\t\t\tthis._renderObjects( doublePassList, camera, scene, lightsNode, 'backSide' );\n\n\t\t\t// render front side\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = FrontSide;\n\n\t\t\t}\n\n\t\t\tthis._renderObjects( renderList, camera, scene, lightsNode );\n\n\t\t\t// restore\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis._renderObjects( renderList, camera, scene, lightsNode );\n\n\t\t}\n\n\t}\n\n\t_renderObjects( renderList, camera, scene, lightsNode, passId = null ) {\n\n\t\t// process renderable objects\n\n\t\tfor ( let i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = renderList[ i ];\n\n\t\t\t// @TODO: Add support for multiple materials per object. This will require to extract\n\t\t\t// the material from the renderItem object and pass it with its group data to renderObject().\n\n\t\t\tconst { object, geometry, material, group, clippingContext } = renderItem;\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\tconst cameras = camera.cameras;\n\n\t\t\t\tfor ( let j = 0, jl = cameras.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst camera2 = cameras[ j ];\n\n\t\t\t\t\tif ( object.layers.test( camera2.layers ) ) {\n\n\t\t\t\t\t\tconst vp = camera2.viewport;\n\t\t\t\t\t\tconst minDepth = ( vp.minDepth === undefined ) ? 0 : vp.minDepth;\n\t\t\t\t\t\tconst maxDepth = ( vp.maxDepth === undefined ) ? 1 : vp.maxDepth;\n\n\t\t\t\t\t\tconst viewportValue = this._currentRenderContext.viewportValue;\n\t\t\t\t\t\tviewportValue.copy( vp ).multiplyScalar( this._pixelRatio ).floor();\n\t\t\t\t\t\tviewportValue.minDepth = minDepth;\n\t\t\t\t\t\tviewportValue.maxDepth = maxDepth;\n\n\t\t\t\t\t\tthis.backend.updateViewport( this._currentRenderContext );\n\n\t\t\t\t\t\tthis._currentRenderObjectFunction( object, scene, camera2, geometry, material, group, lightsNode, clippingContext, passId );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis._currentRenderObjectFunction( object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\trenderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null ) {\n\n\t\tlet overridePositionNode;\n\t\tlet overrideColorNode;\n\t\tlet overrideDepthNode;\n\n\t\t//\n\n\t\tobject.onBeforeRender( this, scene, camera, geometry, material, group );\n\n\t\t//\n\n\t\tif ( scene.overrideMaterial !== null ) {\n\n\t\t\tconst overrideMaterial = scene.overrideMaterial;\n\n\t\t\tif ( material.positionNode && material.positionNode.isNode ) {\n\n\t\t\t\toverridePositionNode = overrideMaterial.positionNode;\n\t\t\t\toverrideMaterial.positionNode = material.positionNode;\n\n\t\t\t}\n\n\t\t\toverrideMaterial.alphaTest = material.alphaTest;\n\t\t\toverrideMaterial.alphaMap = material.alphaMap;\n\n\t\t\tif ( overrideMaterial.isShadowNodeMaterial ) {\n\n\t\t\t\toverrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;\n\n\t\t\t\tif ( material.depthNode && material.depthNode.isNode ) {\n\n\t\t\t\t\toverrideDepthNode = overrideMaterial.depthNode;\n\t\t\t\t\toverrideMaterial.depthNode = material.depthNode;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.castShadowNode && material.castShadowNode.isNode ) {\n\n\t\t\t\t\toverrideColorNode = overrideMaterial.colorNode;\n\t\t\t\t\toverrideMaterial.colorNode = material.castShadowNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterial = overrideMaterial;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\tmaterial.side = BackSide;\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, 'backSide' ); // create backSide pass id\n\n\t\t\tmaterial.side = FrontSide;\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId ); // use default pass id\n\n\t\t\tmaterial.side = DoubleSide;\n\n\t\t} else {\n\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( overridePositionNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.positionNode = overridePositionNode;\n\n\t\t}\n\n\t\tif ( overrideDepthNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.depthNode = overrideDepthNode;\n\n\t\t}\n\n\t\tif ( overrideColorNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.colorNode = overrideColorNode;\n\n\t\t}\n\n\t\t//\n\n\t\tobject.onAfterRender( this, scene, camera, geometry, material, group );\n\n\t}\n\n\t_renderObjectDirect( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {\n\n\t\tconst renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );\n\t\trenderObject.drawRange = object.geometry.drawRange;\n\t\trenderObject.group = group;\n\n\t\t//\n\n\t\tconst needsRefresh = this._nodes.needsRefresh( renderObject );\n\n\t\tif ( needsRefresh ) {\n\n\t\t\tthis._nodes.updateBefore( renderObject );\n\n\t\t\tthis._geometries.updateForRender( renderObject );\n\n\t\t\tthis._nodes.updateForRender( renderObject );\n\t\t\tthis._bindings.updateForRender( renderObject );\n\n\t\t}\n\n\t\tthis._pipelines.updateForRender( renderObject );\n\n\t\t//\n\n\t\tif ( this._currentRenderBundle !== null ) {\n\n\t\t\tconst renderBundleData = this.backend.get( this._currentRenderBundle );\n\n\t\t\trenderBundleData.renderObjects.push( renderObject );\n\n\t\t\trenderObject.bundle = this._currentRenderBundle.scene;\n\n\t\t}\n\n\t\tthis.backend.draw( renderObject, this.info );\n\n\t\tif ( needsRefresh ) this._nodes.updateAfter( renderObject );\n\n\t}\n\n\t_createObjectPipeline( object, material, scene, camera, lightsNode, clippingContext, passId ) {\n\n\t\tconst renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );\n\n\t\t//\n\n\t\tthis._nodes.updateBefore( renderObject );\n\n\t\tthis._geometries.updateForRender( renderObject );\n\n\t\tthis._nodes.updateForRender( renderObject );\n\t\tthis._bindings.updateForRender( renderObject );\n\n\t\tthis._pipelines.getForRender( renderObject, this._compilationPromises );\n\n\t\tthis._nodes.updateAfter( renderObject );\n\n\t}\n\n\tget compile() {\n\n\t\treturn this.compileAsync;\n\n\t}\n\n}\n\nclass Binding {\n\n\tconstructor( name = '' ) {\n\n\t\tthis.name = name;\n\n\t\tthis.visibility = 0;\n\n\t}\n\n\tsetVisibility( visibility ) {\n\n\t\tthis.visibility |= visibility;\n\n\t}\n\n\tclone() {\n\n\t\treturn Object.assign( new this.constructor(), this );\n\n\t}\n\n}\n\nfunction getFloatLength( floatLength ) {\n\n\t// ensure chunk size alignment (STD140 layout)\n\n\treturn floatLength + ( ( GPU_CHUNK_BYTES - ( floatLength % GPU_CHUNK_BYTES ) ) % GPU_CHUNK_BYTES );\n\n}\n\nclass Buffer extends Binding {\n\n\tconstructor( name, buffer = null ) {\n\n\t\tsuper( name );\n\n\t\tthis.isBuffer = true;\n\n\t\tthis.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;\n\n\t\tthis._buffer = buffer;\n\n\t}\n\n\tget byteLength() {\n\n\t\treturn getFloatLength( this._buffer.byteLength );\n\n\t}\n\n\tget buffer() {\n\n\t\treturn this._buffer;\n\n\t}\n\n\tupdate() {\n\n\t\treturn true;\n\n\t}\n\n}\n\nclass UniformBuffer extends Buffer {\n\n\tconstructor( name, buffer = null ) {\n\n\t\tsuper( name, buffer );\n\n\t\tthis.isUniformBuffer = true;\n\n\t}\n\n}\n\nlet _id$4 = 0;\n\nclass NodeUniformBuffer extends UniformBuffer {\n\n\tconstructor( nodeUniform, groupNode ) {\n\n\t\tsuper( 'UniformBuffer_' + _id$4 ++, nodeUniform ? nodeUniform.value : null );\n\n\t\tthis.nodeUniform = nodeUniform;\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\tget buffer() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n}\n\nclass UniformsGroup extends UniformBuffer {\n\n\tconstructor( name ) {\n\n\t\tsuper( name );\n\n\t\tthis.isUniformsGroup = true;\n\n\t\tthis._values = null;\n\n\t\t// the order of uniforms in this array must match the order of uniforms in the shader\n\n\t\tthis.uniforms = [];\n\n\t}\n\n\taddUniform( uniform ) {\n\n\t\tthis.uniforms.push( uniform );\n\n\t\treturn this;\n\n\t}\n\n\tremoveUniform( uniform ) {\n\n\t\tconst index = this.uniforms.indexOf( uniform );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.uniforms.splice( index, 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tget values() {\n\n\t\tif ( this._values === null ) {\n\n\t\t\tthis._values = Array.from( this.buffer );\n\n\t\t}\n\n\t\treturn this._values;\n\n\t}\n\n\tget buffer() {\n\n\t\tlet buffer = this._buffer;\n\n\t\tif ( buffer === null ) {\n\n\t\t\tconst byteLength = this.byteLength;\n\n\t\t\tbuffer = new Float32Array( new ArrayBuffer( byteLength ) );\n\n\t\t\tthis._buffer = buffer;\n\n\t\t}\n\n\t\treturn buffer;\n\n\t}\n\n\tget byteLength() {\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\n\t\tfor ( let i = 0, l = this.uniforms.length; i < l; i ++ ) {\n\n\t\t\tconst uniform = this.uniforms[ i ];\n\n\t\t\tconst { boundary, itemSize } = uniform;\n\n\t\t\t// offset within a single chunk in bytes\n\n\t\t\tconst chunkOffset = offset % GPU_CHUNK_BYTES;\n\t\t\tconst remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;\n\n\t\t\t// conformance tests\n\n\t\t\tif ( chunkOffset !== 0 && ( remainingSizeInChunk - boundary ) < 0 ) {\n\n\t\t\t\t// check for chunk overflow\n\n\t\t\t\toffset += ( GPU_CHUNK_BYTES - chunkOffset );\n\n\t\t\t} else if ( chunkOffset % boundary !== 0 ) {\n\n\t\t\t\t// check for correct alignment\n\n\t\t\t\toffset += ( chunkOffset % boundary );\n\n\t\t\t}\n\n\t\t\tuniform.offset = ( offset / this.bytesPerElement );\n\n\t\t\toffset += ( itemSize * this.bytesPerElement );\n\n\t\t}\n\n\t\treturn Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES;\n\n\t}\n\n\tupdate() {\n\n\t\tlet updated = false;\n\n\t\tfor ( const uniform of this.uniforms ) {\n\n\t\t\tif ( this.updateByType( uniform ) === true ) {\n\n\t\t\t\tupdated = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateByType( uniform ) {\n\n\t\tif ( uniform.isNumberUniform ) return this.updateNumber( uniform );\n\t\tif ( uniform.isVector2Uniform ) return this.updateVector2( uniform );\n\t\tif ( uniform.isVector3Uniform ) return this.updateVector3( uniform );\n\t\tif ( uniform.isVector4Uniform ) return this.updateVector4( uniform );\n\t\tif ( uniform.isColorUniform ) return this.updateColor( uniform );\n\t\tif ( uniform.isMatrix3Uniform ) return this.updateMatrix3( uniform );\n\t\tif ( uniform.isMatrix4Uniform ) return this.updateMatrix4( uniform );\n\n\t\tconsole.error( 'THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform );\n\n\t}\n\n\tupdateNumber( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset ] !== v ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset ] = a[ offset ] = v;\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateVector2( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateVector3( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = v.z;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateVector4( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z || a[ offset + 4 ] !== v.w ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = v.z;\n\t\t\tb[ offset + 3 ] = a[ offset + 3 ] = v.w;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateColor( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst c = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== c.r || a[ offset + 1 ] !== c.g || a[ offset + 2 ] !== c.b ) {\n\n\t\t\tconst b = this.buffer;\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = c.r;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = c.g;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = c.b;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateMatrix3( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst e = uniform.getValue().elements;\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== e[ 0 ] || a[ offset + 1 ] !== e[ 1 ] || a[ offset + 2 ] !== e[ 2 ] ||\n\t\t\ta[ offset + 4 ] !== e[ 3 ] || a[ offset + 5 ] !== e[ 4 ] || a[ offset + 6 ] !== e[ 5 ] ||\n\t\t\ta[ offset + 8 ] !== e[ 6 ] || a[ offset + 9 ] !== e[ 7 ] || a[ offset + 10 ] !== e[ 8 ] ) {\n\n\t\t\tconst b = this.buffer;\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = e[ 0 ];\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = e[ 1 ];\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = e[ 2 ];\n\t\t\tb[ offset + 4 ] = a[ offset + 4 ] = e[ 3 ];\n\t\t\tb[ offset + 5 ] = a[ offset + 5 ] = e[ 4 ];\n\t\t\tb[ offset + 6 ] = a[ offset + 6 ] = e[ 5 ];\n\t\t\tb[ offset + 8 ] = a[ offset + 8 ] = e[ 6 ];\n\t\t\tb[ offset + 9 ] = a[ offset + 9 ] = e[ 7 ];\n\t\t\tb[ offset + 10 ] = a[ offset + 10 ] = e[ 8 ];\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\tupdateMatrix4( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst e = uniform.getValue().elements;\n\t\tconst offset = uniform.offset;\n\n\t\tif ( arraysEqual( a, e, offset ) === false ) {\n\n\t\t\tconst b = this.buffer;\n\t\t\tb.set( e, offset );\n\t\t\tsetArray( a, e, offset );\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t_getBufferForType( type ) {\n\n\t\tif ( type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4' ) return new Int32Array( this.buffer.buffer );\n\t\tif ( type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4' ) return new Uint32Array( this.buffer.buffer );\n\t\treturn this.buffer;\n\n\t}\n\n}\n\nfunction setArray( a, b, offset ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\ta[ offset + i ] = b[ i ];\n\n\t}\n\n}\n\nfunction arraysEqual( a, b, offset ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\tif ( a[ offset + i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nlet _id$3 = 0;\n\nclass NodeUniformsGroup extends UniformsGroup {\n\n\tconstructor( name, groupNode ) {\n\n\t\tsuper( name );\n\n\t\tthis.id = _id$3 ++;\n\t\tthis.groupNode = groupNode;\n\n\t\tthis.isNodeUniformsGroup = true;\n\n\t}\n\n\tgetNodes() {\n\n\t\tconst nodes = [];\n\n\t\tfor ( const uniform of this.uniforms ) {\n\n\t\t\tconst node = uniform.nodeUniform.node;\n\n\t\t\tif ( ! node ) throw new Error( 'NodeUniformsGroup: Uniform has no node.' );\n\n\t\t\tnodes.push( node );\n\n\t\t}\n\n\t\treturn nodes;\n\n\t}\n\n}\n\nlet _id$2 = 0;\n\nclass SampledTexture extends Binding {\n\n\tconstructor( name, texture ) {\n\n\t\tsuper( name );\n\n\t\tthis.id = _id$2 ++;\n\n\t\tthis.texture = texture;\n\t\tthis.version = texture ? texture.version : 0;\n\t\tthis.store = false;\n\t\tthis.generation = null;\n\n\t\tthis.isSampledTexture = true;\n\n\t}\n\n\tneedsBindingsUpdate( generation ) {\n\n\t\tconst { texture } = this;\n\n\t\tif ( generation !== this.generation ) {\n\n\t\t\tthis.generation = generation;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn texture.isVideoTexture;\n\n\t}\n\n\tupdate() {\n\n\t\tconst { texture, version } = this;\n\n\t\tif ( version !== texture.version ) {\n\n\t\t\tthis.version = texture.version;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n}\n\nclass NodeSampledTexture extends SampledTexture {\n\n\tconstructor( name, textureNode, groupNode, access = null ) {\n\n\t\tsuper( name, textureNode ? textureNode.value : null );\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.groupNode = groupNode;\n\n\t\tthis.access = access;\n\n\t}\n\n\tneedsBindingsUpdate( generation ) {\n\n\t\treturn this.textureNode.value !== this.texture || super.needsBindingsUpdate( generation );\n\n\t}\n\n\tupdate() {\n\n\t\tconst { textureNode } = this;\n\n\t\tif ( this.texture !== textureNode.value ) {\n\n\t\t\tthis.texture = textureNode.value;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn super.update();\n\n\t}\n\n}\n\nclass NodeSampledCubeTexture extends NodeSampledTexture {\n\n\tconstructor( name, textureNode, groupNode, access ) {\n\n\t\tsuper( name, textureNode, groupNode, access );\n\n\t\tthis.isSampledCubeTexture = true;\n\n\t}\n\n}\n\nclass NodeSampledTexture3D extends NodeSampledTexture {\n\n\tconstructor( name, textureNode, groupNode, access ) {\n\n\t\tsuper( name, textureNode, groupNode, access );\n\n\t\tthis.isSampledTexture3D = true;\n\n\t}\n\n}\n\nconst glslMethods = {\n\tatan2: 'atan',\n\ttextureDimensions: 'textureSize',\n\tequals: 'equal'\n};\n\nconst precisionLib = {\n\tlow: 'lowp',\n\tmedium: 'mediump',\n\thigh: 'highp'\n};\n\nconst supports$1 = {\n\tswizzleAssign: true,\n\tstorageBuffer: false\n};\n\nconst defaultPrecisions = `\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler3D;\nprecision highp samplerCube;\nprecision highp sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp usampler3D;\nprecision highp usamplerCube;\nprecision highp usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp isampler3D;\nprecision highp isamplerCube;\nprecision highp isampler2DArray;\n\nprecision lowp sampler2DShadow;\n`;\n\nclass GLSLNodeBuilder extends NodeBuilder {\n\n\tconstructor( object, renderer ) {\n\n\t\tsuper( object, renderer, new GLSLNodeParser() );\n\n\t\tthis.uniformGroups = {};\n\t\tthis.transforms = [];\n\t\tthis.extensions = {};\n\t\tthis.builtins = { vertex: [], fragment: [], compute: [] };\n\n\t\tthis.useComparisonMethod = true;\n\n\t}\n\n\tneedsToWorkingColorSpace( texture ) {\n\n\t\treturn texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn glslMethods[ method ] || method;\n\n\t}\n\n\tgetOutputStructName() {\n\n\t\treturn '';\n\n\t}\n\n\tbuildFunctionCode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\t\tconst flowData = this.flowShaderNode( shaderNode );\n\n\t\tconst parameters = [];\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tparameters.push( this.getType( input.type ) + ' ' + input.name );\n\n\t\t}\n\n\t\t//\n\n\t\tconst code = `${ this.getType( layout.type ) } ${ layout.name }( ${ parameters.join( ', ' ) } ) {\n\n\t${ flowData.vars }\n\n${ flowData.code }\n\treturn ${ flowData.result };\n\n}`;\n\n\t\t//\n\n\t\treturn code;\n\n\t}\n\n\tsetupPBO( storageBufferNode ) {\n\n\t\tconst attribute = storageBufferNode.value;\n\n\t\tif ( attribute.pbo === undefined ) {\n\n\t\t\tconst originalArray = attribute.array;\n\t\t\tconst numElements = attribute.count * attribute.itemSize;\n\n\t\t\tconst { itemSize } = attribute;\n\n\t\t\tconst isInteger = attribute.array.constructor.name.toLowerCase().includes( 'int' );\n\n\t\t\tlet format = isInteger ? RedIntegerFormat : RedFormat;\n\n\t\t\tif ( itemSize === 2 ) {\n\n\t\t\t\tformat = isInteger ? RGIntegerFormat : RGFormat;\n\n\t\t\t} else if ( itemSize === 3 ) {\n\n\t\t\t\tformat = isInteger ? RGBIntegerFormat : RGBFormat;\n\n\t\t\t} else if ( itemSize === 4 ) {\n\n\t\t\t\tformat = isInteger ? RGBAIntegerFormat : RGBAFormat;\n\n\t\t\t}\n\n\t\t\tconst typeMap = {\n\t\t\t\tFloat32Array: FloatType,\n\t\t\t\tUint8Array: UnsignedByteType,\n\t\t\t\tUint16Array: UnsignedShortType,\n\t\t\t\tUint32Array: UnsignedIntType,\n\t\t\t\tInt8Array: ByteType,\n\t\t\t\tInt16Array: ShortType,\n\t\t\t\tInt32Array: IntType,\n\t\t\t\tUint8ClampedArray: UnsignedByteType,\n\t\t\t};\n\n\t\t\tconst width = Math.pow( 2, Math.ceil( Math.log2( Math.sqrt( numElements / itemSize ) ) ) );\n\t\t\tlet height = Math.ceil( ( numElements / itemSize ) / width );\n\t\t\tif ( width * height * itemSize < numElements ) height ++; // Ensure enough space\n\n\t\t\tconst newSize = width * height * itemSize;\n\n\t\t\tconst newArray = new originalArray.constructor( newSize );\n\n\t\t\tnewArray.set( originalArray, 0 );\n\n\t\t\tattribute.array = newArray;\n\n\t\t\tconst pboTexture = new DataTexture( attribute.array, width, height, format, typeMap[ attribute.array.constructor.name ] || FloatType );\n\t\t\tpboTexture.needsUpdate = true;\n\t\t\tpboTexture.isPBOTexture = true;\n\n\t\t\tconst pbo = new TextureNode( pboTexture, null, null );\n\t\t\tpbo.setPrecision( 'high' );\n\n\t\t\tattribute.pboNode = pbo;\n\t\t\tattribute.pbo = pbo.value;\n\n\t\t\tthis.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );\n\n\t\t}\n\n\t}\n\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true ) {\n\n\t\t\treturn shaderStage.charAt( 0 ) + '_' + node.name;\n\n\t\t}\n\n\t\treturn super.getPropertyName( node, shaderStage );\n\n\t}\n\n\tgeneratePBO( storageArrayElementNode ) {\n\n\t\tconst { node, indexNode } = storageArrayElementNode;\n\t\tconst attribute = node.value;\n\n\t\tif ( this.renderer.backend.has( attribute ) ) {\n\n\t\t\tconst attributeData = this.renderer.backend.get( attribute );\n\t\t\tattributeData.pbo = attribute.pbo;\n\n\t\t}\n\n\t\tconst nodeUniform = this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );\n\t\tconst textureName = this.getPropertyName( nodeUniform );\n\n\t\tthis.increaseUsage( indexNode ); // force cache generate to be used as index in x,y\n\t\tconst indexSnippet = indexNode.build( this, 'uint' );\n\n\t\tconst elementNodeData = this.getDataFromNode( storageArrayElementNode );\n\n\t\tlet propertyName = elementNodeData.propertyName;\n\n\t\tif ( propertyName === undefined ) {\n\n\t\t\t// property element\n\n\t\t\tconst nodeVar = this.getVarFromNode( storageArrayElementNode );\n\n\t\t\tpropertyName = this.getPropertyName( nodeVar );\n\n\t\t\t// property size\n\n\t\t\tconst bufferNodeData = this.getDataFromNode( node );\n\n\t\t\tlet propertySizeName = bufferNodeData.propertySizeName;\n\n\t\t\tif ( propertySizeName === undefined ) {\n\n\t\t\t\tpropertySizeName = propertyName + 'Size';\n\n\t\t\t\tthis.getVarFromNode( node, propertySizeName, 'uint' );\n\n\t\t\t\tthis.addLineFlowCode( `${ propertySizeName } = uint( textureSize( ${ textureName }, 0 ).x )`, storageArrayElementNode );\n\n\t\t\t\tbufferNodeData.propertySizeName = propertySizeName;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst { itemSize } = attribute;\n\n\t\t\tconst channel = '.' + vectorComponents.join( '' ).slice( 0, itemSize );\n\t\t\tconst uvSnippet = `ivec2(${indexSnippet} % ${ propertySizeName }, ${indexSnippet} / ${ propertySizeName })`;\n\n\t\t\tconst snippet = this.generateTextureLoad( null, textureName, uvSnippet, null, '0' );\n\n\t\t\t//\n\n\n\t\t\tlet prefix = 'vec4';\n\n\t\t\tif ( attribute.pbo.type === UnsignedIntType ) {\n\n\t\t\t\tprefix = 'uvec4';\n\n\t\t\t} else if ( attribute.pbo.type === IntType ) {\n\n\t\t\t\tprefix = 'ivec4';\n\n\t\t\t}\n\n\t\t\tthis.addLineFlowCode( `${ propertyName } = ${prefix}(${ snippet })${channel}`, storageArrayElementNode );\n\n\t\t\telementNodeData.propertyName = propertyName;\n\n\t\t}\n\n\t\treturn propertyName;\n\n\t}\n\n\tgenerateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0' ) {\n\n\t\tif ( depthSnippet ) {\n\n\t\t\treturn `texelFetch( ${ textureProperty }, ivec3( ${ uvIndexSnippet }, ${ depthSnippet } ), ${ levelSnippet } )`;\n\n\t\t} else {\n\n\t\t\treturn `texelFetch( ${ textureProperty }, ${ uvIndexSnippet }, ${ levelSnippet } )`;\n\n\t\t}\n\n\t}\n\n\tgenerateTexture( texture, textureProperty, uvSnippet, depthSnippet ) {\n\n\t\tif ( texture.isDepthTexture ) {\n\n\t\t\treturn `texture( ${ textureProperty }, ${ uvSnippet } ).x`;\n\n\t\t} else {\n\n\t\t\tif ( depthSnippet ) uvSnippet = `vec3( ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\t\treturn `texture( ${ textureProperty }, ${ uvSnippet } )`;\n\n\t\t}\n\n\t}\n\n\tgenerateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet ) {\n\n\t\treturn `textureLod( ${ textureProperty }, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t}\n\n\tgenerateTextureBias( texture, textureProperty, uvSnippet, biasSnippet ) {\n\n\t\treturn `texture( ${ textureProperty }, ${ uvSnippet }, ${ biasSnippet } )`;\n\n\t}\n\n\tgenerateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet ) {\n\n\t\treturn `textureGrad( ${ textureProperty }, ${ uvSnippet }, ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;\n\n\t}\n\n\tgenerateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `texture( ${ textureProperty }, vec3( ${ uvSnippet }, ${ compareSnippet } ) )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippets.push( `${ this.getVar( variable.type, variable.name ) };` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\t' );\n\n\t}\n\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst uniformGroups = {};\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tlet snippet = null;\n\t\t\tlet group = false;\n\n\t\t\tif ( uniform.type === 'texture' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tlet typePrefix = '';\n\n\t\t\t\tif ( texture.isDataTexture === true ) {\n\n\n\t\t\t\t\tif ( texture.type === UnsignedIntType ) {\n\n\t\t\t\t\t\ttypePrefix = 'u';\n\n\t\t\t\t\t} else if ( texture.type === IntType ) {\n\n\t\t\t\t\t\ttypePrefix = 'i';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.compareFunction ) {\n\n\t\t\t\t\tsnippet = `sampler2DShadow ${ uniform.name };`;\n\n\t\t\t\t} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler2DArray ${ uniform.name };`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler2D ${ uniform.name };`;\n\n\t\t\t\t}\n\n\t\t\t} else if ( uniform.type === 'cubeTexture' ) {\n\n\t\t\t\tsnippet = `samplerCube ${ uniform.name };`;\n\n\t\t\t} else if ( uniform.type === 'texture3D' ) {\n\n\t\t\t\tsnippet = `sampler3D ${ uniform.name };`;\n\n\t\t\t} else if ( uniform.type === 'buffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.bufferType );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 ? bufferCount : '';\n\t\t\t\tsnippet = `${bufferNode.name} {\\n\\t${ bufferType } ${ uniform.name }[${ bufferCountSnippet }];\\n};\\n`;\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getVectorType( uniform.type );\n\n\t\t\t\tsnippet = `${ vectorType } ${ this.getPropertyName( uniform, shaderStage ) };`;\n\n\t\t\t\tgroup = true;\n\n\t\t\t}\n\n\t\t\tconst precision = uniform.node.precision;\n\n\t\t\tif ( precision !== null ) {\n\n\t\t\t\tsnippet = precisionLib[ precision ] + ' ' + snippet;\n\n\t\t\t}\n\n\t\t\tif ( group ) {\n\n\t\t\t\tsnippet = '\\t' + snippet;\n\n\t\t\t\tconst groupName = uniform.groupNode.name;\n\t\t\t\tconst groupSnippets = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = [] );\n\n\t\t\t\tgroupSnippets.push( snippet );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = 'uniform ' + snippet;\n\n\t\t\t\tbindingSnippets.push( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet output = '';\n\n\t\tfor ( const name in uniformGroups ) {\n\n\t\t\tconst groupSnippets = uniformGroups[ name ];\n\n\t\t\toutput += this._getGLSLUniformStruct( shaderStage + '_' + name, groupSnippets.join( '\\n' ) ) + '\\n';\n\n\t\t}\n\n\t\toutput += bindingSnippets.join( '\\n' );\n\n\t\treturn output;\n\n\t}\n\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet nodeType = super.getTypeFromAttribute( attribute );\n\n\t\tif ( /^[iu]/.test( nodeType ) && attribute.gpuType !== IntType ) {\n\n\t\t\tlet dataAttribute = attribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\t\tconst array = dataAttribute.array;\n\n\t\t\tif ( ( array instanceof Uint32Array || array instanceof Int32Array ) === false ) {\n\n\t\t\t\tnodeType = nodeType.slice( 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\tgetAttributes( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tlet location = 0;\n\n\t\t\tfor ( const attribute of attributes ) {\n\n\t\t\t\tsnippet += `layout( location = ${ location ++ } ) in ${ attribute.type } ${ attribute.name };\\n`;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\t\tconst members = struct.getMemberTypes();\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\tconst member = members[ i ];\n\t\t\tsnippets.push( `layout( location = ${i} ) out ${ member} m${i};` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\tgetStructs( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tif ( structs.length === 0 ) {\n\n\t\t\treturn 'layout( location = 0 ) out vec4 fragColor;\\n';\n\n\t\t}\n\n\t\tfor ( let index = 0, length = structs.length; index < length; index ++ ) {\n\n\t\t\tconst struct = structs[ index ];\n\n\t\t\tlet snippet = '\\n';\n\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\tsnippet += '\\n';\n\n\t\t\tsnippets.push( snippet );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\n' );\n\n\t}\n\n\tgetVaryings( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst varyings = this.varyings;\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( shaderStage === 'compute' ) varying.needsInterpolation = true;\n\t\t\t\tconst type = this.getType( varying.type );\n\t\t\t\tconst flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';\n\n\t\t\t\tsnippet += `${flat}${varying.needsInterpolation ? 'out' : '/*out*/'} ${type} ${varying.name};\\n`;\n\n\t\t\t}\n\n\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tconst type = this.getType( varying.type );\n\t\t\t\t\tconst flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';\n\n\t\t\t\t\tsnippet += `${flat}in ${type} ${varying.name};\\n`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const builtin of this.builtins[ shaderStage ] ) {\n\n\t\t\tsnippet += `${builtin};\\n`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\treturn 'uint( gl_VertexID )';\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\treturn 'uint( gl_InstanceID )';\n\n\t}\n\n\tgetInvocationLocalIndex() {\n\n\t\tconst workgroupSize = this.object.workgroupSize;\n\n\t\tconst size = workgroupSize.reduce( ( acc, curr ) => acc * curr, 1 );\n\n\t\treturn `uint( gl_InstanceID ) % ${size}u`;\n\n\t}\n\n\tgetDrawIndex() {\n\n\t\tconst extensions = this.renderer.backend.extensions;\n\n\t\tif ( extensions.has( 'WEBGL_multi_draw' ) ) {\n\n\t\t\treturn 'uint( gl_DrawID )';\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\treturn 'gl_FrontFacing';\n\n\t}\n\n\tgetFragCoord() {\n\n\t\treturn 'gl_FragCoord.xy';\n\n\t}\n\n\tgetFragDepth() {\n\n\t\treturn 'gl_FragDepth';\n\n\t}\n\n\tenableExtension( name, behavior, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.extensions[ shaderStage ] || ( this.extensions[ shaderStage ] = new Map() );\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tbehavior\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tgetExtensions( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tconst ext = this.renderer.backend.extensions;\n\t\t\tconst isBatchedMesh = this.object.isBatchedMesh;\n\n\t\t\tif ( isBatchedMesh && ext.has( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\tthis.enableExtension( 'GL_ANGLE_multi_draw', 'require', shaderStage );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensions = this.extensions[ shaderStage ];\n\n\t\tif ( extensions !== undefined ) {\n\n\t\t\tfor ( const { name, behavior } of extensions.values() ) {\n\n\t\t\t\tsnippets.push( `#extension ${name} : ${behavior}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\tgetClipDistance() {\n\n\t\treturn 'gl_ClipDistance';\n\n\t}\n\n\tisAvailable( name ) {\n\n\t\tlet result = supports$1[ name ];\n\n\t\tif ( result === undefined ) {\n\n\t\t\tlet extensionName;\n\n\t\t\tresult = false;\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'float32Filterable':\n\t\t\t\t\textensionName = 'OES_texture_float_linear';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'clipDistance':\n\t\t\t\t\textensionName = 'WEBGL_clip_cull_distance';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( extensionName !== undefined ) {\n\n\t\t\t\tconst extensions = this.renderer.backend.extensions;\n\n\t\t\t\tif ( extensions.has( extensionName ) ) {\n\n\t\t\t\t\textensions.get( extensionName );\n\t\t\t\t\tresult = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tsupports$1[ name ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn true;\n\n\t}\n\n\tenableHardwareClipping( planeCount ) {\n\n\t\tthis.enableExtension( 'GL_ANGLE_clip_cull_distance', 'require' );\n\n\t\tthis.builtins[ 'vertex' ].push( `out float gl_ClipDistance[ ${ planeCount } ]` );\n\n\t}\n\n\tregisterTransform( varyingName, attributeNode ) {\n\n\t\tthis.transforms.push( { varyingName, attributeNode } );\n\n\t}\n\n\tgetTransforms( /* shaderStage  */ ) {\n\n\t\tconst transforms = this.transforms;\n\n\t\tlet snippet = '';\n\n\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\tconst transform = transforms[ i ];\n\n\t\t\tconst attributeName = this.getPropertyName( transform.attributeNode );\n\n\t\t\tsnippet += `${ transform.varyingName } = ${ attributeName };\\n\\t`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t_getGLSLUniformStruct( name, vars ) {\n\n\t\treturn `\nlayout( std140 ) uniform ${name} {\n${vars}\n};`;\n\n\t}\n\n\t_getGLSLVertexCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// extensions \n${shaderData.extensions}\n\n// precision\n${ defaultPrecisions }\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// attributes\n${shaderData.attributes}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// transforms\n\t${shaderData.transforms}\n\n\t// flow\n\t${shaderData.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`;\n\n\t}\n\n\t_getGLSLFragmentCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// precision\n${ defaultPrecisions }\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\n${shaderData.structs}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tthis.sortBindingGroups();\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n\\t`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += 'gl_Position = ';\n\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( ! node.outputNode.isOutputStructNode ) {\n\n\t\t\t\t\t\t\tflow += 'fragColor = ';\n\t\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\n\t\t\tstageData.extensions = this.getExtensions( shaderStage );\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.transforms = this.getTransforms( shaderStage );\n\t\t\tstageData.flow = flow;\n\n\t\t}\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getGLSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getGLSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\tthis.computeShader = this._getGLSLVertexCode( shadersData.compute );\n\n\t\t}\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet uniformGPU = nodeData.uniformGPU;\n\n\t\tif ( uniformGPU === undefined ) {\n\n\t\t\tconst group = node.groupNode;\n\t\t\tconst groupName = group.name;\n\n\t\t\tconst bindings = this.getBindGroupArray( groupName, shaderStage );\n\n\t\t\tif ( type === 'texture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'texture3D' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'buffer' ) {\n\n\t\t\t\tnode.name = `NodeBuffer_${ node.id }`;\n\t\t\t\tuniformNode.name = `buffer${ node.id }`;\n\n\t\t\t\tconst buffer = new NodeUniformBuffer( node, group );\n\t\t\t\tbuffer.name = node.name;\n\n\t\t\t\tbindings.push( buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t} else {\n\n\t\t\t\tconst uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );\n\n\t\t\t\tlet uniformsGroup = uniformsStage[ groupName ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new NodeUniformsGroup( shaderStage + '_' + groupName, group );\n\t\t\t\t\t//uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tuniformsStage[ groupName ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n}\n\nlet vector2 = null;\nlet vector4 = null;\nlet color4 = null;\n\nclass Backend {\n\n\tconstructor( parameters = {} ) {\n\n\t\tthis.parameters = Object.assign( {}, parameters );\n\t\tthis.data = new WeakMap();\n\t\tthis.renderer = null;\n\t\tthis.domElement = null;\n\n\t}\n\n\tasync init( renderer ) {\n\n\t\tthis.renderer = renderer;\n\n\t}\n\n\t// render context\n\n\tbegin( /*renderContext*/ ) { }\n\n\tfinish( /*renderContext*/ ) { }\n\n\t// render object\n\n\tdraw( /*renderObject, info*/ ) { }\n\n\t// program\n\n\tcreateProgram( /*program*/ ) { }\n\n\tdestroyProgram( /*program*/ ) { }\n\n\t// bindings\n\n\tcreateBindings( /*bingGroup, bindings*/ ) { }\n\n\tupdateBindings( /*bingGroup, bindings*/ ) { }\n\n\t// pipeline\n\n\tcreateRenderPipeline( /*renderObject*/ ) { }\n\n\tcreateComputePipeline( /*computeNode, pipeline*/ ) { }\n\n\tdestroyPipeline( /*pipeline*/ ) { }\n\n\t// cache key\n\n\tneedsRenderUpdate( /*renderObject*/ ) { } // return Boolean ( fast test )\n\n\tgetRenderCacheKey( /*renderObject*/ ) { } // return String\n\n\t// node builder\n\n\tcreateNodeBuilder( /*renderObject*/ ) { } // return NodeBuilder (ADD IT)\n\n\t// textures\n\n\tcreateSampler( /*texture*/ ) { }\n\n\tcreateDefaultTexture( /*texture*/ ) { }\n\n\tcreateTexture( /*texture*/ ) { }\n\n\tcopyTextureToBuffer( /*texture, x, y, width, height*/ ) {}\n\n\t// attributes\n\n\tcreateAttribute( /*attribute*/ ) { }\n\n\tcreateIndexAttribute( /*attribute*/ ) { }\n\n\tupdateAttribute( /*attribute*/ ) { }\n\n\tdestroyAttribute( /*attribute*/ ) { }\n\n\t// canvas\n\n\tgetContext() { }\n\n\tupdateSize() { }\n\n\t// utils\n\n\tresolveTimestampAsync( /*renderContext, type*/ ) { }\n\n\thasFeatureAsync( /*name*/ ) { } // return Boolean\n\n\thasFeature( /*name*/ ) { } // return Boolean\n\n\tgetInstanceCount( renderObject ) {\n\n\t\tconst { object, geometry } = renderObject;\n\n\t\treturn geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.count > 1 ? object.count : 1 );\n\n\t}\n\n\tgetDrawingBufferSize() {\n\n\t\tvector2 = vector2 || new Vector2();\n\n\t\treturn this.renderer.getDrawingBufferSize( vector2 );\n\n\t}\n\n\tgetScissor() {\n\n\t\tvector4 = vector4 || new Vector4();\n\n\t\treturn this.renderer.getScissor( vector4 );\n\n\t}\n\n\tsetScissorTest( /*boolean*/ ) { }\n\n\tgetClearColor() {\n\n\t\tconst renderer = this.renderer;\n\n\t\tcolor4 = color4 || new Color4();\n\n\t\trenderer.getClearColor( color4 );\n\n\t\tcolor4.getRGB( color4, this.renderer.currentColorSpace );\n\n\t\treturn color4;\n\n\t}\n\n\tgetDomElement() {\n\n\t\tlet domElement = this.domElement;\n\n\t\tif ( domElement === null ) {\n\n\t\t\tdomElement = ( this.parameters.canvas !== undefined ) ? this.parameters.canvas : createCanvasElement();\n\n\t\t\t// OffscreenCanvas does not have setAttribute, see #22811\n\t\t\tif ( 'setAttribute' in domElement ) domElement.setAttribute( 'data-engine', `three.js r${REVISION} webgpu` );\n\n\t\t\tthis.domElement = domElement;\n\n\t\t}\n\n\t\treturn domElement;\n\n\t}\n\n\t// resource properties\n\n\tset( object, value ) {\n\n\t\tthis.data.set( object, value );\n\n\t}\n\n\tget( object ) {\n\n\t\tlet map = this.data.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tthis.data.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\thas( object ) {\n\n\t\treturn this.data.has( object );\n\n\t}\n\n\tdelete( object ) {\n\n\t\tthis.data.delete( object );\n\n\t}\n\n\tdispose() { }\n\n}\n\nlet _id$1 = 0;\n\nclass DualAttributeData {\n\n\tconstructor( attributeData, dualBuffer ) {\n\n\t\tthis.buffers = [ attributeData.bufferGPU, dualBuffer ];\n\t\tthis.type = attributeData.type;\n\t\tthis.bufferType = attributeData.bufferType;\n\t\tthis.pbo = attributeData.pbo;\n\t\tthis.byteLength = attributeData.byteLength;\n\t\tthis.bytesPerElement = attributeData.BYTES_PER_ELEMENT;\n\t\tthis.version = attributeData.version;\n\t\tthis.isInteger = attributeData.isInteger;\n\t\tthis.activeBufferIndex = 0;\n\t\tthis.baseId = attributeData.id;\n\n\t}\n\n\n\tget id() {\n\n\t\treturn `${ this.baseId }|${ this.activeBufferIndex }`;\n\n\t}\n\n\tget bufferGPU() {\n\n\t\treturn this.buffers[ this.activeBufferIndex ];\n\n\t}\n\n\tget transformBuffer() {\n\n\t\treturn this.buffers[ this.activeBufferIndex ^ 1 ];\n\n\t}\n\n\tswitchBuffers() {\n\n\t\tthis.activeBufferIndex ^= 1;\n\n\t}\n\n}\n\nclass WebGLAttributeUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t}\n\n\tcreateAttribute( attribute, bufferType ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst array = attribute.array;\n\t\tconst usage = attribute.usage || gl.STATIC_DRAW;\n\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\n\t\tlet bufferGPU = bufferData.bufferGPU;\n\n\t\tif ( bufferGPU === undefined ) {\n\n\t\t\tbufferGPU = this._createBuffer( gl, bufferType, array, usage );\n\n\t\t\tbufferData.bufferGPU = bufferGPU;\n\t\t\tbufferData.bufferType = bufferType;\n\t\t\tbufferData.version = bufferAttribute.version;\n\n\t\t}\n\n\t\t//attribute.onUploadCallback();\n\n\t\tlet type;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = gl.FLOAT;\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\tif ( attribute.isFloat16BufferAttribute ) {\n\n\t\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\n\t\t\t}\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = gl.SHORT;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = gl.UNSIGNED_INT;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = gl.INT;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = gl.BYTE;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else if ( array instanceof Uint8ClampedArray ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.WebGLBackend: Unsupported buffer data format: ' + array );\n\n\t\t}\n\n\t\tlet attributeData = {\n\t\t\tbufferGPU,\n\t\t\tbufferType,\n\t\t\ttype,\n\t\t\tbyteLength: array.byteLength,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version,\n\t\t\tpbo: attribute.pbo,\n\t\t\tisInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,\n\t\t\tid: _id$1 ++\n\t\t};\n\n\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {\n\n\t\t\t// create buffer for tranform feedback use\n\t\t\tconst bufferGPUDual = this._createBuffer( gl, bufferType, array, usage );\n\t\t\tattributeData = new DualAttributeData( attributeData, bufferGPUDual );\n\n\t\t}\n\n\t\tbackend.set( attribute, attributeData );\n\n\t}\n\n\tupdateAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst array = attribute.array;\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\t\tconst bufferType = bufferData.bufferType;\n\t\tconst updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;\n\n\t\tgl.bindBuffer( bufferType, bufferData.bufferGPU );\n\n\t\tif ( updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\t\t\t\tgl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray, range.start, range.count );\n\n\t\t\t}\n\n\t\t\tbufferAttribute.clearUpdateRanges();\n\n\t\t}\n\n\t\tgl.bindBuffer( bufferType, null );\n\n\t\tbufferData.version = bufferAttribute.version;\n\n\t}\n\n\tdestroyAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tbackend.delete( attribute.data );\n\n\t\t}\n\n\t\tconst attributeData = backend.get( attribute );\n\n\t\tgl.deleteBuffer( attributeData.bufferGPU );\n\n\t\tbackend.delete( attribute );\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst { bufferGPU } = backend.get( bufferAttribute );\n\n\t\tconst array = attribute.array;\n\t\tconst byteLength = array.byteLength;\n\n\t\tgl.bindBuffer( gl.COPY_READ_BUFFER, bufferGPU );\n\n\t\tconst writeBuffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );\n\t\tgl.bufferData( gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ );\n\n\t\tgl.copyBufferSubData( gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength );\n\n\t\tawait backend.utils._clientWaitAsync();\n\n\t\tconst dstBuffer = new attribute.array.constructor( array.length );\n\n\t\t// Ensure the buffer is bound before reading\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );\n\n\t\tgl.getBufferSubData( gl.COPY_WRITE_BUFFER, 0, dstBuffer );\n\n\t\tgl.deleteBuffer( writeBuffer );\n\n\t\tgl.bindBuffer( gl.COPY_READ_BUFFER, null );\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, null );\n\n\t\treturn dstBuffer.buffer;\n\n\t}\n\n\t_createBuffer( gl, bufferType, array, usage ) {\n\n\t\tconst bufferGPU = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, bufferGPU );\n\t\tgl.bufferData( bufferType, array, usage );\n\t\tgl.bindBuffer( bufferType, null );\n\n\t\treturn bufferGPU;\n\n\t}\n\n}\n\nlet initialized$1 = false, equationToGL, factorToGL;\n\nclass WebGLState {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.gl = this.backend.gl;\n\n\t\tthis.enabled = {};\n\t\tthis.currentFlipSided = null;\n\t\tthis.currentCullFace = null;\n\t\tthis.currentProgram = null;\n\t\tthis.currentBlendingEnabled = false;\n\t\tthis.currentBlending = null;\n\t\tthis.currentBlendSrc = null;\n\t\tthis.currentBlendDst = null;\n\t\tthis.currentBlendSrcAlpha = null;\n\t\tthis.currentBlendDstAlpha = null;\n\t\tthis.currentPremultipledAlpha = null;\n\t\tthis.currentPolygonOffsetFactor = null;\n\t\tthis.currentPolygonOffsetUnits = null;\n\t\tthis.currentColorMask = null;\n\t\tthis.currentDepthFunc = null;\n\t\tthis.currentDepthMask = null;\n\t\tthis.currentStencilFunc = null;\n\t\tthis.currentStencilRef = null;\n\t\tthis.currentStencilFuncMask = null;\n\t\tthis.currentStencilFail = null;\n\t\tthis.currentStencilZFail = null;\n\t\tthis.currentStencilZPass = null;\n\t\tthis.currentStencilMask = null;\n\t\tthis.currentLineWidth = null;\n\t\tthis.currentClippingPlanes = 0;\n\n\t\tthis.currentBoundFramebuffers = {};\n\t\tthis.currentDrawbuffers = new WeakMap();\n\n\t\tthis.maxTextures = this.gl.getParameter( this.gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\tthis.currentTextureSlot = null;\n\t\tthis.currentBoundTextures = {};\n\t\tthis.currentBoundBufferBases = {};\n\n\t\tif ( initialized$1 === false ) {\n\n\t\t\tthis._init( this.gl );\n\n\t\t\tinitialized$1 = true;\n\n\t\t}\n\n\t}\n\n\t_init( gl ) {\n\n\t\t// Store only WebGL constants here.\n\n\t\tequationToGL = {\n\t\t\t[ AddEquation ]: gl.FUNC_ADD,\n\t\t\t[ SubtractEquation ]: gl.FUNC_SUBTRACT,\n\t\t\t[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT\n\t\t};\n\n\t\tfactorToGL = {\n\t\t\t[ ZeroFactor ]: gl.ZERO,\n\t\t\t[ OneFactor ]: gl.ONE,\n\t\t\t[ SrcColorFactor ]: gl.SRC_COLOR,\n\t\t\t[ SrcAlphaFactor ]: gl.SRC_ALPHA,\n\t\t\t[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,\n\t\t\t[ DstColorFactor ]: gl.DST_COLOR,\n\t\t\t[ DstAlphaFactor ]: gl.DST_ALPHA,\n\t\t\t[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,\n\t\t\t[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,\n\t\t\t[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,\n\t\t\t[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA\n\t\t};\n\n\t}\n\n\tenable( id ) {\n\n\t\tconst { enabled } = this;\n\n\t\tif ( enabled[ id ] !== true ) {\n\n\t\t\tthis.gl.enable( id );\n\t\t\tenabled[ id ] = true;\n\n\t\t}\n\n\t}\n\n\tdisable( id ) {\n\n\t\tconst { enabled } = this;\n\n\t\tif ( enabled[ id ] !== false ) {\n\n\t\t\tthis.gl.disable( id );\n\t\t\tenabled[ id ] = false;\n\n\t\t}\n\n\t}\n\n\tsetFlipSided( flipSided ) {\n\n\t\tif ( this.currentFlipSided !== flipSided ) {\n\n\t\t\tconst { gl } = this;\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tthis.currentFlipSided = flipSided;\n\n\t\t}\n\n\t}\n\n\tsetCullFace( cullFace ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\tthis.enable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== this.currentCullFace ) {\n\n\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tthis.currentCullFace = cullFace;\n\n\t}\n\n\tsetLineWidth( width ) {\n\n\t\tconst { currentLineWidth, gl } = this;\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tgl.lineWidth( width );\n\n\t\t\tthis.currentLineWidth = width;\n\n\t\t}\n\n\t}\n\n\n\tsetBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( blending === NoBlending ) {\n\n\t\t\tif ( this.currentBlendingEnabled === true ) {\n\n\t\t\t\tthis.disable( gl.BLEND );\n\t\t\t\tthis.currentBlendingEnabled = false;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.currentBlendingEnabled === false ) {\n\n\t\t\tthis.enable( gl.BLEND );\n\t\t\tthis.currentBlendingEnabled = true;\n\n\t\t}\n\n\t\tif ( blending !== CustomBlending ) {\n\n\t\t\tif ( blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha ) {\n\n\t\t\t\tif ( this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation ) {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\n\t\t\t\t\tthis.currentBlendEquation = AddEquation;\n\t\t\t\t\tthis.currentBlendEquationAlpha = AddEquation;\n\n\t\t\t\t}\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ONE, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.currentBlendSrc = null;\n\t\t\t\tthis.currentBlendDst = null;\n\t\t\t\tthis.currentBlendSrcAlpha = null;\n\t\t\t\tthis.currentBlendDstAlpha = null;\n\n\t\t\t\tthis.currentBlending = blending;\n\t\t\t\tthis.currentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// custom blending\n\n\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\tif ( blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha ) {\n\n\t\t\tgl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );\n\n\t\t\tthis.currentBlendEquation = blendEquation;\n\t\t\tthis.currentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t}\n\n\t\tif ( blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha ) {\n\n\t\t\tgl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );\n\n\t\t\tthis.currentBlendSrc = blendSrc;\n\t\t\tthis.currentBlendDst = blendDst;\n\t\t\tthis.currentBlendSrcAlpha = blendSrcAlpha;\n\t\t\tthis.currentBlendDstAlpha = blendDstAlpha;\n\n\t\t}\n\n\t\tthis.currentBlending = blending;\n\t\tthis.currentPremultipledAlpha = false;\n\n\t}\n\n\tsetColorMask( colorMask ) {\n\n\t\tif ( this.currentColorMask !== colorMask ) {\n\n\t\t\tthis.gl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\tthis.currentColorMask = colorMask;\n\n\t\t}\n\n\t}\n\n\tsetDepthTest( depthTest ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( depthTest ) {\n\n\t\t\tthis.enable( gl.DEPTH_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.DEPTH_TEST );\n\n\t\t}\n\n\t}\n\n\tsetDepthMask( depthMask ) {\n\n\t\tif ( this.currentDepthMask !== depthMask ) {\n\n\t\t\tthis.gl.depthMask( depthMask );\n\t\t\tthis.currentDepthMask = depthMask;\n\n\t\t}\n\n\t}\n\n\tsetDepthFunc( depthFunc ) {\n\n\t\tif ( this.currentDepthFunc !== depthFunc ) {\n\n\t\t\tconst { gl } = this;\n\n\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t}\n\n\t\t\tthis.currentDepthFunc = depthFunc;\n\n\t\t}\n\n\t}\n\n\tsetStencilTest( stencilTest ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( stencilTest ) {\n\n\t\t\tthis.enable( gl.STENCIL_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.STENCIL_TEST );\n\n\t\t}\n\n\t}\n\n\tsetStencilMask( stencilMask ) {\n\n\t\tif ( this.currentStencilMask !== stencilMask ) {\n\n\t\t\tthis.gl.stencilMask( stencilMask );\n\t\t\tthis.currentStencilMask = stencilMask;\n\n\t\t}\n\n\t}\n\n\tsetStencilFunc( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tif ( this.currentStencilFunc !== stencilFunc ||\n\t\t\t this.currentStencilRef !== stencilRef ||\n\t\t\t this.currentStencilFuncMask !== stencilMask ) {\n\n\t\t\tthis.gl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t\tthis.currentStencilFunc = stencilFunc;\n\t\t\tthis.currentStencilRef = stencilRef;\n\t\t\tthis.currentStencilFuncMask = stencilMask;\n\n\t\t}\n\n\t}\n\n\tsetStencilOp( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tif ( this.currentStencilFail !== stencilFail ||\n\t\t\t this.currentStencilZFail !== stencilZFail ||\n\t\t\t this.currentStencilZPass !== stencilZPass ) {\n\n\t\t\tthis.gl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t\tthis.currentStencilFail = stencilFail;\n\t\t\tthis.currentStencilZFail = stencilZFail;\n\t\t\tthis.currentStencilZPass = stencilZPass;\n\n\t\t}\n\n\t}\n\n\tsetMaterial( material, frontFaceCW, hardwareClippingPlanes ) {\n\n\t\tconst { gl } = this;\n\n\t\tmaterial.side === DoubleSide\n\t\t\t? this.disable( gl.CULL_FACE )\n\t\t\t: this.enable( gl.CULL_FACE );\n\n\t\tlet flipSided = ( material.side === BackSide );\n\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\n\t\tthis.setFlipSided( flipSided );\n\n\t\t( material.blending === NormalBlending && material.transparent === false )\n\t\t\t? this.setBlending( NoBlending )\n\t\t\t: this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\tthis.setDepthFunc( material.depthFunc );\n\t\tthis.setDepthTest( material.depthTest );\n\t\tthis.setDepthMask( material.depthWrite );\n\t\tthis.setColorMask( material.colorWrite );\n\n\t\tconst stencilWrite = material.stencilWrite;\n\t\tthis.setStencilTest( stencilWrite );\n\t\tif ( stencilWrite ) {\n\n\t\t\tthis.setStencilMask( material.stencilWriteMask );\n\t\t\tthis.setStencilFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );\n\t\t\tthis.setStencilOp( material.stencilFail, material.stencilZFail, material.stencilZPass );\n\n\t\t}\n\n\t\tthis.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\tmaterial.alphaToCoverage === true && this.backend.renderer.samples > 1\n\t\t\t? this.enable( gl.SAMPLE_ALPHA_TO_COVERAGE )\n\t\t\t: this.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );\n\n\t\tif ( hardwareClippingPlanes > 0 ) {\n\n\t\t\tif ( this.currentClippingPlanes !== hardwareClippingPlanes ) {\n\n\t\t\t\tconst CLIP_DISTANCE0_WEBGL = 0x3000;\n\n\t\t\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\t\t\tif ( i < hardwareClippingPlanes ) {\n\n\t\t\t\t\t\tthis.enable( CLIP_DISTANCE0_WEBGL + i );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.disable( CLIP_DISTANCE0_WEBGL + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetPolygonOffset( polygonOffset, factor, units ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tthis.currentPolygonOffsetFactor = factor;\n\t\t\t\tthis.currentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t}\n\n\tuseProgram( program ) {\n\n\t\tif ( this.currentProgram !== program ) {\n\n\t\t\tthis.gl.useProgram( program );\n\n\t\t\tthis.currentProgram = program;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// framebuffer\n\n\n\tbindFramebuffer( target, framebuffer ) {\n\n\t\tconst { gl, currentBoundFramebuffers } = this;\n\n\t\tif ( currentBoundFramebuffers[ target ] !== framebuffer ) {\n\n\t\t\tgl.bindFramebuffer( target, framebuffer );\n\n\t\t\tcurrentBoundFramebuffers[ target ] = framebuffer;\n\n\t\t\t// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\n\t\t\tif ( target === gl.DRAW_FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\tif ( target === gl.FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tdrawBuffers( renderContext, framebuffer ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet drawBuffers = [];\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tdrawBuffers = this.currentDrawbuffers.get( framebuffer );\n\n\t\t\tif ( drawBuffers === undefined ) {\n\n\t\t\t\tdrawBuffers = [];\n\t\t\t\tthis.currentDrawbuffers.set( framebuffer, drawBuffers );\n\n\t\t\t}\n\n\n\t\t\tconst textures = renderContext.textures;\n\n\t\t\tif ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {\n\n\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\tdrawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t}\n\n\t\t\t\tdrawBuffers.length = textures.length;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\tif ( drawBuffers[ 0 ] !== gl.BACK ) {\n\n\t\t\t\tdrawBuffers[ 0 ] = gl.BACK;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tgl.drawBuffers( drawBuffers );\n\n\t\t}\n\n\t}\n\n\n\t// texture\n\n\tactiveTexture( webglSlot ) {\n\n\t\tconst { gl, currentTextureSlot, maxTextures } = this;\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tthis.currentTextureSlot = webglSlot;\n\n\t\t}\n\n\t}\n\n\tbindTexture( webglType, webglTexture, webglSlot ) {\n\n\t\tconst { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;\n\n\t\tif ( webglSlot === undefined ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\twebglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\t} else {\n\n\t\t\t\twebglSlot = currentTextureSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet boundTexture = currentBoundTextures[ webglSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ webglSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tthis.currentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t\tgl.bindTexture( webglType, webglTexture );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t}\n\n\tbindBufferBase( target, index, buffer ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst key = `${target}-${index}`;\n\n\t\tif ( this.currentBoundBufferBases[ key ] !== buffer ) {\n\n\t\t\tgl.bindBufferBase( target, index, buffer );\n\t\t\tthis.currentBoundBufferBases[ key ] = buffer;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\n\tunbindTexture() {\n\n\t\tconst { gl, currentTextureSlot, currentBoundTextures } = this;\n\n\t\tconst boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture !== undefined && boundTexture.type !== undefined ) {\n\n\t\t\tgl.bindTexture( boundTexture.type, null );\n\n\t\t\tboundTexture.type = undefined;\n\t\t\tboundTexture.texture = undefined;\n\n\t\t}\n\n\t}\n\n}\n\nclass WebGLUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.gl = this.backend.gl;\n\t\tthis.extensions = backend.extensions;\n\n\t}\n\n\tconvert( p, colorSpace = NoColorSpace ) {\n\n\t\tconst { gl, extensions } = this;\n\n\t\tlet extension;\n\n\t\tif ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;\n\t\tif ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;\n\n\t\tif ( p === ByteType ) return gl.BYTE;\n\t\tif ( p === ShortType ) return gl.SHORT;\n\t\tif ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;\n\t\tif ( p === IntType ) return gl.INT;\n\t\tif ( p === UnsignedIntType ) return gl.UNSIGNED_INT;\n\t\tif ( p === FloatType ) return gl.FLOAT;\n\n\t\tif ( p === HalfFloatType ) {\n\n\t\t\treturn gl.HALF_FLOAT;\n\n\t\t}\n\n\t\tif ( p === AlphaFormat ) return gl.ALPHA;\n\t\tif ( p === RGBFormat ) return gl.RGB;\n\t\tif ( p === RGBAFormat ) return gl.RGBA;\n\t\tif ( p === LuminanceFormat ) return gl.LUMINANCE;\n\t\tif ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;\n\t\tif ( p === DepthFormat ) return gl.DEPTH_COMPONENT;\n\t\tif ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;\n\n\t\t// WebGL2 formats.\n\n\t\tif ( p === RedFormat ) return gl.RED;\n\t\tif ( p === RedIntegerFormat ) return gl.RED_INTEGER;\n\t\tif ( p === RGFormat ) return gl.RG;\n\t\tif ( p === RGIntegerFormat ) return gl.RG_INTEGER;\n\t\tif ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;\n\n\t\t// S3TC\n\n\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\tif ( colorSpace === SRGBColorSpace ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// PVRTC\n\n\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ETC\n\n\t\tif ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;\n\t\t\t\tif ( p === RGBA_ETC2_EAC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ASTC\n\n\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\n\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\n\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\n\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\n\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_ASTC_4x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x12_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// BPTC\n\n\t\tif ( p === RGBA_BPTC_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_bptc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// RGTC\n\n\t\tif ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_rgtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n\t\t\t\tif ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\treturn gl.UNSIGNED_INT_24_8;\n\n\t\t}\n\n\t\t// if \"p\" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)\n\n\t\treturn ( gl[ p ] !== undefined ) ? gl[ p ] : null;\n\n\t}\n\n\t_clientWaitAsync() {\n\n\t\tconst { gl } = this;\n\n\t\tconst sync = gl.fenceSync( gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );\n\n\t\tgl.flush();\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tfunction test() {\n\n\t\t\t\tconst res = gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 );\n\n\t\t\t\tif ( res === gl.WAIT_FAILED ) {\n\n\t\t\t\t\tgl.deleteSync( sync );\n\n\t\t\t\t\treject();\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( res === gl.TIMEOUT_EXPIRED ) {\n\n\t\t\t\t\trequestAnimationFrame( test );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tgl.deleteSync( sync );\n\n\t\t\t\tresolve();\n\n\t\t\t}\n\n\t\t\ttest();\n\n\t\t} );\n\n\t}\n\n}\n\nlet initialized = false, wrappingToGL, filterToGL, compareToGL;\n\nclass WebGLTextureUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.gl = backend.gl;\n\t\tthis.extensions = backend.extensions;\n\t\tthis.defaultTextures = {};\n\n\t\tif ( initialized === false ) {\n\n\t\t\tthis._init( this.gl );\n\n\t\t\tinitialized = true;\n\n\t\t}\n\n\t}\n\n\t_init( gl ) {\n\n\t\t// Store only WebGL constants here.\n\n\t\twrappingToGL = {\n\t\t\t[ RepeatWrapping ]: gl.REPEAT,\n\t\t\t[ ClampToEdgeWrapping ]: gl.CLAMP_TO_EDGE,\n\t\t\t[ MirroredRepeatWrapping ]: gl.MIRRORED_REPEAT\n\t\t};\n\n\t\tfilterToGL = {\n\t\t\t[ NearestFilter ]: gl.NEAREST,\n\t\t\t[ NearestMipmapNearestFilter ]: gl.NEAREST_MIPMAP_NEAREST,\n\t\t\t[ NearestMipmapLinearFilter ]: gl.NEAREST_MIPMAP_LINEAR,\n\n\t\t\t[ LinearFilter ]: gl.LINEAR,\n\t\t\t[ LinearMipmapNearestFilter ]: gl.LINEAR_MIPMAP_NEAREST,\n\t\t\t[ LinearMipmapLinearFilter ]: gl.LINEAR_MIPMAP_LINEAR\n\t\t};\n\n\t\tcompareToGL = {\n\t\t\t[ NeverCompare ]: gl.NEVER,\n\t\t\t[ AlwaysCompare ]: gl.ALWAYS,\n\t\t\t[ LessCompare ]: gl.LESS,\n\t\t\t[ LessEqualCompare ]: gl.LEQUAL,\n\t\t\t[ EqualCompare ]: gl.EQUAL,\n\t\t\t[ GreaterEqualCompare ]: gl.GEQUAL,\n\t\t\t[ GreaterCompare ]: gl.GREATER,\n\t\t\t[ NotEqualCompare ]: gl.NOTEQUAL\n\t\t};\n\n\t}\n\n\tfilterFallback( f ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {\n\n\t\t\treturn gl.NEAREST;\n\n\t\t}\n\n\t\treturn gl.LINEAR;\n\n\t}\n\n\tgetGLTextureType( texture ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet glTextureType;\n\n\t\tif ( texture.isCubeTexture === true ) {\n\n\t\t\tglTextureType = gl.TEXTURE_CUBE_MAP;\n\n\t\t} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\tglTextureType = gl.TEXTURE_2D_ARRAY;\n\n\t\t} else if ( texture.isData3DTexture === true ) { // TODO: isCompressed3DTexture, wait for #26642\n\n\t\t\tglTextureType = gl.TEXTURE_3D;\n\n\t\t} else {\n\n\t\t\tglTextureType = gl.TEXTURE_2D;\n\n\n\t\t}\n\n\t\treturn glTextureType;\n\n\t}\n\n\tgetInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {\n\n\t\tconst { gl, extensions } = this;\n\n\t\tif ( internalFormatName !== null ) {\n\n\t\t\tif ( gl[ internalFormatName ] !== undefined ) return gl[ internalFormatName ];\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'' );\n\n\t\t}\n\n\t\tlet internalFormat = glFormat;\n\n\t\tif ( glFormat === gl.RED ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.R32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.R16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.R8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.R16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.R32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RED_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.R8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.R16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.R32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RG ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RG32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RG16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RG8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RG16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RG32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RG_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RG8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RG16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RG32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGB ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RGB32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGB16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGB8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGB16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGB32I;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8 : gl.RGB8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_6_5 ) internalFormat = gl.RGB565;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGB4;\n\t\t\tif ( glType === gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = gl.RGB9_E5;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGB_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGB8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGB16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGB32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGBA ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RGBA32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGBA16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGBA32I;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8_ALPHA8 : gl.RGBA8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGBA4;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGBA_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGBA32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.DEPTH_COMPONENT ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.DEPTH24_STENCIL8;\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.DEPTH_COMPONENT32F;\n\n\t\t}\n\n\t\tif ( glFormat === gl.DEPTH_STENCIL ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_INT_24_8 ) internalFormat = gl.DEPTH24_STENCIL8;\n\n\t\t}\n\n\t\tif ( internalFormat === gl.R16F || internalFormat === gl.R32F ||\n\t\t\tinternalFormat === gl.RG16F || internalFormat === gl.RG32F ||\n\t\t\tinternalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F ) {\n\n\t\t\textensions.get( 'EXT_color_buffer_float' );\n\n\t\t}\n\n\t\treturn internalFormat;\n\n\t}\n\n\tsetTextureParameters( textureType, texture ) {\n\n\t\tconst { gl, extensions, backend } = this;\n\n\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\tgl.pixelStorei( gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\tgl.pixelStorei( gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE );\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );\n\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );\n\n\t\tif ( textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );\n\n\t\t}\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );\n\n\n\t\tconst hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;\n\n\t\t// follow WebGPU backend mapping for texture filtering\n\t\tconst minFilter = texture.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture.minFilter;\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_MIN_FILTER, filterToGL[ minFilter ] );\n\n\t\tif ( texture.compareFunction ) {\n\n\t\t\tgl.texParameteri( textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE );\n\t\t\tgl.texParameteri( textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );\n\n\t\t}\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tif ( texture.magFilter === NearestFilter ) return;\n\t\t\tif ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;\n\t\t\tif ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2\n\n\t\t\tif ( texture.anisotropy > 1 ) {\n\n\t\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\t\t\tgl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, backend.getMaxAnisotropy() ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcreateDefaultTexture( texture ) {\n\n\t\tconst { gl, backend, defaultTextures } = this;\n\n\n\t\tconst glTextureType = this.getGLTextureType( texture );\n\n\t\tlet textureGPU = defaultTextures[ glTextureType ];\n\n\t\tif ( textureGPU === undefined ) {\n\n\t\t\ttextureGPU = gl.createTexture();\n\n\t\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\t\t\tgl.texParameteri( glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\t\t// gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\tdefaultTextures[ glTextureType ] = textureGPU;\n\n\t\t}\n\n\t\tbackend.set( texture, {\n\t\t\ttextureGPU,\n\t\t\tglTextureType,\n\t\t\tisDefault: true\n\t\t} );\n\n\t}\n\n\tcreateTexture( texture, options ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { levels, width, height, depth } = options;\n\n\t\tconst glFormat = backend.utils.convert( texture.format, texture.colorSpace );\n\t\tconst glType = backend.utils.convert( texture.type );\n\t\tconst glInternalFormat = this.getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );\n\n\t\tconst textureGPU = gl.createTexture();\n\t\tconst glTextureType = this.getGLTextureType( texture );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tthis.setTextureParameters( glTextureType, texture );\n\n\t\tif ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\tgl.texStorage3D( gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth );\n\n\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\tgl.texStorage3D( gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth );\n\n\t\t} else if ( ! texture.isVideoTexture ) {\n\n\t\t\tgl.texStorage2D( glTextureType, levels, glInternalFormat, width, height );\n\n\t\t}\n\n\t\tbackend.set( texture, {\n\t\t\ttextureGPU,\n\t\t\tglTextureType,\n\t\t\tglFormat,\n\t\t\tglType,\n\t\t\tglInternalFormat\n\t\t} );\n\n\t}\n\n\tcopyBufferToTexture( buffer, texture ) {\n\n\t\tconst { gl, backend } = this;\n\n\t\tconst { textureGPU, glTextureType, glFormat, glType } = backend.get( texture );\n\n\t\tconst { width, height } = texture.source.data;\n\n\t\tgl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, buffer );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, false );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );\n\t\tgl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, 0 );\n\n\t\tgl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, null );\n\n\t\tbackend.state.unbindTexture();\n\t\t// debug\n\t\t// const framebuffer = gl.createFramebuffer();\n\t\t// gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );\n\t\t// gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );\n\n\t\t// const readout = new Float32Array( width * height * 4 );\n\n\t\t// const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );\n\t\t// const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );\n\n\t\t// gl.readPixels( 0, 0, width, height, altFormat, altType, readout );\n\t\t// gl.bindFramebuffer( gl.FRAMEBUFFER, null );\n\t\t// console.log( readout );\n\n\t}\n\n\tupdateTexture( texture, options ) {\n\n\t\tconst { gl } = this;\n\t\tconst { width, height } = options;\n\t\tconst { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get( texture );\n\n\t\tif ( texture.isRenderTargetTexture || ( textureGPU === undefined /* unsupported texture format */ ) )\n\t\t\treturn;\n\n\t\tconst getImage = ( source ) => {\n\n\t\t\tif ( source.isDataTexture ) {\n\n\t\t\t\treturn source.image.data;\n\n\t\t\t} else if ( ( typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement ) ||\n\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement ) ||\n\t\t\t\t( typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap ) ||\n\t\t\t\tsource instanceof OffscreenCanvas ) {\n\n\t\t\t\treturn source;\n\n\t\t\t}\n\n\t\t\treturn source.data;\n\n\t\t};\n\n\t\tthis.backend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tthis.setTextureParameters( glTextureType, texture );\n\n\t\tif ( texture.isCompressedTexture ) {\n\n\t\t\tconst mipmaps = texture.mipmaps;\n\t\t\tconst image = options.image;\n\n\t\t\tfor ( let i = 0; i < mipmaps.length; i ++ ) {\n\n\t\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.isCompressedArrayTexture ) {\n\n\n\t\t\t\t\tif ( texture.format !== gl.RGBA ) {\n\n\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\tgl.compressedTexSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.texSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\tgl.compressedTexSubImage2D( gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'Unsupported compressed texture format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else if ( texture.isCubeTexture ) {\n\n\t\t\tconst images = options.images;\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tconst image = getImage( images[ i ] );\n\n\t\t\t\tgl.texSubImage2D( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image );\n\n\t\t\t}\n\n\t\t} else if ( texture.isDataArrayTexture ) {\n\n\t\t\tconst image = options.image;\n\n\t\t\tgl.texSubImage3D( gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\tconst image = options.image;\n\n\t\t\tgl.texSubImage3D( gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\ttexture.update();\n\n\t\t\tgl.texImage2D( glTextureType, 0, glInternalFormat, glFormat, glType, options.image );\n\n\n\t\t} else {\n\n\t\t\tconst image = getImage( options.image );\n\n\t\t\tgl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, image );\n\n\t\t}\n\n\t}\n\n\tgenerateMipmaps( texture ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { textureGPU, glTextureType } = backend.get( texture );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\t\tgl.generateMipmap( glTextureType );\n\n\t}\n\n\tdeallocateRenderBuffers( renderTarget ) {\n\n\t\tconst { gl, backend } = this;\n\n\t\t// remove framebuffer reference\n\t\tif ( renderTarget ) {\n\n\t\t\tconst renderContextData = backend.get( renderTarget );\n\n\t\t\trenderContextData.renderBufferStorageSetup = undefined;\n\n\t\t\tif ( renderContextData.framebuffers ) {\n\n\t\t\t\tfor ( const cacheKey in renderContextData.framebuffers ) {\n\n\t\t\t\t\tgl.deleteFramebuffer( renderContextData.framebuffers[ cacheKey ] );\n\n\t\t\t\t}\n\n\t\t\t\tdelete renderContextData.framebuffers;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.depthRenderbuffer ) {\n\n\t\t\t\tgl.deleteRenderbuffer( renderContextData.depthRenderbuffer );\n\t\t\t\tdelete renderContextData.depthRenderbuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.stencilRenderbuffer ) {\n\n\t\t\t\tgl.deleteRenderbuffer( renderContextData.stencilRenderbuffer );\n\t\t\t\tdelete renderContextData.stencilRenderbuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.msaaFrameBuffer ) {\n\n\t\t\t\tgl.deleteFramebuffer( renderContextData.msaaFrameBuffer );\n\t\t\t\tdelete renderContextData.msaaFrameBuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.msaaRenderbuffers ) {\n\n\t\t\t\tfor ( let i = 0; i < renderContextData.msaaRenderbuffers.length; i ++ ) {\n\n\t\t\t\t\tgl.deleteRenderbuffer( renderContextData.msaaRenderbuffers[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tdelete renderContextData.msaaRenderbuffers;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdestroyTexture( texture ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { textureGPU, renderTarget } = backend.get( texture );\n\n\t\tthis.deallocateRenderBuffers( renderTarget );\n\t\tgl.deleteTexture( textureGPU );\n\n\t\tbackend.delete( texture );\n\n\t}\n\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { state } = this.backend;\n\n\t\tconst { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get( dstTexture );\n\n\t\tlet width, height, minX, minY;\n\t\tlet dstX, dstY;\n\n\t\tif ( srcRegion !== null ) {\n\n\t\t\twidth = srcRegion.max.x - srcRegion.min.x;\n\t\t\theight = srcRegion.max.y - srcRegion.min.y;\n\t\t\tminX = srcRegion.min.x;\n\t\t\tminY = srcRegion.min.y;\n\n\t\t} else {\n\n\t\t\twidth = srcTexture.image.width;\n\t\t\theight = srcTexture.image.height;\n\t\t\tminX = 0;\n\t\t\tminY = 0;\n\n\t\t}\n\n\t\tif ( dstPosition !== null ) {\n\n\t\t\tdstX = dstPosition.x;\n\t\t\tdstY = dstPosition.y;\n\n\t\t} else {\n\n\t\t\tdstX = 0;\n\t\t\tdstY = 0;\n\n\t\t}\n\n\t\tstate.bindTexture( glTextureType, dstTextureGPU );\n\n\t\t// As another texture upload may have changed pixelStorei\n\t\t// parameters, make sure they are correct for the dstTexture\n\t\tgl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\tgl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\tconst currentUnpackRowLen = gl.getParameter( gl.UNPACK_ROW_LENGTH );\n\t\tconst currentUnpackImageHeight = gl.getParameter( gl.UNPACK_IMAGE_HEIGHT );\n\t\tconst currentUnpackSkipPixels = gl.getParameter( gl.UNPACK_SKIP_PIXELS );\n\t\tconst currentUnpackSkipRows = gl.getParameter( gl.UNPACK_SKIP_ROWS );\n\t\tconst currentUnpackSkipImages = gl.getParameter( gl.UNPACK_SKIP_IMAGES );\n\n\t\tconst image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;\n\n\t\tgl.pixelStorei( gl.UNPACK_ROW_LENGTH, image.width );\n\t\tgl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, image.height );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_PIXELS, minX );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_ROWS, minY );\n\n\t\tif ( srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture ) {\n\n\t\t\tconst srcTextureData = backend.get( srcTexture );\n\t\t\tconst dstTextureData = backend.get( dstTexture );\n\n\t\t\tconst srcRenderContextData = backend.get( srcTextureData.renderTarget );\n\t\t\tconst dstRenderContextData = backend.get( dstTextureData.renderTarget );\n\n\t\t\tconst srcFramebuffer = srcRenderContextData.framebuffers[ srcTextureData.cacheKey ];\n\t\t\tconst dstFramebuffer = dstRenderContextData.framebuffers[ dstTextureData.cacheKey ];\n\n\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, srcFramebuffer );\n\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, dstFramebuffer );\n\n\t\t\tlet mask = gl.COLOR_BUFFER_BIT;\n\n\t\t\tif ( srcTexture.isDepthTexture ) mask = gl.DEPTH_BUFFER_BIT;\n\n\t\t\tgl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, mask, gl.NEAREST );\n\n\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, null );\n\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );\n\n\t\t} else {\n\n\t\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t\tgl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data );\n\n\t\t\t} else {\n\n\t\t\t\tif ( srcTexture.isCompressedTexture ) {\n\n\t\t\t\t\tgl.compressedTexSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.pixelStorei( gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );\n\t\tgl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );\n\n\t\t// Generate mipmaps only when copying level 0\n\t\tif ( level === 0 && dstTexture.generateMipmaps ) gl.generateMipmap( gl.TEXTURE_2D );\n\n\t\tstate.unbindTexture();\n\n\t}\n\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tconst { gl } = this;\n\t\tconst { state } = this.backend;\n\n\t\tconst { textureGPU } = this.backend.get( texture );\n\n\t\tconst { x, y, z: width, w: height } = rectangle;\n\n\t\tconst requireDrawFrameBuffer = texture.isDepthTexture === true || ( renderContext.renderTarget && renderContext.renderTarget.samples > 0 );\n\n\t\tconst srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.gerDrawingBufferSize().y;\n\n\t\tif ( requireDrawFrameBuffer ) {\n\n\t\t\tconst partial = ( x !== 0 || y !== 0 );\n\t\t\tlet mask;\n\t\t\tlet attachment;\n\n\t\t\tif ( texture.isDepthTexture === true ) {\n\n\t\t\t\tmask = gl.DEPTH_BUFFER_BIT;\n\t\t\t\tattachment = gl.DEPTH_ATTACHMENT;\n\n\t\t\t\tif ( renderContext.stencil ) {\n\n\t\t\t\t\tmask |= gl.STENCIL_BUFFER_BIT;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tmask = gl.COLOR_BUFFER_BIT;\n\t\t\t\tattachment = gl.COLOR_ATTACHMENT0;\n\n\t\t\t}\n\n\t\t\tif ( partial ) {\n\n\t\t\t\tconst renderTargetContextData = this.backend.get( renderContext.renderTarget );\n\n\t\t\t\tconst fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];\n\t\t\t\tconst msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );\n\n\t\t\t\tconst flippedY = srcHeight - y - height;\n\n\t\t\t\tgl.blitFramebuffer( x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST );\n\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );\n\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, textureGPU );\n\n\t\t\t\tgl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height );\n\n\t\t\t\tstate.unbindTexture();\n\n\t\t\t} else {\n\n\t\t\t\tconst fb = gl.createFramebuffer();\n\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\n\t\t\t\tgl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0 );\n\t\t\t\tgl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST );\n\n\t\t\t\tgl.deleteFramebuffer( fb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, textureGPU );\n\t\t\tgl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height );\n\n\t\t\tstate.unbindTexture();\n\n\t\t}\n\n\t\tif ( texture.generateMipmaps ) this.generateMipmaps( texture );\n\n\t\tthis.backend._setFramebuffer( renderContext );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tsetupRenderBufferStorage( renderbuffer, renderContext ) {\n\n\t\tconst { gl } = this;\n\t\tconst renderTarget = renderContext.renderTarget;\n\n\t\tconst { samples, depthTexture, depthBuffer, stencilBuffer, width, height } = renderTarget;\n\n\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( depthBuffer && ! stencilBuffer ) {\n\n\t\t\tlet glInternalFormat = gl.DEPTH_COMPONENT24;\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tif ( depthTexture && depthTexture.isDepthTexture ) {\n\n\t\t\t\t\tif ( depthTexture.type === gl.FLOAT ) {\n\n\t\t\t\t\t\tglInternalFormat = gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, glInternalFormat, width, height );\n\n\t\t\t} else {\n\n\t\t\t\tgl.renderbufferStorage( gl.RENDERBUFFER, glInternalFormat, width, height );\n\n\t\t\t}\n\n\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else if ( depthBuffer && stencilBuffer ) {\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height );\n\n\t\t\t} else {\n\n\t\t\t\tgl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height );\n\n\t\t\t}\n\n\n\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );\n\n\t\t}\n\n\t}\n\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\tconst { backend, gl } = this;\n\n\t\tconst { textureGPU, glFormat, glType } = this.backend.get( texture );\n\n\t\tconst fb = gl.createFramebuffer();\n\n\t\tgl.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );\n\n\t\tconst target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;\n\n\t\tgl.framebufferTexture2D( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0 );\n\n\t\tconst typedArrayType = this._getTypedArrayType( glType );\n\t\tconst bytesPerTexel = this._getBytesPerTexel( glType, glFormat );\n\n\t\tconst elementCount = width * height;\n\t\tconst byteLength = elementCount * bytesPerTexel;\n\n\t\tconst buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );\n\t\tgl.bufferData( gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ );\n\t\tgl.readPixels( x, y, width, height, glFormat, glType, 0 );\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );\n\n\t\tawait backend.utils._clientWaitAsync();\n\n\t\tconst dstBuffer = new typedArrayType( byteLength / typedArrayType.BYTES_PER_ELEMENT );\n\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );\n\t\tgl.getBufferSubData( gl.PIXEL_PACK_BUFFER, 0, dstBuffer );\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );\n\n\t\tgl.deleteFramebuffer( fb );\n\n\t\treturn dstBuffer;\n\n\t}\n\n\t_getTypedArrayType( glType ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( glType === gl.UNSIGNED_BYTE ) return Uint8Array;\n\n\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT_5_6_5 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_INT ) return Uint32Array;\n\n\t\tif ( glType === gl.HALF_FLOAT ) return Uint16Array;\n\t\tif ( glType === gl.FLOAT ) return Float32Array;\n\n\t\tthrow new Error( `Unsupported WebGL type: ${glType}` );\n\n\t}\n\n\t_getBytesPerTexel( glType, glFormat ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet bytesPerComponent = 0;\n\n\t\tif ( glType === gl.UNSIGNED_BYTE ) bytesPerComponent = 1;\n\n\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ||\n\t\t\tglType === gl.UNSIGNED_SHORT_5_5_5_1 ||\n\t\t\tglType === gl.UNSIGNED_SHORT_5_6_5 ||\n\t\t\tglType === gl.UNSIGNED_SHORT ||\n\t\t\tglType === gl.HALF_FLOAT ) bytesPerComponent = 2;\n\n\t\tif ( glType === gl.UNSIGNED_INT ||\n\t\t\tglType === gl.FLOAT ) bytesPerComponent = 4;\n\n\t\tif ( glFormat === gl.RGBA ) return bytesPerComponent * 4;\n\t\tif ( glFormat === gl.RGB ) return bytesPerComponent * 3;\n\t\tif ( glFormat === gl.ALPHA ) return bytesPerComponent;\n\n\t}\n\n}\n\nclass WebGLExtensions {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.gl = this.backend.gl;\n\t\tthis.availableExtensions = this.gl.getSupportedExtensions();\n\n\t\tthis.extensions = {};\n\n\t}\n\n\tget( name ) {\n\n\t\tlet extension = this.extensions[ name ];\n\n\t\tif ( extension === undefined ) {\n\n\t\t\textension = this.gl.getExtension( name );\n\n\t\t\tthis.extensions[ name ] = extension;\n\n\t\t}\n\n\t\treturn extension;\n\n\t}\n\n\thas( name ) {\n\n\t\treturn this.availableExtensions.includes( name );\n\n\t}\n\n}\n\nclass WebGLCapabilities {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.maxAnisotropy = null;\n\n\t}\n\n\tgetMaxAnisotropy() {\n\n\t\tif ( this.maxAnisotropy !== null ) return this.maxAnisotropy;\n\n\t\tconst gl = this.backend.gl;\n\t\tconst extensions = this.backend.extensions;\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tthis.maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tthis.maxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn this.maxAnisotropy;\n\n\t}\n\n}\n\nconst GLFeatureName = {\n\n\t'WEBGL_multi_draw': 'WEBGL_multi_draw',\n\t'WEBGL_compressed_texture_astc': 'texture-compression-astc',\n\t'WEBGL_compressed_texture_etc': 'texture-compression-etc2',\n\t'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',\n\t'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n\t'WEBKIT_WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n\t'WEBGL_compressed_texture_s3tc': 'texture-compression-bc',\n\t'EXT_texture_compression_bptc': 'texture-compression-bptc',\n\t'EXT_disjoint_timer_query_webgl2': 'timestamp-query',\n\n};\n\nclass WebGLBufferRenderer {\n\n\tconstructor( backend ) {\n\n\t\tthis.gl = backend.gl;\n\t\tthis.extensions = backend.extensions;\n\t\tthis.info = backend.renderer.info;\n\t\tthis.mode = null;\n\t\tthis.index = 0;\n\t\tthis.type = null;\n\t\tthis.object = null;\n\n\t}\n\n\trender( start, count ) {\n\n\t\tconst { gl, mode, object, type, info, index } = this;\n\n\t\tif ( index !== 0 ) {\n\n\t\t\tgl.drawElements( mode, count, type, start );\n\n\t\t} else {\n\n\t\t\tgl.drawArrays( mode, start, count );\n\n\t\t}\n\n\t\tinfo.update( object, count, mode, 1 );\n\n\t}\n\n\trenderInstances( start, count, primcount ) {\n\n\t\tconst { gl, mode, type, index, object, info } = this;\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tif ( index !== 0 ) {\n\n\t\t\tgl.drawElementsInstanced( mode, count, type, start, primcount );\n\n\t\t} else {\n\n\t\t\tgl.drawArraysInstanced( mode, start, count, primcount );\n\n\t\t}\n\n\t\tinfo.update( object, count, mode, primcount );\n\n\t}\n\n\trenderMultiDraw( starts, counts, drawCount ) {\n\n\t\tconst { extensions, mode, object, info } = this;\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tthis.render( starts[ i ], counts[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.index !== 0 ) {\n\n\t\t\t\textension.multiDrawElementsWEBGL( mode, counts, 0, this.type, starts, 0, drawCount );\n\n\t\t\t} else {\n\n\t\t\t\textension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );\n\n\t\t\t}\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( object, elementCount, mode, 1 );\n\n\t\t}\n\n\t}\n\n\trenderMultiDrawInstances( starts, counts, drawCount, primcount ) {\n\n\t\tconst { extensions, mode, object, info } = this;\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tthis.renderInstances( starts[ i ], counts[ i ], primcount[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.index !== 0 ) {\n\n\t\t\t\textension.multiDrawElementsInstancedWEBGL( mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount );\n\n\t\t\t} else {\n\n\t\t\t\textension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );\n\n\t\t\t}\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ] * primcount[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( object, elementCount, mode, 1 );\n\n\t\t}\n\n\t}\n\n\t//\n\n}\n\n//\n\nclass WebGLBackend extends Backend {\n\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters );\n\n\t\tthis.isWebGLBackend = true;\n\n\t}\n\n\tinit( renderer ) {\n\n\t\tsuper.init( renderer );\n\n\t\t//\n\n\t\tconst parameters = this.parameters;\n\n\t\tconst glContext = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgl2' );\n\n\t \tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tconst contextLossInfo = {\n\t\t\t\tapi: 'WebGL',\n\t\t\t\tmessage: event.statusMessage || 'Unknown reason',\n\t\t\t\treason: null,\n\t\t\t\toriginalEvent: event\n\t\t\t};\n\n\t\t\trenderer.onDeviceLost( contextLossInfo );\n\n\t\t}\n\n\t\tthis._onContextLost = onContextLost;\n\n\t\trenderer.domElement.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\tthis.gl = glContext;\n\n\t\tthis.extensions = new WebGLExtensions( this );\n\t\tthis.capabilities = new WebGLCapabilities( this );\n\t\tthis.attributeUtils = new WebGLAttributeUtils( this );\n\t\tthis.textureUtils = new WebGLTextureUtils( this );\n\t\tthis.bufferRenderer = new WebGLBufferRenderer( this );\n\n\t\tthis.state = new WebGLState( this );\n\t\tthis.utils = new WebGLUtils( this );\n\n\t\tthis.vaoCache = {};\n\t\tthis.transformFeedbackCache = {};\n\t\tthis.discard = false;\n\t\tthis.trackTimestamp = ( parameters.trackTimestamp === true );\n\n\t\tthis.extensions.get( 'EXT_color_buffer_float' );\n\t\tthis.extensions.get( 'WEBGL_clip_cull_distance' );\n\t\tthis.extensions.get( 'OES_texture_float_linear' );\n\t\tthis.extensions.get( 'EXT_color_buffer_half_float' );\n\t\tthis.extensions.get( 'WEBGL_multisampled_render_to_texture' );\n\t\tthis.extensions.get( 'WEBGL_render_shared_exponent' );\n\t\tthis.extensions.get( 'WEBGL_multi_draw' );\n\n\t\tthis.disjoint = this.extensions.get( 'EXT_disjoint_timer_query_webgl2' );\n\t\tthis.parallel = this.extensions.get( 'KHR_parallel_shader_compile' );\n\n\t\tthis._knownBindings = new WeakSet();\n\n\t\tthis._currentContext = null;\n\n\t}\n\n\tget coordinateSystem() {\n\n\t\treturn WebGLCoordinateSystem;\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.attributeUtils.getArrayBufferAsync( attribute );\n\n\t}\n\n\tasync waitForGPU() {\n\n\t\tawait this.utils._clientWaitAsync();\n\n\t}\n\n\tinitTimestampQuery( renderContext ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( this.queryRunning ) {\n\n\t\t  if ( ! renderContextData.queryQueue ) renderContextData.queryQueue = [];\n\t\t  renderContextData.queryQueue.push( renderContext );\n\t\t  return;\n\n\t\t}\n\n\t\tif ( renderContextData.activeQuery ) {\n\n\t\t  this.gl.endQuery( this.disjoint.TIME_ELAPSED_EXT );\n\t\t  renderContextData.activeQuery = null;\n\n\t\t}\n\n\t\trenderContextData.activeQuery = this.gl.createQuery();\n\n\t\tif ( renderContextData.activeQuery !== null ) {\n\n\t\t  this.gl.beginQuery( this.disjoint.TIME_ELAPSED_EXT, renderContextData.activeQuery );\n\t\t  this.queryRunning = true;\n\n\t\t}\n\n\t}\n\n\t// timestamp utils\n\n\tprepareTimestampBuffer( renderContext ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( renderContextData.activeQuery ) {\n\n\t\t  this.gl.endQuery( this.disjoint.TIME_ELAPSED_EXT );\n\n\t\t  if ( ! renderContextData.gpuQueries ) renderContextData.gpuQueries = [];\n\t\t  renderContextData.gpuQueries.push( { query: renderContextData.activeQuery } );\n\t\t  renderContextData.activeQuery = null;\n\t\t  this.queryRunning = false;\n\n\t\t  if ( renderContextData.queryQueue && renderContextData.queryQueue.length > 0 ) {\n\n\t\t\t\tconst nextRenderContext = renderContextData.queryQueue.shift();\n\t\t\t\tthis.initTimestampQuery( nextRenderContext );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tasync resolveTimestampAsync( renderContext, type = 'render' ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( ! renderContextData.gpuQueries ) renderContextData.gpuQueries = [];\n\n\t\tfor ( let i = 0; i < renderContextData.gpuQueries.length; i ++ ) {\n\n\t\t  const queryInfo = renderContextData.gpuQueries[ i ];\n\t\t  const available = this.gl.getQueryParameter( queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE );\n\t\t  const disjoint = this.gl.getParameter( this.disjoint.GPU_DISJOINT_EXT );\n\n\t\t  if ( available && ! disjoint ) {\n\n\t\t\t\tconst elapsed = this.gl.getQueryParameter( queryInfo.query, this.gl.QUERY_RESULT );\n\t\t\t\tconst duration = Number( elapsed ) / 1000000; // Convert nanoseconds to milliseconds\n\t\t\t\tthis.gl.deleteQuery( queryInfo.query );\n\t\t\t\trenderContextData.gpuQueries.splice( i, 1 ); // Remove the processed query\n\t\t\t\ti --;\n\t\t\t\tthis.renderer.info.updateTimestamp( type, duration );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.gl;\n\n\t}\n\n\tbeginRender( renderContext ) {\n\n\t\tconst { gl } = this;\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t//\n\n\t\t//\n\n\t\tthis.initTimestampQuery( renderContext );\n\n\t\trenderContextData.previousContext = this._currentContext;\n\t\tthis._currentContext = renderContext;\n\n\t\tthis._setFramebuffer( renderContext );\n\n\t\tthis.clear( renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false );\n\n\t\t//\n\t\tif ( renderContext.viewport ) {\n\n\t\t\tthis.updateViewport( renderContext );\n\n\t\t} else {\n\n\t\t\tgl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );\n\n\t\t}\n\n\t\tif ( renderContext.scissor ) {\n\n\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\tgl.scissor( x, renderContext.height - height - y, width, height );\n\n\t\t}\n\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\t// Get a reference to the array of objects with queries. The renderContextData property\n\t\t\t// can be changed by another render pass before the async reading of all previous queries complete\n\t\t\trenderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;\n\t\t\trenderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n\t\t\trenderContextData.lastOcclusionObject = null;\n\t\t\trenderContextData.occlusionQueries = new Array( occlusionQueryCount );\n\t\t\trenderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );\n\t\t\trenderContextData.occlusionQueryIndex = 0;\n\n\t\t}\n\n\t}\n\n\tfinishRender( renderContext ) {\n\n\t\tconst { gl, state } = this;\n\t\tconst renderContextData = this.get( renderContext );\n\t\tconst previousContext = renderContextData.previousContext;\n\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tif ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {\n\n\t\t\t\tgl.endQuery( gl.ANY_SAMPLES_PASSED );\n\n\t\t\t}\n\n\t\t\tthis.resolveOccludedAsync( renderContext );\n\n\t\t}\n\n\t\tconst textures = renderContext.textures;\n\n\t\tif ( textures !== null ) {\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.generateMipmaps ) {\n\n\t\t\t\t\tthis.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._currentContext = previousContext;\n\n\t\tif ( renderContext.textures !== null && renderContext.renderTarget ) {\n\n\t\t\tconst renderTargetContextData = this.get( renderContext.renderTarget );\n\n\t\t\tconst { samples } = renderContext.renderTarget;\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tconst fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];\n\n\t\t\t\tconst mask = gl.COLOR_BUFFER_BIT;\n\n\t\t\t\tconst msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t\tconst textures = renderContext.textures;\n\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t// TODO Add support for MRT\n\n\t\t\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\t\t\t\tconst viewY = renderContext.height - height - y;\n\n\t\t\t\t\t\tgl.blitFramebuffer( x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST );\n\t\t\t\t\t\tgl.invalidateSubFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray, x, viewY, width, height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blitFramebuffer( 0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST );\n\t\t\t\t\t\tgl.invalidateFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tif ( previousContext !== null ) {\n\n\t\t\tthis._setFramebuffer( previousContext );\n\n\t\t\tif ( previousContext.viewport ) {\n\n\t\t\t\tthis.updateViewport( previousContext );\n\n\t\t\t} else {\n\n\t\t\t\tgl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.prepareTimestampBuffer( renderContext );\n\n\t}\n\n\tresolveOccludedAsync( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t// handle occlusion query results\n\n\t\tconst { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;\n\n\t\tif ( currentOcclusionQueries && currentOcclusionQueryObjects ) {\n\n\t\t\tconst occluded = new WeakSet();\n\t\t\tconst { gl } = this;\n\n\t\t\trenderContextData.currentOcclusionQueryObjects = null;\n\t\t\trenderContextData.currentOcclusionQueries = null;\n\n\t\t\tconst check = () => {\n\n\t\t\t\tlet completed = 0;\n\n\t\t\t\t// check all queries and requeue as appropriate\n\t\t\t\tfor ( let i = 0; i < currentOcclusionQueries.length; i ++ ) {\n\n\t\t\t\t\tconst query = currentOcclusionQueries[ i ];\n\n\t\t\t\t\tif ( query === null ) continue;\n\n\t\t\t\t\tif ( gl.getQueryParameter( query, gl.QUERY_RESULT_AVAILABLE ) ) {\n\n\t\t\t\t\t\tif ( gl.getQueryParameter( query, gl.QUERY_RESULT ) > 0 ) occluded.add( currentOcclusionQueryObjects[ i ] );\n\n\t\t\t\t\t\tcurrentOcclusionQueries[ i ] = null;\n\t\t\t\t\t\tgl.deleteQuery( query );\n\n\t\t\t\t\t\tcompleted ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( completed < currentOcclusionQueries.length ) {\n\n\t\t\t\t\trequestAnimationFrame( check );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderContextData.occluded = occluded;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcheck();\n\n\t\t}\n\n\t}\n\n\tisOccluded( renderContext, object ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\treturn renderContextData.occluded && renderContextData.occluded.has( object );\n\n\t}\n\n\tupdateViewport( renderContext ) {\n\n\t\tconst gl = this.gl;\n\t\tconst { x, y, width, height } = renderContext.viewportValue;\n\n\t\tgl.viewport( x, renderContext.height - height - y, width, height );\n\n\t}\n\n\tsetScissorTest( boolean ) {\n\n\t\tconst gl = this.gl;\n\n\t\tif ( boolean ) {\n\n\t\t\tgl.enable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tgl.disable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t}\n\n\tclear( color, depth, stencil, descriptor = null, setFrameBuffer = true ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( descriptor === null ) {\n\n\t\t\tconst clearColor = this.getClearColor();\n\n\t\t\t// premultiply alpha\n\n\t\t\tclearColor.r *= clearColor.a;\n\t\t\tclearColor.g *= clearColor.a;\n\t\t\tclearColor.b *= clearColor.a;\n\n\t\t\tdescriptor = {\n\t\t\t\ttextures: null,\n\t\t\t\tclearColorValue: clearColor\n\t\t\t};\n\n\t\t}\n\n\t\t//\n\n\t\tlet clear = 0;\n\n\t\tif ( color ) clear |= gl.COLOR_BUFFER_BIT;\n\t\tif ( depth ) clear |= gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil ) clear |= gl.STENCIL_BUFFER_BIT;\n\n\t\tif ( clear !== 0 ) {\n\n\t\t\tlet clearColor;\n\n\t\t\tif ( descriptor.clearColorValue ) {\n\n\t\t\t\tclearColor = descriptor.clearColorValue;\n\n\t\t\t} else {\n\n\t\t\t\tclearColor = this.getClearColor();\n\n\t\t\t\t// premultiply alpha\n\n\t\t\t\tclearColor.r *= clearColor.a;\n\t\t\t\tclearColor.g *= clearColor.a;\n\t\t\t\tclearColor.b *= clearColor.a;\n\n\t\t\t}\n\n\t\t\tif ( depth ) this.state.setDepthMask( true );\n\n\t\t\tif ( descriptor.textures === null ) {\n\n\t\t\t\tgl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearColor.a );\n\t\t\t\tgl.clear( clear );\n\n\t\t\t} else {\n\n\t\t\t\tif ( setFrameBuffer ) this._setFramebuffer( descriptor );\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tfor ( let i = 0; i < descriptor.textures.length; i ++ ) {\n\n\t\t\t\t\t\tgl.clearBufferfv( gl.COLOR, i, [ clearColor.r, clearColor.g, clearColor.b, clearColor.a ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( depth && stencil ) {\n\n\t\t\t\t\tgl.clearBufferfi( gl.DEPTH_STENCIL, 0, 1, 0 );\n\n\t\t\t\t} else if ( depth ) {\n\n\t\t\t\t\tgl.clearBufferfv( gl.DEPTH, 0, [ 1.0 ] );\n\n\t\t\t\t} else if ( stencil ) {\n\n\t\t\t\t\tgl.clearBufferiv( gl.STENCIL, 0, [ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tbeginCompute( computeGroup ) {\n\n\t\tconst { state, gl } = this;\n\n\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, null );\n\t\tthis.initTimestampQuery( computeGroup );\n\n\t}\n\n\tcompute( computeGroup, computeNode, bindings, pipeline ) {\n\n\t\tconst { state, gl } = this;\n\n\t\tif ( ! this.discard ) {\n\n\t\t\t// required here to handle async behaviour of render.compute()\n\t\t\tgl.enable( gl.RASTERIZER_DISCARD );\n\t\t\tthis.discard = true;\n\n\t\t}\n\n\t\tconst { programGPU, transformBuffers, attributes } = this.get( pipeline );\n\n\t\tconst vaoKey = this._getVaoKey( null, attributes );\n\n\t\tconst vaoGPU = this.vaoCache[ vaoKey ];\n\n\t\tif ( vaoGPU === undefined ) {\n\n\t\t\tthis._createVao( null, attributes );\n\n\t\t} else {\n\n\t\t\tgl.bindVertexArray( vaoGPU );\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\tthis._bindUniforms( bindings );\n\n\t\tconst transformFeedbackGPU = this._getTransformFeedback( transformBuffers );\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );\n\t\tgl.beginTransformFeedback( gl.POINTS );\n\n\t\tif ( attributes[ 0 ].isStorageInstancedBufferAttribute ) {\n\n\t\t\tgl.drawArraysInstanced( gl.POINTS, 0, 1, computeNode.count );\n\n\t\t} else {\n\n\t\t\tgl.drawArrays( gl.POINTS, 0, computeNode.count );\n\n\t\t}\n\n\t\tgl.endTransformFeedback();\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );\n\n\t\t// switch active buffers\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tconst dualAttributeData = transformBuffers[ i ];\n\n\t\t\tif ( dualAttributeData.pbo ) {\n\n\t\t\t\tthis.textureUtils.copyBufferToTexture( dualAttributeData.transformBuffer, dualAttributeData.pbo );\n\n\t\t\t}\n\n\t\t\tdualAttributeData.switchBuffers();\n\n\n\t\t}\n\n\t}\n\n\tfinishCompute( computeGroup ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.discard = false;\n\n\t\tgl.disable( gl.RASTERIZER_DISCARD );\n\n\t\tthis.prepareTimestampBuffer( computeGroup );\n\n\t\tif ( this._currentContext ) {\n\n\t\t\tthis._setFramebuffer( this._currentContext );\n\n\t\t}\n\n\t}\n\n\tdraw( renderObject/*, info*/ ) {\n\n\t\tconst { object, pipeline, material, context, hardwareClippingPlanes } = renderObject;\n\t\tconst { programGPU } = this.get( pipeline );\n\n\t\tconst { gl, state } = this;\n\n\t\tconst contextData = this.get( context );\n\n\t\tconst drawParams = renderObject.getDrawParameters();\n\n\t\tif ( drawParams === null ) return;\n\n\t\t//\n\n\t\tthis._bindUniforms( renderObject.getBindings() );\n\n\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\tstate.setMaterial( material, frontFaceCW, hardwareClippingPlanes );\n\n\t\tstate.useProgram( programGPU );\n\n\t\t//\n\n\t\tconst renderObjectData = this.get( renderObject );\n\n\t\tlet vaoGPU = renderObjectData.staticVao;\n\n\t\tif ( vaoGPU === undefined || renderObjectData.geometryId !== renderObject.geometry.id ) {\n\n\t\t\tconst vaoKey = this._getVaoKey( renderObject.getIndex(), renderObject.getAttributes() );\n\n\t\t\tvaoGPU = this.vaoCache[ vaoKey ];\n\n\t\t\tif ( vaoGPU === undefined ) {\n\n\t\t\t\tlet staticVao;\n\n\t\t\t\t( { vaoGPU, staticVao } = this._createVao( renderObject.getIndex(), renderObject.getAttributes() ) );\n\n\t\t\t\tif ( staticVao ) {\n\n\t\t\t\t\trenderObjectData.staticVao = vaoGPU;\n\t\t\t\t\trenderObjectData.geometryId = renderObject.geometry.id;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindVertexArray( vaoGPU );\n\n\t\t//\n\n\t\tconst index = renderObject.getIndex();\n\n\t\t//\n\n\t\tconst lastObject = contextData.lastOcclusionObject;\n\n\t\tif ( lastObject !== object && lastObject !== undefined ) {\n\n\t\t\tif ( lastObject !== null && lastObject.occlusionTest === true ) {\n\n\t\t\t\tgl.endQuery( gl.ANY_SAMPLES_PASSED );\n\n\t\t\t\tcontextData.occlusionQueryIndex ++;\n\n\t\t\t}\n\n\t\t\tif ( object.occlusionTest === true ) {\n\n\t\t\t\tconst query = gl.createQuery();\n\n\t\t\t\tgl.beginQuery( gl.ANY_SAMPLES_PASSED, query );\n\n\t\t\t\tcontextData.occlusionQueries[ contextData.occlusionQueryIndex ] = query;\n\t\t\t\tcontextData.occlusionQueryObjects[ contextData.occlusionQueryIndex ] = object;\n\n\t\t\t}\n\n\t\t\tcontextData.lastOcclusionObject = object;\n\n\t\t}\n\n\t\t//\n\t\tconst renderer = this.bufferRenderer;\n\n\t\tif ( object.isPoints ) renderer.mode = gl.POINTS;\n\t\telse if ( object.isLineSegments ) renderer.mode = gl.LINES;\n\t\telse if ( object.isLine ) renderer.mode = gl.LINE_STRIP;\n\t\telse if ( object.isLineLoop ) renderer.mode = gl.LINE_LOOP;\n\t\telse {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * this.renderer.getPixelRatio() );\n\t\t\t\trenderer.mode = gl.LINES;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.mode = gl.TRIANGLES;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst { vertexCount, instanceCount } = drawParams;\n\t\tlet { firstVertex } = drawParams;\n\n\t\trenderer.object = object;\n\n\t\tif ( index !== null ) {\n\n\t\t\tfirstVertex *= index.array.BYTES_PER_ELEMENT;\n\n\t\t\tconst indexData = this.get( index );\n\n\t\t\trenderer.index = index.count;\n\t\t\trenderer.type = indexData.type;\n\n\t\t} else {\n\n\t\t\trenderer.index = 0;\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tif ( object._multiDrawInstances !== null ) {\n\n\t\t\t\trenderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );\n\n\t\t\t} else if ( ! this.hasFeature( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\twarnOnce( 'THREE.WebGLRenderer: WEBGL_multi_draw not supported.' );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );\n\n\t\t\t}\n\n\t\t} else if ( instanceCount > 1 ) {\n\n\t\t\trenderer.renderInstances( firstVertex, vertexCount, instanceCount );\n\n\t\t} else {\n\n\t\t\trenderer.render( firstVertex, vertexCount );\n\n\t\t}\n\t\t//\n\n\t\tgl.bindVertexArray( null );\n\n\t}\n\n\tneedsRenderUpdate( /*renderObject*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetRenderCacheKey( /*renderObject*/ ) {\n\n\t\treturn '';\n\n\t}\n\n\t// textures\n\n\tcreateDefaultTexture( texture ) {\n\n\t\tthis.textureUtils.createDefaultTexture( texture );\n\n\t}\n\n\tcreateTexture( texture, options ) {\n\n\t\tthis.textureUtils.createTexture( texture, options );\n\n\t}\n\n\tupdateTexture( texture, options ) {\n\n\t\tthis.textureUtils.updateTexture( texture, options );\n\n\t}\n\n\tgenerateMipmaps( texture ) {\n\n\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t}\n\n\n\tdestroyTexture( texture ) {\n\n\t\tthis.textureUtils.destroyTexture( texture );\n\n\t}\n\n\tcopyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\treturn this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );\n\n\t}\n\n\tcreateSampler( /*texture*/ ) {\n\n\t\t//console.warn( 'Abstract class.' );\n\n\t}\n\n\tdestroySampler() {}\n\n\t// node builder\n\n\tcreateNodeBuilder( object, renderer ) {\n\n\t\treturn new GLSLNodeBuilder( object, renderer );\n\n\t}\n\n\t// program\n\n\tcreateProgram( program ) {\n\n\t\tconst gl = this.gl;\n\t\tconst { stage, code } = program;\n\n\t\tconst shader = stage === 'fragment' ? gl.createShader( gl.FRAGMENT_SHADER ) : gl.createShader( gl.VERTEX_SHADER );\n\n\t\tgl.shaderSource( shader, code );\n\t\tgl.compileShader( shader );\n\n\t\tthis.set( program, {\n\t\t\tshaderGPU: shader\n\t\t} );\n\n\t}\n\n\tdestroyProgram( /*program*/ ) {\n\n\t\tconsole.warn( 'Abstract class.' );\n\n\t}\n\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tconst gl = this.gl;\n\t\tconst pipeline = renderObject.pipeline;\n\n\t\t// Program\n\n\t\tconst { fragmentProgram, vertexProgram } = pipeline;\n\n\t\tconst programGPU = gl.createProgram();\n\n\t\tconst fragmentShader = this.get( fragmentProgram ).shaderGPU;\n\t\tconst vertexShader = this.get( vertexProgram ).shaderGPU;\n\n\t\tgl.attachShader( programGPU, fragmentShader );\n\t\tgl.attachShader( programGPU, vertexShader );\n\t\tgl.linkProgram( programGPU );\n\n\t\tthis.set( pipeline, {\n\t\t\tprogramGPU,\n\t\t\tfragmentShader,\n\t\t\tvertexShader\n\t\t} );\n\n\t\tif ( promises !== null && this.parallel ) {\n\n\t\t\tconst p = new Promise( ( resolve /*, reject*/ ) => {\n\n\t\t\t\tconst parallel = this.parallel;\n\t\t\t\tconst checkStatus = () => {\n\n\t\t\t\t\tif ( gl.getProgramParameter( programGPU, parallel.COMPLETION_STATUS_KHR ) ) {\n\n\t\t\t\t\t\tthis._completeCompile( renderObject, pipeline );\n\t\t\t\t\t\tresolve();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\trequestAnimationFrame( checkStatus );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tcheckStatus();\n\n\t\t\t} );\n\n\t\t\tpromises.push( p );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._completeCompile( renderObject, pipeline );\n\n\t}\n\n\t_handleSource( string, errorLine ) {\n\n\t\tconst lines = string.split( '\\n' );\n\t\tconst lines2 = [];\n\n\t\tconst from = Math.max( errorLine - 6, 0 );\n\t\tconst to = Math.min( errorLine + 6, lines.length );\n\n\t\tfor ( let i = from; i < to; i ++ ) {\n\n\t\t\tconst line = i + 1;\n\t\t\tlines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );\n\n\t\t}\n\n\t\treturn lines2.join( '\\n' );\n\n\t}\n\n\t_getShaderErrors( gl, shader, type ) {\n\n\t\tconst status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );\n\t\tconst errors = gl.getShaderInfoLog( shader ).trim();\n\n\t\tif ( status && errors === '' ) return '';\n\n\t\tconst errorMatches = /ERROR: 0:(\\d+)/.exec( errors );\n\t\tif ( errorMatches ) {\n\n\t\t\tconst errorLine = parseInt( errorMatches[ 1 ] );\n\t\t\treturn type.toUpperCase() + '\\n\\n' + errors + '\\n\\n' + this._handleSource( gl.getShaderSource( shader ), errorLine );\n\n\t\t} else {\n\n\t\t\treturn errors;\n\n\t\t}\n\n\t}\n\n\t_logProgramError( programGPU, glFragmentShader, glVertexShader ) {\n\n\t\tif ( this.renderer.debug.checkShaderErrors ) {\n\n\t\t\tconst gl = this.gl;\n\n\t\t\tconst programLog = gl.getProgramInfoLog( programGPU ).trim();\n\n\t\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\n\t\t\t\tif ( typeof this.renderer.debug.onShaderError === 'function' ) {\n\n\t\t\t\t\tthis.renderer.debug.onShaderError( gl, programGPU, glVertexShader, glFragmentShader );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// default error reporting\n\n\t\t\t\t\tconst vertexErrors = this._getShaderErrors( gl, glVertexShader, 'vertex' );\n\t\t\t\t\tconst fragmentErrors = this._getShaderErrors( gl, glFragmentShader, 'fragment' );\n\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +\n\t\t\t\t\t\t'VALIDATE_STATUS ' + gl.getProgramParameter( programGPU, gl.VALIDATE_STATUS ) + '\\n\\n' +\n\t\t\t\t\t\t'Program Info Log: ' + programLog + '\\n' +\n\t\t\t\t\t\tvertexErrors + '\\n' +\n\t\t\t\t\t\tfragmentErrors\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} else if ( programLog !== '' ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_completeCompile( renderObject, pipeline ) {\n\n\t\tconst { state, gl } = this;\n\t\tconst pipelineData = this.get( pipeline );\n\t\tconst { programGPU, fragmentShader, vertexShader } = pipelineData;\n\n\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\t\t\tthis._logProgramError( programGPU, fragmentShader, vertexShader );\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\t// Bindings\n\n\t\tconst bindings = renderObject.getBindings();\n\n\t\tthis._setupBindings( bindings, programGPU );\n\n\t\t//\n\n\t\tthis.set( pipeline, {\n\t\t\tprogramGPU\n\t\t} );\n\n\t}\n\n\tcreateComputePipeline( computePipeline, bindings ) {\n\n\t\tconst { state, gl } = this;\n\n\t\t// Program\n\n\t\tconst fragmentProgram = {\n\t\t\tstage: 'fragment',\n\t\t\tcode: '#version 300 es\\nprecision highp float;\\nvoid main() {}'\n\t\t};\n\n\t\tthis.createProgram( fragmentProgram );\n\n\t\tconst { computeProgram } = computePipeline;\n\n\t\tconst programGPU = gl.createProgram();\n\n\t\tconst fragmentShader = this.get( fragmentProgram ).shaderGPU;\n\t\tconst vertexShader = this.get( computeProgram ).shaderGPU;\n\n\t\tconst transforms = computeProgram.transforms;\n\n\t\tconst transformVaryingNames = [];\n\t\tconst transformAttributeNodes = [];\n\n\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\tconst transform = transforms[ i ];\n\n\t\t\ttransformVaryingNames.push( transform.varyingName );\n\t\t\ttransformAttributeNodes.push( transform.attributeNode );\n\n\t\t}\n\n\t\tgl.attachShader( programGPU, fragmentShader );\n\t\tgl.attachShader( programGPU, vertexShader );\n\n\t\tgl.transformFeedbackVaryings(\n\t\t\tprogramGPU,\n\t\t\ttransformVaryingNames,\n\t\t\tgl.SEPARATE_ATTRIBS\n\t\t);\n\n\t\tgl.linkProgram( programGPU );\n\n\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\t\t\tthis._logProgramError( programGPU, fragmentShader, vertexShader );\n\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\t// Bindings\n\n\t\tthis._setupBindings( bindings, programGPU );\n\n\t\tconst attributeNodes = computeProgram.attributes;\n\t\tconst attributes = [];\n\t\tconst transformBuffers = [];\n\n\t\tfor ( let i = 0; i < attributeNodes.length; i ++ ) {\n\n\t\t\tconst attribute = attributeNodes[ i ].node.attribute;\n\n\t\t\tattributes.push( attribute );\n\n\t\t\tif ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < transformAttributeNodes.length; i ++ ) {\n\n\t\t\tconst attribute = transformAttributeNodes[ i ].attribute;\n\n\t\t\tif ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t\t\tconst attributeData = this.get( attribute );\n\n\t\t\ttransformBuffers.push( attributeData );\n\n\t\t}\n\n\t\t//\n\n\t\tthis.set( computePipeline, {\n\t\t\tprogramGPU,\n\t\t\ttransformBuffers,\n\t\t\tattributes\n\t\t} );\n\n\t}\n\n\tcreateBindings( bindGroup, bindings ) {\n\n\t\tif ( this._knownBindings.has( bindings ) === false ) {\n\n\t\t\tthis._knownBindings.add( bindings );\n\n\t\t\tlet uniformBuffers = 0;\n\t\t\tlet textures = 0;\n\n\t\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\t\tthis.set( bindGroup, {\n\t\t\t\t\ttextures: textures,\n\t\t\t\t\tuniformBuffers: uniformBuffers\n\t\t\t\t} );\n\n\t\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\t\tif ( binding.isUniformBuffer ) uniformBuffers ++;\n\t\t\t\t\tif ( binding.isSampledTexture ) textures ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.updateBindings( bindGroup, bindings );\n\n\t}\n\n\tupdateBindings( bindGroup /*, bindings*/ ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst bindGroupData = this.get( bindGroup );\n\n\t\tlet i = bindGroupData.uniformBuffers;\n\t\tlet t = bindGroupData.textures;\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\tconst data = binding.buffer;\n\t\t\t\tconst bufferGPU = gl.createBuffer();\n\n\t\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );\n\n\t\t\t\tthis.set( binding, {\n\t\t\t\t\tindex: i ++,\n\t\t\t\t\tbufferGPU\n\t\t\t\t} );\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst { textureGPU, glTextureType } = this.get( binding.texture );\n\n\t\t\t\tthis.set( binding, {\n\t\t\t\t\tindex: t ++,\n\t\t\t\t\ttextureGPU,\n\t\t\t\t\tglTextureType\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateBinding( binding ) {\n\n\t\tconst gl = this.gl;\n\n\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\tconst bindingData = this.get( binding );\n\t\t\tconst bufferGPU = bindingData.bufferGPU;\n\t\t\tconst data = binding.buffer;\n\n\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );\n\n\t\t}\n\n\t}\n\n\t// attributes\n\n\tcreateIndexAttribute( attribute ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t}\n\n\tcreateAttribute( attribute ) {\n\n\t\tif ( this.has( attribute ) ) return;\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t}\n\n\tcreateStorageAttribute( attribute ) {\n\n\t\tif ( this.has( attribute ) ) return;\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t}\n\n\tupdateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.updateAttribute( attribute );\n\n\t}\n\n\tdestroyAttribute( attribute ) {\n\n\t\tthis.attributeUtils.destroyAttribute( attribute );\n\n\t}\n\n\tupdateSize() {\n\n\t\t//console.warn( 'Abstract class.' );\n\n\t}\n\n\thasFeature( name ) {\n\n\t\tconst keysMatching = Object.keys( GLFeatureName ).filter( key => GLFeatureName[ key ] === name );\n\n\t\tconst extensions = this.extensions;\n\n\t\tfor ( let i = 0; i < keysMatching.length; i ++ ) {\n\n\t\t\tif ( extensions.has( keysMatching[ i ] ) ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetMaxAnisotropy() {\n\n\t\treturn this.capabilities.getMaxAnisotropy();\n\n\t}\n\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level ) {\n\n\t\tthis.textureUtils.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );\n\n\t}\n\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tthis.textureUtils.copyFramebufferToTexture( texture, renderContext, rectangle );\n\n\t}\n\n\t_setFramebuffer( descriptor ) {\n\n\t\tconst { gl, state } = this;\n\n\t\tlet currentFrameBuffer = null;\n\n\t\tif ( descriptor.textures !== null ) {\n\n\t\t\tconst renderTarget = descriptor.renderTarget;\n\t\t\tconst renderTargetContextData = this.get( renderTarget );\n\t\t\tconst { samples, depthBuffer, stencilBuffer } = renderTarget;\n\n\t\t\tconst isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\n\t\t\tlet msaaFb = renderTargetContextData.msaaFrameBuffer;\n\t\t\tlet depthRenderbuffer = renderTargetContextData.depthRenderbuffer;\n\n\t\t\tconst cacheKey = getCacheKey( descriptor );\n\n\t\t\tlet fb;\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetContextData.cubeFramebuffers || ( renderTargetContextData.cubeFramebuffers = {} );\n\n\t\t\t\tfb = renderTargetContextData.cubeFramebuffers[ cacheKey ];\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetContextData.framebuffers || ( renderTargetContextData.framebuffers = {} );\n\n\t\t\t\tfb = renderTargetContextData.framebuffers[ cacheKey ];\n\n\t\t\t}\n\n\t\t\tif ( fb === undefined ) {\n\n\t\t\t\tfb = gl.createFramebuffer();\n\n\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, fb );\n\n\t\t\t\tconst textures = descriptor.textures;\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\trenderTargetContextData.cubeFramebuffers[ cacheKey ] = fb;\n\n\t\t\t\t\tconst { textureGPU } = this.get( textures[ 0 ] );\n\n\t\t\t\t\tconst cubeFace = this.renderer._activeCubeFace;\n\n\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderTargetContextData.framebuffers[ cacheKey ] = fb;\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\tconst textureData = this.get( texture );\n\t\t\t\t\t\ttextureData.renderTarget = descriptor.renderTarget;\n\t\t\t\t\t\ttextureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n\t\t\t\t\t\tconst attachment = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.drawBuffers( descriptor, fb );\n\n\t\t\t\t}\n\n\t\t\t\tif ( descriptor.depthTexture !== null ) {\n\n\t\t\t\t\tconst textureData = this.get( descriptor.depthTexture );\n\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\ttextureData.renderTarget = descriptor.renderTarget;\n\t\t\t\t\ttextureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tif ( msaaFb === undefined ) {\n\n\t\t\t\t\tconst invalidationArray = [];\n\n\t\t\t\t\tmsaaFb = gl.createFramebuffer();\n\n\t\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, msaaFb );\n\n\t\t\t\t\tconst msaaRenderbuffers = [];\n\n\t\t\t\t\tconst textures = descriptor.textures;\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tmsaaRenderbuffers[ i ] = gl.createRenderbuffer();\n\n\t\t\t\t\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\n\t\t\t\t\t\tinvalidationArray.push( gl.COLOR_ATTACHMENT0 + i );\n\n\t\t\t\t\t\tif ( depthBuffer ) {\n\n\t\t\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\t\t\tinvalidationArray.push( depthStyle );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst texture = descriptor.textures[ i ];\n\t\t\t\t\t\tconst textureData = this.get( texture );\n\n\t\t\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height );\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderTargetContextData.msaaFrameBuffer = msaaFb;\n\t\t\t\t\trenderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;\n\n\t\t\t\t\tif ( depthRenderbuffer === undefined ) {\n\n\t\t\t\t\t\tdepthRenderbuffer = gl.createRenderbuffer();\n\t\t\t\t\t\tthis.textureUtils.setupRenderBufferStorage( depthRenderbuffer, descriptor );\n\n\t\t\t\t\t\trenderTargetContextData.depthRenderbuffer = depthRenderbuffer;\n\n\t\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\t\tinvalidationArray.push( depthStyle );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderTargetContextData.invalidationArray = invalidationArray;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t} else {\n\n\t\t\t\tcurrentFrameBuffer = fb;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, currentFrameBuffer );\n\n\t}\n\n\n\t_getVaoKey( index, attributes ) {\n\n\t\tlet key = [];\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst indexData = this.get( index );\n\n\t\t\tkey += ':' + indexData.id;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\n\n\t\t\tconst attributeData = this.get( attributes[ i ] );\n\n\t\t\tkey += ':' + attributeData.id;\n\n\t\t}\n\n\t\treturn key;\n\n\t}\n\n\t_createVao( index, attributes ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst vaoGPU = gl.createVertexArray();\n\t\tlet key = '';\n\n\t\tlet staticVao = true;\n\n\t\tgl.bindVertexArray( vaoGPU );\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst indexData = this.get( index );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, indexData.bufferGPU );\n\n\t\t\tkey += ':' + indexData.id;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\n\n\t\t\tconst attribute = attributes[ i ];\n\t\t\tconst attributeData = this.get( attribute );\n\n\t\t\tkey += ':' + attributeData.id;\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, attributeData.bufferGPU );\n\t\t\tgl.enableVertexAttribArray( i );\n\n\t\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) staticVao = false;\n\n\t\t\tlet stride, offset;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute === true ) {\n\n\t\t\t\tstride = attribute.data.stride * attributeData.bytesPerElement;\n\t\t\t\toffset = attribute.offset * attributeData.bytesPerElement;\n\n\t\t\t} else {\n\n\t\t\t\tstride = 0;\n\t\t\t\toffset = 0;\n\n\t\t\t}\n\n\t\t\tif ( attributeData.isInteger ) {\n\n\t\t\t\tgl.vertexAttribIPointer( i, attribute.itemSize, attributeData.type, stride, offset );\n\n\t\t\t} else {\n\n\t\t\t\tgl.vertexAttribPointer( i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset );\n\n\t\t\t}\n\n\t\t\tif ( attribute.isInstancedBufferAttribute && ! attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tgl.vertexAttribDivisor( i, attribute.meshPerAttribute );\n\n\t\t\t} else if ( attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\tgl.vertexAttribDivisor( i, attribute.data.meshPerAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, null );\n\n\t\tthis.vaoCache[ key ] = vaoGPU;\n\n\t\treturn { vaoGPU, staticVao };\n\n\t}\n\n\t_getTransformFeedback( transformBuffers ) {\n\n\t\tlet key = '';\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tkey += ':' + transformBuffers[ i ].id;\n\n\t\t}\n\n\t\tlet transformFeedbackGPU = this.transformFeedbackCache[ key ];\n\n\t\tif ( transformFeedbackGPU !== undefined ) {\n\n\t\t\treturn transformFeedbackGPU;\n\n\t\t}\n\n\t\tconst { gl } = this;\n\n\t\ttransformFeedbackGPU = gl.createTransformFeedback();\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tconst attributeData = transformBuffers[ i ];\n\n\t\t\tgl.bindBufferBase( gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer );\n\n\t\t}\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );\n\n\t\tthis.transformFeedbackCache[ key ] = transformFeedbackGPU;\n\n\t\treturn transformFeedbackGPU;\n\n\t}\n\n\n\t_setupBindings( bindings, programGPU ) {\n\n\t\tconst gl = this.gl;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\tconst bindingData = this.get( binding );\n\t\t\t\tconst index = bindingData.index;\n\n\t\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\t\tconst location = gl.getUniformBlockIndex( programGPU, binding.name );\n\t\t\t\t\tgl.uniformBlockBinding( programGPU, location, index );\n\n\t\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\t\tconst location = gl.getUniformLocation( programGPU, binding.name );\n\t\t\t\t\tgl.uniform1i( location, index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_bindUniforms( bindings ) {\n\n\t\tconst { gl, state } = this;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\tconst bindingData = this.get( binding );\n\t\t\t\tconst index = bindingData.index;\n\n\t\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\t\t// TODO USE bindBufferRange to group multiple uniform buffers\n\t\t\t\t\tstate.bindBufferBase( gl.UNIFORM_BUFFER, index, bindingData.bufferGPU );\n\n\t\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\t\tstate.bindTexture( bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.renderer.domElement.removeEventListener( 'webglcontextlost', this._onContextLost );\n\n\t}\n\n}\n\nconst GPUPrimitiveTopology = {\n\tPointList: 'point-list',\n\tLineList: 'line-list',\n\tLineStrip: 'line-strip',\n\tTriangleList: 'triangle-list',\n\tTriangleStrip: 'triangle-strip',\n};\n\nconst GPUCompareFunction = {\n\tNever: 'never',\n\tLess: 'less',\n\tEqual: 'equal',\n\tLessEqual: 'less-equal',\n\tGreater: 'greater',\n\tNotEqual: 'not-equal',\n\tGreaterEqual: 'greater-equal',\n\tAlways: 'always'\n};\n\nconst GPUStoreOp = {\n\tStore: 'store',\n\tDiscard: 'discard'\n};\n\nconst GPULoadOp = {\n\tLoad: 'load',\n\tClear: 'clear'\n};\n\nconst GPUFrontFace = {\n\tCCW: 'ccw',\n\tCW: 'cw'\n};\n\nconst GPUCullMode = {\n\tNone: 'none',\n\tFront: 'front',\n\tBack: 'back'\n};\n\nconst GPUIndexFormat = {\n\tUint16: 'uint16',\n\tUint32: 'uint32'\n};\n\nconst GPUTextureFormat = {\n\n\t// 8-bit formats\n\n\tR8Unorm: 'r8unorm',\n\tR8Snorm: 'r8snorm',\n\tR8Uint: 'r8uint',\n\tR8Sint: 'r8sint',\n\n\t// 16-bit formats\n\n\tR16Uint: 'r16uint',\n\tR16Sint: 'r16sint',\n\tR16Float: 'r16float',\n\tRG8Unorm: 'rg8unorm',\n\tRG8Snorm: 'rg8snorm',\n\tRG8Uint: 'rg8uint',\n\tRG8Sint: 'rg8sint',\n\n\t// 32-bit formats\n\n\tR32Uint: 'r32uint',\n\tR32Sint: 'r32sint',\n\tR32Float: 'r32float',\n\tRG16Uint: 'rg16uint',\n\tRG16Sint: 'rg16sint',\n\tRG16Float: 'rg16float',\n\tRGBA8Unorm: 'rgba8unorm',\n\tRGBA8UnormSRGB: 'rgba8unorm-srgb',\n\tRGBA8Snorm: 'rgba8snorm',\n\tRGBA8Uint: 'rgba8uint',\n\tRGBA8Sint: 'rgba8sint',\n\tBGRA8Unorm: 'bgra8unorm',\n\tBGRA8UnormSRGB: 'bgra8unorm-srgb',\n\t// Packed 32-bit formats\n\tRGB9E5UFloat: 'rgb9e5ufloat',\n\tRGB10A2Unorm: 'rgb10a2unorm',\n\tRG11B10uFloat: 'rgb10a2unorm',\n\n\t// 64-bit formats\n\n\tRG32Uint: 'rg32uint',\n\tRG32Sint: 'rg32sint',\n\tRG32Float: 'rg32float',\n\tRGBA16Uint: 'rgba16uint',\n\tRGBA16Sint: 'rgba16sint',\n\tRGBA16Float: 'rgba16float',\n\n\t// 128-bit formats\n\n\tRGBA32Uint: 'rgba32uint',\n\tRGBA32Sint: 'rgba32sint',\n\tRGBA32Float: 'rgba32float',\n\n\t// Depth and stencil formats\n\n\tStencil8: 'stencil8',\n\tDepth16Unorm: 'depth16unorm',\n\tDepth24Plus: 'depth24plus',\n\tDepth24PlusStencil8: 'depth24plus-stencil8',\n\tDepth32Float: 'depth32float',\n\n\t// 'depth32float-stencil8' extension\n\n\tDepth32FloatStencil8: 'depth32float-stencil8',\n\n\t// BC compressed formats usable if 'texture-compression-bc' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tBC1RGBAUnorm: 'bc1-rgba-unorm',\n\tBC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',\n\tBC2RGBAUnorm: 'bc2-rgba-unorm',\n\tBC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',\n\tBC3RGBAUnorm: 'bc3-rgba-unorm',\n\tBC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',\n\tBC4RUnorm: 'bc4-r-unorm',\n\tBC4RSnorm: 'bc4-r-snorm',\n\tBC5RGUnorm: 'bc5-rg-unorm',\n\tBC5RGSnorm: 'bc5-rg-snorm',\n\tBC6HRGBUFloat: 'bc6h-rgb-ufloat',\n\tBC6HRGBFloat: 'bc6h-rgb-float',\n\tBC7RGBAUnorm: 'bc7-rgba-unorm',\n\tBC7RGBAUnormSRGB: 'bc7-rgba-srgb',\n\n\t// ETC2 compressed formats usable if 'texture-compression-etc2' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tETC2RGB8Unorm: 'etc2-rgb8unorm',\n\tETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',\n\tETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',\n\tETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',\n\tETC2RGBA8Unorm: 'etc2-rgba8unorm',\n\tETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',\n\tEACR11Unorm: 'eac-r11unorm',\n\tEACR11Snorm: 'eac-r11snorm',\n\tEACRG11Unorm: 'eac-rg11unorm',\n\tEACRG11Snorm: 'eac-rg11snorm',\n\n\t// ASTC compressed formats usable if 'texture-compression-astc' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tASTC4x4Unorm: 'astc-4x4-unorm',\n\tASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',\n\tASTC5x4Unorm: 'astc-5x4-unorm',\n\tASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',\n\tASTC5x5Unorm: 'astc-5x5-unorm',\n\tASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',\n\tASTC6x5Unorm: 'astc-6x5-unorm',\n\tASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',\n\tASTC6x6Unorm: 'astc-6x6-unorm',\n\tASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',\n\tASTC8x5Unorm: 'astc-8x5-unorm',\n\tASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',\n\tASTC8x6Unorm: 'astc-8x6-unorm',\n\tASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',\n\tASTC8x8Unorm: 'astc-8x8-unorm',\n\tASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',\n\tASTC10x5Unorm: 'astc-10x5-unorm',\n\tASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',\n\tASTC10x6Unorm: 'astc-10x6-unorm',\n\tASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',\n\tASTC10x8Unorm: 'astc-10x8-unorm',\n\tASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',\n\tASTC10x10Unorm: 'astc-10x10-unorm',\n\tASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',\n\tASTC12x10Unorm: 'astc-12x10-unorm',\n\tASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',\n\tASTC12x12Unorm: 'astc-12x12-unorm',\n\tASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb',\n\n};\n\nconst GPUAddressMode = {\n\tClampToEdge: 'clamp-to-edge',\n\tRepeat: 'repeat',\n\tMirrorRepeat: 'mirror-repeat'\n};\n\nconst GPUFilterMode = {\n\tLinear: 'linear',\n\tNearest: 'nearest'\n};\n\nconst GPUBlendFactor = {\n\tZero: 'zero',\n\tOne: 'one',\n\tSrc: 'src',\n\tOneMinusSrc: 'one-minus-src',\n\tSrcAlpha: 'src-alpha',\n\tOneMinusSrcAlpha: 'one-minus-src-alpha',\n\tDst: 'dst',\n\tOneMinusDstColor: 'one-minus-dst',\n\tDstAlpha: 'dst-alpha',\n\tOneMinusDstAlpha: 'one-minus-dst-alpha',\n\tSrcAlphaSaturated: 'src-alpha-saturated',\n\tConstant: 'constant',\n\tOneMinusConstant: 'one-minus-constant'\n};\n\nconst GPUBlendOperation = {\n\tAdd: 'add',\n\tSubtract: 'subtract',\n\tReverseSubtract: 'reverse-subtract',\n\tMin: 'min',\n\tMax: 'max'\n};\n\nconst GPUColorWriteFlags = {\n\tNone: 0,\n\tRed: 0x1,\n\tGreen: 0x2,\n\tBlue: 0x4,\n\tAlpha: 0x8,\n\tAll: 0xF\n};\n\nconst GPUStencilOperation = {\n\tKeep: 'keep',\n\tZero: 'zero',\n\tReplace: 'replace',\n\tInvert: 'invert',\n\tIncrementClamp: 'increment-clamp',\n\tDecrementClamp: 'decrement-clamp',\n\tIncrementWrap: 'increment-wrap',\n\tDecrementWrap: 'decrement-wrap'\n};\n\nconst GPUBufferBindingType = {\n\tUniform: 'uniform',\n\tStorage: 'storage',\n\tReadOnlyStorage: 'read-only-storage'\n};\n\nconst GPUStorageTextureAccess = {\n\tWriteOnly: 'write-only',\n\tReadOnly: 'read-only',\n\tReadWrite: 'read-write',\n};\n\nconst GPUTextureSampleType = {\n\tFloat: 'float',\n\tUnfilterableFloat: 'unfilterable-float',\n\tDepth: 'depth',\n\tSInt: 'sint',\n\tUInt: 'uint'\n};\n\nconst GPUTextureDimension = {\n\tOneD: '1d',\n\tTwoD: '2d',\n\tThreeD: '3d'\n};\n\nconst GPUTextureViewDimension = {\n\tOneD: '1d',\n\tTwoD: '2d',\n\tTwoDArray: '2d-array',\n\tCube: 'cube',\n\tCubeArray: 'cube-array',\n\tThreeD: '3d'\n};\n\nconst GPUTextureAspect = {\n\tAll: 'all',\n\tStencilOnly: 'stencil-only',\n\tDepthOnly: 'depth-only'\n};\n\nconst GPUInputStepMode = {\n\tVertex: 'vertex',\n\tInstance: 'instance'\n};\n\nconst GPUFeatureName = {\n\tDepthClipControl: 'depth-clip-control',\n\tDepth32FloatStencil8: 'depth32float-stencil8',\n\tTextureCompressionBC: 'texture-compression-bc',\n\tTextureCompressionETC2: 'texture-compression-etc2',\n\tTextureCompressionASTC: 'texture-compression-astc',\n\tTimestampQuery: 'timestamp-query',\n\tIndirectFirstInstance: 'indirect-first-instance',\n\tShaderF16: 'shader-f16',\n\tRG11B10UFloat: 'rg11b10ufloat-renderable',\n\tBGRA8UNormStorage: 'bgra8unorm-storage',\n\tFloat32Filterable: 'float32-filterable',\n\tClipDistances: 'clip-distances',\n\tDualSourceBlending: 'dual-source-blending',\n\tSubgroups: 'subgroups'\n};\n\nclass Sampler extends Binding {\n\n\tconstructor( name, texture ) {\n\n\t\tsuper( name );\n\n\t\tthis.texture = texture;\n\t\tthis.version = texture ? texture.version : 0;\n\n\t\tthis.isSampler = true;\n\n\t}\n\n}\n\nclass NodeSampler extends Sampler {\n\n\tconstructor( name, textureNode, groupNode ) {\n\n\t\tsuper( name, textureNode ? textureNode.value : null );\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\tupdate() {\n\n\t\tthis.texture = this.textureNode.value;\n\n\t}\n\n}\n\nclass StorageBuffer extends Buffer {\n\n\tconstructor( name, attribute ) {\n\n\t\tsuper( name, attribute ? attribute.array : null );\n\n\t\tthis.attribute = attribute;\n\n\t\tthis.isStorageBuffer = true;\n\n\t}\n\n}\n\nlet _id = 0;\n\nclass NodeStorageBuffer extends StorageBuffer {\n\n\tconstructor( nodeUniform, groupNode ) {\n\n\t\tsuper( 'StorageBuffer_' + _id ++, nodeUniform ? nodeUniform.value : null );\n\n\t\tthis.nodeUniform = nodeUniform;\n\t\tthis.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\tget buffer() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n}\n\nclass WebGPUTexturePassUtils extends DataMap {\n\n\tconstructor( device ) {\n\n\t\tsuper();\n\n\t\tthis.device = device;\n\n\t\tconst mipmapVertexSource = `\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n`;\n\n\t\tconst mipmapFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n`;\n\n\t\tconst flipYFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );\n\n}\n`;\n\t\tthis.mipmapSampler = device.createSampler( { minFilter: GPUFilterMode.Linear } );\n\t\tthis.flipYSampler = device.createSampler( { minFilter: GPUFilterMode.Nearest } ); //@TODO?: Consider using textureLoad()\n\n\t\t// We'll need a new pipeline for every texture format used.\n\t\tthis.transferPipelines = {};\n\t\tthis.flipYPipelines = {};\n\n\t\tthis.mipmapVertexShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'mipmapVertex',\n\t\t\tcode: mipmapVertexSource\n\t\t} );\n\n\t\tthis.mipmapFragmentShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'mipmapFragment',\n\t\t\tcode: mipmapFragmentSource\n\t\t} );\n\n\t\tthis.flipYFragmentShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'flipYFragment',\n\t\t\tcode: flipYFragmentSource\n\t\t} );\n\n\t}\n\n\tgetTransferPipeline( format ) {\n\n\t\tlet pipeline = this.transferPipelines[ format ];\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = this.device.createRenderPipeline( {\n\t\t\t\tlabel: `mipmap-${ format }`,\n\t\t\t\tvertex: {\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\n\t\t\t\t\tentryPoint: 'main'\n\t\t\t\t},\n\t\t\t\tfragment: {\n\t\t\t\t\tmodule: this.mipmapFragmentShaderModule,\n\t\t\t\t\tentryPoint: 'main',\n\t\t\t\t\ttargets: [ { format } ]\n\t\t\t\t},\n\t\t\t\tprimitive: {\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\n\t\t\t\t},\n\t\t\t\tlayout: 'auto'\n\t\t\t} );\n\n\t\t\tthis.transferPipelines[ format ] = pipeline;\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\tgetFlipYPipeline( format ) {\n\n\t\tlet pipeline = this.flipYPipelines[ format ];\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = this.device.createRenderPipeline( {\n\t\t\t\tlabel: `flipY-${ format }`,\n\t\t\t\tvertex: {\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\n\t\t\t\t\tentryPoint: 'main'\n\t\t\t\t},\n\t\t\t\tfragment: {\n\t\t\t\t\tmodule: this.flipYFragmentShaderModule,\n\t\t\t\t\tentryPoint: 'main',\n\t\t\t\t\ttargets: [ { format } ]\n\t\t\t\t},\n\t\t\t\tprimitive: {\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\n\t\t\t\t},\n\t\t\t\tlayout: 'auto'\n\t\t\t} );\n\n\t\t\tthis.flipYPipelines[ format ] = pipeline;\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\tflipY( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {\n\n\t\tconst format = textureGPUDescriptor.format;\n\t\tconst { width, height } = textureGPUDescriptor.size;\n\n\t\tconst transferPipeline = this.getTransferPipeline( format );\n\t\tconst flipYPipeline = this.getFlipYPipeline( format );\n\n\t\tconst tempTexture = this.device.createTexture( {\n\t\t\tsize: { width, height, depthOrArrayLayers: 1 },\n\t\t\tformat,\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n\t\t} );\n\n\t\tconst srcView = textureGPU.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer\n\t\t} );\n\n\t\tconst dstView = tempTexture.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer: 0\n\t\t} );\n\n\t\tconst commandEncoder = this.device.createCommandEncoder( {} );\n\n\t\tconst pass = ( pipeline, sourceView, destinationView ) => {\n\n\t\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\n\n\t\t\tconst bindGroup = this.device.createBindGroup( {\n\t\t\t\tlayout: bindGroupLayout,\n\t\t\t\tentries: [ {\n\t\t\t\t\tbinding: 0,\n\t\t\t\t\tresource: this.flipYSampler\n\t\t\t\t}, {\n\t\t\t\t\tbinding: 1,\n\t\t\t\t\tresource: sourceView\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: destinationView,\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tpassEncoder.setPipeline( pipeline );\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\n\t\t\tpassEncoder.end();\n\n\t\t};\n\n\t\tpass( transferPipeline, srcView, dstView );\n\t\tpass( flipYPipeline, dstView, srcView );\n\n\t\tthis.device.queue.submit( [ commandEncoder.finish() ] );\n\n\t\ttempTexture.destroy();\n\n\t}\n\n\tgenerateMipmaps( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {\n\n\t\tconst textureData = this.get( textureGPU );\n\n\t\tif ( textureData.useCount === undefined ) {\n\n\t\t\ttextureData.useCount = 0;\n\t\t\ttextureData.layers = [];\n\n\t\t}\n\n\t\tconst passes = textureData.layers[ baseArrayLayer ] || this._mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer );\n\n\t\tconst commandEncoder = this.device.createCommandEncoder( {} );\n\n\t\tthis._mipmapRunBundles( commandEncoder, passes );\n\n\t\tthis.device.queue.submit( [ commandEncoder.finish() ] );\n\n\t\tif ( textureData.useCount !== 0 ) textureData.layers[ baseArrayLayer ] = passes;\n\n\t\ttextureData.useCount ++;\n\n\t}\n\n\t_mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer ) {\n\n\t\tconst pipeline = this.getTransferPipeline( textureGPUDescriptor.format );\n\n\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\n\n\t\tlet srcView = textureGPU.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer\n\t\t} );\n\n\t\tconst passes = [];\n\n\t\tfor ( let i = 1; i < textureGPUDescriptor.mipLevelCount; i ++ ) {\n\n\t\t\tconst bindGroup = this.device.createBindGroup( {\n\t\t\t\tlayout: bindGroupLayout,\n\t\t\t\tentries: [ {\n\t\t\t\t\tbinding: 0,\n\t\t\t\t\tresource: this.mipmapSampler\n\t\t\t\t}, {\n\t\t\t\t\tbinding: 1,\n\t\t\t\t\tresource: srcView\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tconst dstView = textureGPU.createView( {\n\t\t\t\tbaseMipLevel: i,\n\t\t\t\tmipLevelCount: 1,\n\t\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\t\tbaseArrayLayer\n\t\t\t} );\n\n\t\t\tconst passDescriptor = {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: dstView,\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\n\t\t\t\t} ]\n\t\t\t};\n\n\t\t\tconst passEncoder = this.device.createRenderBundleEncoder( {\n\t\t\t\tcolorFormats: [ textureGPUDescriptor.format ]\n\t\t\t} );\n\n\t\t\tpassEncoder.setPipeline( pipeline );\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\n\n\t\t\tpasses.push( {\n\t\t\t\trenderBundles: [ passEncoder.finish() ],\n\t\t\t\tpassDescriptor\n\t\t\t} );\n\n\t\t\tsrcView = dstView;\n\n\t\t}\n\n\t\treturn passes;\n\n\t}\n\n\t_mipmapRunBundles( commandEncoder, passes ) {\n\n\t\tconst levels = passes.length;\n\n\t\tfor ( let i = 0; i < levels; i ++ ) {\n\n\t\t\tconst pass = passes[ i ];\n\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( pass.passDescriptor );\n\n\t\t\tpassEncoder.executeBundles( pass.renderBundles );\n\n\t\t\tpassEncoder.end();\n\n\t\t}\n\n\t}\n\n}\n\nconst _compareToWebGPU = {\n\t[ NeverCompare ]: 'never',\n\t[ LessCompare ]: 'less',\n\t[ EqualCompare ]: 'equal',\n\t[ LessEqualCompare ]: 'less-equal',\n\t[ GreaterCompare ]: 'greater',\n\t[ GreaterEqualCompare ]: 'greater-equal',\n\t[ AlwaysCompare ]: 'always',\n\t[ NotEqualCompare ]: 'not-equal'\n};\n\nconst _flipMap = [ 0, 1, 3, 2, 4, 5 ];\n\nclass WebGPUTextureUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis._passUtils = null;\n\n\t\tthis.defaultTexture = {};\n\t\tthis.defaultCubeTexture = {};\n\t\tthis.defaultVideoFrame = null;\n\n\t\tthis.colorBuffer = null;\n\n\t\tthis.depthTexture = new DepthTexture();\n\t\tthis.depthTexture.name = 'depthBuffer';\n\n\t}\n\n\tcreateSampler( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst textureGPU = backend.get( texture );\n\n\t\tconst samplerDescriptorGPU = {\n\t\t\taddressModeU: this._convertAddressMode( texture.wrapS ),\n\t\t\taddressModeV: this._convertAddressMode( texture.wrapT ),\n\t\t\taddressModeW: this._convertAddressMode( texture.wrapR ),\n\t\t\tmagFilter: this._convertFilterMode( texture.magFilter ),\n\t\t\tminFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\tmipmapFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\tmaxAnisotropy: 1\n\t\t};\n\n\t\t// anisotropy can only be used when all filter modes are set to linear.\n\n\t\tif ( samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear ) {\n\n\t\t\tsamplerDescriptorGPU.maxAnisotropy = texture.anisotropy;\n\n\t\t}\n\n\t\tif ( texture.isDepthTexture && texture.compareFunction !== null ) {\n\n\t\t\tsamplerDescriptorGPU.compare = _compareToWebGPU[ texture.compareFunction ];\n\n\t\t}\n\n\t\ttextureGPU.sampler = device.createSampler( samplerDescriptorGPU );\n\n\t}\n\n\tcreateDefaultTexture( texture ) {\n\n\t\tlet textureGPU;\n\n\t\tconst format = getFormat( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\ttextureGPU = this._getDefaultCubeTextureGPU( format );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\tthis.backend.get( texture ).externalTexture = this._getDefaultVideoFrame();\n\n\t\t} else {\n\n\t\t\ttextureGPU = this._getDefaultTextureGPU( format );\n\n\t\t}\n\n\t\tthis.backend.get( texture ).texture = textureGPU;\n\n\t}\n\n\tcreateTexture( texture, options = {} ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.initialized ) {\n\n\t\t\tthrow new Error( 'WebGPUTextureUtils: Texture already initialized.' );\n\n\t\t}\n\n\t\tif ( options.needsMipmaps === undefined ) options.needsMipmaps = false;\n\t\tif ( options.levels === undefined ) options.levels = 1;\n\t\tif ( options.depth === undefined ) options.depth = 1;\n\n\t\tconst { width, height, depth, levels } = options;\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tif ( options.renderTarget ) {\n\n\t\t\t\toptions.format = this.backend.utils.getCurrentColorFormat( options.renderTarget );\n\n\t\t\t} else {\n\n\t\t\t\toptions.format = this.backend.utils.getPreferredCanvasFormat();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst dimension = this._getDimension( texture );\n\t\tconst format = texture.internalFormat || options.format || getFormat( texture, backend.device );\n\n\t\ttextureData.format = format;\n\n\t\tlet sampleCount = options.sampleCount !== undefined ? options.sampleCount : 1;\n\n\t\tsampleCount = backend.utils.getSampleCount( sampleCount );\n\n\t\tconst primarySampleCount = texture.isRenderTargetTexture && ! texture.isMultisampleRenderTargetTexture ? 1 : sampleCount;\n\n\t\tlet usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n\n\t\tif ( texture.isStorageTexture === true ) {\n\n\t\t\tusage |= GPUTextureUsage.STORAGE_BINDING;\n\n\t\t}\n\n\t\tif ( texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true ) {\n\n\t\t\tusage |= GPUTextureUsage.RENDER_ATTACHMENT;\n\n\t\t}\n\n\t\tconst textureDescriptorGPU = {\n\t\t\tlabel: texture.name,\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: depth,\n\t\t\t},\n\t\t\tmipLevelCount: levels,\n\t\t\tsampleCount: primarySampleCount,\n\t\t\tdimension: dimension,\n\t\t\tformat: format,\n\t\t\tusage: usage\n\t\t};\n\n\t\t// texture creation\n\n\t\tif ( texture.isVideoTexture ) {\n\n\t\t\tconst video = texture.source.data;\n\t\t\tconst videoFrame = new VideoFrame( video );\n\n\t\t\ttextureDescriptorGPU.size.width = videoFrame.displayWidth;\n\t\t\ttextureDescriptorGPU.size.height = videoFrame.displayHeight;\n\n\t\t\tvideoFrame.close();\n\n\t\t\ttextureData.externalTexture = video;\n\n\t\t} else {\n\n\t\t\tif ( format === undefined ) {\n\n\t\t\t\tconsole.warn( 'WebGPURenderer: Texture format not supported.' );\n\n\t\t\t\treturn this.createDefaultTexture( texture );\n\n\t\t\t}\n\n\t\t\ttextureData.texture = backend.device.createTexture( textureDescriptorGPU );\n\n\t\t}\n\n\t\tif ( texture.isRenderTargetTexture && sampleCount > 1 && ! texture.isMultisampleRenderTargetTexture ) {\n\n\t\t\tconst msaaTextureDescriptorGPU = Object.assign( {}, textureDescriptorGPU );\n\n\t\t\tmsaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';\n\t\t\tmsaaTextureDescriptorGPU.sampleCount = sampleCount;\n\n\t\t\ttextureData.msaaTexture = backend.device.createTexture( msaaTextureDescriptorGPU );\n\n\t\t}\n\n\t\ttextureData.initialized = true;\n\n\t\ttextureData.textureDescriptorGPU = textureDescriptorGPU;\n\n\t}\n\n\tdestroyTexture( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.texture !== undefined ) textureData.texture.destroy();\n\n\t\tif ( textureData.msaaTexture !== undefined ) textureData.msaaTexture.destroy();\n\n\t\tbackend.delete( texture );\n\n\t}\n\n\tdestroySampler( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tdelete textureData.sampler;\n\n\t}\n\n\tgenerateMipmaps( texture ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst depth = texture.image.depth || 1;\n\n\t\t\tfor ( let i = 0; i < depth; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetColorBuffer() {\n\n\t\tif ( this.colorBuffer ) this.colorBuffer.destroy();\n\n\t\tconst backend = this.backend;\n\t\tconst { width, height } = backend.getDrawingBufferSize();\n\n\t\tthis.colorBuffer = backend.device.createTexture( {\n\t\t\tlabel: 'colorBuffer',\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t},\n\t\t\tsampleCount: backend.utils.getSampleCount( backend.renderer.samples ),\n\t\t\tformat: backend.utils.getPreferredCanvasFormat(),\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n\t\t} );\n\n\t\treturn this.colorBuffer;\n\n\t}\n\n\tgetDepthBuffer( depth = true, stencil = false ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { width, height } = backend.getDrawingBufferSize();\n\n\t\tconst depthTexture = this.depthTexture;\n\t\tconst depthTextureGPU = backend.get( depthTexture ).texture;\n\n\t\tlet format, type;\n\n\t\tif ( stencil ) {\n\n\t\t\tformat = DepthStencilFormat;\n\t\t\ttype = UnsignedInt248Type;\n\n\t\t} else if ( depth ) {\n\n\t\t\tformat = DepthFormat;\n\t\t\ttype = UnsignedIntType;\n\n\t\t}\n\n\t\tif ( depthTextureGPU !== undefined ) {\n\n\t\t\tif ( depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type ) {\n\n\t\t\t\treturn depthTextureGPU;\n\n\t\t\t}\n\n\t\t\tthis.destroyTexture( depthTexture );\n\n\t\t}\n\n\t\tdepthTexture.name = 'depthBuffer';\n\t\tdepthTexture.format = format;\n\t\tdepthTexture.type = type;\n\t\tdepthTexture.image.width = width;\n\t\tdepthTexture.image.height = height;\n\n\t\tthis.createTexture( depthTexture, { sampleCount: backend.utils.getSampleCount( backend.renderer.samples ), width, height } );\n\n\t\treturn backend.get( depthTexture ).texture;\n\n\t}\n\n\tupdateTexture( texture, options ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tconst { textureDescriptorGPU } = textureData;\n\n\t\tif ( texture.isRenderTargetTexture || ( textureDescriptorGPU === undefined /* unsupported texture format */ ) )\n\t\t\treturn;\n\n\t\t// transfer texture data\n\n\t\tif ( texture.isDataTexture ) {\n\n\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );\n\n\t\t} else if ( texture.isDataArrayTexture || texture.isData3DTexture ) {\n\n\t\t\tfor ( let i = 0; i < options.image.depth; i ++ ) {\n\n\t\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i );\n\n\t\t\t}\n\n\t\t} else if ( texture.isCompressedTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\tthis._copyCompressedBufferToTexture( texture.mipmaps, textureData.texture, textureDescriptorGPU );\n\n\t\t} else if ( texture.isCubeTexture ) {\n\n\t\t\tthis._copyCubeMapToTexture( options.images, textureData.texture, textureDescriptorGPU, texture.flipY );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\tconst video = texture.source.data;\n\n\t\t\ttextureData.externalTexture = video;\n\n\t\t} else {\n\n\t\t\tthis._copyImageToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );\n\n\t\t}\n\n\t\t//\n\n\t\ttextureData.version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tconst textureData = this.backend.get( texture );\n\t\tconst textureGPU = textureData.texture;\n\t\tconst format = textureData.textureDescriptorGPU.format;\n\t\tconst bytesPerTexel = this._getBytesPerTexel( format );\n\n\t\tlet bytesPerRow = width * bytesPerTexel;\n\t\tbytesPerRow = Math.ceil( bytesPerRow / 256 ) * 256; // Align to 256 bytes\n\n\t\tconst readBuffer = device.createBuffer(\n\t\t\t{\n\t\t\t\tsize: width * height * bytesPerTexel,\n\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t}\n\t\t);\n\n\t\tconst encoder = device.createCommandEncoder();\n\n\t\tencoder.copyTextureToBuffer(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\torigin: { x, y, z: faceIndex },\n\t\t\t},\n\t\t\t{\n\t\t\t\tbuffer: readBuffer,\n\t\t\t\tbytesPerRow: bytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t}\n\n\t\t);\n\n\t\tconst typedArrayType = this._getTypedArrayType( format );\n\n\t\tdevice.queue.submit( [ encoder.finish() ] );\n\n\t\tawait readBuffer.mapAsync( GPUMapMode.READ );\n\n\t\tconst buffer = readBuffer.getMappedRange();\n\n\t\treturn new typedArrayType( buffer );\n\n\t}\n\n\t_isEnvironmentTexture( texture ) {\n\n\t\tconst mapping = texture.mapping;\n\n\t\treturn ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\n\n\t}\n\n\t_getDefaultTextureGPU( format ) {\n\n\t\tlet defaultTexture = this.defaultTexture[ format ];\n\n\t\tif ( defaultTexture === undefined ) {\n\n\t\t\tconst texture = new Texture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, format } );\n\n\t\t\tthis.defaultTexture[ format ] = defaultTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultTexture ).texture;\n\n\t}\n\n\t_getDefaultCubeTextureGPU( format ) {\n\n\t\tlet defaultCubeTexture = this.defaultTexture[ format ];\n\n\t\tif ( defaultCubeTexture === undefined ) {\n\n\t\t\tconst texture = new CubeTexture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, depth: 6 } );\n\n\t\t\tthis.defaultCubeTexture[ format ] = defaultCubeTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultCubeTexture ).texture;\n\n\t}\n\n\t_getDefaultVideoFrame() {\n\n\t\tlet defaultVideoFrame = this.defaultVideoFrame;\n\n\t\tif ( defaultVideoFrame === null ) {\n\n\t\t\tconst init = {\n\t\t\t\ttimestamp: 0,\n\t\t\t\tcodedWidth: 1,\n\t\t\t\tcodedHeight: 1,\n\t\t\t\tformat: 'RGBA',\n\t\t\t};\n\n\t\t\tthis.defaultVideoFrame = defaultVideoFrame = new VideoFrame( new Uint8Array( [ 0, 0, 0, 0xff ] ), init );\n\n\t\t}\n\n\t\treturn defaultVideoFrame;\n\n\t}\n\n\t_copyCubeMapToTexture( images, textureGPU, textureDescriptorGPU, flipY ) {\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst image = images[ i ];\n\n\t\t\tconst flipIndex = flipY === true ? _flipMap[ i ] : i;\n\n\t\t\tif ( image.isDataTexture ) {\n\n\t\t\t\tthis._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY );\n\n\t\t\t} else {\n\n\t\t\t\tthis._copyImageToTexture( image, textureGPU, textureDescriptorGPU, flipIndex, flipY );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_copyImageToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tdevice.queue.copyExternalImageToTexture(\n\t\t\t{\n\t\t\t\tsource: image\n\t\t\t}, {\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: 0,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth }\n\t\t\t}, {\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t}\n\t\t);\n\n\t\tif ( flipY === true ) {\n\n\t\t\tthis._flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t\t}\n\n\t}\n\n\t_getPassUtils() {\n\n\t\tlet passUtils = this._passUtils;\n\n\t\tif ( passUtils === null ) {\n\n\t\t\tthis._passUtils = passUtils = new WebGPUTexturePassUtils( this.backend.device );\n\n\t\t}\n\n\t\treturn passUtils;\n\n\t}\n\n\t_generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer = 0 ) {\n\n\t\tthis._getPassUtils().generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer );\n\n\t}\n\n\t_flipY( textureGPU, textureDescriptorGPU, originDepth = 0 ) {\n\n\t\tthis._getPassUtils().flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t}\n\n\t_copyBufferToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0 ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\t\t// @TODO: Consider to support valid buffer layouts with other formats like RGB\n\n\t\tconst device = this.backend.device;\n\n\t\tconst data = image.data;\n\n\t\tconst bytesPerTexel = this._getBytesPerTexel( textureDescriptorGPU.format );\n\t\tconst bytesPerRow = image.width * bytesPerTexel;\n\n\t\tdevice.queue.writeTexture(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: 0,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth }\n\t\t\t},\n\t\t\tdata,\n\t\t\t{\n\t\t\t\toffset: image.width * image.height * bytesPerTexel * depth,\n\t\t\t\tbytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t} );\n\n\t\tif ( flipY === true ) {\n\n\t\t\tthis._flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t\t}\n\n\t}\n\n\t_copyCompressedBufferToTexture( mipmaps, textureGPU, textureDescriptorGPU ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\n\t\tconst device = this.backend.device;\n\n\t\tconst blockData = this._getBlockData( textureDescriptorGPU.format );\n\t\tconst isTextureArray = textureDescriptorGPU.size.depthOrArrayLayers > 1;\n\n\t\tfor ( let i = 0; i < mipmaps.length; i ++ ) {\n\n\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\tconst width = mipmap.width;\n\t\t\tconst height = mipmap.height;\n\t\t\tconst depth = isTextureArray ? textureDescriptorGPU.size.depthOrArrayLayers : 1;\n\n\t\t\tconst bytesPerRow = Math.ceil( width / blockData.width ) * blockData.byteLength;\n\t\t\tconst bytesPerImage = bytesPerRow * Math.ceil( height / blockData.height );\n\n\t\t\tfor ( let j = 0; j < depth; j ++ ) {\n\n\t\t\t\tdevice.queue.writeTexture(\n\t\t\t\t\t{\n\t\t\t\t\t\ttexture: textureGPU,\n\t\t\t\t\t\tmipLevel: i,\n\t\t\t\t\t\torigin: { x: 0, y: 0, z: j }\n\t\t\t\t\t},\n\t\t\t\t\tmipmap.data,\n\t\t\t\t\t{\n\t\t\t\t\t\toffset: j * bytesPerImage,\n\t\t\t\t\t\tbytesPerRow,\n\t\t\t\t\t\trowsPerImage: Math.ceil( height / blockData.height )\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\twidth: Math.ceil( width / blockData.width ) * blockData.width,\n\t\t\t\t\t\theight: Math.ceil( height / blockData.height ) * blockData.height,\n\t\t\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_getBlockData( format ) {\n\n\t\t// this method is only relevant for compressed texture formats\n\n\t\tif ( format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB ) return { byteLength: 8, width: 4, height: 4 }; // DXT1\n\t\tif ( format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT3\n\t\tif ( format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT5\n\t\tif ( format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm ) return { byteLength: 8, width: 4, height: 4 }; // RGTC1\n\t\tif ( format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm ) return { byteLength: 16, width: 4, height: 4 }; // RGTC2\n\t\tif ( format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)\n\t\tif ( format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)\n\n\t\tif ( format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Unorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Snorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Unorm ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Snorm ) return { byteLength: 16, width: 4, height: 4 };\n\n\t\tif ( format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB ) return { byteLength: 16, width: 5, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB ) return { byteLength: 16, width: 5, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB ) return { byteLength: 16, width: 6, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB ) return { byteLength: 16, width: 6, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB ) return { byteLength: 16, width: 8, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB ) return { byteLength: 16, width: 8, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB ) return { byteLength: 16, width: 8, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB ) return { byteLength: 16, width: 10, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB ) return { byteLength: 16, width: 10, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB ) return { byteLength: 16, width: 10, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB ) return { byteLength: 16, width: 10, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB ) return { byteLength: 16, width: 12, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB ) return { byteLength: 16, width: 12, height: 12 };\n\n\t}\n\n\t_convertAddressMode( value ) {\n\n\t\tlet addressMode = GPUAddressMode.ClampToEdge;\n\n\t\tif ( value === RepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.Repeat;\n\n\t\t} else if ( value === MirroredRepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.MirrorRepeat;\n\n\t\t}\n\n\t\treturn addressMode;\n\n\t}\n\n\t_convertFilterMode( value ) {\n\n\t\tlet filterMode = GPUFilterMode.Linear;\n\n\t\tif ( value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter ) {\n\n\t\t\tfilterMode = GPUFilterMode.Nearest;\n\n\t\t}\n\n\t\treturn filterMode;\n\n\t}\n\n\t_getBytesPerTexel( format ) {\n\n\t\t// 8-bit formats\n\t\tif ( format === GPUTextureFormat.R8Unorm ||\n\t\t\tformat === GPUTextureFormat.R8Snorm ||\n\t\t\tformat === GPUTextureFormat.R8Uint ||\n\t\t\tformat === GPUTextureFormat.R8Sint ) return 1;\n\n\t\t// 16-bit formats\n\t\tif ( format === GPUTextureFormat.R16Uint ||\n\t\t\tformat === GPUTextureFormat.R16Sint ||\n\t\t\tformat === GPUTextureFormat.R16Float ||\n\t\t\tformat === GPUTextureFormat.RG8Unorm ||\n\t\t\tformat === GPUTextureFormat.RG8Snorm ||\n\t\t\tformat === GPUTextureFormat.RG8Uint ||\n\t\t\tformat === GPUTextureFormat.RG8Sint ) return 2;\n\n\t\t// 32-bit formats\n\t\tif ( format === GPUTextureFormat.R32Uint ||\n\t\t\tformat === GPUTextureFormat.R32Sint ||\n\t\t\tformat === GPUTextureFormat.R32Float ||\n\t\t\tformat === GPUTextureFormat.RG16Uint ||\n\t\t\tformat === GPUTextureFormat.RG16Sint ||\n\t\t\tformat === GPUTextureFormat.RG16Float ||\n\t\t\tformat === GPUTextureFormat.RGBA8Unorm ||\n\t\t\tformat === GPUTextureFormat.RGBA8UnormSRGB ||\n\t\t\tformat === GPUTextureFormat.RGBA8Snorm ||\n\t\t\tformat === GPUTextureFormat.RGBA8Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA8Sint ||\n\t\t\tformat === GPUTextureFormat.BGRA8Unorm ||\n\t\t\tformat === GPUTextureFormat.BGRA8UnormSRGB ||\n\t\t\t// Packed 32-bit formats\n\t\t\tformat === GPUTextureFormat.RGB9E5UFloat ||\n\t\t\tformat === GPUTextureFormat.RGB10A2Unorm ||\n\t\t\tformat === GPUTextureFormat.RG11B10UFloat ||\n\t\t\tformat === GPUTextureFormat.Depth32Float ||\n\t\t\tformat === GPUTextureFormat.Depth24Plus ||\n\t\t\tformat === GPUTextureFormat.Depth24PlusStencil8 ||\n\t\t\tformat === GPUTextureFormat.Depth32FloatStencil8 ) return 4;\n\n\t\t// 64-bit formats\n\t\tif ( format === GPUTextureFormat.RG32Uint ||\n\t\t\tformat === GPUTextureFormat.RG32Sint ||\n\t\t\tformat === GPUTextureFormat.RG32Float ||\n\t\t\tformat === GPUTextureFormat.RGBA16Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA16Sint ||\n\t\t\tformat === GPUTextureFormat.RGBA16Float ) return 8;\n\n\t\t// 128-bit formats\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA32Sint ||\n\t\t\tformat === GPUTextureFormat.RGBA32Float ) return 16;\n\n\n\t}\n\n\t_getTypedArrayType( format ) {\n\n\t\tif ( format === GPUTextureFormat.R8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.R8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Snorm ) return Int8Array;\n\n\n\t\tif ( format === GPUTextureFormat.R16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.R16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RG16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.R16Float ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Float ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Float ) return Uint16Array;\n\n\n\t\tif ( format === GPUTextureFormat.R32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.R32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.R32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RG32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RG32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Float ) return Float32Array;\n\n\t\tif ( format === GPUTextureFormat.BGRA8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.BGRA8UnormSRGB ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGB10A2Unorm ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGB9E5UFloat ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG11B10UFloat ) return Uint32Array;\n\n\t\tif ( format === GPUTextureFormat.Depth32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.Depth24Plus ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.Depth24PlusStencil8 ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.Depth32FloatStencil8 ) return Float32Array;\n\n\t}\n\n\t_getDimension( texture ) {\n\n\t\tlet dimension;\n\n\t\tif ( texture.isData3DTexture ) {\n\n\t\t\tdimension = GPUTextureDimension.ThreeD;\n\n\t\t} else {\n\n\t\t\tdimension = GPUTextureDimension.TwoD;\n\n\t\t}\n\n\t\treturn dimension;\n\n\t}\n\n}\n\nfunction getFormat( texture, device = null ) {\n\n\tconst format = texture.format;\n\tconst type = texture.type;\n\tconst colorSpace = texture.colorSpace;\n\n\tlet formatGPU;\n\n\tif ( texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBA_S3TC_DXT1_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT3_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGB_ETC2_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ETC2_EAC_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_4x4_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x4_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x8_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x8_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x10_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x10_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x12_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBAFormat:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t} else {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBAFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Uint;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBAFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGBFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt5999Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGB9E5UFloat;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RedFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth16Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24Plus;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with DepthFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthStencilFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt248Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24PlusStencil8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tif ( device && device.features.has( GPUFeatureName.Depth32FloatStencil8 ) === false ) {\n\n\t\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the \"depth32float-stencil8\" GPU feature.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32FloatStencil8;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGBAIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t}\n\n\treturn formatGPU;\n\n}\n\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/i;\nconst propertiesRegexp = /([a-z_0-9]+)\\s*:\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/ig;\n\nconst wgslTypeLib$1 = {\n\t'f32': 'float',\n\t'i32': 'int',\n\t'u32': 'uint',\n\t'bool': 'bool',\n\n\t'vec2<f32>': 'vec2',\n \t'vec2<i32>': 'ivec2',\n \t'vec2<u32>': 'uvec2',\n \t'vec2<bool>': 'bvec2',\n\n\t'vec2f': 'vec2',\n\t'vec2i': 'ivec2',\n\t'vec2u': 'uvec2',\n\t'vec2b': 'bvec2',\n\n\t'vec3<f32>': 'vec3',\n\t'vec3<i32>': 'ivec3',\n\t'vec3<u32>': 'uvec3',\n\t'vec3<bool>': 'bvec3',\n\n\t'vec3f': 'vec3',\n\t'vec3i': 'ivec3',\n\t'vec3u': 'uvec3',\n\t'vec3b': 'bvec3',\n\n\t'vec4<f32>': 'vec4',\n\t'vec4<i32>': 'ivec4',\n\t'vec4<u32>': 'uvec4',\n\t'vec4<bool>': 'bvec4',\n\n\t'vec4f': 'vec4',\n\t'vec4i': 'ivec4',\n\t'vec4u': 'uvec4',\n\t'vec4b': 'bvec4',\n\n\t'mat2x2<f32>': 'mat2',\n\t'mat2x2f': 'mat2',\n\n\t'mat3x3<f32>': 'mat3',\n\t'mat3x3f': 'mat3',\n\n\t'mat4x4<f32>': 'mat4',\n\t'mat4x4f': 'mat4',\n\n\t'sampler': 'sampler',\n\n\t'texture_1d': 'texture',\n\n\t'texture_2d': 'texture',\n\t'texture_2d_array': 'texture',\n\t'texture_multisampled_2d': 'cubeTexture',\n\n\t'texture_depth_2d': 'depthTexture',\n\n\t'texture_3d': 'texture3D',\n\n\t'texture_cube': 'cubeTexture',\n\t'texture_cube_array': 'cubeTexture',\n\n\t'texture_storage_1d': 'storageTexture',\n\t'texture_storage_2d': 'storageTexture',\n\t'texture_storage_2d_array': 'storageTexture',\n\t'texture_storage_3d': 'storageTexture'\n\n};\n\nconst parse = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst declaration = source.match( declarationRegexp );\n\n\tif ( declaration !== null && declaration.length === 4 ) {\n\n\t\tconst inputsCode = declaration[ 2 ];\n\t\tconst propsMatches = [];\n\t\tlet match = null;\n\n\t\twhile ( ( match = propertiesRegexp.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( { name: match[ 1 ], type: match[ 2 ] } );\n\n\t\t}\n\n\t\t// Process matches to correctly pair names and types\n\t\tconst inputs = [];\n\t\tfor ( let i = 0; i < propsMatches.length; i ++ ) {\n\n\t\t\tconst { name, type } = propsMatches[ i ];\n\n\t\t\tlet resolvedType = type;\n\n\t\t\tif ( resolvedType.startsWith( 'ptr' ) ) {\n\n\t\t\t\tresolvedType = 'pointer';\n\n\t\t\t} else {\n\n\t\t\t\tif ( resolvedType.startsWith( 'texture' ) ) {\n\n\t\t\t\t\tresolvedType = type.split( '<' )[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tresolvedType = wgslTypeLib$1[ resolvedType ];\n\n\t\t\t}\n\n\t\t\tinputs.push( new NodeFunctionInput( resolvedType, name ) );\n\n\t\t}\n\n\t\tconst blockCode = source.substring( declaration[ 0 ].length );\n\t\tconst outputType = declaration[ 3 ] || 'void';\n\n\t\tconst name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\t\tconst type = wgslTypeLib$1[ outputType ] || outputType;\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\toutputType\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a WGSL code.' );\n\n\t}\n\n};\n\nclass WGSLNodeFunction extends NodeFunction {\n\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, inputsCode, blockCode, outputType } = parse( source );\n\n\t\tsuper( type, inputs, name );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.outputType = outputType;\n\n\t}\n\n\tgetCode( name = this.name ) {\n\n\t\tconst outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';\n\n\t\treturn `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ outputType }` + this.blockCode;\n\n\t}\n\n}\n\nclass WGSLNodeParser extends NodeParser {\n\n\tparseFunction( source ) {\n\n\t\treturn new WGSLNodeFunction( source );\n\n\t}\n\n}\n\n// GPUShaderStage is not defined in browsers not supporting WebGPU\nconst GPUShaderStage = ( typeof self !== 'undefined' ) ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };\n\nconst accessNames = {\n\t[ NodeAccess.READ_ONLY ]: 'read',\n\t[ NodeAccess.WRITE_ONLY ]: 'write',\n\t[ NodeAccess.READ_WRITE ]: 'read_write'\n};\n\nconst wrapNames = {\n\t[ RepeatWrapping ]: 'repeat',\n\t[ ClampToEdgeWrapping ]: 'clamp',\n\t[ MirroredRepeatWrapping ]: 'mirror'\n};\n\nconst gpuShaderStageLib = {\n\t'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,\n\t'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,\n\t'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4\n};\n\nconst supports = {\n\tinstance: true,\n\tswizzleAssign: false,\n\tstorageBuffer: true\n};\n\nconst wgslFnOpLib = {\n\t'^^': 'tsl_xor'\n};\n\nconst wgslTypeLib = {\n\tfloat: 'f32',\n\tint: 'i32',\n\tuint: 'u32',\n\tbool: 'bool',\n\tcolor: 'vec3<f32>',\n\n\tvec2: 'vec2<f32>',\n\tivec2: 'vec2<i32>',\n\tuvec2: 'vec2<u32>',\n\tbvec2: 'vec2<bool>',\n\n\tvec3: 'vec3<f32>',\n\tivec3: 'vec3<i32>',\n\tuvec3: 'vec3<u32>',\n\tbvec3: 'vec3<bool>',\n\n\tvec4: 'vec4<f32>',\n\tivec4: 'vec4<i32>',\n\tuvec4: 'vec4<u32>',\n\tbvec4: 'vec4<bool>',\n\n\tmat2: 'mat2x2<f32>',\n\tmat3: 'mat3x3<f32>',\n\tmat4: 'mat4x4<f32>'\n};\n\nconst wgslCodeCache = {};\n\nconst wgslPolyfill = {\n\ttsl_xor: new CodeNode( 'fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }' ),\n\tmod_float: new CodeNode( 'fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }' ),\n\tmod_vec2: new CodeNode( 'fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }' ),\n\tmod_vec3: new CodeNode( 'fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }' ),\n\tmod_vec4: new CodeNode( 'fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }' ),\n\tequals_bool: new CodeNode( 'fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }' ),\n\tequals_bvec2: new CodeNode( 'fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }' ),\n\tequals_bvec3: new CodeNode( 'fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }' ),\n\tequals_bvec4: new CodeNode( 'fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }' ),\n\trepeatWrapping_float: new CodeNode( 'fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }' ),\n\tmirrorWrapping_float: new CodeNode( 'fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }' ),\n\tclampWrapping_float: new CodeNode( 'fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }' ),\n\tbiquadraticTexture: new CodeNode( /* wgsl */`\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {\n\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n` )\n};\n\nconst wgslMethods = {\n\tdFdx: 'dpdx',\n\tdFdy: '- dpdy',\n\tmod_float: 'tsl_mod_float',\n\tmod_vec2: 'tsl_mod_vec2',\n\tmod_vec3: 'tsl_mod_vec3',\n\tmod_vec4: 'tsl_mod_vec4',\n\tequals_bool: 'tsl_equals_bool',\n\tequals_bvec2: 'tsl_equals_bvec2',\n\tequals_bvec3: 'tsl_equals_bvec3',\n\tequals_bvec4: 'tsl_equals_bvec4',\n\tinversesqrt: 'inverseSqrt',\n\tbitcast: 'bitcast<f32>'\n};\n\n// WebGPU issue: does not support pow() with negative base on Windows\n\nif ( typeof navigator !== 'undefined' && /Windows/g.test( navigator.userAgent ) ) {\n\n\twgslPolyfill.pow_float = new CodeNode( 'fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }' );\n\twgslPolyfill.pow_vec2 = new CodeNode( 'fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [ wgslPolyfill.pow_float ] );\n\twgslPolyfill.pow_vec3 = new CodeNode( 'fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [ wgslPolyfill.pow_float ] );\n\twgslPolyfill.pow_vec4 = new CodeNode( 'fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [ wgslPolyfill.pow_float ] );\n\n\twgslMethods.pow_float = 'tsl_pow_float';\n\twgslMethods.pow_vec2 = 'tsl_pow_vec2';\n\twgslMethods.pow_vec3 = 'tsl_pow_vec3';\n\twgslMethods.pow_vec4 = 'tsl_pow_vec4';\n\n}\n\n//\n\nlet diagnostics = '';\n\nif ( ( typeof navigator !== 'undefined' && /Firefox|Deno/g.test( navigator.userAgent ) ) !== true ) {\n\n\tdiagnostics += 'diagnostic( off, derivative_uniformity );\\n';\n\n}\n\n//\n\nclass WGSLNodeBuilder extends NodeBuilder {\n\n\tconstructor( object, renderer ) {\n\n\t\tsuper( object, renderer, new WGSLNodeParser() );\n\n\t\tthis.uniformGroups = {};\n\n\t\tthis.builtins = {};\n\n\t\tthis.directives = {};\n\n\t\tthis.scopedArrays = new Map();\n\n\t}\n\n\tneedsToWorkingColorSpace( texture ) {\n\n\t\treturn texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n\n\t}\n\n\t_generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\tif ( depthSnippet ) {\n\n\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\t\t} else {\n\n\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet } )`;\n\n\t\t\t}\n\n\t\t} else if ( this.isFilteredTexture( texture ) ) {\n\n\t\t\treturn this.generateFilteredTexture( texture, textureProperty, uvSnippet );\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0' );\n\n\t\t}\n\n\t}\n\n\t_generateVideoSample( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleBaseClampToEdge( ${ textureProperty }, ${ textureProperty }_sampler, vec2<f32>( ${ uvSnippet }.x, 1.0 - ${ uvSnippet }.y ) )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.VideoTexture does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t_generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' && this.isUnfilterable( texture ) === false ) {\n\n\t\t\treturn `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t\t} else if ( this.isFilteredTexture( texture ) ) {\n\n\t\t\treturn this.generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet );\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet );\n\n\t\t}\n\n\t}\n\n\tgenerateWrapFunction( texture ) {\n\n\t\tconst functionName = `tsl_coord_${ wrapNames[ texture.wrapS ] }S_${ wrapNames[ texture.wrapT ] }T`;\n\n\t\tlet nodeCode = wgslCodeCache[ functionName ];\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst includes = [];\n\n\t\t\tlet code = `fn ${ functionName }( coord : vec2f ) -> vec2f {\\n\\n\\treturn vec2f(\\n`;\n\n\t\t\tconst addWrapSnippet = ( wrap, axis ) => {\n\n\t\t\t\tif ( wrap === RepeatWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.repeatWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_repeatWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else if ( wrap === ClampToEdgeWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.clampWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_clampWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else if ( wrap === MirroredRepeatWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.mirrorWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_mirrorWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcode += `\\t\\tcoord.${ axis }`;\n\n\t\t\t\t\tconsole.warn( `WebGPURenderer: Unsupported texture wrap type \"${ wrap }\" for vertex shader.` );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\taddWrapSnippet( texture.wrapS, 'x' );\n\n\t\t\tcode += ',\\n';\n\n\t\t\taddWrapSnippet( texture.wrapT, 'y' );\n\n\t\t\tcode += '\\n\\t);\\n\\n}\\n';\n\n\t\t\twgslCodeCache[ functionName ] = nodeCode = new CodeNode( code, includes );\n\n\t\t}\n\n\t\tnodeCode.build( this );\n\n\t\treturn functionName;\n\n\t}\n\n\tgenerateTextureDimension( texture, textureProperty, levelSnippet ) {\n\n\t\tconst textureData = this.getDataFromNode( texture, this.shaderStage, this.globalCache );\n\n\t\tif ( textureData.dimensionsSnippet === undefined ) textureData.dimensionsSnippet = {};\n\n\t\tlet textureDimensionNode = textureData.dimensionsSnippet[ levelSnippet ];\n\n\t\tif ( textureData.dimensionsSnippet[ levelSnippet ] === undefined ) {\n\n\t\t\tlet textureDimensionsParams;\n\n\t\t\tif ( texture.isMultisampleRenderTargetTexture === true ) {\n\n\t\t\t\ttextureDimensionsParams = textureProperty;\n\n\t\t\t} else {\n\n\t\t\t\ttextureDimensionsParams = `${ textureProperty }, u32( ${ levelSnippet } )`;\n\n\t\t\t}\n\n\t\t\ttextureDimensionNode = new VarNode( new ExpressionNode( `textureDimensions( ${ textureDimensionsParams } )`, 'uvec2' ) );\n\n\t\t\ttextureData.dimensionsSnippet[ levelSnippet ] = textureDimensionNode;\n\n\t\t}\n\n\t\treturn textureDimensionNode.build( this );\n\n\t}\n\n\tgenerateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet = '0u' ) {\n\n\t\tthis._include( 'biquadraticTexture' );\n\n\t\tconst wrapFunction = this.generateWrapFunction( texture );\n\t\tconst textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );\n\n\t\treturn `tsl_biquadraticTexture( ${ textureProperty }, ${ wrapFunction }( ${ uvSnippet } ), ${ textureDimension }, u32( ${ levelSnippet } ) )`;\n\n\t}\n\n\tgenerateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet = '0u' ) {\n\n\t\tconst wrapFunction = this.generateWrapFunction( texture );\n\t\tconst textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );\n\n\t\tconst coordSnippet = `vec2u( ${ wrapFunction }( ${ uvSnippet } ) * vec2f( ${ textureDimension } ) )`;\n\n\t\treturn this.generateTextureLoad( texture, textureProperty, coordSnippet, depthSnippet, levelSnippet );\n\n\t}\n\n\tgenerateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u' ) {\n\n\t\tif ( texture.isVideoTexture === true || texture.isStorageTexture === true ) {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet } )`;\n\n\t\t} else if ( depthSnippet ) {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, u32( ${ levelSnippet } ) )`;\n\n\t\t} else {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, u32( ${ levelSnippet } ) )`;\n\n\t\t}\n\n\t}\n\n\tgenerateTextureStore( texture, textureProperty, uvIndexSnippet, valueSnippet ) {\n\n\t\treturn `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ valueSnippet } )`;\n\n\t}\n\n\tisSampleCompare( texture ) {\n\n\t\treturn texture.isDepthTexture === true && texture.compareFunction !== null;\n\n\t}\n\n\tisUnfilterable( texture ) {\n\n\t\treturn this.getComponentTypeFromTexture( texture ) !== 'float' ||\n\t\t\t( ! this.isAvailable( 'float32Filterable' ) && texture.isDataTexture === true && texture.type === FloatType ) ||\n\t\t\t( this.isSampleCompare( texture ) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter ) ||\n\t\t\ttexture.isMultisampleRenderTargetTexture === true;\n\n\t}\n\n\tgenerateTexture( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tlet snippet = null;\n\n\t\tif ( texture.isVideoTexture === true ) {\n\n\t\t\tsnippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );\n\n\t\t} else if ( this.isUnfilterable( texture ) ) {\n\n\t\t\tsnippet = this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage );\n\n\t\t} else {\n\n\t\t\tsnippet = this._generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgenerateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\t// TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy\n\t\t\treturn `textureSampleGrad( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet },  ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.TextureNode.gradient() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\tgenerateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ compareSnippet } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\tgenerateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tlet snippet = null;\n\n\t\tif ( texture.isVideoTexture === true ) {\n\n\t\t\tsnippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );\n\n\t\t} else {\n\n\t\t\tsnippet = this._generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgenerateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleBias( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ biasSnippet } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.TextureNode.biasNode does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeVarying === true && node.needsInterpolation === true ) {\n\n\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\treturn `varyings.${ node.name }`;\n\n\t\t\t}\n\n\t\t} else if ( node.isNodeUniform === true ) {\n\n\t\t\tconst name = node.name;\n\t\t\tconst type = node.type;\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {\n\n\t\t\t\treturn name;\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {\n\n\t\t\t\treturn `NodeBuffer_${ node.id }.${name}`;\n\n\t\t\t} else {\n\n\t\t\t\treturn node.groupNode.name + '.' + name;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.getPropertyName( node );\n\n\t}\n\n\tgetOutputStructName() {\n\n\t\treturn 'output';\n\n\t}\n\n\t_getUniformGroupCount( shaderStage ) {\n\n\t\treturn Object.keys( this.uniforms[ shaderStage ] ).length;\n\n\t}\n\n\tgetFunctionOperator( op ) {\n\n\t\tconst fnOp = wgslFnOpLib[ op ];\n\n\t\tif ( fnOp !== undefined ) {\n\n\t\t\tthis._include( fnOp );\n\n\t\t\treturn fnOp;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tgetNodeAccess( node, shaderStage ) {\n\n\t\tif ( shaderStage !== 'compute' )\n\t\t\treturn NodeAccess.READ_ONLY;\n\n\t\treturn node.access;\n\n\t}\n\n\tgetStorageAccess( node, shaderStage ) {\n\n\t\treturn accessNames[ this.getNodeAccess( node, shaderStage ) ];\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tif ( nodeData.uniformGPU === undefined ) {\n\n\t\t\tlet uniformGPU;\n\n\t\t\tconst group = node.groupNode;\n\t\t\tconst groupName = group.name;\n\n\t\t\tconst bindings = this.getBindGroupArray( groupName, shaderStage );\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {\n\n\t\t\t\tlet texture = null;\n\n\t\t\t\tconst access = this.getNodeAccess( node, shaderStage );\n\n\t\t\t\tif ( type === 'texture' || type === 'storageTexture' ) {\n\n\t\t\t\t\ttexture = new NodeSampledTexture( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\t\ttexture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t} else if ( type === 'texture3D' ) {\n\n\t\t\t\t\ttexture = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.store = node.isStorageTextureNode === true;\n\t\t\t\ttexture.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\tif ( shaderStage === 'fragment' && this.isUnfilterable( node.value ) === false && texture.store === false ) {\n\n\t\t\t\t\tconst sampler = new NodeSampler( `${uniformNode.name}_sampler`, uniformNode.node, group );\n\t\t\t\t\tsampler.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tbindings.push( sampler, texture );\n\n\t\t\t\t\tuniformGPU = [ sampler, texture ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbindings.push( texture );\n\n\t\t\t\t\tuniformGPU = [ texture ];\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tconst bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;\n\n\t\t\t\tconst buffer = new bufferClass( node, group );\n\t\t\t\tbuffer.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\tbindings.push( buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t} else {\n\n\t\t\t\tconst uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );\n\n\t\t\t\tlet uniformsGroup = uniformsStage[ groupName ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new NodeUniformsGroup( groupName, group );\n\t\t\t\t\tuniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tuniformsStage[ groupName ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n\tgetBuiltin( name, property, type, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.builtins[ shaderStage ] || ( this.builtins[ shaderStage ] = new Map() );\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tproperty,\n\t\t\t\ttype\n\t\t\t} );\n\n\t\t}\n\n\t\treturn property;\n\n\t}\n\n\thasBuiltin( name, shaderStage = this.shaderStage ) {\n\n\t\treturn ( this.builtins[ shaderStage ] !== undefined && this.builtins[ shaderStage ].has( name ) );\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'vertex_index', 'vertexIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'vertexIndex';\n\n\t}\n\n\tbuildFunctionCode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\t\tconst flowData = this.flowShaderNode( shaderNode );\n\n\t\tconst parameters = [];\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tparameters.push( input.name + ' : ' + this.getType( input.type ) );\n\n\t\t}\n\n\t\t//\n\n\t\tlet code = `fn ${ layout.name }( ${ parameters.join( ', ' ) } ) -> ${ this.getType( layout.type ) } {\n${ flowData.vars }\n${ flowData.code }\n`;\n\n\t\tif ( flowData.result ) {\n\n\t\t\tcode += `\\treturn ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tcode += '\\n}\\n';\n\n\t\t//\n\n\t\treturn code;\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'instanceIndex';\n\n\t}\n\n\tgetInvocationLocalIndex() {\n\n\t\treturn this.getBuiltin( 'local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute' );\n\n\t}\n\n\tgetSubgroupSize() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );\n\n\t}\n\n\tgetInvocationSubgroupIndex() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute' );\n\n\t}\n\n\tgetSubgroupIndex() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_id', 'subgroupIndex', 'u32', 'attribute' );\n\n\t}\n\n\tgetDrawIndex() {\n\n\t\treturn null;\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\treturn this.getBuiltin( 'front_facing', 'isFront', 'bool' );\n\n\t}\n\n\tgetFragCoord() {\n\n\t\treturn this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>' ) + '.xy';\n\n\t}\n\n\tgetFragDepth() {\n\n\t\treturn 'output.' + this.getBuiltin( 'frag_depth', 'depth', 'f32', 'output' );\n\n\t}\n\n\tgetClipDistance() {\n\n\t\treturn 'varyings.hw_clip_distances';\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\tenableDirective( name, shaderStage = this.shaderStage ) {\n\n\t\tconst stage = this.directives[ shaderStage ] || ( this.directives[ shaderStage ] = new Set() );\n\t\tstage.add( name );\n\n\t}\n\n\tgetDirectives( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst directives = this.directives[ shaderStage ];\n\n\t\tif ( directives !== undefined ) {\n\n\t\t\tfor ( const directive of directives ) {\n\n\t\t\t\tsnippets.push( `enable ${directive};` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\tenableSubGroups() {\n\n\t\tthis.enableDirective( 'subgroups' );\n\n\t}\n\n\tenableSubgroupsF16() {\n\n\t\tthis.enableDirective( 'subgroups-f16' );\n\n\t}\n\n\tenableClipDistances() {\n\n\t\tthis.enableDirective( 'clip_distances' );\n\n\t}\n\n\tenableShaderF16() {\n\n\t\tthis.enableDirective( 'f16' );\n\n\t}\n\n\tenableDualSourceBlending() {\n\n\t\tthis.enableDirective( 'dual_source_blending' );\n\n\t}\n\n\tenableHardwareClipping( planeCount ) {\n\n\t\tthis.enableClipDistances();\n\t\tthis.getBuiltin( 'clip_distances', 'hw_clip_distances', `array<f32, ${ planeCount } >`, 'vertex' );\n\n\t}\n\n\tgetBuiltins( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst builtins = this.builtins[ shaderStage ];\n\n\t\tif ( builtins !== undefined ) {\n\n\t\t\tfor ( const { name, property, type } of builtins.values() ) {\n\n\t\t\t\tsnippets.push( `@builtin( ${name} ) ${property} : ${type}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\tgetScopedArray( name, scope, bufferType, bufferCount ) {\n\n\t\tif ( this.scopedArrays.has( name ) === false ) {\n\n\t\t\tthis.scopedArrays.set( name, {\n\t\t\t\tname,\n\t\t\t\tscope,\n\t\t\t\tbufferType,\n\t\t\t\tbufferCount\n\t\t\t} );\n\n\t\t}\n\n\t\treturn name;\n\n\t}\n\n\tgetScopedArrays( shaderStage ) {\n\n\t\tif ( shaderStage !== 'compute' ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst snippets = [];\n\n\t\tfor ( const { name, scope, bufferType, bufferCount } of this.scopedArrays.values() ) {\n\n\t\t\tconst type = this.getType( bufferType );\n\n\t\t\tsnippets.push( `var<${scope}> ${name}: array< ${type}, ${bufferCount} >;` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\tgetAttributes( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tthis.getBuiltin( 'global_invocation_id', 'id', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'local_invocation_id', 'localId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute' );\n\n\t\t\tif ( this.renderer.hasFeature( 'subgroups' ) ) {\n\n\t\t\t\tthis.enableDirective( 'subgroups', shaderStage );\n\t\t\t\tthis.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tconst builtins = this.getBuiltins( 'attribute' );\n\n\t\t\tif ( builtins ) snippets.push( builtins );\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tfor ( let index = 0, length = attributes.length; index < length; index ++ ) {\n\n\t\t\t\tconst attribute = attributes[ index ];\n\t\t\t\tconst name = attribute.name;\n\t\t\t\tconst type = this.getType( attribute.type );\n\n\t\t\t\tsnippets.push( `@location( ${index} ) ${ name } : ${ type }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\t\tconst members = struct.getMemberTypes();\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\tconst member = members[ i ];\n\t\t\tsnippets.push( `\\t@location( ${i} ) m${i} : ${ member }<f32>` );\n\n\t\t}\n\n\t\tconst builtins = this.getBuiltins( 'output' );\n\n\t\tif ( builtins ) snippets.push( '\\t' + builtins );\n\n\t\treturn snippets.join( ',\\n' );\n\n\t}\n\n\tgetStructs( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tfor ( let index = 0, length = structs.length; index < length; index ++ ) {\n\n\t\t\tconst struct = structs[ index ];\n\t\t\tconst name = struct.name;\n\n\t\t\tlet snippet = `\\struct ${ name } {\\n`;\n\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\tsnippet += '\\n}';\n\n\n\t\t\tsnippets.push( snippet );\n\n\t\t\tsnippets.push( `\\nvar<private> output : ${ name };\\n\\n` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\n' );\n\n\t}\n\n\tgetVar( type, name ) {\n\n\t\treturn `var ${ name } : ${ this.getType( type ) }`;\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippets.push( `\\t${ this.getVar( variable.type, variable.name ) };` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `\\n${ snippets.join( '\\n' ) }\\n`;\n\n\t}\n\n\tgetVaryings( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tthis.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst vars = this.vars[ shaderStage ];\n\n\t\t\tfor ( let index = 0; index < varyings.length; index ++ ) {\n\n\t\t\t\tconst varying = varyings[ index ];\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tlet attributesSnippet = `@location( ${index} )`;\n\n\t\t\t\t\tif ( /^(int|uint|ivec|uvec)/.test( varying.type ) ) {\n\n\t\t\t\t\t\tattributesSnippet += ' @interpolate( flat )';\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsnippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );\n\n\t\t\t\t} else if ( shaderStage === 'vertex' && vars.includes( varying ) === false ) {\n\n\t\t\t\t\tvars.push( varying );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst builtins = this.getBuiltins( shaderStage );\n\n\t\tif ( builtins ) snippets.push( builtins );\n\n\t\tconst code = snippets.join( ',\\n\\t' );\n\n\t\treturn shaderStage === 'vertex' ? this._getWGSLStruct( 'VaryingsStruct', '\\t' + code ) : code;\n\n\t}\n\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst bufferSnippets = [];\n\t\tconst structSnippets = [];\n\t\tconst uniformGroups = {};\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tconst groupName = uniform.groupNode.name;\n\t\t\tconst uniformIndexes = this.bindingsIndexes[ groupName ];\n\n\t\t\tif ( uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tif ( shaderStage === 'fragment' && this.isUnfilterable( texture ) === false && uniform.node.isStorageTextureNode !== true ) {\n\n\t\t\t\t\tif ( this.isSampleCompare( texture ) ) {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler_comparison;` );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler;` );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlet textureType;\n\n\t\t\t\tlet multisampled = '';\n\n\t\t\t\tif ( texture.isMultisampleRenderTargetTexture === true ) {\n\n\t\t\t\t\tmultisampled = '_multisampled';\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.isCubeTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_cube<f32>';\n\n\t\t\t\t} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_2d_array<f32>';\n\n\t\t\t\t} else if ( texture.isDepthTexture === true ) {\n\n\t\t\t\t\ttextureType = `texture_depth${multisampled}_2d`;\n\n\t\t\t\t} else if ( texture.isVideoTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_external';\n\n\t\t\t\t} else if ( texture.isData3DTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_3d<f32>';\n\n\t\t\t\t} else if ( uniform.node.isStorageTextureNode === true ) {\n\n\t\t\t\t\tconst format = getFormat( texture );\n\t\t\t\t\tconst access = this.getStorageAccess( uniform.node, shaderStage );\n\n\t\t\t\t\ttextureType = `texture_storage_2d<${ format }, ${ access }>`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst componentPrefix = this.getComponentTypeFromTexture( texture ).charAt( 0 );\n\n\t\t\t\t\ttextureType = `texture${multisampled}_2d<${ componentPrefix }32>`;\n\n\t\t\t\t}\n\n\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name } : ${ textureType };` );\n\n\t\t\t} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.bufferType );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';\n\t\t\t\tconst bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`;\n\t\t\t\tconst bufferSnippet = `\\t${ uniform.name } : array< ${ bufferTypeSnippet }${ bufferCountSnippet } >\\n`;\n\t\t\t\tconst bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${ this.getStorageAccess( bufferNode, shaderStage ) }` : 'uniform';\n\n\t\t\t\tbufferSnippets.push( this._getWGSLStructBinding( 'NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, uniformIndexes.binding ++, uniformIndexes.group ) );\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getType( this.getVectorType( uniform.type ) );\n\t\t\t\tconst groupName = uniform.groupNode.name;\n\n\t\t\t\tconst group = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = {\n\t\t\t\t\tindex: uniformIndexes.binding ++,\n\t\t\t\t\tid: uniformIndexes.group,\n\t\t\t\t\tsnippets: []\n\t\t\t\t} );\n\n\t\t\t\tgroup.snippets.push( `\\t${ uniform.name } : ${ vectorType }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const name in uniformGroups ) {\n\n\t\t\tconst group = uniformGroups[ name ];\n\n\t\t\tstructSnippets.push( this._getWGSLStructBinding( name, group.snippets.join( ',\\n' ), 'uniform', group.index, group.id ) );\n\n\t\t}\n\n\t\tlet code = bindingSnippets.join( '\\n' );\n\t\tcode += bufferSnippets.join( '\\n' );\n\t\tcode += structSnippets.join( '\\n' );\n\n\t\treturn code;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tthis.sortBindingGroups();\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.directives = this.getDirectives( shaderStage );\n\t\t\tstageData.scopedArrays = this.getScopedArrays( shaderStage );\n\n\t\t\t//\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tconst outputNode = mainNode.outputNode;\n\t\t\tconst isOutputStruct = ( outputNode !== undefined && outputNode.isOutputStructNode === true );\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n\\t`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += `varyings.Vertex = ${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( isOutputStruct ) {\n\n\t\t\t\t\t\t\tstageData.returnType = outputNode.nodeType;\n\n\t\t\t\t\t\t\tflow += `return ${ flowSlotData.result };`;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tlet structSnippet = '\\t@location(0) color: vec4<f32>';\n\n\t\t\t\t\t\t\tconst builtins = this.getBuiltins( 'output' );\n\n\t\t\t\t\t\t\tif ( builtins ) structSnippet += ',\\n\\t' + builtins;\n\n\t\t\t\t\t\t\tstageData.returnType = 'OutputStruct';\n\t\t\t\t\t\t\tstageData.structs += this._getWGSLStruct( 'OutputStruct', structSnippet );\n\t\t\t\t\t\t\tstageData.structs += '\\nvar<private> output : OutputStruct;\\n\\n';\n\n\t\t\t\t\t\t\tflow += `output.color = ${ flowSlotData.result };\\n\\n\\treturn output;`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstageData.flow = flow;\n\n\n\t\t}\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getWGSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\tthis.computeShader = this._getWGSLComputeCode( shadersData.compute, ( this.object.workgroupSize || [ 64 ] ).join( ', ' ) );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method, output = null ) {\n\n\t\tlet wgslMethod;\n\n\t\tif ( output !== null ) {\n\n\t\t\twgslMethod = this._getWGSLMethod( method + '_' + output );\n\n\t\t}\n\n\t\tif ( wgslMethod === undefined ) {\n\n\t\t\twgslMethod = this._getWGSLMethod( method );\n\n\t\t}\n\n\t\treturn wgslMethod || method;\n\n\t}\n\n\tgetType( type ) {\n\n\t\treturn wgslTypeLib[ type ] || type;\n\n\t}\n\n\tisAvailable( name ) {\n\n\t\tlet result = supports[ name ];\n\n\t\tif ( result === undefined ) {\n\n\t\t\tif ( name === 'float32Filterable' ) {\n\n\t\t\t\tresult = this.renderer.hasFeature( 'float32-filterable' );\n\n\t\t\t} else if ( name === 'clipDistance' ) {\n\n\t\t\t\tresult = this.renderer.hasFeature( 'clip-distances' );\n\n\t\t\t}\n\n\t\t\tsupports[ name ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t_getWGSLMethod( method ) {\n\n\t\tif ( wgslPolyfill[ method ] !== undefined ) {\n\n\t\t\tthis._include( method );\n\n\t\t}\n\n\t\treturn wgslMethods[ method ];\n\n\t}\n\n\t_include( name ) {\n\n\t\tconst codeNode = wgslPolyfill[ name ];\n\t\tcodeNode.build( this );\n\n\t\tif ( this.currentFunctionNode !== null ) {\n\n\t\t\tthis.currentFunctionNode.includes.push( codeNode );\n\n\t\t}\n\n\t\treturn codeNode;\n\n\t}\n\n\t_getWGSLVertexCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n// directives\n${shaderData.directives}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( ${shaderData.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn varyings;\n\n}\n`;\n\n\t}\n\n\t_getWGSLFragmentCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n// global\n${ diagnostics }\n\n// uniforms\n${shaderData.uniforms}\n\n// structs\n${shaderData.structs}\n\n// codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t_getWGSLComputeCode( shaderData, workgroupSize ) {\n\n\t\treturn `${ this.getSignature() }\n// directives\n${shaderData.directives}\n\n// system\nvar<private> instanceIndex : u32;\n\n// locals\n${shaderData.scopedArrays}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@compute @workgroup_size( ${workgroupSize} )\nfn main( ${shaderData.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x + id.y * numWorkgroups.x * u32(${workgroupSize}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${workgroupSize});\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t_getWGSLStruct( name, vars ) {\n\n\t\treturn `\nstruct ${name} {\n${vars}\n};`;\n\n\t}\n\n\t_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {\n\n\t\tconst structName = name + 'Struct';\n\t\tconst structSnippet = this._getWGSLStruct( structName, vars );\n\n\t\treturn `${structSnippet}\n@binding( ${binding} ) @group( ${group} )\nvar<${access}> ${name} : ${structName};`;\n\n\t}\n\n}\n\nclass WebGPUUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t}\n\n\tgetCurrentDepthStencilFormat( renderContext ) {\n\n\t\tlet format;\n\n\t\tif ( renderContext.depthTexture !== null ) {\n\n\t\t\tformat = this.getTextureFormatGPU( renderContext.depthTexture );\n\n\t\t} else if ( renderContext.depth && renderContext.stencil ) {\n\n\t\t\tformat = GPUTextureFormat.Depth24PlusStencil8;\n\n\t\t} else if ( renderContext.depth ) {\n\n\t\t\tformat = GPUTextureFormat.Depth24Plus;\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\tgetTextureFormatGPU( texture ) {\n\n\t\treturn this.backend.get( texture ).format;\n\n\t}\n\n\tgetCurrentColorFormat( renderContext ) {\n\n\t\tlet format;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tformat = this.getTextureFormatGPU( renderContext.textures[ 0 ] );\n\n\t\t} else {\n\n\t\t\tformat = this.getPreferredCanvasFormat(); // default context format\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\tgetCurrentColorSpace( renderContext ) {\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\treturn renderContext.textures[ 0 ].colorSpace;\n\n\t\t}\n\n\t\treturn this.backend.renderer.outputColorSpace;\n\n\t}\n\n\tgetPrimitiveTopology( object, material ) {\n\n\t\tif ( object.isPoints ) return GPUPrimitiveTopology.PointList;\n\t\telse if ( object.isLineSegments || ( object.isMesh && material.wireframe === true ) ) return GPUPrimitiveTopology.LineList;\n\t\telse if ( object.isLine ) return GPUPrimitiveTopology.LineStrip;\n\t\telse if ( object.isMesh ) return GPUPrimitiveTopology.TriangleList;\n\n\t}\n\n\tgetSampleCount( sampleCount ) {\n\n\t\tlet count = 1;\n\n\t\tif ( sampleCount > 1 ) {\n\n\t\t\t// WebGPU only supports power-of-two sample counts and 2 is not a valid value\n\t\t\tcount = Math.pow( 2, Math.floor( Math.log2( sampleCount ) ) );\n\n\t\t\tif ( count === 2 ) {\n\n\t\t\t\tcount = 4;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tgetSampleCountRenderContext( renderContext ) {\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\treturn this.getSampleCount( renderContext.sampleCount );\n\n\t\t}\n\n\t\treturn this.getSampleCount( this.backend.renderer.samples );\n\n\t}\n\n\tgetPreferredCanvasFormat() {\n\n\t\t// TODO: Remove this check when Quest 34.5 is out\n\t\t// https://github.com/mrdoob/three.js/pull/29221/files#r1731833949\n\n\t\tif ( navigator.userAgent.includes( 'Quest' ) ) {\n\n\t\t\treturn GPUTextureFormat.BGRA8Unorm;\n\n\t\t} else {\n\n\t\t\treturn navigator.gpu.getPreferredCanvasFormat();\n\n\t\t}\n\n\t}\n\n}\n\nconst typedArraysToVertexFormatPrefix = new Map( [\n\t[ Int8Array, [ 'sint8', 'snorm8' ]],\n\t[ Uint8Array, [ 'uint8', 'unorm8' ]],\n\t[ Int16Array, [ 'sint16', 'snorm16' ]],\n\t[ Uint16Array, [ 'uint16', 'unorm16' ]],\n\t[ Int32Array, [ 'sint32', 'snorm32' ]],\n\t[ Uint32Array, [ 'uint32', 'unorm32' ]],\n\t[ Float32Array, [ 'float32', ]],\n] );\n\nconst typedAttributeToVertexFormatPrefix = new Map( [\n\t[ Float16BufferAttribute, [ 'float16', ]],\n] );\n\nconst typeArraysToVertexFormatPrefixForItemSize1 = new Map( [\n\t[ Int32Array, 'sint32' ],\n\t[ Int16Array, 'sint32' ], // patch for INT16\n\t[ Uint32Array, 'uint32' ],\n\t[ Uint16Array, 'uint32' ], // patch for UINT16\n\t[ Float32Array, 'float32' ]\n] );\n\nclass WebGPUAttributeUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t}\n\n\tcreateAttribute( attribute, usage ) {\n\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\tconst backend = this.backend;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\n\t\tlet buffer = bufferData.buffer;\n\n\t\tif ( buffer === undefined ) {\n\n\t\t\tconst device = backend.device;\n\n\t\t\tlet array = bufferAttribute.array;\n\n\t\t\t// patch for INT16 and UINT16\n\t\t\tif ( attribute.normalized === false && ( array.constructor === Int16Array || array.constructor === Uint16Array ) ) {\n\n\t\t\t\tconst tempArray = new Uint32Array( array.length );\n\t\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\t\ttempArray[ i ] = array[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tarray = tempArray;\n\n\t\t\t}\n\n\t\t\tbufferAttribute.array = array;\n\n\t\t\tif ( ( bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute ) && bufferAttribute.itemSize === 3 ) {\n\n\t\t\t\tarray = new array.constructor( bufferAttribute.count * 4 );\n\n\t\t\t\tfor ( let i = 0; i < bufferAttribute.count; i ++ ) {\n\n\t\t\t\t\tarray.set( bufferAttribute.array.subarray( i * 3, i * 3 + 3 ), i * 4 );\n\n\t\t\t\t}\n\n\t\t\t\t// Update BufferAttribute\n\t\t\t\tbufferAttribute.itemSize = 4;\n\t\t\t\tbufferAttribute.array = array;\n\n\t\t\t}\n\n\t\t\tconst size = array.byteLength + ( ( 4 - ( array.byteLength % 4 ) ) % 4 ); // ensure 4 byte alignment, see #20441\n\n\t\t\tbuffer = device.createBuffer( {\n\t\t\t\tlabel: bufferAttribute.name,\n\t\t\t\tsize: size,\n\t\t\t\tusage: usage,\n\t\t\t\tmappedAtCreation: true\n\t\t\t} );\n\n\t\t\tnew array.constructor( buffer.getMappedRange() ).set( array );\n\n\t\t\tbuffer.unmap();\n\n\t\t\tbufferData.buffer = buffer;\n\n\t\t}\n\n\t}\n\n\tupdateAttribute( attribute ) {\n\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst buffer = backend.get( bufferAttribute ).buffer;\n\n\t\tconst array = bufferAttribute.array;\n\t\tconst isTypedArray = this._isTypedArray( array );\n\t\tconst updateRanges = bufferAttribute.updateRanges;\n\n\t\tif ( updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tdevice.queue.writeBuffer(\n\t\t\t\tbuffer,\n\t\t\t\t0,\n\t\t\t\tarray,\n\t\t\t\t0\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tconst byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\n\t\t\t\tconst dataOffset = range.start * byteOffsetFactor;\n\t\t\t\tconst size = range.count * byteOffsetFactor;\n\n\t\t\t\tdevice.queue.writeBuffer(\n\t\t\t\t\tbuffer,\n\t\t\t\t\t0,\n\t\t\t\t\tarray,\n\t\t\t\t\tdataOffset,\n\t\t\t\t\tsize\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tbufferAttribute.clearUpdateRanges();\n\n\t\t}\n\n\t}\n\n\tcreateShaderVertexBuffers( renderObject ) {\n\n\t\tconst attributes = renderObject.getAttributes();\n\t\tconst vertexBuffers = new Map();\n\n\t\tfor ( let slot = 0; slot < attributes.length; slot ++ ) {\n\n\t\t\tconst geometryAttribute = attributes[ slot ];\n\t\t\tconst bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;\n\t\t\tconst bufferAttribute = this._getBufferAttribute( geometryAttribute );\n\n\t\t\tlet vertexBufferLayout = vertexBuffers.get( bufferAttribute );\n\n\t\t\tif ( vertexBufferLayout === undefined ) {\n\n\t\t\t\tlet arrayStride, stepMode;\n\n\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute === true ) {\n\n\t\t\t\t\tarrayStride = geometryAttribute.data.stride * bytesPerElement;\n\t\t\t\t\tstepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarrayStride = geometryAttribute.itemSize * bytesPerElement;\n\t\t\t\t\tstepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n\n\t\t\t\t}\n\n\t\t\t\t// patch for INT16 and UINT16\n\t\t\t\tif ( geometryAttribute.normalized === false && ( geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array ) ) {\n\n\t\t\t\t\tarrayStride = 4;\n\n\t\t\t\t}\n\n\t\t\t\tvertexBufferLayout = {\n\t\t\t\t\tarrayStride,\n\t\t\t\t\tattributes: [],\n\t\t\t\t\tstepMode\n\t\t\t\t};\n\n\t\t\t\tvertexBuffers.set( bufferAttribute, vertexBufferLayout );\n\n\t\t\t}\n\n\t\t\tconst format = this._getVertexFormat( geometryAttribute );\n\t\t\tconst offset = ( geometryAttribute.isInterleavedBufferAttribute === true ) ? geometryAttribute.offset * bytesPerElement : 0;\n\n\t\t\tvertexBufferLayout.attributes.push( {\n\t\t\t\tshaderLocation: slot,\n\t\t\t\toffset,\n\t\t\t\tformat\n\t\t\t} );\n\n\t\t}\n\n\t\treturn Array.from( vertexBuffers.values() );\n\n\t}\n\n\tdestroyAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst data = backend.get( this._getBufferAttribute( attribute ) );\n\n\t\tdata.buffer.destroy();\n\n\t\tbackend.delete( attribute );\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst data = backend.get( this._getBufferAttribute( attribute ) );\n\n\t\tconst bufferGPU = data.buffer;\n\t\tconst size = bufferGPU.size;\n\n\t\tconst readBufferGPU = device.createBuffer( {\n\t\t\tlabel: attribute.name,\n\t\t\tsize,\n\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t} );\n\n\n\t\tconst cmdEncoder = device.createCommandEncoder( {} );\n\n\t\tcmdEncoder.copyBufferToBuffer(\n\t\t\tbufferGPU,\n\t\t\t0,\n\t\t\treadBufferGPU,\n\t\t\t0,\n\t\t\tsize\n\t\t);\n\n\t\treadBufferGPU.unmap();\n\n\t\tconst gpuCommands = cmdEncoder.finish();\n\t\tdevice.queue.submit( [ gpuCommands ] );\n\n\t\tawait readBufferGPU.mapAsync( GPUMapMode.READ );\n\n\t\tconst arrayBuffer = readBufferGPU.getMappedRange();\n\n\t\treturn arrayBuffer;\n\n\t}\n\n\t_getVertexFormat( geometryAttribute ) {\n\n\t\tconst { itemSize, normalized } = geometryAttribute;\n\t\tconst ArrayType = geometryAttribute.array.constructor;\n\t\tconst AttributeType = geometryAttribute.constructor;\n\n\t\tlet format;\n\n\t\tif ( itemSize == 1 ) {\n\n\t\t\tformat = typeArraysToVertexFormatPrefixForItemSize1.get( ArrayType );\n\n\t\t} else {\n\n\t\t\tconst prefixOptions = typedAttributeToVertexFormatPrefix.get( AttributeType ) || typedArraysToVertexFormatPrefix.get( ArrayType );\n\t\t\tconst prefix = prefixOptions[ normalized ? 1 : 0 ];\n\n\t\t\tif ( prefix ) {\n\n\t\t\t\tconst bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;\n\t\t\t\tconst paddedBytesPerUnit = Math.floor( ( bytesPerUnit + 3 ) / 4 ) * 4;\n\t\t\t\tconst paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;\n\n\t\t\t\tif ( paddedItemSize % 1 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.WebGPUAttributeUtils: Bad vertex format item size.' );\n\n\t\t\t\t}\n\n\t\t\t\tformat = `${prefix}x${paddedItemSize}`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! format ) {\n\n\t\t\tconsole.error( 'THREE.WebGPUAttributeUtils: Vertex format not supported yet.' );\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\t_isTypedArray( array ) {\n\n\t\treturn ArrayBuffer.isView( array ) && ! ( array instanceof DataView );\n\n\t}\n\n\t_getBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn attribute;\n\n\t}\n\n}\n\nclass WebGPUBindingUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\t\tthis.bindGroupLayoutCache = new WeakMap();\n\n\t}\n\n\tcreateBindingsLayout( bindGroup ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst entries = [];\n\n\t\tlet index = 0;\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tconst bindingGPU = {\n\t\t\t\tbinding: index ++,\n\t\t\t\tvisibility: binding.visibility\n\t\t\t};\n\n\t\t\tif ( binding.isUniformBuffer || binding.isStorageBuffer ) {\n\n\t\t\t\tconst buffer = {}; // GPUBufferBindingLayout\n\n\t\t\t\tif ( binding.isStorageBuffer ) {\n\n\t\t\t\t\tif ( binding.visibility & 4 ) {\n\n\t\t\t\t\t\t// compute\n\n\t\t\t\t\t\tif ( binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY ) {\n\n\t\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.Storage;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.ReadOnlyStorage;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.ReadOnlyStorage;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.buffer = buffer;\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst sampler = {}; // GPUSamplerBindingLayout\n\n\t\t\t\tif ( binding.texture.isDepthTexture ) {\n\n\t\t\t\t\tif ( binding.texture.compareFunction !== null ) {\n\n\t\t\t\t\t\tsampler.type = 'comparison';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.sampler = sampler;\n\n\t\t\t} else if ( binding.isSampledTexture && binding.texture.isVideoTexture ) {\n\n\t\t\t\tbindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout\n\n\t\t\t} else if ( binding.isSampledTexture && binding.store ) {\n\n\t\t\t\tconst storageTexture = {}; // GPUStorageTextureBindingLayout\n\t\t\t\tstorageTexture.format = this.backend.get( binding.texture ).texture.format;\n\n\t\t\t\tconst access = binding.access;\n\n\t\t\t\tif ( access === NodeAccess.READ_WRITE ) {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.ReadWrite;\n\n\t\t\t\t} else if ( access === NodeAccess.WRITE_ONLY ) {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.WriteOnly;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.ReadOnly;\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.storageTexture = storageTexture;\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst texture = {}; // GPUTextureBindingLayout\n\n\t\t\t\tif ( binding.texture.isMultisampleRenderTargetTexture === true ) {\n\n\t\t\t\t\ttexture.multisampled = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.texture.isDepthTexture ) {\n\n\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.Depth;\n\n\t\t\t\t} else if ( binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture ) {\n\n\t\t\t\t\tconst type = binding.texture.type;\n\n\t\t\t\t\tif ( type === IntType ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.SInt;\n\n\t\t\t\t\t} else if ( type === UnsignedIntType ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UInt;\n\n\t\t\t\t\t} else if ( type === FloatType ) {\n\n\t\t\t\t\t\tif ( this.backend.hasFeature( 'float32-filterable' ) ) {\n\n\t\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.Float;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.isSampledCubeTexture ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.Cube;\n\n\t\t\t\t} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.TwoDArray;\n\n\t\t\t\t} else if ( binding.isSampledTexture3D ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.ThreeD;\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.texture = texture;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( `WebGPUBindingUtils: Unsupported binding \"${ binding }\".` );\n\n\t\t\t}\n\n\t\t\tentries.push( bindingGPU );\n\n\t\t}\n\n\t\treturn device.createBindGroupLayout( { entries } );\n\n\t}\n\n\tcreateBindings( bindGroup, bindings, cacheIndex, version = 0 ) {\n\n\t\tconst { backend, bindGroupLayoutCache } = this;\n\t\tconst bindingsData = backend.get( bindGroup );\n\n\t\t// setup (static) binding layout and (dynamic) binding group\n\n\t\tlet bindLayoutGPU = bindGroupLayoutCache.get( bindGroup.bindingsReference );\n\n\t\tif ( bindLayoutGPU === undefined ) {\n\n\t\t\tbindLayoutGPU = this.createBindingsLayout( bindGroup );\n\t\t\tbindGroupLayoutCache.set( bindGroup.bindingsReference, bindLayoutGPU );\n\n\t\t}\n\n\t\tlet bindGroupGPU;\n\n\t\tif ( cacheIndex > 0 ) {\n\n\t\t\tif ( bindingsData.groups === undefined ) {\n\n\t\t\t\tbindingsData.groups = [];\n\t\t\t\tbindingsData.versions = [];\n\n\t\t\t}\n\n\t\t\tif ( bindingsData.versions[ cacheIndex ] === version ) {\n\n\t\t\t\tbindGroupGPU = bindingsData.groups[ cacheIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( bindGroupGPU === undefined ) {\n\n\t\t\tbindGroupGPU = this.createBindGroup( bindGroup, bindLayoutGPU );\n\n\t\t\tif ( cacheIndex > 0 ) {\n\n\t\t\t\tbindingsData.groups[ cacheIndex ] = bindGroupGPU;\n\t\t\t\tbindingsData.versions[ cacheIndex ] = version;\n\n\t\t\t}\n\n\t\t}\n\n\t\tbindingsData.group = bindGroupGPU;\n\t\tbindingsData.layout = bindLayoutGPU;\n\n\t}\n\n\tupdateBinding( binding ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst buffer = binding.buffer;\n\t\tconst bufferGPU = backend.get( binding ).buffer;\n\n\t\tdevice.queue.writeBuffer( bufferGPU, 0, buffer, 0 );\n\n\t}\n\n\tcreateBindGroup( bindGroup, layoutGPU ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tlet bindingPoint = 0;\n\t\tconst entriesGPU = [];\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isUniformBuffer ) {\n\n\t\t\t\tconst bindingData = backend.get( binding );\n\n\t\t\t\tif ( bindingData.buffer === undefined ) {\n\n\t\t\t\t\tconst byteLength = binding.byteLength;\n\n\t\t\t\t\tconst usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n\n\t\t\t\t\tconst bufferGPU = device.createBuffer( {\n\t\t\t\t\t\tlabel: 'bindingBuffer_' + binding.name,\n\t\t\t\t\t\tsize: byteLength,\n\t\t\t\t\t\tusage: usage\n\t\t\t\t\t} );\n\n\t\t\t\t\tbindingData.buffer = bufferGPU;\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\n\n\t\t\t} else if ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst bindingData = backend.get( binding );\n\n\t\t\t\tif ( bindingData.buffer === undefined ) {\n\n\t\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\t\t//const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;\n\n\t\t\t\t\t//backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer\n\n\t\t\t\t\tbindingData.buffer = backend.get( attribute ).buffer;\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst textureGPU = backend.get( binding.texture );\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: textureGPU.sampler } );\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst textureData = backend.get( binding.texture );\n\n\t\t\t\tlet resourceGPU;\n\n\t\t\t\tif ( textureData.externalTexture !== undefined ) {\n\n\t\t\t\t\tresourceGPU = device.importExternalTexture( { source: textureData.externalTexture } );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;\n\t\t\t\t\tconst propertyName = `view-${ textureData.texture.width }-${ textureData.texture.height }-${ mipLevelCount }`;\n\n\t\t\t\t\tresourceGPU = textureData[ propertyName ];\n\n\t\t\t\t\tif ( resourceGPU === undefined ) {\n\n\t\t\t\t\t\tconst aspectGPU = GPUTextureAspect.All;\n\n\t\t\t\t\t\tlet dimensionViewGPU;\n\n\t\t\t\t\t\tif ( binding.isSampledCubeTexture ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.Cube;\n\n\t\t\t\t\t\t} else if ( binding.isSampledTexture3D ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.ThreeD;\n\n\t\t\t\t\t\t} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.TwoDArray;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.TwoD;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresourceGPU = textureData[ propertyName ] = textureData.texture.createView( { aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount } );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: resourceGPU } );\n\n\t\t\t}\n\n\t\t\tbindingPoint ++;\n\n\t\t}\n\n\t\treturn device.createBindGroup( {\n\t\t\tlabel: 'bindGroup_' + bindGroup.name,\n\t\t\tlayout: layoutGPU,\n\t\t\tentries: entriesGPU\n\t\t} );\n\n\t}\n\n}\n\nclass WebGPUPipelineUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t}\n\n\t_getSampleCount( renderObjectContext ) {\n\n\t\treturn this.backend.utils.getSampleCountRenderContext( renderObjectContext );\n\n\t}\n\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tconst { object, material, geometry, pipeline } = renderObject;\n\t\tconst { vertexProgram, fragmentProgram } = pipeline;\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\t\tconst utils = backend.utils;\n\n\t\tconst pipelineData = backend.get( pipeline );\n\n\t\t// bind group layouts\n\n\t\tconst bindGroupLayouts = [];\n\n\t\tfor ( const bindGroup of renderObject.getBindings() ) {\n\n\t\t\tconst bindingsData = backend.get( bindGroup );\n\n\t\t\tbindGroupLayouts.push( bindingsData.layout );\n\n\t\t}\n\n\t\t// vertex buffers\n\n\t\tconst vertexBuffers = backend.attributeUtils.createShaderVertexBuffers( renderObject );\n\n\t\t// blending\n\n\t\tlet blending;\n\n\t\tif ( material.transparent === true && material.blending !== NoBlending ) {\n\n\t\t\tblending = this._getBlending( material );\n\n\t\t}\n\n\t\t// stencil\n\n\t\tlet stencilFront = {};\n\n\t\tif ( material.stencilWrite === true ) {\n\n\t\t\tstencilFront = {\n\t\t\t\tcompare: this._getStencilCompare( material ),\n\t\t\t\tfailOp: this._getStencilOperation( material.stencilFail ),\n\t\t\t\tdepthFailOp: this._getStencilOperation( material.stencilZFail ),\n\t\t\t\tpassOp: this._getStencilOperation( material.stencilZPass )\n\t\t\t};\n\n\t\t}\n\n\t\tconst colorWriteMask = this._getColorWriteMask( material );\n\n\t\tconst targets = [];\n\n\t\tif ( renderObject.context.textures !== null ) {\n\n\t\t\tconst textures = renderObject.context.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst colorFormat = utils.getTextureFormatGPU( textures[ i ] );\n\n\t\t\t\ttargets.push( {\n\t\t\t\t\tformat: colorFormat,\n\t\t\t\t\tblend: blending,\n\t\t\t\t\twriteMask: colorWriteMask\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst colorFormat = utils.getCurrentColorFormat( renderObject.context );\n\n\t\t\ttargets.push( {\n\t\t\t\tformat: colorFormat,\n\t\t\t\tblend: blending,\n\t\t\t\twriteMask: colorWriteMask\n\t\t\t} );\n\n\t\t}\n\n\t\tconst vertexModule = backend.get( vertexProgram ).module;\n\t\tconst fragmentModule = backend.get( fragmentProgram ).module;\n\n\t\tconst primitiveState = this._getPrimitiveState( object, geometry, material );\n\t\tconst depthCompare = this._getDepthCompare( material );\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );\n\n\t\tconst sampleCount = this._getSampleCount( renderObject.context );\n\n\t\tconst pipelineDescriptor = {\n\t\t\tlabel: `renderPipeline_${ material.name || material.type }_${ material.id }`,\n\t\t\tvertex: Object.assign( {}, vertexModule, { buffers: vertexBuffers } ),\n\t\t\tfragment: Object.assign( {}, fragmentModule, { targets } ),\n\t\t\tprimitive: primitiveState,\n\t\t\tmultisample: {\n\t\t\t\tcount: sampleCount,\n\t\t\t\talphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1\n\t\t\t},\n\t\t\tlayout: device.createPipelineLayout( {\n\t\t\t\tbindGroupLayouts\n\t\t\t} )\n\t\t};\n\n\n\t\tconst depthStencil = {};\n\t\tconst renderDepth = renderObject.context.depth;\n\t\tconst renderStencil = renderObject.context.stencil;\n\n\t\tif ( renderDepth === true || renderStencil === true ) {\n\n\t\t\tif ( renderDepth === true ) {\n\n\t\t\t\tdepthStencil.format = depthStencilFormat;\n\t\t\t\tdepthStencil.depthWriteEnabled = material.depthWrite;\n\t\t\t\tdepthStencil.depthCompare = depthCompare;\n\n\t\t\t}\n\n\t\t\tif ( renderStencil === true ) {\n\n\t\t\t\tdepthStencil.stencilFront = stencilFront;\n\t\t\t\tdepthStencil.stencilBack = {}; // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)\n\t\t\t\tdepthStencil.stencilReadMask = material.stencilFuncMask;\n\t\t\t\tdepthStencil.stencilWriteMask = material.stencilWriteMask;\n\n\t\t\t}\n\n\t\t\tpipelineDescriptor.depthStencil = depthStencil;\n\n\t\t}\n\n\n\t\tif ( promises === null ) {\n\n\t\t\tpipelineData.pipeline = device.createRenderPipeline( pipelineDescriptor );\n\n\t\t} else {\n\n\t\t\tconst p = new Promise( ( resolve /*, reject*/ ) => {\n\n\t\t\t\tdevice.createRenderPipelineAsync( pipelineDescriptor ).then( pipeline => {\n\n\t\t\t\t\tpipelineData.pipeline = pipeline;\n\t\t\t\t\tresolve();\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t\tpromises.push( p );\n\n\t\t}\n\n\t}\n\n\tcreateBundleEncoder( renderContext ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { utils, device } = backend;\n\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderContext );\n\t\tconst colorFormat = utils.getCurrentColorFormat( renderContext );\n\t\tconst sampleCount = this._getSampleCount( renderContext );\n\n\t\tconst descriptor = {\n\t\t\tlabel: 'renderBundleEncoder',\n\t\t\tcolorFormats: [ colorFormat ],\n\t\t\tdepthStencilFormat,\n\t\t\tsampleCount\n\t\t};\n\n\t\treturn device.createRenderBundleEncoder( descriptor );\n\n\t}\n\n\tcreateComputePipeline( pipeline, bindings ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst computeProgram = backend.get( pipeline.computeProgram ).module;\n\n\t\tconst pipelineGPU = backend.get( pipeline );\n\n\t\t// bind group layouts\n\n\t\tconst bindGroupLayouts = [];\n\n\t\tfor ( const bindingsGroup of bindings ) {\n\n\t\t\tconst bindingsData = backend.get( bindingsGroup );\n\n\t\t\tbindGroupLayouts.push( bindingsData.layout );\n\n\t\t}\n\n\t\tpipelineGPU.pipeline = device.createComputePipeline( {\n\t\t\tcompute: computeProgram,\n\t\t\tlayout: device.createPipelineLayout( {\n\t\t\t\tbindGroupLayouts\n\t\t\t} )\n\t\t} );\n\n\t}\n\n\t_getBlending( material ) {\n\n\t\tlet color, alpha;\n\n\t\tconst blending = material.blending;\n\t\tconst blendSrc = material.blendSrc;\n\t\tconst blendDst = material.blendDst;\n\t\tconst blendEquation = material.blendEquation;\n\n\n\t\tif ( blending === CustomBlending ) {\n\n\t\t\tconst blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;\n\t\t\tconst blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;\n\t\t\tconst blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;\n\n\t\t\tcolor = {\n\t\t\t\tsrcFactor: this._getBlendFactor( blendSrc ),\n\t\t\t\tdstFactor: this._getBlendFactor( blendDst ),\n\t\t\t\toperation: this._getBlendOperation( blendEquation )\n\t\t\t};\n\n\t\t\talpha = {\n\t\t\t\tsrcFactor: this._getBlendFactor( blendSrcAlpha ),\n\t\t\t\tdstFactor: this._getBlendFactor( blendDstAlpha ),\n\t\t\t\toperation: this._getBlendOperation( blendEquationAlpha )\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconst premultipliedAlpha = material.premultipliedAlpha;\n\n\t\t\tconst setBlend = ( srcRGB, dstRGB, srcAlpha, dstAlpha ) => {\n\n\t\t\t\tcolor = {\n\t\t\t\t\tsrcFactor: srcRGB,\n\t\t\t\t\tdstFactor: dstRGB,\n\t\t\t\t\toperation: GPUBlendOperation.Add\n\t\t\t\t};\n\n\t\t\t\talpha = {\n\t\t\t\t\tsrcFactor: srcAlpha,\n\t\t\t\t\tdstFactor: dstAlpha,\n\t\t\t\t\toperation: GPUBlendOperation.Add\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( color !== undefined && alpha !== undefined ) {\n\n\t\t\treturn { color, alpha };\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.WebGPURenderer: Invalid blending: ', blending );\n\n\t\t}\n\n\t}\n\n\t_getBlendFactor( blend ) {\n\n\t\tlet blendFactor;\n\n\t\tswitch ( blend ) {\n\n\t\t\tcase ZeroFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Zero;\n\t\t\t\tbreak;\n\n\t\t\tcase OneFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.One;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Src;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusSrcColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusSrc;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.SrcAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusSrcAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusSrcAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase DstColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Dst;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusDstColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusDstColor;\n\t\t\t\tbreak;\n\n\t\t\tcase DstAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.DstAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusDstAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusDstAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcAlphaSaturateFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.SrcAlphaSaturated;\n\t\t\t\tbreak;\n\n\t\t\tcase BlendColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Constant;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusBlendColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusConstant;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPURenderer: Blend factor not supported.', blend );\n\n\t\t}\n\n\t\treturn blendFactor;\n\n\t}\n\n\t_getStencilCompare( material ) {\n\n\t\tlet stencilCompare;\n\n\t\tconst stencilFunc = material.stencilFunc;\n\n\t\tswitch ( stencilFunc ) {\n\n\t\t\tcase NeverStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Never;\n\t\t\t\tbreak;\n\n\t\t\tcase AlwaysStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Always;\n\t\t\t\tbreak;\n\n\t\t\tcase LessStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Less;\n\t\t\t\tbreak;\n\n\t\t\tcase LessEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.LessEqual;\n\t\t\t\tbreak;\n\n\t\t\tcase EqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Equal;\n\t\t\t\tbreak;\n\n\t\t\tcase GreaterEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.GreaterEqual;\n\t\t\t\tbreak;\n\n\t\t\tcase GreaterStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Greater;\n\t\t\t\tbreak;\n\n\t\t\tcase NotEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.NotEqual;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPURenderer: Invalid stencil function.', stencilFunc );\n\n\t\t}\n\n\t\treturn stencilCompare;\n\n\t}\n\n\t_getStencilOperation( op ) {\n\n\t\tlet stencilOperation;\n\n\t\tswitch ( op ) {\n\n\t\t\tcase KeepStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Keep;\n\t\t\t\tbreak;\n\n\t\t\tcase ZeroStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Zero;\n\t\t\t\tbreak;\n\n\t\t\tcase ReplaceStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Replace;\n\t\t\t\tbreak;\n\n\t\t\tcase InvertStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Invert;\n\t\t\t\tbreak;\n\n\t\t\tcase IncrementStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.IncrementClamp;\n\t\t\t\tbreak;\n\n\t\t\tcase DecrementStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.DecrementClamp;\n\t\t\t\tbreak;\n\n\t\t\tcase IncrementWrapStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.IncrementWrap;\n\t\t\t\tbreak;\n\n\t\t\tcase DecrementWrapStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.DecrementWrap;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPURenderer: Invalid stencil operation.', stencilOperation );\n\n\t\t}\n\n\t\treturn stencilOperation;\n\n\t}\n\n\t_getBlendOperation( blendEquation ) {\n\n\t\tlet blendOperation;\n\n\t\tswitch ( blendEquation ) {\n\n\t\t\tcase AddEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Add;\n\t\t\t\tbreak;\n\n\t\t\tcase SubtractEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Subtract;\n\t\t\t\tbreak;\n\n\t\t\tcase ReverseSubtractEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.ReverseSubtract;\n\t\t\t\tbreak;\n\n\t\t\tcase MinEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Min;\n\t\t\t\tbreak;\n\n\t\t\tcase MaxEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Max;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPUPipelineUtils: Blend equation not supported.', blendEquation );\n\n\t\t}\n\n\t\treturn blendOperation;\n\n\t}\n\n\t_getPrimitiveState( object, geometry, material ) {\n\n\t\tconst descriptor = {};\n\t\tconst utils = this.backend.utils;\n\n\t\tdescriptor.topology = utils.getPrimitiveTopology( object, material );\n\n\t\tif ( geometry.index !== null && object.isLine === true && object.isLineSegments !== true ) {\n\n\t\t\tdescriptor.stripIndexFormat = ( geometry.index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n\n\t\t}\n\n\t\tswitch ( material.side ) {\n\n\t\t\tcase FrontSide:\n\t\t\t\tdescriptor.frontFace = GPUFrontFace.CCW;\n\t\t\t\tdescriptor.cullMode = GPUCullMode.Back;\n\t\t\t\tbreak;\n\n\t\t\tcase BackSide:\n\t\t\t\tdescriptor.frontFace = GPUFrontFace.CCW;\n\t\t\t\tdescriptor.cullMode = GPUCullMode.Front;\n\t\t\t\tbreak;\n\n\t\t\tcase DoubleSide:\n\t\t\t\tdescriptor.frontFace = GPUFrontFace.CCW;\n\t\t\t\tdescriptor.cullMode = GPUCullMode.None;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPUPipelineUtils: Unknown material.side value.', material.side );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\t_getColorWriteMask( material ) {\n\n\t\treturn ( material.colorWrite === true ) ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;\n\n\t}\n\n\t_getDepthCompare( material ) {\n\n\t\tlet depthCompare;\n\n\t\tif ( material.depthTest === false ) {\n\n\t\t\tdepthCompare = GPUCompareFunction.Always;\n\n\t\t} else {\n\n\t\t\tconst depthFunc = material.depthFunc;\n\n\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\tcase NeverDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Never;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AlwaysDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Always;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Less;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.LessEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Equal;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.GreaterEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Greater;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NotEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.NotEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error( 'THREE.WebGPUPipelineUtils: Invalid depth function.', depthFunc );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn depthCompare;\n\n\t}\n\n}\n\n/*// debugger tools\nimport 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';\n//*/\n\n\n//\n\nclass WebGPUBackend extends Backend {\n\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters );\n\n\t\tthis.isWebGPUBackend = true;\n\n\t\t// some parameters require default values other than \"undefined\"\n\t\tthis.parameters.alpha = ( parameters.alpha === undefined ) ? true : parameters.alpha;\n\n\t\tthis.parameters.requiredLimits = ( parameters.requiredLimits === undefined ) ? {} : parameters.requiredLimits;\n\n\t\tthis.trackTimestamp = ( parameters.trackTimestamp === true );\n\n\t\tthis.device = null;\n\t\tthis.context = null;\n\t\tthis.colorBuffer = null;\n\t\tthis.defaultRenderPassdescriptor = null;\n\n\t\tthis.utils = new WebGPUUtils( this );\n\t\tthis.attributeUtils = new WebGPUAttributeUtils( this );\n\t\tthis.bindingUtils = new WebGPUBindingUtils( this );\n\t\tthis.pipelineUtils = new WebGPUPipelineUtils( this );\n\t\tthis.textureUtils = new WebGPUTextureUtils( this );\n\t\tthis.occludedResolveCache = new Map();\n\n\t}\n\n\tasync init( renderer ) {\n\n\t\tawait super.init( renderer );\n\n\t\t//\n\n\t\tconst parameters = this.parameters;\n\n\t\t// create the device if it is not passed with parameters\n\n\t\tlet device;\n\n\t\tif ( parameters.device === undefined ) {\n\n\t\t\tconst adapterOptions = {\n\t\t\t\tpowerPreference: parameters.powerPreference\n\t\t\t};\n\n\t\t\tconst adapter = ( typeof navigator !== 'undefined' ) ? await navigator.gpu.requestAdapter( adapterOptions ) : null;\n\n\t\t\tif ( adapter === null ) {\n\n\t\t\t\tthrow new Error( 'WebGPUBackend: Unable to create WebGPU adapter.' );\n\n\t\t\t}\n\n\t\t\t// feature support\n\n\t\t\tconst features = Object.values( GPUFeatureName );\n\n\t\t\tconst supportedFeatures = [];\n\n\t\t\tfor ( const name of features ) {\n\n\t\t\t\tif ( adapter.features.has( name ) ) {\n\n\t\t\t\t\tsupportedFeatures.push( name );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst deviceDescriptor = {\n\t\t\t\trequiredFeatures: supportedFeatures,\n\t\t\t\trequiredLimits: parameters.requiredLimits\n\t\t\t};\n\n\t\t\tdevice = await adapter.requestDevice( deviceDescriptor );\n\n\t\t} else {\n\n\t\t\tdevice = parameters.device;\n\n\t\t}\n\n\t\tdevice.lost.then( ( info ) => {\n\n\t\t\tconst deviceLossInfo = {\n\t\t\t\tapi: 'WebGPU',\n\t\t\t\tmessage: info.message || 'Unknown reason',\n\t\t\t\treason: info.reason || null,\n\t\t\t\toriginalEvent: info\n\t\t\t};\n\n\t\t\trenderer.onDeviceLost( deviceLossInfo );\n\n\t\t} );\n\n\t\tconst context = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgpu' );\n\n\t\tthis.device = device;\n\t\tthis.context = context;\n\n\t\tconst alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';\n\n\t\tthis.trackTimestamp = this.trackTimestamp && this.hasFeature( GPUFeatureName.TimestampQuery );\n\n\t\tthis.context.configure( {\n\t\t\tdevice: this.device,\n\t\t\tformat: this.utils.getPreferredCanvasFormat(),\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n\t\t\talphaMode: alphaMode\n\t\t} );\n\n\t\tthis.updateSize();\n\n\t}\n\n\tget coordinateSystem() {\n\n\t\treturn WebGPUCoordinateSystem;\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.attributeUtils.getArrayBufferAsync( attribute );\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\t_getDefaultRenderPassDescriptor() {\n\n\t\tlet descriptor = this.defaultRenderPassdescriptor;\n\n\t\tif ( descriptor === null ) {\n\n\t\t\tconst renderer = this.renderer;\n\n\t\t\tdescriptor = {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: null\n\t\t\t\t} ],\n\t\t\t};\n\n\t\t\tif ( this.renderer.depth === true || this.renderer.stencil === true ) {\n\n\t\t\t\tdescriptor.depthStencilAttachment = {\n\t\t\t\t\tview: this.textureUtils.getDepthBuffer( renderer.depth, renderer.stencil ).createView()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\t\tif ( this.renderer.samples > 0 ) {\n\n\t\t\t\tcolorAttachment.view = this.colorBuffer.createView();\n\n\t\t\t} else {\n\n\t\t\t\tcolorAttachment.resolveTarget = undefined;\n\n\t\t\t}\n\n\t\t\tthis.defaultRenderPassdescriptor = descriptor;\n\n\t\t}\n\n\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\tif ( this.renderer.samples > 0 ) {\n\n\t\t\tcolorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n\n\t\t} else {\n\n\t\t\tcolorAttachment.view = this.context.getCurrentTexture().createView();\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\t_getRenderPassDescriptor( renderContext ) {\n\n\t\tconst renderTarget = renderContext.renderTarget;\n\t\tconst renderTargetData = this.get( renderTarget );\n\n\t\tlet descriptors = renderTargetData.descriptors;\n\n\t\tif ( descriptors === undefined ||\n\t\t\trenderTargetData.width !== renderTarget.width ||\n\t\t\trenderTargetData.height !== renderTarget.height ||\n\t\t\trenderTargetData.activeMipmapLevel !== renderTarget.activeMipmapLevel ||\n\t\t\trenderTargetData.samples !== renderTarget.samples\n\t\t) {\n\n\t\t\tdescriptors = {};\n\n\t\t\trenderTargetData.descriptors = descriptors;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\trenderTarget.removeEventListener( 'dispose', onDispose );\n\n\t\t\t\tthis.delete( renderTarget );\n\n\t\t\t};\n\n\t\t\trenderTarget.addEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t\tconst cacheKey = renderContext.getCacheKey();\n\n\t\tlet descriptor = descriptors[ cacheKey ];\n\n\t\tif ( descriptor === undefined ) {\n\n\t\t\tconst textures = renderContext.textures;\n\t\t\tconst colorAttachments = [];\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst textureData = this.get( textures[ i ] );\n\n\t\t\t\tconst textureView = textureData.texture.createView( {\n\t\t\t\t\tbaseMipLevel: renderContext.activeMipmapLevel,\n\t\t\t\t\tmipLevelCount: 1,\n\t\t\t\t\tbaseArrayLayer: renderContext.activeCubeFace,\n\t\t\t\t\tdimension: GPUTextureViewDimension.TwoD\n\t\t\t\t} );\n\n\t\t\t\tlet view, resolveTarget;\n\n\t\t\t\tif ( textureData.msaaTexture !== undefined ) {\n\n\t\t\t\t\tview = textureData.msaaTexture.createView();\n\t\t\t\t\tresolveTarget = textureView;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tview = textureView;\n\t\t\t\t\tresolveTarget = undefined;\n\n\t\t\t\t}\n\n\t\t\t\tcolorAttachments.push( {\n\t\t\t\t\tview,\n\t\t\t\t\tresolveTarget,\n\t\t\t\t\tloadOp: GPULoadOp.Load,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store\n\t\t\t\t} );\n\n\t\t\t}\n\n\n\t\t\tdescriptor = {\n\t\t\t\tcolorAttachments,\n\t\t\t};\n\n\t\t\tif ( renderContext.depth ) {\n\n\t\t\t\tconst depthTextureData = this.get( renderContext.depthTexture );\n\n\t\t\t\tconst depthStencilAttachment = {\n\t\t\t\t\tview: depthTextureData.texture.createView()\n\t\t\t\t};\n\t\t\t\tdescriptor.depthStencilAttachment = depthStencilAttachment;\n\n\t\t\t}\n\n\t\t\tdescriptors[ cacheKey ] = descriptor;\n\n\t\t\trenderTargetData.width = renderTarget.width;\n\t\t\trenderTargetData.height = renderTarget.height;\n\t\t\trenderTargetData.samples = renderTarget.samples;\n\t\t\trenderTargetData.activeMipmapLevel = renderTarget.activeMipmapLevel;\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\tbeginRender( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tconst device = this.device;\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tlet occlusionQuerySet;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tif ( renderContextData.currentOcclusionQuerySet ) renderContextData.currentOcclusionQuerySet.destroy();\n\t\t\tif ( renderContextData.currentOcclusionQueryBuffer ) renderContextData.currentOcclusionQueryBuffer.destroy();\n\n\t\t\t// Get a reference to the array of objects with queries. The renderContextData property\n\t\t\t// can be changed by another render pass before the buffer.mapAsyc() completes.\n\t\t\trenderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;\n\t\t\trenderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;\n\t\t\trenderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n\t\t\t//\n\n\t\t\tocclusionQuerySet = device.createQuerySet( { type: 'occlusion', count: occlusionQueryCount, label: `occlusionQuerySet_${ renderContext.id }` } );\n\n\t\t\trenderContextData.occlusionQuerySet = occlusionQuerySet;\n\t\t\trenderContextData.occlusionQueryIndex = 0;\n\t\t\trenderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );\n\n\t\t\trenderContextData.lastOcclusionObject = null;\n\n\t\t}\n\n\t\tlet descriptor;\n\n\t\tif ( renderContext.textures === null ) {\n\n\t\t\tdescriptor = this._getDefaultRenderPassDescriptor();\n\n\t\t} else {\n\n\t\t\tdescriptor = this._getRenderPassDescriptor( renderContext );\n\n\t\t}\n\n\t\tthis.initTimestampQuery( renderContext, descriptor );\n\n\t\tdescriptor.occlusionQuerySet = occlusionQuerySet;\n\n\t\tconst depthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst colorAttachments = descriptor.colorAttachments;\n\n\t\t\tfor ( let i = 0; i < colorAttachments.length; i ++ ) {\n\n\t\t\t\tconst colorAttachment = colorAttachments[ i ];\n\n\t\t\t\tif ( renderContext.clearColor ) {\n\n\t\t\t\t\tcolorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : { r: 0, g: 0, b: 0, a: 1 };\n\t\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\t\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\t\tif ( renderContext.clearColor ) {\n\n\t\t\t\tcolorAttachment.clearValue = renderContext.clearColorValue;\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderContext.depth ) {\n\n\t\t\tif ( renderContext.clearDepth ) {\n\n\t\t\t\tdepthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( renderContext.stencil ) {\n\n\t\t\tif ( renderContext.clearStencil ) {\n\n\t\t\t\tdepthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst encoder = device.createCommandEncoder( { label: 'renderContext_' + renderContext.id } );\n\t\tconst currentPass = encoder.beginRenderPass( descriptor );\n\n\t\t//\n\n\t\trenderContextData.descriptor = descriptor;\n\t\trenderContextData.encoder = encoder;\n\t\trenderContextData.currentPass = currentPass;\n\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\t\trenderContextData.renderBundles = [];\n\n\t\t//\n\n\t\tif ( renderContext.viewport ) {\n\n\t\t\tthis.updateViewport( renderContext );\n\n\t\t}\n\n\t\tif ( renderContext.scissor ) {\n\n\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\tcurrentPass.setScissorRect( x, y, width, height );\n\n\t\t}\n\n\t}\n\n\tfinishRender( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( renderContextData.renderBundles.length > 0 ) {\n\n\t\t\trenderContextData.currentPass.executeBundles( renderContextData.renderBundles );\n\n\t\t}\n\n\t\tif ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {\n\n\t\t\trenderContextData.currentPass.endOcclusionQuery();\n\n\t\t}\n\n\t\trenderContextData.currentPass.end();\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tconst bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results\n\n\t\t\t//\n\n\t\t\tlet queryResolveBuffer = this.occludedResolveCache.get( bufferSize );\n\n\t\t\tif ( queryResolveBuffer === undefined ) {\n\n\t\t\t\tqueryResolveBuffer = this.device.createBuffer(\n\t\t\t\t\t{\n\t\t\t\t\t\tsize: bufferSize,\n\t\t\t\t\t\tusage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tthis.occludedResolveCache.set( bufferSize, queryResolveBuffer );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst readBuffer = this.device.createBuffer(\n\t\t\t\t{\n\t\t\t\t\tsize: bufferSize,\n\t\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined\n\t\t\trenderContextData.encoder.resolveQuerySet( renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0 );\n\t\t\trenderContextData.encoder.copyBufferToBuffer( queryResolveBuffer, 0, readBuffer, 0, bufferSize );\n\n\t\t\trenderContextData.occlusionQueryBuffer = readBuffer;\n\n\t\t\t//\n\n\t\t\tthis.resolveOccludedAsync( renderContext );\n\n\t\t}\n\n\t\tthis.prepareTimestampBuffer( renderContext, renderContextData.encoder );\n\n\t\tthis.device.queue.submit( [ renderContextData.encoder.finish() ] );\n\n\n\t\t//\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst textures = renderContext.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.generateMipmaps === true ) {\n\n\t\t\t\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tisOccluded( renderContext, object ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\treturn renderContextData.occluded && renderContextData.occluded.has( object );\n\n\t}\n\n\tasync resolveOccludedAsync( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t// handle occlusion query results\n\n\t\tconst { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;\n\n\t\tif ( currentOcclusionQueryBuffer && currentOcclusionQueryObjects ) {\n\n\t\t\tconst occluded = new WeakSet();\n\n\t\t\trenderContextData.currentOcclusionQueryObjects = null;\n\t\t\trenderContextData.currentOcclusionQueryBuffer = null;\n\n\t\t\tawait currentOcclusionQueryBuffer.mapAsync( GPUMapMode.READ );\n\n\t\t\tconst buffer = currentOcclusionQueryBuffer.getMappedRange();\n\t\t\tconst results = new BigUint64Array( buffer );\n\n\t\t\tfor ( let i = 0; i < currentOcclusionQueryObjects.length; i ++ ) {\n\n\t\t\t\tif ( results[ i ] !== BigInt( 0 ) ) {\n\n\t\t\t\t\toccluded.add( currentOcclusionQueryObjects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentOcclusionQueryBuffer.destroy();\n\n\t\t\trenderContextData.occluded = occluded;\n\n\t\t}\n\n\t}\n\n\tupdateViewport( renderContext ) {\n\n\t\tconst { currentPass } = this.get( renderContext );\n\t\tconst { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;\n\n\t\tcurrentPass.setViewport( x, y, width, height, minDepth, maxDepth );\n\n\t}\n\n\tclear( color, depth, stencil, renderTargetData = null ) {\n\n\t\tconst device = this.device;\n\t\tconst renderer = this.renderer;\n\n\t\tlet colorAttachments = [];\n\n\t\tlet depthStencilAttachment;\n\t\tlet clearValue;\n\n\t\tlet supportsDepth;\n\t\tlet supportsStencil;\n\n\t\tif ( color ) {\n\n\t\t\tconst clearColor = this.getClearColor();\n\n\t\t\tif ( this.renderer.alpha === true ) {\n\n\t\t\t\t// premultiply alpha\n\n\t\t\t\tconst a = clearColor.a;\n\n\t\t\t\tclearValue = { r: clearColor.r * a, g: clearColor.g * a, b: clearColor.b * a, a: a };\n\n\t\t\t} else {\n\n\t\t\t\tclearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( renderTargetData === null ) {\n\n\t\t\tsupportsDepth = renderer.depth;\n\t\t\tsupportsStencil = renderer.stencil;\n\n\t\t\tconst descriptor = this._getDefaultRenderPassDescriptor();\n\n\t\t\tif ( color ) {\n\n\t\t\t\tcolorAttachments = descriptor.colorAttachments;\n\n\t\t\t\tconst colorAttachment = colorAttachments[ 0 ];\n\n\t\t\t\tcolorAttachment.clearValue = clearValue;\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t\tif ( supportsDepth || supportsStencil ) {\n\n\t\t\t\tdepthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsupportsDepth = renderTargetData.depth;\n\t\t\tsupportsStencil = renderTargetData.stencil;\n\n\t\t\tif ( color ) {\n\n\t\t\t\tfor ( const texture of renderTargetData.textures ) {\n\n\t\t\t\t\tconst textureData = this.get( texture );\n\t\t\t\t\tconst textureView = textureData.texture.createView();\n\n\t\t\t\t\tlet view, resolveTarget;\n\n\t\t\t\t\tif ( textureData.msaaTexture !== undefined ) {\n\n\t\t\t\t\t\tview = textureData.msaaTexture.createView();\n\t\t\t\t\t\tresolveTarget = textureView;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tview = textureView;\n\t\t\t\t\t\tresolveTarget = undefined;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcolorAttachments.push( {\n\t\t\t\t\t\tview,\n\t\t\t\t\t\tresolveTarget,\n\t\t\t\t\t\tclearValue,\n\t\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\t\tstoreOp: GPUStoreOp.Store\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( supportsDepth || supportsStencil ) {\n\n\t\t\t\tconst depthTextureData = this.get( renderTargetData.depthTexture );\n\n\t\t\t\tdepthStencilAttachment = {\n\t\t\t\t\tview: depthTextureData.texture.createView()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( supportsDepth ) {\n\n\t\t\tif ( depth ) {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.depthClearValue = renderer.getClearDepth();\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( supportsStencil ) {\n\n\t\t\tif ( stencil ) {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.stencilClearValue = renderer.getClearStencil();\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst encoder = device.createCommandEncoder( {} );\n\t\tconst currentPass = encoder.beginRenderPass( {\n\t\t\tcolorAttachments,\n\t\t\tdepthStencilAttachment\n\t\t} );\n\n\t\tcurrentPass.end();\n\n\t\tdevice.queue.submit( [ encoder.finish() ] );\n\n\t}\n\n\t// compute\n\n\tbeginCompute( computeGroup ) {\n\n\t\tconst groupGPU = this.get( computeGroup );\n\n\n\t\tconst descriptor = {};\n\n\t\tthis.initTimestampQuery( computeGroup, descriptor );\n\n\t\tgroupGPU.cmdEncoderGPU = this.device.createCommandEncoder();\n\n\t\tgroupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass( descriptor );\n\n\t}\n\n\tcompute( computeGroup, computeNode, bindings, pipeline ) {\n\n\t\tconst { passEncoderGPU } = this.get( computeGroup );\n\n\t\t// pipeline\n\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\n\t\tpassEncoderGPU.setPipeline( pipelineGPU );\n\n\t\t// bind groups\n\n\t\tfor ( let i = 0, l = bindings.length; i < l; i ++ ) {\n\n\t\t\tconst bindGroup = bindings[ i ];\n\t\t\tconst bindingsData = this.get( bindGroup );\n\n\t\t\tpassEncoderGPU.setBindGroup( i, bindingsData.group );\n\n\t\t}\n\n\t\tconst maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;\n\n\t\tconst computeNodeData = this.get( computeNode );\n\n\t\tif ( computeNodeData.dispatchSize === undefined ) computeNodeData.dispatchSize = { x: 0, y: 1, z: 1 };\n\n\t\tconst { dispatchSize } = computeNodeData;\n\n\t\tif ( computeNode.dispatchCount > maxComputeWorkgroupsPerDimension ) {\n\n\t\t\tdispatchSize.x = Math.min( computeNode.dispatchCount, maxComputeWorkgroupsPerDimension );\n\t\t\tdispatchSize.y = Math.ceil( computeNode.dispatchCount / maxComputeWorkgroupsPerDimension );\n\n\t\t} else {\n\n\t\t\tdispatchSize.x = computeNode.dispatchCount;\n\n\t\t}\n\n\t\tpassEncoderGPU.dispatchWorkgroups(\n\t\t\tdispatchSize.x,\n\t\t\tdispatchSize.y,\n\t\t\tdispatchSize.z\n\t\t);\n\n\t}\n\n\tfinishCompute( computeGroup ) {\n\n\t\tconst groupData = this.get( computeGroup );\n\n\t\tgroupData.passEncoderGPU.end();\n\n\t\tthis.prepareTimestampBuffer( computeGroup, groupData.cmdEncoderGPU );\n\n\t\tthis.device.queue.submit( [ groupData.cmdEncoderGPU.finish() ] );\n\n\t}\n\n\tasync waitForGPU() {\n\n\t\tawait this.device.queue.onSubmittedWorkDone();\n\n\t}\n\n\t// render object\n\n\tdraw( renderObject, info ) {\n\n\t\tconst { object, context, pipeline } = renderObject;\n\t\tconst bindings = renderObject.getBindings();\n\t\tconst renderContextData = this.get( context );\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\n\t\tconst currentSets = renderContextData.currentSets;\n\t\tconst passEncoderGPU = renderContextData.currentPass;\n\n\t\tconst drawParams = renderObject.getDrawParameters();\n\n\t\tif ( drawParams === null ) return;\n\n\t\t// pipeline\n\n\t\tif ( currentSets.pipeline !== pipelineGPU ) {\n\n\t\t\tpassEncoderGPU.setPipeline( pipelineGPU );\n\n\t\t\tcurrentSets.pipeline = pipelineGPU;\n\n\t\t}\n\n\t\t// bind groups\n\n\t\tconst currentBindingGroups = currentSets.bindingGroups;\n\n\t\tfor ( let i = 0, l = bindings.length; i < l; i ++ ) {\n\n\t\t\tconst bindGroup = bindings[ i ];\n\t\t\tconst bindingsData = this.get( bindGroup );\n\n\t\t\tif ( currentBindingGroups[ bindGroup.index ] !== bindGroup.id ) {\n\n\t\t\t\tpassEncoderGPU.setBindGroup( bindGroup.index, bindingsData.group );\n\t\t\t\tcurrentBindingGroups[ bindGroup.index ] = bindGroup.id;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst index = renderObject.getIndex();\n\n\t\tconst hasIndex = ( index !== null );\n\n\t\t// index\n\n\t\tif ( hasIndex === true ) {\n\n\t\t\tif ( currentSets.index !== index ) {\n\n\t\t\t\tconst buffer = this.get( index ).buffer;\n\t\t\t\tconst indexFormat = ( index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n\n\t\t\t\tpassEncoderGPU.setIndexBuffer( buffer, indexFormat );\n\n\t\t\t\tcurrentSets.index = index;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// vertex buffers\n\n\t\tconst vertexBuffers = renderObject.getVertexBuffers();\n\n\t\tfor ( let i = 0, l = vertexBuffers.length; i < l; i ++ ) {\n\n\t\t\tconst vertexBuffer = vertexBuffers[ i ];\n\n\t\t\tif ( currentSets.attributes[ i ] !== vertexBuffer ) {\n\n\t\t\t\tconst buffer = this.get( vertexBuffer ).buffer;\n\t\t\t\tpassEncoderGPU.setVertexBuffer( i, buffer );\n\n\t\t\t\tcurrentSets.attributes[ i ] = vertexBuffer;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// occlusion queries - handle multiple consecutive draw calls for an object\n\n\t\tif ( renderContextData.occlusionQuerySet !== undefined ) {\n\n\t\t\tconst lastObject = renderContextData.lastOcclusionObject;\n\n\t\t\tif ( lastObject !== object ) {\n\n\t\t\t\tif ( lastObject !== null && lastObject.occlusionTest === true ) {\n\n\t\t\t\t\tpassEncoderGPU.endOcclusionQuery();\n\t\t\t\t\trenderContextData.occlusionQueryIndex ++;\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.occlusionTest === true ) {\n\n\t\t\t\t\tpassEncoderGPU.beginOcclusionQuery( renderContextData.occlusionQueryIndex );\n\t\t\t\t\trenderContextData.occlusionQueryObjects[ renderContextData.occlusionQueryIndex ] = object;\n\n\t\t\t\t}\n\n\t\t\t\trenderContextData.lastOcclusionObject = object;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// draw\n\n\t\tif ( object.isBatchedMesh === true ) {\n\n\t\t\tconst starts = object._multiDrawStarts;\n\t\t\tconst counts = object._multiDrawCounts;\n\t\t\tconst drawCount = object._multiDrawCount;\n\t\t\tconst drawInstances = object._multiDrawInstances;\n\n\t\t\tconst bytesPerElement = hasIndex ? index.array.BYTES_PER_ELEMENT : 1;\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tconst count = drawInstances ? drawInstances[ i ] : 1;\n\t\t\t\tconst firstInstance = count > 1 ? 0 : i;\n\n\t\t\t\tpassEncoderGPU.drawIndexed( counts[ i ], count, starts[ i ] / bytesPerElement, 0, firstInstance );\n\n\t\t\t}\n\n\t\t} else if ( hasIndex === true ) {\n\n\t\t\tconst { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParams;\n\n\t\t\tconst indirect = renderObject.getIndirect();\n\n\t\t\tif ( indirect !== null ) {\n\n\t\t\t\tconst buffer = this.get( indirect ).buffer;\n\n\t\t\t\tpassEncoderGPU.drawIndexedIndirect( buffer, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tpassEncoderGPU.drawIndexed( indexCount, instanceCount, firstIndex, 0, 0 );\n\n\t\t\t}\n\n\t\t\tinfo.update( object, indexCount, instanceCount );\n\n\t\t} else {\n\n\t\t\tconst { vertexCount, instanceCount, firstVertex } = drawParams;\n\n\t\t\tconst indirect = renderObject.getIndirect();\n\n\t\t\tif ( indirect !== null ) {\n\n\t\t\t\tconst buffer = this.get( indirect ).buffer;\n\n\t\t\t\tpassEncoderGPU.drawIndirect( buffer, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tpassEncoderGPU.draw( vertexCount, instanceCount, firstVertex, 0 );\n\n\t\t\t}\n\n\t\t\tinfo.update( object, vertexCount, instanceCount );\n\n\t\t}\n\n\t}\n\n\t// cache key\n\n\tneedsRenderUpdate( renderObject ) {\n\n\t\tconst data = this.get( renderObject );\n\n\t\tconst { object, material } = renderObject;\n\n\t\tconst utils = this.utils;\n\n\t\tconst sampleCount = utils.getSampleCountRenderContext( renderObject.context );\n\t\tconst colorSpace = utils.getCurrentColorSpace( renderObject.context );\n\t\tconst colorFormat = utils.getCurrentColorFormat( renderObject.context );\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );\n\t\tconst primitiveTopology = utils.getPrimitiveTopology( object, material );\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( data.material !== material || data.materialVersion !== material.version ||\n\t\t\tdata.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||\n\t\t\tdata.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||\n\t\t\tdata.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||\n\t\t\tdata.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||\n\t\t\tdata.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||\n\t\t\tdata.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||\n\t\t\tdata.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||\n\t\t\tdata.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage ||\n\t\t\tdata.sampleCount !== sampleCount || data.colorSpace !== colorSpace ||\n\t\t\tdata.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat ||\n\t\t\tdata.primitiveTopology !== primitiveTopology ||\n\t\t\tdata.clippingContextCacheKey !== renderObject.clippingContextCacheKey\n\t\t) {\n\n\t\t\tdata.material = material; data.materialVersion = material.version;\n\t\t\tdata.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;\n\t\t\tdata.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;\n\t\t\tdata.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;\n\t\t\tdata.colorWrite = material.colorWrite;\n\t\t\tdata.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;\n\t\t\tdata.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;\n\t\t\tdata.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;\n\t\t\tdata.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;\n\t\t\tdata.side = material.side; data.alphaToCoverage = material.alphaToCoverage;\n\t\t\tdata.sampleCount = sampleCount;\n\t\t\tdata.colorSpace = colorSpace;\n\t\t\tdata.colorFormat = colorFormat;\n\t\t\tdata.depthStencilFormat = depthStencilFormat;\n\t\t\tdata.primitiveTopology = primitiveTopology;\n\t\t\tdata.clippingContextCacheKey = renderObject.clippingContextCacheKey;\n\n\t\t\tneedsUpdate = true;\n\n\t\t}\n\n\t\treturn needsUpdate;\n\n\t}\n\n\tgetRenderCacheKey( renderObject ) {\n\n\t\tconst { object, material } = renderObject;\n\n\t\tconst utils = this.utils;\n\t\tconst renderContext = renderObject.context;\n\n\t\treturn [\n\t\t\tmaterial.transparent, material.blending, material.premultipliedAlpha,\n\t\t\tmaterial.blendSrc, material.blendDst, material.blendEquation,\n\t\t\tmaterial.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,\n\t\t\tmaterial.colorWrite,\n\t\t\tmaterial.depthWrite, material.depthTest, material.depthFunc,\n\t\t\tmaterial.stencilWrite, material.stencilFunc,\n\t\t\tmaterial.stencilFail, material.stencilZFail, material.stencilZPass,\n\t\t\tmaterial.stencilFuncMask, material.stencilWriteMask,\n\t\t\tmaterial.side,\n\t\t\tutils.getSampleCountRenderContext( renderContext ),\n\t\t\tutils.getCurrentColorSpace( renderContext ), utils.getCurrentColorFormat( renderContext ), utils.getCurrentDepthStencilFormat( renderContext ),\n\t\t\tutils.getPrimitiveTopology( object, material ),\n\t\t\trenderObject.getGeometryCacheKey(),\n\t\t\trenderObject.clippingContextCacheKey\n\t\t].join();\n\n\t}\n\n\t// textures\n\n\tcreateSampler( texture ) {\n\n\t\tthis.textureUtils.createSampler( texture );\n\n\t}\n\n\tdestroySampler( texture ) {\n\n\t\tthis.textureUtils.destroySampler( texture );\n\n\t}\n\n\tcreateDefaultTexture( texture ) {\n\n\t\tthis.textureUtils.createDefaultTexture( texture );\n\n\t}\n\n\tcreateTexture( texture, options ) {\n\n\t\tthis.textureUtils.createTexture( texture, options );\n\n\t}\n\n\tupdateTexture( texture, options ) {\n\n\t\tthis.textureUtils.updateTexture( texture, options );\n\n\t}\n\n\tgenerateMipmaps( texture ) {\n\n\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t}\n\n\tdestroyTexture( texture ) {\n\n\t\tthis.textureUtils.destroyTexture( texture );\n\n\t}\n\n\tcopyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\treturn this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );\n\n\t}\n\n\n\tinitTimestampQuery( renderContext, descriptor ) {\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( ! renderContextData.timeStampQuerySet ) {\n\n\n\t\t\tconst type = renderContext.isComputeNode ? 'compute' : 'render';\n\t\t\tconst timeStampQuerySet = this.device.createQuerySet( { type: 'timestamp', count: 2, label: `timestamp_${type}_${renderContext.id}` } );\n\n\t\t\tconst timestampWrites = {\n\t\t\t\tquerySet: timeStampQuerySet,\n\t\t\t\tbeginningOfPassWriteIndex: 0, // Write timestamp in index 0 when pass begins.\n\t\t\t\tendOfPassWriteIndex: 1, // Write timestamp in index 1 when pass ends.\n\t\t\t};\n\n\t\t\tObject.assign( descriptor, { timestampWrites } );\n\n\t\t\trenderContextData.timeStampQuerySet = timeStampQuerySet;\n\n\t\t}\n\n\t}\n\n\t// timestamp utils\n\n\tprepareTimestampBuffer( renderContext, encoder ) {\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\n\t\tconst size = 2 * BigInt64Array.BYTES_PER_ELEMENT;\n\n\t\tif ( renderContextData.currentTimestampQueryBuffers === undefined ) {\n\n\t\t\trenderContextData.currentTimestampQueryBuffers = {\n\t\t\t\tresolveBuffer: this.device.createBuffer( {\n\t\t\t\t\tlabel: 'timestamp resolve buffer',\n\t\t\t\t\tsize: size,\n\t\t\t\t\tusage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,\n\t\t\t\t} ),\n\t\t\t\tresultBuffer: this.device.createBuffer( {\n\t\t\t\t\tlabel: 'timestamp result buffer',\n\t\t\t\t\tsize: size,\n\t\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n\t\t\t\t} )\n\t\t\t};\n\n\t\t}\n\n\t\tconst { resolveBuffer, resultBuffer } = renderContextData.currentTimestampQueryBuffers;\n\n\n\t\tencoder.resolveQuerySet( renderContextData.timeStampQuerySet, 0, 2, resolveBuffer, 0 );\n\n\t\tif ( resultBuffer.mapState === 'unmapped' ) {\n\n\t\t\tencoder.copyBufferToBuffer( resolveBuffer, 0, resultBuffer, 0, size );\n\n\t\t}\n\n\t}\n\n\tasync resolveTimestampAsync( renderContext, type = 'render' ) {\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( renderContextData.currentTimestampQueryBuffers === undefined ) return;\n\n\t\tconst { resultBuffer } = renderContextData.currentTimestampQueryBuffers;\n\n\t\tawait this.device.queue.onSubmittedWorkDone();\n\n\t\tif ( resultBuffer.mapState === 'unmapped' ) {\n\n\t\t\tresultBuffer.mapAsync( GPUMapMode.READ ).then( () => {\n\n\t\t\t\tconst times = new BigUint64Array( resultBuffer.getMappedRange() );\n\t\t\t\tconst duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;\n\n\n\t\t\t\tthis.renderer.info.updateTimestamp( type, duration );\n\n\t\t\t\tresultBuffer.unmap();\n\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// node builder\n\n\tcreateNodeBuilder( object, renderer ) {\n\n\t\treturn new WGSLNodeBuilder( object, renderer );\n\n\t}\n\n\t// program\n\n\tcreateProgram( program ) {\n\n\t\tconst programGPU = this.get( program );\n\n\t\tprogramGPU.module = {\n\t\t\tmodule: this.device.createShaderModule( { code: program.code, label: program.stage } ),\n\t\t\tentryPoint: 'main'\n\t\t};\n\n\t}\n\n\tdestroyProgram( program ) {\n\n\t\tthis.delete( program );\n\n\t}\n\n\t// pipelines\n\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tthis.pipelineUtils.createRenderPipeline( renderObject, promises );\n\n\t}\n\n\tcreateComputePipeline( computePipeline, bindings ) {\n\n\t\tthis.pipelineUtils.createComputePipeline( computePipeline, bindings );\n\n\t}\n\n\tbeginBundle( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\trenderContextData._currentPass = renderContextData.currentPass;\n\t\trenderContextData._currentSets = renderContextData.currentSets;\n\n\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\t\trenderContextData.currentPass = this.pipelineUtils.createBundleEncoder( renderContext );\n\n\t}\n\n\tfinishBundle( renderContext, bundle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tconst bundleEncoder = renderContextData.currentPass;\n\t\tconst bundleGPU = bundleEncoder.finish();\n\n\t\tthis.get( bundle ).bundleGPU = bundleGPU;\n\n\t\t// restore render pass state\n\n\t\trenderContextData.currentSets = renderContextData._currentSets;\n\t\trenderContextData.currentPass = renderContextData._currentPass;\n\n\t}\n\n\taddBundle( renderContext, bundle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\trenderContextData.renderBundles.push( this.get( bundle ).bundleGPU );\n\n\t}\n\n\t// bindings\n\n\tcreateBindings( bindGroup, bindings, cacheIndex, version ) {\n\n\t\tthis.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );\n\n\t}\n\n\tupdateBindings( bindGroup, bindings, cacheIndex, version ) {\n\n\t\tthis.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );\n\n\t}\n\n\tupdateBinding( binding ) {\n\n\t\tthis.bindingUtils.updateBinding( binding );\n\n\t}\n\n\t// attributes\n\n\tcreateIndexAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\tcreateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\tcreateStorageAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\tcreateIndirectStorageAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\tupdateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.updateAttribute( attribute );\n\n\t}\n\n\tdestroyAttribute( attribute ) {\n\n\t\tthis.attributeUtils.destroyAttribute( attribute );\n\n\t}\n\n\t// canvas\n\n\tupdateSize() {\n\n\t\tthis.colorBuffer = this.textureUtils.getColorBuffer();\n\t\tthis.defaultRenderPassdescriptor = null;\n\n\t}\n\n\t// utils public\n\n\tgetMaxAnisotropy() {\n\n\t\treturn 16;\n\n\t}\n\n\thasFeature( name ) {\n\n\t\treturn this.device.features.has( name );\n\n\t}\n\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\tlet dstX = 0;\n\t\tlet dstY = 0;\n\t\tlet dstLayer = 0;\n\n\t\tlet srcX = 0;\n\t\tlet srcY = 0;\n\t\tlet srcLayer = 0;\n\n\t\tlet srcWidth = srcTexture.image.width;\n\t\tlet srcHeight = srcTexture.image.height;\n\n\t\tif ( srcRegion !== null ) {\n\n\t\t\tsrcX = srcRegion.x;\n\t\t\tsrcY = srcRegion.y;\n\t\t\tsrcLayer = srcRegion.z || 0;\n\t\t\tsrcWidth = srcRegion.width;\n\t\t\tsrcHeight = srcRegion.height;\n\n\t\t}\n\n\t\tif ( dstPosition !== null ) {\n\n\t\t\tdstX = dstPosition.x;\n\t\t\tdstY = dstPosition.y;\n\t\t\tdstLayer = dstPosition.z || 0;\n\n\t\t}\n\n\t\tconst encoder = this.device.createCommandEncoder( { label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id } );\n\n\t\tconst sourceGPU = this.get( srcTexture ).texture;\n\t\tconst destinationGPU = this.get( dstTexture ).texture;\n\n\t\tencoder.copyTextureToTexture(\n\t\t\t{\n\t\t\t\ttexture: sourceGPU,\n\t\t\t\tmipLevel: level,\n\t\t\t\torigin: { x: srcX, y: srcY, z: srcLayer }\n\t\t\t},\n\t\t\t{\n\t\t\t\ttexture: destinationGPU,\n\t\t\t\tmipLevel: level,\n\t\t\t\torigin: { x: dstX, y: dstY, z: dstLayer }\n\t\t\t},\n\t\t\t[\n\t\t\t\tsrcWidth,\n\t\t\t\tsrcHeight,\n\t\t\t\t1\n\t\t\t]\n\t\t);\n\n\t\tthis.device.queue.submit( [ encoder.finish() ] );\n\n\t}\n\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tlet sourceGPU = null;\n\n\t\tif ( renderContext.renderTarget ) {\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\tsourceGPU = this.get( renderContext.depthTexture ).texture;\n\n\t\t\t} else {\n\n\t\t\t\tsourceGPU = this.get( renderContext.textures[ 0 ] ).texture;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\tsourceGPU = this.textureUtils.getDepthBuffer( renderContext.depth, renderContext.stencil );\n\n\t\t\t} else {\n\n\t\t\t\tsourceGPU = this.context.getCurrentTexture();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst destinationGPU = this.get( texture ).texture;\n\n\t\tif ( sourceGPU.format !== destinationGPU.format ) {\n\n\t\t\tconsole.error( 'WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet encoder;\n\n\t\tif ( renderContextData.currentPass ) {\n\n\t\t\trenderContextData.currentPass.end();\n\n\t\t\tencoder = renderContextData.encoder;\n\n\t\t} else {\n\n\t\t\tencoder = this.device.createCommandEncoder( { label: 'copyFramebufferToTexture_' + texture.id } );\n\n\t\t}\n\n\t\tencoder.copyTextureToTexture(\n\t\t\t{\n\t\t\t\ttexture: sourceGPU,\n\t\t\t\torigin: [ rectangle.x, rectangle.y, 0 ],\n\t\t\t},\n\t\t\t{\n\t\t\t\ttexture: destinationGPU\n\t\t\t},\n\t\t\t[\n\t\t\t\trectangle.z,\n\t\t\t\trectangle.w\n\t\t\t]\n\t\t);\n\n\t\tif ( texture.generateMipmaps ) this.textureUtils.generateMipmaps( texture );\n\n\t\tif ( renderContextData.currentPass ) {\n\n\t\t\tconst { descriptor } = renderContextData;\n\n\t\t\tfor ( let i = 0; i < descriptor.colorAttachments.length; i ++ ) {\n\n\t\t\t\tdescriptor.colorAttachments[ i ].loadOp = GPULoadOp.Load;\n\n\t\t\t}\n\n\t\t\tif ( renderContext.depth ) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\tif ( renderContext.stencil ) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\n\t\t\trenderContextData.currentPass = encoder.beginRenderPass( descriptor );\n\t\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\n\t\t\tif ( renderContext.viewport ) {\n\n\t\t\t\tthis.updateViewport( renderContext );\n\n\t\t\t}\n\n\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\t\trenderContextData.currentPass.setScissorRect( x, y, width, height );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.device.queue.submit( [ encoder.finish() ] );\n\n\t\t}\n\n\t}\n\n}\n\nclass IESSpotLight extends SpotLight {\n\n\tconstructor( color, intensity, distance, angle, penumbra, decay ) {\n\n\t\tsuper( color, intensity, distance, angle, penumbra, decay );\n\n\t\tthis.iesMap = null;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.iesMap = source.iesMap;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass StandardNodeLibrary extends NodeLibrary {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.addMaterial( MeshPhongNodeMaterial, 'MeshPhongMaterial' );\n\t\tthis.addMaterial( MeshStandardNodeMaterial, 'MeshStandardMaterial' );\n\t\tthis.addMaterial( MeshPhysicalNodeMaterial, 'MeshPhysicalMaterial' );\n\t\tthis.addMaterial( MeshToonNodeMaterial, 'MeshToonMaterial' );\n\t\tthis.addMaterial( MeshBasicNodeMaterial, 'MeshBasicMaterial' );\n\t\tthis.addMaterial( MeshLambertNodeMaterial, 'MeshLambertMaterial' );\n\t\tthis.addMaterial( MeshNormalNodeMaterial, 'MeshNormalMaterial' );\n\t\tthis.addMaterial( MeshMatcapNodeMaterial, 'MeshMatcapMaterial' );\n\t\tthis.addMaterial( LineBasicNodeMaterial, 'LineBasicMaterial' );\n\t\tthis.addMaterial( LineDashedNodeMaterial, 'LineDashedMaterial' );\n\t\tthis.addMaterial( PointsNodeMaterial, 'PointsMaterial' );\n\t\tthis.addMaterial( SpriteNodeMaterial, 'SpriteMaterial' );\n\t\tthis.addMaterial( ShadowNodeMaterial, 'ShadowMaterial' );\n\n\t\tthis.addLight( PointLightNode, PointLight );\n\t\tthis.addLight( DirectionalLightNode, DirectionalLight );\n\t\tthis.addLight( RectAreaLightNode, RectAreaLight );\n\t\tthis.addLight( SpotLightNode, SpotLight );\n\t\tthis.addLight( AmbientLightNode, AmbientLight );\n\t\tthis.addLight( HemisphereLightNode, HemisphereLight );\n\t\tthis.addLight( LightProbeNode, LightProbe );\n\t\tthis.addLight( IESSpotLightNode, IESSpotLight );\n\n\t\tthis.addToneMapping( linearToneMapping, LinearToneMapping );\n\t\tthis.addToneMapping( reinhardToneMapping, ReinhardToneMapping );\n\t\tthis.addToneMapping( cineonToneMapping, CineonToneMapping );\n\t\tthis.addToneMapping( acesFilmicToneMapping, ACESFilmicToneMapping );\n\t\tthis.addToneMapping( agxToneMapping, AgXToneMapping );\n\t\tthis.addToneMapping( neutralToneMapping, NeutralToneMapping );\n\n\t}\n\n}\n\n/*\nconst debugHandler = {\n\n\tget: function ( target, name ) {\n\n\t\t// Add |update\n\t\tif ( /^(create|destroy)/.test( name ) ) console.log( 'WebGPUBackend.' + name );\n\n\t\treturn target[ name ];\n\n\t}\n\n};\n*/\nclass WebGPURenderer extends Renderer {\n\n\tconstructor( parameters = {} ) {\n\n\t\tlet BackendClass;\n\n\t\tif ( parameters.forceWebGL ) {\n\n\t\t\tBackendClass = WebGLBackend;\n\n\t\t} else {\n\n\t\t\tBackendClass = WebGPUBackend;\n\n\t\t\tparameters.getFallback = () => {\n\n\t\t\t\tconsole.warn( 'THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.' );\n\n\t\t\t\treturn new WebGLBackend( parameters );\n\n\t\t\t};\n\n\t\t}\n\n\t\tconst backend = new BackendClass( parameters );\n\n\t\t//super( new Proxy( backend, debugHandler ) );\n\t\tsuper( backend, parameters );\n\n\t\tthis.library = new StandardNodeLibrary();\n\n\t\tthis.isWebGPURenderer = true;\n\n\t}\n\n}\n\nclass BundleGroup extends Group {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBundleGroup = true;\n\n\t\tthis.type = 'BundleGroup';\n\n\t\tthis.static = true;\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n}\n\nconst _material = /*@__PURE__*/ new NodeMaterial();\nconst _quadMesh = /*@__PURE__*/ new QuadMesh( _material );\n\nclass PostProcessing {\n\n\tconstructor( renderer, outputNode = vec4( 0, 0, 1, 1 ) ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.outputNode = outputNode;\n\n\t\tthis.outputColorTransform = true;\n\n\t\tthis.needsUpdate = true;\n\n\t\t_material.name = 'PostProcessing';\n\n\t}\n\n\trender() {\n\n\t\tthis.update();\n\n\t\tconst renderer = this.renderer;\n\n\t\tconst toneMapping = renderer.toneMapping;\n\t\tconst outputColorSpace = renderer.outputColorSpace;\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.outputColorSpace = LinearSRGBColorSpace;\n\n\t\t//\n\n\t\t_quadMesh.render( renderer );\n\n\t\t//\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.outputColorSpace = outputColorSpace;\n\n\t}\n\n\tupdate() {\n\n\t\tif ( this.needsUpdate === true ) {\n\n\t\t\tconst renderer = this.renderer;\n\n\t\t\tconst toneMapping = renderer.toneMapping;\n\t\t\tconst outputColorSpace = renderer.outputColorSpace;\n\n\t\t\t_quadMesh.material.fragmentNode = this.outputColorTransform === true ? renderOutput( this.outputNode, toneMapping, outputColorSpace ) : this.outputNode.context( { toneMapping, outputColorSpace } );\n\t\t\t_quadMesh.material.needsUpdate = true;\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t}\n\n\t}\n\n\tasync renderAsync() {\n\n\t\tthis.update();\n\n\t\tconst renderer = this.renderer;\n\n\t\tconst toneMapping = renderer.toneMapping;\n\t\tconst outputColorSpace = renderer.outputColorSpace;\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.outputColorSpace = LinearSRGBColorSpace;\n\n\t\t//\n\n\t\tawait _quadMesh.renderAsync( renderer );\n\n\t\t//\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.outputColorSpace = outputColorSpace;\n\n\t}\n\n}\n\n// renderer state\n\nfunction saveRendererState( renderer, state = {} ) {\n\n\tstate.toneMapping = renderer.toneMapping;\n\tstate.toneMappingExposure = renderer.toneMappingExposure;\n\tstate.outputColorSpace = renderer.outputColorSpace;\n\tstate.renderTarget = renderer.getRenderTarget();\n\tstate.activeCubeFace = renderer.getActiveCubeFace();\n\tstate.activeMipmapLevel = renderer.getActiveMipmapLevel();\n\tstate.renderObjectFunction = renderer.getRenderObjectFunction();\n\tstate.pixelRatio = renderer.getPixelRatio();\n\tstate.mrt = renderer.getMRT();\n\tstate.clearColor = renderer.getClearColor( state.clearColor || new Color() );\n\tstate.clearAlpha = renderer.getClearAlpha();\n\tstate.autoClear = renderer.autoClear;\n\tstate.scissorTest = renderer.getScissorTest();\n\n\treturn state;\n\n}\n\nfunction resetRendererState( renderer, state ) {\n\n\tstate = saveRendererState( renderer, state );\n\n\trenderer.setMRT( null );\n\trenderer.setRenderObjectFunction( null );\n\trenderer.setClearColor( 0x000000, 1 );\n\trenderer.autoClear = true;\n\n\treturn state;\n\n}\n\nfunction restoreRendererState( renderer, state ) {\n\n\trenderer.toneMapping = state.toneMapping;\n\trenderer.toneMappingExposure = state.toneMappingExposure;\n\trenderer.outputColorSpace = state.outputColorSpace;\n\trenderer.setRenderTarget( state.renderTarget, state.activeCubeFace, state.activeMipmapLevel );\n\trenderer.setRenderObjectFunction( state.renderObjectFunction );\n\trenderer.setPixelRatio( state.pixelRatio );\n\trenderer.setMRT( state.mrt );\n\trenderer.setClearColor( state.clearColor, state.clearAlpha );\n\trenderer.autoClear = state.autoClear;\n\trenderer.setScissorTest( state.scissorTest );\n\n}\n\n// renderer and scene state\n\nfunction saveRendererAndSceneState( renderer, scene, state = {} ) {\n\n\tstate = saveRendererState( renderer, state );\n\tstate.background = scene.background;\n\tstate.backgroundNode = scene.backgroundNode;\n\tstate.overrideMaterial = scene.overrideMaterial;\n\n\treturn state;\n\n}\n\nfunction resetRendererAndSceneState( renderer, scene, state ) {\n\n\tstate = saveRendererAndSceneState( renderer, scene, state );\n\n\tscene.background = null;\n\tscene.backgroundNode = null;\n\tscene.overrideMaterial = null;\n\n\treturn state;\n\n}\n\nfunction restoreRendererAndSceneState( renderer, scene, state ) {\n\n\trestoreRendererState( renderer, state );\n\n\tscene.background = state.background;\n\tscene.backgroundNode = state.backgroundNode;\n\tscene.overrideMaterial = state.overrideMaterial;\n\n}\n\nvar PostProcessingUtils = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tresetRendererAndSceneState: resetRendererAndSceneState,\n\tresetRendererState: resetRendererState,\n\trestoreRendererAndSceneState: restoreRendererAndSceneState,\n\trestoreRendererState: restoreRendererState,\n\tsaveRendererAndSceneState: saveRendererAndSceneState,\n\tsaveRendererState: saveRendererState\n});\n\nclass StorageTexture extends Texture {\n\n\tconstructor( width = 1, height = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.image = { width, height };\n\n\t\tthis.magFilter = LinearFilter;\n\t\tthis.minFilter = LinearFilter;\n\n\t\tthis.isStorageTexture = true;\n\n\t}\n\n}\n\nclass IndirectStorageBufferAttribute extends StorageBufferAttribute {\n\n\tconstructor( array, itemSize ) {\n\n\t\tsuper( array, itemSize, Uint32Array );\n\n\t\tthis.isIndirectStorageBufferAttribute = true;\n\n\t}\n\n}\n\nclass NodeLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.textures = {};\n\t\tthis.nodes = {};\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, ( text ) => {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( this.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tthis.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparseNodes( json ) {\n\n\t\tconst nodes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( const nodeJSON of json ) {\n\n\t\t\t\tconst { uuid, type } = nodeJSON;\n\n\t\t\t\tnodes[ uuid ] = this.createNodeFromType( type );\n\t\t\t\tnodes[ uuid ].uuid = uuid;\n\n\t\t\t}\n\n\t\t\tconst meta = { nodes, textures: this.textures };\n\n\t\t\tfor ( const nodeJSON of json ) {\n\n\t\t\t\tnodeJSON.meta = meta;\n\n\t\t\t\tconst node = nodes[ nodeJSON.uuid ];\n\t\t\t\tnode.deserialize( nodeJSON );\n\n\t\t\t\tdelete nodeJSON.meta;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodes;\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst node = this.createNodeFromType( json.type );\n\t\tnode.uuid = json.uuid;\n\n\t\tconst nodes = this.parseNodes( json.nodes );\n\t\tconst meta = { nodes, textures: this.textures };\n\n\t\tjson.meta = meta;\n\n\t\tnode.deserialize( json );\n\n\t\tdelete json.meta;\n\n\t\treturn node;\n\n\t}\n\n\tsetTextures( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\tcreateNodeFromType( type ) {\n\n\t\tif ( this.nodes[ type ] === undefined ) {\n\n\t\t\tconsole.error( 'THREE.NodeLoader: Node type not found:', type );\n\t\t\treturn float();\n\n\t\t}\n\n\t\treturn nodeObject( new this.nodes[ type ]() );\n\n\t}\n\n}\n\nclass NodeMaterialLoader extends MaterialLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.nodes = {};\n\t\tthis.nodeMaterials = {};\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst material = super.parse( json );\n\n\t\tconst nodes = this.nodes;\n\t\tconst inputNodes = json.inputNodes;\n\n\t\tfor ( const property in inputNodes ) {\n\n\t\t\tconst uuid = inputNodes[ property ];\n\n\t\t\tmaterial[ property ] = nodes[ uuid ];\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\tsetNodeMaterials( value ) {\n\n\t\tthis.nodeMaterials = value;\n\t\treturn this;\n\n\t}\n\n\tcreateMaterialFromType( type ) {\n\n\t\tconst materialClass = this.nodeMaterials[ type ];\n\n\t\tif ( materialClass !== undefined ) {\n\n\t\t\treturn new materialClass();\n\n\t\t}\n\n\t\treturn super.createMaterialFromType( type );\n\n\t}\n\n}\n\nclass NodeObjectLoader extends ObjectLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.nodes = {};\n\t\tthis.nodeMaterials = {};\n\n\t\tthis._nodesJSON = null;\n\n\t}\n\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\tsetNodeMaterials( value ) {\n\n\t\tthis.nodeMaterials = value;\n\t\treturn this;\n\n\t}\n\n\tparse( json, onLoad ) {\n\n\t\tthis._nodesJSON = json.nodes;\n\n\t\tconst data = super.parse( json, onLoad );\n\n\t\tthis._nodesJSON = null; // dispose\n\n\t\treturn data;\n\n\t}\n\n\tparseNodes( json, textures ) {\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new NodeLoader();\n\t\t\tloader.setNodes( this.nodes );\n\t\t\tloader.setTextures( textures );\n\n\t\t\treturn loader.parseNodes( json );\n\n\t\t}\n\n\t\treturn {};\n\n\t}\n\n\tparseMaterials( json, textures ) {\n\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst nodes = this.parseNodes( this._nodesJSON, textures );\n\n\t\t\tconst loader = new NodeMaterialLoader();\n\t\t\tloader.setTextures( textures );\n\t\t\tloader.setNodes( nodes );\n\t\t\tloader.setNodeMaterials( this.nodeMaterials );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tmaterials[ data.uuid ] = loader.parse( data );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n}\n\nclass ClippingGroup extends Group {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isClippingGroup = true;\n\t\tthis.clippingPlanes = [];\n\t\tthis.enabled = true;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t}\n\n}\n\nexport { ACESFilmicToneMapping, AONode, AddEquation, AddOperation, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightNode, AnalyticLightNode, ArrayElementNode, AssignNode, AttributeNode, BackSide, BasicEnvironmentNode, BasicShadowMap, BatchNode, BoxGeometry, BufferAttribute, BufferAttributeNode, BufferGeometry, BufferNode, BumpMapNode, BundleGroup, BypassNode, ByteType, CacheNode, CineonToneMapping, ClampToEdgeWrapping, ClippingGroup, CodeNode, Color, ColorManagement, ColorSpaceNode, ComputeNode, ConstNode, ContextNode, ConvertNode, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureNode, CubeUVReflectionMapping, CullFaceBack, CullFaceFront, CullFaceNone, CustomBlending, DataArrayTexture, DataTexture, DecrementStencilOp, DecrementWrapStencilOp, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightNode, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicDrawUsage, EnvironmentNode, EqualCompare, EqualDepth, EqualStencilFunc, EquirectUVNode, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExpressionNode, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, FogExp2Node, FogNode, FogRangeNode, FramebufferTexture, FrontFacingNode, FrontSide, Frustum, FunctionCallNode, FunctionNode, FunctionOverloadingNode, GLSLNodeParser, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, Group, HalfFloatType, HemisphereLight, HemisphereLightNode, IESSpotLight, IESSpotLightNode, IncrementStencilOp, IncrementWrapStencilOp, IndexNode, IndirectStorageBufferAttribute, InstanceNode, InstancedBufferAttribute, InstancedInterleavedBuffer, InstancedMeshNode, InstancedPointsNodeMaterial, IntType, InterleavedBuffer, InterleavedBufferAttribute, InvertStencilOp, IrradianceNode, JoinNode, KeepStencilOp, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, LightProbe, LightProbeNode, Lighting, LightingContextNode, LightingModel, LightingNode, LightsNode, Line2NodeMaterial, LineBasicMaterial, LineBasicNodeMaterial, LineDashedMaterial, LineDashedNodeMaterial, LinearFilter, LinearMipMapLinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, Loader, LoopNode, LuminanceAlphaFormat, LuminanceFormat, MRTNode, MatcapUVNode, Material, MaterialLoader, MaterialNode, MaterialReferenceNode, MathUtils, Matrix3, Matrix4, MaxEquation, MaxMipLevelNode, Mesh, MeshBasicMaterial, MeshBasicNodeMaterial, MeshLambertMaterial, MeshLambertNodeMaterial, MeshMatcapMaterial, MeshMatcapNodeMaterial, MeshNormalMaterial, MeshNormalNodeMaterial, MeshPhongMaterial, MeshPhongNodeMaterial, MeshPhysicalMaterial, MeshPhysicalNodeMaterial, MeshSSSNodeMaterial, MeshStandardMaterial, MeshStandardNodeMaterial, MeshToonMaterial, MeshToonNodeMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, ModelNode, ModelViewProjectionNode, MorphNode, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, Node, NodeAccess, NodeAttribute, NodeBuilder, NodeCache, NodeCode, NodeFrame, NodeFunctionInput, NodeLoader, NodeMaterial, NodeMaterialLoader, NodeMaterialObserver, NodeObjectLoader, NodeShaderStage, NodeType, NodeUniform, NodeUpdateType, NodeUtils, NodeVar, NodeVarying, NormalBlending, NormalMapNode, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, Object3D, Object3DNode, ObjectLoader, ObjectSpaceNormalMap, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, OutputStructNode, PCFShadowMap, PMREMGenerator, PMREMNode, ParameterNode, PassNode, PerspectiveCamera, PhongLightingModel, PhysicalLightingModel, Plane, PointLight, PointLightNode, PointUVNode, PointsMaterial, PointsNodeMaterial, PostProcessing, PostProcessingUtils, PosterizeNode, PropertyNode, QuadMesh, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBFormat, RGBIntegerFormat, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RTTNode, RangeNode, RectAreaLight, RectAreaLightNode, RedFormat, RedIntegerFormat, ReferenceNode, ReflectorNode, ReinhardToneMapping, RemapNode, RenderOutputNode, RenderTarget, RendererReferenceNode, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RotateNode, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, SceneNode, ScreenNode, ScriptableNode, ScriptableValueNode, SetNode, ShadowMaterial, ShadowNode, ShadowNodeMaterial, ShortType, SkinningNode, SphereGeometry, SplitNode, SpotLight, SpotLightNode, SpriteMaterial, SpriteNodeMaterial, SpriteSheetUVNode, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StackNode, StaticDrawUsage, StorageArrayElementNode, StorageBufferAttribute, StorageBufferNode, StorageInstancedBufferAttribute, StorageTexture, StorageTextureNode, SubtractEquation, SubtractiveBlending, TSL, TangentSpaceNormalMap, TempNode, Texture, Texture3DNode, TextureNode, TextureSizeNode, ToneMappingNode, ToonOutlinePassNode, TriplanarTexturesNode, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, UniformArrayNode, UniformGroupNode, UniformNode, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, UserDataNode, VSMShadowMap, VarNode, VaryingNode, Vector2, Vector3, Vector4, VertexColorNode, ViewportDepthNode, ViewportDepthTextureNode, ViewportSharedTextureNode, ViewportTextureNode, VolumeNodeMaterial, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGPUCoordinateSystem, WebGPURenderer, ZeroFactor, ZeroStencilOp, createCanvasElement, defaultBuildStages, defaultShaderStages, shaderStages, vectorComponents };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}