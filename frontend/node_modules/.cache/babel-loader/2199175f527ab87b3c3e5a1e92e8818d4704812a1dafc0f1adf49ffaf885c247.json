{"ast":null,"code":"// frontend/src/services/etymologyService.js\n\n// frontend/src/services/etymologyService.js\n\nimport { etymologyAPI } from './etymologyAPI';\nimport { LOCAL_ETYMOLOGY_DATA } from './localEtymologyData'; // We'll create this next\n//import {analyzeWord} from './etymologyService.js'\n\nexport class EtymologyService {\n  async getWordEtymology(word) {\n    try {\n      // First try to get data from external API\n      const apiData = await etymologyAPI.getWordEtymology(word);\n      if (apiData) {\n        return this.formatApiData(apiData);\n      }\n\n      // Fall back to local data if API fails or returns no data\n      return this.getLocalEtymology(word);\n    } catch (error) {\n      console.error('Etymology service error:', error);\n      return this.getLocalEtymology(word);\n    }\n  }\n  formatApiData(apiData) {\n    // This will convert external API data to match your expected format\n    return {\n      word: apiData.word,\n      pie: apiData.protoIndoEuropeanRoot,\n      evolution: this.formatEvolutionData(apiData.evolution),\n      modernCognates: apiData.cognates,\n      semanticDevelopment: apiData.meaningDevelopment\n    };\n  }\n  getLocalEtymology(word) {\n    // Your existing local etymology logic\n    return {\n      word,\n      pie: LOCAL_ETYMOLOGY_DATA.findPIERoot(word),\n      evolution: LOCAL_ETYMOLOGY_DATA.getEvolution(word),\n      modernCognates: LOCAL_ETYMOLOGY_DATA.getCognates(word),\n      semanticDevelopment: LOCAL_ETYMOLOGY_DATA.getSemanticDevelopment(word)\n    };\n  }\n  formatEvolutionData(evolution) {\n    // Convert API evolution data to your format\n    return (evolution === null || evolution === void 0 ? void 0 : evolution.map(stage => ({\n      period: stage.timePeriod,\n      years: stage.dateRange,\n      form: stage.wordForm,\n      changes: stage.soundChanges\n    }))) || [];\n  }\n}\nexport const etymologyService = new EtymologyService();","map":{"version":3,"names":["etymologyAPI","LOCAL_ETYMOLOGY_DATA","EtymologyService","getWordEtymology","word","apiData","formatApiData","getLocalEtymology","error","console","pie","protoIndoEuropeanRoot","evolution","formatEvolutionData","modernCognates","cognates","semanticDevelopment","meaningDevelopment","findPIERoot","getEvolution","getCognates","getSemanticDevelopment","map","stage","period","timePeriod","years","dateRange","form","wordForm","changes","soundChanges","etymologyService"],"sources":["/Users/BrooksCole/Documents/reading-community/frontend/src/services/etymologyService.js"],"sourcesContent":["// frontend/src/services/etymologyService.js\n\n// frontend/src/services/etymologyService.js\n\nimport { etymologyAPI } from './etymologyAPI';\nimport { LOCAL_ETYMOLOGY_DATA } from './localEtymologyData'; // We'll create this next\n//import {analyzeWord} from './etymologyService.js'\n\nexport class EtymologyService {\n  async getWordEtymology(word) {\n    try {\n      // First try to get data from external API\n      const apiData = await etymologyAPI.getWordEtymology(word);\n      if (apiData) {\n        return this.formatApiData(apiData);\n      }\n\n      // Fall back to local data if API fails or returns no data\n      return this.getLocalEtymology(word);\n    } catch (error) {\n      console.error('Etymology service error:', error);\n      return this.getLocalEtymology(word);\n    }\n  }\n\n  formatApiData(apiData) {\n    // This will convert external API data to match your expected format\n    return {\n      word: apiData.word,\n      pie: apiData.protoIndoEuropeanRoot,\n      evolution: this.formatEvolutionData(apiData.evolution),\n      modernCognates: apiData.cognates,\n      semanticDevelopment: apiData.meaningDevelopment\n    };\n  }\n\n  getLocalEtymology(word) {\n    // Your existing local etymology logic\n    return {\n      word,\n      pie: LOCAL_ETYMOLOGY_DATA.findPIERoot(word),\n      evolution: LOCAL_ETYMOLOGY_DATA.getEvolution(word),\n      modernCognates: LOCAL_ETYMOLOGY_DATA.getCognates(word),\n      semanticDevelopment: LOCAL_ETYMOLOGY_DATA.getSemanticDevelopment(word)\n    };\n  }\n\n  formatEvolutionData(evolution) {\n    // Convert API evolution data to your format\n    return evolution?.map(stage => ({\n      period: stage.timePeriod,\n      years: stage.dateRange,\n      form: stage.wordForm,\n      changes: stage.soundChanges\n    })) || [];\n  }\n}\n\nexport const etymologyService = new EtymologyService();\n\n"],"mappings":"AAAA;;AAEA;;AAEA,SAASA,YAAY,QAAQ,gBAAgB;AAC7C,SAASC,oBAAoB,QAAQ,sBAAsB,CAAC,CAAC;AAC7D;;AAEA,OAAO,MAAMC,gBAAgB,CAAC;EAC5B,MAAMC,gBAAgBA,CAACC,IAAI,EAAE;IAC3B,IAAI;MACF;MACA,MAAMC,OAAO,GAAG,MAAML,YAAY,CAACG,gBAAgB,CAACC,IAAI,CAAC;MACzD,IAAIC,OAAO,EAAE;QACX,OAAO,IAAI,CAACC,aAAa,CAACD,OAAO,CAAC;MACpC;;MAEA;MACA,OAAO,IAAI,CAACE,iBAAiB,CAACH,IAAI,CAAC;IACrC,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAChD,OAAO,IAAI,CAACD,iBAAiB,CAACH,IAAI,CAAC;IACrC;EACF;EAEAE,aAAaA,CAACD,OAAO,EAAE;IACrB;IACA,OAAO;MACLD,IAAI,EAAEC,OAAO,CAACD,IAAI;MAClBM,GAAG,EAAEL,OAAO,CAACM,qBAAqB;MAClCC,SAAS,EAAE,IAAI,CAACC,mBAAmB,CAACR,OAAO,CAACO,SAAS,CAAC;MACtDE,cAAc,EAAET,OAAO,CAACU,QAAQ;MAChCC,mBAAmB,EAAEX,OAAO,CAACY;IAC/B,CAAC;EACH;EAEAV,iBAAiBA,CAACH,IAAI,EAAE;IACtB;IACA,OAAO;MACLA,IAAI;MACJM,GAAG,EAAET,oBAAoB,CAACiB,WAAW,CAACd,IAAI,CAAC;MAC3CQ,SAAS,EAAEX,oBAAoB,CAACkB,YAAY,CAACf,IAAI,CAAC;MAClDU,cAAc,EAAEb,oBAAoB,CAACmB,WAAW,CAAChB,IAAI,CAAC;MACtDY,mBAAmB,EAAEf,oBAAoB,CAACoB,sBAAsB,CAACjB,IAAI;IACvE,CAAC;EACH;EAEAS,mBAAmBA,CAACD,SAAS,EAAE;IAC7B;IACA,OAAO,CAAAA,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEU,GAAG,CAACC,KAAK,KAAK;MAC9BC,MAAM,EAAED,KAAK,CAACE,UAAU;MACxBC,KAAK,EAAEH,KAAK,CAACI,SAAS;MACtBC,IAAI,EAAEL,KAAK,CAACM,QAAQ;MACpBC,OAAO,EAAEP,KAAK,CAACQ;IACjB,CAAC,CAAC,CAAC,KAAI,EAAE;EACX;AACF;AAEA,OAAO,MAAMC,gBAAgB,GAAG,IAAI9B,gBAAgB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}