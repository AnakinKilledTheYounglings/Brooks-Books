{"ast":null,"code":"// frontend/src/services/etymologyService.js\n\n// frontend/src/services/etymologyService.js\n\nimport { etymologyAPI } from './etymologyAPI';\nimport { LOCAL_ETYMOLOGY_DATA } from './localEtymologyData'; // We'll create this next\n\nexport class EtymologyService {\n  async getWordEtymology(word) {\n    try {\n      // First try to get data from external API\n      const apiData = await etymologyAPI.getWordEtymology(word);\n      if (apiData) {\n        return this.formatApiData(apiData);\n      }\n\n      // Fall back to local data if API fails or returns no data\n      return this.getLocalEtymology(word);\n    } catch (error) {\n      console.error('Etymology service error:', error);\n      return this.getLocalEtymology(word);\n    }\n  }\n  formatApiData(apiData) {\n    // This will convert external API data to match your expected format\n    return {\n      word: apiData.word,\n      pie: apiData.protoIndoEuropeanRoot,\n      evolution: this.formatEvolutionData(apiData.evolution),\n      modernCognates: apiData.cognates,\n      semanticDevelopment: apiData.meaningDevelopment\n    };\n  }\n  getLocalEtymology(word) {\n    // Your existing local etymology logic\n    return {\n      word,\n      pie: LOCAL_ETYMOLOGY_DATA.findPIERoot(word),\n      evolution: LOCAL_ETYMOLOGY_DATA.getEvolution(word),\n      modernCognates: LOCAL_ETYMOLOGY_DATA.getCognates(word),\n      semanticDevelopment: LOCAL_ETYMOLOGY_DATA.getSemanticDevelopment(word)\n    };\n  }\n  formatEvolutionData(evolution) {\n    // Convert API evolution data to your format\n    return (evolution === null || evolution === void 0 ? void 0 : evolution.map(stage => ({\n      period: stage.timePeriod,\n      years: stage.dateRange,\n      form: stage.wordForm,\n      changes: stage.soundChanges\n    }))) || [];\n  }\n}\nexport const etymologyService = new EtymologyService();\n\n// const PROTO_INDO_EUROPEAN_ROOTS = {\n//   '*bher-': {\n//     meaning: 'to carry, bring',\n//     descendants: {\n//       latin: ['ferre (to bear)', 'fertile', 'transfer'],\n//       greek: ['pherein (to carry)', 'phosphorus (light-bearing)'],\n//       germanic: ['bear', 'birth'],\n//       sanskrit: ['bharati (he carries)']\n//     }\n//   },\n//   '*weid-': {\n//     meaning: 'to see, to know',\n//     descendants: {\n//       latin: ['videre (to see)', 'vision', 'video'],\n//       greek: ['idein (to see)', 'idea'],\n//       germanic: ['wit', 'wise'],\n//       sanskrit: ['veda (knowledge)']\n//     }\n//   },\n//   '*dhē-': {\n//     meaning: 'to set, put, place',\n//     descendants: {\n//       latin: ['facere (to do)', 'fact'],\n//       greek: ['thesis (placing)', 'theme'],\n//       germanic: ['do', 'deed'],\n//       sanskrit: ['dhātu (element)']\n//     }\n//   },\n//   '*leuk-': {\n//     meaning: 'light, brightness',\n//     descendants: {\n//       latin: ['lux (light)', 'lucid', 'illuminate'],\n//       greek: ['leukos (white)', 'lychnos (lamp)'],\n//       germanic: ['light', 'lightning'],\n//       sanskrit: ['roca (bright)']\n//     }\n//   }\n// };\n\n// const LANGUAGE_FAMILIES = {\n//   GERMANIC: {\n//     timeline: [\n//       { period: 'Proto-Germanic', years: '500 BCE-200 CE' },\n//       { period: 'West Germanic', years: '200-500 CE' },\n//       { period: 'Old English', years: '500-1100 CE' },\n//       { period: 'Middle English', years: '1100-1500 CE' },\n//       { period: 'Early Modern English', years: '1500-1800 CE' },\n//       { period: 'Modern English', years: '1800-present' }\n//     ],\n//     soundChanges: {\n//       'Proto-Germanic': 'Grimm\\'s Law consonant shifts',\n//       'West Germanic': 'Loss of word-final -z',\n//       'Old English': 'I-mutation and breaking of vowels',\n//       'Middle English': 'Great Vowel Shift begins',\n//       'Early Modern English': 'Great Vowel Shift completes'\n//     }\n//   },\n//   ROMANCE: {\n//     timeline: [\n//       { period: 'Classical Latin', years: '75 BCE-3rd c. CE' },\n//       { period: 'Vulgar Latin', years: '3rd-8th c. CE' },\n//       { period: 'Old French', years: '842-1400 CE' },\n//       { period: 'Middle French', years: '1400-1600 CE' },\n//       { period: 'Modern French', years: '1600-present' }\n//     ],\n//     soundChanges: {\n//       'Vulgar Latin': 'Loss of final consonants',\n//       'Old French': 'Lenition of intervocalic consonants',\n//       'Middle French': 'Loss of final -e in many words'\n//     }\n//   }\n// };\n\n// const SEMANTIC_DEVELOPMENTS = {\n//   'nice': [\n//     'From Latin nescius \"ignorant\"',\n//     'Old French nice \"silly, simple\"',\n//     'Middle English \"foolish, stupid\"',\n//     'Gradually shifted to \"pleasing, agreeable\"',\n//     'Modern English \"pleasant, kind\"'\n//   ],\n//   'silly': [\n//     'Old English gesælig \"happy, fortunate, blessed\"',\n//     'Middle English \"innocent, harmless, pitiable\"',\n//     'Later \"weak, feeble, frail\"',\n//     'Finally \"foolish, simple, ridiculous\"'\n//   ]\n// };\n\n// const analyzeWord = (word) => {\n//   // Convert word to lowercase for matching\n//   const wordLower = word.toLowerCase();\n\n//   // Try to find PIE root\n//   let pieRoot = null;\n//   for (const [root, info] of Object.entries(PROTO_INDO_EUROPEAN_ROOTS)) {\n//     if (Object.values(info.descendants).flat().some(desc => \n//       desc.toLowerCase().includes(wordLower) ||\n//       wordLower.includes(desc.toLowerCase().split(' ')[0])\n//     )) {\n//       pieRoot = { root, ...info };\n//       break;\n//     }\n//   }\n\n//   // Determine language family and evolution path\n//   let evolution = [];\n//   let modernCognates = {};\n//   let semanticDevelopment = null;\n\n//   // Check for Germanic words\n//   if (isGermanicWord(wordLower)) {\n//     evolution = buildEvolutionPath(wordLower, 'GERMANIC');\n//     modernCognates = getGermanicCognates(wordLower);\n//   } \n//   // Check for Romance words\n//   else if (isRomanceWord(wordLower)) {\n//     evolution = buildEvolutionPath(wordLower, 'ROMANCE');\n//     modernCognates = getRomanceCognates(wordLower);\n//   }\n\n//   // Check for semantic development history\n//   if (SEMANTIC_DEVELOPMENTS[wordLower]) {\n//     semanticDevelopment = SEMANTIC_DEVELOPMENTS[wordLower];\n//   }\n\n//   return {\n//     word,\n//     pie: pieRoot,\n//     evolution,\n//     modernCognates,\n//     semanticDevelopment\n//   };\n// };\n\n// // Helper functions\n// const isGermanicWord = (word) => {\n//   // Basic check for Germanic origin (can be enhanced)\n//   const germanicPatterns = [\n//     'th', 'gh', 'ght', 'ing', 'ness', 'ship', 'hood'\n//   ];\n//   return germanicPatterns.some(pattern => word.includes(pattern));\n// };\n\n// const isRomanceWord = (word) => {\n//   // Basic check for Romance origin (can be enhanced)\n//   const romancePatterns = [\n//     'tion', 'sion', 'ment', 'ance', 'ence', 'ify', 'ous'\n//   ];\n//   return romancePatterns.some(pattern => word.includes(pattern));\n// };\n\n// const buildEvolutionPath = (word, family) => {\n//   const timeline = LANGUAGE_FAMILIES[family].timeline;\n//   const soundChanges = LANGUAGE_FAMILIES[family].soundChanges;\n\n//   return timeline.map(stage => ({\n//     ...stage,\n//     changes: soundChanges[stage.period],\n//     form: getHistoricalForm(word, stage.period, family)\n//   }));\n// };\n\n// const getHistoricalForm = (word, period, family) => {\n//   // This is a simplified example - in a real implementation,\n//   // you would have a database of historical forms\n//   if (family === 'GERMANIC') {\n//     const historicalForms = {\n//       'light': {\n//         'Proto-Germanic': '*leuhtą',\n//         'West Germanic': '*lioht',\n//         'Old English': 'lēoht',\n//         'Middle English': 'light',\n//         'Early Modern English': 'light',\n//         'Modern English': 'light'\n//       }\n//       // Add more words...\n//     };\n//     return historicalForms[word]?.[period] || word;\n//   }\n//   return word; // Fallback\n// };\n\n// const getGermanicCognates = (word) => {\n//   // Example cognates - in a real implementation,\n//   // you would have a comprehensive database\n//   const cognates = {\n//     'light': {\n//       'German': 'Licht',\n//       'Dutch': 'licht',\n//       'Swedish': 'ljus',\n//       'Danish': 'lys'\n//     }\n//     // Add more words...\n//   };\n//   return cognates[word] || {};\n// };\n\n// const getRomanceCognates = (word) => {\n//   // Example cognates\n//   const cognates = {\n//     'nature': {\n//       'French': 'nature',\n//       'Spanish': 'naturaleza',\n//       'Italian': 'natura',\n//       'Portuguese': 'natureza'\n//     }\n//     // Add more words...\n//   };\n//   return cognates[word] || {};\n// };\n\n// export {\n//   analyzeWord,\n//   PROTO_INDO_EUROPEAN_ROOTS,\n//   LANGUAGE_FAMILIES\n// };","map":{"version":3,"names":["etymologyAPI","LOCAL_ETYMOLOGY_DATA","EtymologyService","getWordEtymology","word","apiData","formatApiData","getLocalEtymology","error","console","pie","protoIndoEuropeanRoot","evolution","formatEvolutionData","modernCognates","cognates","semanticDevelopment","meaningDevelopment","findPIERoot","getEvolution","getCognates","getSemanticDevelopment","map","stage","period","timePeriod","years","dateRange","form","wordForm","changes","soundChanges","etymologyService"],"sources":["/Users/BrooksCole/Documents/reading-community/frontend/src/services/etymologyService.js"],"sourcesContent":["// frontend/src/services/etymologyService.js\n\n// frontend/src/services/etymologyService.js\n\nimport { etymologyAPI } from './etymologyAPI';\nimport { LOCAL_ETYMOLOGY_DATA } from './localEtymologyData'; // We'll create this next\n\nexport class EtymologyService {\n  async getWordEtymology(word) {\n    try {\n      // First try to get data from external API\n      const apiData = await etymologyAPI.getWordEtymology(word);\n      if (apiData) {\n        return this.formatApiData(apiData);\n      }\n\n      // Fall back to local data if API fails or returns no data\n      return this.getLocalEtymology(word);\n    } catch (error) {\n      console.error('Etymology service error:', error);\n      return this.getLocalEtymology(word);\n    }\n  }\n\n  formatApiData(apiData) {\n    // This will convert external API data to match your expected format\n    return {\n      word: apiData.word,\n      pie: apiData.protoIndoEuropeanRoot,\n      evolution: this.formatEvolutionData(apiData.evolution),\n      modernCognates: apiData.cognates,\n      semanticDevelopment: apiData.meaningDevelopment\n    };\n  }\n\n  getLocalEtymology(word) {\n    // Your existing local etymology logic\n    return {\n      word,\n      pie: LOCAL_ETYMOLOGY_DATA.findPIERoot(word),\n      evolution: LOCAL_ETYMOLOGY_DATA.getEvolution(word),\n      modernCognates: LOCAL_ETYMOLOGY_DATA.getCognates(word),\n      semanticDevelopment: LOCAL_ETYMOLOGY_DATA.getSemanticDevelopment(word)\n    };\n  }\n\n  formatEvolutionData(evolution) {\n    // Convert API evolution data to your format\n    return evolution?.map(stage => ({\n      period: stage.timePeriod,\n      years: stage.dateRange,\n      form: stage.wordForm,\n      changes: stage.soundChanges\n    })) || [];\n  }\n}\n\nexport const etymologyService = new EtymologyService();\n\n\n\n// const PROTO_INDO_EUROPEAN_ROOTS = {\n//   '*bher-': {\n//     meaning: 'to carry, bring',\n//     descendants: {\n//       latin: ['ferre (to bear)', 'fertile', 'transfer'],\n//       greek: ['pherein (to carry)', 'phosphorus (light-bearing)'],\n//       germanic: ['bear', 'birth'],\n//       sanskrit: ['bharati (he carries)']\n//     }\n//   },\n//   '*weid-': {\n//     meaning: 'to see, to know',\n//     descendants: {\n//       latin: ['videre (to see)', 'vision', 'video'],\n//       greek: ['idein (to see)', 'idea'],\n//       germanic: ['wit', 'wise'],\n//       sanskrit: ['veda (knowledge)']\n//     }\n//   },\n//   '*dhē-': {\n//     meaning: 'to set, put, place',\n//     descendants: {\n//       latin: ['facere (to do)', 'fact'],\n//       greek: ['thesis (placing)', 'theme'],\n//       germanic: ['do', 'deed'],\n//       sanskrit: ['dhātu (element)']\n//     }\n//   },\n//   '*leuk-': {\n//     meaning: 'light, brightness',\n//     descendants: {\n//       latin: ['lux (light)', 'lucid', 'illuminate'],\n//       greek: ['leukos (white)', 'lychnos (lamp)'],\n//       germanic: ['light', 'lightning'],\n//       sanskrit: ['roca (bright)']\n//     }\n//   }\n// };\n\n// const LANGUAGE_FAMILIES = {\n//   GERMANIC: {\n//     timeline: [\n//       { period: 'Proto-Germanic', years: '500 BCE-200 CE' },\n//       { period: 'West Germanic', years: '200-500 CE' },\n//       { period: 'Old English', years: '500-1100 CE' },\n//       { period: 'Middle English', years: '1100-1500 CE' },\n//       { period: 'Early Modern English', years: '1500-1800 CE' },\n//       { period: 'Modern English', years: '1800-present' }\n//     ],\n//     soundChanges: {\n//       'Proto-Germanic': 'Grimm\\'s Law consonant shifts',\n//       'West Germanic': 'Loss of word-final -z',\n//       'Old English': 'I-mutation and breaking of vowels',\n//       'Middle English': 'Great Vowel Shift begins',\n//       'Early Modern English': 'Great Vowel Shift completes'\n//     }\n//   },\n//   ROMANCE: {\n//     timeline: [\n//       { period: 'Classical Latin', years: '75 BCE-3rd c. CE' },\n//       { period: 'Vulgar Latin', years: '3rd-8th c. CE' },\n//       { period: 'Old French', years: '842-1400 CE' },\n//       { period: 'Middle French', years: '1400-1600 CE' },\n//       { period: 'Modern French', years: '1600-present' }\n//     ],\n//     soundChanges: {\n//       'Vulgar Latin': 'Loss of final consonants',\n//       'Old French': 'Lenition of intervocalic consonants',\n//       'Middle French': 'Loss of final -e in many words'\n//     }\n//   }\n// };\n\n// const SEMANTIC_DEVELOPMENTS = {\n//   'nice': [\n//     'From Latin nescius \"ignorant\"',\n//     'Old French nice \"silly, simple\"',\n//     'Middle English \"foolish, stupid\"',\n//     'Gradually shifted to \"pleasing, agreeable\"',\n//     'Modern English \"pleasant, kind\"'\n//   ],\n//   'silly': [\n//     'Old English gesælig \"happy, fortunate, blessed\"',\n//     'Middle English \"innocent, harmless, pitiable\"',\n//     'Later \"weak, feeble, frail\"',\n//     'Finally \"foolish, simple, ridiculous\"'\n//   ]\n// };\n\n// const analyzeWord = (word) => {\n//   // Convert word to lowercase for matching\n//   const wordLower = word.toLowerCase();\n  \n//   // Try to find PIE root\n//   let pieRoot = null;\n//   for (const [root, info] of Object.entries(PROTO_INDO_EUROPEAN_ROOTS)) {\n//     if (Object.values(info.descendants).flat().some(desc => \n//       desc.toLowerCase().includes(wordLower) ||\n//       wordLower.includes(desc.toLowerCase().split(' ')[0])\n//     )) {\n//       pieRoot = { root, ...info };\n//       break;\n//     }\n//   }\n\n//   // Determine language family and evolution path\n//   let evolution = [];\n//   let modernCognates = {};\n//   let semanticDevelopment = null;\n\n//   // Check for Germanic words\n//   if (isGermanicWord(wordLower)) {\n//     evolution = buildEvolutionPath(wordLower, 'GERMANIC');\n//     modernCognates = getGermanicCognates(wordLower);\n//   } \n//   // Check for Romance words\n//   else if (isRomanceWord(wordLower)) {\n//     evolution = buildEvolutionPath(wordLower, 'ROMANCE');\n//     modernCognates = getRomanceCognates(wordLower);\n//   }\n\n//   // Check for semantic development history\n//   if (SEMANTIC_DEVELOPMENTS[wordLower]) {\n//     semanticDevelopment = SEMANTIC_DEVELOPMENTS[wordLower];\n//   }\n\n//   return {\n//     word,\n//     pie: pieRoot,\n//     evolution,\n//     modernCognates,\n//     semanticDevelopment\n//   };\n// };\n\n// // Helper functions\n// const isGermanicWord = (word) => {\n//   // Basic check for Germanic origin (can be enhanced)\n//   const germanicPatterns = [\n//     'th', 'gh', 'ght', 'ing', 'ness', 'ship', 'hood'\n//   ];\n//   return germanicPatterns.some(pattern => word.includes(pattern));\n// };\n\n// const isRomanceWord = (word) => {\n//   // Basic check for Romance origin (can be enhanced)\n//   const romancePatterns = [\n//     'tion', 'sion', 'ment', 'ance', 'ence', 'ify', 'ous'\n//   ];\n//   return romancePatterns.some(pattern => word.includes(pattern));\n// };\n\n// const buildEvolutionPath = (word, family) => {\n//   const timeline = LANGUAGE_FAMILIES[family].timeline;\n//   const soundChanges = LANGUAGE_FAMILIES[family].soundChanges;\n  \n//   return timeline.map(stage => ({\n//     ...stage,\n//     changes: soundChanges[stage.period],\n//     form: getHistoricalForm(word, stage.period, family)\n//   }));\n// };\n\n// const getHistoricalForm = (word, period, family) => {\n//   // This is a simplified example - in a real implementation,\n//   // you would have a database of historical forms\n//   if (family === 'GERMANIC') {\n//     const historicalForms = {\n//       'light': {\n//         'Proto-Germanic': '*leuhtą',\n//         'West Germanic': '*lioht',\n//         'Old English': 'lēoht',\n//         'Middle English': 'light',\n//         'Early Modern English': 'light',\n//         'Modern English': 'light'\n//       }\n//       // Add more words...\n//     };\n//     return historicalForms[word]?.[period] || word;\n//   }\n//   return word; // Fallback\n// };\n\n// const getGermanicCognates = (word) => {\n//   // Example cognates - in a real implementation,\n//   // you would have a comprehensive database\n//   const cognates = {\n//     'light': {\n//       'German': 'Licht',\n//       'Dutch': 'licht',\n//       'Swedish': 'ljus',\n//       'Danish': 'lys'\n//     }\n//     // Add more words...\n//   };\n//   return cognates[word] || {};\n// };\n\n// const getRomanceCognates = (word) => {\n//   // Example cognates\n//   const cognates = {\n//     'nature': {\n//       'French': 'nature',\n//       'Spanish': 'naturaleza',\n//       'Italian': 'natura',\n//       'Portuguese': 'natureza'\n//     }\n//     // Add more words...\n//   };\n//   return cognates[word] || {};\n// };\n\n// export {\n//   analyzeWord,\n//   PROTO_INDO_EUROPEAN_ROOTS,\n//   LANGUAGE_FAMILIES\n// };"],"mappings":"AAAA;;AAEA;;AAEA,SAASA,YAAY,QAAQ,gBAAgB;AAC7C,SAASC,oBAAoB,QAAQ,sBAAsB,CAAC,CAAC;;AAE7D,OAAO,MAAMC,gBAAgB,CAAC;EAC5B,MAAMC,gBAAgBA,CAACC,IAAI,EAAE;IAC3B,IAAI;MACF;MACA,MAAMC,OAAO,GAAG,MAAML,YAAY,CAACG,gBAAgB,CAACC,IAAI,CAAC;MACzD,IAAIC,OAAO,EAAE;QACX,OAAO,IAAI,CAACC,aAAa,CAACD,OAAO,CAAC;MACpC;;MAEA;MACA,OAAO,IAAI,CAACE,iBAAiB,CAACH,IAAI,CAAC;IACrC,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAChD,OAAO,IAAI,CAACD,iBAAiB,CAACH,IAAI,CAAC;IACrC;EACF;EAEAE,aAAaA,CAACD,OAAO,EAAE;IACrB;IACA,OAAO;MACLD,IAAI,EAAEC,OAAO,CAACD,IAAI;MAClBM,GAAG,EAAEL,OAAO,CAACM,qBAAqB;MAClCC,SAAS,EAAE,IAAI,CAACC,mBAAmB,CAACR,OAAO,CAACO,SAAS,CAAC;MACtDE,cAAc,EAAET,OAAO,CAACU,QAAQ;MAChCC,mBAAmB,EAAEX,OAAO,CAACY;IAC/B,CAAC;EACH;EAEAV,iBAAiBA,CAACH,IAAI,EAAE;IACtB;IACA,OAAO;MACLA,IAAI;MACJM,GAAG,EAAET,oBAAoB,CAACiB,WAAW,CAACd,IAAI,CAAC;MAC3CQ,SAAS,EAAEX,oBAAoB,CAACkB,YAAY,CAACf,IAAI,CAAC;MAClDU,cAAc,EAAEb,oBAAoB,CAACmB,WAAW,CAAChB,IAAI,CAAC;MACtDY,mBAAmB,EAAEf,oBAAoB,CAACoB,sBAAsB,CAACjB,IAAI;IACvE,CAAC;EACH;EAEAS,mBAAmBA,CAACD,SAAS,EAAE;IAC7B;IACA,OAAO,CAAAA,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEU,GAAG,CAACC,KAAK,KAAK;MAC9BC,MAAM,EAAED,KAAK,CAACE,UAAU;MACxBC,KAAK,EAAEH,KAAK,CAACI,SAAS;MACtBC,IAAI,EAAEL,KAAK,CAACM,QAAQ;MACpBC,OAAO,EAAEP,KAAK,CAACQ;IACjB,CAAC,CAAC,CAAC,KAAI,EAAE;EACX;AACF;AAEA,OAAO,MAAMC,gBAAgB,GAAG,IAAI9B,gBAAgB,CAAC,CAAC;;AAItD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}