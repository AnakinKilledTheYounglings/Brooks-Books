{"ast":null,"code":"// frontend/src/services/etymologyService.js\n// frontend/src/services/etymologyService.js\nimport{etymologyAPI}from'./etymologyAPI';import{LOCAL_ETYMOLOGY_DATA}from'./localEtymologyData';// We'll create this next\n//import {analyzeWord} from './etymologyService.js'\nexport class EtymologyService{async getWordEtymology(word){try{// First try to get data from external API\nconst apiData=await etymologyAPI.getWordEtymology(word);if(apiData){return this.formatApiData(apiData);}// Fall back to local data if API fails or returns no data\nreturn this.getLocalEtymology(word);}catch(error){console.error('Etymology service error:',error);return this.getLocalEtymology(word);}}formatApiData(apiData){// This will convert external API data to match your expected format\nreturn{word:apiData.word,pie:apiData.protoIndoEuropeanRoot,evolution:this.formatEvolutionData(apiData.evolution),modernCognates:apiData.cognates,semanticDevelopment:apiData.meaningDevelopment};}getLocalEtymology(word){// Your existing local etymology logic\nreturn{word,pie:LOCAL_ETYMOLOGY_DATA.findPIERoot(word),evolution:LOCAL_ETYMOLOGY_DATA.getEvolution(word),modernCognates:LOCAL_ETYMOLOGY_DATA.getCognates(word),semanticDevelopment:LOCAL_ETYMOLOGY_DATA.getSemanticDevelopment(word)};}formatEvolutionData(evolution){// Convert API evolution data to your format\nreturn(evolution===null||evolution===void 0?void 0:evolution.map(stage=>({period:stage.timePeriod,years:stage.dateRange,form:stage.wordForm,changes:stage.soundChanges})))||[];}}export const etymologyService=new EtymologyService();","map":{"version":3,"names":["etymologyAPI","LOCAL_ETYMOLOGY_DATA","EtymologyService","getWordEtymology","word","apiData","formatApiData","getLocalEtymology","error","console","pie","protoIndoEuropeanRoot","evolution","formatEvolutionData","modernCognates","cognates","semanticDevelopment","meaningDevelopment","findPIERoot","getEvolution","getCognates","getSemanticDevelopment","map","stage","period","timePeriod","years","dateRange","form","wordForm","changes","soundChanges","etymologyService"],"sources":["/Users/BrooksCole/Documents/reading-community/frontend/src/services/etymologyService.js"],"sourcesContent":["// frontend/src/services/etymologyService.js\n\n// frontend/src/services/etymologyService.js\n\nimport { etymologyAPI } from './etymologyAPI';\nimport { LOCAL_ETYMOLOGY_DATA } from './localEtymologyData'; // We'll create this next\n//import {analyzeWord} from './etymologyService.js'\n\nexport class EtymologyService {\n  async getWordEtymology(word) {\n    try {\n      // First try to get data from external API\n      const apiData = await etymologyAPI.getWordEtymology(word);\n      if (apiData) {\n        return this.formatApiData(apiData);\n      }\n\n      // Fall back to local data if API fails or returns no data\n      return this.getLocalEtymology(word);\n    } catch (error) {\n      console.error('Etymology service error:', error);\n      return this.getLocalEtymology(word);\n    }\n  }\n\n  formatApiData(apiData) {\n    // This will convert external API data to match your expected format\n    return {\n      word: apiData.word,\n      pie: apiData.protoIndoEuropeanRoot,\n      evolution: this.formatEvolutionData(apiData.evolution),\n      modernCognates: apiData.cognates,\n      semanticDevelopment: apiData.meaningDevelopment\n    };\n  }\n\n  getLocalEtymology(word) {\n    // Your existing local etymology logic\n    return {\n      word,\n      pie: LOCAL_ETYMOLOGY_DATA.findPIERoot(word),\n      evolution: LOCAL_ETYMOLOGY_DATA.getEvolution(word),\n      modernCognates: LOCAL_ETYMOLOGY_DATA.getCognates(word),\n      semanticDevelopment: LOCAL_ETYMOLOGY_DATA.getSemanticDevelopment(word)\n    };\n  }\n\n  formatEvolutionData(evolution) {\n    // Convert API evolution data to your format\n    return evolution?.map(stage => ({\n      period: stage.timePeriod,\n      years: stage.dateRange,\n      form: stage.wordForm,\n      changes: stage.soundChanges\n    })) || [];\n  }\n}\n\nexport const etymologyService = new EtymologyService();\n\n"],"mappings":"AAAA;AAEA;AAEA,OAASA,YAAY,KAAQ,gBAAgB,CAC7C,OAASC,oBAAoB,KAAQ,sBAAsB,CAAE;AAC7D;AAEA,MAAO,MAAM,CAAAC,gBAAiB,CAC5B,KAAM,CAAAC,gBAAgBA,CAACC,IAAI,CAAE,CAC3B,GAAI,CACF;AACA,KAAM,CAAAC,OAAO,CAAG,KAAM,CAAAL,YAAY,CAACG,gBAAgB,CAACC,IAAI,CAAC,CACzD,GAAIC,OAAO,CAAE,CACX,MAAO,KAAI,CAACC,aAAa,CAACD,OAAO,CAAC,CACpC,CAEA;AACA,MAAO,KAAI,CAACE,iBAAiB,CAACH,IAAI,CAAC,CACrC,CAAE,MAAOI,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,0BAA0B,CAAEA,KAAK,CAAC,CAChD,MAAO,KAAI,CAACD,iBAAiB,CAACH,IAAI,CAAC,CACrC,CACF,CAEAE,aAAaA,CAACD,OAAO,CAAE,CACrB;AACA,MAAO,CACLD,IAAI,CAAEC,OAAO,CAACD,IAAI,CAClBM,GAAG,CAAEL,OAAO,CAACM,qBAAqB,CAClCC,SAAS,CAAE,IAAI,CAACC,mBAAmB,CAACR,OAAO,CAACO,SAAS,CAAC,CACtDE,cAAc,CAAET,OAAO,CAACU,QAAQ,CAChCC,mBAAmB,CAAEX,OAAO,CAACY,kBAC/B,CAAC,CACH,CAEAV,iBAAiBA,CAACH,IAAI,CAAE,CACtB;AACA,MAAO,CACLA,IAAI,CACJM,GAAG,CAAET,oBAAoB,CAACiB,WAAW,CAACd,IAAI,CAAC,CAC3CQ,SAAS,CAAEX,oBAAoB,CAACkB,YAAY,CAACf,IAAI,CAAC,CAClDU,cAAc,CAAEb,oBAAoB,CAACmB,WAAW,CAAChB,IAAI,CAAC,CACtDY,mBAAmB,CAAEf,oBAAoB,CAACoB,sBAAsB,CAACjB,IAAI,CACvE,CAAC,CACH,CAEAS,mBAAmBA,CAACD,SAAS,CAAE,CAC7B;AACA,MAAO,CAAAA,SAAS,SAATA,SAAS,iBAATA,SAAS,CAAEU,GAAG,CAACC,KAAK,GAAK,CAC9BC,MAAM,CAAED,KAAK,CAACE,UAAU,CACxBC,KAAK,CAAEH,KAAK,CAACI,SAAS,CACtBC,IAAI,CAAEL,KAAK,CAACM,QAAQ,CACpBC,OAAO,CAAEP,KAAK,CAACQ,YACjB,CAAC,CAAC,CAAC,GAAI,EAAE,CACX,CACF,CAEA,MAAO,MAAM,CAAAC,gBAAgB,CAAG,GAAI,CAAA9B,gBAAgB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}